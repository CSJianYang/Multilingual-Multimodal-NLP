[
    {
        "title": "Sum of Subsequence Widths",
        "question_content": "The width of a sequence is the difference between the maximum and minimum elements in the sequence.\nGiven an array of integers nums, return the sum of the widths of all the non-empty subsequences of nums. Since the answer may be very large, return it modulo 109 + 7.\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n&nbsp;\nExample 1:\n\nInput: nums = [2,1,3]\nOutput: 6\nExplanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].\nThe corresponding widths are 0, 0, 0, 1, 1, 2, 2.\nThe sum of these widths is 6.\n\nExample 2:\n\nInput: nums = [2]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 161267,
                "title": "java-c-python-sort-and-one-pass",
                "content": "# **Explanation**\\nThe order in initial arrays doesn\\'t matter,\\nmy first intuition is to sort the array.\\n\\nFor each number `A[i]`:\\n\\n1. There are `i` smaller numbers,\\nso there are `2 ^ i` sequences in which `A[i]` is maximum.\\nwe should do `res += A[i] * 2^i`\\n\\n2. There are `n - i - 1` bigger numbers,\\nso there are `2 ^ (n - i - 1)` sequences in which `A[i]` is minimum.\\nwe should do `res -= A[i] * 2^(n - i - 1)`\\n\\nDone.\\n<br>\\n\\n# **Time Complexity**:\\nTime `O(NlogN)`\\nSpace `O(1)`\\n<br>\\n\\n\\n# **FAQ**\\n**Q. why do we plus mod before return?**\\n**A** In Cpp and Java, mod on negative number will still get a negative number.\\n<br>\\n\\n**Java:**\\n```java\\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n```\\n**C++:**\\n```cpp\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n```\\n**1-line Python:**\\n```py\\n    def sumSubseqWidths(self, A):\\n        return sum(((1 << i) - (1 << len(A) - i - 1)) * a for i, a in enumerate(sorted(A))) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n```\n```cpp\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n```\n```py\\n    def sumSubseqWidths(self, A):\\n        return sum(((1 << i) - (1 << len(A) - i - 1)) * a for i, a in enumerate(sorted(A))) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161263,
                "title": "c-solution-o-n-log-n-sort-o-n-calculate",
                "content": "We only care about the subsequences and max/min values, so the order of the elements does not matter. Therefore, we sort the array at first.\\n\\nFor a sorted subarray A=[p,......,q], there are 2^(len(A)-2) subsequences which has min value=p, and max value=q. Because we can choose any numbers between p and q, there are 2^(len(A)-2) ways to choose.\\n\\nFor example, a given array is `[0,1,3,4,7]`.\\nFor the subarray `[1,3,4,7]`, there are 2^2 subsequences which has min value=1 and max value=7.\\n\\nThen we got an O(N^2) solution:\\nthe answer is `sum((max(Ai)-min(Ai))\\xD72^(len(Ai)-2))`, for all subarrays `Ai` where `len(Ai) > 1`.  \\nFor the example above, it is:\\n\\n```\\n1*2^0+3*2^1+4*2^2+7*2^3       // = x0\\n     +2*2^0+3*2^1+6*2^2       // = x1\\n           +1*2^0+4*2^1       // = x2\\n                 +3*2^0       // = x3\\n```\\n\\n***\\nOf course the efficiency is not enough. Observe the table above\\u2191, we can find that\\n\\n```\\nx0-1*(2^0+2^1+2^2+2^3)=x1*2\\nx1-2*(2^0+2^1+2^2)=x2*2\\nx2-1*(2^0+2^1)=x3*2\\nx3-3*(2^0)=0\\n```\\n\\nwe can then calculate x3, x2, x1, x0 one by one: \\n\\n```\\nx4=0;\\nx3=x4*2 + (A4-A3)*(2^0)\\nx2=x3*2 + (A3-A2)*(2^0+2^1)\\nx1=x2*2 + (A2-A1)*(2^0+2^1+2^2)\\nx0=x1*2 + (A1-A0)*(2^0+2^1+2^2+2^3)\\n\\nresult=x4+x3+x2+x1+x0\\n```\\n\\nHere is my code:\\n\\n```cpp\\n#define M 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        vector<ll> diff;\\n        for (int i = 0; i < A.size() - 1; i++) diff.push_back(A[i + 1] - A[i]);\\n        ll result = 0;\\n        ll x = 0;\\n        ll sum2 = 1;\\n        int len = diff.size();\\n        reverse(diff.begin(), diff.end());\\n        for (int i = 0; i < len; i++) {\\n            x <<= 1;\\n            x += sum2 * diff[i];\\n            x %= M;\\n            sum2 <<= 1;\\n            sum2++;\\n            sum2 %= M;\\n            result += x;\\n            result %= M;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1*2^0+3*2^1+4*2^2+7*2^3       // = x0\\n     +2*2^0+3*2^1+6*2^2       // = x1\\n           +1*2^0+4*2^1       // = x2\\n                 +3*2^0       // = x3\\n```\n```\\nx0-1*(2^0+2^1+2^2+2^3)=x1*2\\nx1-2*(2^0+2^1+2^2)=x2*2\\nx2-1*(2^0+2^1)=x3*2\\nx3-3*(2^0)=0\\n```\n```\\nx4=0;\\nx3=x4*2 + (A4-A3)*(2^0)\\nx2=x3*2 + (A3-A2)*(2^0+2^1)\\nx1=x2*2 + (A2-A1)*(2^0+2^1+2^2)\\nx0=x1*2 + (A1-A0)*(2^0+2^1+2^2+2^3)\\n\\nresult=x4+x3+x2+x1+x0\\n```\n```cpp\\n#define M 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        vector<ll> diff;\\n        for (int i = 0; i < A.size() - 1; i++) diff.push_back(A[i + 1] - A[i]);\\n        ll result = 0;\\n        ll x = 0;\\n        ll sum2 = 1;\\n        int len = diff.size();\\n        reverse(diff.begin(), diff.end());\\n        for (int i = 0; i < len; i++) {\\n            x <<= 1;\\n            x += sum2 * diff[i];\\n            x %= M;\\n            sum2 <<= 1;\\n            sum2++;\\n            sum2 %= M;\\n            result += x;\\n            result %= M;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456511,
                "title": "c-o-nlogn-approach-sum-of-subsequence-widths",
                "content": "**Logic -**\\n**Observations 1**: Order doesn\\'t matter \\n**Observations 2**: Every numbers contribute based on its index in the sorted array.\\n\\n**Mathematical Derivations -**\\nConsider that there are total (n) number in a sorted array, then (i) numbers will be <= nums[i] and (n-i-1) numbers will be >= A[i]\\n\\nA[i] will be upper bound of (2^i) subsequences         <-------- when A[i] as maxm value\\nA[i] will be lower bound of (2^(n-i-1)) subsequences <-------- when A[i] as minm value\\n\\n```\\nso, contribution of A[i] = upper - lower = A[i]*(2^i) - A[i]*(2^(n-i-1))\\n                                          \\nAns  = Sum{A[i]* 2^i - A[i] * 2^(n-i-1)}  , for 0 <= i < n \\n     = (A[0]*2^0 - A[0]*2^(n-1) + (A[1]*2^1 - A[1]*2^(n-2) + ... \\n       + (A[i]*2^i - A[i]*2^(n-i-1) + ...  + (A[n-i-1]*2^(n-i-1) - A[n-i-1]*2^i + ... + (A[n-1] * 2^(n-1) - A[n-1]*2^0)\\n        \\n\\t\\t//some of the terms in above expression will cancel each other,\\n\\t\\t\\nAns = Sum{A[i] * 2^i - A[n-i-1]* 2^i} ..........on taking 2^(i) common, the sum can be re-written as \\n     =Sum{ (A[i] - A[n-i-1]) * 2^(i)  }\\n\\n```\\n\\n**Now,**\\n**Step 1 :** Sort the array first,\\n**Step 2 :** Once array is sorted, Calculate the result by summation of above derived results.\\n\\n```\\nint sumSubseqWidths(vector<int>& nums) {\\n\\n    int n = nums.size();\\n    int ans = 0; \\n\\n    // sort the array\\n    sort(nums.begin(),nums.end());                        // O(nlogn)\\n\\n    // create the vector to store power terms\\n    vector<long> exp(n, 0);\\n    exp[0] = 1;\\n\\n    // Pre-Calculate the value of exp for each (i) so need not to do again. \\n\\t// Note- Divide by mod to keep the answer in range. \\n    for (int i = 1; i < n; i++) {\\n        exp[i] = exp[i - 1] * 2 % mod;\\n    }\\n\\n    // Iterate the array and calculate the sum using above mathematical expression\\n    for(int i=0;i<n;i++){\\n        ans = ( ans + exp[i]*(nums[i] - nums[n-i-1])) %mod;\\n    }    \\n    return ans; \\n}\\n\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nso, contribution of A[i] = upper - lower = A[i]*(2^i) - A[i]*(2^(n-i-1))\\n                                          \\nAns  = Sum{A[i]* 2^i - A[i] * 2^(n-i-1)}  , for 0 <= i < n \\n     = (A[0]*2^0 - A[0]*2^(n-1) + (A[1]*2^1 - A[1]*2^(n-2) + ... \\n       + (A[i]*2^i - A[i]*2^(n-i-1) + ...  + (A[n-i-1]*2^(n-i-1) - A[n-i-1]*2^i + ... + (A[n-1] * 2^(n-1) - A[n-1]*2^0)\\n        \\n\\t\\t//some of the terms in above expression will cancel each other,\\n\\t\\t\\nAns = Sum{A[i] * 2^i - A[n-i-1]* 2^i} ..........on taking 2^(i) common, the sum can be re-written as \\n     =Sum{ (A[i] - A[n-i-1]) * 2^(i)  }\\n\\n```\n```\\nint sumSubseqWidths(vector<int>& nums) {\\n\\n    int n = nums.size();\\n    int ans = 0; \\n\\n    // sort the array\\n    sort(nums.begin(),nums.end());                        // O(nlogn)\\n\\n    // create the vector to store power terms\\n    vector<long> exp(n, 0);\\n    exp[0] = 1;\\n\\n    // Pre-Calculate the value of exp for each (i) so need not to do again. \\n\\t// Note- Divide by mod to keep the answer in range. \\n    for (int i = 1; i < n; i++) {\\n        exp[i] = exp[i - 1] * 2 % mod;\\n    }\\n\\n    // Iterate the array and calculate the sum using above mathematical expression\\n    for(int i=0;i<n;i++){\\n        ans = ( ans + exp[i]*(nums[i] - nums[n-i-1])) %mod;\\n    }    \\n    return ans; \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2361648,
                "title": "c-sum-of-subsequence-widths",
                "content": "After solving this ques, go for this ques https://www.codechef.com/problems/DECOSUB \\n\\nThe approach to the solution can be started by observing max and min(max-min) value of all subsequence and then go for simple maths as shown below:\\n\\n![image](https://assets.leetcode.com/users/images/237be303-4f7e-4146-8a64-a6d2c7c504d2_1659301276.4129994.jpeg)\\n\\nHere is my code for the approach.....\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& a) {\\n        \\n        int n=a.size(),i,j=n-1;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        long long int p=1;\\n        \\n        long long int ans=0;\\n        \\n        long long int mod=1000000007;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            ans=(ans+p*a[i]-p*a[j])%mod;\\n            \\n            p=(p*2)%mod;\\n            \\n            j--;\\n        }\\n        return (int)ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& a) {\\n        \\n        int n=a.size(),i,j=n-1;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        long long int p=1;\\n        \\n        long long int ans=0;\\n        \\n        long long int mod=1000000007;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            ans=(ans+p*a[i]-p*a[j])%mod;\\n            \\n            p=(p*2)%mod;\\n            \\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 162318,
                "title": "o-nlogn-solution",
                "content": "Sort the array cost <code>O(nlogn)</code>;\\nThe number of subset that fixed <code>A[i]</code> as minimum element and <code>A[j]</code> as maximum element (<code>i<j</code>) is <code>2^{j-i-1}</code>:\\n\\n1. when <code>j-i=1</code>, we can get <code>T_{1}=(A[2]-A[1])*2^{0} + (A[3]-A[2])*2^{0} + ...+(A[n]-A[n-1])*2^{0} = (A[n]-A[1])*2^{0}</code>\\n2. when <code>j-i=2</code>, we can get <code>T_{2}=(A[3]-A[1])*2^{1} + (A[4]-A[2])*2^{1} + ...+(A[n]-A[n-2])*2^{1} = (A[n]+A[n-1]-A[2]-A[1])*2^{1}</code>\\n3. when <code>j-i=3</code>, we can get <code>T_{3}=(A[4]-A[1])*2^{2} + (A[5]-A[2])*2^{2} + ...+(A[n]-A[n-3])*2^{2} = (A[n]+A[n-1]+A[n-2]-A[3]-A[2]-A[1])*2^{2}</code>\\n4. when <code>j-i=k</code>, we can get <code>T_{k}=(sum[n-k+1][n] - sum[1][k])*2^{k-1}</code>\\n5. Finally, <code>ans=T_{1}+T_{2}+...+T_{k}</code>\\n\\nIn my code, <code>lsum</code> referred to <code>sum[1][k]</code>, <code>rsum</code> referred to <code>sum[n-k+1][n]</code>, and <code>d</code> referred to <code>2^{k-1}</code>\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int l = 0, r = A.size()-1;\\n        int lsum = 0, rsum = 0;\\n        long long d = 1, ans = 0, mod = 1000000007;\\n        while(l < A.size()){\\n            lsum += A[l++];\\n            rsum += A[r--];\\n            ans += (rsum-lsum)*d;\\n            ans %= mod;\\n            d = d * 2 % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int l = 0, r = A.size()-1;\\n        int lsum = 0, rsum = 0;\\n        long long d = 1, ans = 0, mod = 1000000007;\\n        while(l < A.size()){\\n            lsum += A[l++];\\n            rsum += A[r--];\\n            ans += (rsum-lsum)*d;\\n            ans %= mod;\\n            d = d * 2 % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161327,
                "title": "leetcode-weekly-contest-98-screencast",
                "content": "https://www.youtube.com/watch?v=KpPDMI02LVQ\\n\\nDid a really bad job this time. One out-of-boundary issue bite me and I was thinking there must be some LC bug all the time until I stopped screencast.",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=KpPDMI02LVQ\\n\\nDid a really bad job this time. One out-of-boundary issue bite me and I was thinking there must be some LC bug all the time until I stopped screencast.",
                "codeTag": "Unknown"
            },
            {
                "id": 881805,
                "title": "c-simple-sol-with-comments-beats-88",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        long power = 1, res = 0, mod = 1e9+7,n = arr.size();\\n        \\n        //adding maximums\\n        //number of times this item will be maximum\\n        for(int i=0;i<n;i++){\\n            res = (res + arr[i]*power)%mod;\\n            power = (power*2)%mod;\\n        }\\n        \\n        //subtracting minimums\\n        //number of times this item will be minimum\\n        power = 1;\\n        for(int i=n-1;i>=0;i--){\\n            res = (res - arr[i]*power +mod)%mod;\\n            power = (power*2)%mod;\\n        }\\n        return (res+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        long power = 1, res = 0, mod = 1e9+7,n = arr.size();\\n        \\n        //adding maximums\\n        //number of times this item will be maximum\\n        for(int i=0;i<n;i++){\\n            res = (res + arr[i]*power)%mod;\\n            power = (power*2)%mod;\\n        }\\n        \\n        //subtracting minimums\\n        //number of times this item will be minimum\\n        power = 1;\\n        for(int i=n-1;i>=0;i--){\\n            res = (res - arr[i]*power +mod)%mod;\\n            power = (power*2)%mod;\\n        }\\n        return (res+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161318,
                "title": "pythonic-o-nlogn-sorting",
                "content": "First, the brute force solution is to check every index `(i, j)` pair. The total number of of subsequence with `i` the smallest and `j` the largest value is `2^(j-i-1)`. Time complexity is `O(n^2)`, which gets TLE.\\n```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res=0\\n        A.sort()\\n        for i in range(len(A)):\\n            for j in range(i+1, len(A)):\\n                res+=2**(j-i-1)*(A[j]-A[i])\\n                res%=10**9+7\\n        return res\\n```\\nThen to optimize, we find that for the same difference of index `i`, `j` (say `k=j-i`), their sum would be:\\n`2^(k-1)*(A[k]-A[0]+A[k+1]-A[1]+A[k+2]-A[2]+....+A[len(A)-1]-A[len(A)-1-k])=2^(k-1)*(sum of last k numbers in A - sum of first k numbers in A)`\\nWe can use a `preSum` and a `postSum` array to calculate the difference above. Building both arrays take O(n), final counting part is also O(n), sorting is O(nlogn), total would be O(nlogn).\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        l=len(A)\\n        preSum, postSum=[A[0]]*l, [A[-1]]*l\\n        for i in range(1, l):\\n            preSum[i]=preSum[i-1]+A[i]\\n            postSum[i]=postSum[i-1]+A[l-1-i]\\n        s=0\\n        for i in range(len(A)-1):\\n            s+=(1<<i)*(postSum[i]-preSum[i])\\n            s%=10**9+7\\n        return s\\n```\\nA more pythonic solution to add to the result only one pass:\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        res=0\\n        for i in range(len(A)):\\n            res*=2\\n            res-=A[i]\\n            res+=A[~i]\\n            res%=10**9+7\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res=0\\n        A.sort()\\n        for i in range(len(A)):\\n            for j in range(i+1, len(A)):\\n                res+=2**(j-i-1)*(A[j]-A[i])\\n                res%=10**9+7\\n        return res\\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        l=len(A)\\n        preSum, postSum=[A[0]]*l, [A[-1]]*l\\n        for i in range(1, l):\\n            preSum[i]=preSum[i-1]+A[i]\\n            postSum[i]=postSum[i-1]+A[l-1-i]\\n        s=0\\n        for i in range(len(A)-1):\\n            s+=(1<<i)*(postSum[i]-preSum[i])\\n            s%=10**9+7\\n        return s\\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        res=0\\n        for i in range(len(A)):\\n            res*=2\\n            res-=A[i]\\n            res+=A[~i]\\n            res%=10**9+7\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768402,
                "title": "python3-sort-and-1-pass-derived-from-dp-solution",
                "content": "I\\'m pretty happy to have found the solution to that one alone, so I would like to share here my line of thinking.\\n\\nFirst things first, we notice that we can sort the array without changing the problem, as the order of values in sub-sequences do not have importance.\\n\\nLet us suppose we have a sorted array. For example, `[1, 2, 2, 3, 4, 5, 5, 6, 9]`. What information do we need to find the answer while iterating over the array? For example, let us suppose we are considering the `4`, what information from `[1, 2, 2, 3]` do we need to find the answer for the array up to `4`?\\n\\nWe notice that the difference between min and max in that case is the difference between `4` and the first element of all previous sub-sequences. Therefore, to sum the differences for all subsequences, we must have the count of all subsequences in `[1, 2, 2, 3]` starting with any of its values.\\n\\nOnce we have that, we can:\\n* Update the total value by adding `(4 - value) * count` for each `value, count` pair existing,\\n* Update our table of counts by multiplying each existing value by `2` (each previous sub-sequence is split in two, one without and one with `4` appended), as well as adding one more for `4`, for the sub-sequence `[4]`.\\n\\nThis gives us the following code:\\n\\n```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        ans = 0\\n        dp = defaultdict(int)\\n        for right in A:\\n            for left, cnt in dp.items():\\n                ans = (ans + (right - left) * cnt) % self.BASE\\n                dp[left] = (cnt * 2) % self.BASE\\n            dp[right] += 1\\n        return ans\\n```\\n\\nThe problem is, although correct, this code is in `O(n^2)`, which is too slow. The main issue is the second loop inside, iterating over `dp`. Now, is it possible to write this loop as a single iteration?\\n\\nIf we rewrite our expression, we notice that it is equivalent to:\\n\\n```\\nans += sum(right * cnt_i) - sum(left_i * cnt_i) = right * sum(cnt_i) - sum(left_i * cnt_i)\\n```\\n\\nAs we multiply each `cnt_i` by 2 in the loop, and add `1` for `right` at the end of the loop, we can rewrite these expressions as standalone variables. I name `total_cnt = sum(cnt_i)` and `total_prod = sum(left_i * cnt_i)`.\\n\\n```\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        total_cnt = 0\\n        total_prod = 0\\n        ans = 0\\n        for num in A:\\n            ans = (ans + total_cnt * num - total_prod) % self.BASE\\n            total_cnt = (2 * total_cnt + 1) % self.BASE\\n            total_prod = (2 * total_prod + num) % self.BASE\\n        return ans\\n```\\n\\nThis solution is in `O(n log(n))` and `O(1)` space, and passes without TLE.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        ans = 0\\n        dp = defaultdict(int)\\n        for right in A:\\n            for left, cnt in dp.items():\\n                ans = (ans + (right - left) * cnt) % self.BASE\\n                dp[left] = (cnt * 2) % self.BASE\\n            dp[right] += 1\\n        return ans\\n```\n```\\nans += sum(right * cnt_i) - sum(left_i * cnt_i) = right * sum(cnt_i) - sum(left_i * cnt_i)\\n```\n```\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        total_cnt = 0\\n        total_prod = 0\\n        ans = 0\\n        for num in A:\\n            ans = (ans + total_cnt * num - total_prod) % self.BASE\\n            total_cnt = (2 * total_cnt + 1) % self.BASE\\n            total_prod = (2 * total_prod + num) % self.BASE\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708434,
                "title": "easy-explanation-with-example-java-o-nlogn",
                "content": "Let\\'s say,\\nThis is our array:\\n[3,1,2,4]\\n\\nSubsequences:\\n\\n\\t\\t\\t\\tmax - min\\n\\t3\\t\\t\\t3-3 = 0\\n\\t1\\t\\t\\t1-1 = 0\\n\\t2\\t\\t\\t2-2 = 0\\n\\t4\\t\\t\\t4-4 = 0\\n\\t3,1\\t\\t\\t3-1 = 2\\n\\t3,2\\t\\t\\t3-2 = 1\\n\\t3,4\\t\\t\\t4-3 = 1\\n\\t1,2\\t\\t\\t2-1 = 1\\n\\t1,4\\t\\t\\t4-1 = 3\\n\\t2,4\\t\\t\\t4-2 = 2\\n\\t3,1,2\\t\\t3-1 = 2\\n\\t3,1,4\\t\\t4-1 = 3\\n\\t3,2,4\\t\\t4-2 = 2\\n\\t1,2,4\\t\\t4-1 = 3\\n\\t3,1,2,4\\t\\t4-1 = 3\\n\\nanswer = 0+0+0+0+2+1+1+1+3+2+2+3+2+3+3 = 23 **-------------------- reference (1)**\\n\\nLet us calculate the total number of occurrences of maximum and minimum elements from these subsequence .\\n\\nMaximum side occurrences: **-------------------- reference (2)**\\n\\'3\\' occurred 4 times\\n\\'1\\' occurred 1 times\\n\\'2\\' occurred 2 times\\n\\'4\\' occurred 8 times\\n\\nMinimum side occurrences:  **-------------------- reference (3)**\\n\\'3\\' occurred 2 times\\n\\'1\\' occurred 8 times\\n\\'2\\' occurred 4 times\\n\\'4\\' occurred 1 times\\n\\nultimately the effective frequencies of elements would be:\\n\\'4\\' occurred 8-1 = 7 times\\n\\'3\\' occurred 4-2 = 2 times\\n\\'2\\' occurred 2-4 = -2 times\\n\\'1\\' occurred 1-8 = -7 times\\n\\nanswer would be:\\n(7 * 4) + (2 * 3) + (-2 * 2) + (-7 * 1) = 28+6-4-7 = 23\\nsame answer right? (**reference (1)**)\\n\\nNow let us get a detailed view of the maximum side occurrences of **4**:\\n\\n\\t4\\t\\t\\t4-4 = 0\\n\\t3,4\\t\\t\\t4-3 = 1\\n\\t1,4\\t\\t\\t4-1 = 3\\n\\t2,4\\t\\t\\t4-2 = 2\\n\\t3,1,4\\t\\t4-1 = 3\\n\\t3,2,4\\t\\t4-2 = 2\\n\\t1,2,4\\t\\t4-1 = 3\\n\\t3,1,2,4\\t\\t4-1 = 3\\n\\nsubsequence  with \\nlength 4 occurred 1 times\\nlength 3 occurred 3 times\\nlength 2 occurred 3 times\\nlength 1 occurred 1 times\\n\\nLet us sort the array in ascending order,\\n[1,2,3,4]\\n\\nSo, to generate subsequence with length 4 we need to include 3 elements from the remaining 3 elements = 3C3 \\t= 1\\nto generate subsequence with length 3 we need to include 2 elements from the remaining 3 elements = 3C2\\t\\t= 3\\nto generate subsequence with length 2 we need to include 1 elements from the remaining 3 elements = 3C1\\t\\t= 3\\nto generate subsequence with length 1 we need to include 0 elements from the remaining 3 elements = 3C0\\t\\t= 1\\n\\nSo, total occurrence of 4:\\n3C3 + 3C2 + 3C1 + 3C0 = 2^3 = 8 (nC0 + nC1 + nC2 + ... + nCn = 2^n)\\n\\nSimilarly, for the whole array,\\n[1,2,3,4]\\n\\n4 -> 2^3 = 8\\n3 -> 2^2 = 4\\n2 -> 2^1 = 2\\n1 -> 2^0 = 1\\nBasically 2 to the power of remaining elements those are lesser than the current element.\\n\\nSimilarly to get the occurrences of minimum side:\\n[1,2,3,4]\\n\\n1 -> 2^3 = 8\\n2 -> 2^2 = 4\\n3 -> 2^1 = 2\\n4 -> 2^0 = 1\\n\\nTo get the effective frequencies we need to subtract the minimum side occurrence of each element from its maximum side occurrence.\\nThe answer would be:\\n((8-1)*4) + ((4-2)*3) + ((2-4)*2) + ((1-8)*1) = 28+6-4-7 = 23\\n\\nBasically, to get the effective frequencies, we need to generate the 2 power array, and reversed version of the 2 power array and then subtract each element.\\ni.e. \\n\\n\\t[8,4,2,1] - \\n\\t[1,2,4,8]\\n\\t= [8-1, 4-2, 2-4, 1-8]\\n\\t= [7, 2, -2, -7]\\n\\nAnd ultimately we multiply them with values of our sorted array ([1,2,3,4]).\\n\\nHere is the code:\\n\\n```\\npublic int sumSubseqWidths(int[] nums) {\\n       long twoPower [] =new long[nums.length];\\n       long mod = 1000000007L;\\n       twoPower[0] =1;\\n\\t   // generating 2 power array\\n       for (int i = 1; i< nums.length; i++){\\n           twoPower[i] = (twoPower[i-1]*2)%mod;\\n       }\\n       long effective[] = new long[nums.length];\\n\\t   // generating effective frequency array  by subtracting the 2 power array\\'s elements from its reverse view\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   effective[i] = (twoPower[i]- twoPower[nums.length- i-1]);\\n       }\\n       Arrays.sort(nums); // sorting the array\\n       long ans = 0;\\n\\t   // now, to get the answer we multiply the elements of the sorted array with the effective frequency array elements\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   ans = (ans+ effective[i]*nums[i])%mod;\\n       }\\n       return (int) ans;\\n   }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int sumSubseqWidths(int[] nums) {\\n       long twoPower [] =new long[nums.length];\\n       long mod = 1000000007L;\\n       twoPower[0] =1;\\n\\t   // generating 2 power array\\n       for (int i = 1; i< nums.length; i++){\\n           twoPower[i] = (twoPower[i-1]*2)%mod;\\n       }\\n       long effective[] = new long[nums.length];\\n\\t   // generating effective frequency array  by subtracting the 2 power array\\'s elements from its reverse view\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   effective[i] = (twoPower[i]- twoPower[nums.length- i-1]);\\n       }\\n       Arrays.sort(nums); // sorting the array\\n       long ans = 0;\\n\\t   // now, to get the answer we multiply the elements of the sorted array with the effective frequency array elements\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   ans = (ans+ effective[i]*nums[i])%mod;\\n       }\\n       return (int) ans;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1667728,
                "title": "python-sort-and-sum-the-contribution",
                "content": "My solution was largely inspired by [this solution for question 2104](https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624416/python3-stack/1203869). I happened to saw the question yesterday, and loved the idea there. Similar to that question, we can solve this question by counting the contribution to the max values and min values separately. The only difference is that [question 2104](https://leetcode.com/problems/sum-of-subarray-ranges/) is asking for sub arrays, but this one is asking for subsequences. But the general idea behind the solution is the same.\\n\\nThe core idea is, for each subsequence, we have one max and one min (can be the same), so when we have the `(max1-min1) + (max2 - min2) + ... + (max_n - min_n)`, we can just separate them to `max_val = max1 + max2 + ... + max_n` and `min_val = min1 + min2 + ... min_n`. The final answer if `max_val - min_val`. \\n\\nThe trick for finding the `max_val` and `min_val` lies in **the number of times a number `x` contributes to the `min_val` or `max_val`**.  Think about this, if we have a **sorted** array `[a, b, 1, c]`, we know `1` can be the max, if a subsequence containing only `1` and `a`, `b`. Similarly, any subsequence containing `1` and `c` will have `1` as `min_val`. \\n\\nLet\\'s do an example for `1` as `max_val`, we can have subsequence `[1]`, `[a, 1]`, `[b, 1]`, and `[a, b, 1]`. In another words, we are selecting elements from `a` and `b`. The number of subsequences with `1` as `max_val` is `choose(0, 2) + choose(1, 2) + choose(2, 2)` (`choose` is the function nCr or combination in math). Therefore, we know `1` contributes *4 times* to the `max_val`. \\n\\nUsing the same method, we can calculate the number of times a number contributes to the max and min. Then we have the answer.\\n\\nHere is the code:\\n```python\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        max_val = min_val = 0\\n        MOD = 10 ** 9 + 7\\n        size = len(nums)\\n        for index, num in enumerate(nums):\\n            max_val = (max_val + num * pow(2, index, MOD)) % MOD\\n            min_val = (min_val + num * pow(2, size - index - 1, MOD)) % MOD\\n        return (max_val - min_val) % MOD\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        max_val = min_val = 0\\n        MOD = 10 ** 9 + 7\\n        size = len(nums)\\n        for index, num in enumerate(nums):\\n            max_val = (max_val + num * pow(2, index, MOD)) % MOD\\n            min_val = (min_val + num * pow(2, size - index - 1, MOD)) % MOD\\n        return (max_val - min_val) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204444,
                "title": "solution-using-fenwick-tree-binary-indexed-tree",
                "content": "We can solve this problem without sorting, instead using\\n a Fenwick Tree (a.k.a. Binary Indexed Tree, BIT).\\n\\n\\n### How Fenwick Trees Work\\nFor those who have not heard of Fenwick Trees before, it would be helpful to take a look at https://en.wikipedia.org/wiki/Fenwick_tree .\\n\\nIn short, a Fenwick Tree is an array and provides two interfaces. Let `bit` be an array expressing a Fenwick Tree initialized by a certain **1-indexed** array `X`. it offers the following operations:\\n- `query_sum(bit, idx)` : returns `X[1] + ... + X[idx]`\\n- `add_sum(bit, idx, value)`: add `value` to `X[idx]`\\nLet N be `len(X)`. Both operations are done in O(logN) time. \\n\\nThe happy thing is that you can implement them very concisely:\\n\\n```Python\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\ndef add_sum(bit, idx, value):\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n```\\nNote again that this is 1-indexed.\\n\\n### My Solution\\nWe can create a Fenwick tree `bit`  such that `query_sum(bit, item)` returns how many items smaller than `item`  there are in `A`, namely each index of `bit` has the number of `item - 1\\n`s in `A` and you can calculate the total number of occurrances of `1, 2, .., item - 1` by `query(bit, item)` in O(lgW) time, where W is `max(A)`.\\nMy solution has mainly 3 parts:\\n1. initialize `bit` from `A`\\n2. Count the number of each item of `A`\\n3. For each `item` and its `count`,  calculate how many times it appears as the minimum or maximum value  of all the subarrays\\n    - We easily know how many items in ` A` are smaller or larger than `item` by:\\n\\t\\t- `num_smaller = query_sum(bit, item)`\\n\\t\\t- `num_larger = N - num_smaller - count`\\n    - The number of subarrays which have `item` as maximum is `(2**num_smaller - 1) * (2**count - 1)` . Likewise, the number of subarrays having `item` as minimum is `(2**num_larger - 1) * (2**count - 1)`\\n    - Add the total contribution of `(2**smaller - 2**larger) * item * (2**count - 1)` to `ans`\\n \\n **Python**\\n ```\\nfrom collections import defaultdict\\n\\n\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\n\\ndef add_sum(bit, idx, value):\\n    \"\"\"\\n    add value to a[i].\\n    \"\"\"\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n\\n\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MOD = 10**9 + 7\\n        N = len(A)\\n\\n        # 1, 2: initialize bit and count items in A\\n        max_item = max(A)\\n        bit = [0] * (max_item + 100)\\n        ans = 0\\n        counter_A = [0] * (max_item + 1)\\n        for item in A:\\n            add_sum(bit, item + 1, 1)\\n            counter_A[item] += 1\\n\\n        # trivial: it is faster to calculate pow(2, hoge) beforehand\\n        pows = [1]\\n        for _ in range(N):\\n            pows.append(pows[-1] * 2 % MOD)\\n        \\n        # 3: add up each contribution\\n        for item, count in enumerate(counter_A[1:], start=1):\\n            if count == 0: continue\\n            num_smallers = query_sum(bit, item)\\n            num_largers = N - num_smallers - count\\n            ans += (pows[num_smallers] - pows[num_largers]) * item * (pows[count] - 1)\\n            ans %= MOD\\n        return ans\\n ```\\n \\n **C++**\\n ```\\n#include <bits/stdc++.h>\\n#define ll long long\\nusing namespace std;\\n\\n\\nint query_sum(vector<int>& bit, int idx) {\\n    int sum_ = 0;\\n    while (idx > 0) {\\n        sum_ += bit.at(idx);\\n        idx -= idx & -idx;\\n    }\\n    return sum_;\\n}\\n\\nvoid add_sum(vector<int>& bit, int idx, int value) {\\n    while (idx <= bit.size()) {\\n        bit.at(idx) += value;\\n        idx += idx & -idx;\\n    }\\n    return;\\n}\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        const ll MOD = 1000000000 + 7;\\n        const int N = A.size();\\n        int max_A = 0;\\n        for (int i = 0; i < N; i++) {\\n            max_A = max(max_A, A.at(i));\\n        }\\n        vector<int> bit(max_A + 100, 0);\\n        vector<int> counter(max_A + 100, 0);\\n        for (int i = 0; i < N; i++) {\\n            int item = A.at(i);\\n            add_sum(bit, item + 1, 1);\\n            counter.at(item) += 1;\\n        }\\n\\n        vector<ll> pows(N + 1, 1);\\n        for (int i = 1; i < N + 1; i++) {\\n            ll prev_pow = pows.at(i - 1);\\n            pows.at(i) = prev_pow * 2 % MOD;\\n        }\\n\\n        ll ans = 0;\\n        for (int item = 1; item < max_A + 1; item++) {\\n            int count = counter.at(item);\\n            if (count == 0) continue;\\n            int num_smallers = query_sum(bit, item);\\n            int num_largers = N - num_smallers - count;\\n            ans += (pows.at(num_smallers) - pows.at(num_largers)) * item % MOD * (pows.at(count) - 1) % MOD;\\n            ans %= MOD;\\n        }\\n        return ans;\\n    }\\n};\\n ```\\nThe total time complexity is O(N + NlgW) and space complexity is O(N + W), where N and W are `len(A)` and `max(A)` respectively.\\nHope this will give you a new perspective!!",
                "solutionTags": [],
                "code": "```Python\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\ndef add_sum(bit, idx, value):\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n```\n```\\nfrom collections import defaultdict\\n\\n\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\n\\ndef add_sum(bit, idx, value):\\n    \"\"\"\\n    add value to a[i].\\n    \"\"\"\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n\\n\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MOD = 10**9 + 7\\n        N = len(A)\\n\\n        # 1, 2: initialize bit and count items in A\\n        max_item = max(A)\\n        bit = [0] * (max_item + 100)\\n        ans = 0\\n        counter_A = [0] * (max_item + 1)\\n        for item in A:\\n            add_sum(bit, item + 1, 1)\\n            counter_A[item] += 1\\n\\n        # trivial: it is faster to calculate pow(2, hoge) beforehand\\n        pows = [1]\\n        for _ in range(N):\\n            pows.append(pows[-1] * 2 % MOD)\\n        \\n        # 3: add up each contribution\\n        for item, count in enumerate(counter_A[1:], start=1):\\n            if count == 0: continue\\n            num_smallers = query_sum(bit, item)\\n            num_largers = N - num_smallers - count\\n            ans += (pows[num_smallers] - pows[num_largers]) * item * (pows[count] - 1)\\n            ans %= MOD\\n        return ans\\n ```\n```\\n#include <bits/stdc++.h>\\n#define ll long long\\nusing namespace std;\\n\\n\\nint query_sum(vector<int>& bit, int idx) {\\n    int sum_ = 0;\\n    while (idx > 0) {\\n        sum_ += bit.at(idx);\\n        idx -= idx & -idx;\\n    }\\n    return sum_;\\n}\\n\\nvoid add_sum(vector<int>& bit, int idx, int value) {\\n    while (idx <= bit.size()) {\\n        bit.at(idx) += value;\\n        idx += idx & -idx;\\n    }\\n    return;\\n}\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        const ll MOD = 1000000000 + 7;\\n        const int N = A.size();\\n        int max_A = 0;\\n        for (int i = 0; i < N; i++) {\\n            max_A = max(max_A, A.at(i));\\n        }\\n        vector<int> bit(max_A + 100, 0);\\n        vector<int> counter(max_A + 100, 0);\\n        for (int i = 0; i < N; i++) {\\n            int item = A.at(i);\\n            add_sum(bit, item + 1, 1);\\n            counter.at(item) += 1;\\n        }\\n\\n        vector<ll> pows(N + 1, 1);\\n        for (int i = 1; i < N + 1; i++) {\\n            ll prev_pow = pows.at(i - 1);\\n            pows.at(i) = prev_pow * 2 % MOD;\\n        }\\n\\n        ll ans = 0;\\n        for (int item = 1; item < max_A + 1; item++) {\\n            int count = counter.at(item);\\n            if (count == 0) continue;\\n            int num_smallers = query_sum(bit, item);\\n            int num_largers = N - num_smallers - count;\\n            ans += (pows.at(num_smallers) - pows.at(num_largers)) * item % MOD * (pows.at(count) - 1) % MOD;\\n            ans %= MOD;\\n        }\\n        return ans;\\n    }\\n};\\n ```",
                "codeTag": "C++"
            },
            {
                "id": 161299,
                "title": "this-is-bulls-2-xx-gives-me-tle-whereas-passed-seriously",
                "content": "I spent the last 40 minutes trying to come up w/ a better than O(nlonn) solution, which I don\\'t think exists. So I\\'m curious and waiting for smarter solution... And it turned out that the catch is the bit-wise opearting when computing power of 2s. \\n\\nIf you un-comment the code you will find that you get TLE... \\n\\nI understand bit-wise operator is faster than ** , but if this is the speed limit, I don\\'t think its fair. Plus who cares whether its ** or a more hacky << ? \\n\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        CONST = 10 ** 9 + 7\\n        A = sorted(A, key=lambda x: -x)\\n        n = len(A)\\n        ans = 0\\n        for i in range(n):\\n            ans += A[i] * (2 ** (n-i-1) - 2 ** i)         # <- This you get TLE \\n            # ans += A[i] * ((1 << (n-i-1)) - (1 << i))       # <- This you pass\\n        return ans % CONST\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        CONST = 10 ** 9 + 7\\n        A = sorted(A, key=lambda x: -x)\\n        n = len(A)\\n        ans = 0\\n        for i in range(n):\\n            ans += A[i] * (2 ** (n-i-1) - 2 ** i)         # <- This you get TLE \\n            # ans += A[i] * ((1 << (n-i-1)) - (1 << i))       # <- This you pass\\n        return ans % CONST\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961298,
                "title": "python3-a-much-easier-way-to-build-the-math-logic",
                "content": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, A: List[int]) -> int:\\n\\t\\t\\t# Note:  sub sequence, not sub array\\n\\t\\t\\t# after sorting, for each i \\n\\t\\t\\t# -  A[i] will serve as max for 2**i combinations with elements from A[:i], which makes additions to res\\n\\t\\t\\t# -  A[i] will serve as min for 2**(n-1-i) combinations with elements from A[i+1:n], which makes deductions to res\\n\\t\\t\\t# we just need to enumerate i, and update the res\\n\\n\\t\\t\\tA = sorted(A)\\n\\t\\t\\tM = 10**9 + 7\\n\\t\\t\\tP = [(2**i)%M for i in range(len(A))] \\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(A)):\\n\\t\\t\\t\\tadd = P[i] * A[i]\\n\\t\\t\\t\\tded = P[len(A)-1-i]* A[i]\\n\\t\\t\\t\\tres += (add - ded)%M\\n\\t\\t\\t\\tres = res%M\\n\\t\\t\\treturn res\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, A: List[int]) -> int:\\n\\t\\t\\t# Note:  sub sequence, not sub array\\n\\t\\t\\t# after sorting, for each i \\n\\t\\t\\t# -  A[i] will serve as max for 2**i combinations with elements from A[:i], which makes additions to res\\n\\t\\t\\t# -  A[i] will serve as min for 2**(n-1-i) combinations with elements from A[i+1:n], which makes deductions to res\\n\\t\\t\\t# we just need to enumerate i, and update the res\\n\\n\\t\\t\\tA = sorted(A)\\n\\t\\t\\tM = 10**9 + 7\\n\\t\\t\\tP = [(2**i)%M for i in range(len(A))] \\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(A)):\\n\\t\\t\\t\\tadd = P[i] * A[i]\\n\\t\\t\\t\\tded = P[len(A)-1-i]* A[i]\\n\\t\\t\\t\\tres += (add - ded)%M\\n\\t\\t\\t\\tres = res%M\\n\\t\\t\\treturn res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 161265,
                "title": "black-magic",
                "content": "```\\nA.sort()\\nlookup = [1] * len(A)\\nfor i in xrange(1, len(A)):\\n\\tlookup[i] = (lookup[i-1]) * 2 % 1000000007 \\nreturn sum([A[i] * (lookup[i] - lookup[len(A)-i-1]) for i in xrange(len(A))]) % 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nA.sort()\\nlookup = [1] * len(A)\\nfor i in xrange(1, len(A)):\\n\\tlookup[i] = (lookup[i-1]) * 2 % 1000000007 \\nreturn sum([A[i] * (lookup[i] - lookup[len(A)-i-1]) for i in xrange(len(A))]) % 1000000007\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 162583,
                "title": "python-solution-with-detailed-steps",
                "content": "dp[i] represent A[:i+1]\\'s sum of subsequence widths.\\nobviously, dp[0] = 0(only A[0]), dp[1] = A[1]-A[0]\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/2017111303/image_1535013111.png)\\ncare about 2^i, it\\'s very large(i<20000), so we should mod 1e9+7 before we calculate the result!\\nI use rec[i] represent 2^i,as a global variable\\n\\n```python\\nrec,mod,s = [],10**9+7,1\\nfor i in range(20000):\\n    rec.append(s)\\n    s *= 2\\n    s %= mod\\n\\ndef sumSubseqWidths(A):\\n\\tA.sort()\\n\\tdp = [0] * len(A)\\n\\tdp[0],dp[1] = 0,A[1]-A[0]\\n\\tfor i in range(2,len(dp)):\\n\\t\\tdp[i] = (3*dp[i-1] - 2*dp[i-2] + (A[i]-A[i-1]) * (rec[i]-1)) % mod\\n\\treturn dp[-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\nrec,mod,s = [],10**9+7,1\\nfor i in range(20000):\\n    rec.append(s)\\n    s *= 2\\n    s %= mod\\n\\ndef sumSubseqWidths(A):\\n\\tA.sort()\\n\\tdp = [0] * len(A)\\n\\tdp[0],dp[1] = 0,A[1]-A[0]\\n\\tfor i in range(2,len(dp)):\\n\\t\\tdp[i] = (3*dp[i-1] - 2*dp[i-2] + (A[i]-A[i-1]) * (rec[i]-1)) % mod\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3963373,
                "title": "calculate-contribution-of-each-element",
                "content": "# Intuition\\nSince the contraints are very strict to try and go for brute force approach, we try to solve this question by calculating contribution of each element\\n\\n# Approach\\nSort the array firstly. Then at each index we have to calculate in how many subsequence will the current element be maximum and minimum.\\n1) Maximum case\\n   All the subsequences ending at current index will have the maximum  element as nums[i]. 2*i subsequences\\n2) Minimum case\\nAll the subsequences starting at current index will have minimum element as nums[i]. 2*(n-i-1) subsequences\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    #define ll long long\\n    int mod = 1e9+7;\\n    int power(ll x, ll y) {\\n        int res = 1;  \\n        x = x % mod; \\n        if (x == 0) return 0;\\n    \\n        while (y > 0) {\\n            if (y & 1)\\n                res = (res*x) % mod;\\n    \\n            y = y>>1; \\n            x = (x*x) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ll ans = 0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0 ; i<n ; ++i) {\\n            ans = (ans + nums[i]*1ll*power(2,i))%mod;\\n            ans = (ans - nums[i]*1ll*power(2,n-i-1))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\n    int mod = 1e9+7;\\n    int power(ll x, ll y) {\\n        int res = 1;  \\n        x = x % mod; \\n        if (x == 0) return 0;\\n    \\n        while (y > 0) {\\n            if (y & 1)\\n                res = (res*x) % mod;\\n    \\n            y = y>>1; \\n            x = (x*x) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ll ans = 0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0 ; i<n ; ++i) {\\n            ans = (ans + nums[i]*1ll*power(2,i))%mod;\\n            ans = (ans - nums[i]*1ll*power(2,n-i-1))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545992,
                "title": "c-891-sum-of-subsequence-widths",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size(), MOD = 1\\'000\\'000\\'007; \\n        vector<long> p(n, 1); \\n        for (int i = 1; i < n; ++i) p[i] = 2*p[i-1]%MOD; \\n        \\n        long ans = 0; \\n        sort(nums.begin(), nums.end()); \\n        for (int i = 0; i < n; ++i) \\n            ans = (ans + nums[i] * (p[i] - p[n-1-i])) % MOD; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size(), MOD = 1\\'000\\'000\\'007; \\n        vector<long> p(n, 1); \\n        for (int i = 1; i < n; ++i) p[i] = 2*p[i-1]%MOD; \\n        \\n        long ans = 0; \\n        sort(nums.begin(), nums.end()); \\n        for (int i = 0; i < n; ++i) \\n            ans = (ans + nums[i] * (p[i] - p[n-1-i])) % MOD; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550718,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int mod=1000000007;\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        long first=0;\\n        long second=0;\\n        long pow[]=new long[n+1];\\n        pow[0] = 1;\\n        for (int i = 1; i<n;i++){\\n            pow[i] = (pow[i-1] * 2) % mod;\\n        }    \\n        for(int i=1;i<nums.length;i++){\\n            long a=nums[i];\\n            long r=2;\\n            int len=i;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            first=(first+sum)%mod;\\n        }\\n         \\n        for(int j=0;j<nums.length-1;j++){\\n            long a=nums[j];\\n            long r=2;\\n            int len=n-j-1;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            second=(second+sum)%mod;\\n        }\\n        long res=first-second;\\n        if(res<0)res+=mod;\\n        return (int)(res);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int mod=1000000007;\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        long first=0;\\n        long second=0;\\n        long pow[]=new long[n+1];\\n        pow[0] = 1;\\n        for (int i = 1; i<n;i++){\\n            pow[i] = (pow[i-1] * 2) % mod;\\n        }    \\n        for(int i=1;i<nums.length;i++){\\n            long a=nums[i];\\n            long r=2;\\n            int len=i;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            first=(first+sum)%mod;\\n        }\\n         \\n        for(int j=0;j<nums.length-1;j++){\\n            long a=nums[j];\\n            long r=2;\\n            int len=n-j-1;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            second=(second+sum)%mod;\\n        }\\n        long res=first-second;\\n        if(res<0)res+=mod;\\n        return (int)(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511726,
                "title": "solution",
                "content": "```C++ []\\nconst long M=1e9+7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long sum=0, cnt=1;\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=0, j=n-1; i<n; sum=(sum+(nums[i++]-nums[j--])*cnt)%M, cnt=cnt*2%M) {}\\n        return sum;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n        nums.sort()\\n        ans, pow2 = 0, 1\\n        for x, y in zip(nums, reversed(nums)):\\n            ans += (x - y) * pow2\\n            pow2 = pow2 * 2 % mod\\n        return ans % mod\\n```\\n\\n```Java []\\nclass Solution {\\n\\tpublic int sumSubseqWidths(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tlong c = 1;\\n\\t\\tlong result = 0;\\n\\t\\tlong mod = 1000000007L;\\n\\t\\tfor (int i = 0, j = nums.length - 1; i < nums.length; i++, j--) {\\n\\t\\t\\tresult = (result + (nums[i] * c) - (nums[j] * c)) % mod;\\n\\t\\t\\tc = (c * 2) % mod;\\n\\t\\t}\\n\\t\\treturn (int) ((result + mod) % mod);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nconst long M=1e9+7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long sum=0, cnt=1;\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=0, j=n-1; i<n; sum=(sum+(nums[i++]-nums[j--])*cnt)%M, cnt=cnt*2%M) {}\\n        return sum;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n        nums.sort()\\n        ans, pow2 = 0, 1\\n        for x, y in zip(nums, reversed(nums)):\\n            ans += (x - y) * pow2\\n            pow2 = pow2 * 2 % mod\\n        return ans % mod\\n```\n```Java []\\nclass Solution {\\n\\tpublic int sumSubseqWidths(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tlong c = 1;\\n\\t\\tlong result = 0;\\n\\t\\tlong mod = 1000000007L;\\n\\t\\tfor (int i = 0, j = nums.length - 1; i < nums.length; i++, j--) {\\n\\t\\t\\tresult = (result + (nums[i] * c) - (nums[j] * c)) % mod;\\n\\t\\t\\tc = (c * 2) % mod;\\n\\t\\t}\\n\\t\\treturn (int) ((result + mod) % mod);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791666,
                "title": "c-easy-shorts",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740307,
                "title": "golang-runtime-283-ms-faster-than-16-67",
                "content": "- Runtime: 283 ms, faster than 16.67% of Go online submissions for Sum of Subsequence Widths.\\n- Memory Usage: 8.4 MB, less than 100.00% of Go online submissions for Sum of Subsequence Widths.\\n```\\nfunc sumSubseqWidths(nums []int) int {\\n    sort.Ints(nums)\\n\\tres, mod, n, p := 0, 1000000007, len(nums), 1\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tres = (res + (nums[i]-nums[n-1-i])*p) % mod\\n\\t\\tp = (p << 1) % mod\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc sumSubseqWidths(nums []int) int {\\n    sort.Ints(nums)\\n\\tres, mod, n, p := 0, 1000000007, len(nums), 1\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tres = (res + (nums[i]-nums[n-1-i])*p) % mod\\n\\t\\tp = (p << 1) % mod\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2537337,
                "title": "magical-solution-true-for-all-complexity-nlogn",
                "content": "\\n![image](https://assets.leetcode.com/users/images/1ed44939-621b-4e4b-b1ac-6d9d638a9075_1662429184.0499213.png)\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "\\n![image](https://assets.leetcode.com/users/images/1ed44939-621b-4e4b-b1ac-6d9d638a9075_1662429184.0499213.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2350649,
                "title": "simple-easy-method-for-those-who-did-not-understand-c",
                "content": "In this question if we deeply try to think then we can able to understand that order of elements does not matter because we are actually choosing the all subsequences and take the difference of maximum and minimum values.\\nNow coming to max and min values, we wants to find the contribution of each array elements in thier subsequence they are part with where they are minimum and maximum.\\n1) There are 2 ^ i sequence are possible in which a[i]th element are maxmium. \\ne.g. [2, 3, 5] => here 2 is contibuting in sequnces [2], [2, 3] , [2, 5], [2, 3, 5] now we can easily see that 2 is maximum in only single sequnce which is [2].\\n2) Now whatever the sequence left i.e. 2 ^( n - i - 1) sequences are possible in which a[i]th element is minimum.\\n\\nNow the problem is solved , but some might get memory limit exceeded due to not perfom the mod operation in right way here we just use mod operation as simpe way and do addition first so that answer will always be positive so there will be no chance of mistake.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        vector < long long > pow(nums.size() ); \\n        pow[0] = 1;\\n          for(int i = 1 ; i<nums.size(); i++){ \\n             pow[i] = pow[i-1] * 2 % 1000000007; \\n          }\\n        sort(nums.begin() , nums.end()); \\n       long long ans = 0 ;   \\n        for(int i = 0 ; i<nums.size(); i++){ \\n              ans = (ans + pow[i]*nums[i]) % 1000000007; \\n               ans = (ans - pow[nums.size()-i-1] * (long long)nums[i] ) % 1000000007; \\n           \\n          } \\n        return ans; \\n    }\\n};\\n```\\n\\n```\\nwhile(1){ \\nif(likes == true){ \\n  upvotes +=1; \\n}\\nelse { \\nlike = true; \\ncontinue; \\n}\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        vector < long long > pow(nums.size() ); \\n        pow[0] = 1;\\n          for(int i = 1 ; i<nums.size(); i++){ \\n             pow[i] = pow[i-1] * 2 % 1000000007; \\n          }\\n        sort(nums.begin() , nums.end()); \\n       long long ans = 0 ;   \\n        for(int i = 0 ; i<nums.size(); i++){ \\n              ans = (ans + pow[i]*nums[i]) % 1000000007; \\n               ans = (ans - pow[nums.size()-i-1] * (long long)nums[i] ) % 1000000007; \\n           \\n          } \\n        return ans; \\n    }\\n};\\n```\n```\\nwhile(1){ \\nif(likes == true){ \\n  upvotes +=1; \\n}\\nelse { \\nlike = true; \\ncontinue; \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159982,
                "title": "py-3-sorting-no-comments-video-refrence",
                "content": "[ Credits PepCoding](https://www.youtube.com/watch?v=kSo8W6ZGYqw&list=PL-Jc9J83PIiE-TR27GB7V5TBLQRT5RnSl&index=50&ab_channel=Pepcoding)\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = 0\\n        for i in range(n):\\n            ans += nums[i] * 1<<i\\n            ans -= nums[i] * 1<<(n-i-1)\\n        return ans%(10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = 0\\n        for i in range(n):\\n            ans += nums[i] * 1<<i\\n            ans -= nums[i] * 1<<(n-i-1)\\n        return ans%(10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027479,
                "title": "2-line-python-sorting-subset-with-thought-process-when-being-asked-during-interviews",
                "content": "### Sorting + Subset\\nThis problem is similar with the [2104. Sum of Subarray Ranges](https://leetcode.com/problems/sum-of-subarray-ranges/), while the solution is significantly different. But the idea is similar, we just get the sum of maximum and sum of minimum respetively, then get the final answer by subtraction.\\n\\nInteresting tips:\\n * Use stack when seeing maximum/minimum of subarrays since order matters.\\n * Use sorting when seeing maximum/minimum of subsequences since order doesn\\'t matter with removal.\\n\\nThen the first step is that for each number `nums[i]`, we need calculate the sum of subsequences that the `nums[i]` is maximum. In order to have `nums[i]` maximum, we can only put the numbers that are smaller than `nums[i]`. For instance, `[1,2,3,4]`, we want to calculate the sum of subsequences for `3`, then only `[1, 2]` can be put into the subsequences, finally add `3`. \\n\\nSo the second step is that how many subsequences we can construct given list of numbers? It\\'s `2 ^ size of list`. Why?\\nBecause for each number, we have only 2 options to include it or not, if all included, it\\'s `[1,2]`, otherwise if all not included, it\\'s empty set/list `[]`. \\nThen the number of subsets/subsequences we can construct is `2 ^ size of list`.\\nFinally, it\\'s quite simply, we need to know the number of integers that are smaller than `nums[i]`, so sorting is the solution.\\nLet\\'s put it all together:\\n1. sort the `nums`\\n2. iterate each number and sum up of `nums[i] * ((1 << i) - (1 << n - i - 1))`\\n3. modulus the result.\\n\\nYou might find that you got TLE with this solution, because shifting bit is expensive when `n` is large. So we can modulus `M` whenever shifting bits. \\nAlternatively use `pow(2, i, M)`.\\n\\n```python\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t# 1Cn + 2Cn + 3Cn ... nCn\\n    # 1 * 2 ^ 0 + 2 * 2 ^ 1 + 3 * 2 ^ 2 = 1 + 4 + 12 = 17\\n    # 1 * 2 ^ 2 + 2 * 2 ^ 1 + 3 * 2 ^ 0 = 4 + 4 + 3 = 11\\n    # 2 ^ number of subsets        \\n    n, M = len(nums),10 ** 9 + 7\\n    return sum(nums[index] * (pow(2, i, M) - pow(2, n - i - 1, M)) for i, index in enumerate(sorted(range(n), key=lambda x: nums[x]))) % M\\n```\\n\\n*Time Complexity*= **O(NlgN)**\\n*Space Complexity*= **O(1)**\\n\\n\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```python\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t# 1Cn + 2Cn + 3Cn ... nCn\\n    # 1 * 2 ^ 0 + 2 * 2 ^ 1 + 3 * 2 ^ 2 = 1 + 4 + 12 = 17\\n    # 1 * 2 ^ 2 + 2 * 2 ^ 1 + 3 * 2 ^ 0 = 4 + 4 + 3 = 11\\n    # 2 ^ number of subsets        \\n    n, M = len(nums),10 ** 9 + 7\\n    return sum(nums[index] * (pow(2, i, M) - pow(2, n - i - 1, M)) for i, index in enumerate(sorted(range(n), key=lambda x: nums[x]))) % M\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1753530,
                "title": "c-solution-time-complexity-o-n-log-n-space-complexity-o-1",
                "content": "For each number we have 2 choices, whether to include it in our subsequence or not. So for any choosen subsequence we have 2 choices for every element except for min and max element. \\n\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        long long two=1;\\n        int i=0,j=nums.size()-1;\\n        long long left=0,right=0;\\n        while(j>=0){\\n            left=left+nums[i++];\\n            right=right+nums[j--];\\n            long long sum=((right-left)*two)%int(1e9+7);\\n            ans=(ans+sum)%int(1e9+7);\\n            two=(two*2)%int(1e9+7);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        long long two=1;\\n        int i=0,j=nums.size()-1;\\n        long long left=0,right=0;\\n        while(j>=0){\\n            left=left+nums[i++];\\n            right=right+nums[j--];\\n            long long sum=((right-left)*two)%int(1e9+7);\\n            ans=(ans+sum)%int(1e9+7);\\n            two=(two*2)%int(1e9+7);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694290,
                "title": "c-solution-math-combinatorics-explained",
                "content": "Observation: The answer will be sum of Max element of each subsequence - sum of Min elements of each subsequence\\n\\nLength of nums = N\\nLets consider and element X which occurs xn times, there are L numbers strictly less than X and G numbers strictly greater than X.\\n\\nTherefore,\\nnx + L + G = N\\n\\nthe number of subsequences where X is the minimum is (there is atleast one X):\\n\\t(number of X\\'s we can chhose from nx X\\'s ) * (number of susequences formed from the Greater G elements)\\n\\t\\n\\tsub_x_min = (nxC1 + nxC2 + ... nxCnx) * (GC0 + GC1 + GC2 + ... GCG)\\n\\tsub_x_min = ( 2 ^ (nx) - 1 ) * (2 ^ (G))\\nTherefore for every X in nums the sum of Min elements of each subsequence will be:\\n\\t= sum(sub_x_min*X) for every X\\n\\t\\nRepeat the same Process but find Sum of Max elements of each subsequence\\n\\nReturn the difference of these sums.\\n\\n```\\nclass Solution {\\npublic:\\n    int MAX = 1000000007;\\n    \\n    // function for modular exponentiation to find (2^n)%MAX\\n    long long expo(vector<int>& dp, int n){\\n        if(n < 2) return n+1;\\n        if(dp[n]) return dp[n];\\n        \\n        if(n % 2 == 0){\\n            long long temp = expo(dp, n/2) % MAX;\\n            dp[n] = (temp*temp) % MAX;\\n            return dp[n];\\n        } else{\\n            dp[n] = (2 * expo(dp, n-1)) % MAX;\\n            return dp[n];\\n        }\\n    }\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mpGreater;\\n        \\n        int resHigh = 0, resLow = 0;\\n        \\n        //count of each element\\n        for(int a : nums) mpGreater[a]++;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> dp(nums.size());\\n        \\n        for(auto current : mpGreater){\\n            // number of elements greater than current element\\n            int greater = nums.end() - upper_bound(nums.begin(), nums.end(), current.first); \\n            //elements strictly lesser than current\\n            int lesser = n - current.second - greater;\\n\\n            int temp1 = expo(dp, current.second)-1;\\n            resLow = (resLow + (((expo(dp, greater) * temp1) * current.first)%MAX)) % MAX;\\n            resHigh = (resHigh + (((expo(dp, lesser) * temp1) * current.first)%MAX))%MAX;\\n            \\n        }\\n        \\n        int res = resHigh%MAX - resLow%MAX;\\n        \\n        return res < 0 ? res % MAX + MAX : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MAX = 1000000007;\\n    \\n    // function for modular exponentiation to find (2^n)%MAX\\n    long long expo(vector<int>& dp, int n){\\n        if(n < 2) return n+1;\\n        if(dp[n]) return dp[n];\\n        \\n        if(n % 2 == 0){\\n            long long temp = expo(dp, n/2) % MAX;\\n            dp[n] = (temp*temp) % MAX;\\n            return dp[n];\\n        } else{\\n            dp[n] = (2 * expo(dp, n-1)) % MAX;\\n            return dp[n];\\n        }\\n    }\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mpGreater;\\n        \\n        int resHigh = 0, resLow = 0;\\n        \\n        //count of each element\\n        for(int a : nums) mpGreater[a]++;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> dp(nums.size());\\n        \\n        for(auto current : mpGreater){\\n            // number of elements greater than current element\\n            int greater = nums.end() - upper_bound(nums.begin(), nums.end(), current.first); \\n            //elements strictly lesser than current\\n            int lesser = n - current.second - greater;\\n\\n            int temp1 = expo(dp, current.second)-1;\\n            resLow = (resLow + (((expo(dp, greater) * temp1) * current.first)%MAX)) % MAX;\\n            resHigh = (resHigh + (((expo(dp, lesser) * temp1) * current.first)%MAX))%MAX;\\n            \\n        }\\n        \\n        int res = resHigh%MAX - resLow%MAX;\\n        \\n        return res < 0 ? res % MAX + MAX : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489381,
                "title": "c-with-explanation-93-solution",
                "content": "Take a simple example\\n```\\n\\t\\tnums = [3,1,2]\\n\\t\\tWe will have \"2\"  as a highest number in \"How many sub-sequence\" ?\\n\\t\\tAns. \\n\\t\\t\\tIf we sort nums = [1, 2, 3]\\n\\t\\t\\twe will have \"2 as a highest number in 2^1 sub-sequence \"\\n\\t\\t\\tNamely [1, 2] and [2]\\n\\t\\t\\tOr we can say 2^index number of subarrays\\n\\t\\tAs we have number of time in which a certain index will be the highest number \\n\\t\\twe need to find the lowest number in each of the sub-sequence\\n\\t\\t\\n\\t\\tNow think about index => 2 \\n\\t\\t[1 ,  2,  3]  => lowest 1\\n\\t    [1,        3] => lowest 1\\n\\t\\t\\t  [2,  3] => lowest 2\\n\\t\\t\\t       [3] => lowest 3\\n\\t\\tnumber of times 1 was smallest is equal to  \"2^( index_of_3 - index_of_1  - 1) == 2 ^ (2 - 0 - 1) = 2 \\n\\t\\tnumber of times 2 was smallest is equal to  \"2^( index_of_3 - index_of_2  - 1) == 2 ^ (2 - 1 - 1) = 1 \\n\\t\\t\\n\\t\\tNow 3 as a highest number will add \\n\\t\\t\\t\\t(3 - 1) + (3 - 1) + (3 - 2) + (3 - 3) ==  3 * (  (2 ^ index_of_3) - 1 ) - 1 * 2^( index_of_3 - index_of_1  - 1) - 2 * 2^( index_of_3 - index_of_2  - 1) \\n\\t\\t\\n\\t\\tSimilary do for the remaing element starting from 0 index\\n\\t\\t\\n```\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        int n = nums.size();\\n        \\n        long long ans = 0, last = 0, p = 1;\\n        \\n        long long mod = 1e9 + 7, temp;\\n        \\n        for(int i = 0 ; i < n ; ++i){\\n            \\n            temp = ((p-1ll)*nums[i] - last ) % mod;\\n            \\n            ans = (ans + temp ) % mod;\\n            \\n            p = (p*2ll) % mod;\\n            \\n            last = (2*last + 1ll*nums[i]) % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tnums = [3,1,2]\\n\\t\\tWe will have \"2\"  as a highest number in \"How many sub-sequence\" ?\\n\\t\\tAns. \\n\\t\\t\\tIf we sort nums = [1, 2, 3]\\n\\t\\t\\twe will have \"2 as a highest number in 2^1 sub-sequence \"\\n\\t\\t\\tNamely [1, 2] and [2]\\n\\t\\t\\tOr we can say 2^index number of subarrays\\n\\t\\tAs we have number of time in which a certain index will be the highest number \\n\\t\\twe need to find the lowest number in each of the sub-sequence\\n\\t\\t\\n\\t\\tNow think about index => 2 \\n\\t\\t[1 ,  2,  3]  => lowest 1\\n\\t    [1,        3] => lowest 1\\n\\t\\t\\t  [2,  3] => lowest 2\\n\\t\\t\\t       [3] => lowest 3\\n\\t\\tnumber of times 1 was smallest is equal to  \"2^( index_of_3 - index_of_1  - 1) == 2 ^ (2 - 0 - 1) = 2 \\n\\t\\tnumber of times 2 was smallest is equal to  \"2^( index_of_3 - index_of_2  - 1) == 2 ^ (2 - 1 - 1) = 1 \\n\\t\\t\\n\\t\\tNow 3 as a highest number will add \\n\\t\\t\\t\\t(3 - 1) + (3 - 1) + (3 - 2) + (3 - 3) ==  3 * (  (2 ^ index_of_3) - 1 ) - 1 * 2^( index_of_3 - index_of_1  - 1) - 2 * 2^( index_of_3 - index_of_2  - 1) \\n\\t\\t\\n\\t\\tSimilary do for the remaing element starting from 0 index\\n\\t\\t\\n```\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        int n = nums.size();\\n        \\n        long long ans = 0, last = 0, p = 1;\\n        \\n        long long mod = 1e9 + 7, temp;\\n        \\n        for(int i = 0 ; i < n ; ++i){\\n            \\n            temp = ((p-1ll)*nums[i] - last ) % mod;\\n            \\n            ans = (ans + temp ) % mod;\\n            \\n            p = (p*2ll) % mod;\\n            \\n            last = (2*last + 1ll*nums[i]) % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449195,
                "title": "python-two-o-nlogn-approaches",
                "content": "Let `n` be the length of `nums`. We need to first sort `nums`. For the element at index `i` (0-based) in sorted `nums`, there are `2^i` subsequences where that element is the maximum and there are `2^(n - i - 1)` subsequences where that element is the minimum. Then, we get the following solution.\\n\\nApproach 1:\\n`O(nlogn) + O(nlogn) = O(nlogn)`\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        return sum(n * (pow(2, i, mod) - pow(2, len(nums) - i - 1, mod)) for i,n in enumerate(sorted(nums))) % mod\\n```\\n\\nWe can optimize our second step by caluculating the powers of two as we go while adding and substracting the elements using the power of two at each step.\\n\\nApproach 2:\\n`O(nlogn) + O(n) = O(nlogn)`\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mod = int(1e9 + 7)\\n        res = 0\\n        cur_pow = 1\\n        for i in range(len(nums)):\\n            res = (res + cur_pow * (nums[i] - nums[len(nums) - i - 1])) % mod\\n            cur_pow = cur_pow * 2 % mod\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        return sum(n * (pow(2, i, mod) - pow(2, len(nums) - i - 1, mod)) for i,n in enumerate(sorted(nums))) % mod\\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mod = int(1e9 + 7)\\n        res = 0\\n        cur_pow = 1\\n        for i in range(len(nums)):\\n            res = (res + cur_pow * (nums[i] - nums[len(nums) - i - 1])) % mod\\n            cur_pow = cur_pow * 2 % mod\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104026,
                "title": "java-array-math-14ms-beats-96-t-c-o-nlogn-s-c-o-n",
                "content": "\\n    public int sumSubseqWidths(int[] A) {\\n        int len = A.length, mod = 1000000007;\\n\\t\\tlong sum = 0;\\n\\t\\tArrays.sort(A);\\n\\t\\tlong[] dp = new long[len];\\n\\t\\tdp[0] = 1;\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tdp[i] = (dp[i - 1] * 2) % mod;\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tsum = (sum + (A[i] * (dp[i] - dp[len - 1 - i]))) % mod;\\n\\n\\t\\treturn (int) (sum % mod);\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int sumSubseqWidths(int[] A) {\\n        int len = A.length, mod = 1000000007;\\n\\t\\tlong sum = 0;\\n\\t\\tArrays.sort(A);\\n\\t\\tlong[] dp = new long[len];\\n\\t\\tdp[0] = 1;\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tdp[i] = (dp[i - 1] * 2) % mod;\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tsum = (sum + (A[i] * (dp[i] - dp[len - 1 - i]))) % mod;\\n\\n\\t\\treturn (int) (sum % mod);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1093550,
                "title": "c-o-n-log-n",
                "content": "```\\nconst int m=1e9+7;\\nclass Solution {\\npublic:\\n    vector<int>POW;\\n    void init(int n)\\n    {\\n        POW.clear();\\n        POW.push_back(1);\\n        for(int i=1;i<=n;i++){\\n            int temp=POW[i-1]*2;\\n            temp%=m;\\n            POW.push_back(temp);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            POW[i]=(POW[i-1]%m+POW[i]%m)%m;\\n        }\\n    }\\n    int mul(long long int a,long long int b)\\n    {\\n        return ((a%m)*(b%m))%m;\\n    }\\n    int sumSubseqWidths(vector<int>& A) {\\n        int n=A.size();\\n        init(n);\\n        sort(A.begin(),A.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int less=i-1;\\n            int more=n-i-2;\\n            int temp=0;\\n            if(less>=0)\\n            {\\n                temp=mul(POW[less],A[i]);\\n            }\\n            if(more>=0)\\n            {\\n                temp=(temp%m+((-1*mul(POW[more],A[i]))%m+m)%m)%m;\\n            }\\n            ans=(ans%m+temp%m)%m;            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nconst int m=1e9+7;\\nclass Solution {\\npublic:\\n    vector<int>POW;\\n    void init(int n)\\n    {\\n        POW.clear();\\n        POW.push_back(1);\\n        for(int i=1;i<=n;i++){\\n            int temp=POW[i-1]*2;\\n            temp%=m;\\n            POW.push_back(temp);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            POW[i]=(POW[i-1]%m+POW[i]%m)%m;\\n        }\\n    }\\n    int mul(long long int a,long long int b)\\n    {\\n        return ((a%m)*(b%m))%m;\\n    }\\n    int sumSubseqWidths(vector<int>& A) {\\n        int n=A.size();\\n        init(n);\\n        sort(A.begin(),A.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int less=i-1;\\n            int more=n-i-2;\\n            int temp=0;\\n            if(less>=0)\\n            {\\n                temp=mul(POW[less],A[i]);\\n            }\\n            if(more>=0)\\n            {\\n                temp=(temp%m+((-1*mul(POW[more],A[i]))%m+m)%m)%m;\\n            }\\n            ans=(ans%m+temp%m)%m;            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974489,
                "title": "java-o-n-logn",
                "content": "```\\nclass Solution {\\n    //1-6 (number of elements in between 1 and 6) = (6-1-1) = 4  \\n    //length of sub seq 2 -> 4C0 3 -> 4C1 ; 4 -> 4c2 ; 5 -> 4C3  6 -> 4C4  4c0 + 4c1 + 4c2 + 4c3 + 4c4 1+4+6+4+1=16\\n    //1-5 3c0 + 3c1 + 3c2 + 3c3  = 8 \\n    //1-4 2c0 + 2c1 2c2 = 4\\n    //1-3 1c0 + 1c1  = 2\\n    //1-2 1c0 = 1\\n    \\n    /*16+8+4+2+1(for 1 as min) 8+4+2+1(for 2 as min)  4+2+1(for 3 as min)  2+1(for 4 as min)  1(for 5 as min)  \\n    -1*nums[0]*31 + nums[1]*1 + nums[2]*2 + nums[3]*4 + nums[4]*8 + nums[5]*16\\n        -1*nums[1]*15 + nums[2]*1 +nums[3]*2 + nums[4]*4 + nums[5]*8\\n        -1*nums[2]*7 + nums[3]*1 + nums[4]*2 + nums[5]*4\\n        -1*nums[3]*3 + nums[4]*1 + nums[5]*2\\n        -1*nums[4]*1 + nums[5]*1\\n        \\n        -nums[0]*31 + -nums[1]*15 - nums[2]*7 - nums[3]*3 - nums[4]*1\\n        nums[1]*1 + nums[2]*3 + nums[3]*7 + nums[4]*15 + nums[5]*31\\n    \\n    (-1)*nums[0]*(pow[6-1-0]-1) + (-1)*nums[1]*(pow[6-1-1]-1) + (-1)*nums[2]*(pow[6-1-2]-1)\\n    ... (-1)* nums[5]*(pow[6-1-5]-1)  \\n    + nums[1]*(pow[1]-1) + nums[2]*(pow[2]-1) + .... + nums[5]*(pow[5]-1)\\n    \\n    (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1)        \\n*/\\n    public int sumSubseqWidths(int[] A) {\\n        int MOD = 1_000_000_007;\\n        Arrays.sort(A);\\n        int l = A.length;\\n        long[] pow = new long[l];\\n        pow[0]=1;\\n        for(int i=1;i<l;i++){\\n            pow[i]=pow[i-1]*2 % MOD;\\n        }\\n        long res = 0;\\n        for(int i=0;i<l;i++){\\n            res = (res + (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1))%MOD;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //1-6 (number of elements in between 1 and 6) = (6-1-1) = 4  \\n    //length of sub seq 2 -> 4C0 3 -> 4C1 ; 4 -> 4c2 ; 5 -> 4C3  6 -> 4C4  4c0 + 4c1 + 4c2 + 4c3 + 4c4 1+4+6+4+1=16\\n    //1-5 3c0 + 3c1 + 3c2 + 3c3  = 8 \\n    //1-4 2c0 + 2c1 2c2 = 4\\n    //1-3 1c0 + 1c1  = 2\\n    //1-2 1c0 = 1\\n    \\n    /*16+8+4+2+1(for 1 as min) 8+4+2+1(for 2 as min)  4+2+1(for 3 as min)  2+1(for 4 as min)  1(for 5 as min)  \\n    -1*nums[0]*31 + nums[1]*1 + nums[2]*2 + nums[3]*4 + nums[4]*8 + nums[5]*16\\n        -1*nums[1]*15 + nums[2]*1 +nums[3]*2 + nums[4]*4 + nums[5]*8\\n        -1*nums[2]*7 + nums[3]*1 + nums[4]*2 + nums[5]*4\\n        -1*nums[3]*3 + nums[4]*1 + nums[5]*2\\n        -1*nums[4]*1 + nums[5]*1\\n        \\n        -nums[0]*31 + -nums[1]*15 - nums[2]*7 - nums[3]*3 - nums[4]*1\\n        nums[1]*1 + nums[2]*3 + nums[3]*7 + nums[4]*15 + nums[5]*31\\n    \\n    (-1)*nums[0]*(pow[6-1-0]-1) + (-1)*nums[1]*(pow[6-1-1]-1) + (-1)*nums[2]*(pow[6-1-2]-1)\\n    ... (-1)* nums[5]*(pow[6-1-5]-1)  \\n    + nums[1]*(pow[1]-1) + nums[2]*(pow[2]-1) + .... + nums[5]*(pow[5]-1)\\n    \\n    (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1)        \\n*/\\n    public int sumSubseqWidths(int[] A) {\\n        int MOD = 1_000_000_007;\\n        Arrays.sort(A);\\n        int l = A.length;\\n        long[] pow = new long[l];\\n        pow[0]=1;\\n        for(int i=1;i<l;i++){\\n            pow[i]=pow[i-1]*2 % MOD;\\n        }\\n        long res = 0;\\n        for(int i=0;i<l;i++){\\n            res = (res + (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1))%MOD;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669883,
                "title": "java-my-solution-with-explanation-runs-in-o-n-log-n-time-fermat-s-little-theorem",
                "content": "Let\\'s fix `i`-th element and `j`-th element in array.  The difference is `max(A[i], A[j]) - min(A[i], A[j])`. How many times do we need to add it? If there exist such an element `A[k]` with property `min(A[i], A[j]) <= A[k] <= max(A[i], A[j])` then we can place it in between and our difference will remains the same.\\nLet\\'s sort the array. Then it can be proven that there exist exactly `2 ^ (j - i)` such selections of numbers `k` where `i < j` (we can decide to place number in between or not to place it. This gives us 2 possibilities per such `k`. If there exist `n` such `k` numbers then we have `2 ^ n` possibilities to place some set of them). Now our time complexity is `O(n ^ 2)`. But it\\'s now enought to solve it.\\nWe can express our computations as following: \\n* `answer = sum((a[j] - a[i]) * 2 ^ (j - i))`\\n* `answer = (2^j - 1) * a[j] - (a[j - 1] * 2 ^ 0 + a[j - 2] * 2 ^ 1 + a[j - 3] * 2 ^ 2) `\\n\\nLet `prefix[i] = a[0] * 2^ (n - 1) + a[1] * 2 ^ (n - 2) + a[2] * 2 ^ (n - 3) + ... + a[i] * 2 ^ (n - i - 1)`. We can transform `prefix[3]` to `a[0] * 2 ^ 2 + a[1] * 2 ^ 1 + a[2] * 2 ^ 0` by dividing `prefix[i]` on `2 ^ (n - i - 1)`.\\n\\n* `answer = (2^j - 1) * a[j] - prefix[j-1] / 2 ^ (n - j)`\\n\\nSuch division is possible on Python, Ruby, but in Java we can\\'t divide because all our numbers are remainder by division on `MOD`. Common solution to do the division is [Fermat\\'s little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem). \\n\\n* `2 ^ -(n - j) = 2 ^ (MOD - (n - j) - 1) % MOD`\\n\\n```\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        \\n        int n = A.length;\\n        int[] bitsMod = calculateBits(n);\\n        long[] prefixSum = new long[n];\\n        \\n        long answer = 0;\\n        long divisor = power(power(2, MOD - 2), n);\\n        for (int i = 0; i < n; i++) {\\n            prefixSum[i] = i == 0 ? 0 : prefixSum[i-1];\\n            prefixSum[i] = (prefixSum[i] + (long) bitsMod[n - i - 1] * A[i]) % MOD;\\n            \\n            if (i > 0) {\\n                long multiplier = bitsMod[i] - 1;\\n                if (multiplier < 0) multiplier = MOD - 1;\\n                \\n                long firstTerm = A[i] * multiplier % MOD;\\n                long secondTerm = prefixSum[i - 1] * divisor % MOD;\\n                answer = (answer + firstTerm - secondTerm) % MOD;\\n                \\n                if (answer < 0) {\\n                    answer += MOD;\\n                }\\n            }\\n            \\n            divisor = (divisor * 2) % MOD;\\n        }\\n        \\n        return (int) answer;\\n    }\\n    \\n    private int[] calculateBits(int n) {\\n        int[] bits = new int[n];\\n        bits[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            bits[i] = (bits[i-1] << 1) % MOD;\\n        }\\n        \\n        return bits;\\n    }\\n    \\n    private long power(long a, long b) {\\n        if (b == 0) {\\n            return 1;\\n        }\\n        \\n        if (b % 2 == 0) {\\n            return power(a * a % MOD, b / 2);\\n        } else {\\n            return a * power(a, b - 1) % MOD;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        \\n        int n = A.length;\\n        int[] bitsMod = calculateBits(n);\\n        long[] prefixSum = new long[n];\\n        \\n        long answer = 0;\\n        long divisor = power(power(2, MOD - 2), n);\\n        for (int i = 0; i < n; i++) {\\n            prefixSum[i] = i == 0 ? 0 : prefixSum[i-1];\\n            prefixSum[i] = (prefixSum[i] + (long) bitsMod[n - i - 1] * A[i]) % MOD;\\n            \\n            if (i > 0) {\\n                long multiplier = bitsMod[i] - 1;\\n                if (multiplier < 0) multiplier = MOD - 1;\\n                \\n                long firstTerm = A[i] * multiplier % MOD;\\n                long secondTerm = prefixSum[i - 1] * divisor % MOD;\\n                answer = (answer + firstTerm - secondTerm) % MOD;\\n                \\n                if (answer < 0) {\\n                    answer += MOD;\\n                }\\n            }\\n            \\n            divisor = (divisor * 2) % MOD;\\n        }\\n        \\n        return (int) answer;\\n    }\\n    \\n    private int[] calculateBits(int n) {\\n        int[] bits = new int[n];\\n        bits[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            bits[i] = (bits[i-1] << 1) % MOD;\\n        }\\n        \\n        return bits;\\n    }\\n    \\n    private long power(long a, long b) {\\n        if (b == 0) {\\n            return 1;\\n        }\\n        \\n        if (b % 2 == 0) {\\n            return power(a * a % MOD, b / 2);\\n        } else {\\n            return a * power(a, b - 1) % MOD;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451179,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        l=len(A)\\n        res=0\\n        for i in range(l):\\n            res+=(A[i]<<i)-(A[i]<<(l-i-1))\\n        return res%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        l=len(A)\\n        res=0\\n        for i in range(l):\\n            res+=(A[i]<<i)-(A[i]<<(l-i-1))\\n        return res%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374028,
                "title": "bucket-sort-o-n-max-a-detailed-intuition",
                "content": "I will first give the intuition, then the solution using Sort, and then the solution using bucket Sort.\\n\\nThe intuition for this problem is pretty much the same as [sum of subarray minimums](https://leetcode.com/problems/sum-of-subarray-minimums/), where we compute the contribution of each A[i] to the result. (No worries if you haven\\'t yet seen that problem)\\n\\nThe first idea is to notice that  `sumWidths = sum(max - min) = sumMaxs - sumMins`\\n\\nFor [2, 4, 3], we have these subsequences: `[2], [4], [3], [2, 3], [2, 4], [4, 3], [2, 4, 3]`.\\n`3` will show up as maximum in 2 subsequences: `[3], [2, 3]` => So We add `3`*2 to sumMaxs.\\nAnd then as minimum in 2 subsequences: `[3], [4, 3]` => We add `3`*2 to sumMins.\\n\\nNow we can focus on how we can efficiently compute the number of contributions of an A[i] to sumMins (computing sumMaxs is similar)\\n\\nFor example in [1, 2, 4, 3], 2 appears as minimum in these subsequences:\\n`{2}, {2, 3}, {2, 4}, {2, 4, 3}`\\n\\nDiscarding the 2 from these subsequences we get: `{}, {3}, {4}, {3, 4}`.\\nThese are the *subsets* of {3, 4} !\\n\\nThe number of appearances of 2 in sumMins = the number of subsets of the set of elements higher than it\\nThe number of subsets of a set with size N is 2^N.\\n\\nSimilarly, the number of appearances of 2 in sumMaxs = the number of subsets of the set of elements smaller than it.\\n\\nThere is a small detail with duplicates, for a subsequence like [2, 2, 3, 4] we need to make sure we add 2 *once and only once* to sumMins\\n\\nThe first attempt to compute the number of elements higher and less than A[i] is to iterate over A for each i. This will have O(N^2) time complexity.\\nIf we sort the array the number of elements greater than A[i] is len(A)-i-1 and the number of elements smaller is i, which are computed in constant time.\\n\\nOrdering the array doesn\\'t have any effect on the result because min(A) = min(Sorted(A)) and max(A) = max(Sorted(A))\\n\\nDuplicates will be handled automatically when we sort.\\n\\nSo the overall time complexity is O(NlogN)\\n\\n```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\tA.sort()\\n\\tsumWidths = 0\\n\\tfor i, num in enumerate(A):\\n\\t\\tsumWidths += nb_sets(i)*num - nb_sets(len(A)-i-1)*num\\n\\treturn sumWidths % 1000000007\\n```\\n\\nNow, because max(A) is in the order of N like mentioned in the description, we can use bucket sort instead !\\nIn each bucket i we have the number of occurences of i in A.\\nWe maintain a variable `nbSmallerElements` that cumulates the count of numbers.\\n\\n```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\t\\t\\n\\tbuckets = [0]*(max(A)+1)\\n\\tfor num in A:\\n\\t\\tbuckets[num] += 1\\n\\n\\tsumWidths, nbSmallerElements = 0, 0\\n\\tfor num in range(len(buckets)):\\n\\t\\tfor _ in range(buckets[num]):\\n\\t\\t\\tsumWidths += nb_sets(nbSmallerElements)*num - nb_sets(len(A)-nbSmallerElements-1)*num\\n\\t\\t\\tnbSmallerElements += 1\\n\\treturn sumWidths % 1000000007\\n```\\n\\nThe time complexity is O(N+max(A)).",
                "solutionTags": [],
                "code": "```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\tA.sort()\\n\\tsumWidths = 0\\n\\tfor i, num in enumerate(A):\\n\\t\\tsumWidths += nb_sets(i)*num - nb_sets(len(A)-i-1)*num\\n\\treturn sumWidths % 1000000007\\n```\n```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\t\\t\\n\\tbuckets = [0]*(max(A)+1)\\n\\tfor num in A:\\n\\t\\tbuckets[num] += 1\\n\\n\\tsumWidths, nbSmallerElements = 0, 0\\n\\tfor num in range(len(buckets)):\\n\\t\\tfor _ in range(buckets[num]):\\n\\t\\t\\tsumWidths += nb_sets(nbSmallerElements)*num - nb_sets(len(A)-nbSmallerElements-1)*num\\n\\t\\t\\tnbSmallerElements += 1\\n\\treturn sumWidths % 1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161275,
                "title": "mathematical-sequence-problem-related-to-subsets",
                "content": "This is a mathematical sequence problem related to subsets. Obviously the order does not matter so we sort the numbers. Then for any two numbers with index i and j, ```0 <= i < j < n```, there are 2^(j-i-1) subsets with the same max-min difference. A naive approach to try all (i,j) pair would be O(N^2) time but we can optimize by calculating the coefficiences of each number linearly which leads to solution with O(N*log(N)) time complexcity.\\n\\nSpecifically by looking at all subsets with a[0] be the min/max number, the coefficient for a[0] is ```k[0] = -(2^0 + 2^1 + ... + 2^(n-2))=1-2^(n-1)```, by looking at all subsets with a[0] be the min/max number, coefficient for a[1] is ```k[1]=2^0-(2^0+2^1+...+2^(n-3)) = k[0]+2^0+2^(n-2)``` and in general ```k[i]=k[i-1]+2^(i-1)+2^(n-i-1)```. Code below:\\n\\n```\\n    public static int sumSubseqWidths(int[] A) {\\n        final long mod = 1000000007L;\\n        Arrays.sort(A);\\n        int n = A.length;\\n        // calculate power of 2 modular MOD\\n        long[] mp = new long[n];\\n        mp[0] = 1;\\n        for (int i = 1; i < n; i++) mp[i] = (mp[i-1] * 2) % mod;\\n        // calculate coefficients for each number\\n        long[] k = new long[n];\\n        k[0] = (1 + mod - mp[n-1]) % mod;\\n        for (int i = 1; i < n; i++) {\\n            k[i] = (k[i-1] + mp[i-1] + mp[n-i-1]) % mod;\\n        }\\n        // calculate total sum.\\n        long output = 0;\\n        for (int i = 0; i < n; i++) {\\n            output += k[i] * A[i];\\n        }\\n        return (int) (output % mod);\\n    }",
                "solutionTags": [],
                "code": "```0 <= i < j < n```\n```k[0] = -(2^0 + 2^1 + ... + 2^(n-2))=1-2^(n-1)```\n```k[1]=2^0-(2^0+2^1+...+2^(n-3)) = k[0]+2^0+2^(n-2)```\n```k[i]=k[i-1]+2^(i-1)+2^(n-i-1)```",
                "codeTag": "Unknown"
            },
            {
                "id": 161272,
                "title": "891-sum-of-subsequence-widths-c-sort-and-math-with-brief-explanation",
                "content": "1. Sort the array, because we need to know the largest number and smallest number for each pair.\\n2. \\tFor pair A[i] and A[j],they can have 2^(j - i - 1) different subsequence(s) in the array, which means that you can insert 2^(j - i - 1) possibilities and the largest and smallest values are A[j] and A[i].\\n3. \\tMath: For the length of k, k is the distance of max number A[j] and min number A[i]\\nand k = j - i\\nk = 1: A[1] - A[0], A[2] - A[1] ....., A[n-1] - A[n-2], sum all of them: which is just A[n-1] - A[0]\\nso: generally, for length k, the sum of withds are:\\nA[n-1] + A[n-2] + .... + A[n-k] - A[0] - A[1] - ... - A[k - 1]\\nso we can use S to store the sum at every step.\\n\\n\\n\\n\\t\\n\\t\\n\\n\\n\\n\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\t\\t\\t\\tint MOD = 1000000007;\\n\\t\\t\\t\\t\\t\\tsort(A.begin(), A.end());\\n\\t\\t\\t\\t\\t\\tint n = A.size();\\n\\t\\t\\t\\t\\t\\tvector<long> vec(n, 1);\\n\\t\\t\\t\\t\\t\\tfor(int i = 1; i < n; ++i){\\n\\t\\t\\t\\t\\t\\t\\t\\tvec[i] = vec[i-1]*2 % MOD;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\t\\t\\tint i = n-1;\\n\\t\\t\\t\\t\\t\\tint S = 0;\\n\\t\\t\\t\\t\\t\\tfor(int len = 1; len < n; ++len){\\n\\t\\t\\t\\t\\t\\t\\t\\tS = S + A[i] - A[n - 1 - i];\\n\\t\\t\\t\\t\\t\\t\\t\\tres = (res + S * vec[len - 1] % MOD) % MOD;\\n\\t\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\t\\t\\t\\tint MOD = 1000000007;\\n\\t\\t\\t\\t\\t\\tsort(A.begin(), A.end());\\n\\t\\t\\t\\t\\t\\tint n = A.size();\\n\\t\\t\\t\\t\\t\\tvector<long> vec(n, 1);\\n\\t\\t\\t\\t\\t\\tfor(int i = 1; i < n; ++i){\\n\\t\\t\\t\\t\\t\\t\\t\\tvec[i] = vec[i-1]*2 % MOD;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4073740,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }\\n        return (int)width;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }\\n        return (int)width;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924148,
                "title": "python-solution-less-than-10-lines-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe input size is large so we find an approach that accumulates the answer at the position `i` with the information from the position `i-1`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort `nums` and compute the answer from the smallest to the largest. \\nAt `i` (`nums[0] < nums[1] < ... < nums[i]`), we define $$A_i$$ as the sum of widths of all the subsequences of `nums[0:i]` that ends at `i`. \\n\\n$$A_i = \\\\sum_{j=0}^{i-1}\\\\left( A_j + 2^j (\\\\textrm{nums}[i] - \\\\textrm{nums}[j])\\\\right) = A_{i-1} + \\\\delta_i$$\\n\\nwhere $$\\\\delta_i = \\\\sum_{j=0}^{i-1}2^j (\\\\textrm{nums}[i] - \\\\textrm{nums}[j])$$ that be defined in a recursive way as follows: \\n\\n$$ \\\\delta_i = \\\\delta_{i-1} + \\\\sum_{k=0}^{i-1}2^k (\\\\textrm{nums}[i] - \\\\textrm{nums}[i-1]) $$\\n\\nIn this way, we can maintain $$A_i$$ and $$\\\\delta_i$$ iteractively and obtain the final solution in linear time. \\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$ for sorting\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Only $$O(1)$$ extra memory\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = delta = 0\\n        accu_k = k = 1\\n        for u, v in zip(nums, nums[1:]):\\n            delta = (delta + accu_k * (v - u)) % 1000000007 \\n            ans = (ans + ans + delta) % 1000000007\\n            k = (k * 2) % 1000000007\\n            accu_k = (accu_k + k) % 1000000007\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = delta = 0\\n        accu_k = k = 1\\n        for u, v in zip(nums, nums[1:]):\\n            delta = (delta + accu_k * (v - u)) % 1000000007 \\n            ans = (ans + ans + delta) % 1000000007\\n            k = (k * 2) % 1000000007\\n            accu_k = (accu_k + k) % 1000000007\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885067,
                "title": "cpp-amazon-most-asked-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n         sort(nums.begin(),nums.end());\\n    vector<long>p(n,0);\\n    p[0]=1;\\n    for(int i=1;i<n;i++){\\n        p[i]=(p[i-1]*2) % (1000000007);\\n    }\\n      \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(p[i]-p[n-i-1])) % (1000000007);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n         sort(nums.begin(),nums.end());\\n    vector<long>p(n,0);\\n    p[0]=1;\\n    for(int i=1;i<n;i++){\\n        p[i]=(p[i-1]*2) % (1000000007);\\n    }\\n      \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(p[i]-p[n-i-1])) % (1000000007);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866425,
                "title": "easy-to-understand-java-solution",
                "content": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        long mod=1000000007;\\n        int n=nums.length;\\n        long[] pow=new long[n];\\n        pow[0]=1;\\n\\n        for(int i=1;i<n;i++){\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            ans+=nums[i]*pow[i];\\n            ans-=nums[i]*pow[n-i-1];\\n            ans=ans%mod;\\n        }\\n\\n        return (int) ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        long mod=1000000007;\\n        int n=nums.length;\\n        long[] pow=new long[n];\\n        pow[0]=1;\\n\\n        for(int i=1;i<n;i++){\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3820577,
                "title": "dp",
                "content": "\\n# Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        mod = 10**9 + 7\\n\\n        # Calculate powers of 2 modulo mod\\n        powers_of_2 = [1]\\n        for i in range(1, n):\\n            powers_of_2.append((powers_of_2[-1] * 2) % mod)\\n\\n        # Calculate the sum of widths\\n        ans = 0\\n        for i in range(n):\\n            ans = (ans + nums[i] * (powers_of_2[i] - powers_of_2[n-i-1])) % mod\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        mod = 10**9 + 7\\n\\n        # Calculate powers of 2 modulo mod\\n        powers_of_2 = [1]\\n        for i in range(1, n):\\n            powers_of_2.append((powers_of_2[-1] * 2) % mod)\\n\\n        # Calculate the sum of widths\\n        ans = 0\\n        for i in range(n):\\n            ans = (ans + nums[i] * (powers_of_2[i] - powers_of_2[n-i-1])) % mod\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804670,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626631,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def sumSubseqWidths(nums: Array[Int]): Int = {\\n      val twoPower = Array.ofDim[Long](nums.length)\\n      val mod = 1000000007L\\n      twoPower(0) = 1\\n      for (i <- 1 until nums.length) twoPower(i) = (twoPower(i - 1) * 2) % mod\\n      val effective = Array.ofDim[Long](nums.length)\\n      for (i <- nums.indices) effective(i) = twoPower(i) - twoPower(nums.length - i - 1)\\n      val sorted= nums.sorted\\n      var ans = 0L\\n      for (i <- nums.indices) ans = (ans + effective(i) * sorted(i)) % mod\\n      ans.toInt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def sumSubseqWidths(nums: Array[Int]): Int = {\\n      val twoPower = Array.ofDim[Long](nums.length)\\n      val mod = 1000000007L\\n      twoPower(0) = 1\\n      for (i <- 1 until nums.length) twoPower(i) = (twoPower(i - 1) * 2) % mod\\n      val effective = Array.ofDim[Long](nums.length)\\n      for (i <- nums.indices) effective(i) = twoPower(i) - twoPower(nums.length - i - 1)\\n      val sorted= nums.sorted\\n      var ans = 0L\\n      for (i <- nums.indices) ans = (ans + effective(i) * sorted(i)) % mod\\n      ans.toInt\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3453393,
                "title": "easy-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nPhase-1-> ans=0+(1-3)*1\\n          ans=-2%kmod\\n          exp=1*2%kmod\\nPhase-2-> ans=(-2)+(2-2)*2\\n          ans=-2%kmod\\n          exp=2*2%kmod\\nPhase-3-> ans=(-2)+(3-1)*4\\n          ans=6%kmod\\n          exp=4*2%kmod \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        kMod = 10**9+7\\n        n = len(nums)\\n        ans = 0\\n        exp = 1\\n        nums.sort()\\n        for i in range(n):\\n            ans += (nums[i] - nums[n - i - 1]) * exp\\n            ans %= kMod\\n            exp = exp * 2 % kMod\\n        return ans\\n\\n\\n    # pass only 19 test cases occer TLE problem\\n         result = [[]]\\n         for i in nums:\\n             n = len(result)\\n             for j in range(n):\\n                 r = result[j] + [i]\\n                 result.append(r)        \\n         s=[]\\n         for i in result[1:]:\\n             a=max(i)\\n             b=min(i)\\n             s.append(a-b)\\n         return sum(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        kMod = 10**9+7\\n        n = len(nums)\\n        ans = 0\\n        exp = 1\\n        nums.sort()\\n        for i in range(n):\\n            ans += (nums[i] - nums[n - i - 1]) * exp\\n            ans %= kMod\\n            exp = exp * 2 % kMod\\n        return ans\\n\\n\\n    # pass only 19 test cases occer TLE problem\\n         result = [[]]\\n         for i in nums:\\n             n = len(result)\\n             for j in range(n):\\n                 r = result[j] + [i]\\n                 result.append(r)        \\n         s=[]\\n         for i in result[1:]:\\n             a=max(i)\\n             b=min(i)\\n             s.append(a-b)\\n         return sum(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393106,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        LL M = 1e9 + 7 ;\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        vector<LL>pow(n) ;\\n        pow[0] = 1 ;\\n        for(int i = 1; i < n; i++){\\n            pow[i] = (pow[i-1]*2) % M ;\\n        }\\n        \\n        LL sum = 0 ;\\n        for(int i = n-1; i >= 0; i--){\\n            sum = (sum + nums[i] * pow[i]%M) % M ;\\n            sum = (sum - nums[i] * pow[n-1-i]%M + M) % M ;\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        LL M = 1e9 + 7 ;\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        vector<LL>pow(n) ;\\n        pow[0] = 1 ;\\n        for(int i = 1; i < n; i++){\\n            pow[i] = (pow[i-1]*2) % M ;\\n        }\\n        \\n        LL sum = 0 ;\\n        for(int i = n-1; i >= 0; i--){\\n            sum = (sum + nums[i] * pow[i]%M) % M ;\\n            sum = (sum - nums[i] * pow[n-1-i]%M + M) % M ;\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384340,
                "title": "c-simple-and-explained-solution-o-n-log-n-sort-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nafter sorting we just have to figure out how many subsequences will be there in which a particular number will be maximum and other  minimum\\nhowever our final ans will be=diff1 x (no of subsequence whose width is this max and min are same) + diff2 x n2 + diff3 x n3+...\\nNow, this can be expanded into\\nans=max1(no. of subseq. in which max1 is maximum)+max2xn2+...-min1 x (n1) - min2*(n2)-...    ..eq 1(say)\\nas ...+diff(i)*(n)+..=...+(max(i)-min(i)) x (n)+..\\n=..+max(i)xn-min(i)xn+...\\nnow separating positive and negative terms will give us eqn 1.\\nnow in a sorted array\\narr[0],arr[1],...,arr[i],..arr[j],..arr[n-1]\\nstarting from arr[1]->arr[n-1] calculating how many subsequences can be there where these will be the maximum \\nno of subsequences in which arr[i] can be the maximum = no. of subsequences  that can end at arr[i] and containing zero or more elements smaller than this for ith index no of elements smaller than this i =c(i,0) + c(i,1)+c(i,2)+..+c(i,i)=2^i - 1\\nnow using this formula we can evaluate no of subsequences in which arr[i] will be maximum and add the max_i x (ni) to ans\\nand similarly for minimums in reverse fashion from n-2 -> 0 subsequences will contain elements afyer this ith element (>=arr[i])\\nans-=min_i*(n_i);\\nreturn this ans\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting + maths\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n x log(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n\\n\\n**PLS UPVOTE IF IT HELPED**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        long long ans=0;\\n        int m=1e9+7;\\n        sort(nums.begin(),nums.end());\\n        long long pre=0;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans-=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        pre=0;\\n        for(int i=1;i<nums.size();i++){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans+=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        long long ans=0;\\n        int m=1e9+7;\\n        sort(nums.begin(),nums.end());\\n        long long pre=0;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans-=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        pre=0;\\n        for(int i=1;i<nums.size();i++){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans+=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294924,
                "title": "basic-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n= nums.size();\\n        int i;\\n        int j = n-1;\\n        sort(nums.begin(), nums.end());\\n        long long int m=1;\\n        long long int x = 1e9+7;\\n        int result =0;\\n        for(int i=0; i<n; i++)\\n        {\\n            result = (result + m*nums[i] - m*nums[j])%x;\\n            m = (m*2)%x;\\n            j--;\\n        }\\n        return (int)result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n= nums.size();\\n        int i;\\n        int j = n-1;\\n        sort(nums.begin(), nums.end());\\n        long long int m=1;\\n        long long int x = 1e9+7;\\n        int result =0;\\n        for(int i=0; i<n; i++)\\n        {\\n            result = (result + m*nums[i] - m*nums[j])%x;\\n            m = (m*2)%x;\\n            j--;\\n        }\\n        return (int)result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195161,
                "title": "o-max-time-complexity-counting-sort-python",
                "content": "Since the range of numbers are small, we can sort number in ```O(n)``` time complexity with counting sort.\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        mx = max(nums)\\n        cnt = [0] * (mx + 1)\\n        for num in nums:\\n            cnt[num] += 1\\n        \\n        smaller = [0] + list(accumulate(cnt))\\n        greater = list(accumulate(cnt[::-1]))[::-1] + [0]\\n\\n        ans = 0\\n        nums = set(nums)\\n        for num in nums:\\n            ans += (pow(2, smaller[num], mod) - pow(2, greater[num + 1], mod)) * (pow(2, cnt[num], mod) - 1) * num\\n            ans %= mod\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```O(n)```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        mx = max(nums)\\n        cnt = [0] * (mx + 1)\\n        for num in nums:\\n            cnt[num] += 1\\n        \\n        smaller = [0] + list(accumulate(cnt))\\n        greater = list(accumulate(cnt[::-1]))[::-1] + [0]\\n\\n        ans = 0\\n        nums = set(nums)\\n        for num in nums:\\n            ans += (pow(2, smaller[num], mod) - pow(2, greater[num + 1], mod)) * (pow(2, cnt[num], mod) - 1) * num\\n            ans %= mod\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184377,
                "title": "java-current-element-effect",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    long[] power;\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        power = new long[len];\\n        initPower();\\n        long ans = 0;\\n        for (int i = 0; i < len; i++) {\\n            ans = (ans + (nums[i] * effect(i, len)) % mod) % mod;\\n        }\\n        return (int)ans % mod;\\n    }\\n\\n    private long effect(int curr, int len) {\\n        long plus = power[curr];\\n        long minus = power[len - curr - 1];\\n        return (plus - minus + mod) % mod;\\n    }\\n    private void initPower() {\\n        power[0] = 1;\\n        for (int i = 1; i < power.length; i ++)\\n            power[i] = (2 * power[i-1]) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    long[] power;\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        power = new long[len];\\n        initPower();\\n        long ans = 0;\\n        for (int i = 0; i < len; i++) {\\n            ans = (ans + (nums[i] * effect(i, len)) % mod) % mod;\\n        }\\n        return (int)ans % mod;\\n    }\\n\\n    private long effect(int curr, int len) {\\n        long plus = power[curr];\\n        long minus = power[len - curr - 1];\\n        return (plus - minus + mod) % mod;\\n    }\\n    private void initPower() {\\n        power[0] = 1;\\n        for (int i = 1; i < power.length; i ++)\\n            power[i] = (2 * power[i-1]) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178235,
                "title": "solve-on-paper-first-for-sorted-array",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(nums)\\n        nums.sort()\\n        res = 0\\n        powt = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            powt[i] = 2 * powt[i - 1]\\n            powt[i] %= M\\n        res = 0\\n        for i in range(n):\\n            res += nums[i] * (powt[i] - 1)\\n            res -= nums[i] * (powt[n - i - 1] - 1)\\n            res %= M\\n        return (M + res) % M\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(nums)\\n        nums.sort()\\n        res = 0\\n        powt = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            powt[i] = 2 * powt[i - 1]\\n            powt[i] %= M\\n        res = 0\\n        for i in range(n):\\n            res += nums[i] * (powt[i] - 1)\\n            res -= nums[i] * (powt[n - i - 1] - 1)\\n            res %= M\\n        return (M + res) % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166228,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExpression can  be broken down to\\n```\\nsum of widths of all subsequences = sum of maximuns of all subsequences - sum of minimums of all subsequences.\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCounting contribution of each number to wanted expression, i.e. number of subsequences in which number is maximum or minimum.\\nOther details in code comments\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n  public int sumSubseqWidths(int[] nums) {\\n    // For N numbers there are 2^N subsequences (either take or don\\'t the next element for N elements)\\n    //\\n    // Rearranging wanted expression we get to:\\n    //    \\n    //    -> Sum of subsequence widths = Sum of subsequence max - (Sum of subsequence mins)\\n    //\\n    // For each number n in nums, find the number of subsequences in \\n    // which n is the maximum, and the number of subsequences in which\\n    // n is the minimum.\\n    //                                                   pows: [ 1, 2, 4]\\n    // E.g. nums = [3, -1, 7], sorting the array for easily counting: [-1, 3, 7]\\n    //\\n    // From the 2^3 = 8 subsequences, how -1 contributes? It is the maximum of 1 (2\\u2070) sequences,\\n    // and the minimum of 4 (2\\xB2)\\n    //\\n    // How 3 contribues? It is the maximum of 2 sequences (2\\xB9) and minimum of 2 sequences (2\\xB9)\\n    //\\n    // how 7 contributes? It is the maximum of 4 sequences (2\\xB2) and minimum of 1 (2\\u2070) \\n    //\\n    // Sum of maximums: -1 * 1 + 3 * 2 + 7 * 4\\n    // Sum of minimums: -1 * 4 + 3 * 2 + 7 * 1\\n    // ----------------------------------------\\n    //                  -1 * (-3) + 7 * 3         = 3 + 21 = 24 \\n    //\\n    //\\n    //\\n    //\\n    // Also notice some modulo properties:\\n    //\\n    // (a + b) % c = ((a % c) + b) % c\\n    // (a * b) % c = ((a % c) * b) % c\\n    //\\n    //\\n    long mod = 1000000007;\\n    int n = nums.length;\\n    long[] pow = new long[n];\\n    pow[0] = 1;\\n    for (int i = 1; i < n; i ++)\\n      pow[i] = (2 * pow[i-1]) % mod;\\n    Arrays.sort(nums);\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      // number of subsequences in which nums[i] is the maximum\\n      long largest = pow[i];\\n      // number of subsequences in which nums[i] is the minimum\\n      long smallest = pow[n-i-1];\\n      // Contribution of nums[i] = largest * nums[i] - smallest * nums[i]\\n      //                         = (largest - smallest) * nums[i]\\n      ans = (int) ((ans + (nums[i] * (largest - smallest) % mod) % mod) % mod);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nsum of widths of all subsequences = sum of maximuns of all subsequences - sum of minimums of all subsequences.\\n```\n```\\nclass Solution {\\n\\n\\n  public int sumSubseqWidths(int[] nums) {\\n    // For N numbers there are 2^N subsequences (either take or don\\'t the next element for N elements)\\n    //\\n    // Rearranging wanted expression we get to:\\n    //    \\n    //    -> Sum of subsequence widths = Sum of subsequence max - (Sum of subsequence mins)\\n    //\\n    // For each number n in nums, find the number of subsequences in \\n    // which n is the maximum, and the number of subsequences in which\\n    // n is the minimum.\\n    //                                                   pows: [ 1, 2, 4]\\n    // E.g. nums = [3, -1, 7], sorting the array for easily counting: [-1, 3, 7]\\n    //\\n    // From the 2^3 = 8 subsequences, how -1 contributes? It is the maximum of 1 (2\\u2070) sequences,\\n    // and the minimum of 4 (2\\xB2)\\n    //\\n    // How 3 contribues? It is the maximum of 2 sequences (2\\xB9) and minimum of 2 sequences (2\\xB9)\\n    //\\n    // how 7 contributes? It is the maximum of 4 sequences (2\\xB2) and minimum of 1 (2\\u2070) \\n    //\\n    // Sum of maximums: -1 * 1 + 3 * 2 + 7 * 4\\n    // Sum of minimums: -1 * 4 + 3 * 2 + 7 * 1\\n    // ----------------------------------------\\n    //                  -1 * (-3) + 7 * 3         = 3 + 21 = 24 \\n    //\\n    //\\n    //\\n    //\\n    // Also notice some modulo properties:\\n    //\\n    // (a + b) % c = ((a % c) + b) % c\\n    // (a * b) % c = ((a % c) * b) % c\\n    //\\n    //\\n    long mod = 1000000007;\\n    int n = nums.length;\\n    long[] pow = new long[n];\\n    pow[0] = 1;\\n    for (int i = 1; i < n; i ++)\\n      pow[i] = (2 * pow[i-1]) % mod;\\n    Arrays.sort(nums);\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      // number of subsequences in which nums[i] is the maximum\\n      long largest = pow[i];\\n      // number of subsequences in which nums[i] is the minimum\\n      long smallest = pow[n-i-1];\\n      // Contribution of nums[i] = largest * nums[i] - smallest * nums[i]\\n      //                         = (largest - smallest) * nums[i]\\n      ans = (int) ((ans + (nums[i] * (largest - smallest) % mod) % mod) % mod);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093598,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9+7\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9+7\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912273,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864499,
                "title": "beats-95-6-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long a = 1;\\n        long res = 0;\\n        long mod = (long) 1e9 + 7;\\n        for(int i = 0; i < nums.length; ++i, a = (a * 2) % mod) res = (res + nums[i] * a - nums[nums.length - i - 1] * a) % mod;\\n        return (int) ((res + mod) % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long a = 1;\\n        long res = 0;\\n        long mod = (long) 1e9 + 7;\\n        for(int i = 0; i < nums.length; ++i, a = (a * 2) % mod) res = (res + nums[i] * a - nums[nums.length - i - 1] * a) % mod;\\n        return (int) ((res + mod) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839381,
                "title": "math-dp",
                "content": "# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        nums.sort()\\n\\n        dp = [0] * n\\n\\n        p = 2\\n        temp = nums[0]\\n\\n        for i in range(1, n):\\n            dp[i] = ((dp[i-1] + ((p-1)*nums[i])%MOD)%MOD - temp)%MOD\\n            p = (2*p)%MOD\\n            temp = ((2*temp)%MOD + nums[i])%MOD\\n        \\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        nums.sort()\\n\\n        dp = [0] * n\\n\\n        p = 2\\n        temp = nums[0]\\n\\n        for i in range(1, n):\\n            dp[i] = ((dp[i-1] + ((p-1)*nums[i])%MOD)%MOD - temp)%MOD\\n            p = (2*p)%MOD\\n            temp = ((2*temp)%MOD + nums[i])%MOD\\n        \\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839218,
                "title": "rust-version",
                "content": "# Code\\nCredit: https://leetcode.com/problems/sum-of-subsequence-widths/solutions/2791666/c-easy-shorts/\\n```\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn sum_subseq_widths(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n\\n        let mut c = 1;\\n        let mut result: i64 = 0;\\n        let n = nums.len();\\n\\n        for i in 0..n {\\n            result = (result + nums[i] as i64 * c - nums[n - i - 1] as i64 * c) % MOD;\\n            c = c * 2 % MOD;\\n        }\\n\\n        ((result + MOD) % MOD) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn sum_subseq_widths(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n\\n        let mut c = 1;\\n        let mut result: i64 = 0;\\n        let n = nums.len();\\n\\n        for i in 0..n {\\n            result = (result + nums[i] as i64 * c - nums[n - i - 1] as i64 * c) % MOD;\\n            c = c * 2 % MOD;\\n        }\\n\\n        ((result + MOD) % MOD) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2825898,
                "title": "python-solution-math-property-faster-than-98-time-o-nlog-space-o-1",
                "content": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t\\t\\tk_mod = 10**9 + 7\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tnums_len = len(nums)\\n\\n\\t\\t\\tp = 2**0\\n\\t\\t\\tres = 0 \\n\\t\\t\\tfor i in range(nums_len): \\n\\t\\t\\t\\tres += (nums[i] - nums[nums_len-i-1])*p % k_mod\\n\\t\\t\\t\\tp = (p<<1) % k_mod\\n\\t\\t\\treturn res % k_mod        \\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t\\t\\tk_mod = 10**9 + 7\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tnums_len = len(nums)\\n\\n\\t\\t\\tp = 2**0\\n\\t\\t\\tres = 0 \\n\\t\\t\\tfor i in range(nums_len): \\n\\t\\t\\t\\tres += (nums[i] - nums[nums_len-i-1])*p % k_mod\\n\\t\\t\\t\\tp = (p<<1) % k_mod\\n\\t\\t\\treturn res % k_mod        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2724415,
                "title": "javascript-sort-and-one-traversal",
                "content": "```\\nvar sumSubseqWidths = function(nums) {\\n    nums.sort((b, a) => b - a);\\n\\n    let sumOfWidths = 0, mod = 1000000007;\\n\\n    for (let i = 0, nCr = 1; i < nums.length; i++) {\\n        sumOfWidths = (sumOfWidths + nCr * (nums[i] - nums[nums.length - 1 - i]) % mod) % mod;\\n        nCr = (nCr << 1) % mod;\\n    }\\n\\n    return sumOfWidths;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar sumSubseqWidths = function(nums) {\\n    nums.sort((b, a) => b - a);\\n\\n    let sumOfWidths = 0, mod = 1000000007;\\n\\n    for (let i = 0, nCr = 1; i < nums.length; i++) {\\n        sumOfWidths = (sumOfWidths + nCr * (nums[i] - nums[nums.length - 1 - i]) % mod) % mod;\\n        nCr = (nCr << 1) % mod;\\n    }\\n\\n    return sumOfWidths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589963,
                "title": "reminder-subsequences-with-same-elements-in-same-order-are-different",
                "content": "For [1,2,2], if we ignore the dublicate, here are all subsequences, [1], [2], [2], [1,2], [1,2], [1,2,2]. \\n0+0+0+1+1+1 = 3\\nWe get the answer is 3.\\n[1,2] and [1,2] are treated as different sequence in this problem.",
                "solutionTags": [],
                "code": "For [1,2,2], if we ignore the dublicate, here are all subsequences, [1], [2], [2], [1,2], [1,2], [1,2,2]. \\n0+0+0+1+1+1 = 3\\nWe get the answer is 3.\\n[1,2] and [1,2] are treated as different sequence in this problem.",
                "codeTag": "Unknown"
            },
            {
                "id": 2589520,
                "title": "c-the-most-complicated-solution",
                "content": "```cpp\\n#define all(x) begin(x), end(x)\\n#define has(c, x) (c.find(x) != c.end())\\n#define vec vector\\n#define umap unordered_map\\n#define uset unordered_set\\n#define valid(i, j, m, n) (i >= 0 && i < m && j >= 0 && j < n)\\n\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\ntemplate <typename T> T &amax(T &a, const T &b) { return a = max(a, b); }\\n\\nusing ll = long long;\\nusing pii = pair<int, int>;\\nusing pll = pair<ll, ll>;\\nusing vi = vec<int>;\\nusing vvi = vec<vec<int>>;\\nusing vvvi = vec<vec<vec<int>>>;\\nusing vl = vec<ll>;\\nusing vvl = vec<vec<ll>>;\\nusing vs = vec<string>;\\nusing vvs = vec<vec<string>>;\\nusing vpii = vec<pii>;\\nusing vvpii = vec<vec<pii>>;\\nusing tiii = tuple<int, int, int>;\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, -1, 1, 0, -1, 1, -1, 1};\\nconstexpr int MXN = (int)1e6;\\nconstexpr int INF = (int)1e9 + 15;\\nconstexpr ll INFL = ll(1e18) + 15;\\nconstexpr double EPS = 1e-9;\\nconstexpr int P = 31;\\nconstexpr int P2 = 33;\\nconstexpr int M = (int)1e9 + 7;\\nconstexpr int M2 = (int)1e9 + 9;\\n\\nconstexpr ll binpow(ll a, ll b, ll m) {\\n  a %= m;\\n  ll res = 1;\\n  while (b > 0) {\\n    if (b & 1)\\n      res = res * a % m;\\n    a = a * a % m;\\n    b >>= 1;\\n  }\\n  return res;\\n}\\nconstexpr int extended_gcd(int a, int b, int &x, int &y) {\\n  x = 1, y = 0;\\n  int x1 = 0, y1 = 1, a1 = a, b1 = b;\\n  while (b1) {\\n    int q = a1 / b1;\\n    tie(x, x1) = make_tuple(x1, x - q * x1);\\n    tie(y, y1) = make_tuple(y1, y - q * y1);\\n    tie(a1, b1) = make_tuple(b1, a1 - q * b1);\\n  }\\n  return a1;\\n}\\n\\nclass Solution {\\npublic:\\n  int sumSubseqWidths(vector<int> &nums) {\\n    map<int, int> mp;\\n    for (int v : nums) {\\n      mp[v]++;\\n    }\\n    vpii p(all(mp));\\n    int n = p.size();\\n\\n    ll ans = 0, res = 0, between_subsets = 1, subsets_cnt = 0;\\n    for (int i = 1; i < n; i++) {\\n      ll diff = p[i].first - p[0].first;\\n      ll left_subsets = binpow(2, p[0].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i].second, M) - 1;\\n      ll end_subsets = (left_subsets * right_subsets) % M;\\n\\n      res += (diff * (end_subsets * between_subsets) % M) % M;\\n      res %= M;\\n\\n      subsets_cnt += (end_subsets * between_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      between_subsets *= right_subsets + 1;\\n      between_subsets %= M;\\n    }\\n    for (int i = 0; i < n - 1; i++) {\\n      ans += res;\\n      ans %= M;\\n\\n      ll diff = p[i + 1].first - p[i].first;\\n      ll left_subsets = binpow(2, p[i].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i + 1].second, M) - 1;\\n\\n      res -= (diff * (left_subsets * right_subsets) % M) % M;\\n      res = (res % M + M) % M;\\n      subsets_cnt -= (left_subsets * right_subsets) % M;\\n      subsets_cnt = (subsets_cnt % M + M) % M;\\n\\n      ll k = n - i - 2;\\n      ll remove = (k * (left_subsets * (right_subsets + 1) % M) % M) % M;\\n      int inv_remove, y;\\n      extended_gcd(remove, M, inv_remove, y);\\n      inv_remove = (inv_remove % M + M) % M;\\n\\n      res *= inv_remove;\\n      res %= M;\\n      res *= (k * right_subsets) % M;\\n      res %= M;\\n\\n      subsets_cnt *= inv_remove;\\n      subsets_cnt %= M;\\n      subsets_cnt *= (k * right_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      res -= (subsets_cnt * diff) % M;\\n      res = (res % M + M) % M;\\n    }\\n    return ans;\\n  }\\n};\\n#endif\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```cpp\\n#define all(x) begin(x), end(x)\\n#define has(c, x) (c.find(x) != c.end())\\n#define vec vector\\n#define umap unordered_map\\n#define uset unordered_set\\n#define valid(i, j, m, n) (i >= 0 && i < m && j >= 0 && j < n)\\n\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\ntemplate <typename T> T &amax(T &a, const T &b) { return a = max(a, b); }\\n\\nusing ll = long long;\\nusing pii = pair<int, int>;\\nusing pll = pair<ll, ll>;\\nusing vi = vec<int>;\\nusing vvi = vec<vec<int>>;\\nusing vvvi = vec<vec<vec<int>>>;\\nusing vl = vec<ll>;\\nusing vvl = vec<vec<ll>>;\\nusing vs = vec<string>;\\nusing vvs = vec<vec<string>>;\\nusing vpii = vec<pii>;\\nusing vvpii = vec<vec<pii>>;\\nusing tiii = tuple<int, int, int>;\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, -1, 1, 0, -1, 1, -1, 1};\\nconstexpr int MXN = (int)1e6;\\nconstexpr int INF = (int)1e9 + 15;\\nconstexpr ll INFL = ll(1e18) + 15;\\nconstexpr double EPS = 1e-9;\\nconstexpr int P = 31;\\nconstexpr int P2 = 33;\\nconstexpr int M = (int)1e9 + 7;\\nconstexpr int M2 = (int)1e9 + 9;\\n\\nconstexpr ll binpow(ll a, ll b, ll m) {\\n  a %= m;\\n  ll res = 1;\\n  while (b > 0) {\\n    if (b & 1)\\n      res = res * a % m;\\n    a = a * a % m;\\n    b >>= 1;\\n  }\\n  return res;\\n}\\nconstexpr int extended_gcd(int a, int b, int &x, int &y) {\\n  x = 1, y = 0;\\n  int x1 = 0, y1 = 1, a1 = a, b1 = b;\\n  while (b1) {\\n    int q = a1 / b1;\\n    tie(x, x1) = make_tuple(x1, x - q * x1);\\n    tie(y, y1) = make_tuple(y1, y - q * y1);\\n    tie(a1, b1) = make_tuple(b1, a1 - q * b1);\\n  }\\n  return a1;\\n}\\n\\nclass Solution {\\npublic:\\n  int sumSubseqWidths(vector<int> &nums) {\\n    map<int, int> mp;\\n    for (int v : nums) {\\n      mp[v]++;\\n    }\\n    vpii p(all(mp));\\n    int n = p.size();\\n\\n    ll ans = 0, res = 0, between_subsets = 1, subsets_cnt = 0;\\n    for (int i = 1; i < n; i++) {\\n      ll diff = p[i].first - p[0].first;\\n      ll left_subsets = binpow(2, p[0].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i].second, M) - 1;\\n      ll end_subsets = (left_subsets * right_subsets) % M;\\n\\n      res += (diff * (end_subsets * between_subsets) % M) % M;\\n      res %= M;\\n\\n      subsets_cnt += (end_subsets * between_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      between_subsets *= right_subsets + 1;\\n      between_subsets %= M;\\n    }\\n    for (int i = 0; i < n - 1; i++) {\\n      ans += res;\\n      ans %= M;\\n\\n      ll diff = p[i + 1].first - p[i].first;\\n      ll left_subsets = binpow(2, p[i].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i + 1].second, M) - 1;\\n\\n      res -= (diff * (left_subsets * right_subsets) % M) % M;\\n      res = (res % M + M) % M;\\n      subsets_cnt -= (left_subsets * right_subsets) % M;\\n      subsets_cnt = (subsets_cnt % M + M) % M;\\n\\n      ll k = n - i - 2;\\n      ll remove = (k * (left_subsets * (right_subsets + 1) % M) % M) % M;\\n      int inv_remove, y;\\n      extended_gcd(remove, M, inv_remove, y);\\n      inv_remove = (inv_remove % M + M) % M;\\n\\n      res *= inv_remove;\\n      res %= M;\\n      res *= (k * right_subsets) % M;\\n      res %= M;\\n\\n      subsets_cnt *= inv_remove;\\n      subsets_cnt %= M;\\n      subsets_cnt *= (k * right_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      res -= (subsets_cnt * diff) % M;\\n      res = (res % M + M) % M;\\n    }\\n    return ans;\\n  }\\n};\\n#endif\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557241,
                "title": "c-solution-with-explanation",
                "content": "The idea is to count in how many subsets an element will be minimum and maximum, by summing all the values will give the answer.\\n\\nFor an elements A_i to be minimum in a subset, all the elements in the subset must be greater or equal to A_i, and for it to be maximum all the elements in the subset must be lesser or equal to A_i. \\n\\nTo obtain the number of subsets that are possible with A_i as minimum, we can sort the whole array, and if for any element index at i, all the numbers above will be greater and all the subsets that can be formed with those elements have minimum >= i_th element, if we add a_i to every set that is possible with the elements greater than a_i will always be minimum in those sets. And similarly we can do for i_th element to be maximum by looking at number of elements in below it. \\n\\nThus, the contribution of A_i(0-indexing), in a sorted array, to the whole sum is \\n (2^i)*A_i - 2^(n-i-1)*A_i\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mod = 1e9+7;\\n    ll power(ll x, ll y , ll mod) {\\n        ll ans = 1;\\n        while (y) {\\n            if (y&1) ans = (ans*x)%mod;\\n            x = (x*x)%mod;\\n            y/=2;\\n        }\\n        return ans;\\n    }\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        ll ans = 0, n = nums.size();\\n        for (int i = 0; i < n;i++) {\\n            ans = (ans + power(2, i,mod)*nums[i] - power(2,n-1-i,mod)*nums[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mod = 1e9+7;\\n    ll power(ll x, ll y , ll mod) {\\n        ll ans = 1;\\n        while (y) {\\n            if (y&1) ans = (ans*x)%mod;\\n            x = (x*x)%mod;\\n            y/=2;\\n        }\\n        return ans;\\n    }\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        ll ans = 0, n = nums.size();\\n        for (int i = 0; i < n;i++) {\\n            ans = (ans + power(2, i,mod)*nums[i] - power(2,n-1-i,mod)*nums[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553573,
                "title": "java-solution-runtime-734-ms-faster-than-5-21-of-java-online-submissions",
                "content": "class Solution {\\n     //inbuilt power function wont work for hard test so implement custom power function with Tc - logn\\n   static long pow(int A, int B, int C){\\n\\n    //Base condition for recursive call\\n        //Base condition for recursive call\\n        long num  = A;\\n        if(B == 0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n        long square_number = pow((int)num, B/2 , C);\\n\\t\\tlong power_square = (square_number  * square_number ) % C;\\n\\t\\tpower_square=(power_square+C)%C;\\n\\n        if(B % 2 == 0)\\n\\t\\t{\\n\\t\\t\\treturn power_square;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t    power_square=((num * power_square)+C)%C;\\n\\t\\t\\treturn (power_square);\\n\\t\\t}\\n\\n    }\\n    public int sumSubseqWidths(int[] nums) {\\n        \\n         int mod=1000000007;\\n        //Collections.sort(A);\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n\\n        long max = 0;\\n        long min = 0;\\n\\n        for(int i = 0 ; i < nums.length ; i++)\\n        {\\n            max = ((max + (long)nums[n-i-1] * pow(2 , n-i-1 , mod)) % mod);\\n            min = ((min + (long)nums[i] * pow(2 , n-i-1 , mod)) % mod);\\n        }\\n\\n        return (int)(max-min+mod)%mod; \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n     //inbuilt power function wont work for hard test so implement custom power function with Tc - logn\\n   static long pow(int A, int B, int C){\\n\\n    //Base condition for recursive call\\n        //Base condition for recursive call\\n        long num  = A;\\n        if(B == 0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2535420,
                "title": "c-math-problem",
                "content": "First sort the array. Then for each index i. \\narr[i] is the maximum number of any subsqeuence of [0, 1, ...i]\\narr[i] is the minimum number of any subsequence of [i, i+1,... n-1]\\nSo we just count the # of appearances of arr[i] as the minimum number and as the maximum number.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll big = 1e9 + 7;\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> pow(n+1, 1);\\n        for(int i=1; i<n+1; ++i) pow[i] = (pow[i-1] * 2) % big;\\n        \\n        sort(nums.begin(), nums.end());\\n        ll ans = 0;\\n        for(int i=0; i<n; ++i) {\\n            ll pos = pow[i] - 1, neg = pow[n-1-i] - 1;\\n            ans = (ans + (pos - neg) * nums[i]) % big; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll big = 1e9 + 7;\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> pow(n+1, 1);\\n        for(int i=1; i<n+1; ++i) pow[i] = (pow[i-1] * 2) % big;\\n        \\n        sort(nums.begin(), nums.end());\\n        ll ans = 0;\\n        for(int i=0; i<n; ++i) {\\n            ll pos = pow[i] - 1, neg = pow[n-1-i] - 1;\\n            ans = (ans + (pos - neg) * nums[i]) % big; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373322,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int MOD = (int)1e9 + 7;\\n        Arrays.sort(nums);\\n        \\n        long ans = 0;\\n        long p = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            ans = (ans + p * nums[i] - p * nums[nums.length - 1 - i]) % MOD;\\n            p = (p * 2) % MOD;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int MOD = (int)1e9 + 7;\\n        Arrays.sort(nums);\\n        \\n        long ans = 0;\\n        long p = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            ans = (ans + p * nums[i] - p * nums[nums.length - 1 - i]) % MOD;\\n            p = (p * 2) % MOD;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370250,
                "title": "short-trick-to-remove-integer-overflow-c",
                "content": "```\\n int mod=1000000007;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        //Step 1--> Sort krke ans nikalna is same as normally ans nikalna as at the end hmse max-min pucha hai 4 8 3 ka b (max-min) same hoga aur 3 4 8 ka bhi..\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        long long power2[n];\\n        power2[0]=1;\\n        \\n        //Step 2--> Power 2 bohat bdi bn skti hai as n=10^5 so mod krte chalo and bar bar krna na pde to 2^i ko store krte chalo array me \\n        for(int i=1;i<n;i++)\\n        power2[i]=(power2[i-1]*2)%mod;\\n            \\n        long long sum=0;\\n        \\n         //Step 3 --> VERY VERY IMPORTANT TO REMOVE OVERFLOW --> sum=sum+(xyz) means long long variable pehle likhdiya to overflow nahi hoga long long dominate kr jayega int ko \\n        for(int i=0;i<n;i++)\\n            sum=(sum+nums[i]*(power2[i]-power2[n-i-1]))%mod;  //sum+= nahi chlega yaha pe \\n\\n        return sum%mod;       \\n    }",
                "solutionTags": [],
                "code": "```\\n int mod=1000000007;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        //Step 1--> Sort krke ans nikalna is same as normally ans nikalna as at the end hmse max-min pucha hai 4 8 3 ka b (max-min) same hoga aur 3 4 8 ka bhi..\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        long long power2[n];\\n        power2[0]=1;\\n        \\n        //Step 2--> Power 2 bohat bdi bn skti hai as n=10^5 so mod krte chalo and bar bar krna na pde to 2^i ko store krte chalo array me \\n        for(int i=1;i<n;i++)\\n        power2[i]=(power2[i-1]*2)%mod;\\n            \\n        long long sum=0;\\n        \\n         //Step 3 --> VERY VERY IMPORTANT TO REMOVE OVERFLOW --> sum=sum+(xyz) means long long variable pehle likhdiya to overflow nahi hoga long long dominate kr jayega int ko \\n        for(int i=0;i<n;i++)\\n            sum=(sum+nums[i]*(power2[i]-power2[n-i-1]))%mod;  //sum+= nahi chlega yaha pe \\n\\n        return sum%mod;       \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2359247,
                "title": "java-sorting",
                "content": "```\\nclass Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }\\n        return (int)width;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2357334,
                "title": "java-prefix-sum-o-nlogn",
                "content": "I now understand this is not the optimal solution but I am sharing it regardless. \\n- Sort the array first because the order doesn\\'t matter.\\n\\n- Consider each index ending in `i` being the max element, there are `[0, i-1]` min element choice, with each choice giving some `2^j` where `j` is the gap between the min and the max element.\\n\\n- Now Consider the whole array. If we fixed \"gap\", we will realize that for each specific gap `j`, the contribution of it is the suffix sum - prefix sum of the same size.\\n\\n#### Java \\n```Java\\n// Time O(nlogn)\\n// Space O(n)\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, two = 1, ans = 0, M = (int)1e9+7;\\n        long[] pre = new long[n];\\n        for (int i = 0; i < n; i++){\\n            pre[i] = i == 0? nums[i] : nums[i] + pre[i-1];\\n        }\\n        for (int i = 1; i < n; i++){\\n            long g = pre[n-1] - pre[i-1]; // suffix sum\\n            long l = pre[n-1-i]; // prefix sum\\n            ans += two * (g-l) % M; // contribution of the current gap.\\n            ans %= M;\\n            two = 2*two%M;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\n// Time O(nlogn)\\n// Space O(n)\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, two = 1, ans = 0, M = (int)1e9+7;\\n        long[] pre = new long[n];\\n        for (int i = 0; i < n; i++){\\n            pre[i] = i == 0? nums[i] : nums[i] + pre[i-1];\\n        }\\n        for (int i = 1; i < n; i++){\\n            long g = pre[n-1] - pre[i-1]; // suffix sum\\n            long l = pre[n-1-i]; // prefix sum\\n            ans += two * (g-l) % M; // contribution of the current gap.\\n            ans %= M;\\n            two = 2*two%M;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355112,
                "title": "easy-c-solution-with-explanation",
                "content": "Observations-\\n1- Since we need to find sum of width (difference between largest and smallest element) so the sequence of elements doesn\\'t matter.\\n2- sorting array to make things easier\\n\\nExample - [1,2,3,4]\\n\\nNow problem is boil down to find number of subsequence ends with an element (that element will be greater in that subsequences ) and number of subsequence starts with an element (that element will be smaller in that subsequences )\\n\\nlet say element 2\\nsubsequences ends with 2 => [1,2] [2]  (2 subsquences )\\nsubsequences starts with 2 => [2] [2,3] [2,4] [2,3,4] (4 subsquences)\\n\\ncontribution of these subsqences width in answer  can be calculated by ( 2* 4 - 2 * 2 )\\n\\n\\n\\n`````\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int mod=1e9+7;\\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<int>pow(n,1);\\n        pow[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }\\n        \\n        long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=(ans+1ll*nums[i]*(pow[i]-pow[n-i-1]))%mod;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int mod=1e9+7;\\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<int>pow(n,1);\\n        pow[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2355044,
                "title": "sum-of-subsequence-widths",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        //sorting the array so we can easily get max and min as width=max-min\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;    //answer can go beyond int range so mod it to come it in range\\n        \\n        long[] pow=new long[n];     //array to store power of 2\\n        \\n        pow[0]=1;   //power of 2^0==1 \\n\\n        \\n        //use to store power of 2\\n        //2^0,2^1,2^2....\\n        //we store power of two as we need total no of subsequence and to find no. of subsequence of n digit is 2^n\\n        for(int i=1;i<n;i++){\\n           pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        \\n        //width==max-min\\n        //n-i-1 for count of left element and then take the power of 2 from pow array which store power of 2\\n        for(int i=0;i<n;i++){\\n            //for ith element we have to find no of subsequence till me and no of subsequence after ith element \\n            //ith element can be in maximum element in previous subsequence and min in next subsequence as array is sorted\\n            //so as we already store power of 2 in pow array we just need count of element till prevoius and after i to               //last element , so we can take no of subsequence from pow\\n            //width=max*subsequence-min*subsequence\\n            ans=(ans+nums[i]*pow[i]-nums[i]*pow[n-i-1])%mod;\\n            System.out.println(ans);\\n            \\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n}\\n//1 2 3\\n//1 2 4\\n//0+1-1*4==-3\\n//-3+2*2-2*2==-3\\n//-3+3*4-3*1==-3+12-3=6\\n```\\nif have any query i will suggest you to go through this video \\nhttps://www.youtube.com/watch?v=kSo8W6ZGYqw",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        //sorting the array so we can easily get max and min as width=max-min\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;    //answer can go beyond int range so mod it to come it in range\\n        \\n        long[] pow=new long[n];     //array to store power of 2\\n        \\n        pow[0]=1;   //power of 2^0==1 \\n\\n        \\n        //use to store power of 2\\n        //2^0,2^1,2^2....\\n        //we store power of two as we need total no of subsequence and to find no. of subsequence of n digit is 2^n\\n        for(int i=1;i<n;i++){\\n           pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        \\n        //width==max-min\\n        //n-i-1 for count of left element and then take the power of 2 from pow array which store power of 2\\n        for(int i=0;i<n;i++){\\n            //for ith element we have to find no of subsequence till me and no of subsequence after ith element \\n            //ith element can be in maximum element in previous subsequence and min in next subsequence as array is sorted\\n            //so as we already store power of 2 in pow array we just need count of element till prevoius and after i to               //last element , so we can take no of subsequence from pow\\n            //width=max*subsequence-min*subsequence\\n            ans=(ans+nums[i]*pow[i]-nums[i]*pow[n-i-1])%mod;\\n            System.out.println(ans);\\n            \\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n}\\n//1 2 3\\n//1 2 4\\n//0+1-1*4==-3\\n//-3+2*2-2*2==-3\\n//-3+3*4-3*1==-3+12-3=6\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311848,
                "title": "python-users-pow-2-i-function-is-slow",
                "content": "Either use ```<<``` or construct the power array manually. I found that constructing the pow2 array as in the solution is the fastest",
                "solutionTags": [],
                "code": "```<<```",
                "codeTag": "Unknown"
            },
            {
                "id": 2229984,
                "title": "o-nlog-n-time-complexity",
                "content": "```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222412,
                "title": "sum-of-subsequence-widths-easy-to-understand-solution-java",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;\\n        \\n        long []pow=new long[n];\\n        \\n        pow[0]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(pow[i]-pow[n-i-1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n\\n//for p numbers there are 2^p subsequences possible\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;\\n        \\n        long []pow=new long[n];\\n        \\n        pow[0]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(pow[i]-pow[n-i-1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n\\n//for p numbers there are 2^p subsequences possible\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181862,
                "title": "java-easy-understanding-solution",
                "content": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n      \\n       Arrays.sort(nums);\\n        int n = nums.length;\\n        \\n        long[] power = new long[n];\\n        long mod = 1000000007L;\\n        power[0] = 1;\\n        \\n        for(int i =1; i<n; i++){\\n            power[i] = (power[i-1]*2)%mod;\\n        }\\n        \\n        long ans = 0;\\n        \\n        for(int i = 0; i<n; i++){\\n            ans = (ans + nums[i]*power[i] - nums[i]*power[n-i-1])%mod;\\n        }\\n        return (int) ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n      \\n       Arrays.sort(nums);\\n        int n = nums.length;\\n        \\n        long[] power = new long[n];\\n        long mod = 1000000007L;\\n        power[0] = 1;\\n        \\n        for(int i =1; i<n; i++){\\n            power[i] = (power[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2179790,
                "title": "c-simple-solution-no-power",
                "content": "```\\nint sumSubseqWidths(vector<int>& A) {\\n        int N = A.size();\\n        long mn = 0, mx = 0, mod = 1000000007;\\n\\n        sort(A.begin(), A.end());\\n        for(int i=0; i<N; i++) {\\n            mn = (mn*2)%mod;\\n            mn = (mn + A[i])%mod;\\n        }\\n\\n        for(int i=N-1; i>=0; i--) {\\n            mx = (mx*2)%mod;\\n            mx = (mx + A[i])%mod;\\n        }\\n        return (mx-mn + mod)%mod;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint sumSubseqWidths(vector<int>& A) {\\n        int N = A.size();\\n        long mn = 0, mx = 0, mod = 1000000007;\\n\\n        sort(A.begin(), A.end());\\n        for(int i=0; i<N; i++) {\\n            mn = (mn*2)%mod;\\n            mn = (mn + A[i])%mod;\\n        }\\n\\n        for(int i=N-1; i>=0; i--) {\\n            mx = (mx*2)%mod;\\n            mx = (mx + A[i])%mod;\\n        }\\n        return (mx-mn + mod)%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176301,
                "title": "java-easy-commented-solution",
                "content": "class Solution {\\n\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] pow = new long[n]; //this array keeps count of number of subsequences till a particular index\\n        pow[0] = 1;\\n        long mod = 1000000007;\\n        \\n        for(int i = 1; i<n; i++){\\n            pow[i] =( pow[i-1]*2)%mod;\\n        }\\n        \\n        long ans = 0;\\n        for(int i = 0; i<n; i++){\\n            //an element occurs adds in the answer only when it appears as mas of a subsequence and subtracts only when it occurs as min of a subarray so we calculated this and then kept on appending it in the answer\\n            ans = (ans + nums[i]*pow[i] - nums[i]*pow[n-i-1])%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] pow = new long[n]; //this array keeps count of number of subsequences till a particular index\\n        pow[0] = 1;\\n        long mod = 1000000007;\\n        \\n        for(int i = 1; i<n; i++){\\n            pow[i] =( pow[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2162427,
                "title": "python-easy-sort-count",
                "content": "(1) first sort the array;\\n(2) ith item, + times=2**i-1, -times=2**(n-1-i)-1 times;\\n(3) sum up\\n\\n```\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod=10**9+7\\n        nums.sort()\\n        n=len(nums)\\n        ct=[1]*n\\n        a=1/2\\n        for i in range(n):\\n            a=int(a*2)%mod\\n            ct[i]=a\\n        res=0\\n        for i in range(n):\\n            count=ct[i]-1\\n            count-=ct[-i-1]-1\\n            res+=(mod+nums[i]*count)%mod\\n            res=res%mod\\n        return res",
                "solutionTags": [],
                "code": "(1) first sort the array;\\n(2) ith item, + times=2**i-1, -times=2**(n-1-i)-1 times;\\n(3) sum up\\n\\n```\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod=10**9+7\\n        nums.sort()\\n        n=len(nums)\\n        ct=[1]*n\\n        a=1/2\\n        for i in range(n):\\n            a=int(a*2)%mod\\n            ct[i]=a\\n        res=0\\n        for i in range(n):\\n            count=ct[i]-1\\n            count-=ct[-i-1]-1\\n            res+=(mod+nums[i]*count)%mod\\n            res=res%mod\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2069229,
                "title": "detailed-explanation-brute-force-optimised-algorithm-java-solution-89-faster",
                "content": "https://www.youtube.com/watch?v=LuiCMG_hBWc&t=223s",
                "solutionTags": [
                    "Math"
                ],
                "code": "https://www.youtube.com/watch?v=LuiCMG_hBWc&t=223s",
                "codeTag": "Unknown"
            },
            {
                "id": 2014439,
                "title": "simple-straight-forward-solution-no-tricks",
                "content": "This one is inspired by https://leetcode.com/problems/sum-of-subsequence-widths/discuss/881805/C%2B%2B-simple-sol-with-comments-beats-88\\n\\nWhere we find out the number of subsets a number would be a part of ending on that number and we sum those counts. Similarly, we subtract all the counts where the number would be a part of a subset starting from that index.\\n\\n```\\nvar sumSubseqWidths = function(nums) {\\n    const mod = 1000000007;\\n    nums.sort((a, b) => a - b), total = 0, power = 1;\\n    for(let i = 0; i < nums.length; i++) {\\n        total = (total + nums[i] * power) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    power = 1;\\n    for(let i = nums.length - 1; i >= 0; i--) {\\n        total = (total - nums[i] * power + mod) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    return (total + mod) % mod\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sumSubseqWidths = function(nums) {\\n    const mod = 1000000007;\\n    nums.sort((a, b) => a - b), total = 0, power = 1;\\n    for(let i = 0; i < nums.length; i++) {\\n        total = (total + nums[i] * power) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    power = 1;\\n    for(let i = nums.length - 1; i >= 0; i--) {\\n        total = (total - nums[i] * power + mod) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    return (total + mod) % mod\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969433,
                "title": "python-sort-and-linear-scan-o-nlogn-explained",
                "content": "Let A be the array nums.\\nLet n be len(A).\\nFirst sort A.\\nFor each A[i] there are 2^i cases when A[i] becomes the minimum in a subsequence, and 2^(n-1-i) cases when A[i] becomes the maximum.\\nWith a linear scan, process at each position.\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        M = 10**9+7\\n        res = 0\\n        le = 1\\n        re = pow(2, n-1, M)\\n        #by Fermat\\'s Little Thm\\n        #inverse of 2 modulo M\\n        inv = pow(2, M-2, M)\\n        for num in nums:\\n            res = (res + num * (le - re))%M\\n            le = (le * 2) % M\\n            re = (re * inv) % M\\n        return res",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "Let A be the array nums.\\nLet n be len(A).\\nFirst sort A.\\nFor each A[i] there are 2^i cases when A[i] becomes the minimum in a subsequence, and 2^(n-1-i) cases when A[i] becomes the maximum.\\nWith a linear scan, process at each position.\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        M = 10**9+7\\n        res = 0\\n        le = 1\\n        re = pow(2, n-1, M)\\n        #by Fermat\\'s Little Thm\\n        #inverse of 2 modulo M\\n        inv = pow(2, M-2, M)\\n        for num in nums:\\n            res = (res + num * (le - re))%M\\n            le = (le * 2) % M\\n            re = (re * inv) % M\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1949106,
                "title": "sum-of-subsequence-widths-solution-java",
                "content": "class Solution {\\n  public int sumSubseqWidths(int[] nums) {\\n    final int kMod = (int) 1e9 + 7;\\n    final int n = nums.length;\\n    long ans = 0;\\n    long exp = 1;\\n\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i < n; ++i, exp = exp * 2 % kMod) {\\n      ans += (nums[i] - nums[n - i - 1]) * exp;\\n      ans %= kMod;\\n    }\\n\\n    return (int) ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "class Solution {\\n  public int sumSubseqWidths(int[] nums) {\\n    final int kMod = (int) 1e9 + 7;\\n    final int n = nums.length;\\n    long ans = 0;\\n    long exp = 1;\\n\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i < n; ++i, exp = exp * 2 % kMod) {\\n      ans += (nums[i] - nums[n - i - 1]) * exp;\\n      ans %= kMod;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1944862,
                "title": "python-sorting-solution",
                "content": "Sort the list since order won\\'t matter for subsequences.\\nThen just need to observer greatest item will be used 2^(len(nums) - 1) times next largest will used 2^(len(nums) - 2) times ...\\n\\nWe can just calculate this directly since Python ints are unbounded. \\n\\nSame for the mins.\\n\\nThen can just subtract the two.\\n\\n\\n\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        maxes, mins = 0, 0\\n        for i in range(len(nums) - 1, -1, -1):\\n            maxes += nums[i] * (1 << i)\\n        for i in range(len(nums)):\\n            mins += nums[i] * (1 << (len(nums) - i - 1))\\n        return (maxes - mins) % int(1e9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        maxes, mins = 0, 0\\n        for i in range(len(nums) - 1, -1, -1):\\n            maxes += nums[i] * (1 << i)\\n        for i in range(len(nums)):\\n            mins += nums[i] * (1 << (len(nums) - i - 1))\\n        return (maxes - mins) % int(1e9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934391,
                "title": "c-o-n-solution-in-one-linear-scan",
                "content": "```\\nconstexpr long p = 1000000007;\\nclass Solution \\n{\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        long totalWidth = 0;\\n        long numSubSets = 1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            totalWidth = (totalWidth + numSubSets * (nums[i] - nums[n - 1 - i])) % p;\\n            numSubSets = (numSubSets * 2) % p;\\n        }\\n        return totalWidth % p;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconstexpr long p = 1000000007;\\nclass Solution \\n{\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        long totalWidth = 0;\\n        long numSubSets = 1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            totalWidth = (totalWidth + numSubSets * (nums[i] - nums[n - 1 - i])) % p;\\n            numSubSets = (numSubSets * 2) % p;\\n        }\\n        return totalWidth % p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881830,
                "title": "python-easy-to-read-and-understand-sorting",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            mx = (2**i)*nums[i]\\n            mn = (2**(n-1-i))*nums[i]\\n            ans += (mx-mn)\\n        \\n        return ans%(10**9+7)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            mx = (2**i)*nums[i]\\n            mn = (2**(n-1-i))*nums[i]\\n            ans += (mx-mn)\\n        \\n        return ans%(10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 1855046,
                "title": "java-mathematics-logic-easy-to-understand",
                "content": "# public int sumSubseqWidths(int[] nums) {\\n        long res = 0;\\n        long mod = 1000000007;\\n        Arrays.sort(nums);\\n        long[] powers = new long[nums.length];\\n        powers[0] = 1;\\n        for (int i = 1; i < powers.length; i++) {\\n            powers[i] = (powers[i - 1] * 2) % mod;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            res = (res + nums[i] * (powers[i] - powers[nums.length - i - 1])) % mod;\\n        }\\n        return (int) res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "# public int sumSubseqWidths(int[] nums) {\\n        long res = 0;\\n        long mod = 1000000007;\\n        Arrays.sort(nums);\\n        long[] powers = new long[nums.length];\\n        powers[0] = 1;\\n        for (int i = 1; i < powers.length; i++) {\\n            powers[i] = (powers[i - 1] * 2) % mod;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            res = (res + nums[i] * (powers[i] - powers[nums.length - i - 1])) % mod;\\n        }\\n        return (int) res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1833525,
                "title": "c-o-nlogn-explained-completely-new-approach",
                "content": "**Intuition and Approach:** \\n\\nClearly, generating all subsequences is not possible because of huge constraints. So, try thinking about what each element can contribute to the answer. For each subsequence, we have to find the maximum and minimum element. \\n\\nThinking on a broader expectation, it can be said that pick two elements, consider one as max and one as min, and just multiply their absolute difference with the number of times they will be maximum and minimum in the subsequences generated.\\n\\nSort the array, such that no extra time could be taken to find max and min elements. \\n\\nlet sorted array be [1,2,3,4,5,6,7,8] \\n\\nLets consider 1 as min and 4 as max for a subsequence \\n\\n1 and 4 can have 3 elements in between as per the given array\\n\\n1 _   _   _  4\\n1 2 2 2 1\\n\\n**By permutations, we can say that the number of such possible subsequences are 1x2x2x2x1=8. Thus (4-1) will come 8 times in the total subsequences and will contribute (4-1)x8 to the answer.**\\n\\nThus, anwer is:\\n `for(i = 0 to n - 2) for(j = i + 1 to n - 1) ans+=(Aj - Ai) X (2^(j - i + 1))          ------------------> Eqn 1`\\n\\nWhere Aj and Ai are the max and min elements. \\n\\n**But if you simply run the above snippet, you will again get TLE because it is again O(N^2).**\\n\\nKeeping the same idea intact, try reducing `Eqn 1 `to its reduced version. \\n\\n**Consider elements [a,b,c,d] such that a <= b <= c <= d. Here n=4, place all values of i and j**\\n\\n```\\n= { A1 (2^0) + A2 (2^1) + A3 (2^2) + A2 (2^0) + A3 (2^1) + A3 (2^0) }  - { A0 (2^0) + A0 (2^1) + A0 (2^2) + A1 (2^0) + A1 (2^1) + A2 (2^0) }    \\n\\n= { (2^0)(A1+A2+A3) + (2^1)(A2+A3) + (2^2)(A3) }  - { (2^0)(A0+A1+A2) + (2^1)(A0+A1) + (2^2)(A0) }\\n```\\n\\nTo generalize this,  we can say that\\n\\n```\\nFor (i = 0 to n-1) ans = ans + 2^i * (prefix[n-1] - prefix[i]) - 2^i * prefix[n-2-i];\\n```\\nWe have to handle this under modulo.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int md=1e9+7;\\n    using ll=long long;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n\\n        vector<ll> pow(n), pref(n);\\n        pow[0]=1;\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++) {\\n            pow[i]=(2*pow[i-1]) % md;\\n            pref[i]=(pref[i-1]%md+nums[i]%md)%md;\\n        }\\n        \\n        ll ans=0;\\n         for(int i=0;i<n-1;i++) {\\n            ans+=(pow[i] * (pref[n-1]-pref[i])) % md  -  (pow[i] * pref[n-2-i] + md) % md;\\n            ans=(ans+md)%md;\\n         }\\n        return ans%md;\\n    }\\n};\\n```\\n\\n**Time: O(NlogN)\\nSpace: O(N)**\\n\\nUpvote if you liked!!\\nLet me know your doubts in the comment section!!",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n= { A1 (2^0) + A2 (2^1) + A3 (2^2) + A2 (2^0) + A3 (2^1) + A3 (2^0) }  - { A0 (2^0) + A0 (2^1) + A0 (2^2) + A1 (2^0) + A1 (2^1) + A2 (2^0) }    \\n\\n= { (2^0)(A1+A2+A3) + (2^1)(A2+A3) + (2^2)(A3) }  - { (2^0)(A0+A1+A2) + (2^1)(A0+A1) + (2^2)(A0) }\\n```\n```\\nFor (i = 0 to n-1) ans = ans + 2^i * (prefix[n-1] - prefix[i]) - 2^i * prefix[n-2-i];\\n```\n```\\nclass Solution {\\npublic:\\n    int md=1e9+7;\\n    using ll=long long;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n\\n        vector<ll> pow(n), pref(n);\\n        pow[0]=1;\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++) {\\n            pow[i]=(2*pow[i-1]) % md;\\n            pref[i]=(pref[i-1]%md+nums[i]%md)%md;\\n        }\\n        \\n        ll ans=0;\\n         for(int i=0;i<n-1;i++) {\\n            ans+=(pow[i] * (pref[n-1]-pref[i])) % md  -  (pow[i] * pref[n-2-i] + md) % md;\\n            ans=(ans+md)%md;\\n         }\\n        return ans%md;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789008,
                "title": "java-easy-solution-o-nlogn-time-complexity",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] arr1) {\\n        Arrays.sort(arr1);\\n        int n=arr1.length;\\n        int mod=(int)1e9+7;\\n        long ans=0l;\\n        long power=1l;\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            ans=((ans%mod)+power*(arr1[i]-arr1[n-i-1])+mod)%mod;\\n            power=(power<<1)%mod;\\n        }\\n        \\n        return (int)(ans%mod);\\n    }   \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] arr1) {\\n        Arrays.sort(arr1);\\n        int n=arr1.length;\\n        int mod=(int)1e9+7;\\n        long ans=0l;\\n        long power=1l;\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            ans=((ans%mod)+power*(arr1[i]-arr1[n-i-1])+mod)%mod;\\n            power=(power<<1)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1788362,
                "title": "nlog-n-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        long ans = 0;\\n        long mod = 1000000007;\\n        long[] pow = new long[arr.length];\\n        pow[0] = 1;\\n        for(int i = 1 ; i < pow.length ; i++){\\n            pow[i] = (pow[i-1]*2)%mod; \\n        }\\n        \\n        for(int i = 0 ; i < arr.length ; i++){\\n            ans = (ans + arr[i]*(pow[i] - pow[arr.length - i - 1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        long ans = 0;\\n        long mod = 1000000007;\\n        long[] pow = new long[arr.length];\\n        pow[0] = 1;\\n        for(int i = 1 ; i < pow.length ; i++){\\n            pow[i] = (pow[i-1]*2)%mod; \\n        }\\n        \\n        for(int i = 0 ; i < arr.length ; i++){\\n            ans = (ans + arr[i]*(pow[i] - pow[arr.length - i - 1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755006,
                "title": "query-regarding-java-code",
                "content": "The mathematical base of this approach is correct for smaller lengths but for larger arrays I am getting a negative answer. Can someone help me to figure this out!\\n```\\n   Arrays.sort(a);\\n        long curr = 0;\\n        int n = a.length;\\n        int max=-1;\\n        long ans=0;\\n      \\n        long[] pow = new long[n+1];\\n        long cp =1;\\n        pow[0]=1;\\n        for(int i=1;i<=n;i++){\\n            cp = (cp*2)%mod;\\n            if(cp<0){\\n                cp+=mod;\\n            }\\n            pow[i] = cp;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            curr = (curr+(pow[max+1]*((long)(a[n-1])-(long)(a[i])))%mod)%mod;\\n            max++;\\n           \\n        }\\n        ans+=curr;\\n        \\n        for(int j= n-2;j>=0;j--){\\n          \\n            curr= (curr- (long)(a[j+1])+(long)(a[j]))%mod;\\n          \\n            curr/=2;\\n            max--;\\n            int nc= 0;\\n            if(max>=0){\\n                long k = ((pow[max+1]-1)%mod*((long)(a[j+1])-(long)(a[j]))%mod)%mod;\\n\\n                curr= (curr - k)%mod;\\n           \\n\\n            }\\n          \\n            \\n            ans = (ans+curr)%mod;\\n        }\\n        \\n        return (int)(ans%mod);\\n```",
                "solutionTags": [],
                "code": "```\\n   Arrays.sort(a);\\n        long curr = 0;\\n        int n = a.length;\\n        int max=-1;\\n        long ans=0;\\n      \\n        long[] pow = new long[n+1];\\n        long cp =1;\\n        pow[0]=1;\\n        for(int i=1;i<=n;i++){\\n            cp = (cp*2)%mod;\\n            if(cp<0){\\n                cp+=mod;\\n            }\\n            pow[i] = cp;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            curr = (curr+(pow[max+1]*((long)(a[n-1])-(long)(a[i])))%mod)%mod;\\n            max++;\\n           \\n        }\\n        ans+=curr;\\n        \\n        for(int j= n-2;j>=0;j--){\\n          \\n            curr= (curr- (long)(a[j+1])+(long)(a[j]))%mod;\\n          \\n            curr/=2;\\n            max--;\\n            int nc= 0;\\n            if(max>=0){\\n                long k = ((pow[max+1]-1)%mod*((long)(a[j+1])-(long)(a[j]))%mod)%mod;\\n\\n                curr= (curr - k)%mod;\\n           \\n\\n            }\\n          \\n            \\n            ans = (ans+curr)%mod;\\n        }\\n        \\n        return (int)(ans%mod);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730973,
                "title": "n-logn-time-complexity",
                "content": "In Swift, we don\\'t have anyway to store a number more than 2^63 - 1. So, for larger numbers we will get runtime error.\\n\\n```\\nfunc sumSubseqWidths(_ nums: [Int]) -> Int {\\n    let sortedNums = nums.sorted()\\n    var output: Int64 = 0\\n    let n = sortedNums.count\\n    \\n    for i in 0..<n {\\n        let num = Int64(sortedNums[i])\\n        let leftElements = i\\n        let rightElements = n-1-i\\n        let leftSubSeq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, leftElements))))%10000000007\\n        let rightSubseq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, rightElements))))%10000000007\\n        let diff: Int64 = (leftSubSeq-rightSubseq)%10000000007\\n        output += num*diff\\n    }\\n    \\n    return Int(output%10000000007)\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nfunc sumSubseqWidths(_ nums: [Int]) -> Int {\\n    let sortedNums = nums.sorted()\\n    var output: Int64 = 0\\n    let n = sortedNums.count\\n    \\n    for i in 0..<n {\\n        let num = Int64(sortedNums[i])\\n        let leftElements = i\\n        let rightElements = n-1-i\\n        let leftSubSeq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, leftElements))))%10000000007\\n        let rightSubseq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, rightElements))))%10000000007\\n        let diff: Int64 = (leftSubSeq-rightSubseq)%10000000007\\n        output += num*diff\\n    }\\n    \\n    return Int(output%10000000007)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677485,
                "title": "sum-of-subsequence-widths",
                "content": "Why does the solution (in java) do a mod of 1000000007 when calculating 2 power array. As per the question, the mod of 1000000007 should only be performed on the result. isnt it?",
                "solutionTags": [],
                "code": "Why does the solution (in java) do a mod of 1000000007 when calculating 2 power array. As per the question, the mod of 1000000007 should only be performed on the result. isnt it?",
                "codeTag": "Unknown"
            },
            {
                "id": 1627929,
                "title": "python-with-explanation",
                "content": "First, sort the nums as the order doesn\\'t matter in this case\\nSecond, let\\'s take a look which subarrays will be used and how many times they will be counted.\\n\\nAssume the length is *l*, and the subarrays are:\\n[0,1] once, [0,2] twice, [0,3] three times, .. [0,l-1] l times\\n\\t\\t\\t\\t\\t   [1,2] once, [1,3] twice, ..        [1,l-1] l-1 times\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[2,3] once, ..            [2,l-1] l-2 times\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[l-2,l-1] once\\nif we use an array res to represent the sum with different length *l* \\n        ****when l=2:****\\n        res[l=2] = (nums[1]-nums[0])*1 = nums[1]*2^0 - nums[0]*2^0\\n        ****when l=3:****\\n        res[l=3] = (nums[2]-nums[1])*1 + (nums[2]-nums[0])*2 + (nums[1]-nums[0])*1\\n\\t\\t\\t\\t\\t= res[l=2] + nums[2]*(2^0+2^1) - nums[1]*2^0 + nums[0]*2^1\\n        ****when l=4:****            \\n        res[l=4] = (nums[1]-nums[0])*1 + (nums[2]-nums[1])*1 + (nums[3]-nums[2])*1 + \\n                (nums[2]-nums[0])*2 + (nums[3]-nums[1])*2 +\\n                (nums[3]-nums[0])*2^2\\n            = nums[3]*(4+2+1)-nums[0]*(2^0+2^1+2^2) + nums[2]*(2) - nums[1]*(2)\\n            = res[3] + (nums[3]-nums[2])*1 + (nums[3]-nums[1])*2 + (nums[3]-nums[0])*2^2\\n            = res[l=3] + nums[3]*(1+2+4) - nums[2]*1 - nums[1]*2 - nums[0]*2^2\\n       ****when l=5:****\\n        res[l=5] = (nums[1]-nums[0])*1 + (nums[2]-nums[1])*1 + (nums[3]-nums[2])*1 + (nums[4]-nums[3])*1 +\\n                (nums[2]-nums[0])*2 + (nums[3]-nums[1])*2 + (nums[4]-nums[2])*2 +\\n                (nums[3]-nums[0])*2^2 + (nums[4]-nums[1])*2^2 +\\n                (nums[4]-nums[0])*2^3\\n            = res[l=4] + (nums[4]-nums[3])*1 + (nums[4]-nums[2])*2 + (nums[4]-nums[1])*2^2 + (nums[4]-nums[0])*2^3\\n            = res[l=4] + nums[4]*(2^0+2^1+2^2+2^3) - nums[3] - nums[2]*2 - nums[1]*2^2 - nums[0]*2^3\\n        ****when l=6:****\\n        res[l=6] = res[l=5] + nums[5]*(1+...+2^4) - nums[4] - nums[3]*2 - nums[2]*2^2 - nums[1]*2^3 - nums[0]*2^4\\n\\nIt\\'s easy to write code like this:\\n```\\nnums = sorted(nums)\\n        l = len(nums)\\n        res = 0\\n        n = 0\\n        s = 0\\n        m = 10**9+7\\n        for i in range(1,l):\\n            n = (n*2+nums[i-1])%m\\n            s = (s*2+1)%m\\n            res = (res + s*nums[i] - n)%m\\n        return res%m\\n```",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nnums = sorted(nums)\\n        l = len(nums)\\n        res = 0\\n        n = 0\\n        s = 0\\n        m = 10**9+7\\n        for i in range(1,l):\\n            n = (n*2+nums[i-1])%m\\n            s = (s*2+1)%m\\n            res = (res + s*nums[i] - n)%m\\n        return res%m\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590029,
                "title": "c-maths-sorting-greedy",
                "content": "class Solution {\\npublic:\\n    \\n    long long M=1e9+7;\\n    \\n    long long mod(long long a){\\n        \\n        return ((a%M)+M)%M;\\n        \\n    }\\n    \\n    long long mul(long long a,long long b){\\n        \\n        return mod(mod(a)*mod(b));\\n        \\n    }\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n      \\n        long long n=nums.size();\\n        \\n        vector<long long>pow(n);\\n        \\n        pow[0]=1LL;\\n        \\n        for(long i=1;i<n;i++){\\n            \\n            pow[i]=mul(2,pow[i-1]);\\n            \\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        long long ans=0;\\n        \\n        for(long i=0;i<n;i++){\\n            \\n            long long val=(pow[i]-pow[n-i-1])*nums[i];\\n            \\n            ans=(ans+val)%M;\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    long long M=1e9+7;\\n    \\n    long long mod(long long a){\\n        \\n        return ((a%M)+M)%M;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1545974,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461971,
                "title": "somthing-wrong-with-this-test-case",
                "content": "[2,1] returns 1 as a test case and in my local dev env with python 3, but when I submit, I got a 0 as output. What am I missing here?\\n\\n![image](https://assets.leetcode.com/users/images/bde95861-01ba-4ad4-9dd2-fc8e8b21b7fe_1631562000.1102972.png)\\n",
                "solutionTags": [],
                "code": "[2,1] returns 1 as a test case and in my local dev env with python 3, but when I submit, I got a 0 as output. What am I missing here?\\n\\n![image](https://assets.leetcode.com/users/images/bde95861-01ba-4ad4-9dd2-fc8e8b21b7fe_1631562000.1102972.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1455321,
                "title": "python-time-complexity-nlogn",
                "content": "\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, a: List[int]) -> int:\\n        mod=int(1e9)+7\\n        p=1\\n        ans=0\\n        n=len(a)\\n        a.sort()\\n        for i in range(0,n):\\n            ans=(ans+((a[i]-a[n-i-1])*p))%mod\\n            p=(p<<1)%mod\\n        return ans%mod\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, a: List[int]) -> int:\\n        mod=int(1e9)+7\\n        p=1\\n        ans=0\\n        n=len(a)\\n        a.sort()\\n        for i in range(0,n):\\n            ans=(ans+((a[i]-a[n-i-1])*p))%mod\\n            p=(p<<1)%mod\\n        return ans%mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419500,
                "title": "can-anyone-help-in-telling-me-the-issue-with-my-approach",
                "content": "My appaoach is that from result we substract and add in such a way that\\n1. Substract No. of subsequences in which nums[i] is minimum * nums[i]\\n2. Add no. of subsequences in which nums[i] is maximum * nums[i]\\n3. No of subsequences = 2^ (elements to left OR right of nums[i])\\n\\n\\n```\\npublic int sumSubseqWidths(int[] nums) {\\n        int MOD = 1000000007;\\n        long res =0, n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i=0;i<n;i++) {\\n            res = (res - ((long)Math.pow(2, n-1-i)*(long)nums[i]))%MOD;\\n            res = (res + ((long)Math.pow(2, i)*(long)nums[i]))%MOD;\\n        }\\n        return (int)(res % MOD);\\n    }\\n```\\n\\nIt is failing for following test case\\n[96,87,191,197,40,101,108,35,169,50,168,182,95,80,144,43,18,60,174,13,77,173,38,46,80,117,13,19,11,6,13,118,39,80,171,36,86,156,165,190,53,49,160,192,57,42,97,35,124,200,84,70,145,180,54,141,159,42,66,66,25,95,24,136,140,159,71,131,5,140,115,76,151,137,63,47,69,164,60,172,153,183,6,70,40,168,133,45,116,188,20,52,70,156,44,27,124,59,42,172]",
                "solutionTags": [],
                "code": "```\\npublic int sumSubseqWidths(int[] nums) {\\n        int MOD = 1000000007;\\n        long res =0, n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i=0;i<n;i++) {\\n            res = (res - ((long)Math.pow(2, n-1-i)*(long)nums[i]))%MOD;\\n            res = (res + ((long)Math.pow(2, i)*(long)nums[i]))%MOD;\\n        }\\n        return (int)(res % MOD);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1289099,
                "title": "c-nlogn-99-faster",
                "content": "logic:\\n1.Here we are considering every subsequence hence ordering don\\'t matter.Hence sort it ..work will become easy.\\n2.We know n elements can form 2^n subsequences\\n3.In sorted array A[i] will be maximum in 2^(i-1)subsequences and smallest in 2^(n-i-1) subsequences .\\n```\\n    int sumSubseqWidths(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        long long n=a.size(),i,ans=0,x=1,m=1e9+7;\\n        for(i=0;i<n;i++)\\n        {\\n            x%=m;\\n            ans=(ans+(x*a[i])%m-(x*(a[n-i-1]))%m)%m;\\n            x*=2;\\n        }\\n        \\n        return (ans+m)%m;\\n    }",
                "solutionTags": [],
                "code": "logic:\\n1.Here we are considering every subsequence hence ordering don\\'t matter.Hence sort it ..work will become easy.\\n2.We know n elements can form 2^n subsequences\\n3.In sorted array A[i] will be maximum in 2^(i-1)subsequences and smallest in 2^(n-i-1) subsequences .\\n```\\n    int sumSubseqWidths(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        long long n=a.size(),i,ans=0,x=1,m=1e9+7;\\n        for(i=0;i<n;i++)\\n        {\\n            x%=m;\\n            ans=(ans+(x*a[i])%m-(x*(a[n-i-1]))%m)%m;\\n            x*=2;\\n        }\\n        \\n        return (ans+m)%m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1274191,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    private  int mod = 1000000007;\\n\\n        public  int SumSubseqWidths(int[] nums)\\n        {\\n\\n            long ans = 0;\\n            Array.Sort(nums);\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                ans = (ans + (cChe(2L, i) - 1) * nums[i] % mod) % mod;\\n                ans = (ans - (cChe(2L, nums.Length - 1 - i) - 1) * nums[i] % mod) % mod;\\n            }\\n\\n            return (int)ans;\\n        }\\n\\n        private  long cChe(long x, long y)\\n        {\\n            long res = 1;\\n            while (y > 0)\\n            {\\n                if (y % 2 != 0)\\n                    res = res * x % mod;\\n                x = x * x % mod;\\n                y /= 2;\\n            }\\n            return res % mod;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private  int mod = 1000000007;\\n\\n        public  int SumSubseqWidths(int[] nums)\\n        {\\n\\n            long ans = 0;\\n            Array.Sort(nums);\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                ans = (ans + (cChe(2L, i) - 1) * nums[i] % mod) % mod;\\n                ans = (ans - (cChe(2L, nums.Length - 1 - i) - 1) * nums[i] % mod) % mod;\\n            }\\n\\n            return (int)ans;\\n        }\\n\\n        private  long cChe(long x, long y)\\n        {\\n            long res = 1;\\n            while (y > 0)\\n            {\\n                if (y % 2 != 0)\\n                    res = res * x % mod;\\n                x = x * x % mod;\\n                y /= 2;\\n            }\\n            return res % mod;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213909,
                "title": "c-o-nlgn",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    #define ll long long int\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        ll pow2[n];\\n        pow2[0]=1;\\n        for(int i=1;i<n;i++)\\n            pow2[i]=(2*pow2[i-1])%mod;\\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            res=(res+(pow2[i]-pow2[n-i-1])*nums[i])%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    #define ll long long int\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        ll pow2[n];\\n        pow2[0]=1;\\n        for(int i=1;i<n;i++)\\n            pow2[i]=(2*pow2[i-1])%mod;\\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            res=(res+(pow2[i]-pow2[n-i-1])*nums[i])%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203276,
                "title": "c-concise-code",
                "content": "```\\n#define mod 1000000007\\nint sumSubseqWidths(vector<int>& arr) \\n{\\n\\tsort(arr.begin(),arr.end());\\n\\tlong val=0,ret=0,_2=1;\\n\\tfor(int i=arr.size()-2;i>=0;--i)\\n\\t{\\n\\t\\tval=val*2+arr[i+1];\\n\\t\\t_2<<=1;\\n\\t\\t_2%=mod;\\n\\t\\tret+=(val-(_2-1)*arr[i]);\\n\\t\\tval%=mod;\\n\\t\\tret%=mod;\\n\\t}\\n\\treturn (ret+mod)%mod;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define mod 1000000007\\nint sumSubseqWidths(vector<int>& arr) \\n{\\n\\tsort(arr.begin(),arr.end());\\n\\tlong val=0,ret=0,_2=1;\\n\\tfor(int i=arr.size()-2;i>=0;--i)\\n\\t{\\n\\t\\tval=val*2+arr[i+1];\\n\\t\\t_2<<=1;\\n\\t\\t_2%=mod;\\n\\t\\tret+=(val-(_2-1)*arr[i]);\\n\\t\\tval%=mod;\\n\\t\\tret%=mod;\\n\\t}\\n\\treturn (ret+mod)%mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1160960,
                "title": "ruby",
                "content": "```\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef sum_subseq_widths(a)\\n  mod = 10 ** 9 + 7\\n  n = a.size\\n  a.sort!\\n  \\n  pow2 = Array.new(n)\\n  pow2[0] = 1\\n  \\n  (1..n).each do |i|\\n    pow2[i] = pow2[i - 1] * 2 % mod\\n  end\\n  \\n  ans = 0\\n  (0..n - 1).each do |i|\\n    ans = (ans + (pow2[i] - pow2[n-1-i]) * a[i]) % mod\\n  end\\n  \\n  ans\\n\\nend\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef sum_subseq_widths(a)\\n  mod = 10 ** 9 + 7\\n  n = a.size\\n  a.sort!\\n  \\n  pow2 = Array.new(n)\\n  pow2[0] = 1\\n  \\n  (1..n).each do |i|\\n    pow2[i] = pow2[i - 1] * 2 % mod\\n  end\\n  \\n  ans = 0\\n  (0..n - 1).each do |i|\\n    ans = (ans + (pow2[i] - pow2[n-1-i]) * a[i]) % mod\\n  end\\n  \\n  ans\\n\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1112290,
                "title": "how-this-can-be-optimized",
                "content": "Intution: I have use recurssive top to down approch for the given problem. My solution is divided into 3 parts. \\nPart 1: storing each subset into a temporary vector.\\nPart 2: I use a width vector to store width of each subset.\\nPart 3: Finally, adding all the values of width vector\\n\\nI am getting TLE. can anyone there to help me out where I can do optimization. Here is the code\\n```\\n\\tclass Solution {\\npublic:\\n    vector<long long int>width;\\nvoid subsequence(vector<int> &arr, int index, vector<int> &temp) \\n{\\n\\n\\tif (index == arr.size()) {\\n\\t\\tlong long int MAX = *max_element(temp.begin(),temp.end());\\n\\t\\tlong long int MIN = *min_element(temp.begin(),temp.end());\\n\\t\\twidth.push_back(MAX-MIN);\\n\\t\\treturn;\\n\\t}\\n\\telse {\\n\\n\\t\\ttemp.push_back(arr[index]);\\n\\t\\tsubsequence(arr, index + 1, temp); //  including\\n\\t\\ttemp.pop_back();\\n\\t\\tsubsequence(arr, index + 1, temp); // Not Including\\n\\n\\t\\treturn;\\n\\t}\\n}\\nint sumSubseqWidths(vector<int>& A) {\\n        vector<int> temp;\\n        subsequence(A, 0, temp);\\n        long long int ans = 0;\\n        for(auto i:width){\\n            ans+= i;\\n            ans = ans%1000000007;\\n        }\\n\\t    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    vector<long long int>width;\\nvoid subsequence(vector<int> &arr, int index, vector<int> &temp) \\n{\\n\\n\\tif (index == arr.size()) {\\n\\t\\tlong long int MAX = *max_element(temp.begin(),temp.end());\\n\\t\\tlong long int MIN = *min_element(temp.begin(),temp.end());\\n\\t\\twidth.push_back(MAX-MIN);\\n\\t\\treturn;\\n\\t}\\n\\telse {\\n\\n\\t\\ttemp.push_back(arr[index]);\\n\\t\\tsubsequence(arr, index + 1, temp); //  including\\n\\t\\ttemp.pop_back();\\n\\t\\tsubsequence(arr, index + 1, temp); // Not Including\\n\\n\\t\\treturn;\\n\\t}\\n}\\nint sumSubseqWidths(vector<int>& A) {\\n        vector<int> temp;\\n        subsequence(A, 0, temp);\\n        long long int ans = 0;\\n        for(auto i:width){\\n            ans+= i;\\n            ans = ans%1000000007;\\n        }\\n\\t    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077876,
                "title": "c-faster-than-97-braindead-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& v) {\\n        int n = v.size();\\n        const long long mod = 1000000007;\\n        sort(v.begin(), v.end());\\n        vector<long long> power_2(n, 1);\\n        for(int i = 1;i < n;i++)\\n            power_2[i] = (power_2[i - 1] << 1) % mod;\\n        long long res = 0;\\n        for(int i = 0;i < n;i++)\\n            res = (res + v[i] * (power_2[i] - power_2[n - i - 1])) % mod;\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& v) {\\n        int n = v.size();\\n        const long long mod = 1000000007;\\n        sort(v.begin(), v.end());\\n        vector<long long> power_2(n, 1);\\n        for(int i = 1;i < n;i++)\\n            power_2[i] = (power_2[i - 1] << 1) % mod;\\n        long long res = 0;\\n        for(int i = 0;i < n;i++)\\n            res = (res + v[i] * (power_2[i] - power_2[n - i - 1])) % mod;\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1042236,
                "title": "doubt",
                "content": "I see that the collection of  subsequences resemble the power set except null.Is there any relevant approach in that direction?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1035119,
                "title": "p23-5",
                "content": "Hint -> Sort the array, subseq when olny checking fo rmin and max does not effect after sorting\\nHint -> Complexity will be nlog(n)\\nHint -> For every element, find for how many it will be max, and for how many it will be min",
                "solutionTags": [],
                "code": "Hint -> Sort the array, subseq when olny checking fo rmin and max does not effect after sorting\\nHint -> Complexity will be nlog(n)\\nHint -> For every element, find for how many it will be max, and for how many it will be min",
                "codeTag": "Unknown"
            },
            {
                "id": 800350,
                "title": "can-someone-help-me-find-the-issue-in-this-code",
                "content": "The below mentioned solution passes 20/61 test cases. The ones in which it fails are very close to the answer. For example, actual answer = 8724365, my answer = 8724364\\n\\n\\n    int sumSubseqWidths(vector<int>& A) {\\n        int m = *max_element(A.begin(), A.end());\\n        long long int arr[m+1];\\n        for(int i = 0; i <= m; i++) {\\n            arr[i] = 0;\\n        }\\n\\t\\t\\n        for(int i = 0; i < A.size(); i++) {\\n            arr[A[i]]++;\\n        }\\n        \\n        //prefix sum\\n        for(int i = 1; i <= m; i++) {\\n            arr[i] += arr[i-1];\\n        }\\n        \\n        long long int ans = 0;\\n        for(int i = 1; i <= m-1; i++) {\\n            if(arr[i] == arr[i-1]) {\\n                continue;\\n            }\\n            for(int j = i+1; j <= m; j++) {\\n                if(arr[j] == arr[j-1]) {\\n                    continue;\\n                }\\n                long long int start = arr[i]-arr[i-1];\\n                long long int end = arr[j]-arr[j-1];\\n                long long int mid = arr[j-1]-arr[i];\\n                ans += (j-i)*pow(2, mid)*(pow(2, start)-1)*(pow(2, end)-1);\\n                ans = ans%1000000007;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "The below mentioned solution passes 20/61 test cases. The ones in which it fails are very close to the answer. For example, actual answer = 8724365, my answer = 8724364\\n\\n\\n    int sumSubseqWidths(vector<int>& A) {\\n        int m = *max_element(A.begin(), A.end());\\n        long long int arr[m+1];\\n        for(int i = 0; i <= m; i++) {\\n            arr[i] = 0;\\n        }\\n\\t\\t\\n        for(int i = 0; i < A.size(); i++) {\\n            arr[A[i]]++;\\n        }\\n        \\n        //prefix sum\\n        for(int i = 1; i <= m; i++) {\\n            arr[i] += arr[i-1];\\n        }\\n        \\n        long long int ans = 0;\\n        for(int i = 1; i <= m-1; i++) {\\n            if(arr[i] == arr[i-1]) {\\n                continue;\\n            }\\n            for(int j = i+1; j <= m; j++) {\\n                if(arr[j] == arr[j-1]) {\\n                    continue;\\n                }\\n                long long int start = arr[i]-arr[i-1];\\n                long long int end = arr[j]-arr[j-1];\\n                long long int mid = arr[j-1]-arr[i];\\n                ans += (j-i)*pow(2, mid)*(pow(2, start)-1)*(pow(2, end)-1);\\n                ans = ans%1000000007;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 788784,
                "title": "o-n-log-n-sort-compact-14-lines",
                "content": "```\\n#define MOD__ ((int)(1e9 + 7))\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1;\\n        int res = 0;\\n        \\n        for (int i = 0; i < A.size(); i++, c = c * 2 % MOD__)\\n            res = (res + A[i] * c - A[A.size() - i - 1] * c) % MOD__;\\n        \\n        return (res + MOD__) % MOD__;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD__ ((int)(1e9 + 7))\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1;\\n        int res = 0;\\n        \\n        for (int i = 0; i < A.size(); i++, c = c * 2 % MOD__)\\n            res = (res + A[i] * c - A[A.size() - i - 1] * c) % MOD__;\\n        \\n        return (res + MOD__) % MOD__;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738182,
                "title": "o-n-logn-sort-o-n-loop",
                "content": "```\\n#define M 1000000007\\n    int modularExponentiation(long long int x,long long int n)\\n    {\\n        long long int result=1;\\n        while(n>0)\\n        {\\n            if(n % 2 ==1)\\n                result=(result * x)%M;\\n            x=(x*x)%M;\\n            n=n/2;\\n        }\\n        return result;\\n    }\\n    \\n\\n    int sumSubseqWidths(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        long long int sumf=0,sumb=0;\\n        long long int ans=0;\\n        for(int i=0;i<n/2;++i){\\n            sumf+=v[i];\\n            sumb+=v[n-1-i];\\n            if(2*(i+1)==n){\\n                ans=(ans+(sumb-sumf)*(modularExponentiation(2,i))%M)%M;\\n            }\\n            else{\\n                 ans=(ans+(sumb-sumf)*(modularExponentiation(2,i)+modularExponentiation(2,n-2-i))%M)%M;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n#define M 1000000007\\n    int modularExponentiation(long long int x,long long int n)\\n    {\\n        long long int result=1;\\n        while(n>0)\\n        {\\n            if(n % 2 ==1)\\n                result=(result * x)%M;\\n            x=(x*x)%M;\\n            n=n/2;\\n        }\\n        return result;\\n    }\\n    \\n\\n    int sumSubseqWidths(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        long long int sumf=0,sumb=0;\\n        long long int ans=0;\\n        for(int i=0;i<n/2;++i){\\n            sumf+=v[i];\\n            sumb+=v[n-1-i];\\n            if(2*(i+1)==n){\\n                ans=(ans+(sumb-sumf)*(modularExponentiation(2,i))%M)%M;\\n            }\\n            else{\\n                 ans=(ans+(sumb-sumf)*(modularExponentiation(2,i)+modularExponentiation(2,n-2-i))%M)%M;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 725360,
                "title": "dp-c",
                "content": "```\\nclass Solution {\\n    int M=1e9+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        int N=A.size();\\n        sort(A.begin(),A.end());\\n        vector<long> dp(N),s(N);\\n        s[0]=A[0];\\n        long power=1;\\n        for(int i=1;i<N;++i)\\n        {\\n            power=power*2%M;\\n            dp[i]=(dp[i-1]+((power-1)*A[i])-s[i-1])%M;\\n            s[i]=(2*s[i-1]%M+A[i])%M;\\n        }\\n        return dp[N-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int M=1e9+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        int N=A.size();\\n        sort(A.begin(),A.end());\\n        vector<long> dp(N),s(N);\\n        s[0]=A[0];\\n        long power=1;\\n        for(int i=1;i<N;++i)\\n        {\\n            power=power*2%M;\\n            dp[i]=(dp[i-1]+((power-1)*A[i])-s[i-1])%M;\\n            s[i]=(2*s[i-1]%M+A[i])%M;\\n        }\\n        return dp[N-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721887,
                "title": "python-easy-and-concise-o-nlogn-sort-o-n-scan",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort(reverse=True)\\n         \\n        # a b c d\\n        # [a], scan b -> (b - a) * 1\\n        # [a, b], scan c -> (c - a) * 2 + (c - b) * 1\\n        # [a, b, c], scan d -> (d - a) * 4 + (d - b) * 2 + (d - c) * 1\\n        \\n        # b - a                  -> b   - (a)\\n        # 3c - 2a - b            -> 3c  - (2a + b)\\n        # 7d - 4a - 2b - c       -> 7d  - (4a + 2b + c)\\n        # 15e - 8a - 4b - 2c - d -> 15e - (8a + 4b + 2c + d)\\n        \\n        MOD = 10 ** 9 + 7\\n        total, incre, prev = 0, 2, A.pop()\\n        while A:\\n            number = A.pop()\\n            total = (total + (incre - 1) * number - prev) % MOD\\n            prev = (prev * 2 + number) % MOD\\n            incre = (incre * 2) % MOD\\n            \\n        return total\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort(reverse=True)\\n         \\n        # a b c d\\n        # [a], scan b -> (b - a) * 1\\n        # [a, b], scan c -> (c - a) * 2 + (c - b) * 1\\n        # [a, b, c], scan d -> (d - a) * 4 + (d - b) * 2 + (d - c) * 1\\n        \\n        # b - a                  -> b   - (a)\\n        # 3c - 2a - b            -> 3c  - (2a + b)\\n        # 7d - 4a - 2b - c       -> 7d  - (4a + 2b + c)\\n        # 15e - 8a - 4b - 2c - d -> 15e - (8a + 4b + 2c + d)\\n        \\n        MOD = 10 ** 9 + 7\\n        total, incre, prev = 0, 2, A.pop()\\n        while A:\\n            number = A.pop()\\n            total = (total + (incre - 1) * number - prev) % MOD\\n            prev = (prev * 2 + number) % MOD\\n            incre = (incre * 2) % MOD\\n            \\n        return total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701032,
                "title": "c-o-n-log-n-solution",
                "content": "```\\n        public class Solution\\n        {\\n            public int SumSubseqWidths(int[] A)\\n            {\\n                BigInteger modolo = BigInteger.Pow(10, 9) + 7;\\n                if (A.Length <= 1)\\n                {\\n                    return 0;\\n                }\\n                if (A.Length == 2)\\n                {\\n                    return (int)Math.Abs(A[1] - A[0]);\\n                }\\n                Array.Sort(A);\\n                BigInteger subSize = 1;\\n                BigInteger valueA = new BigInteger(A[1] - A[0]);\\n                int sum = (int)valueA;\\n                for (int i = 2; i < A.Length; i++)\\n                {\\n                    valueA = 2 * (valueA + subSize * (A[i] - A[i - 1])) +(A[i] - A[i - 1]);\\n                    sum += (int)(valueA % modolo);\\n                    sum = sum % (int)modolo;\\n                    subSize = (2 * subSize + 1);\\n            }\\n\\n                return  (sum %(int) modolo);\\n            }\\n        }\\n",
                "solutionTags": [],
                "code": "class Solution\\n        {\\n            public int SumSubseqWidths(int[] A)\\n            {\\n                BigInteger modolo = BigInteger.Pow(10, 9) + 7;\\n                if (A.Length <= 1)\\n                {\\n                    return 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 647841,
                "title": "c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\tint kMod=1e9+7;\\n\\t\\t\\tvector<long> powOf2(20001);\\n\\t\\t\\tpowOf2[0]=1;\\n\\t\\t\\tfor(int i=1;i<=20000;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpowOf2[i]=(powOf2[i-1]*2)%kMod;\\n\\t\\t\\t}\\n\\t\\t\\tsort(A.begin(),A.end());\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tint n=A.size();\\n\\t\\t\\tfor(int i=0;i<A.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans-=A[i]*(powOf2[n-1-i+1-1]-1)%kMod;\\n\\t\\t\\t\\tans+=A[i]*(powOf2[i]-1)%kMod;\\n\\t\\t\\t\\tans%=kMod;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\tint kMod=1e9+7;\\n\\t\\t\\tvector<long> powOf2(20001);\\n\\t\\t\\tpowOf2[0]=1;\\n\\t\\t\\tfor(int i=1;i<=20000;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpowOf2[i]=(powOf2[i-1]*2)%kMod;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 643916,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475268,
                "title": "simple-java-solution-cost-19ms",
                "content": "```java\\nclass Solution {\\n    public int sumSubseqWidths(int[] A) {\\n        if (A == null || A.length <= 1) {\\n            return 0;\\n        }\\n        Arrays.sort(A);\\n        int[] sum = new int[A.length];\\n        sum[0] = A[0];\\n        for(int i = 1; i < A.length; ++i) {\\n            sum[i] = sum[i - 1] + A[i];\\n        }\\n        long[] twoPow = new long[A.length];\\n        twoPow[0] = 1;\\n        for(int i = 1; i < A.length; ++i) {\\n            twoPow[i] = (twoPow[i - 1] << 1) % 1000000007l;\\n        }\\n        long res = 0;\\n        for(int i = 0; i < A.length - 1; ++i) {\\n            long tail = sum[A.length - 1] - sum[A.length - i - 2];\\n            long head = sum[i];\\n            res += (tail - head) * twoPow[A.length - i - 2];\\n            res = res % 1000000007l;\\n        }\\n        return (int) res;\\n    }\\n    \\n    // public long pow(long num, long exp) {\\n    //     if (exp == 0) {\\n    //         return 1l;\\n    //     }\\n    //     if (exp == 1) {\\n    //         return num;\\n    //     }\\n    //     long tmp = (exp & 1) == 0 ? 1 : num;\\n    //     long value = pow(num, exp / 2) % 1000000007l;\\n    //     return (tmp * value * value) % 1000000007l;\\n    // }\\n}\\n\\n//[1, 2, 3]\\n//[1, 3] * 2 + [1, 2] * 1\\n//[2, 3] * 1\\n\\n//[1, 3, 3]\\n\\n//[1, 3]\\n//[1, 3, 3]\\n//(a[0] - a[10]) * 8 + (a[0] - a[9]) * 7 + (a[0] - a[8]) * 6 + .... (a[0] - a[1])\\n//(a[1] - a[10]) * 7 + (a[1] - a[9]) * 6\\n//(a[2] - a[10]) * 6 ....\\n//(a[i] - a[10]) * (n - i - 2)\\n//(a[9] - a[10])\\n\\n\\n// ((a[n] + a[n - 1] ... + a[n - i]) - (a[0] + a[1] + ... + a[i])) * (n - i - 2)",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] A) {\\n        if (A == null || A.length <= 1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 474540,
                "title": "a-ordinary-solution-for-ordinary-people-but-simple-and-easy-to-come-up-with",
                "content": "After sorting the array. We group the A[i], A[j] pairs by the length (j - i - 1). Then we notice that the contribution of pairs with the same length can be calculated with the help of presum in one time.  \\n```\\nclass Solution {\\n    private static final int mod = (int)1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        int n = A.length;\\n        int[] pow = new int[n + 1];\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * 2) % mod;\\n        \\n        Arrays.sort(A);\\n        int[] presum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) presum[i] = (presum[i - 1] + A[i - 1]) % mod;\\n        \\n        long res = 0;\\n        for (int j = 0; j <= n - 2; j++) {\\n            long cur = (presum[n] - presum[j + 1] - presum[n - j - 1] + mod) % mod;\\n            cur = (cur * pow[j]) % mod;\\n            res = (res + cur) % mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int mod = (int)1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        int n = A.length;\\n        int[] pow = new int[n + 1];\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * 2) % mod;\\n        \\n        Arrays.sort(A);\\n        int[] presum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) presum[i] = (presum[i - 1] + A[i - 1]) % mod;\\n        \\n        long res = 0;\\n        for (int j = 0; j <= n - 2; j++) {\\n            long cur = (presum[n] - presum[j + 1] - presum[n - j - 1] + mod) % mod;\\n            cur = (cur * pow[j]) % mod;\\n            res = (res + cur) % mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415126,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int SumSubseqWidths(int[] arr) \\n    {\\n        Array.Sort(arr);\\n        long res = 0, mod = 1_000_000_007, pow = 1, n = arr.Length;\\n        for(int i = 0; i < arr.Length; i++, pow = (2 * pow) % mod)\\n            res =  (res + (long) arr[i] * pow - (long) arr[n - i - 1] * pow) % mod;\\n        return  (int) res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int SumSubseqWidths(int[] arr) \\n    {\\n        Array.Sort(arr);\\n        long res = 0, mod = 1_000_000_007, pow = 1, n = arr.Length;\\n        for(int i = 0; i < arr.Length; i++, pow = (2 * pow) % mod)\\n            res =  (res + (long) arr[i] * pow - (long) arr[n - i - 1] * pow) % mod;\\n        return  (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380768,
                "title": "python-solution-suggestions-for-improvement-are-welcome",
                "content": "For each element we count the number of subsequences it is the maximum element of, like wise for the minimum. Multiply the counts with the values and subtract the minSum from the maxSum. I wonder where I can improve my code\\'s speed ? Maybe the powers of 2 can be done faster using merging ?? \\n\\n```\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        S = 0\\n        B = [1]*len(A)\\n        for i in range(1,len(B)):\\n            B[i] = 2*B[i-1]\\n        for i in range(len(A)):\\n            S += (B[i]-B[-1-i])*A[i]\\n        return S%((10**9)+7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        S = 0\\n        B = [1]*len(A)\\n        for i in range(1,len(B)):\\n            B[i] = 2*B[i-1]\\n        for i in range(len(A)):\\n            S += (B[i]-B[-1-i])*A[i]\\n        return S%((10**9)+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 380613,
                "title": "javascript-why-its-failing-for",
                "content": "Failing for\\n\\n[5,69,89,92,31,16,25,45,63,40,16,56,24,40,75,82,40,12,50,62,92,44,67,38,92,22,91,24,26,21,100,42,23,56,64,43,95,76,84,79,89,4,16,94,16,77,92,9,30,13]\\nOutput:\\n102383039574557488\\nExpected:\\n857876214\\n\\n```var sumSubseqWidths = function(A) {\\n  let min = 0;\\n  let max = 0;\\n  let N = A.length;\\n  A = A.sort((a,b) => a-b);\\n  for(let i =0; i < N;i++){\\n      let minTemp = Math.floor(Math.pow(2, i ) - 1)\\n      max += A[i]*(minTemp)\\n      min += A[i]*( Math.pow(2, (N - i - 1)) - 1);\\n  }\\n  result = max - min;\\n  return result\\n};```",
                "solutionTags": [],
                "code": "```var sumSubseqWidths = function(A) {\\n  let min = 0;\\n  let max = 0;\\n  let N = A.length;\\n  A = A.sort((a,b) => a-b);\\n  for(let i =0; i < N;i++){\\n      let minTemp = Math.floor(Math.pow(2, i ) - 1)\\n      max += A[i]*(minTemp)\\n      min += A[i]*( Math.pow(2, (N - i - 1)) - 1);\\n  }\\n  result = max - min;\\n  return result\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 376893,
                "title": "simple-explanation-cpp",
                "content": "first sort the array \\nso we have (2^i-1)  (selecting certain element or not selecting 2^i-1 options ) options for making certain a[i] maximum in the sorted array and (2^(n-i-1)-1) options for making it minimum for i (  0 to  n-1) \\n\\nso adding (2^i-1)a[i] ans subtracting (2^(n-1-i) -1)a[i]  for every i \\n\\n\\n\\n\\n#define ll  long long\\nconst ll m= 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n\\n    int sumSubseqWidths(vector<int>& a) \\n\\t\\n    {\\n\\t\\n\\t\\t\\tll res = 0, n = a.size();\\n\\t\\t\\tsort(a.begin(), a.end());\\n\\t\\t\\tll dp[20001];\\n\\t\\t\\tmemset(dp,0,sizeof(dp));\\n\\t\\t\\tdp[0] = 1;\\n\\t\\t\\tfor(int i = 1; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i] = (dp[i - 1] % m * 2) % m;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres += a[i] * (dp[i] - dp[n - i - 1]);\\n\\t\\t\\t\\tres %= m;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n};\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int sumSubseqWidths(vector<int>& a) \\n\\t\\n    {\\n\\t\\n\\t\\t\\tll res = 0, n = a.size();\\n\\t\\t\\tsort(a.begin(), a.end());\\n\\t\\t\\tll dp[20001];\\n\\t\\t\\tmemset(dp,0,sizeof(dp));\\n\\t\\t\\tdp[0] = 1;\\n\\t\\t\\tfor(int i = 1; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i] = (dp[i - 1] % m * 2) % m;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 297594,
                "title": "java-solution-in-dp-but-always-time-limit-exceeded",
                "content": "```\\n    public int sumSubseqWidths(int[] A) {\\n        List<MinMaxPair> subseqList = new ArrayList<>();\\n        int result = 0;\\n        for (int num : A) {\\n            if (subseqList.isEmpty()) {\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            } else {\\n                int size = subseqList.size();\\n                for (int i = 0; i < size; i++) {\\n                    MinMaxPair oldPair = subseqList.get(i);\\n                    MinMaxPair newPair = new MinMaxPair(oldPair);\\n                    subseqList.add(newPair);\\n                    if (num < newPair.min) {\\n                        newPair.min = num;\\n                    }\\n                    if (num > newPair.max) {\\n                        newPair.max = num;\\n                    }\\n                    result += (newPair.max - newPair.min);\\n                }\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    class MinMaxPair {\\n        public int min;\\n        public int max;\\n\\n        MinMaxPair(int min, int max) {\\n            this.min = min;\\n            this.max = max;\\n        }\\n\\n        MinMaxPair(MinMaxPair pair) {\\n            this.min = pair.min;\\n            this.max = pair.max;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int sumSubseqWidths(int[] A) {\\n        List<MinMaxPair> subseqList = new ArrayList<>();\\n        int result = 0;\\n        for (int num : A) {\\n            if (subseqList.isEmpty()) {\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            } else {\\n                int size = subseqList.size();\\n                for (int i = 0; i < size; i++) {\\n                    MinMaxPair oldPair = subseqList.get(i);\\n                    MinMaxPair newPair = new MinMaxPair(oldPair);\\n                    subseqList.add(newPair);\\n                    if (num < newPair.min) {\\n                        newPair.min = num;\\n                    }\\n                    if (num > newPair.max) {\\n                        newPair.max = num;\\n                    }\\n                    result += (newPair.max - newPair.min);\\n                }\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    class MinMaxPair {\\n        public int min;\\n        public int max;\\n\\n        MinMaxPair(int min, int max) {\\n            this.min = min;\\n            this.max = max;\\n        }\\n\\n        MinMaxPair(MinMaxPair pair) {\\n            this.min = pair.min;\\n            this.max = pair.max;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291698,
                "title": "go-most-fast-solution-without-power-or-multiply",
                "content": "```go\\nfunc sumSubseqWidths(A []int) int {\\n\\tsort.Ints(A)\\n\\tvar ans int = 0\\n\\tfor i:=0; i<len(A); i++ {\\n\\t\\tans *= 2\\n\\t\\tans += A[len(A)-1-i] - A[i]\\n\\t\\tans %= 1E9+7\\n\\t}\\n\\tif ans < 0 { ans += 1E9+7 }\\n\\treturn ans\\n}\\n```\\n\\nWe can do it top-down so that we can avoid multiply or shift or power\\nThis could help if A is extremely long",
                "solutionTags": [],
                "code": "```go\\nfunc sumSubseqWidths(A []int) int {\\n\\tsort.Ints(A)\\n\\tvar ans int = 0\\n\\tfor i:=0; i<len(A); i++ {\\n\\t\\tans *= 2\\n\\t\\tans += A[len(A)-1-i] - A[i]\\n\\t\\tans %= 1E9+7\\n\\t}\\n\\tif ans < 0 { ans += 1E9+7 }\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 281708,
                "title": "super-nice-and-clean-java",
                "content": "\\n```\\nimport java.math.BigInteger;\\nimport java.util.Arrays;\\n\\nclass Solution {\\n\\n    public int sumSubseqWidths(final int[] arr) {\\n        if (arr.length == 1) {\\n            return 0;\\n        }\\n\\n        Arrays.sort(arr);\\n        BigInteger count = BigInteger.ZERO;\\n\\n        for (int gap = 0; gap < arr.length - 1; gap++) {\\n            long sumPerGap = 0L;\\n\\n            for (int i = 0; i + gap + 1 < arr.length; i++) {\\n                sumPerGap = sumPerGap + (arr[i + gap + 1] - arr[i]);\\n            }\\n\\n            count = count.add(BigInteger.valueOf(sumPerGap).multiply(BigInteger.valueOf(2).pow(gap)));\\n        }\\n\\n        return count.remainder(BigInteger.valueOf((long)Math.pow(10, 9) + 7)).intValue();\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\nimport java.util.Arrays;\\n\\nclass Solution {\\n\\n    public int sumSubseqWidths(final int[] arr) {\\n        if (arr.length == 1) {\\n            return 0;\\n        }\\n\\n        Arrays.sort(arr);\\n        BigInteger count = BigInteger.ZERO;\\n\\n        for (int gap = 0; gap < arr.length - 1; gap++) {\\n            long sumPerGap = 0L;\\n\\n            for (int i = 0; i + gap + 1 < arr.length; i++) {\\n                sumPerGap = sumPerGap + (arr[i + gap + 1] - arr[i]);\\n            }\\n\\n            count = count.add(BigInteger.valueOf(sumPerGap).multiply(BigInteger.valueOf(2).pow(gap)));\\n        }\\n\\n        return count.remainder(BigInteger.valueOf((long)Math.pow(10, 9) + 7)).intValue();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222325,
                "title": "o-n-nlog-n",
                "content": "1.sort the array\\n2.iterate from 1 to n\\n3.using the fact that # subsequence upto i is equal to sum(# subsequence from [0,n-1])+1\\n4.use long long int to handel higher test cases\\n\\n```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213939,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        s = diff = 0 \\n        k = 1 << max(len(A)-2,0)\\n        A.sort() \\n        for i in range(len(A)):\\n            diff += A[~i] - A[i] \\n            s += k * diff \\n            k >>= 1 \\n        return s % (10 ** 9 + 7)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        s = diff = 0 \\n        k = 1 << max(len(A)-2,0)\\n        A.sort() \\n        for i in range(len(A)):\\n            diff += A[~i] - A[i] \\n            s += k * diff \\n            k >>= 1 \\n        return s % (10 ** 9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 190386,
                "title": "could-someone-help-me-why-my-algorithm-is-not-correct",
                "content": "I think algorithm is straightforward.\\n1. We sort the array.\\n2. We loop from smallest to largest number.\\n3. For each number we calculate in how many subsequences we can have when we pick minimum and maximum, A[i] and A[j] in the code, the number will be pow(2, j - i - 1)\\n\\n failed at:\\n[96,87,191,197,40,101,108,35,169,50,168,182,95,80,144,43,18,60,174,13,77,173,38,46,80,117,13,19,11,6,13,118,39,80,171,36,86,156,165,190,53,49,160,192,57,42,97,35,124,200,84,70,145,180,54,141,159,42,66,66,25,95,24,136,140,159,71,131,5,140,115,76,151,137,63,47,69,164,60,172,153,183,6,70,40,168,133,45,116,188,20,52,70,156,44,27,124,59,42,172]\\nmy outcome is: 931507168\\nthe expected is: 136988321\\n\\nMuch appreciated.\\n```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long result = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int j = i + 1; j < A.size(); j++) {\\n                int gap = A[j] - A[i];\\n                long count = pow(2, j - i - 1);\\n                count %= mod;\\n                result += count * gap;\\n                result %= mod;\\n            }\\n        }\\n        return result % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long result = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int j = i + 1; j < A.size(); j++) {\\n                int gap = A[j] - A[i];\\n                long count = pow(2, j - i - 1);\\n                count %= mod;\\n                result += count * gap;\\n                result %= mod;\\n            }\\n        }\\n        return result % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185577,
                "title": "explaining-the-nlogn-n-thought-process",
                "content": "```\\n# Note that 1 << k == 2**k\\ndef sum_subsequence_widths(nums):\\n    nums.sort()\\n    mod = 10**9 + 7\\n    result = 0\\n    for i, n in enumerate(nums):\\n        # I am min for all the subsequences that start at me and end to the right.\\n        # For each of the subsequences that end to my right, subtract me once as min.\\n        result = (result - n*(1 << len(nums)-i-1)) % mod\\n        # I am max for all the subsequences that end at me.\\n        # For each of the subsequences that begin to my left, add me once as max.\\n        result = (result + n*(1 << i)) % mod\\n    \\n    return result\\n```",
                "solutionTags": [],
                "code": "```\\n# Note that 1 << k == 2**k\\ndef sum_subsequence_widths(nums):\\n    nums.sort()\\n    mod = 10**9 + 7\\n    result = 0\\n    for i, n in enumerate(nums):\\n        # I am min for all the subsequences that start at me and end to the right.\\n        # For each of the subsequences that end to my right, subtract me once as min.\\n        result = (result - n*(1 << len(nums)-i-1)) % mod\\n        # I am max for all the subsequences that end at me.\\n        # For each of the subsequences that begin to my left, add me once as max.\\n        result = (result + n*(1 << i)) % mod\\n    \\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 169511,
                "title": "lookup-table-of-the-power-of-2-for-acceleration",
                "content": "Use the dp lookup table to save the computation time.\\n```cpp\\n#define ll  long long\\nconst ll MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) \\n    {\\n        ll res = 0, sz = A.size();\\n        sort(A.begin(), A.end());\\n        ll dp[20001] = {0};\\n        dp[0] = 1;\\n        for(int i = 1; i < sz; i++)\\n        {\\n            dp[i] = (dp[i - 1] % MOD * 2) % MOD;\\n        }\\n        for(int i = 0; i < sz; i++)\\n        {\\n            res += A[i] * (dp[i] - dp[sz - i - 1]);\\n            res %= MOD;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n#define ll  long long\\nconst ll MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) \\n    {\\n        ll res = 0, sz = A.size();\\n        sort(A.begin(), A.end());\\n        ll dp[20001] = {0};\\n        dp[0] = 1;\\n        for(int i = 1; i < sz; i++)\\n        {\\n            dp[i] = (dp[i - 1] % MOD * 2) % MOD;\\n        }\\n        for(int i = 0; i < sz; i++)\\n        {\\n            res += A[i] * (dp[i] - dp[sz - i - 1]);\\n            res %= MOD;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167688,
                "title": "better-choice-of-modulo",
                "content": "Problems like this should have a smaller modulo so that the calculations never run into long type. Wrong answer due to use of **int** when answer is expected in **int** is simply infuriating.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 163661,
                "title": "what-is-the-error-in-this",
                "content": "```\\nsubs,r={()},0\\n        for num in nums:\\n            subs |= {sub+(num,)\\n                    for sub in subs}\\n        \\n        for i in subs:\\n            if len(i)>1: r+=max(i)-min(i)\\n                \\n        return r%((pow(10,9)+7))\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nsubs,r={()},0\\n        for num in nums:\\n            subs |= {sub+(num,)\\n                    for sub in subs}\\n        \\n        for i in subs:\\n            if len(i)>1: r+=max(i)-min(i)\\n                \\n        return r%((pow(10,9)+7))\\n\\t\\t\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 161885,
                "title": "python-math-time-o-nlogn",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        length=len(A)\\n        if(length==1):\\n            return 0\\n        p1=length-1\\n        p2=0\\n        P1=2**(length-1)\\n        P2=2**0\\n        index=0\\n        A.sort()\\n        mod=10**9+7\\n        while(p1>p2):\\n            index+=((P1-P2)*(A[p1]-A[p2]))\\n            index%=mod\\n            p1-=1\\n            p2+=1\\n            P1//=2\\n            P2*=2\\n        return index\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        length=len(A)\\n        if(length==1):\\n            return 0\\n        p1=length-1\\n        p2=0\\n        P1=2**(length-1)\\n        P2=2**0\\n        index=0\\n        A.sort()\\n        mod=10**9+7\\n        while(p1>p2):\\n            index+=((P1-P2)*(A[p1]-A[p2]))\\n            index%=mod\\n            p1-=1\\n            p2+=1\\n            P1//=2\\n            P2*=2\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161842,
                "title": "c-math-dp-solution-easy-to-explain-and-impl-in-20mins",
                "content": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n\\n        long long cur = 0;\\n        long long base = 1;\\n        long long res = 0;\\n\\n        int n = A.size();\\n        for (int i = 1; i < n; ++i) {\\n            long long delta = A[i] - A[i - 1];\\n            base = (base * 2) % MOD;\\n            cur = (cur * 2 + delta * (base - 1)) % MOD;\\n            res = (res + cur) % MOD;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n\\n        long long cur = 0;\\n        long long base = 1;\\n        long long res = 0;\\n\\n        int n = A.size();\\n        for (int i = 1; i < n; ++i) {\\n            long long delta = A[i] - A[i - 1];\\n            base = (base * 2) % MOD;\\n            cur = (cur * 2 + delta * (base - 1)) % MOD;\\n            res = (res + cur) % MOD;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 161742,
                "title": "my-c-o-nlgn-time-o-1-space-solution-with-detail-explanation",
                "content": "1. Sort the array first.\\n2.  For each pair `[j, i]`, if we choose elements between `j` ans `i`, then the maximum element is `A[i]`, and the minimum element is `A[j]`.\\n3.  We will choose at least two elements(which is `A[j]` and `A[i]`) and at most `i-j+1` elements.\\n4.  The total sum of pair `[j, i]` is \\n`(A[i] - A[j]) * (C(0, i-j-1) + C(1, i-j-1) + ... + C(i-j-1, i-j-1))`\\n`=(A[i] - A[j]) * (2^(i-j-1))`  \\n(`C(x, y)` means the total combinations of `y` numbers select `x` numbers)\\n5. Given an `i`, we can calculate all pairs `[j, i]`(`0 <= j < i`), use `S` to store\\n`S[i] = A[i] * (2^(i-1) + 2^(i-2) + ... + 2^(i-j-1) + ... + 2^1 + 2^0) `\\n`- (A[0] * 2^(i-1) + A[1] * 2^(i-2) + ... + A[j] * 2^(i-j-1) + ... + A[i-1] * 2^0)`\\n`= A[i] * (2^i - 1) -  (A[0] * 2^(i-1) + A[1] * 2^(i-2) + ... + A[j] * 2^(i-j-1) + ... + A[i-1] * 2^0)` \\n6. Use `sum` to store the right part of `-`, so we get this:\\n`S[i] = A[i] * (2^i - 1) -  sum[i]`\\n`sum[i] = 2 * sum[i-1] + A[i-1]`\\n7. The answer is sum of `S`, (by the way don\\'t forget mod `1000000007`)\\nthe c++ code below use two varible(`ans` and `sum`) to save the space.\\n```\\nclass Solution {\\npublic:\\n    #define M 1000000007\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long long ans=0, sum=A[0], p=2;\\n        for (int i=1;i<A.size();++i){\\n            ans=(ans+(p-1)*A[i]-sum)%M;\\n            sum=(2*sum+A[i])%M;\\n            p=(p<<1)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define M 1000000007\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long long ans=0, sum=A[0], p=2;\\n        for (int i=1;i<A.size();++i){\\n            ans=(ans+(p-1)*A[i]-sum)%M;\\n            sum=(2*sum+A[i])%M;\\n            p=(p<<1)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161393,
                "title": "19-64-test-pass-i-don-t-know-why-i-was-wrong-i-think-i-am-right",
                "content": "```\\n public  int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        for(int i:A)System.out.println(i);\\n        int sum=0;\\n        for(int n=2;n<=A.length;n++)\\n        {\\n            for(int m=0;m<=n-2;m++)\\n            {\\n                sum+=(A[n-1]-A[m])*(Math.pow(2,n-2-m));\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public  int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        for(int i:A)System.out.println(i);\\n        int sum=0;\\n        for(int n=2;n<=A.length;n++)\\n        {\\n            for(int m=0;m<=n-2;m++)\\n            {\\n                sum+=(A[n-1]-A[m])*(Math.pow(2,n-2-m));\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1568049,
                "content": [
                    {
                        "username": "leetgugu",
                        "content": "Firstly I used  a simple way as the provided solution like this:\\n       //sort A first\\n       sum += (A[j] - A[i]) * pow(2, j-i-1);\\nThen I realized the duplicated number is different and should be treated in a different way.\\n\\nLook the testcase array: [2,3,3,7]. The sum should be calculated with such steps:\\n1) subarray [2,3,3]:    non-zero sequence [2,3]  and [2,3,3] then sum += 2*1\\n2) subarray [2,3,3,7]: non-zero sequence [2,7], [2,3,7], [2,3,3,7]. then sum += 3*5\\n3) subarray [3,3]: sum += 0\\n4) subarray [3,3,7]: non-zero sequence [3,7],[3,3,7],  then sum += 2*4\\n\\nSo the final result is 25, rather than 35.\\n\\n35 is calculated by this way:\\n[2,3]   ----> [2,3]                sum += 1 * 1\\n[2,3,3] ---->[2,3](the number  3 is the number at last pos),[2,3,3]      sum += 2 * 1\\n[2,3,3,7] --->[2,7],[2,3,7],[2,3,7],[2,3,3,7]       sum += 4 * 5\\n[3,3,7].  ----> [3,7],[3,3,7].                sum += 2 * 4\\n[3,7]. -------->[3,7]                   sum += 1 * 4\\nthen sum =35\\n\\nbut I think when the duplicated numbers in different postions are picked into a subsequence, the original postion does not make any sense, so some subsequences which are equal should be ignored. Then the final sum is 25 in this testcase.\\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* **Sort**: Since Q does\\'t involve subarray, and sorting doesn\\'t affect the min-max in a subsequence, SORT!\\n* **Element contribution**: Instead of condiering the naive 2^N backtracking approach, consider each element being min and max. For this pre-computation of sort BECAME HANDY.\\n* **Subsequence property**: No. of subsequences ending at index i = 2^i\\n\\n**Similar**: https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/\\n\\n**Subsequences properties**:\\n![image](https://assets.leetcode.com/users/images/c6097e86-b794-4ae0-9612-9834a590ab75_1633799786.4522336.jpeg)\\n\\n"
                    },
                    {
                        "username": "huyalvchuan",
                        "content": "\\u5148\\u6392\\u5E8F\\u5F97\\u5230\\u6392\\u5E8F\\u540E\\u7684A\\n\\u7136\\u540E\\u6211\\u4EEC\\u901A\\u8FC7\\u89C2\\u5BDF\\u5F97\\u5230\\u4E0B\\u9762\\u7684\\u4E00\\u4E2A\\u516C\\u5F0F\\uFF1A\\nf(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u5BBD\\u3002\\nk(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u4E2A\\u6570\\n\\u90A3\\u4E48f(i) = 2 * (f(i - 1) + A[i] - A[i - 1]) + (A[i] - A[i - 1])"
                    }
                ]
            },
            {
                "id": 1567677,
                "content": [
                    {
                        "username": "leetgugu",
                        "content": "Firstly I used  a simple way as the provided solution like this:\\n       //sort A first\\n       sum += (A[j] - A[i]) * pow(2, j-i-1);\\nThen I realized the duplicated number is different and should be treated in a different way.\\n\\nLook the testcase array: [2,3,3,7]. The sum should be calculated with such steps:\\n1) subarray [2,3,3]:    non-zero sequence [2,3]  and [2,3,3] then sum += 2*1\\n2) subarray [2,3,3,7]: non-zero sequence [2,7], [2,3,7], [2,3,3,7]. then sum += 3*5\\n3) subarray [3,3]: sum += 0\\n4) subarray [3,3,7]: non-zero sequence [3,7],[3,3,7],  then sum += 2*4\\n\\nSo the final result is 25, rather than 35.\\n\\n35 is calculated by this way:\\n[2,3]   ----> [2,3]                sum += 1 * 1\\n[2,3,3] ---->[2,3](the number  3 is the number at last pos),[2,3,3]      sum += 2 * 1\\n[2,3,3,7] --->[2,7],[2,3,7],[2,3,7],[2,3,3,7]       sum += 4 * 5\\n[3,3,7].  ----> [3,7],[3,3,7].                sum += 2 * 4\\n[3,7]. -------->[3,7]                   sum += 1 * 4\\nthen sum =35\\n\\nbut I think when the duplicated numbers in different postions are picked into a subsequence, the original postion does not make any sense, so some subsequences which are equal should be ignored. Then the final sum is 25 in this testcase.\\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* **Sort**: Since Q does\\'t involve subarray, and sorting doesn\\'t affect the min-max in a subsequence, SORT!\\n* **Element contribution**: Instead of condiering the naive 2^N backtracking approach, consider each element being min and max. For this pre-computation of sort BECAME HANDY.\\n* **Subsequence property**: No. of subsequences ending at index i = 2^i\\n\\n**Similar**: https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/\\n\\n**Subsequences properties**:\\n![image](https://assets.leetcode.com/users/images/c6097e86-b794-4ae0-9612-9834a590ab75_1633799786.4522336.jpeg)\\n\\n"
                    },
                    {
                        "username": "huyalvchuan",
                        "content": "\\u5148\\u6392\\u5E8F\\u5F97\\u5230\\u6392\\u5E8F\\u540E\\u7684A\\n\\u7136\\u540E\\u6211\\u4EEC\\u901A\\u8FC7\\u89C2\\u5BDF\\u5F97\\u5230\\u4E0B\\u9762\\u7684\\u4E00\\u4E2A\\u516C\\u5F0F\\uFF1A\\nf(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u5BBD\\u3002\\nk(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u4E2A\\u6570\\n\\u90A3\\u4E48f(i) = 2 * (f(i - 1) + A[i] - A[i - 1]) + (A[i] - A[i - 1])"
                    }
                ]
            },
            {
                "id": 1572356,
                "content": [
                    {
                        "username": "leetgugu",
                        "content": "Firstly I used  a simple way as the provided solution like this:\\n       //sort A first\\n       sum += (A[j] - A[i]) * pow(2, j-i-1);\\nThen I realized the duplicated number is different and should be treated in a different way.\\n\\nLook the testcase array: [2,3,3,7]. The sum should be calculated with such steps:\\n1) subarray [2,3,3]:    non-zero sequence [2,3]  and [2,3,3] then sum += 2*1\\n2) subarray [2,3,3,7]: non-zero sequence [2,7], [2,3,7], [2,3,3,7]. then sum += 3*5\\n3) subarray [3,3]: sum += 0\\n4) subarray [3,3,7]: non-zero sequence [3,7],[3,3,7],  then sum += 2*4\\n\\nSo the final result is 25, rather than 35.\\n\\n35 is calculated by this way:\\n[2,3]   ----> [2,3]                sum += 1 * 1\\n[2,3,3] ---->[2,3](the number  3 is the number at last pos),[2,3,3]      sum += 2 * 1\\n[2,3,3,7] --->[2,7],[2,3,7],[2,3,7],[2,3,3,7]       sum += 4 * 5\\n[3,3,7].  ----> [3,7],[3,3,7].                sum += 2 * 4\\n[3,7]. -------->[3,7]                   sum += 1 * 4\\nthen sum =35\\n\\nbut I think when the duplicated numbers in different postions are picked into a subsequence, the original postion does not make any sense, so some subsequences which are equal should be ignored. Then the final sum is 25 in this testcase.\\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* **Sort**: Since Q does\\'t involve subarray, and sorting doesn\\'t affect the min-max in a subsequence, SORT!\\n* **Element contribution**: Instead of condiering the naive 2^N backtracking approach, consider each element being min and max. For this pre-computation of sort BECAME HANDY.\\n* **Subsequence property**: No. of subsequences ending at index i = 2^i\\n\\n**Similar**: https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/\\n\\n**Subsequences properties**:\\n![image](https://assets.leetcode.com/users/images/c6097e86-b794-4ae0-9612-9834a590ab75_1633799786.4522336.jpeg)\\n\\n"
                    },
                    {
                        "username": "huyalvchuan",
                        "content": "\\u5148\\u6392\\u5E8F\\u5F97\\u5230\\u6392\\u5E8F\\u540E\\u7684A\\n\\u7136\\u540E\\u6211\\u4EEC\\u901A\\u8FC7\\u89C2\\u5BDF\\u5F97\\u5230\\u4E0B\\u9762\\u7684\\u4E00\\u4E2A\\u516C\\u5F0F\\uFF1A\\nf(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u5BBD\\u3002\\nk(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u4E2A\\u6570\\n\\u90A3\\u4E48f(i) = 2 * (f(i - 1) + A[i] - A[i - 1]) + (A[i] - A[i - 1])"
                    }
                ]
            }
        ]
    },
    {
        "title": "Replace Elements with Greatest Element on Right Side",
        "question_content": "<p>Given an array <code>arr</code>,&nbsp;replace every element in that array with the greatest element among the elements to its&nbsp;right, and replace the last element with <code>-1</code>.</p>\n\n<p>After doing so, return the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [17,18,5,4,6,1]\n<strong>Output:</strong> [18,6,6,6,1,-1]\n<strong>Explanation:</strong> \n- index 0 --&gt; the greatest element to the right of index 0 is index 1 (18).\n- index 1 --&gt; the greatest element to the right of index 1 is index 4 (6).\n- index 2 --&gt; the greatest element to the right of index 2 is index 4 (6).\n- index 3 --&gt; the greatest element to the right of index 3 is index 4 (6).\n- index 4 --&gt; the greatest element to the right of index 4 is index 5 (1).\n- index 5 --&gt; there are no elements to the right of index 5, so we put -1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [400]\n<strong>Output:</strong> [-1]\n<strong>Explanation:</strong> There are no elements to the right of index 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 463249,
                "title": "java-c-python-straight-forward",
                "content": "## **Explanation**\\nIterate from the back to the start,\\nWe initilize `mx = -1`, where `mx` represent the max on the right.\\nEach round, we set `A[i] = mx`, where `mx` is its mas on the right.\\nAlso we update `mx = max(mx, A[i])`, where `A[i]` is its  original value.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int[] replaceElements(int[] A) {\\n        for (int i = A.length - 1, mx = -1; i >= 0; --i)\\n            mx = Math.max(A[i], A[i] = mx);\\n        return A;\\n    }\\n```\\n\\n**Java, expanded version:**\\n```java\\n    public int[] replaceElements2(int[] A) {\\n        int mx = -1, n = A.length, a;\\n        for (int i = n - 1; i >= 0; --i) {\\n            a = A[i];\\n            A[i] = mx;\\n            mx = Math.max(mx, a);\\n        }\\n        return A;\\n    }\\n```\\n\\n**C++:**\\n@0xFFFFFFFF suggest using `exchange`\\n```cpp\\n    vector<int> replaceElements(vector<int>& A, int mx = -1) {\\n        for (int i = A.size() - 1; i >= 0; --i)\\n            mx = max(mx, exchange(A[i], mx));\\n        return A;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def replaceElements(self, A, mx = -1):\\n        for i in xrange(len(A) - 1, -1, -1):\\n            A[i], mx = mx, max(mx, A[i])\\n        return A\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[] replaceElements(int[] A) {\\n        for (int i = A.length - 1, mx = -1; i >= 0; --i)\\n            mx = Math.max(A[i], A[i] = mx);\\n        return A;\\n    }\\n```\n```java\\n    public int[] replaceElements2(int[] A) {\\n        int mx = -1, n = A.length, a;\\n        for (int i = n - 1; i >= 0; --i) {\\n            a = A[i];\\n            A[i] = mx;\\n            mx = Math.max(mx, a);\\n        }\\n        return A;\\n    }\\n```\n```cpp\\n    vector<int> replaceElements(vector<int>& A, int mx = -1) {\\n        for (int i = A.size() - 1; i >= 0; --i)\\n            mx = max(mx, exchange(A[i], mx));\\n        return A;\\n    }\\n```\n```python\\n    def replaceElements(self, A, mx = -1):\\n        for i in xrange(len(A) - 1, -1, -1):\\n            A[i], mx = mx, max(mx, A[i])\\n        return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 799052,
                "title": "easy-c-solution-o-n-faster-than-99-44",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        int n=arr.size(),temp,mx=-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            temp=arr[i];\\n            arr[i]=mx;\\n            mx=max(mx,temp);\\n        }\\n     return arr;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        int n=arr.size(),temp,mx=-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            temp=arr[i];\\n            arr[i]=mx;\\n            mx=max(mx,temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3340519,
                "title": "java-easy-similar-to-leaders-in-an-array",
                "content": "**T.C.:- O(N)\\nS.C.:- O(1)**\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=-1;\\n        for(int i=arr.length-1;i>=0;i--){\\n            if(arr[i]>max){\\n                int temp=max;\\n                max=arr[i];\\n                arr[i]=temp;\\n            }\\n            else\\n                arr[i]=max;\\n        }\\n        return arr;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/1bde3f1a-2bb3-45d1-92c0-4d579992e1c6_1679762566.7449884.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=-1;\\n        for(int i=arr.length-1;i>=0;i--){\\n            if(arr[i]>max){\\n                int temp=max;\\n                max=arr[i];\\n                arr[i]=temp;\\n            }\\n            else\\n                arr[i]=max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544507,
                "title": "i-don-t-understand-the-question",
                "content": "> Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.\\n\\nAfter doing so, return the array.\\n\\n \\n\\nExample 1:\\n\\nInput: arr = [17,18,5,4,6,1]\\nOutput: [18,6,6,6,1,-1]\\n\\n-------------------------------------\\n\\nEvery element in `arr` is `[17,18,5,4,6,1]`. If we replace every element with the greatest element among the elements to its right.. Well there is no other element to the right of the array. After the array, the input is ended. \\n\\nIf they meant repalce _each_ value in that array with the value of the greatest element to that element\\'s right, that\\'s different. Every and each have specific and distinct meaning.\\n\\nWhy are they lying in their question again? To confuse us?\\n\\nFollowing what I\\'ve written, whcih is different, we can get it to pass. We take ` [17,18,5,4,6,1]` and result in  [**18**,18,5,4,6,1], then [18,**6**,5,4,6,1], then [18,6,**6**,4,6,1], then [18,6,6,**6**,6,1], then , then [18,6,6,6,1,1]. \\n\\nAnd then, replacing the last element with `-1`, it becomes [18,6,6,6,1,-**1**].\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nconst replaceElements = function(arr) {\\n    const b = Array.from(arr);\\n    for(let i = 0; i < b.length; i++) {\\n        b[i] = Math.max(...b.slice(i+1));\\n    }\\n    b[b.length-1] = -1;\\n    return b;\\n};\\n```\\nIs it a problem with LeetCode not knowing English? Or do they not know how to proofread? Or are they deliberately fucking the questions up to make easy questions impossible?",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nconst replaceElements = function(arr) {\\n    const b = Array.from(arr);\\n    for(let i = 0; i < b.length; i++) {\\n        b[i] = Math.max(...b.slice(i+1));\\n    }\\n    b[b.length-1] = -1;\\n    return b;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557857,
                "title": "easy-to-understand-simple-python-solution",
                "content": "```\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        i = len(arr) -1 \\n        while i >= 0:\\n            temp = arr[i]\\n            arr[i] = m\\n            if temp > m:\\n                m = temp\\n            i-= 1\\n        return arr\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        i = len(arr) -1 \\n        while i >= 0:\\n            temp = arr[i]\\n            arr[i] = m\\n            if temp > m:\\n                m = temp\\n            i-= 1\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 487742,
                "title": "javascript-optimal-solution-w-explanation",
                "content": "First of all, I created a base array in which I will write the results.\\n\\nInitially, I already know that there will be a shift in the array: the first value will disappear, and the last will be `-1`. That\\'s why I know that the last `result` value is `-1`.\\n\\nThen, I go through the input `arr` from the end, each time checking the current value `arr[i]` with the previous value that has already been changed (which has the same index in the resulting array `result[i]`) and set the next bigger value in `result[i-1]` because as I go from the end.\\n\\nThe solution is good because in the end, you no longer need to modify the array. It just needs to be returned.\\n<br/>\\n\\n```javascript\\nconst replaceElements = arr => {\\n    const result = new Array(arr.length);\\n    result[arr.length - 1] = -1;\\n    \\n    for (let i = arr.length - 1; i > 0; i -= 1) {\\n        result[i - 1] = Math.max(arr[i], result[i]);\\n    }\\n    \\n    return result;\\n};\\n```\\n\\n<br/>\\n\\nI hope this explanation will be useful to you.\\n\\n<br/>\\n\\n**Results**:\\n\\nRuntime: **72 ms**, faster than **94.81%** of JavaScript online submissions.\\nMemory Usage: **37.9 MB**, less than **100.00%** of JavaScript online submissions.\\n\\n<br/>",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst replaceElements = arr => {\\n    const result = new Array(arr.length);\\n    result[arr.length - 1] = -1;\\n    \\n    for (let i = arr.length - 1; i > 0; i -= 1) {\\n        result[i - 1] = Math.max(arr[i], result[i]);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463227,
                "title": "java-python-3-scan-from-right-to-left",
                "content": "```java\\n    public int[] replaceElements(int[] arr) {\\n        for (int i = arr.length - 1, max = -1; i >= 0; --i) {\\n            int tmp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, tmp);\\n        }\\n        return arr;\\n    }\\n```\\n```python\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        mx = -1\\n        for i in range(len(arr) - 1, -1, -1):\\n            arr[i], mx = mx, max(arr[i], mx)\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int[] replaceElements(int[] arr) {\\n        for (int i = arr.length - 1, max = -1; i >= 0; --i) {\\n            int tmp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, tmp);\\n        }\\n        return arr;\\n    }\\n```\n```python\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        mx = -1\\n        for i in range(len(arr) - 1, -1, -1):\\n            arr[i], mx = mx, max(arr[i], mx)\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 482693,
                "title": "java-o-n-time-o-1-space-simple-clear-100-solution",
                "content": "This is the straightforward and simple Java solution to this question\\n```\\n// Replace Elements with Greatest Element on Right Side\\n\\n    public int[] replaceElements(int[] arr) {\\n        int maxSoFar = arr[arr.length - 1]; //take last element in array as maxVal\\n        arr[arr.length - 1] = -1;\\n\\t\\t//start array traversal from right to left\\n        for(int i = arr.length - 2; i > -1; i--){\\n            int currVal = arr[i];\\n            arr[i] = maxSoFar;\\n            maxSoFar = Math.max(maxSoFar, currVal);\\n\\t\\t\\t//keep updating maxRight element encountered so far\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Replace Elements with Greatest Element on Right Side\\n\\n    public int[] replaceElements(int[] arr) {\\n        int maxSoFar = arr[arr.length - 1]; //take last element in array as maxVal\\n        arr[arr.length - 1] = -1;\\n\\t\\t//start array traversal from right to left\\n        for(int i = arr.length - 2; i > -1; i--){\\n            int currVal = arr[i];\\n            arr[i] = maxSoFar;\\n            maxSoFar = Math.max(maxSoFar, currVal);\\n\\t\\t\\t//keep updating maxRight element encountered so far\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463190,
                "title": "java-traverse-backwards",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        if(n == 0) return arr;\\n        int max = arr[n - 1];\\n        for(int i = n - 2; i >= 0; i--){\\n            int temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }\\n        arr[n - 1] = -1;\\n        return arr;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        if(n == 0) return arr;\\n        int max = arr[n - 1];\\n        for(int i = n - 2; i >= 0; i--){\\n            int temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1068886,
                "title": "java-fast-solution-beats-100-o-n",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        var max = -1;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            var tmp = arr[i];\\n            arr[i] = max;\\n            if (tmp > max) {\\n                max = tmp;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        var max = -1;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            var tmp = arr[i];\\n            arr[i] = max;\\n            if (tmp > max) {\\n                max = tmp;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522807,
                "title": "python-in-place-clean-4-lines-fast-96ms-99-with-explanation",
                "content": "The standard approach ... we start from the end, use `me` to track the max element to the right value.\\n\\n1. we start with setting me to the value of the last element and setting the last element to -1\\n2. now we slide down to the beginning of the lest and for each step we set the arr[i] to the current me and then we update me to be the max of the current me or the arr[i] value before it was updated. Actually, Python allows both steps to be done in one line without extra temp variables. that is nice. So if you look at `arr[i],me = me,max(me,arr[i])` - the me and arr[i] on the right side are before they were updated and on the left side - after. Neat, right?\\n\\nOk, now we just return arr.\\n\\n```\\nclass Solution(object):\\n    def replaceElements(self, arr):\\n    \\n        me,arr[-1] = arr[-1],-1\\n        \\n        for i in range(len(arr)-2,-1,-1):\\n            arr[i],me = me,max(me,arr[i])\\n            \\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def replaceElements(self, arr):\\n    \\n        me,arr[-1] = arr[-1],-1\\n        \\n        for i in range(len(arr)-2,-1,-1):\\n            arr[i],me = me,max(me,arr[i])\\n            \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648596,
                "title": "java-easy-to-understand-linear-scanning-from-end-to-beginning",
                "content": "I know it is a very straightforward problem, but still I would like to share my solution in case it might be useful to anyone. I wish you all good luck and have fun.\\n\\n    public int[] replaceElements(int[] arr) {\\n              \\n        int max = -1; // All elements in the input range are positive. Otherwise, it can be modified slightly\\n        \\n        for (int i = arr.length - 1; i >= 0; i--)\\n        {\\n            int temp = arr[i];\\n            arr[i] = max; \\n            max = Math.max(max, temp);\\n        }\\n        return arr;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I know it is a very straightforward problem, but still I would like to share my solution in case it might be useful to anyone. I wish you all good luck and have fun.\\n\\n    public int[] replaceElements(int[] arr) {\\n              \\n        int max = -1; // All elements in the input range are positive. Otherwise, it can be modified slightly\\n        \\n        for (int i = arr.length - 1; i >= 0; i--)\\n        {\\n            int temp = arr[i];\\n            arr[i] = max; \\n            max = Math.max(max, temp);\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 478465,
                "title": "python-3-faster-than-99-7-memory-less-than-100",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        out = [-1]\\n        greatest = 0\\n        for num in arr[::-1]:\\n            if greatest < num:\\n                greatest = num\\n            out.append(greatest)\\n        out.pop()\\n        return out[::-1]\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        out = [-1]\\n        greatest = 0\\n        for num in arr[::-1]:\\n            if greatest < num:\\n                greatest = num\\n            out.append(greatest)\\n        out.pop()\\n        return out[::-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2579337,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr)\\n    {\\n        int mx=-1;\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            int temp=max(mx,arr[i]);\\n            arr[i]=mx;\\n            mx=temp;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr)\\n    {\\n        int mx=-1;\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            int temp=max(mx,arr[i]);\\n            arr[i]=mx;\\n            mx=temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 612028,
                "title": "java-solution-100-and-100",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int[] result = new int[arr.length];\\n        int maxValue = -1;\\n        for(int x = arr.length-1; x >=0; x--) {\\n        \\tresult[x] = maxValue;\\n        \\tmaxValue = Math.max(arr[x], maxValue);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int[] result = new int[arr.length];\\n        int maxValue = -1;\\n        for(int x = arr.length-1; x >=0; x--) {\\n        \\tresult[x] = maxValue;\\n        \\tmaxValue = Math.max(arr[x], maxValue);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479005,
                "title": "c",
                "content": "```\\npublic int[] ReplaceElements(int[] arr) {\\n\\tvar max = -1;\\n\\tfor (var i = arr.Length - 1; i >= 0; i--) {\\n\\t\\tvar tmp = arr[i];\\n\\t\\tarr[i] = max;\\n\\t\\tif (tmp > max) {\\n\\t\\t\\tmax = tmp;\\n\\t\\t}\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] ReplaceElements(int[] arr) {\\n\\tvar max = -1;\\n\\tfor (var i = arr.Length - 1; i >= 0; i--) {\\n\\t\\tvar tmp = arr[i];\\n\\t\\tarr[i] = max;\\n\\t\\tif (tmp > max) {\\n\\t\\t\\tmax = tmp;\\n\\t\\t}\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 601747,
                "title": "python-super-simple-explanation-must-read",
                "content": "Starting at the end of the array, at each position there are three things to do:\\n\\t\\t1. Hold the value in that position\\n\\t\\t2. Insert maximum number until that position\\n\\t\\t3. Compare \\'hold\\' value with maximum value, the greater is new maximum number.\\n- First maximum number value is -1. \\n- First \\'hold\\' value is value at the end of array\\n\\n```\\n    maxNum = -1\\n\\tfor i in range(len(arr)-1,-1,-1):\\n\\t\\thold = arr[i]\\n\\t\\tarr[i] = maxNum\\n\\t\\tif hold > maxNum:\\n\\t\\t\\tmaxNum = hold\\n\\treturn arr\\n```\\nTime complexity - O(n)\\nSpace complexity - O(1)\\n\\n- amen-Ra",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\n    maxNum = -1\\n\\tfor i in range(len(arr)-1,-1,-1):\\n\\t\\thold = arr[i]\\n\\t\\tarr[i] = maxNum\\n\\t\\tif hold > maxNum:\\n\\t\\t\\tmaxNum = hold\\n\\treturn arr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643620,
                "title": "faster-than-99-31",
                "content": "``` \\nvar replaceElements = function(arr) {\\n    let max = arr[arr.length - 1];\\n    arr[arr.length - 1] = -1;\\n    \\n    for(let i = arr.length - 2; i >= 0; i--) {\\n        let curr = arr[i];\\n        arr[i] = max;\\n        if(curr > max) max = curr;\\n    }\\n    \\n    return arr;\\n};\\n```\\n\\nRuntime: **73** ms, faster than **99.31%** of JavaScript online submissions for Replace Elements with Greatest Element on Right Side.\\nMemory Usage: **45.1** MB, less than **79.20%** of JavaScript online submissions for Replace Elements with Greatest Element on Right Side.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` \\nvar replaceElements = function(arr) {\\n    let max = arr[arr.length - 1];\\n    arr[arr.length - 1] = -1;\\n    \\n    for(let i = arr.length - 2; i >= 0; i--) {\\n        let curr = arr[i];\\n        arr[i] = max;\\n        if(curr > max) max = curr;\\n    }\\n    \\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2366624,
                "title": "with-explanation-comments-time-24-ms-63-84-space-14-6-mb-69-38",
                "content": "**Like it? ->Upvote please!**\\n\\n**Solution 1:**\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        //base case: if there\\'s only one element-> replace it with -1\\n        if(arr.size()==1){\\n            arr[0]=-1;\\n            return arr;\\n        }\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<arr.size();i++){\\n            //initialize the maximum variable with 0 in each step\\n            int max=0;\\n            //loop over the remainder array elements again\\n            for(int j=i+1;j<arr.size();j++)\\n                //get the largest value\\n                if(arr[j]>max)\\n                    max=arr[j];\\n            //replace the current value with the max one\\n            arr[i]=max;\\n        }\\n        \\n        //after that-> replace the last value with -1 & return the array\\n        arr[arr.size()-1]=-1;\\n        return arr;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Solution 2:**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        int maximum=-1;\\n        //loop over the whole array elements\\n        for(int i=arr.size()-1;i>=0;i--){\\n            //store the current value in a temp variable\\n            int temp=arr[i];\\n            //replace the current value with the maximum one & by default, the last element will be -1, as the initial value is it\\'s\\n            arr[i]=maximum;\\n            //get the largest element by comparing\\n            maximum=max(maximum,temp);\\n        }\\n\\n        //return the array elements\\n        return arr;\\n    }\\n};\\n\\'\\'\\'\\n\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        //base case: if there\\'s only one element-> replace it with -1\\n        if(arr.size()==1){\\n            arr[0]=-1;\\n            return arr;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2351429,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        curr_max = arr[-1]\\n        arr[-1] = -1\\n        for i in range(len(arr)-2,-1,-1):\\n            curr = arr[i]\\n            arr[i] = curr_max\\n            if curr>curr_max:\\n                curr_max = curr\\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        curr_max = arr[-1]\\n        arr[-1] = -1\\n        for i in range(len(arr)-2,-1,-1):\\n            curr = arr[i]\\n            arr[i] = curr_max\\n            if curr>curr_max:\\n                curr_max = curr\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417547,
                "title": "c-easy-solution-variation-of-leader-elements-in-array",
                "content": "```\\n The question is just a variation of problem \" Leaders in an array \". We just have to keep \\n track of maximum element on right side of any element. Traverse the loop from last \\n elelement. We know there is no element on right side of last element so put -1.  And \\n bang you solved the problem. We just need to identify the variation ( easy peasy \\u263A\\uFE0F)\\n ```\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size();\\n        int ma=arr[n-1];\\n        arr[n-1]=-1;\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int c=ma;\\n               ma=max(arr[i],ma);\\n            arr[i]=c;\\n        }\\n        return arr;\\n    }\\n};\\n```\\nPlease upvote if you like !! \\nHAPPY CODING:)",
                "solutionTags": [],
                "code": "```\\n The question is just a variation of problem \" Leaders in an array \". We just have to keep \\n track of maximum element on right side of any element. Traverse the loop from last \\n elelement. We know there is no element on right side of last element so put -1.  And \\n bang you solved the problem. We just need to identify the variation ( easy peasy \\u263A\\uFE0F)\\n ```\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size();\\n        int ma=arr[n-1];\\n        arr[n-1]=-1;\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int c=ma;\\n               ma=max(arr[i],ma);\\n            arr[i]=c;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593302,
                "title": "c-100-memory-one-pass",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int max_num = -1;\\n        vector<int> res = arr;\\n        for (int i=arr.size()-1; i>=0; i--) {\\n            res[i] = max_num;\\n            max_num = max(max_num, arr[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int max_num = -1;\\n        vector<int> res = arr;\\n        for (int i=arr.size()-1; i>=0; i--) {\\n            res[i] = max_num;\\n            max_num = max(max_num, arr[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869693,
                "title": "12ms-c-using-stack-easy-to-understand",
                "content": "```\\n**Pls Upvote if you like it**\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) \\n\\t{\\n        stack<int> hello ;  // Initialize a stack\\n        vector<int> ans (1,-1) ; // base condition , -1 should be present in array at last position\\n        \\n        hello.push(arr[arr.size()-1]) ; // push last element in stack because it is necessary \\n        for (int i=arr.size()-2; i>=0 ; i--) // traverse it from back\\n        {\\n            ans.push_back(hello.top()) ;\\n            \\n            if (hello.top()<arr[i]) // check maximum element \\n                hello.push(arr[i]) ;  // if found then push it into stack\\n        }\\n        \\n        reverse(ans.begin(),ans.end()) ; // reverse your answer array \\n        return ans ; // here is your solution\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n**Pls Upvote if you like it**\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) \\n\\t{\\n        stack<int> hello ;  // Initialize a stack\\n        vector<int> ans (1,-1) ; // base condition , -1 should be present in array at last position\\n        \\n        hello.push(arr[arr.size()-1]) ; // push last element in stack because it is necessary \\n        for (int i=arr.size()-2; i>=0 ; i--) // traverse it from back\\n        {\\n            ans.push_back(hello.top()) ;\\n            \\n            if (hello.top()<arr[i]) // check maximum element \\n                hello.push(arr[i]) ;  // if found then push it into stack\\n        }\\n        \\n        reverse(ans.begin(),ans.end()) ; // reverse your answer array \\n        return ans ; // here is your solution\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967005,
                "title": "java-and-go-solutions-with-explanation-and-images",
                "content": "# ***Code Is On The Bottom***\\n**If you found this helpful please up vote**\\n\\nThis problems wording is kind of confusing so I decided to try to explain it.\\n\\nI am using the descriptions example, `[17, 18, 5, 4, 6, 1]` for my example because we know that the output should be `[18, 6, 6, 6, 1, -1]`.\\n\\nBefore I start with the example I will explain what the problem is actualy asking us to do. It is asking us to start at the begining character and then check for the greatest character in all the items after it. Then after that to do the second character, find the max value in all the item the follow the second character. They ask us to do this up to one from the end. For the last item they ask us to make that `-1`, ( *Note, they are not asking us to make the last character negative, they are asking to make it exactly `-1`*).\\n\\n# **If you don\\'t understand my example just look at my code or picture**\\n\\n* For the example `[17, 18, 5, 4, 6, 1]` we will start off with the first number, `17`. We have to replace this number with the greatest number that has an index that is greater than its own, `18`.\\n* Then we will go to the next number `18`. The number that is greatest and has a index greater than eighteens is  `6` so replace `18` with `6`.\\n* The next number is `5` the greatest number that has a index greater than `5\\'s` is also `6` so we replace `5` with `6`.\\n* The next number, `4` can also be replaced by `6`.\\n* Now we get to `6`, so we find the greatest number that has a index greater than six\\'s, `1`. So we replace `6` with `1`.\\n* For the last number we have to make it `-1`.\\n\\nNow we end up with the array `[18, 6, 6, 6, 1, -1]`.\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/10273d03-be15-4706-836a-0af03df741ee_1607608209.7424724.png)\\n\\n\\n**Java solution:**\\n```\\npublic int[] replaceElements(int[] arr) {\\n\\tfor (int i = 0; i < arr.length - 1; i++) {\\n\\t\\tint max = 0;\\n\\t\\tfor (int j = i + 1; j < arr.length; j++) {\\n\\t\\t\\tif (arr[j] > max){\\n\\t\\t\\t\\tmax = arr[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max;\\n\\t}\\n\\tarr[arr.length - 1] = -1;\\n\\treturn arr;\\n}\\n```\\n\\n\\n**Go solution:**\\n\\n```\\nfunc replaceElements(arr []int) []int {\\n\\tfor i := range arr{\\n\\t\\tmax := 0\\n\\t\\tfor j := i + 1; j < len(arr); j++ {\\n\\t\\t\\tif arr[j] > max {\\n\\t\\t\\t\\tmax = arr[j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max\\n\\t}\\n\\tarr[len(arr) - 1] = -1\\n\\treturn arr\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] replaceElements(int[] arr) {\\n\\tfor (int i = 0; i < arr.length - 1; i++) {\\n\\t\\tint max = 0;\\n\\t\\tfor (int j = i + 1; j < arr.length; j++) {\\n\\t\\t\\tif (arr[j] > max){\\n\\t\\t\\t\\tmax = arr[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max;\\n\\t}\\n\\tarr[arr.length - 1] = -1;\\n\\treturn arr;\\n}\\n```\n```\\nfunc replaceElements(arr []int) []int {\\n\\tfor i := range arr{\\n\\t\\tmax := 0\\n\\t\\tfor j := i + 1; j < len(arr); j++ {\\n\\t\\t\\tif arr[j] > max {\\n\\t\\t\\t\\tmax = arr[j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max\\n\\t}\\n\\tarr[len(arr) - 1] = -1\\n\\treturn arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526028,
                "title": "fastest-javascript-solution-w-stack-most-optimal-solution",
                "content": "```\\nconst replaceElements = (arr) => {\\n    let stack = [-1]\\n    for(let i = arr.length-1; i > 0; i--){\\n        if(stack.peak() < arr[i])stack.push(arr[i])\\n        else stack.push(stack.peak())\\n    }\\n    return stack.reverse()\\n};\\nArray.prototype.peak = function(){return this[this.length-1]}\\n```\\nOptimized O(1) Space O(n) Time Solution. (This Solution is Better)\\n```\\nconst replaceElements = (arr) => {\\n    let currMax = arr[arr.length-1]\\n    arr[arr.length-1] = -1\\n    for(let i = arr.length-2; i >= 0; i--){\\n        let curr = arr[i]\\n        arr[i] = currMax\\n        if(curr > currMax)currMax = curr\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst replaceElements = (arr) => {\\n    let stack = [-1]\\n    for(let i = arr.length-1; i > 0; i--){\\n        if(stack.peak() < arr[i])stack.push(arr[i])\\n        else stack.push(stack.peak())\\n    }\\n    return stack.reverse()\\n};\\nArray.prototype.peak = function(){return this[this.length-1]}\\n```\n```\\nconst replaceElements = (arr) => {\\n    let currMax = arr[arr.length-1]\\n    arr[arr.length-1] = -1\\n    for(let i = arr.length-2; i >= 0; i--){\\n        let curr = arr[i]\\n        arr[i] = currMax\\n        if(curr > currMax)currMax = curr\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2071637,
                "title": "python3-o-n-in-place-solution",
                "content": "Although a straight-forwarded solution which most of people could come up with is for each element at ith index : \\n```\\n# For each ith element, find the maximum value beyond its index then assign to it, do so for every element.\\narr[ i ] = max( arr[ i + 1: ] ) \\n```\\nSuch method essentially gives a **O(n^2)** runtime as for each element, it needs to look up all elements at its right side.\\nInstead looking from left to right, we could do it reversly from the end of array, by doing so it only needs a variable to keep the rightmost maximum.\\nUse a variable \"max\" to track the current maximum with initial value -1 ( *as required the last element is set to -1.* )\\n\\n![image](https://assets.leetcode.com/users/images/3a57c8d0-70f0-4845-81ce-7e15b74da15d_1653454837.6219654.png)\\n\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        r_max = -1\\n        for i in range(len(arr)-1, -1, -1):\\n            temp = arr[i]\\n            arr[i] = r_max\\n            if temp > r_max:\\n                r_max = temp\\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\n# For each ith element, find the maximum value beyond its index then assign to it, do so for every element.\\narr[ i ] = max( arr[ i + 1: ] ) \\n```\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        r_max = -1\\n        for i in range(len(arr)-1, -1, -1):\\n            temp = arr[i]\\n            arr[i] = r_max\\n            if temp > r_max:\\n                r_max = temp\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058153,
                "title": "easy-and-simple-python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        mx = arr[-1]\\n        arr[-1] = -1\\n        for i in range(len(arr) - 2, -1, -1):\\n            temp = arr[i]\\n            arr[i] = mx\\n            if mx < temp: mx = temp\\n        return arr\\n```\\nfor more such questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        mx = arr[-1]\\n        arr[-1] = -1\\n        for i in range(len(arr) - 2, -1, -1):\\n            temp = arr[i]\\n            arr[i] = mx\\n            if mx < temp: mx = temp\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852552,
                "title": "java-1ms-o-n-runtime-99-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatest = -1;\\n        for(int i=arr.length-1;i>=0;i--){\\n            int temp = arr[i];\\n            arr[i] = greatest;\\n            greatest = Math.max(temp,greatest);\\n        }\\n        return arr;\\n    }\\n}\\n//Note that we do not take into account the input array when calculating space complexity.\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatest = -1;\\n        for(int i=arr.length-1;i>=0;i--){\\n            int temp = arr[i];\\n            arr[i] = greatest;\\n            greatest = Math.max(temp,greatest);\\n        }\\n        return arr;\\n    }\\n}\\n//Note that we do not take into account the input array when calculating space complexity.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489146,
                "title": "java-easy-to-understand-solution-with-analysis-1ms-better-than-100",
                "content": "Hey everyone,\\n\\nThe problem asks us to update each element in the array to be the greatest of elements to its right.\\nIf we go left to right, we compare the current element to each element to its right. We\\'ll end up with an O(n^2) solution. So, the element on the left is always determined by the elements on the right. Once we reach the largest element on the right, we don\\'t need to go any farther. How can we avoid doing all this extra work?\\n\\nLet\\'s approach the problem from right to left. By going right to left and updating the current element to the biggest seen so far, we handle the problem of doing excess work. In other words, we keep track of the solution so far/build up the solution, a type of memoization.\\n\\nSo, how do we do this? When we reach an element it will always be updated to the greatest element value seen so far. So, we need a variable to keep track of this greatest value, let\\'s call it *greatest*. We know that if the current element is greater than *greatest* we need to update the value of *greatest* to the current element\\'s value. But, how do we compare the the current element with the greatest so far without losing the current element value? We need a temporary variable to store this, let\\'s call it *temp*. So, the logic here is store the element\\'s value as *temp*. Update the element to *greatest*\\'s value. Then, if *temp* is greater than *greatest*, we update *greatest* to *temp*\\'s value.\\n\\n**Algorithm**:\\n\\u2022 Initialize int *greatest* as -1.\\n\\u2022 Iterate decrementally through passed array.\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\u2022 Store current element value as *temp*.\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\u2022 Update the current element with *greatest*.\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\u2022 If the element was greater than *greatest*, update it.\\n\\u2022 Return the array.\\n\\n**Complexity**\\nLet *n* represent the size of array *arr*.\\n\\nWe iterate through *n* only once. So, our time complexity is **O(*n*)**.\\n\\nWe only use 2 variables no matter what the input, and we overwrite the passed array using no extra space. So, space complexity is constant **O(1)**.\\n\\nHope this helps :)\\n\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatest = -1; //Initialize greatest as -1\\n        \\n        //Iterate decrementally through array\\n        for(int i = arr.length-1; i >= 0; i--) {\\n            int temp = arr[i]; //Get current element as temp\\n            arr[i] = greatest; //Update current element with greatest\\n            greatest = Math.max(greatest, temp); //If the element was greater than greatest, update greatest\\n        }\\n        return arr; //Return the array\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatest = -1; //Initialize greatest as -1\\n        \\n        //Iterate decrementally through array\\n        for(int i = arr.length-1; i >= 0; i--) {\\n            int temp = arr[i]; //Get current element as temp\\n            arr[i] = greatest; //Update current element with greatest\\n            greatest = Math.max(greatest, temp); //If the element was greater than greatest, update greatest\\n        }\\n        return arr; //Return the array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658953,
                "title": "js-very-easy-solution-with-o-n",
                "content": "```\\nvar replaceElements = function(arr) {\\n    let currentMax = arr[arr.length - 1];\\n    arr[arr.length - 1] = -1;\\n\\n    for (let i = arr.length - 2; i >= 0; i--) {\\n        if (currentMax > arr[i]) {\\n            arr[i] = currentMax;\\n        } else {\\n            const temp = currentMax;\\n            currentMax = arr[i];\\n            arr[i] = temp;\\n        }\\n    }\\n    \\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar replaceElements = function(arr) {\\n    let currentMax = arr[arr.length - 1];\\n    arr[arr.length - 1] = -1;\\n\\n    for (let i = arr.length - 2; i >= 0; i--) {\\n        if (currentMax > arr[i]) {\\n            arr[i] = currentMax;\\n        } else {\\n            const temp = currentMax;\\n            currentMax = arr[i];\\n            arr[i] = temp;\\n        }\\n    }\\n    \\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 760502,
                "title": "python-o-n-with-comments-explanation-easy-to-understand",
                "content": "Strat:\\n    Iterate through arr, from right to left, while keeping track of the largest element we\\'ve seen. max_so_far starts out at -1, because that\\'s what the last elem\\'s value will be. As we iterate, we compare to current num\\'s value to max_so_far; update as appropiate. \\n\\nStats: O(n) time\\n    Runtime: 112 ms, faster than 76.23% of Python online submissions for Replace Elements with Greatest Element on Right Side.\\n    Memory Usage: 14.3 MB, less than 21.28% of Python online submissions for Replace Elements with Greatest Element on Right Side.\\n\\t\\nHere\\'s the code:\\n\\n\\tclass Solution(object):\\n    def replaceElements(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        length = len(arr)\\n        max_so_far = -1\\n        result = [0] * length\\n        \\n        #iterate through arr, from right to left, one elem at a time\\n        for i in range(length - 1, -1, -1):\\n            #store max_so_far in results & update it\\n            result[i] = max_so_far\\n            max_so_far = max(max_so_far, arr[i])\\n            \\n        return result\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Strat:\\n    Iterate through arr, from right to left, while keeping track of the largest element we\\'ve seen. max_so_far starts out at -1, because that\\'s what the last elem\\'s value will be. As we iterate, we compare to current num\\'s value to max_so_far; update as appropiate. \\n\\nStats: O(n) time\\n    Runtime: 112 ms, faster than 76.23% of Python online submissions for Replace Elements with Greatest Element on Right Side.\\n    Memory Usage: 14.3 MB, less than 21.28% of Python online submissions for Replace Elements with Greatest Element on Right Side.\\n\\t\\nHere\\'s the code:\\n\\n\\tclass Solution(object):\\n    def replaceElements(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        length = len(arr)\\n        max_so_far = -1\\n        result = [0] * length\\n        \\n        #iterate through arr, from right to left, one elem at a time\\n        for i in range(length - 1, -1, -1):\\n            #store max_so_far in results & update it\\n            result[i] = max_so_far\\n            max_so_far = max(max_so_far, arr[i])\\n            \\n        return result\\n",
                "codeTag": "Java"
            },
            {
                "id": 690979,
                "title": "java-simple-looping-from-end",
                "content": "```\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1, n = arr.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int tmp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, tmp);\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1, n = arr.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int tmp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, tmp);\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 595286,
                "title": "c-5-lines",
                "content": "```\\nint* replaceElements(int* arr, int arrSize, int* returnSize){\\n    *returnSize=arrSize;\\n    for(int i=arrSize-1,tmp=0,max=-1;i>=0;i--){\\n        tmp=arr[i];\\n        arr[i]=max;\\n        max=(max>tmp)?max:tmp;\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* replaceElements(int* arr, int arrSize, int* returnSize){\\n    *returnSize=arrSize;\\n    for(int i=arrSize-1,tmp=0,max=-1;i>=0;i--){\\n        tmp=arr[i];\\n        arr[i]=max;\\n        max=(max>tmp)?max:tmp;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 500168,
                "title": "simple-javascript-solution-beats-91",
                "content": "Runtime: 76 ms, faster than 91.51% of JavaScript online submissions for Replace Elements with Greatest Element on Right Side.\\nMemory Usage: 37.8 MB, less than 100.00% of JavaScript online submissions for Replace Elements with Greatest Element on Right Side.\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nconst replaceElements = arr => {\\n    let lastMax = -1\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        const val = arr[i]\\n        if (!arr[i + 1]) {\\n            arr[i] = lastMax \\n            lastMax = val\\n        } else {\\n            arr[i] = lastMax\\n            lastMax = Math.max(lastMax, val)\\n        }\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nconst replaceElements = arr => {\\n    let lastMax = -1\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        const val = arr[i]\\n        if (!arr[i + 1]) {\\n            arr[i] = lastMax \\n            lastMax = val\\n        } else {\\n            arr[i] = lastMax\\n            lastMax = Math.max(lastMax, val)\\n        }\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3146616,
                "title": "easy-to-understand-c-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFinding the maximum element towards the right and replacing it to the newly form vector.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n=arr.size();\\n        vector<int>ans(n);\\n        int max=arr[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(max < arr[i+1])\\n                max=arr[i+1];\\n            ans[i]=max;\\n        }\\n        ans[n-1]=-1;\\n        return ans;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n=arr.size();\\n        vector<int>ans(n);\\n        int max=arr[n-1];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(max < arr[i+1])\\n                max=arr[i+1];\\n            ans[i]=max;\\n        }\\n        ans[n-1]=-1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141342,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr)\\n    {\\n        int n=arr.size();\\n        vector<int>v(n);\\n        int t=-1;\\n        v[n-1]=-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            v[i]=max(v[i+1],arr[i+1]);\\n        }\\n        return v;\\n        \\n    }\\n};\\n```\\n\\n**please upvote if helpful**\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr)\\n    {\\n        int n=arr.size();\\n        vector<int>v(n);\\n        int t=-1;\\n        v[n-1]=-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            v[i]=max(v[i+1],arr[i+1]);\\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173967,
                "title": "simple-python-solution-with-comments",
                "content": "Start iterating from the end and keep track of the highest number.  Array is replaced in place.\\n\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        \\n        i = len(arr) - 1\\n        \\n        hi = -1\\n        \\n        while i >= 0 :\\n            # Keep track of the \\'would be\\' highest number\\n            temp_hi = max (arr[i], hi)\\n            # Replace the index with the last known highest number\\n            arr[i] = hi\\n            # Replace the last known highest number with the current highest number\\n            hi = temp_hi\\n            i -= 1\\n        \\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        \\n        i = len(arr) - 1\\n        \\n        hi = -1\\n        \\n        while i >= 0 :\\n            # Keep track of the \\'would be\\' highest number\\n            temp_hi = max (arr[i], hi)\\n            # Replace the index with the last known highest number\\n            arr[i] = hi\\n            # Replace the last known highest number with the current highest number\\n            hi = temp_hi\\n            i -= 1\\n        \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851033,
                "title": "ruby-change-values-in-place-one-pass-over-indices-while-moving-backward",
                "content": "##### Leetcode: 1299. Replace Elements with Greatest Element on Right Side.\\n\\nBecause minimum value of an input array is 1 and -1 is a value for modified array when there is no max elements at the right side, it is easy to solve this task in one loop and one \"storage\" variable that initiated as -1. Just loop the array indexes backward and calculate next maximum based on current value (select maximum value from two values), substituting current value with a current maximum and at the end of an iteration set current maximum equal to the next one.  Change array in place by one pass. \\n\\nRuby code (readable version):\\n```Ruby\\n# Leetcode: 1299. Replace Elements with Greatest Element on Right Side.\\n# https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\\n# Runtime: 68 ms, faster than 93.44% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# Memory Usage: 12.3 MB, less than 24.59% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef replace_elements(arr)\\n    prev = -1\\n    (0...arr.size).reverse_each do |i|\\n        tmp = arr[i]\\n        arr[i] = prev\\n        prev = tmp if tmp > prev        \\n    end\\n    arr\\nend\\n```\\n\\nRuby code (\"concise\" version):\\n```Ruby\\n# Leetcode: 1299. Replace Elements with Greatest Element on Right Side.\\n# https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\\n# Runtime: 68 ms, faster than 93.44% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# Memory Usage: 11.3 MB, less than 91.80% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef replace_elements(arr)\\n    prev = -1\\n    (0...arr.size).reverse_each do |i|\\n        prev, arr[i] = (arr[i] > prev ? arr[i] : prev)  , prev    \\n    end\\n    arr\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1299. Replace Elements with Greatest Element on Right Side.\\n# https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\\n# Runtime: 68 ms, faster than 93.44% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# Memory Usage: 12.3 MB, less than 24.59% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef replace_elements(arr)\\n    prev = -1\\n    (0...arr.size).reverse_each do |i|\\n        tmp = arr[i]\\n        arr[i] = prev\\n        prev = tmp if tmp > prev        \\n    end\\n    arr\\nend\\n```\n```Ruby\\n# Leetcode: 1299. Replace Elements with Greatest Element on Right Side.\\n# https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\\n# Runtime: 68 ms, faster than 93.44% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# Memory Usage: 11.3 MB, less than 91.80% of Ruby online submissions for Replace Elements with Greatest Element on Right Side.\\n# @param {Integer[]} arr\\n# @return {Integer[]}\\ndef replace_elements(arr)\\n    prev = -1\\n    (0...arr.size).reverse_each do |i|\\n        prev, arr[i] = (arr[i] > prev ? arr[i] : prev)  , prev    \\n    end\\n    arr\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 463649,
                "title": "easy-javascript-time-o-n-space-o-1",
                "content": "```\\n\\nconst replaceElements = arr => {\\n  let prev = -1;\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    let cur = arr[i];\\n    arr[i] = prev;\\n    prev = Math.max(prev, cur);\\n  }\\n  return arr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst replaceElements = arr => {\\n  let prev = -1;\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    let cur = arr[i];\\n    arr[i] = prev;\\n    prev = Math.max(prev, cur);\\n  }\\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463645,
                "title": "python-3-two-lines-72-ms-beats-100-with-explanation-o-n-time-o-1-space",
                "content": "_Explanation:_\\nThe program starts by iterating backwards from the end of list A. It does a pairwise comparison of the value at index i and index i+1 and writes the higher of these two values into index i. After each iteration, we will have ```max(A[i:L])``` stored into A[i]. This allows us to efficiently only do pairwise comparisons to create the final list as opposed to repeatedly calling the ```max``` function on longer and longer sublists. This gives us an O(n) algorithm instead of an O(n\\xB2) algorithm. As an example, the output of the for loop after an input of A = [17,18,5,4,6,1], is A = [18, 18, 6, 6, 6, 1]. Since we want the highest value to the right of each number, we will never include the first number in our answer. The program ends by returning the current list A, without the first number, and after having appended -1 to the end of the list.\\n```\\nclass Solution:\\n    def replaceElements(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)-2,-1,-1): A[i] = max(A[i],A[i+1])\\n        return  A[1:]+[-1]\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```max(A[i:L])```\n```max```",
                "codeTag": "Unknown"
            },
            {
                "id": 3333664,
                "title": "c-o-n-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* replaceElements(int* arr, int arrSize, int* returnSize) {\\n    *returnSize = arrSize;\\n    int* result = malloc(*returnSize * sizeof(int));\\n\\n    int max = -1;\\n    int current;\\n    \\n    for (int i = *returnSize - 1; i >= 0; i--) {\\n        current = arr[i];\\n        result[i] = max;\\n        if (current > max) max = current;\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* replaceElements(int* arr, int arrSize, int* returnSize) {\\n    *returnSize = arrSize;\\n    int* result = malloc(*returnSize * sizeof(int));\\n\\n    int max = -1;\\n    int current;\\n    \\n    for (int i = *returnSize - 1; i >= 0; i--) {\\n        current = arr[i];\\n        result[i] = max;\\n        if (current > max) max = current;\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3296398,
                "title": "simplest-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        int ans[] = new int[arr.length]; \\n        for(int i=arr.length-1 ; i>=0 ; i--){\\n            ans[i] = max;\\n            max = Math.max(max,arr[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        int ans[] = new int[arr.length]; \\n        for(int i=arr.length-1 ; i>=0 ; i--){\\n            ans[i] = max;\\n            max = Math.max(max,arr[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510679,
                "title": "replace-element-with-greatest-element-on-right-side-0-n-time",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        int max = arr[n-1];\\n        arr[n-1] = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(arr[i]>=max){\\n                int  temp  = max;\\n                max = arr[i];\\n                arr[i] = temp;\\n            }\\n            else{\\n                arr[i] = max;\\n            }\\n           //upvote if you  like the solution pls!\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        int max = arr[n-1];\\n        arr[n-1] = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(arr[i]>=max){\\n                int  temp  = max;\\n                max = arr[i];\\n                arr[i] = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2443754,
                "title": "java-2-approaches-easy-understanding",
                "content": "**Please upvote if it helps you. It motivates me to work harder.**\\n*if any query, pls comment.*\\n# Naive(Brute-force) Approach\\n```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N*N)\\n    //  Space Complexity = O(1)\\n    \\n    public int[] replaceElements(int[] arr) {\\n        \\n        //  Traversing the array till array length -1\\n        for(int i = 0 ; i < arr.length - 1; i++){\\n            int max = 0;                    \\n            \\n            //  max variable to store the max value to the right of the element\\n            //  traversing the right side of the element i\\n            for(int j = i+1; j < arr.length ; j++ ){\\n                max = Math.max(max,arr[j]);         //  updating the max value each time\\n            }\\n            arr[i] = max;   // updating the element i with the greatest element among the elements to its right\\n        }\\n        arr[arr.length - 1] = -1;       //  Updating the last element with -1 value\\n        \\n        return arr;\\n    }\\n}\\n```\\n# Single Iteration Approach\\n```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N)\\n    //  Space Complexity = O(1)\\n    \\n    public int[] replaceElements(int[] arr) {\\n        \\n        var max = -1;                   //  to store the max value\\n        \\n        //  iterating from right side which is more convenient according to the problem\\n        for (int i = arr.length-1 ; i >= 0 ; --i){   \\n            var temp = arr[i];          //  temp variable to store the array present array value\\n            arr[i] = max;               //  updating the array with max value\\n            if(temp > max)              //  comparison between array value and max value\\n                max = temp;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N*N)\\n    //  Space Complexity = O(1)\\n    \\n    public int[] replaceElements(int[] arr) {\\n        \\n        //  Traversing the array till array length -1\\n        for(int i = 0 ; i < arr.length - 1; i++){\\n            int max = 0;                    \\n            \\n            //  max variable to store the max value to the right of the element\\n            //  traversing the right side of the element i\\n            for(int j = i+1; j < arr.length ; j++ ){\\n                max = Math.max(max,arr[j]);         //  updating the max value each time\\n            }\\n            arr[i] = max;   // updating the element i with the greatest element among the elements to its right\\n        }\\n        arr[arr.length - 1] = -1;       //  Updating the last element with -1 value\\n        \\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N)\\n    //  Space Complexity = O(1)\\n    \\n    public int[] replaceElements(int[] arr) {\\n        \\n        var max = -1;                   //  to store the max value\\n        \\n        //  iterating from right side which is more convenient according to the problem\\n        for (int i = arr.length-1 ; i >= 0 ; --i){   \\n            var temp = arr[i];          //  temp variable to store the array present array value\\n            arr[i] = max;               //  updating the array with max value\\n            if(temp > max)              //  comparison between array value and max value\\n                max = temp;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409501,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int mx=-1,n=arr.size();\\n        for(int i=n-1;i>=0;i--){\\n            int a=arr[i];\\n            // mx is the maximum element from the right of arr[i]\\n\\t\\t\\tarr[i]=mx;\\n            mx=max(mx,a);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int mx=-1,n=arr.size();\\n        for(int i=n-1;i>=0;i--){\\n            int a=arr[i];\\n            // mx is the maximum element from the right of arr[i]\\n\\t\\t\\tarr[i]=mx;\\n            mx=max(mx,a);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583372,
                "title": "python-3-o-n-time-o-1-memory",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        curMax = -1\\n        for i in range(len(arr)-1, -1, -1):\\n            arr[i], curMax = curMax, max(arr[i], curMax)\\n        return arr",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        curMax = -1\\n        for i in range(len(arr)-1, -1, -1):\\n            arr[i], curMax = curMax, max(arr[i], curMax)\\n        return arr",
                "codeTag": "Java"
            },
            {
                "id": 1555668,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n           vector<int> sem;\\n     int n=arr.size();\\n        int t;\\n        int m=-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            t=arr[i];\\n            arr[i]=m;\\n            m=max(m,t);   \\n        }\\n         return arr;\\n        }\\n       };",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n           vector<int> sem;\\n     int n=arr.size();\\n        int t;\\n        int m=-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            t=arr[i];\\n            arr[i]=m;\\n            m=max(m,t);   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1363155,
                "title": "simple-js-solution-o-1-space-and-o-n-time",
                "content": "```\\n\\n```/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar replaceElements = function(arr) {\\n    const n = arr.length-1;\\n    let prevMax = arr[n];\\n    arr[n] = -1;\\n    \\n    for(let i = n-1; i>=0; --i) {\\n     const current = arr[i]; \\n     arr[i]=prevMax;\\n     if(current>prevMax) {\\n        prevMax = current;\\n     }          \\n    }\\n    \\n    return arr;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022072,
                "title": "o-n-easy-16ms-golang",
                "content": "```\\nfunc replaceElements(arr []int) []int {\\n    greatest := -1\\n    \\n    for i := len(arr) - 1; i >= 0; i-- {\\n        arr[i], greatest = greatest, max(greatest, arr[i])\\n    }\\n    \\n    return arr\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc replaceElements(arr []int) []int {\\n    greatest := -1\\n    \\n    for i := len(arr) - 1; i >= 0; i-- {\\n        arr[i], greatest = greatest, max(greatest, arr[i])\\n    }\\n    \\n    return arr\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 809822,
                "title": "swift-simple-sweet",
                "content": "```\\nfunc replaceElements(_ arr: [Int]) -> [Int] {\\n\\tlet lastIndex = arr.count - 1\\n\\tvar nums = arr\\n\\tvar curMax = nums[lastIndex]\\n\\n\\tnums[lastIndex] = -1\\n\\tfor i in stride(from: lastIndex - 1, through: 0, by: -1) {\\n\\t\\tlet temp = curMax\\n\\t\\tcurMax = max(curMax, nums[i])\\n\\t\\tnums[i] = temp\\n\\t}\\n\\n\\treturn nums\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc replaceElements(_ arr: [Int]) -> [Int] {\\n\\tlet lastIndex = arr.count - 1\\n\\tvar nums = arr\\n\\tvar curMax = nums[lastIndex]\\n\\n\\tnums[lastIndex] = -1\\n\\tfor i in stride(from: lastIndex - 1, through: 0, by: -1) {\\n\\t\\tlet temp = curMax\\n\\t\\tcurMax = max(curMax, nums[i])\\n\\t\\tnums[i] = temp\\n\\t}\\n\\n\\treturn nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 633511,
                "title": "scala-1-line-scanright",
                "content": "```\\narr.tail.scanRight(-1)(_ max _)\\n```",
                "solutionTags": [],
                "code": "```\\narr.tail.scanRight(-1)(_ max _)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615142,
                "title": "simple-o-n-python-solution-using-list-slicing",
                "content": "Simple O(n) python solution using list slicing:\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(0, len(arr)-1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(0, len(arr)-1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 514730,
                "title": "c-o-n-solution-easy-to-understand",
                "content": "```\\nvector<int> replaceElements(vector<int>& arr, int m = -1) {\\n\\tfor (int i = arr.size() - 1; i > -1; i--)\\n\\t{\\n\\t\\tint temp = max(arr[i] , m);\\n\\t\\tarr[i] = m;\\n\\t\\tm = temp;\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> replaceElements(vector<int>& arr, int m = -1) {\\n\\tfor (int i = arr.size() - 1; i > -1; i--)\\n\\t{\\n\\t\\tint temp = max(arr[i] , m);\\n\\t\\tarr[i] = m;\\n\\t\\tm = temp;\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481711,
                "title": "javascript-solution",
                "content": "```\\nlet replaceElements = function(arr) {\\n    let maxEle = -1\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        let currentEle = arr[i]\\n        arr[i] = maxEle\\n        if (currentEle > maxEle) { maxEle = currentEle }\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet replaceElements = function(arr) {\\n    let maxEle = -1\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        let currentEle = arr[i]\\n        arr[i] = maxEle\\n        if (currentEle > maxEle) { maxEle = currentEle }\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466005,
                "title": "concise-rust-solution",
                "content": "```rust\\npub fn replace_elements(mut A: Vec<i32>) -> Vec<i32> {\\n\\tlet mut max = -1;\\n\\tfor x in A.iter_mut().rev() {\\n\\t\\tlet t = *x;\\n\\t\\t*x = max;\\n\\t\\tmax = std::cmp::max(max, t);\\n\\t}\\n\\tA\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn replace_elements(mut A: Vec<i32>) -> Vec<i32> {\\n\\tlet mut max = -1;\\n\\tfor x in A.iter_mut().rev() {\\n\\t\\tlet t = *x;\\n\\t\\t*x = max;\\n\\t\\tmax = std::cmp::max(max, t);\\n\\t}\\n\\tA\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463256,
                "title": "o-n-1-liners-python",
                "content": "Sounds like a job for `accumulate(..., max)`.\\n```\\ndef replaceElements(self, arr):\\n    return [*itertools.accumulate([-1] + arr[:0:-1], max)][::-1]\\n```\\nAlternatively a somewhat tricky one:\\n```\\ndef replaceElements(self, arr):\\n    return (b := [-1]).extend(map(max, b, arr[:0:-1])) or b[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef replaceElements(self, arr):\\n    return [*itertools.accumulate([-1] + arr[:0:-1], max)][::-1]\\n```\n```\\ndef replaceElements(self, arr):\\n    return (b := [-1]).extend(map(max, b, arr[:0:-1])) or b[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4019999,
                "title": "brute-force-to-optimal-with-easy-explanation",
                "content": "# Brute force approach\\n\\n---\\n\\n\\n### Intution and approach:\\nSuppose we are standing at an index, starting from index 0.\\n\\n1. We need to find the maximum element to the right of our current position.\\n\\n2. To achieve this, we compare all the elements to the right of our current position.\\n\\n3. After finding the maximum, we replace the element at our current index with this maximum value.\\n\\n4. We then happily jump to the next index and repeat this process until we reach the second to last element (end-1) of the array.\\n\\nFinally, we set the last element to -1 to complete the replacement.\\n\\n### Complexity\\n- Time complexity: O(N)*O(N)\\n For each iteration of the (i<n-1) outer loop,j or the inner loop goes till n \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n No extra space taken\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Optimal soln\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n---\\n\\n### Intution and approach:\\nThe above solution is taking at a lot time to solve our problem.\\nlet\\'s think about a O(N) approach.\\nNow let\\'s stand at the end of the array, we observe that if we keep track of the maximum element our problem would get solved as we are already keeping the track of maximum element to the right of each element.\\n\\n1. Start from the end of the array (the last element). Assume it as the maximum element to the right.\\n\\n2. Move one step backward for each element in the array, comparing it with the maximum element you\\'ve tracked.\\n\\n3. If the current element is greater than or equal to the tracked maximum, update the tracked maximum to the current element. Otherwise, update the current element to the tracked maximum.\\n\\nRepeat this process until you reach the first element.\\n\\nFinally, move each element backward and set the last element to -1.\\n\\n### Complexity\\n- Time complexity: O(N)\\n We iterate through the array only once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n No extra space taken\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> replaceElements(vector<int>& arr) {\\n\\n        /*//brute force sol\\n        int max;\\n        int i=0,j;\\n        int n=arr.size();\\n        int temp;\\n        int ind;\\n        while(i<n-1)\\n        {\\n            max=arr.at(i+1);\\n            for(j=i+1;j<n;j++)\\n            {\\n                if(arr.at(j)>=max)//comparing all elements right to i \\n                {\\n                    ind=j;\\n                    max=arr.at(j);\\n                }\\n            }\\n            arr.at(i)=arr.at(ind); //setting the element at ith index to maximum element which we found above\\n            i++;\\n        }\\n        arr.at(n-1)=-1;\\n        return arr;*/\\n\\n\\n    //Optimal\\n    int n=arr.size();\\n    int i,j;\\n    int max=arr.at(n-1);//assuming the last element is max element,this to compare it with other element so that we can find maximum element each time\\n    for(i=n-1;i>=0;i--)// strating from end till 0\\n    {\\n        if(arr.at(i)>=max)// current element greater than or equal to tracked element\\n        {\\n            max=arr.at(i);// assigning maximum to current element\\n        }\\n        else\\n        {\\n            arr.at(i)=max;// current element NOT >=, assigning current element to maximum\\n        }\\n    }\\n    for(i=0;i<n-1;i++)// move each element backward and set the last element to -1\\n    {\\n        arr.at(i)=arr.at(i+1);\\n    }\\n    arr.at(n-1)=-1;\\n    return arr;\\n}};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> replaceElements(vector<int>& arr) {\\n\\n        /*//brute force sol\\n        int max;\\n        int i=0,j;\\n        int n=arr.size();\\n        int temp;\\n        int ind;\\n        while(i<n-1)\\n        {\\n            max=arr.at(i+1);\\n            for(j=i+1;j<n;j++)\\n            {\\n                if(arr.at(j)>=max)//comparing all elements right to i \\n                {\\n                    ind=j;\\n                    max=arr.at(j);\\n                }\\n            }\\n            arr.at(i)=arr.at(ind); //setting the element at ith index to maximum element which we found above\\n            i++;\\n        }\\n        arr.at(n-1)=-1;\\n        return arr;*/\\n\\n\\n    //Optimal\\n    int n=arr.size();\\n    int i,j;\\n    int max=arr.at(n-1);//assuming the last element is max element,this to compare it with other element so that we can find maximum element each time\\n    for(i=n-1;i>=0;i--)// strating from end till 0\\n    {\\n        if(arr.at(i)>=max)// current element greater than or equal to tracked element\\n        {\\n            max=arr.at(i);// assigning maximum to current element\\n        }\\n        else\\n        {\\n            arr.at(i)=max;// current element NOT >=, assigning current element to maximum\\n        }\\n    }\\n    for(i=0;i<n-1;i++)// move each element backward and set the last element to -1\\n    {\\n        arr.at(i)=arr.at(i+1);\\n    }\\n    arr.at(n-1)=-1;\\n    return arr;\\n}};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624820,
                "title": "easy-beats-92-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to replace each element in the given vector arr with the maximum element to its right. For the last element in arr, it will be replaced with -1 since there are no elements to its right.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code initializes a new vector ans with a size twice that of the given vector nums. It then iterates through each element in nums using the variable i as the index. For each element, it performs the following steps:\\n\\nAssign the current element of nums (nums[i]) to the corresponding index in ans (ans[i]).\\nAssign the same element to the index i + nums.size() in ans. Since nums.size() gives the size of the original vector, this step effectively places the same element at an index that is exactly one full cycle (size of nums) ahead of its original position in ans.\\nRepeat the above steps for all elements in nums until the iteration is complete.\\nAfter the iteration, ans contains all the elements of nums followed by the same elements again, effectively concatenating the original vector with itself.\\n\\nFinally, the ans vector is returned as the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through each element in nums once, resulting in a time complexity of O(n), where n is the number of elements in the input vector nums.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n), where n is the number of elements in nums. The additional space is required to store the resulting vector ans, which has a size twice that of nums.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int maxx=-1;\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            \\n            int test= arr[i];\\n            arr[i]=maxx;\\n            if(test>maxx)\\n            maxx=test;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int maxx=-1;\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            \\n            int test= arr[i];\\n            arr[i]=maxx;\\n            if(test>maxx)\\n            maxx=test;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486898,
                "title": "brute-force-optimal-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Brute Force\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                max = Math.max(max, arr[j]);\\n            }\\n            arr[i]=max;\\n            max=-1;\\n        }\\n        return arr;\\n    }\\n}\\n```\\n# Optimal Code\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        int[] ans = new int[arr.length];\\n        ans[arr.length-1]=max;\\n        for(int i=arr.length-1;i>0;i--){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                ans[i-1]=max;\\n            }else{\\n                ans[i-1]=max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                max = Math.max(max, arr[j]);\\n            }\\n            arr[i]=max;\\n            max=-1;\\n        }\\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        int[] ans = new int[arr.length];\\n        ans[arr.length-1]=max;\\n        for(int i=arr.length-1;i>0;i--){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                ans[i-1]=max;\\n            }else{\\n                ans[i-1]=max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366011,
                "title": "c-easy-approach-with-great-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We have an array of numbers (arr) and we want to replace each element in the array with the greatest element that is to the right of the element.\\n2. Our approach is to traverse the array from right to left and keep track of the maximum element we have seen so far (oldmax) and replace the current element with it.\\n3. After replacing the current element, we update the oldmax to be the new maximum element we have seen so far (which is the current element).\\n4. We return the array after we are done replacing all the elements. */\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int oldmax = -1;\\n        int length = arr.size();\\n        for(int i = length - 1 ; i >=0 ; i--)\\n        {\\n            int newmax = max(oldmax , arr[i]);\\n            arr[i] = oldmax;\\n            oldmax = newmax;\\n        }\\n        return arr;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int oldmax = -1;\\n        int length = arr.size();\\n        for(int i = length - 1 ; i >=0 ; i--)\\n        {\\n            int newmax = max(oldmax , arr[i]);\\n            arr[i] = oldmax;\\n            oldmax = newmax;\\n        }\\n        return arr;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302682,
                "title": "a-simple-python-solution-in-place",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        max=arr[len(arr)-1]\\n        for i in range(len(arr)-1,-1,-1):\\n            if i==len(arr)-1:\\n                arr[i]=-1\\n            else:\\n                temp=arr[i]\\n                arr[i]=max\\n                if max<temp:\\n                    max=temp\\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        max=arr[len(arr)-1]\\n        for i in range(len(arr)-1,-1,-1):\\n            if i==len(arr)-1:\\n                arr[i]=-1\\n            else:\\n                temp=arr[i]\\n                arr[i]=max\\n                if max<temp:\\n                    max=temp\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228997,
                "title": "java-solution-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int maxx = arr[arr.length-1];\\n        arr[arr.length-1]=-1;\\n        for(int i=arr.length-2;i>=0;i--){\\n            int temp = Math.max(maxx,arr[i]);\\n            arr[i]=maxx;\\n            maxx=temp;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int maxx = arr[arr.length-1];\\n        arr[arr.length-1]=-1;\\n        for(int i=arr.length-2;i>=0;i--){\\n            int temp = Math.max(maxx,arr[i]);\\n            arr[i]=maxx;\\n            maxx=temp;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183849,
                "title": "python-beats-99-94-without-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst of all reverse the array. Initialize ```max_so_far``` to -1\\nThen create an array to store the max element so far we have found.\\nTraverse the reversed array and append the ``` max_so_far``` toe res array. Fianlly reverse the array and return it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        arr = arr[::-1]\\n        res = []\\n        max_so_far = -1\\n        for i in arr:\\n            res.append(max_so_far)\\n            if i>max_so_far:\\n                max_so_far = i\\n\\n\\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```max_so_far```\n``` max_so_far```\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        arr = arr[::-1]\\n        res = []\\n        max_so_far = -1\\n        for i in arr:\\n            res.append(max_so_far)\\n            if i>max_so_far:\\n                max_so_far = i\\n\\n\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114827,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>res(arr.size());\\n        int great=arr[arr.size()-1];\\n        res[res.size()-1]=-1;\\n        for(int i=res.size()-2;i>=0;i--){\\n            res[i]=great;\\n            great=max(great,arr[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>res(arr.size());\\n        int great=arr[arr.size()-1];\\n        res[res.size()-1]=-1;\\n        for(int i=res.size()-2;i>=0;i--){\\n            res[i]=great;\\n            great=max(great,arr[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797050,
                "title": "python3-o-n-simple-to-understand",
                "content": "\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        rev, maximum = arr[::-1], -1\\n\\n        for i in range(len(rev)):\\n            rev[i], maximum = maximum, max(maximum, rev[i])\\n\\n        return rev[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        rev, maximum = arr[::-1], -1\\n\\n        for i in range(len(rev)):\\n            rev[i], maximum = maximum, max(maximum, rev[i])\\n\\n        return rev[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770767,
                "title": "c-o-n-beginner-friendly",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> replaceElements(vector<int> &arr)\\n        {\\n            int m = arr[arr.size() - 1];\\n            arr[arr.size() - 1] = -1;\\n            if (arr.size() == 1) return arr;\\n            \\n            for (int i = arr.size() - 2; i >= 0; i--)\\n            {\\n                int temp = arr[i];\\n                arr[i] = m;\\n                m = max(temp, m);\\n            }\\n            return arr;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> replaceElements(vector<int> &arr)\\n        {\\n            int m = arr[arr.size() - 1];\\n            arr[arr.size() - 1] = -1;\\n            if (arr.size() == 1) return arr;\\n            \\n            for (int i = arr.size() - 2; i >= 0; i--)\\n            {\\n                int temp = arr[i];\\n                arr[i] = m;\\n                m = max(temp, m);\\n            }\\n            return arr;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722192,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> v(n,0);\\n        v[n-1] = -1;\\n        int maxi = arr[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            v[i] = maxi;\\n            maxi = max(maxi,arr[i]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> v(n,0);\\n        v[n-1] = -1;\\n        int maxi = arr[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            v[i] = maxi;\\n            maxi = max(maxi,arr[i]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602091,
                "title": "iterate-and-swap",
                "content": "![image](https://assets.leetcode.com/users/images/c36cb5a5-f105-4f47-a9d9-3ad2a9452bb9_1663693064.2390969.png)\\n\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxi = -1\\n        for i in range(len(arr) -1, -1, -1):\\n            arr[i], maxi = maxi, max(arr[i],maxi)\\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxi = -1\\n        for i in range(len(arr) -1, -1, -1):\\n            arr[i], maxi = maxi, max(arr[i],maxi)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551929,
                "title": "simple-o-n-time-and-o-1-space-complexity-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        \\n        int max = -1;        \\n        for(int i=arr.length-1;i>=0;i--){\\n            int element = arr[i];\\n            arr[i]= max;\\n            if(max<element){\\n                max = element ;\\n            }\\n        }\\n        return arr;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        \\n        int max = -1;        \\n        for(int i=arr.length-1;i>=0;i--){\\n            int element = arr[i];\\n            arr[i]= max;\\n            if(max<element){\\n                max = element ;\\n            }\\n        }\\n        return arr;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830191,
                "title": "c-2-approach-left-start-o-n-2-right-start-o-n-7-lines",
                "content": "\\n# Approach 1. start from left\\nFrom the observation from left to right, \\nwe have the following solution.\\n```C++\\nvector<int> replaceElements(vector<int>& arr) {\\n\\tint n = arr.size();\\n\\tint max_val, max_idx = 0;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(i>=max_idx) {\\n\\t\\t\\tmax_val = -1;\\n\\t\\t\\t//figure out max element in the range \\n\\t\\t\\t//from arr[i+1] to arr[n-1]\\n\\t\\t\\tfor(int j=i+1; j<n;j++) {\\n\\t\\t\\t\\tif(arr[j] > max_val) {\\n\\t\\t\\t\\t\\tmax_idx = j;\\n\\t\\t\\t\\t\\tmax_val = arr[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max_val;            \\n\\t}\\n\\treturn arr;\\n}\\n```\\nThe worst case is descending order array. \\nIt is something like [n-1,n-2,...,9,8,7,6,5,4,3,2,1].\\n\\n\\nIf we can change the return type of API from `vector<int>` into `vector<int>&`, \\nthen the complexity analysis are\\n**Time complexity O(n^2)**\\n**Space complexity O(1)**\\n\\n\\nBecause the max element is always happen in the right side of every \\ncurrent element when you travel from left to right. So we can try to change \\nthe observation from right to left. \\n# Approach 2. start from right \\nFrom the observation from right to left, \\nwe have the following solution.\\n\\n\\n```C++\\nvector<int> replaceElements(vector<int>& arr) {\\n\\tint max_val = -1;\\n\\tfor(int i = arr.size()-1; i>=0;i--) \\n\\t\\tif(arr[i]>max_val) \\n\\t\\t\\tswap(arr[i],max_val);\\n\\t\\telse \\n\\t\\t\\tarr[i] = max_val;\\n\\treturn arr;\\n}\\n```\\n\\n\\nIf we can change the return type of API from `vector<int>` into `vector<int>&`, \\nthen the complexity analysis are\\n\\n**Time complexity O(n)**\\n**Space complexity O(1)**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nvector<int> replaceElements(vector<int>& arr) {\\n\\tint n = arr.size();\\n\\tint max_val, max_idx = 0;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(i>=max_idx) {\\n\\t\\t\\tmax_val = -1;\\n\\t\\t\\t//figure out max element in the range \\n\\t\\t\\t//from arr[i+1] to arr[n-1]\\n\\t\\t\\tfor(int j=i+1; j<n;j++) {\\n\\t\\t\\t\\tif(arr[j] > max_val) {\\n\\t\\t\\t\\t\\tmax_idx = j;\\n\\t\\t\\t\\t\\tmax_val = arr[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarr[i] = max_val;            \\n\\t}\\n\\treturn arr;\\n}\\n```\n```C++\\nvector<int> replaceElements(vector<int>& arr) {\\n\\tint max_val = -1;\\n\\tfor(int i = arr.size()-1; i>=0;i--) \\n\\t\\tif(arr[i]>max_val) \\n\\t\\t\\tswap(arr[i],max_val);\\n\\t\\telse \\n\\t\\t\\tarr[i] = max_val;\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1793644,
                "title": "kotlin-o-n-straightforward-solution",
                "content": "```kotlin\\nclass Solution {\\n    fun replaceElements(arr: IntArray): IntArray {\\n        var max = -1\\n        \\n        for (i in arr.size - 1 downTo 0) {\\n            val current = arr[i]\\n            arr[i] = max\\n            max = maxOf(current, max)\\n        }\\n        \\n        return arr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun replaceElements(arr: IntArray): IntArray {\\n        var max = -1\\n        \\n        for (i in arr.size - 1 downTo 0) {\\n            val current = arr[i]\\n            arr[i] = max\\n            max = maxOf(current, max)\\n        }\\n        \\n        return arr\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596649,
                "title": "java-solution-w-explanation-faster-than-99-7",
                "content": "```\\nif(arr.length == 1){arr[0] = -1;return arr;}  //edge case: an only element\\nint max = -1; \\nint curNum = 0; \\n\\nfor(int i = arr.length-1;i >= 0;i--){  \\n\\t//remember the current number and for the last element put -1 in the slot\\n            curNum= arr[i];   \\n\\t//put the greatest element to the right in current slot\\n            arr[i] = max;   \\n\\t//compare current number and the greatest element to the right\\n            max = Math.max(max,curNum);   \\n        }\\nreturn arr;\\n```",
                "solutionTags": [],
                "code": "```\\nif(arr.length == 1){arr[0] = -1;return arr;}  //edge case: an only element\\nint max = -1; \\nint curNum = 0; \\n\\nfor(int i = arr.length-1;i >= 0;i--){  \\n\\t//remember the current number and for the last element put -1 in the slot\\n            curNum= arr[i];   \\n\\t//put the greatest element to the right in current slot\\n            arr[i] = max;   \\n\\t//compare current number and the greatest element to the right\\n            max = Math.max(max,curNum);   \\n        }\\nreturn arr;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1583740,
                "title": "6-lines-easy-java-solution-1ms-99-76-faster",
                "content": "**Upvote if you LIKE** \\uD83D\\uDE42\\nclass Solution {\\n\\n    public int[] replaceElements(int[] arr) {\\n        \\n        int max = -1, temp;\\n        for (int i = arr.length - 1; i >= 0; --i) {\\n            temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] replaceElements(int[] arr) {\\n        \\n        int max = -1, temp;\\n        for (int i = arr.length - 1; i >= 0; --i) {\\n            temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1371359,
                "title": "super-simple-java-100",
                "content": "\\tpublic int[] replaceElements(int[] arr) {\\n\\t\\t\\t\\n\\t\\t\\t// keep track of the max value on the right side\\n\\t\\t\\tint max = arr[arr.length - 1];\\n\\t\\t\\t// iterate backwards, replacing the element at i with the max\\n\\t\\t\\t// update max if the value at index i is greater than max \\n\\t\\t\\tfor (int i = arr.length - 2; i >= 0; i -= 1) {\\n\\t\\t\\t\\tint temp = arr[i];\\n\\t\\t\\t\\tarr[i] = max;\\n\\t\\t\\t\\tmax = Math.max(max, temp);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tarr[arr.length - 1] = -1;\\n\\t\\t\\treturn arr;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int[] replaceElements(int[] arr) {\\n\\t\\t\\t\\n\\t\\t\\t// keep track of the max value on the right side\\n\\t\\t\\tint max = arr[arr.length - 1];\\n\\t\\t\\t// iterate backwards, replacing the element at i with the max\\n\\t\\t\\t// update max if the value at index i is greater than max \\n\\t\\t\\tfor (int i = arr.length - 2; i >= 0; i -= 1) {\\n\\t\\t\\t\\tint temp = arr[i];\\n\\t\\t\\t\\tarr[i] = max;\\n\\t\\t\\t\\tmax = Math.max(max, temp);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tarr[arr.length - 1] = -1;\\n\\t\\t\\treturn arr;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1359199,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        int maxv = arr[n-1];\\n\\n        if(n == 0 || n==1)\\n            return {-1};\\n\\n        for(int i=n-2; i>=0; i--){\\n\\n            int temp = arr[i];\\n\\n            arr[i] = maxv;\\n            \\n            if(maxv < temp)\\n                maxv = temp;\\n        }\\n\\n    arr[n-1] = -1;\\n    return arr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        int maxv = arr[n-1];\\n\\n        if(n == 0 || n==1)\\n            return {-1};\\n\\n        for(int i=n-2; i>=0; i--){\\n\\n            int temp = arr[i];\\n\\n            arr[i] = maxv;\\n            \\n            if(maxv < temp)\\n                maxv = temp;\\n        }\\n\\n    arr[n-1] = -1;\\n    return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282572,
                "title": "java-o-n-time-complexity-o-1-space-complexity-beats-100",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        ans[arr.length - 1] = -1;\\n        int rightMax = arr[arr.length - 1];\\n        \\n        for(int i = arr.length - 2; i >= 0; i--) {\\n            ans[i] = rightMax;\\n            if(arr[i] > rightMax) {\\n                rightMax = arr[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        ans[arr.length - 1] = -1;\\n        int rightMax = arr[arr.length - 1];\\n        \\n        for(int i = arr.length - 2; i >= 0; i--) {\\n            ans[i] = rightMax;\\n            if(arr[i] > rightMax) {\\n                rightMax = arr[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241982,
                "title": "java-easy-100-solution-with-meaningful-variables-and-explanation",
                "content": "```\\n// Read from the back finding the maximum value\\n// We need the previous max because we can\\'t include the current value but we will for the next index\\npublic int[] replaceElements(int[] arr) {\\n\\tint max = -1;\\n\\tint previousMax = 0;\\n\\tfor (int i = arr.length-1; i >= 0; i--) {\\n\\t\\tpreviousMax = max;\\n\\t\\tmax = Math.max(max, arr[i]);\\n\\t\\tarr[i] = previousMax;\\n\\t}\\n\\n\\treturn arr;\\n}",
                "solutionTags": [],
                "code": "```\\n// Read from the back finding the maximum value\\n// We need the previous max because we can\\'t include the current value but we will for the next index\\npublic int[] replaceElements(int[] arr) {\\n\\tint max = -1;\\n\\tint previousMax = 0;\\n\\tfor (int i = arr.length-1; i >= 0; i--) {\\n\\t\\tpreviousMax = max;\\n\\t\\tmax = Math.max(max, arr[i]);\\n\\t\\tarr[i] = previousMax;\\n\\t}\\n\\n\\treturn arr;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1188635,
                "title": "java-easy-solution-beats-99",
                "content": "```\\nclass Solution { \\n    public int[] replaceElements(int[] arr) {\\n        int[] res = new int[arr.length];\\n        int max = Integer.MIN_VALUE;\\n        for (int i = arr.length - 1; i > 0; i--){\\n            max = Math.max(max, arr[i]);\\n            res[i - 1] = max;\\n        }\\n        res[arr.length - 1] = -1;\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution { \\n    public int[] replaceElements(int[] arr) {\\n        int[] res = new int[arr.length];\\n        int max = Integer.MIN_VALUE;\\n        for (int i = arr.length - 1; i > 0; i--){\\n            max = Math.max(max, arr[i]);\\n            res[i - 1] = max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1004144,
                "title": "javascript-o-n-beats-98",
                "content": "```\\n\\nconst replaceElements = arr => {\\n    \\n  let max = arr[arr.length-1];\\n  arr[arr.length-1] = -1;\\n  \\n  for(let i = arr.length-2; i >= 0; i--){\\n    let temp = arr[i]\\n    arr[i] = max;\\n    max = Math.max(max, temp)\\n  }\\n  return arr;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst replaceElements = arr => {\\n    \\n  let max = arr[arr.length-1];\\n  arr[arr.length-1] = -1;\\n  \\n  for(let i = arr.length-2; i >= 0; i--){\\n    let temp = arr[i]\\n    arr[i] = max;\\n    max = Math.max(max, temp)\\n  }\\n  return arr;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955289,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr):\\n        m=-1\\n        for i in range(len(arr)-1,-1,-1):\\n                arr[i],m =m, max(arr[i],m)\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr):\\n        m=-1\\n        for i in range(len(arr)-1,-1,-1):\\n                arr[i],m =m, max(arr[i],m)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885141,
                "title": "c-solution-using-stack-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n     \\n        int n=arr.size();\\n        stack<int> s;\\n        vector<int> ans;\\n        \\n        \\n        s.push(arr[n-1]);\\n        ans.push_back(-1);\\n        for(int i=n-2; i>=0; i--){\\n            ans.push_back(s.top());\\n            if(s.top()<arr[i]){\\n                s.push(arr[i]);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n     \\n        int n=arr.size();\\n        stack<int> s;\\n        vector<int> ans;\\n        \\n        \\n        s.push(arr[n-1]);\\n        ans.push_back(-1);\\n        for(int i=n-2; i>=0; i--){\\n            ans.push_back(s.top());\\n            if(s.top()<arr[i]){\\n                s.push(arr[i]);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835139,
                "title": "typescript-o-n-easy-w-comments",
                "content": "```\\nfunction replaceElements(arr: number[]): number[] {\\n    // current max number we\\'ve seen\\n    let max: number = -1;\\n    // go through the array from the right,\\n    // put in the number representing the max number at that point in arr\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        // store temp\\n        let temp: number = arr[i];\\n        // change current value to current max\\n        arr[i] = max;\\n        // set new max\\n        max = Math.max(max, temp);\\n    }\\n\\n    return arr;\\n}\\n```\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction replaceElements(arr: number[]): number[] {\\n    // current max number we\\'ve seen\\n    let max: number = -1;\\n    // go through the array from the right,\\n    // put in the number representing the max number at that point in arr\\n    for (let i = arr.length - 1; i >= 0; i--) {\\n        // store temp\\n        let temp: number = arr[i];\\n        // change current value to current max\\n        arr[i] = max;\\n        // set new max\\n        max = Math.max(max, temp);\\n    }\\n\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 724708,
                "title": "javascript-es6-solution-2-lines",
                "content": "```\\nvar replaceElements = function (arr) {\\n  var len = arr.length;\\n  return arr.map((x, i) =>\\n    i == len - 1 ? -1 : Math.max(...arr.slice(i + 1, len))\\n  );\\n};\\n```\\nThis solution below is faster:\\n\\n```\\nvar replaceElements = function (arr) {\\n  var res = [];\\n  var max = arr[arr.length - 1];\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    if (i == arr.length - 1) {\\n      res[i] = -1;\\n    } else {\\n      res[i] = max;\\n      max = Math.max(max, arr[i]);\\n    }\\n  }\\n  return res;\\n};\\n```\\n```\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar replaceElements = function (arr) {\\n  var len = arr.length;\\n  return arr.map((x, i) =>\\n    i == len - 1 ? -1 : Math.max(...arr.slice(i + 1, len))\\n  );\\n};\\n```\n```\\nvar replaceElements = function (arr) {\\n  var res = [];\\n  var max = arr[arr.length - 1];\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    if (i == arr.length - 1) {\\n      res[i] = -1;\\n    } else {\\n      res[i] = max;\\n      max = Math.max(max, arr[i]);\\n    }\\n  }\\n  return res;\\n};\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656403,
                "title": "java-easy-solution-better-than-100-both-memory-and-runtime",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        for(int i = arr.length - 1; i >= 0; i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        for(int i = arr.length - 1; i >= 0; i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, temp);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627109,
                "title": "golang-simple-solution",
                "content": "```\\nfunc replaceElements(arr []int) []int {\\n\\tmax := -1\\n\\tfor i := len(arr) - 1; i >= 0; i-- {\\n\\t\\tt := arr[i]\\n\\t\\tarr[i] = max\\n\\t\\tif t > max {\\n\\t\\t\\tmax = t\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc replaceElements(arr []int) []int {\\n\\tmax := -1\\n\\tfor i := len(arr) - 1; i >= 0; i-- {\\n\\t\\tt := arr[i]\\n\\t\\tarr[i] = max\\n\\t\\tif t > max {\\n\\t\\t\\tmax = t\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 617444,
                "title": "c-3-lines-solution-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        for(int i = (int)arr.size()-1, mx = -1; i >= 0; --i)\\n            mx = max(mx, exchange(arr[i], mx));\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        for(int i = (int)arr.size()-1, mx = -1; i >= 0; --i)\\n            mx = max(mx, exchange(arr[i], mx));\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557377,
                "title": "go-golang-clean-solutions",
                "content": ">Runtime: 148 ms, faster than 24.11% of Go online submissions for Replace Elements with Greatest Element on Right Side.\\nMemory Usage: 5.9 MB, less than 100.00% of Go online submissions for Replace Elements with Greatest Element on Right Side.\\n\\n```go\\nfunc replaceElements(arr []int) []int {\\n    res := make([]int, len(arr))\\n    for i := 0; i < len(arr); i++ {\\n        if i == len(arr) - 1 {\\n            res[i] = -1\\n        } else {\\n            res[i] = helper(arr[i + 1:])\\n        }\\n    }\\n    return res\\n}\\n\\nfunc helper(arr []int) int {\\n    max := 0\\n    for _, v := range arr {\\n        if v > max { max = v }\\n    }\\n    return max\\n}\\n```\\n\\n>Runtime: 12 ms, faster than 95.86% of Go online submissions for Replace Elements with Greatest Element on Right Side.\\nMemory Usage: 6.1 MB, less than 100.00% of Go online submissions for Replace Elements with Greatest Element on Right Side.\\n\\n```go\\nfunc replaceElements(arr []int) []int {\\n    max := -1\\n    for i := len(arr) - 1; i >= 0; i-- {\\n        if arr[i] > max {\\n            max, arr[i] = arr[i], max\\n        } else {\\n            arr[i] = max\\n        }\\n    }\\n    return arr\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc replaceElements(arr []int) []int {\\n    res := make([]int, len(arr))\\n    for i := 0; i < len(arr); i++ {\\n        if i == len(arr) - 1 {\\n            res[i] = -1\\n        } else {\\n            res[i] = helper(arr[i + 1:])\\n        }\\n    }\\n    return res\\n}\\n\\nfunc helper(arr []int) int {\\n    max := 0\\n    for _, v := range arr {\\n        if v > max { max = v }\\n    }\\n    return max\\n}\\n```\n```go\\nfunc replaceElements(arr []int) []int {\\n    max := -1\\n    for i := len(arr) - 1; i >= 0; i-- {\\n        if arr[i] > max {\\n            max, arr[i] = arr[i], max\\n        } else {\\n            arr[i] = max\\n        }\\n    }\\n    return arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 556615,
                "title": "php-solution",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer[]\\n     */\\n    function replaceElements($arr) {\\n        $len = count($arr) - 1;\\n        $max = $arr[$len];\\n        $arr[$len] = -1;\\n        \\n        for($i = $len - 1; $i >= 0; $i--) {\\n            $old_max = $max;\\n            $max = $arr[$i] > $max ? $arr[$i] : $max;   \\n            $arr[$i] = $old_max;\\n        } \\n        \\n        return $arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer[]\\n     */\\n    function replaceElements($arr) {\\n        $len = count($arr) - 1;\\n        $max = $arr[$len];\\n        $arr[$len] = -1;\\n        \\n        for($i = $len - 1; $i >= 0; $i--) {\\n            $old_max = $max;\\n            $max = $arr[$i] > $max ? $arr[$i] : $max;   \\n            $arr[$i] = $old_max;\\n        } \\n        \\n        return $arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554235,
                "title": "java-1ms-faster-than-100-submission-with-explaination",
                "content": "The ideal is to traverse array from the end, and keep hold of max element before current element. At the same time time keep updating the input array.\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = arr[arr.length -1];\\n        for(int i = arr.length - 2; i >=0; i--){\\n            int temp = max;\\n            if(arr[i] > max) max = arr[i];\\n            arr[i] = temp;\\n        }\\n        arr[arr.length - 1] = -1;\\n        return arr;\\n    }\\n}\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = arr[arr.length -1];\\n        for(int i = arr.length - 2; i >=0; i--){\\n            int temp = max;\\n            if(arr[i] > max) max = arr[i];\\n            arr[i] = temp;\\n        }\\n        arr[arr.length - 1] = -1;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544817,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxn = arr[-1]\\n        for i in range(len(arr)-1,-1, -1):\\n            if maxn < arr[i]:\\n                temp = arr[i]\\n                arr[i] = maxn\\n                maxn = temp\\n            else:\\n                arr[i] = maxn\\n        arr[-1] = -1\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxn = arr[-1]\\n        for i in range(len(arr)-1,-1, -1):\\n            if maxn < arr[i]:\\n                temp = arr[i]\\n                arr[i] = maxn\\n                maxn = temp\\n            else:\\n                arr[i] = maxn\\n        arr[-1] = -1\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521039,
                "title": "straightforward-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if (arr == null) {\\n            return arr;\\n        }\\n        int max = -1;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            int val = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, val);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if (arr == null) {\\n            return arr;\\n        }\\n        int max = -1;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            int val = arr[i];\\n            arr[i] = max;\\n            max = Math.max(max, val);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466057,
                "title": "python-3-simple-fast",
                "content": "#### Step 1:\\n##### scan array from right to left\\n\\n#### Step 2:\\n##### keep track of the max number\\n\\n#### Step 3:\\n##### create a new array with current max number\\n\\n#### Step 4:\\n##### Rinse & Repeat\\n\\n\\n```python\\n# Most Readable\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n\\tmax_i = -1\\n\\tres = [-1]\\n\\tfor i in arr[::-1]:\\n\\t\\tif i > max_i:\\n\\t\\t\\tmax_i = i\\n\\t\\tres = [max_i] + res\\n\\treturn res[1:]\\n\\t\\n```\\n\\n```python\\n# Super Fast\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        max_i = -1\\n        res = [-1]\\n        for i in arr[::-1]:\\n            if i > max_i:\\n                max_i = i\\n            res += [max_i]\\n        res = res[:-1]\\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```python\\n# Most Readable\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n\\tmax_i = -1\\n\\tres = [-1]\\n\\tfor i in arr[::-1]:\\n\\t\\tif i > max_i:\\n\\t\\t\\tmax_i = i\\n\\t\\tres = [max_i] + res\\n\\treturn res[1:]\\n\\t\\n```\n```python\\n# Super Fast\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        max_i = -1\\n        res = [-1]\\n        for i in arr[::-1]:\\n            if i > max_i:\\n                max_i = i\\n            res += [max_i]\\n        res = res[:-1]\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463572,
                "title": "python3-backward-scan",
                "content": "Algorithm:\\nInitialize `m` at -1;\\nScan array backward and 1) assign `m` to `arr[i]` and simultaneously update `m` to be `max(m, arr[i])`. \\n\\nImplementation (76ms, 100%): \\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        for i in reversed(range(len(arr))):\\n            arr[i], m = m, max(m, arr[i])\\n        return arr\\n```\\nAnalysis:\\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        for i in reversed(range(len(arr))):\\n            arr[i], m = m, max(m, arr[i])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463353,
                "title": "simple-python-solution-beat-100",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        \\n        maxNum = -1\\n        for i in range(len(arr) - 1, -1, -1):\\n            last = maxNum\\n            maxNum = max(maxNum, arr[i])\\n            arr[i] = last\\n        return arr\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        \\n        maxNum = -1\\n        for i in range(len(arr) - 1, -1, -1):\\n            last = maxNum\\n            maxNum = max(maxNum, arr[i])\\n            arr[i] = last\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463182,
                "title": "easy-solution-in-java",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxele=arr[n-1];\\n        arr[n-1]=-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int temp=arr[i];\\n            arr[i]=maxele;\\n            maxele=max(maxele,temp);\\n            \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxele=arr[n-1];\\n        arr[n-1]=-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int temp=arr[i];\\n            arr[i]=maxele;\\n            maxele=max(maxele,temp);\\n            \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685923,
                "title": "c-java-both-simple-and-concise-solutions-100-easy-to-understand-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to traverse the array from right to left, keeping track of the maximum element encountered so far. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code initializes the maximum value (mx) as the last element of the input array, replaces it with -1.\\n- And then iterates from the second-to-last element to the first element.\\n- At each step, it updates the current maximum (cur) by taking the maximum of the current element and the previous maximum.\\n- The current element is then replaced with the previous maximum, and the process continues until all elements are replaced.\\n# Complexity\\n- Time complexity: $$ O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code : \\n### C++ : \\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = arr.size();\\n        int cur;\\n        int mx = arr[n-1];\\n        arr[n-1] = -1;\\n        for(int i=n-2; i>=0; i--){\\n            cur = max(mx, arr[i]);\\n            arr[i] = mx;\\n            mx = cur;\\n        }\\n        return arr;\\n    }\\n};\\n```\\nNote : The use of `ios_base::sync_with_stdio(false);` `cin.tie(NULL);` reduces the time complexity bit more.\\nFor more info refer this [Link](https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull)\\n### Java :\\n```\\npublic int[] replaceElements(int[] arr) {\\n    for (int i = arr.length - 1, max = -1; i >= 0; --i) {\\n        int tmp = arr[i];\\n        arr[i] = max;\\n        max = Math.max(max, tmp);\\n    }\\n    return arr;\\n}\\n```\\n\\n## More Concise Code : \\n### C++ : \\n```\\nvector<int> replaceElements(vector<int>& A, int mx = -1) {\\n    for (int i = A.size() - 1; i >= 0; --i)\\n        mx = max(mx, exchange(A[i], mx));\\n    return A;\\n}\\n```\\n### Java :\\n```\\npublic int[] replaceElements(int[] A) {\\n    for (int i = A.length - 1, mx = -1; i >= 0; --i)\\n        mx = Math.max(A[i], A[i] = mx);\\n    return A;\\n}\\n```\\n\\n### Happy coding.\\n**Feel free to ask any question in the comment section.**\\n**If you like this solution, Please do upvote this post.**\\n\\n**Tom needs upvote.**\\n![tom up 2.gif](https://assets.leetcode.com/users/images/b072e326-7346-4b1e-80bf-9da9877391c2_1687797330.550179.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = arr.size();\\n        int cur;\\n        int mx = arr[n-1];\\n        arr[n-1] = -1;\\n        for(int i=n-2; i>=0; i--){\\n            cur = max(mx, arr[i]);\\n            arr[i] = mx;\\n            mx = cur;\\n        }\\n        return arr;\\n    }\\n};\\n```\n```\\npublic int[] replaceElements(int[] arr) {\\n    for (int i = arr.length - 1, max = -1; i >= 0; --i) {\\n        int tmp = arr[i];\\n        arr[i] = max;\\n        max = Math.max(max, tmp);\\n    }\\n    return arr;\\n}\\n```\n```\\nvector<int> replaceElements(vector<int>& A, int mx = -1) {\\n    for (int i = A.size() - 1; i >= 0; --i)\\n        mx = max(mx, exchange(A[i], mx));\\n    return A;\\n}\\n```\n```\\npublic int[] replaceElements(int[] A) {\\n    for (int i = A.length - 1, mx = -1; i >= 0; --i)\\n        mx = Math.max(A[i], A[i] = mx);\\n    return A;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679535,
                "title": "java-easy-to-learn-o-n-and-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=arr[arr.length-1];\\n        arr[arr.length-1]=-1;\\n        for(int i=arr.length-2;i>=0;i--){\\n            int temp=arr[i];\\n            arr[i]=max;\\n            max=Math.max(max,temp);\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=arr[arr.length-1];\\n        arr[arr.length-1]=-1;\\n        for(int i=arr.length-2;i>=0;i--){\\n            int temp=arr[i];\\n            arr[i]=max;\\n            max=Math.max(max,temp);\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207474,
                "title": "o-n-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* replaceElements(int* arr, int arrSize, int* returnSize){\\n\\n    *returnSize = arrSize;\\n    int max=-1,temp;\\n    \\n\\n    for(int i=arrSize - 1;i >= 0;i--){\\n        if(arr[i]>max)\\n            temp = arr[i];\\n        arr[i]=max;\\n        max = temp;\\n    }\\n\\n\\n    return arr;\\n    \\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* replaceElements(int* arr, int arrSize, int* returnSize){\\n\\n    *returnSize = arrSize;\\n    int max=-1,temp;\\n    \\n\\n    for(int i=arrSize - 1;i >= 0;i--){\\n        if(arr[i]>max)\\n            temp = arr[i];\\n        arr[i]=max;\\n        max = temp;\\n    }\\n\\n\\n    return arr;\\n    \\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3155975,
                "title": "easy-to-understand-o-n-2-solution-java-code",
                "content": "\\n\\n# Bruteforce approach (Java Code)\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) {\\n            arr[0] =-1;\\n        }\\n        for(int i =0;i<arr.length;i++) {\\n            int max = -1;\\n            for(int j =i+1;j<arr.length;j++) {\\n                max = Math.max(max,arr[j]);\\n            } \\n            arr[i] = max;\\n        }\\n        return arr;\\n    }\\n}\\n```\\n# Optimised approach (Java Code)\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n      int max = -1;\\n      for(int i = arr.length-1;i>=0;i--) {\\n          int temp = arr[i];\\n          arr[i] = max;\\n          max= Math.max(max,temp);\\n      }\\n      return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) {\\n            arr[0] =-1;\\n        }\\n        for(int i =0;i<arr.length;i++) {\\n            int max = -1;\\n            for(int j =i+1;j<arr.length;j++) {\\n                max = Math.max(max,arr[j]);\\n            } \\n            arr[i] = max;\\n        }\\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n      int max = -1;\\n      for(int i = arr.length-1;i>=0;i--) {\\n          int temp = arr[i];\\n          arr[i] = max;\\n          max= Math.max(max,temp);\\n      }\\n      return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793243,
                "title": "easy-golang-solution-simple-go",
                "content": "Please don\\'t forget to upvote the post. \\n\\n```\\nfunc replaceElements(arr []int) []int {\\n    m := -1\\n    for i:=len(arr)-1; i>=0;i-- {\\n        temp := arr[i]\\n        arr[i] = m\\n        if m < temp {\\n            m = temp\\n        }\\n    }\\n    return arr\\n}\\n```\\n\\n\\u270C\\uFE0F",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nfunc replaceElements(arr []int) []int {\\n    m := -1\\n    for i:=len(arr)-1; i>=0;i-- {\\n        temp := arr[i]\\n        arr[i] = m\\n        if m < temp {\\n            m = temp\\n        }\\n    }\\n    return arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2718888,
                "title": "simple-o-n-in-place",
                "content": "\\n\\n# Code\\n```\\nfunc replaceElements(arr []int) []int {\\n   \\n    max := -1\\n    for i := len(arr)-1; i >= 0; i-- {\\n        if arr[i] > max {\\n            arr[i], max = max, arr[i]\\n        } else {\\n            arr[i] = max\\n        }\\n    }\\n    \\n    return arr\\n}\\n\\n// [1, 2, 0, -5, 2] -> [2, 2, 2, 2, -1]\\n// [0] -> [-1]\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc replaceElements(arr []int) []int {\\n   \\n    max := -1\\n    for i := len(arr)-1; i >= 0; i-- {\\n        if arr[i] > max {\\n            arr[i], max = max, arr[i]\\n        } else {\\n            arr[i] = max\\n        }\\n    }\\n    \\n    return arr\\n}\\n\\n// [1, 2, 0, -5, 2] -> [2, 2, 2, 2, -1]\\n// [0] -> [-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643490,
                "title": "20ms-c-beats-81-6-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to take the max on the right so lets take an example \\n\\nInput=[3,2,4,1,2]\\n\\nso the max to the right of the element at index 0 that is 3 is clearly 4\\n\\nand now if we check for the element at index 1 that is 2 then the element is still 4\\nbut we reached this by iterating the entier array so we can reduce this extra work done\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake a temp array \\n\\nfill it from back with the max \\n\\nnow just fill the ans array with -1 at last index and then taking the value at same index in the temp array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        if(n==1){\\n            arr[0]=-1;\\n            return arr;\\n        }\\n        vector<int> ab(n,-1);\\n        int mx=arr[n-1];\\n        \\n        for(int i=n-1;i>0;i--){\\n            mx=max(mx,arr[i]);\\n            ab[i]=mx;\\n        }\\n        vector<int> ans(n,-1);\\n        ans[n-1]=-1;\\n        for(int i=n-2;i>=0;i--){\\n            ans[i]=ab[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        if(n==1){\\n            arr[0]=-1;\\n            return arr;\\n        }\\n        vector<int> ab(n,-1);\\n        int mx=arr[n-1];\\n        \\n        for(int i=n-1;i>0;i--){\\n            mx=max(mx,arr[i]);\\n            ab[i]=mx;\\n        }\\n        vector<int> ans(n,-1);\\n        ans[n-1]=-1;\\n        for(int i=n-2;i>=0;i--){\\n            ans[i]=ab[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608885,
                "title": "2ms-very-easy-fast-and-simple-java-solution-with-o-n-time-complexity",
                "content": "```\\n//We start from end and update the max until we reach the starting of the array.\\n\\nclass Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        int max = arr[arr.length-1];\\n        int[] otpt = new int[arr.length];\\n        for(int i=arr.length-1;i>=0;i--)\\n        {\\n            otpt[i] = max;\\n            \\n            if(max<arr[i])\\n            {\\n                max = arr[i];\\n            }\\n        }\\n        otpt[arr.length-1] = -1;\\n        return otpt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//We start from end and update the max until we reach the starting of the array.\\n\\nclass Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        int max = arr[arr.length-1];\\n        int[] otpt = new int[arr.length];\\n        for(int i=arr.length-1;i>=0;i--)\\n        {\\n            otpt[i] = max;\\n            \\n            if(max<arr[i])\\n            {\\n                max = arr[i];\\n            }\\n        }\\n        otpt[arr.length-1] = -1;\\n        return otpt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578010,
                "title": "python-simple-solution",
                "content": "Optimised one\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        s = 0\\n        x = 0\\n        y = 0\\n        while x != len(arr)-1:\\n            for i in range(x+1, len(arr)):\\n                if s < arr[i]:\\n                    s = arr[i]\\n                    x = i\\n            for i in range(y, x):\\n                arr[i] = s\\n            s = 0\\n            y = x\\n        arr.pop()\\n        arr.append(-1)\\n        return arr\\n            \\n```\\nUnoptimised solution below , may give TLE\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(len(arr)-1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n```\\n![image](https://assets.leetcode.com/users/images/3fce3324-533c-45ab-a5fa-1995a72cc366_1663998889.5267887.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        s = 0\\n        x = 0\\n        y = 0\\n        while x != len(arr)-1:\\n            for i in range(x+1, len(arr)):\\n                if s < arr[i]:\\n                    s = arr[i]\\n                    x = i\\n            for i in range(y, x):\\n                arr[i] = s\\n            s = 0\\n            y = x\\n        arr.pop()\\n        arr.append(-1)\\n        return arr\\n            \\n```\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(len(arr)-1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455043,
                "title": "simple-o-n-solution-1ms-easy-solution",
                "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n     \\n        int max = arr[arr.length-1];\\n        arr[arr.length-1] = -1;    \\n        \\n        for(int i = arr.length-2; i >= 0 ;i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            \\n            if(temp > max)  {\\n                max =temp;\\n            }\\n        }\\n        \\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n     \\n        int max = arr[arr.length-1];\\n        arr[arr.length-1] = -1;    \\n        \\n        for(int i = arr.length-2; i >= 0 ;i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            \\n            if(temp > max)  {\\n                max =temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2395022,
                "title": "python-in-place-simple-execution",
                "content": "Hope you all find it useful.\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxright = arr[-1]\\n        for i in range(len(arr) -1,-1,-1):\\n            temp = arr[i]\\n            arr[i] = maxright\\n            if temp > maxright:\\n                maxright = temp\\n        arr[-1] = -1\\n        \\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        maxright = arr[-1]\\n        for i in range(len(arr) -1,-1,-1):\\n            temp = arr[i]\\n            arr[i] = maxright\\n            if temp > maxright:\\n                maxright = temp\\n        arr[-1] = -1\\n        \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366804,
                "title": "simple-c-solution-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        for(int i = 0; i < arr.size() - 1; i++)\\n        {\\n            arr[i] = *max_element(arr.begin() + i + 1, arr.end());\\n        }\\n        arr[arr.size() - 1] = -1;\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        for(int i = 0; i < arr.size() - 1; i++)\\n        {\\n            arr[i] = *max_element(arr.begin() + i + 1, arr.end());\\n        }\\n        arr[arr.size() - 1] = -1;\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188680,
                "title": "java-easy-solutions-with-2-approach-in-best-time-complexity-in-place-method-stack-method",
                "content": "USING STACK\\n```\\nint n=arr.length;\\n        Stack<Integer> s = new Stack<>();\\n        int[] ans = new int[n];\\n        \\n        s.push(arr[n-1]);\\n        ans[n-1] = -1 ;\\n        for(int i=n-2; i>=0; i--){\\n            ans[i] = s.peek();\\n            if(s.peek()<arr[i]){\\n                s.push(arr[i]);\\n            }\\n        }\\n    return ans;\\n```\\n\\nIN-PLACE METHOD : \\n```\\nint n = arr.length;\\n           int max = -1;\\n           int temp = 0 ;\\n           for(int i = n-1 ; i >= 0 ; i-- ){\\n               temp = arr[i];\\n               arr[i] = max;\\n               max = Math.max(temp,max);\\n           }\\n        \\n           return arr;\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nint n=arr.length;\\n        Stack<Integer> s = new Stack<>();\\n        int[] ans = new int[n];\\n        \\n        s.push(arr[n-1]);\\n        ans[n-1] = -1 ;\\n        for(int i=n-2; i>=0; i--){\\n            ans[i] = s.peek();\\n            if(s.peek()<arr[i]){\\n                s.push(arr[i]);\\n            }\\n        }\\n    return ans;\\n```\n```\\nint n = arr.length;\\n           int max = -1;\\n           int temp = 0 ;\\n           for(int i = n-1 ; i >= 0 ; i-- ){\\n               temp = arr[i];\\n               arr[i] = max;\\n               max = Math.max(temp,max);\\n           }\\n        \\n           return arr;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2080041,
                "title": "python3-runtime-133ms-82-42-memory-15-2mb-64-02",
                "content": "Both brute force and optimal solution are mentioned\\n```\\nclass Solution:\\n    def replaceElements(self, array: List[int]) -> List[int]:\\n        return self.optimalSolution(array)\\n\\n    #     O(N) || O(1) 133ms 82.42%\\n    def optimalSolution(self, array):\\n        rightMax = -1\\n        for i in reversed(range(len(array))):\\n            maxVal = max(rightMax, array[i])\\n            array[i] = rightMax\\n            rightMax = maxVal\\n        return array\\n        \\n    # O(n^2) || O(1) TLE\\n    def bruteForce(self, array):\\n        if not array:\\n            return array\\n        \\n        for i in range(len(array)):\\n            maxVal = 0\\n            for j in range(i+1, len(array)):\\n                maxVal = max(maxVal, array[j])\\n            array[i] = maxVal\\n\\n\\n        array[-1] = -1\\n\\n        return array\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, array: List[int]) -> List[int]:\\n        return self.optimalSolution(array)\\n\\n    #     O(N) || O(1) 133ms 82.42%\\n    def optimalSolution(self, array):\\n        rightMax = -1\\n        for i in reversed(range(len(array))):\\n            maxVal = max(rightMax, array[i])\\n            array[i] = rightMax\\n            rightMax = maxVal\\n        return array\\n        \\n    # O(n^2) || O(1) TLE\\n    def bruteForce(self, array):\\n        if not array:\\n            return array\\n        \\n        for i in range(len(array)):\\n            maxVal = 0\\n            for j in range(i+1, len(array)):\\n                maxVal = max(maxVal, array[j])\\n            array[i] = maxVal\\n\\n\\n        array[-1] = -1\\n\\n        return array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074507,
                "title": "o-n-solution-in-cpp-in-constant-space",
                "content": "Here we traverse the array in reverse order and keep track of the largest element till then...\\nWe update each element then based on this largest value...\\n\\n**Pls Upvote this thread if u found the explanation helpful**\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int currMax = arr[arr.size()-1];\\n        arr[arr.size()-1] = -1;\\n        for(int i=arr.size()-2;i>=0;i--) {\\n            if(arr[i]>currMax) {\\n                int x = currMax;\\n                currMax = arr[i];\\n                arr[i] = x;\\n            } else {\\n                arr[i] = currMax;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int currMax = arr[arr.size()-1];\\n        arr[arr.size()-1] = -1;\\n        for(int i=arr.size()-2;i>=0;i--) {\\n            if(arr[i]>currMax) {\\n                int x = currMax;\\n                currMax = arr[i];\\n                arr[i] = x;\\n            } else {\\n                arr[i] = currMax;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981200,
                "title": "easytounderstand-s-1-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n//         O(n*n) && S(1)\\n        // int n=arr.size();\\n        // for(int i=0;i<n-1;i++){\\n        //     arr[i]=*max_element(arr.begin()+i+1,arr.end());   \\n        // }\\n        // arr[n-1]=-1;\\n        // return arr;\\n        \\n//         O(n) && S(n)\\n        // int n=arr.size();\\n        // int large;\\n        // vector<int> a(n,-1);\\n        // large=arr[n-1];\\n        // int k=n-2;\\n        // for(int i=n-2;i>=0;i--){\\n        //     a[k--]=large;\\n        //     large=max(large,arr[i]);\\n        // }\\n        // return a;\\n        \\n//         O(n) && S(1)\\n        int mx=-1;\\n        for(int i=arr.size()-1;i>=0;i--){\\n            int curr=arr[i];\\n            arr[i]=mx;\\n            mx=max(mx,curr);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n//         O(n*n) && S(1)\\n        // int n=arr.size();\\n        // for(int i=0;i<n-1;i++){\\n        //     arr[i]=*max_element(arr.begin()+i+1,arr.end());   \\n        // }\\n        // arr[n-1]=-1;\\n        // return arr;\\n        \\n//         O(n) && S(n)\\n        // int n=arr.size();\\n        // int large;\\n        // vector<int> a(n,-1);\\n        // large=arr[n-1];\\n        // int k=n-2;\\n        // for(int i=n-2;i>=0;i--){\\n        //     a[k--]=large;\\n        //     large=max(large,arr[i]);\\n        // }\\n        // return a;\\n        \\n//         O(n) && S(1)\\n        int mx=-1;\\n        for(int i=arr.size()-1;i>=0;i--){\\n            int curr=arr[i];\\n            arr[i]=mx;\\n            mx=max(mx,curr);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961570,
                "title": "fastest-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        var n=arr.length-1;\\n        var prevHigh=arr[n];\\n        arr[n]=-1;\\n        for(var i=n-1;i>=0;i--)\\n        {\\n            var cur=arr[i];\\n            arr[i]=prevHigh;\\n            if(cur>prevHigh)\\n                prevHigh=cur;\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        var n=arr.length-1;\\n        var prevHigh=arr[n];\\n        arr[n]=-1;\\n        for(var i=n-1;i>=0;i--)\\n        {\\n            var cur=arr[i];\\n            arr[i]=prevHigh;\\n            if(cur>prevHigh)\\n                prevHigh=cur;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1893418,
                "title": "java-99-faster-replace-elements-with-greatest-element-on-right",
                "content": "```\\npublic int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        int maxVal = -1;\\n        int temp = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n\\t\\t   //store the maxValue temporarily\\n            temp = maxVal;\\n\\t\\t\\t//compute the maxValue with original array value\\n            maxVal = Math.max(arr[i], maxVal);\\n\\t\\t\\t//assign the maxValue now\\n            arr[i] = temp;\\n        }   \\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] replaceElements(int[] arr) {\\n        int n = arr.length;\\n        int maxVal = -1;\\n        int temp = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n\\t\\t   //store the maxValue temporarily\\n            temp = maxVal;\\n\\t\\t\\t//compute the maxValue with original array value\\n            maxVal = Math.max(arr[i], maxVal);\\n\\t\\t\\t//assign the maxValue now\\n            arr[i] = temp;\\n        }   \\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887228,
                "title": "python-beginner-friendly-solution",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        res = [-1] * len(arr)\\n        for i in range(len(arr)-1):\\n            res[i] = max(arr[i+1:])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        res = [-1] * len(arr)\\n        for i in range(len(arr)-1):\\n            res[i] = max(arr[i+1:])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1839512,
                "title": "simple-java-one-traversal-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=-1;\\n        int n=arr.length;\\n        for(int i=n-1;i>=0;i--){\\n            int t=arr[i];\\n            arr[i]=max;\\n            max=Math.max(t,max);\\n             }\\n         return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max=-1;\\n        int n=arr.length;\\n        for(int i=n-1;i>=0;i--){\\n            int t=arr[i];\\n            arr[i]=max;\\n            max=Math.max(t,max);\\n             }\\n         return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833289,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length;\\n        int max = arr[arr.length - 1];\\n\\n        for (int i = len - 2; i >= 0; i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            if (max < temp) {\\n                max = temp;\\n            }\\n        }\\n\\n        arr[arr.length - 1] = -1;\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length;\\n        int max = arr[arr.length - 1];\\n\\n        for (int i = len - 2; i >= 0; i--) {\\n            int temp = arr[i];\\n            arr[i] = max;\\n            if (max < temp) {\\n                max = temp;\\n            }\\n        }\\n\\n        arr[arr.length - 1] = -1;\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796076,
                "title": "replace-elements-with-greatest-element",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int max_ele=0;\\n            for(int j=i+1; j<arr.size(); j++){\\n               if(arr[j]>max_ele){\\n                   max_ele= arr[j];\\n               }\\n                \\n            }\\n            if(i==arr.size()-1){\\n               ans.push_back(-1);\\n                break;\\n                }\\n            ans.push_back(max_ele);\\n            \\n        }\\n      \\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int max_ele=0;\\n            for(int j=i+1; j<arr.size(); j++){\\n               if(arr[j]>max_ele){\\n                   max_ele= arr[j];\\n               }\\n                \\n            }\\n            if(i==arr.size()-1){\\n               ans.push_back(-1);\\n                break;\\n                }\\n            ans.push_back(max_ele);\\n            \\n        }\\n      \\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792227,
                "title": "easiest-javascript-solution-98-faster",
                "content": "```\\nvar replaceElements = function(arr) {\\n    let j = -1;\\n    \\n    for(let i = arr.length - 1; i >= 0; i--) {\\n        let temp = arr[i];\\n        arr[i] = j;\\n        if(temp > j) {\\n            j = temp;\\n        }\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvar replaceElements = function(arr) {\\n    let j = -1;\\n    \\n    for(let i = arr.length - 1; i >= 0; i--) {\\n        let temp = arr[i];\\n        arr[i] = j;\\n        if(temp > j) {\\n            j = temp;\\n        }\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1723718,
                "title": "easy-to-understand-c-solution-n-newmax-currmax",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        int currMax = -1;\\n        for(int i=n-1; i>=0; i--){\\n            int newMax = max(currMax,arr[i]); //compare\\n            arr[i] = currMax; //replace the element\\n            currMax = newMax; //update currMax value\\n        }\\n        return arr;\\n    \\n    }\\n};\\n```\\n****Please Upvote if you Like ****\\uD83D\\uDE00",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n = arr.size();\\n        int currMax = -1;\\n        for(int i=n-1; i>=0; i--){\\n            int newMax = max(currMax,arr[i]); //compare\\n            arr[i] = currMax; //replace the element\\n            currMax = newMax; //update currMax value\\n        }\\n        return arr;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668769,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            ans.push_back(*max_element(arr.begin()+i+1,arr.end()));\\n        }\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            ans.push_back(*max_element(arr.begin()+i+1,arr.end()));\\n        }\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664732,
                "title": "java-simple-1ms",
                "content": "```\\npublic int[] replaceElements(int[] arr) {\\n       int max = -1;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tint tmp = arr[i];\\n\\t\\t\\tarr[i] = max;\\n\\t\\t\\tif (tmp > max) {\\n\\t\\t\\t\\tmax = tmp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn arr; \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] replaceElements(int[] arr) {\\n       int max = -1;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tint tmp = arr[i];\\n\\t\\t\\tarr[i] = max;\\n\\t\\t\\tif (tmp > max) {\\n\\t\\t\\t\\tmax = tmp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn arr; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640960,
                "title": "simple-c-solution-with-temp-variable-o-n-time-o-1-space",
                "content": "```\\npublic int[] ReplaceElements(int[] arr) {\\n        int max = -1;\\n        for (int i = arr.Length - 1; i >= 0; i--)\\n        {\\n        int temp = max;\\n        if (arr[i] > max)\\n            max = arr[i];\\n        arr[i] = temp;\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] ReplaceElements(int[] arr) {\\n        int max = -1;\\n        for (int i = arr.Length - 1; i >= 0; i--)\\n        {\\n        int temp = max;\\n        if (arr[i] > max)\\n            max = arr[i];\\n        arr[i] = temp;\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580431,
                "title": "python-with-explanation",
                "content": "In this question we need to place the largest to the right value in curr index\\n\\nSteps:\\n1. at first make sanity check: if length is 1 => only `[-1]` is possible\\n2. so far the largest is last ele => attach to var\\n3. idx must be penultimate number.\\n4. traverse till `idx >= 0`\\n5. at first save curr value\\n6. then flip value to largest\\n7. alter: either curr largest or new\\n8. at the end flip value at `idx -1` with -1\\n\\n```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        if len(arr) == 1:\\n            return [-1]\\n        \\n        largest = arr[-1]\\n        idx = len(arr) - 2\\n        while idx >= 0:\\n            temp = arr[idx]\\n            arr[idx] = largest\\n            largest = max(largest, temp)\\n            \\n            idx -= 1\\n        \\n        arr[-1] = -1\\n        return arr\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        if len(arr) == 1:\\n            return [-1]\\n        \\n        largest = arr[-1]\\n        idx = len(arr) - 2\\n        while idx >= 0:\\n            temp = arr[idx]\\n            arr[idx] = largest\\n            largest = max(largest, temp)\\n            \\n            idx -= 1\\n        \\n        arr[-1] = -1\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560449,
                "title": "python-easy-and-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        tillmax = arr[len(arr)-1]\\n        \\n        for j in range(len(arr)-2,-1,-1):\\n            tillmax,arr[j] =  max(arr[j],tillmax),tillmax\\n        \\n        arr[len(arr)-1]=-1\\n        \\n        return arr",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        tillmax = arr[len(arr)-1]\\n        \\n        for j in range(len(arr)-2,-1,-1):\\n            tillmax,arr[j] =  max(arr[j],tillmax),tillmax\\n        \\n        arr[len(arr)-1]=-1\\n        \\n        return arr",
                "codeTag": "Java"
            },
            {
                "id": 1491495,
                "title": "python-solution-not-passing-all-test-cases",
                "content": "Can someone tell me why it is not able to pass all test cases ?\\n\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        x = []\\n        if(len(arr) >1):\\n            for i in range(0, len(arr)):\\n                s = max(arr[i:])\\n                x.append(s)\\n            x.append(-1)\\n            return x[1:]\\n        else:\\n            return [-1]",
                "solutionTags": [],
                "code": "Can someone tell me why it is not able to pass all test cases ?\\n\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        x = []\\n        if(len(arr) >1):\\n            for i in range(0, len(arr)):\\n                s = max(arr[i:])\\n                x.append(s)\\n            x.append(-1)\\n            return x[1:]\\n        else:\\n            return [-1]",
                "codeTag": "Java"
            },
            {
                "id": 1380359,
                "title": "easy-solution-faster-than-90-in-o-n",
                "content": "```\\nvar replaceElements = function(arr) {\\n let result = new Array(arr.length)\\n     result[result.length-1]  = -1\\n     for(let i = arr.length-2; i>= 0; i--){\\n         result[i] = Math.max(arr[i+1] , result[i+1])\\n     }\\n \\n    return result\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar replaceElements = function(arr) {\\n let result = new Array(arr.length)\\n     result[result.length-1]  = -1\\n     for(let i = arr.length-2; i>= 0; i--){\\n         result[i] = Math.max(arr[i+1] , result[i+1])\\n     }\\n \\n    return result\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1264189,
                "title": "python-solution-using-list-slicing-and-max-function-takes-99-8-less-space",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(len(arr) - 1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        for i in range(len(arr) - 1):\\n            arr[i] = max(arr[i+1:])\\n        arr[-1] = -1\\n        return arr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263861,
                "title": "two-python-3-solutions",
                "content": "1. If you don\\'t have time, and you don\\'t care about runtime\\n```\\ndef replaceElements(self, nums: List[int]) -> List[int]:\\n\\tfor i in range(0, len(nums)-1):\\n\\t\\tnums[i] = max(nums[i+1:])\\n\\tnums[-1]=-1\\n\\treturn nums\\n```\\n\\n2. If you have time and you care about runtime\\n```\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n\\tl = len(arr)-1\\n\\tlargest = arr[l]\\n\\tarr[l] = -1\\n\\tl-=1\\n\\n\\twhile l>=0:\\n\\t\\tif arr[l]>largest:\\n\\t\\t\\tarr[l], largest = largest, arr[l]\\n\\t\\telse:\\n\\t\\t\\tarr[l] = largest\\n\\t\\tl-=1\\n\\treturn arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef replaceElements(self, nums: List[int]) -> List[int]:\\n\\tfor i in range(0, len(nums)-1):\\n\\t\\tnums[i] = max(nums[i+1:])\\n\\tnums[-1]=-1\\n\\treturn nums\\n```\n```\\ndef replaceElements(self, arr: List[int]) -> List[int]:\\n\\tl = len(arr)-1\\n\\tlargest = arr[l]\\n\\tarr[l] = -1\\n\\tl-=1\\n\\n\\twhile l>=0:\\n\\t\\tif arr[l]>largest:\\n\\t\\t\\tarr[l], largest = largest, arr[l]\\n\\t\\telse:\\n\\t\\t\\tarr[l] = largest\\n\\t\\tl-=1\\n\\treturn arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1222079,
                "title": "java-code-99-faster-runtime-1ms-o-1-space",
                "content": "# 1299. Replace Elements with Greatest Element on Right Side\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n=arr.length;\\n        int max=arr[n-1];\\n        int temp=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            temp=max;\\n            if(arr[i]>max)\\n            {\\n                max=arr[i];\\n            }\\n            arr[i]=temp;\\n            \\n        }\\n        arr[n-1]=-1;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int n=arr.length;\\n        int max=arr[n-1];\\n        int temp=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            temp=max;\\n            if(arr[i]>max)\\n            {\\n                max=arr[i];\\n            }\\n            arr[i]=temp;\\n            \\n        }\\n        arr[n-1]=-1;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215058,
                "title": "simple-python-solution",
                "content": "```\\nif len(arr)==1:\\n        return [-1]\\n    max=arr[-1]\\n    for i in range(len(arr)-1,-1,-1):\\n        if arr[i]<max:\\n            arr[i]=max\\n        else:\\n            arr[i],max=max,arr[i]\\n    arr[-1]=-1\\n    return arr\\n```",
                "solutionTags": [],
                "code": "```\\nif len(arr)==1:\\n        return [-1]\\n    max=arr[-1]\\n    for i in range(len(arr)-1,-1,-1):\\n        if arr[i]<max:\\n            arr[i]=max\\n        else:\\n            arr[i],max=max,arr[i]\\n    arr[-1]=-1\\n    return arr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203837,
                "title": "c-easiest-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size(); int mx=-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int temp=arr[i];\\n            arr[i]=mx;\\n            mx=max(temp,mx);\\n        }\\n        return arr;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int n=arr.size(); int mx=-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int temp=arr[i];\\n            arr[i]=mx;\\n            mx=max(temp,mx);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1164926,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length;\\n        int [] res = new int [len];\\n        res[len - 1] = -1;\\n        for(int i = len - 1; i > 0; i--){\\n            res[i - 1] = arr[i] > res[i]? arr[i] : res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length;\\n        int [] res = new int [len];\\n        res[len - 1] = -1;\\n        for(int i = len - 1; i > 0; i--){\\n            res[i - 1] = arr[i] > res[i]? arr[i] : res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137403,
                "title": "simple-java-solution-beats-99-9",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int maxv = arr[arr.length-1];\\n        arr[arr.length-1] = -1;\\n        for (int i=arr.length-2; i>=0; --i) {\\n            int temp = Math.max(maxv, arr[i]);\\n            arr[i] = maxv;\\n            maxv = temp;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int maxv = arr[arr.length-1];\\n        arr[arr.length-1] = -1;\\n        for (int i=arr.length-2; i>=0; --i) {\\n            int temp = Math.max(maxv, arr[i]);\\n            arr[i] = maxv;\\n            maxv = temp;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107483,
                "title": "easy-java-solution-two-different-ways",
                "content": "# **1 : **\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) \\n        {\\n            arr[0]=-1;\\n            return arr;\\n        }\\n\\t\\t int max=-1;\\n        for(int i=arr.length-1 ; i>=0 ; i--)\\n        {\\n            int a = arr[i];\\n            arr[i]=max;\\n            max=Math.max(max,a);\\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n\\n\\n```\\n# **2 : **\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) \\n        {\\n            arr[0]=-1;\\n            return arr;\\n        }\\n        int max=0;\\n        for(int i=0 ; i<arr.length ;i++)\\n        {\\n            if(i==arr.length-1)\\n            {\\n                arr[i]=-1;\\n                break;\\n            }\\n            \\n            for(int j=i+1 ; j<arr.length ; j++)\\n            {\\n            if(arr[j]>max)\\n                max=arr[j];\\n            }\\n            arr[i]=max;\\n            max=0;\\n        }\\n        return arr;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) \\n        {\\n            arr[0]=-1;\\n            return arr;\\n        }\\n\\t\\t int max=-1;\\n        for(int i=arr.length-1 ; i>=0 ; i--)\\n        {\\n            int a = arr[i];\\n            arr[i]=max;\\n            max=Math.max(max,a);\\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n\\n\\n```\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        if(arr.length==1) \\n        {\\n            arr[0]=-1;\\n            return arr;\\n        }\\n        int max=0;\\n        for(int i=0 ; i<arr.length ;i++)\\n        {\\n            if(i==arr.length-1)\\n            {\\n                arr[i]=-1;\\n                break;\\n            }\\n            \\n            for(int j=i+1 ; j<arr.length ; j++)\\n            {\\n            if(arr[j]>max)\\n                max=arr[j];\\n            }\\n            arr[i]=max;\\n            max=0;\\n        }\\n        return arr;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099167,
                "title": "java-right-to-left-1ms-beats-99-89-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(n) O(1)\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length, msf = arr[len - 1];\\n\\t\\tint[] ans = new int[len];\\n\\t\\tans[len - 1] = -1;\\n\\t\\tfor (int i = len - 2; i >= 0; i--) {\\n\\t\\t\\tans[i] = msf;\\n\\t\\t\\tif (arr[i] > msf)\\n\\t\\t\\t\\tmsf = arr[i];\\n\\t\\t}\\n\\t\\treturn ans; \\n    }",
                "solutionTags": [],
                "code": "\\n    // O(n) O(1)\\n    public int[] replaceElements(int[] arr) {\\n        int len = arr.length, msf = arr[len - 1];\\n\\t\\tint[] ans = new int[len];\\n\\t\\tans[len - 1] = -1;\\n\\t\\tfor (int i = len - 2; i >= 0; i--) {\\n\\t\\t\\tans[i] = msf;\\n\\t\\t\\tif (arr[i] > msf)\\n\\t\\t\\t\\tmsf = arr[i];\\n\\t\\t}\\n\\t\\treturn ans; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 959751,
                "title": "js-javascript-1-liner",
                "content": "Not very efficient but just for fun:\\n```\\nvar replaceElements = function (arr) {\\n\\treturn arr.reverse().reduce((a, b, i) => a.concat([Math.max(a[i], b)]), [-1]).reverse().slice(1);\\n}\\n```\\nor use the lesser-known `reduceRight` to avoid `reverse`, as well as remove the `slice` to improve speed:\\n```\\nvar replaceElements = function(arr) {\\n    return arr.reduceRight((a, b, i) => i > 0 ? [Math.max(a[0], b)].concat(a) : a, [-1]);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar replaceElements = function (arr) {\\n\\treturn arr.reverse().reduce((a, b, i) => a.concat([Math.max(a[i], b)]), [-1]).reverse().slice(1);\\n}\\n```\n```\\nvar replaceElements = function(arr) {\\n    return arr.reduceRight((a, b, i) => i > 0 ? [Math.max(a[0], b)].concat(a) : a, [-1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 869683,
                "title": "c-providing-3-soultions-brute-force-one-pass-with-a-vector-one-pass-replace",
                "content": "If you have any question about my code,or thought about the code,please comment below , i will try my best to answer it :)\\n# **O(n^2) brute force**\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        vector<int>ans;\\n        for(int i = 0;i<N;i++){\\n            int element = -1;\\n            for(int j = i+1;j<N;j++){\\n                element = max(arr[j],element);\\n            }\\n            ans.push_back(element);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# **O(n) : One-pass & With a Vector**\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        int element = -1;\\n        vector<int>ans(N,-1);\\n        for(int i = N-2;i>=0;i--){\\n            element = max(element,arr[i+1]);\\n            ans[i] = element;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# **O(n) : One-pass & replace**\\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        int element = -1;\\n        int temp = 0;\\n        for(int i = N-1;i>=0;i--){\\n            temp = arr[i];\\n            arr[i] = element;\\n            element = max(element,temp);\\n        }\\n        return arr;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        vector<int>ans;\\n        for(int i = 0;i<N;i++){\\n            int element = -1;\\n            for(int j = i+1;j<N;j++){\\n                element = max(arr[j],element);\\n            }\\n            ans.push_back(element);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        int element = -1;\\n        vector<int>ans(N,-1);\\n        for(int i = N-2;i>=0;i--){\\n            element = max(element,arr[i+1]);\\n            ans[i] = element;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int N = arr.size();\\n        int element = -1;\\n        int temp = 0;\\n        for(int i = N-1;i>=0;i--){\\n            temp = arr[i];\\n            arr[i] = element;\\n            element = max(element,temp);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819806,
                "title": "java-easy-solution",
                "content": "```\\nint rightMax = -1, newMax = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tnewMax = Math.max(arr[i], rightMax);\\n\\t\\t\\tarr[i] = rightMax;\\n\\t\\t\\trightMax = newMax;\\n\\n\\t\\t}\\n\\t\\treturn arr\\n```",
                "solutionTags": [],
                "code": "```\\nint rightMax = -1, newMax = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tnewMax = Math.max(arr[i], rightMax);\\n\\t\\t\\tarr[i] = rightMax;\\n\\t\\t\\trightMax = newMax;\\n\\n\\t\\t}\\n\\t\\treturn arr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 819804,
                "title": "java-easy-solution",
                "content": "```\\nint rightMax = -1, newMax = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tnewMax = Math.max(arr[i], rightMax);\\n\\t\\t\\tarr[i] = rightMax;\\n\\t\\t\\trightMax = newMax;\\n\\n\\t\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nint rightMax = -1, newMax = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0; i--) {\\n\\t\\t\\tnewMax = Math.max(arr[i], rightMax);\\n\\t\\t\\tarr[i] = rightMax;\\n\\t\\t\\trightMax = newMax;\\n\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817555,
                "title": "inplace-algorithm-c-easy-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int lastindex = arr.size() - 1;\\n        // get the max number to be the last element a/c to the problem statement\\n        int maxelement = arr[lastindex];\\n        // replace last element with -1 a/c problem statement\\n        arr[lastindex] = -1;\\n        while(lastindex--){\\n            // if the current element is greater than the max element then swap tha values\\n            if(maxelement <= arr[lastindex])\\n                swap(maxelement, arr[lastindex]);\\n            // else use the current value\\n            else\\n                arr[lastindex] = maxelement;\\n            \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int lastindex = arr.size() - 1;\\n        // get the max number to be the last element a/c to the problem statement\\n        int maxelement = arr[lastindex];\\n        // replace last element with -1 a/c problem statement\\n        arr[lastindex] = -1;\\n        while(lastindex--){\\n            // if the current element is greater than the max element then swap tha values\\n            if(maxelement <= arr[lastindex])\\n                swap(maxelement, arr[lastindex]);\\n            // else use the current value\\n            else\\n                arr[lastindex] = maxelement;\\n            \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753425,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    // O(n) time | O(1) space\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        \\n        for (int i = arr.length-1;i>=0;i--) {  \\n            if (i==arr.length-1) {\\n                max = arr[i];\\n                arr[i] = -1;\\n                continue;\\n            } \\n            \\n            int temp = arr[i];\\n            arr[i]   = max;\\n            \\n            if (temp > max) {\\n                max = temp;\\n            }\\n        }\\n        \\n        return arr;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // O(n) time | O(1) space\\n    public int[] replaceElements(int[] arr) {\\n        int max = -1;\\n        \\n        for (int i = arr.length-1;i>=0;i--) {  \\n            if (i==arr.length-1) {\\n                max = arr[i];\\n                arr[i] = -1;\\n                continue;\\n            } \\n            \\n            int temp = arr[i];\\n            arr[i]   = max;\\n            \\n            if (temp > max) {\\n                max = temp;\\n            }\\n        }\\n        \\n        return arr;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741727,
                "title": "simple-clean-solution",
                "content": "\\'\\'\\'class Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        int top = arr[ arr.length -1 ] ;\\n        arr[ arr.length-1] = -1 ; \\n        \\n        for( int i = arr.length - 2 ; i >= 0 ; i-- )\\n        {\\n        \\t\\tint temp = arr[i] ;\\n        \\t\\tarr[i]   = top ;\\n        \\t\\tif( top < temp )\\n        \\t\\t\\t\\ttop = temp ;\\t\\n        }\\n\\n      return arr ;\\n    }\\n}\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] replaceElements(int[] arr) \\n    {\\n        int top = arr[ arr.length -1 ] ;\\n        arr[ arr.length-1] = -1 ; \\n        \\n        for( int i = arr.length - 2 ; i >= 0 ; i-- )\\n        {\\n        \\t\\tint temp = arr[i] ;\\n        \\t\\tarr[i]   = top ;\\n        \\t\\tif( top < temp )\\n        \\t\\t\\t\\ttop = temp ;\\t\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 715806,
                "title": "python3-faster-than-96-no-need-to-use-max",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        arr = arr[::-1] #reverse the list to make the logic easier\\n        prev = -1 # prev saves the largest value among the previous number. Since the original last number should be replace by -1, we intialize prev as -1.\\n        for i in range(len(arr)):\\n            cur = arr[i] #cur saves the value of the current number\\n            arr[i] = prev # replace the current number with the previous largest number\\n            if cur > prev:\\n                prev = cur #only update the previous largest number if the current number is larger than prev. This is for the next loop\\n            else:\\n                pass\\n        return arr[::-1] # return the list in the original order\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        arr = arr[::-1] #reverse the list to make the logic easier\\n        prev = -1 # prev saves the largest value among the previous number. Since the original last number should be replace by -1, we intialize prev as -1.\\n        for i in range(len(arr)):\\n            cur = arr[i] #cur saves the value of the current number\\n            arr[i] = prev # replace the current number with the previous largest number\\n            if cur > prev:\\n                prev = cur #only update the previous largest number if the current number is larger than prev. This is for the next loop\\n            else:\\n                pass\\n        return arr[::-1] # return the list in the original order\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 708954,
                "title": "swift",
                "content": "```\\n    func replaceElements(_ arr: [Int]) -> [Int] {\\n        var result = [-1]\\n        for i in (1..<arr.count).reversed() {\\n            result.insert(max(result[0], arr[i]), at: 0)\\n        }\\n        return result\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func replaceElements(_ arr: [Int]) -> [Int] {\\n        var result = [-1]\\n        for i in (1..<arr.count).reversed() {\\n            result.insert(max(result[0], arr[i]), at: 0)\\n        }\\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702247,
                "title": "c-python-solutions",
                "content": "C++ solution,\\n```\\nclass Solution {\\npublic:\\n\\tvector<int> replaceElements(vector<int>& arr) {\\n\\t\\tint maxValue = -1;\\n\\n\\t\\tfor (int i = arr.size()-1; i > -1; --i) {\\n\\t\\t\\tint temp = arr[i];\\n\\t\\t\\tarr[i] = maxValue;\\n\\t\\t\\tmaxValue = max(maxValue,temp);\\n\\t\\t}\\n\\n\\t\\treturn arr;\\n\\t}\\n};\\n```\\n\\nPython solution,\\n```\\nclass Solution:\\n\\tdef replaceElements(self, arr):\\n\\t\\tmaxValue = -1\\n\\n\\t\\tfor i in range(len(arr)-1,-1,-1):\\n\\t\\t\\ttemp = arr[i]\\n\\t\\t\\tarr[i] = maxValue\\n\\t\\t\\tmaxValue = max(maxValue,temp)\\n\\n\\t\\treturn arr\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> replaceElements(vector<int>& arr) {\\n\\t\\tint maxValue = -1;\\n\\n\\t\\tfor (int i = arr.size()-1; i > -1; --i) {\\n\\t\\t\\tint temp = arr[i];\\n\\t\\t\\tarr[i] = maxValue;\\n\\t\\t\\tmaxValue = max(maxValue,temp);\\n\\t\\t}\\n\\n\\t\\treturn arr;\\n\\t}\\n};\\n```\n```\\nclass Solution:\\n\\tdef replaceElements(self, arr):\\n\\t\\tmaxValue = -1\\n\\n\\t\\tfor i in range(len(arr)-1,-1,-1):\\n\\t\\t\\ttemp = arr[i]\\n\\t\\t\\tarr[i] = maxValue\\n\\t\\t\\tmaxValue = max(maxValue,temp)\\n\\n\\t\\treturn arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686210,
                "title": "c-80-time-and-space-varies-wildly-with-random-inputs-o-n-time-o-i-space",
                "content": "Starting from the right, nothing much to be said - first value goes stored (into `v`), set the rightmost to `-1`, then you keep storing the maximum value seen so far and replacing:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int lastPos = arr.size() - 1, v = arr[lastPos];\\n        arr[lastPos] = -1;\\n        while (lastPos--) {\\n            if (arr[lastPos] > v) swap(arr[lastPos], v);\\n            else arr[lastPos] = v;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        int lastPos = arr.size() - 1, v = arr[lastPos];\\n        arr[lastPos] = -1;\\n        while (lastPos--) {\\n            if (arr[lastPos] > v) swap(arr[lastPos], v);\\n            else arr[lastPos] = v;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592124,
                "title": "python3-faster-than-96-less-than-100",
                "content": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(arr))[::-1]:\\n            arr[i], m = m, max(m, arr[i])\\n        return arr",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceElements(self, arr: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(arr))[::-1]:\\n            arr[i], m = m, max(m, arr[i])\\n        return arr",
                "codeTag": "Java"
            },
            {
                "id": 568634,
                "title": "java-100-both-space-and-time",
                "content": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n     int n = arr.length;\\n     int max = -1;   \\n     for(int i=n-1;i>=0;i--){\\n        int temp = arr[i];\\n        arr[i] = max;\\n        max = Integer.max(max,temp);\\n     }\\n    \\n     return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n     int n = arr.length;\\n     int max = -1;   \\n     for(int i=n-1;i>=0;i--){\\n        int temp = arr[i];\\n        arr[i] = max;\\n        max = Integer.max(max,temp);\\n     }\\n    \\n     return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563665,
                "title": "js-91-o-n-o-1-memory-in-place-easy-clean-with-comments",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar replaceElements = function(arr) {\\n    var len = arr.length;\\n    // Pick the last element as the max element to start.\\n    var maxTillNow = arr[len - 1];\\n    \\n    // Assign the last index\\'s value to be -1.\\n    arr[len - 1] = -1;\\n    \\n    // Go from the last, assign the previous max to the current index value.\\n    for (var i = len - 2; i >= 0; -- i) {\\n        var temp = maxTillNow;\\n        maxTillNow = maxTillNow < arr[i] ? arr[i] : maxTillNow;\\n        arr[i] = temp;\\n    }\\n    \\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number[]}\\n */\\nvar replaceElements = function(arr) {\\n    var len = arr.length;\\n    // Pick the last element as the max element to start.\\n    var maxTillNow = arr[len - 1];\\n    \\n    // Assign the last index\\'s value to be -1.\\n    arr[len - 1] = -1;\\n    \\n    // Go from the last, assign the previous max to the current index value.\\n    for (var i = len - 2; i >= 0; -- i) {\\n        var temp = maxTillNow;\\n        maxTillNow = maxTillNow < arr[i] ? arr[i] : maxTillNow;\\n        arr[i] = temp;\\n    }\\n    \\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559227,
                "title": "easy-java-1-ms-40-9-mb-o-n",
                "content": "Traverse backwards and keep updating the max element\\n```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = arr[arr.length - 1];\\n        arr[arr.length-1] = -1;\\n        int temp;\\n        \\n        for(int i=arr.length-2; i>=0; i--){\\n            if(max < arr[i]){\\n                temp = arr[i];\\n                arr[i] = max;\\n                max = temp;\\n            } else\\n                arr[i] = max;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int max = arr[arr.length - 1];\\n        arr[arr.length-1] = -1;\\n        int temp;\\n        \\n        for(int i=arr.length-2; i>=0; i--){\\n            if(max < arr[i]){\\n                temp = arr[i];\\n                arr[i] = max;\\n                max = temp;\\n            } else\\n                arr[i] = max;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569721,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1828573,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1834605,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1695789,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1857701,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1691967,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2052243,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2037026,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1894831,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1801920,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1569721,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1828573,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1834605,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1695789,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1857701,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1691967,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2052243,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2037026,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1894831,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1801920,
                "content": [
                    {
                        "username": "venendroid",
                        "content": "It seems like a medium question as most of the people spent more time get the answer. \\nDo you Agree?"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "[@JustinAdams](/JustinAdams)  With brute force you can do it in O(n) time  ."
                    },
                    {
                        "username": "mochiball",
                        "content": "Gotta disagree. I\\'m not even good at leetcode but i solved this in 5 minutes\\n\\nAny time you see each element\\'s greatest, think of starting from the back of the array and/or monotonic stack "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "without the hint, I think it\\'s a bit difficult to come up with the solution.  But once you realize the solution, it\\'s super easy to code."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force is easy.\n\nThe TLE makes it medium.\n\nThe problem needs a follow-up to have you do it in O(n) time."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint:\\nA lot of approaches comes into mind... but this could be solvable in O(n) time and O(1) space.\\n\\nTry to think in reverse manner i.e. computing values from the end of the array instead of start."
                    },
                    {
                        "username": "Derek_Stackboy",
                        "content": "brilliant notice :)"
                    },
                    {
                        "username": "Shobhit_2203",
                        "content": "Yes. Exactly. As I saw this comment, whole code and logic just got print in my brain"
                    },
                    {
                        "username": "varshini-S",
                        "content": "begineers out here!!"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "If you hit time limits a lot, try to change your perspective. \\n\\nI\\'ve hit many times even with the *max_element() (C++), I tried brute force and max() as well, the thing that I forgot was...\\n\\nAnd suddenly I realized that when we change the current element with any other element in the vector-array, all the indexes between needs to be changed to max value.\\nEg\\nvector<int>& arr = [15, 13, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] First for loop changes to:\\nvector<int>& arr = [15, 14, 14, 12, 11, 10, 9, 8, 7, 6, 5, 4, 13, 2, 1] which is okay but for the next for loop the index 3 should be changed to 13, and also all the indexes between the index 12 needs to be changed to 13 as well, see:\\nvector<int>& arr = [15, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 1]. \\n\\nMy first time limit approaches were checking the each index even tho their value needs to be changed already..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Bro wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "nviswa002",
                        "content": "Time complexity for *max_element()  is O(n), so you would have use loop to make the changes with the *max_element fuction. Now the time complexity has become O(N^2).\\n "
                    },
                    {
                        "username": "asterfung",
                        "content": "As a leetcode beginner I find the hidden test case of looooog array was almost vicious as if someone intended to fail people, afterall this is an \"easy\" problem. Someone should have mentioned that edge case/time limit in the problem. Does anyone feel the same? "
                    },
                    {
                        "username": "joe_masana",
                        "content": "I also thought that, but then saw that it does tell us that the length of the array can by anywhere from 1 to 10^4. Always good to check the constraints first."
                    },
                    {
                        "username": "SanketSalviii",
                        "content": "why brute force approach is showing time limit exceeded?"
                    },
                    {
                        "username": "Jonta",
                        "content": "Time Limit Exceeded means they ran your code on a bigger input, and the code is slow"
                    },
                    {
                        "username": "vidyadharjogi101",
                        "content": "It\\'s a fairly simple problem. You just need to think a bit.\\nTraverse through the input array in reverse order.\\nkeep the temporary variable largest (initially -1)\\nwhile traversing add the largest to output array \\ncheck if largest < arr[i] then update largest else continue."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Average indian kid"
                    },
                    {
                        "username": "potatopie",
                        "content": "really hard..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@potatopie](/potatopie) I understand you, I\\'m a 13 year old boy who learns how to code by myself, but everyday it becomes easier to solve and undersatnd code, just take your time"
                    },
                    {
                        "username": "potatopie",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i still struggle with easy problems, so im working down the acceptance rate list. Worth noting that I ma not a CS student. So I\\'m learning to code as im doing these."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, if you would spend more time on coding and solving harder problems this would be that problematic, if you want to be better, you can start solving more medium problems, if they have high acceptance rate, than they could be easier"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Traverse from the end to the start and have a variable \\'prev\\' which stores the last max value initialized to -1. If the current value is lesser than the \\'prev\\', then swap the current value and the prev. If not, simply assign the current value with prev value."
                    },
                    {
                        "username": "lapartman",
                        "content": "It\\'s the other way around. If the current value is bigger than the prev, that\\'s when you do the swap. If not, you just assign the \"prev\" value to the current one."
                    },
                    {
                        "username": "mkathi",
                        "content": "hey , your comment helped me improve my solution but the condition is wrong the code will work if we store current element value in a temp variable and then assign current value with prevMax Value which is initialized to \\'-1\\' and then prevMax will be max(prevMax,temp) \\n\\nThank you , with your comment my solution from 14% transited to 90% "
                    },
                    {
                        "username": "mk6405146",
                        "content": "class Solution {\\n    public int[] replaceElements(int[] arr) {\\n        int greatRight=-1;\\n        for(int i=arr.length-1;i>=0;i--) //start from right side of array \\n{\\n\\n            int temp=arr[i];  // store current element in temp variable\\n            arr[i]=greatRight;  // replace curr element with greatest element \\n            if(temp>greatRight){\\n                greatRight=temp;\\n            }\\n        }\\n        return arr;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1994088,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1978817,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1976453,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1966942,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1961999,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1939821,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1898670,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1889892,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1830202,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            },
            {
                "id": 1822408,
                "content": [
                    {
                        "username": "shkhiab87",
                        "content": "Hint : \\n. question is not as simple as it looks \\n. i took 45 mints to solve and to understand the approach \\n. there are many approaches comes in the mind while starting \\n. but try to solve in reverse order while considering ( max = -1)\\n. than compare max....... and perform some swapping operation and basic computation \\n"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Consider starting from the end and observe how the values change in the result."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I'm glad I went through the arrays explore card to get a better feel for these problems. I've spent so much time working in other patterns that my mind immediately went to a PriorityQueue and I was really over engineering the problem vs doing something simple and coming in from the right which is the most basic of basic angles of attack for so many problems. "
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "I have tried to solve this problem using streams and it has given me a Time limit exceeded error. \\n\\nIs trying to solve it using Streams a good idea?   "
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Brute force o(n^2) is easy, but you might TLE so you\\'ll need to drop down to O(n).\\n\\nConsider traversing from right to left and carrying the max value up to that point forward."
                    },
                    {
                        "username": "Kenzie7",
                        "content": "n = len(arr)\\n        ans = []\\n\\n        for i in range(0, n-1):\\n            ans.append(max(arr[i+1:]))\\n        \\n        return ans + [-1]\\n\\n\\nwhat\\'s wrong with this one? "
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "Time complexity is O(n^2) because slicing is O(n)"
                    },
                    {
                        "username": "Godfather20",
                        "content": " `class Solution {\\npublic:  \\n    int greatestElement(vector<int> arr, int n) {\\n        int max = -1;\\n        for(int i=n+1; i<arr.size(); i++){\\n            if(max<arr[i]){\\n                max = arr[i];\\n            }\\n        }\\n        return max;\\n    }\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0; i<arr.size(); i++){\\n            int greatestLeftElement = greatestElement(arr, i);\\n            ans.push_back(greatestLeftElement);\\n        }\\n        return ans;\\n    }\\n};`\\nthough this code works but it gives memory limit exceeds on an edge case. why?"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "Hey folks, super beginner here - I wonder if anyone would be so kind as to point out why my code (JavaScript) fails at very large array sizes? The output is correct for 95% of test cases, only very large inputs seem to fail\n\n `var replaceElements = function(arr) {\n    if (arr.length < 2) return [-1];\n\n    let max = arr.slice(1).reduce((a, b) => Math.max(a, b), -Infinity);\n    let largestIndex = arr.findIndex(element => element === max);\n\n    for (let i=0; i<arr.length-1; i++)\n    {\n        if (i < largestIndex) arr[i] = max;\n        else\n        {\n            max = arr.slice(i+1).reduce((a, b) => Math.max(a, b), -Infinity);\n            largestIndex = arr.findIndex(element => element === max);\n        }\n    }\n    arr.shift();\n    arr.push(-1);\n    return arr\n};`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For arrays like `[1,2,3]` you'll get $O({n}^{2})$ complexity. Each time you'll traverse the array of length $[1, n - 1]$. `slice`, `reduce` and `findIndex` are too expensive for this problem, each of them is traversing the entire array."
                    },
                    {
                        "username": "Shree_Ram_Singh",
                        "content": "class Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n        vector<int>v;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            int big=*max_element(arr.begin()+i+1,arr.end());\\n            v.push_back(big);\\n        }\\n        v.push_back(-1);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "TrippingLettuce",
                        "content": "Can someone explain to me why my code is wrong it works for all the test cases besides Test Case 8\\n\\n```Python\\ndef replaceElements(arr):\\n    \"\"\"\\n    :type arr: List[int]\\n    :rtype: List[int]\\n    \"\"\"\\n    rtype = []\\n    for x in range(len(arr)):\\n        for y in arr:\\n            if y == arr[0]:\\n                maxim = 0\\n            elif y > maxim:\\n                maxim = y\\n        if maxim == 0:\\n            rtype.append(-1)\\n        else:\\n            rtype.append(maxim)\\n            arr.pop(0)\\n    return rtype\\n```"
                    }
                ]
            }
        ]
    }
]