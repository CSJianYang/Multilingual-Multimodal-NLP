[
    {
        "title": "Generate Parentheses",
        "question_content": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n&nbsp;\nExample 1:\nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\nExample 2:\nInput: n = 1\nOutput: [\"()\"]\n&nbsp;\nConstraints:\n\n\t1 <= n <= 8",
        "solutions": [
            {
                "id": 10100,
                "title": "easy-to-understand-java-backtracking-solution",
                "content": "     public List<String> generateParenthesis(int n) {\\n            List<String> list = new ArrayList<String>();\\n            backtrack(list, \"\", 0, 0, n);\\n            return list;\\n        }\\n        \\n        public void backtrack(List<String> list, String str, int open, int close, int max){\\n            \\n            if(str.length() == max*2){\\n                list.add(str);\\n                return;\\n            }\\n            \\n            if(open < max)\\n                backtrack(list, str+\"(\", open+1, close, max);\\n            if(close < open)\\n                backtrack(list, str+\")\", open, close+1, max);\\n        }\\n\\nThe idea here is to only add '(' and ')' that we know will guarantee us a solution (instead of adding 1 too many close). Once we add a '(' we will then discard it and try a ')' which can only close a valid '('. Each of these steps are recursively called.",
                "solutionTags": [
                    "Java"
                ],
                "code": "     public List<String> generateParenthesis(int n) {\\n            List<String> list = new ArrayList<String>();\\n            backtrack(list, \"\", 0, 0, n);\\n            return list;\\n        }\\n        \\n        public void backtrack(List<String> list, String str, int open, int close, int max){\\n            \\n            if(str.length() == max*2){\\n                list.add(str);\\n                return;\\n            }\\n            \\n            if(open < max)\\n                backtrack(list, str+\"(\", open+1, close, max);\\n            if(close < open)\\n                backtrack(list, str+\")\", open, close+1, max);\\n        }\\n\\nThe idea here is to only add '(' and ')' that we know will guarantee us a solution (instead of adding 1 too many close). Once we add a '(' we will then discard it and try a ')' which can only close a valid '('. Each of these steps are recursively called.",
                "codeTag": "Unknown"
            },
            {
                "id": 2542620,
                "title": "python-java-w-explanation-faster-than-96-w-proof-easy-to-understand",
                "content": "1. The idea is to add `\\')\\'` only after valid `\\'(\\'`\\n2. We use two integer variables `left` & `right` to see how many `\\'(\\'` & `\\')\\'` are in the current string\\n3. If `left < n` then we can add `\\'(\\'` to the current string\\n4. If `right < left` then we can add `\\')\\'` to the current string\\n\\n**Python Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tdef dfs(left, right, s):\\n\\t\\tif len(s) == n * 2:\\n\\t\\t\\tres.append(s)\\n\\t\\t\\treturn \\n\\n\\t\\tif left < n:\\n\\t\\t\\tdfs(left + 1, right, s + \\'(\\')\\n\\n\\t\\tif right < left:\\n\\t\\t\\tdfs(left, right + 1, s + \\')\\')\\n\\n\\tres = []\\n\\tdfs(0, 0, \\'\\')\\n\\treturn res\\n```\\n\\nFor` n = 2`, the recursion tree will be something like this,\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\t(0, 0, \\'\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t \\t    |\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(1, 0, \\'(\\')  \\n\\t\\t\\t\\t\\t\\t\\t\\t   /           \\\\\\n\\t\\t\\t\\t\\t\\t\\t(2, 0, \\'((\\')      (1, 1, \\'()\\')\\n\\t\\t\\t\\t\\t\\t\\t   /                 \\\\\\n\\t\\t\\t\\t\\t\\t(2, 1, \\'(()\\')           (2, 1, \\'()(\\')\\n\\t\\t\\t\\t\\t\\t   /                       \\\\\\n\\t\\t\\t\\t\\t(2, 2, \\'(())\\')                (2, 2, \\'()()\\')\\n\\t\\t\\t\\t\\t\\t      |\\t                             |\\n\\t\\t\\t\\t\\tres.append(\\'(())\\')             res.append(\\'()()\\')\\n   \\n```\\n\\n**Java Code:**\\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        recurse(res, 0, 0, \"\", n);\\n        return res;\\n    }\\n    \\n    public void recurse(List<String> res, int left, int right, String s, int n) {\\n        if (s.length() == n * 2) {\\n            res.add(s);\\n            return;\\n        }\\n        \\n        if (left < n) {\\n            recurse(res, left + 1, right, s + \"(\", n);\\n        }\\n        \\n        if (right < left) {\\n            recurse(res, left, right + 1, s + \")\", n);\\n        }\\n    }\\n\\t// See above tree diagram with parameters (left, right, s) for better understanding\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/7df8c537-35e6-42a5-8b91-e2f6ec9031d0_1662519743.7174962.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/227fc269-7b54-4e64-b490-66e6154a40cd_1662518370.2619233.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tdef dfs(left, right, s):\\n\\t\\tif len(s) == n * 2:\\n\\t\\t\\tres.append(s)\\n\\t\\t\\treturn \\n\\n\\t\\tif left < n:\\n\\t\\t\\tdfs(left + 1, right, s + \\'(\\')\\n\\n\\t\\tif right < left:\\n\\t\\t\\tdfs(left, right + 1, s + \\')\\')\\n\\n\\tres = []\\n\\tdfs(0, 0, \\'\\')\\n\\treturn res\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\t(0, 0, \\'\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t \\t    |\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(1, 0, \\'(\\')  \\n\\t\\t\\t\\t\\t\\t\\t\\t   /           \\\\\\n\\t\\t\\t\\t\\t\\t\\t(2, 0, \\'((\\')      (1, 1, \\'()\\')\\n\\t\\t\\t\\t\\t\\t\\t   /                 \\\\\\n\\t\\t\\t\\t\\t\\t(2, 1, \\'(()\\')           (2, 1, \\'()(\\')\\n\\t\\t\\t\\t\\t\\t   /                       \\\\\\n\\t\\t\\t\\t\\t(2, 2, \\'(())\\')                (2, 2, \\'()()\\')\\n\\t\\t\\t\\t\\t\\t      |\\t                             |\\n\\t\\t\\t\\t\\tres.append(\\'(())\\')             res.append(\\'()()\\')\\n   \\n```\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        recurse(res, 0, 0, \"\", n);\\n        return res;\\n    }\\n    \\n    public void recurse(List<String> res, int left, int right, String s, int n) {\\n        if (s.length() == n * 2) {\\n            res.add(s);\\n            return;\\n        }\\n        \\n        if (left < n) {\\n            recurse(res, left + 1, right, s + \"(\", n);\\n        }\\n        \\n        if (right < left) {\\n            recurse(res, left, right + 1, s + \")\", n);\\n        }\\n    }\\n\\t// See above tree diagram with parameters (left, right, s) for better understanding\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10105,
                "title": "concise-recursive-c-solution",
                "content": "The idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n >0 and add a right parenthesis if m>0. Append the result and terminate recursive calls when both m and n are zero.\\n\\n    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> res;\\n            addingpar(res, \"\", n, 0);\\n            return res;\\n        }\\n        void addingpar(vector<string> &v, string str, int n, int m){\\n            if(n==0 && m==0) {\\n                v.push_back(str);\\n                return;\\n            }\\n            if(m > 0){ addingpar(v, str+\")\", n, m-1); }\\n            if(n > 0){ addingpar(v, str+\"(\", n-1, m+1); }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> res;\\n            addingpar(res, \"\", n, 0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 10096,
                "title": "4-7-lines-python",
                "content": "`p` is the parenthesis-string built so far, `left` and `right` tell the number of left and right parentheses still to add, and `parens` collects the parentheses.\\n\\n**Solution 1**\\n\\nI used a few \"tricks\"... how many can you find? :-)\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right, parens=[]):\\n            if left:         generate(p + '(', left-1, right)\\n            if right > left: generate(p + ')', left, right-1)\\n            if not right:    parens += p,\\n            return parens\\n        return generate('', n, n)\\n\\n**Solution 2**\\n\\nHere I wrote an actual Python generator. I allow myself to put the `yield q` at the end of the line because it's not that bad and because in \"real life\" I use Python 3 where I just say `yield from generate(...)`.\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right):\\n            if right >= left >= 0:\\n                if not right:\\n                    yield p\\n                for q in generate(p + '(', left-1, right): yield q\\n                for q in generate(p + ')', left, right-1): yield q\\n        return list(generate('', n, n))\\n\\n**Solution 3**\\n\\nImproved version of [this](https://leetcode.com/discuss/25725/7-lines-in-python-44-ms). Parameter `open` tells the number of \"already opened\" parentheses, and I continue the recursion as long as I still have to open parentheses (`n > 0`) and I haven't made a mistake yet (`open >= 0`).\\n\\n    def generateParenthesis(self, n, open=0):\\n        if n > 0 <= open:\\n            return ['(' + p for p in self.generateParenthesis(n-1, open+1)] + \\\\\\n                   [')' + p for p in self.generateParenthesis(n, open-1)]\\n        return [')' * open] * (not n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "`p` is the parenthesis-string built so far, `left` and `right` tell the number of left and right parentheses still to add, and `parens` collects the parentheses.\\n\\n**Solution 1**\\n\\nI used a few \"tricks\"... how many can you find? :-)\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right, parens=[]):\\n            if left:         generate(p + '(', left-1, right)\\n            if right > left: generate(p + ')', left, right-1)\\n            if not right:    parens += p,\\n            return parens\\n        return generate('', n, n)\\n\\n**Solution 2**\\n\\nHere I wrote an actual Python generator. I allow myself to put the `yield q` at the end of the line because it's not that bad and because in \"real life\" I use Python 3 where I just say `yield from generate(...)`.\\n\\n    def generateParenthesis(self, n):\\n        def generate(p, left, right):\\n            if right >= left >= 0:\\n                if not right:\\n                    yield p\\n                for q in generate(p + '(', left-1, right): yield q\\n                for q in generate(p + ')', left, right-1): yield q\\n        return list(generate('', n, n))\\n\\n**Solution 3**\\n\\nImproved version of [this](https://leetcode.com/discuss/25725/7-lines-in-python-44-ms). Parameter `open` tells the number of \"already opened\" parentheses, and I continue the recursion as long as I still have to open parentheses (`n > 0`) and I haven't made a mistake yet (`open >= 0`).\\n\\n    def generateParenthesis(self, n, open=0):\\n        if n > 0 <= open:\\n            return ['(' + p for p in self.generateParenthesis(n-1, open+1)] + \\\\\\n                   [')' + p for p in self.generateParenthesis(n, open-1)]\\n        return [')' * open] * (not n)",
                "codeTag": "Python3"
            },
            {
                "id": 10127,
                "title": "an-iterative-method",
                "content": "My method is DP. First consider how to get the result f(n) from previous result f(0)...f(n-1).\\nActually, the result f(n) will be put an extra () pair to f(n-1). Let the \"(\" always at the first position, to produce a valid result, we can only put \")\" in a way that there will be i pairs () inside the extra () and n - 1 - i pairs () outside the extra pair.\\n\\nLet us consider an example to get clear view:\\n\\nf(0):  \"\"\\n\\nf(1):  \"(\"f(0)\")\"\\n\\nf(2): \"(\"f(0)\")\"f(1), \"(\"f(1)\")\"\\n\\nf(3): \"(\"f(0)\")\"f(2), \"(\"f(1)\")\"f(1), \"(\"f(2)\")\"\\n\\nSo f(n) = \"(\"f(0)\")\"f(n-1) , \"(\"f(1)\")\"f(n-2) \"(\"f(2)\")\"f(n-3) ... \"(\"f(i)\")\"f(n-1-i) ... \"(f(n-1)\")\"\\n\\nBelow is my code:\\n\\n    public class Solution\\n    {\\n        public List<String> generateParenthesis(int n)\\n        {\\n            List<List<String>> lists = new ArrayList<>();\\n            lists.add(Collections.singletonList(\"\"));\\n            \\n            for (int i = 1; i <= n; ++i)\\n            {\\n                final List<String> list = new ArrayList<>();\\n                \\n                for (int j = 0; j < i; ++j)\\n                {\\n                    for (final String first : lists.get(j))\\n                    {\\n                        for (final String second : lists.get(i - 1 - j))\\n                        {\\n                            list.add(\"(\" + first + \")\" + second);\\n                        }\\n                    }\\n                }\\n                \\n                lists.add(list);\\n            }\\n            \\n            return lists.get(lists.size() - 1);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution\\n    {\\n        public List<String> generateParenthesis(int n)\\n        {\\n            List<List<String>> lists = new ArrayList<>();\\n            lists.add(Collections.singletonList(\"\"));\\n            \\n            for (int i = 1; i <= n; ++i)\\n            {\\n                final List<String> list = new ArrayList<>();\\n                \\n                for (int j = 0; j < i; ++j)\\n                {\\n                    for (final String first : lists.get(j))\\n                    {\\n                        for (final String second : lists.get(i - 1 - j))\\n                        {\\n                            list.add(\"(\" + first + \")\" + second);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 10369,
                "title": "clean-python-dp-solution",
                "content": "To generate all n-pair parentheses, we can do the following:\\n\\n1. Generate one pair: ()\\n2. Generate 0 pair inside, n - 1 afterward: () (...)...\\n\\n    Generate 1 pair inside, n - 2 afterward: (()) (...)...\\n\\n    ...\\n\\n    Generate n - 1 pair inside, 0 afterward: ((...)) \\n\\nI bet you see the overlapping subproblems here. Here is the code:\\n\\n(you could see in the code that `x` represents one j-pair solution and `y` represents one (i - j - 1) pair solution, and we are taking into account all possible of combinations of them)\\n\\n    class Solution(object):\\n        def generateParenthesis(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: List[str]\\n            \"\"\"\\n            dp = [[] for i in range(n + 1)]\\n            dp[0].append('')\\n            for i in range(n + 1):\\n                for j in range(i):\\n                    dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]]\\n            return dp[n]",
                "solutionTags": [],
                "code": "To generate all n-pair parentheses, we can do the following:\\n\\n1. Generate one pair: ()\\n2. Generate 0 pair inside, n - 1 afterward: () (...)...\\n\\n    Generate 1 pair inside, n - 2 afterward: (()) (...)...\\n\\n    ...\\n\\n    Generate n - 1 pair inside, 0 afterward: ((...)) \\n\\nI bet you see the overlapping subproblems here. Here is the code:\\n\\n(you could see in the code that `x` represents one j-pair solution and `y` represents one (i - j - 1) pair solution, and we are taking into account all possible of combinations of them)\\n\\n    class Solution(object):\\n        def generateParenthesis(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: List[str]\\n            \"\"\"\\n            dp = [[] for i in range(n + 1)]\\n            dp[0].append('')\\n            for i in range(n + 1):\\n                for j in range(i):\\n                    dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]]\\n            return dp[n]",
                "codeTag": "Java"
            },
            {
                "id": 1131364,
                "title": "clear-and-simple-explanation-with-intuition-100-faster",
                "content": "**Intuition:** Since we are asked to calculate all the possible permutations of brackets , hence we have to use backtracking\\n\\n**Concept:** In every backtracking problem , there are two things to keep in mind , which we will explore here as well :\\n*  Base Case: Every problem of backtracking has some base case which tells us at which point we have to stop with the recursion process. In our case, when the length of our string has reached the maximum length(`n*2`), we stop with the recursion for that case and that is our base case.\\n\\n*   Conditions: On observing carefully we find that there are two conditions present:\\n    *  For adding **`(`**:  If number of opening brackets(`open`) is less than the the given length(`n`) i.e.\\n        if `max`<`n`, then we can add **`(`**,else not.\\n\\t*  For adding **`)`**: If number of close brackets(`close`) is less than the opening brackets(`open`), i.e.\\n\\t    if `open`<`close`, we can add **`)`**, else not\\n\\t\\t\\nAnd thats it!!! Keeping these two things in mind here is the code: \\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string>result;\\n    \\n    void helper(int open,int close,int n,string current)\\n    {\\n        if(current.length()==n*2)\\n        {\\n            result.push_back(current);\\n            return;\\n        }\\n        if(open<n)  helper(open+1,close,n,current+\"(\");\\n        if(close<open)  helper(open,close+1,n,current+\")\");\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        helper(0,0,n,\"\");\\n        return result;\\n    }\\n};\\n```\\n\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you like, please **UPVOTE**\\nHappy Coding :))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>result;\\n    \\n    void helper(int open,int close,int n,string current)\\n    {\\n        if(current.length()==n*2)\\n        {\\n            result.push_back(current);\\n            return;\\n        }\\n        if(open<n)  helper(open+1,close,n,current+\"(\");\\n        if(close<open)  helper(open,close+1,n,current+\")\");\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        helper(0,0,n,\"\");\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290261,
                "title": "i-bet-you-will-understand-intutive-solution-beginner-friendly-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is one of the classical recursion problems. \\nFor any given n, lets say n = 2, we have to fill four places in our output (\"_ _ _ _\"). And each of these places can be either filled by an open braces \"(\" or a closed braces \")\". \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n                                    \"_  _  _  _\"\\n                                    / \\\\     \\n                                  \\'(\\' \\')\\'\\n\\nFor every place we have two choices and 1 decision to make. \\nOur choices are to either use \\'(\\' or \\')\\'.\\n\\nNow lets try to visualize the recursive tree based upon the choices discussed above.\\n\\nInitially, we have:\\nFor n = 3\\ncurrent ouput = \"\"\\navailableOpenBracketsCnt = 3 and availableCloseBracketsCnt  = 3\\n\\nThe first choise is very simple. Since we can not start a balanced parenthesis sequence with \\')\\', we have only one choice in the begining. So our output will be \\'(\\' and count of open brackets left = 2 and count of closed brackets left = 3.\\n\\n                                        op      ip\\n                                        \"\"   O-3, C-3\\n                                \\n                                        \"(\",O-2,C-3\\n                        \\n                    \"((\",O-1,C-3                            \"()\", O-2,C-2\\n\\n        \"(((\",0,3             \"(()\",1,2                       \"()(\",1,2\\n\\n        \"((()\",0,2      \"(()(\",0,2    \"(())\",1,1        \"()((\",0,2      \"()()\",1,1\\n\\n        \"((())\",0,1     \"(()()\",0,1   \"(())(\",0,1       \"()(()\",0,1     \"()()(\",0,1\\n\\n        \"((()))\",0,0   \"(()())\",0,0   \"(())()\",0,0      \"()(())\",0,0    \"()()()\", 0,0\\n                            \\n\\n# Observation from the recursive tree\\n\\n - Whenever we have count of open brackets equal to the count of close brackets, we have only one choice - that is to use \\'(\\'. Because, all the brackets till now have been balanced. And we can not start a new sequence with \\')\\'. \\n - Whenever, count of close bracket is 0, we can only use \\'(\\'.\\n - Whenever, count of open bracket is 0, we can only use \\')\\'.\\n - And for all the remaining cases, we have both the choices.\\n - We get an answer, when count of open == 0 and count of close == 0.\\n\\nJust convert these 5 observations into an algorithm and write the code. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```\\n**Note** : I have kept the code implementation simple by just following the observations I mentioned. The same code can be made more compact by reducing some conditional statements (although the time and space complexity will remain the same).\\nTry to come up with your own compact version. Refer the comments of other peers for help.\\n\\n# Complexity Analysis: \\n- Time Complexity : $O(N*2^N)$ where N = 2*n\\n $O(2^N)$ : We have N = 2n places to fill and for every place we will have a maximum of 2 choices. \\n $O(N)$ : We will have to multiply our TC by a factor of N, as every time when we hit the base case, we will copy current op (which is of size N) into the answer vector.\\n- Space Complexity : $O(N)$ + Recursive Stack Space\\n We have used an extra string of size N for storing current output\\n# Please upvote the solution if you understood it.\\n\\n![NRRa.gif](https://assets.leetcode.com/users/images/ac16397a-5dda-46bb-8508-a6caf66f016b_1679243081.1794233.gif)\\n\\n**You can connect with me on linkedin, If you understood my solution :D**\\nhttps://www.linkedin.com/in/imraghavagr/\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10110,
                "title": "simple-python-dfs-solution-with-explanation",
                "content": "If you have two stacks, one for n \"(\", the other for n \")\", you generate a binary tree from these two stacks of left/right parentheses to form an output string. \\n\\n\\nThis means that whenever you traverse deeper, you pop one parentheses from one of stacks. When two stacks are empty, you form an output string.\\n\\nHow to form a legal string? Here is the simple observation:\\n\\n - For the output string to be right, stack of \")\" most be larger than stack of \"(\". If not, it creates string like \"())\"\\n - Since elements in each of stack are the same, we can simply express them with a number. For example, left = 3 is like a stacks [\"(\", \"(\", \"(\"]\\n\\nSo, here is my sample code in Python:\\n\\n    class Solution:\\n    # @param {integer} n\\n    # @return {string[]}\\n    def generateParenthesis(self, n):\\n        if not n:\\n            return []\\n        left, right, ans = n, n, []\\n        self.dfs(left,right, ans, \"\")\\n        return ans\\n\\n    def dfs(self, left, right, ans, string):\\n        if right < left:\\n            return\\n        if not left and not right:\\n            ans.append(string)\\n            return\\n        if left:\\n            self.dfs(left-1, right, ans, string + \"(\")\\n        if right:\\n            self.dfs(left, right-1, ans, string + \")\")",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 10099,
                "title": "time-complexity-to-generate-all-combinations-of-well-formed-parentheses",
                "content": "Generating all combinations of well formed paranthesis is a typical example of catalan numbers. You can use the links at the bottom here if you are not aware of the catalan numbers since they are at the heart of the exercise.\\nLet time complexity for the generating all combinations of well-formed parentheses is f(n), then\\nf(n) = g(n) * h(n) where g(n) is the time complexity for calculating nth catalan number, and h(n) is the time required to copy this combination to result array.\\nTherefore, f(n) = catalan(n) * O(n) which is O(4^n/n^1.5)*(n)). Broadly saying just remember that this is a typical example of catalan number and it's time complexity is similar to how catalan(n) is got.\\nFurther readings in to catalan numbers:\\nhttps://en.wikipedia.org/wiki/Catalan_number\\nhttps://www.youtube.com/watch?v=GlI17WaMrtw\\nhttps://www.youtube.com/watch?v=eoofvKI_Okg",
                "solutionTags": [],
                "code": "Generating all combinations of well formed paranthesis is a typical example of catalan numbers. You can use the links at the bottom here if you are not aware of the catalan numbers since they are at the heart of the exercise.\\nLet time complexity for the generating all combinations of well-formed parentheses is f(n), then\\nf(n) = g(n) * h(n) where g(n) is the time complexity for calculating nth catalan number, and h(n) is the time required to copy this combination to result array.\\nTherefore, f(n) = catalan(n) * O(n) which is O(4^n/n^1.5)*(n)). Broadly saying just remember that this is a typical example of catalan number and it's time complexity is similar to how catalan(n) is got.\\nFurther readings in to catalan numbers:\\nhttps://en.wikipedia.org/wiki/Catalan_number\\nhttps://www.youtube.com/watch?v=GlI17WaMrtw\\nhttps://www.youtube.com/watch?v=eoofvKI_Okg",
                "codeTag": "Unknown"
            },
            {
                "id": 10283,
                "title": "python-simple-stack-solution-without-recursion",
                "content": "    def generateParenthesis(self, n):\\n        res = []\\n        s = [(\"(\", 1, 0)]\\n        while s:\\n            x, l, r = s.pop()\\n            if l - r < 0 or l > n or r > n:\\n                continue\\n            if l == n and r == n:\\n                res.append(x)\\n            s.append((x+\"(\", l+1, r))\\n            s.append((x+\")\", l, r+1))\\n        return res\\n\\n\\nvariable l is current left parenthesis count\\n\\nvariable r is current right parenthesis count\\n\\nl - r < 0 means this is not a valid parenthesis",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "    def generateParenthesis(self, n):\\n        res = []\\n        s = [(\"(\", 1, 0)]\\n        while s:\\n            x, l, r = s.pop()\\n            if l - r < 0 or l > n or r > n:\\n                continue\\n            if l == n and r == n:\\n                res.append(x)\\n            s.append((x+\"(\", l+1, r))\\n            s.append((x+\")\", l, r+1))\\n        return res\\n\\n\\nvariable l is current left parenthesis count\\n\\nvariable r is current right parenthesis count\\n\\nl - r < 0 means this is not a valid parenthesis",
                "codeTag": "Python3"
            },
            {
                "id": 10098,
                "title": "java-dfs-way-solution",
                "content": "    public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        generateOneByOne(\"\", list, n, n);\\n        return list;\\n    }\\n    public void generateOneByOne(String sublist, List<String> list, int left, int right){\\n        if(left > right){\\n            return;\\n        }\\n        if(left > 0){\\n            generateOneByOne( sublist + \"(\" , list, left-1, right);\\n        }\\n        if(right > 0){\\n            generateOneByOne( sublist + \")\" , list, left, right-1);\\n        }\\n        if(left == 0 && right == 0){\\n            list.add(sublist);\\n            return;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        generateOneByOne(\"\", list, n, n);\\n        return list;\\n    }\\n    public void generateOneByOne(String sublist, List<String> list, int left, int right){\\n        if(left > right){\\n            return;\\n        }\\n        if(left > 0){\\n            generateOneByOne( sublist + \"(\" , list, left-1, right);\\n        }\\n        if(right > 0){\\n            generateOneByOne( sublist + \")\" , list, left, right-1);\\n        }\\n        if(left == 0 && right == 0){\\n            list.add(sublist);\\n            return;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10388,
                "title": "python-easy-to-understand-dfs-solution",
                "content": "        \\n    def generateParenthesis(self, n):\\n        res = []\\n        self.dfs(n, n, \"\", res)\\n        return res\\n            \\n    def dfs(self, leftRemain, rightRemain, path, res):\\n        if leftRemain > rightRemain or leftRemain < 0 or rightRemain < 0:\\n            return  # backtracking\\n        if leftRemain == 0 and rightRemain == 0:\\n            res.append(path)\\n            return \\n        self.dfs(leftRemain-1, rightRemain, path+\"(\", res)\\n        self.dfs(leftRemain, rightRemain-1, path+\")\", res)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "        \\n    def generateParenthesis(self, n):\\n        res = []\\n        self.dfs(n, n, \"\", res)\\n        return res\\n            \\n    def dfs(self, leftRemain, rightRemain, path, res):\\n        if leftRemain > rightRemain or leftRemain < 0 or rightRemain < 0:\\n            return  # backtracking\\n        if leftRemain == 0 and rightRemain == 0:\\n            res.append(path)\\n            return \\n        self.dfs(leftRemain-1, rightRemain, path+\"(\", res)\\n        self.dfs(leftRemain, rightRemain-1, path+\")\", res)",
                "codeTag": "Python3"
            },
            {
                "id": 139455,
                "title": "clean-javascript-backtracking-solution",
                "content": "**Solution 1**\\n\\n```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => {\\n    if (s.length === 2 * n) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l < n) go(l + 1, r, s + \\'(\\');\\n    if (r < l) go(l, r + 1, s + \\')\\');\\n  };\\n\\n  go(0, 0, \\'\\');\\n  return res;\\n};\\n```\\n\\n**Solution 2**\\n\\n```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => { // l: left remaining, r: right remaining\\n    if (l > r) return; // Validate by the number of \\'(\\' should be always >= \\')\\'\\n\\n    if (l === 0 && r === 0) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l > 0) go(l - 1, r, s + \\'(\\');\\n    if (r > 0) go(l, r - 1, s + \\')\\');\\n  };\\n\\n  go(n, n, \\'\\');\\n  return res;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => {\\n    if (s.length === 2 * n) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l < n) go(l + 1, r, s + \\'(\\');\\n    if (r < l) go(l, r + 1, s + \\')\\');\\n  };\\n\\n  go(0, 0, \\'\\');\\n  return res;\\n};\\n```\n```js\\nconst generateParenthesis = (n) => {\\n  const res = [];\\n\\n  const go = (l, r, s) => { // l: left remaining, r: right remaining\\n    if (l > r) return; // Validate by the number of \\'(\\' should be always >= \\')\\'\\n\\n    if (l === 0 && r === 0) {\\n      res.push(s);\\n      return;\\n    }\\n\\n    if (l > 0) go(l - 1, r, s + \\'(\\');\\n    if (r > 0) go(l, r - 1, s + \\')\\');\\n  };\\n\\n  go(n, n, \\'\\');\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276079,
                "title": "python-backtracking-complexity-analysis-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Naive Backtracking**\\n```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = []\\n        \\n        def isValidParenthesis(s):\\n            cntOpen = 0\\n            for c in s:\\n                if c == \\'(\\':\\n                    cntOpen += 1\\n                else:\\n                    if cntOpen == 0: return False  # Don\\'t have enough open to match with this close parentheses\\n                    cntOpen -= 1\\n            return cntOpen == 0  #\\xA0Fully match all open parentheses\\n        \\n        def bt(i, path):\\n            if i == 2 * n:\\n                if isValidParenthesis(path):\\n                    ans.append(path)\\n                return\\n            \\n            bt(i+1, path + \"(\")  # Add open\\n            bt(i+1, path + \")\")  # Add close\\n            \\n        bt(0, \"\")\\n        return ans\\n```\\nComplexity:\\n- Time: `O(2^m * m)`, where `m = 2n`, `n <= 8`\\n- Space: `n-th` Catalan Number.\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Smart Backtracking**\\n```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        def backtracking(nOpen, nClose, path):\\n            if n == nClose:  # Found a valid n pairs of parentheses\\n                ans.append(path)\\n                return\\n\\n            if nOpen < n:  # Number of opening bracket up to `n`\\n                backtracking(nOpen + 1, nClose, path + \"(\")\\n            if nClose < nOpen:  # Number of closing bracket up to opening bracket\\n                backtracking(nOpen, nClose + 1, path + \")\")\\n\\n        ans = []\\n        backtracking(0, 0, \"\")\\n        return ans\\n```\\n**Complexity**\\n- Our complexity analysis based on how many elements there are in `generateParenthesis(n)`. \\n- This is the `n-th` [Catalan number](https://en.wikipedia.org/wiki/Catalan_number), where the first Catalan numbers for `n = 0, 1, 2, 3, ...` are `1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,...`\\n- Time & Space: `n-th` Catalan Number.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = []\\n        \\n        def isValidParenthesis(s):\\n            cntOpen = 0\\n            for c in s:\\n                if c == \\'(\\':\\n                    cntOpen += 1\\n                else:\\n                    if cntOpen == 0: return False  # Don\\'t have enough open to match with this close parentheses\\n                    cntOpen -= 1\\n            return cntOpen == 0  #\\xA0Fully match all open parentheses\\n        \\n        def bt(i, path):\\n            if i == 2 * n:\\n                if isValidParenthesis(path):\\n                    ans.append(path)\\n                return\\n            \\n            bt(i+1, path + \"(\")  # Add open\\n            bt(i+1, path + \")\")  # Add close\\n            \\n        bt(0, \"\")\\n        return ans\\n```\n```python\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        def backtracking(nOpen, nClose, path):\\n            if n == nClose:  # Found a valid n pairs of parentheses\\n                ans.append(path)\\n                return\\n\\n            if nOpen < n:  # Number of opening bracket up to `n`\\n                backtracking(nOpen + 1, nClose, path + \"(\")\\n            if nClose < nOpen:  # Number of closing bracket up to opening bracket\\n                backtracking(nOpen, nClose + 1, path + \")\")\\n\\n        ans = []\\n        backtracking(0, 0, \"\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10367,
                "title": "simple-2ms-c-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0);\\n        return result;\\n    }\\n\\n    /*  this hepler function insert result strings to \"vector<string> result\"\\n   \\t\\tWhen number of '(' less than \"n\", can append '(';\\n   \\t\\tWhen number of '(' is more than number of ')', can append ')';\\n\\n    \\tstring s : current string;\\n    \\tint leftpare_need : number of '(' that have not put into \"string s\";\\n    \\tint moreleft : number of '(' minus number of ')' in the \"string s\";\\n    */\\n\\n    void helper(string s, int leftpare_need, int moreleft)\\n    {\\n    \\tif(leftpare_need == 0 && moreleft == 0)\\n    \\t{\\n    \\t    result.push_back(s);\\n    \\t    return;\\n    \\t}\\n    \\tif(leftpare_need > 0)\\n    \\t\\thelper(s + \"(\", leftpare_need - 1, moreleft+1);\\n    \\tif(moreleft > 0)\\n    \\t\\thelper(s + \")\", leftpare_need, moreleft - 1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1561062,
                "title": "python3-recursive-approach-simple-logic-step-by-step-explanation",
                "content": "One thing we need to understand is, we need a way to add \\u201C(\\u201D and \\u201C)\\u201D to all possible cases and \\nthen find a way to validate so that we don\\u2019t generate the unnecessary ones.\\n\\nThe first condition is if there are more than 0 open / left brackets, we recurse with the right\\nones. And if we have more than 0 right brackets, we recurse with the left ones. Left and right\\nare initialized with` \\'n\\' `- the number given.\\n\\n\\n```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\\n\\n<br>\\n\\nThere\\u2019s a catch. We can\\u2019t add the \\u201C)\\u201D everytime we have `right>0` cause then it will not be\\nbalanced. We can balance that with a simple condition of `left<right.`\\n\\n```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\\n\\n<br>\\nSince this is a recursive approach we need to have a **BASE condition**,\\nand the base case is: \\n\\nWhen both right and left are 0, \\nwe have found one possible combination of parentheses \\n& we now need to append/add the `\\'s\\'` to `\\'ans\\'` list.\\n\\n```\\n\\t\\t\\tif left==0 and right==0:\\n                ans.append(s)\\n```\\n\\n<br>\\n<br>\\n\\n**Complete code**\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        \\n        def helper(ans, s, left, right):\\n            if left==0 and right==0:\\n                ans.append(s)\\n                \\n            if left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n        \\n        ans = []\\n        helper(ans, \\'\\', n, n)\\n        \\n        return ans\\n```\\n\\n\\n\\n<br>\\n<br>\\n*If this post seems to be helpful, please upvote!!*",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\n```\\n\\t\\t\\tif left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n```\n```\\n\\t\\t\\tif left==0 and right==0:\\n                ans.append(s)\\n```\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        \\n        def helper(ans, s, left, right):\\n            if left==0 and right==0:\\n                ans.append(s)\\n                \\n            if left>0:\\n                helper(ans, s+\\'(\\', left-1, right)\\n                \\n            if right>0 and left<right:\\n                helper(ans, s+\\')\\', left, right-1)\\n        \\n        ans = []\\n        helper(ans, \\'\\', n, n)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679907,
                "title": "easy-recursive-c-solution-clearly-explained",
                "content": "Hello all, \\n\\nBefore jumping to the code, go through the explanation. I have curated the explanation for your easy understanding. This will help you build a clear logic for many recursive problems moving forward.\\n\\nStep1: Identification of Problem\\nThe problem asks us to generate all the valid paranthesis sequences, the first thing that should come to mind is recursion. Hence recursion is the way forward.  \\n\\nStep2: Correctness of Solution\\nIt is really crucial to understand that the solution should be correct befire being optimized. \\n\\nStep3: Building Solution \\nWe start by maintaining a count for both the opening and closing paranthesis as\\n```\\n// count1 is used to flag the base case \\n// count2 is used to react to the base case \\ncount1=0 and count2=0 respectively.\\n\\n// following is the signature for the recursive function\\nsubseq(int count1,int count2,string v,vector<string> &ans,int n)\\n\\n// only the first three parameters are determining the state of each recursive call.\\n// vector<string> &ans   is passed with every recursive call to store the final valid strings\\n// int n   is used to check the base condition\\n```\\n\\nStep 4: Logic\\n\\n* A Valid sequence will include the closing paranthesis only when there are more opening paranthesis. Hence, the condition\\n```\\nif(count2<count1){\\n\\tsubseq(count1,count2+1,v+\")\",ans,n);    \\n}\\n```\\n* An opening paranthesis is always open to be the part of a valid paranthesis till it has a count less than n. \\n* As soon as the count of opening paranthesis reaches n, we push all the remaining closing paranthesis into the sequence, because there are no more opening paranthesis to add.\\n\\nStep5: Code\\n```\\nvoid subseq(int count1,int count2,string v,vector<string> &ans,int n){\\n        if(count1==n){\\n            // if there are n open \\'(\\', we simply push the rest closing \\')\\'\\n            while(count2<n){\\n                v+=\")\";\\n                count2+=1;\\n            }\\n\\t\\t\\t// v is pushed to the answer vector\\n\\t\\t\\t\\n            ans.push_back(v);\\n            return;\\n        }\\n\\t\\t\\n        subseq(count1+1,count2,v+\"(\",ans,n);\\n\\t\\t\\n        if(count2<count1){\\n            subseq(count1,count2+1,v+\")\",ans,n);    \\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string v;\\n        subseq(0,0,v,ans,n);\\n\\n        return ans;\\n    }\\n```\\n\\n**Please upvote, if the solution was of help to you. This will help other people in the community optimize their search for the best solution.**\\n\\nCheers!!\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// count1 is used to flag the base case \\n// count2 is used to react to the base case \\ncount1=0 and count2=0 respectively.\\n\\n// following is the signature for the recursive function\\nsubseq(int count1,int count2,string v,vector<string> &ans,int n)\\n\\n// only the first three parameters are determining the state of each recursive call.\\n// vector<string> &ans   is passed with every recursive call to store the final valid strings\\n// int n   is used to check the base condition\\n```\n```\\nif(count2<count1){\\n\\tsubseq(count1,count2+1,v+\")\",ans,n);    \\n}\\n```\n```\\nvoid subseq(int count1,int count2,string v,vector<string> &ans,int n){\\n        if(count1==n){\\n            // if there are n open \\'(\\', we simply push the rest closing \\')\\'\\n            while(count2<n){\\n                v+=\")\";\\n                count2+=1;\\n            }\\n\\t\\t\\t// v is pushed to the answer vector\\n\\t\\t\\t\\n            ans.push_back(v);\\n            return;\\n        }\\n\\t\\t\\n        subseq(count1+1,count2,v+\"(\",ans,n);\\n\\t\\t\\n        if(count2<count1){\\n            subseq(count1,count2+1,v+\")\",ans,n);    \\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string v;\\n        subseq(0,0,v,ans,n);\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594770,
                "title": "c-2-solutions-backtracking-and-dp",
                "content": "**Solution One**\\n\\nGiven a number n, we have to generate all valid `n` pairs of parenthesis. Since we have to generate all the valid combinations, the first solution which comes to our mind is backtracking (recursion). Given the constraint, I would say that is the best solution. \\n\\nWe start with number of open brackets `open = 0`, and number of close brackets `close = 0`. Now at any given recursion level, either we can put one open bracket or one close bracket. The constraints would be that `open can never be greater than n` and that `close < open` at all times. Below code is self explanatory. **Note I used string references to obtain a gain in speed**.\\n\\n```\\nclass Solution {\\npublic:\\n    void util(vector<string>& res, int open, int close, string& tmp, int n)\\n    {\\n        if(tmp.length()==2*n) {res.push_back(tmp); return;}\\n        if(open<n){\\n            tmp.push_back(\\'(\\');\\n            util(res,open+1,close,tmp,n);\\n            tmp.pop_back();\\n        }\\n        if(close<open){\\n            tmp.push_back(\\')\\');\\n            util(res,open,close+1,tmp,n);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open=0,close=0; // open -> number of open brackets\\n\\t\\t\\t\\t\\t\\t // close -> number of close brackets\\n        vector<string> res;\\n        if(n==0) return res;\\n        string temp=\"\";\\n        util(res,open,close,temp,n);\\n        return res;\\n    }\\n};\\n```\\n\\n*Time Complexity* - Very important for these kind of questions. Since recursion is a tree, and here there are two recursive calls possible at any level. Heigh of the tree will be `2*n`, since we are generating `2*n` number of brackets. So, **worst-case Time Complexity will be** ```O(2^(2n))```.\\n\\n*Space Complexity* - `O(2*n)` (Stack space after using recursion)\\n\\n**Solution Two**\\n\\nNow, given the constraints in the problem, backtracking is good. But what if, `n` is large. We can\\'t afford exponential solution. The next thought should be dynamic programming, and if there is a overlapping subproblems nature to it.\\n\\nSuppose `dp[i]` contains all the valid parentheses possible of length `2*i`. Suppose you got `dp[2]` which is `{ (()) , ()() }`. Now what will be `dp[3]`? It can be written as -\\n\\n`(` + dp[0] + `)` + dp[2] = `()(())` and `()()()`\\n`(` + dp[1] + `)` + dp[1] = `(())()`\\n`(` + dp[2] + `)` + dp[0] = `((()))` and `(()())`\\n\\nSo you see, we have an overlapping subproblems structure. It\\'s good to know here that this structure closely follows `Catalan Numbers`. (You can find the number of valid parentheses using Catalan Numbers).\\n\\n`dp[i] = \"(\" + dp[j] + \")\" + dp[i-j-1]`   (Recursive relation. Similar to a binary tree generation).\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n        vector<vector<string>> dp(n+1); // cache to store all generated strings\\n        dp[0] = {\"\"}; \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string> left = dp[j];\\n                vector<string> right = dp[i-j-1];\\n                for(int k=0;k<left.size();k++){\\n                    for(int l=0;l<right.size();l++){\\n                        dp[i].push_back(\"(\" + left[k] + \")\" + right[l]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n\\n*Time Complexity* - `O(n^4)`.\\n*Space Complexity* - `O(n)`.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void util(vector<string>& res, int open, int close, string& tmp, int n)\\n    {\\n        if(tmp.length()==2*n) {res.push_back(tmp); return;}\\n        if(open<n){\\n            tmp.push_back(\\'(\\');\\n            util(res,open+1,close,tmp,n);\\n            tmp.pop_back();\\n        }\\n        if(close<open){\\n            tmp.push_back(\\')\\');\\n            util(res,open,close+1,tmp,n);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open=0,close=0; // open -> number of open brackets\\n\\t\\t\\t\\t\\t\\t // close -> number of close brackets\\n        vector<string> res;\\n        if(n==0) return res;\\n        string temp=\"\";\\n        util(res,open,close,temp,n);\\n        return res;\\n    }\\n};\\n```\n```O(2^(2n))```\n```\\nvector<string> generateParenthesis(int n) {\\n        vector<vector<string>> dp(n+1); // cache to store all generated strings\\n        dp[0] = {\"\"}; \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string> left = dp[j];\\n                vector<string> right = dp[i-j-1];\\n                for(int k=0;k<left.size();k++){\\n                    for(int l=0;l<right.size();l++){\\n                        dp[i].push_back(\"(\" + left[k] + \")\" + right[l]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276579,
                "title": "short-easy-solution-w-explanation-beats-100",
                "content": "\\u2714\\uFE0F ***Solution - I (Brute - Force)***\\n\\nWe have `n` pair of parenthesis which means we are required to form a valid parenthesis string of `length == 2*n`. Let\\'s start with the brute-force way. At each position of the string, we can insert **`(`** or **`)`** brackets and so we will try both the options. Atlast, when the length of string becomes `2*n`, we will perform a check and insert into `ans` array if it is valid.\\n\\n```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup> * n)</code>**, for each index in string, we try both the parenthesis which is <code>2`*`2`*`2...2n times = O(2<sup>2n</sup>) = O(4<sup>n</sup>) </code> and lastly, we spend an `O(n)` time to check for the formed string\\'s validity. \\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>** (A tighter bound exists)\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Approach)***\\n\\nInstead of trying out both the brackets at each index of the string, we only try them at places which won\\'t outright invalidate the string. For eg. In the previous approach, we were trying to insert `)` even at the start which would surely not have generated a valid parenthesis. Here, we avoid that. We have 2 cases:\\n\\n* **`(`** can be inserted anywhere till its count is less than `n`\\n* **`)`** can be inserted whenever its count is less than `start` (number of openinig parenthesis)\\n\\nFinally, we will insert the string when its length reaches `2*n`.\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup>)</code>** Here we save the time for string validation at the end and also avoid the extra recursive calls which we know are invalid anyway. \\n**Note**: There exists a tighter bound - <code>O(4<sup>n</sup> / &radic;n)</code>  but without deep analysis of the recursion structure, it\\'s very hard to arrive at it. So, <code>O(4<sup>n</sup>)</code> is good enough for quick estimations\\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>**, Tighter bound - **<code>O(4<sup>n</sup> / &radic;n)</code>**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/001e3d19-b69f-4c1b-96c9-f760343aef54_1623844459.7738905.png  /></td></tr></table>\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909785,
                "title": "beats-100-this-is-how-you-explain-it-to-your-interviewer",
                "content": "UPVOTE IT TO KEEP IT AT THE TOP!\\n\\n# Intuition\\nThis code aims to generate all valid combinations of balanced parentheses pairs given a positive integer n. The goal is to produce all possible strings of length 2*n, where each character is either \\'(\\' or \\')\\', and the resulting strings are valid parentheses expressions.\\n\\n# Approach\\nThe code uses a recursive approach to generate these combinations. The solve function is called recursively to build the strings while maintaining the count of open and closed parentheses. Here\\'s how it works:\\n\\nThe base case is when the index ind reaches or exceeds n * 2. At this point, the constructed string op is a valid combination of parentheses, so it\\'s added to the result vector ans.\\n\\nIf the count of open parentheses cnt1 is less than n and the current index ind is less than n * 2 - 1, a \\'(\\' character is added to the string op, and the solve function is called recursively with cnt1 incremented by 1 and the index increased by 1.\\n\\nIf the count of closed parentheses cnt2 is less than cnt1 and the current index ind is greater than 0, a \\')\\' character is added to the string op, and the solve function is called recursively with cnt2 incremented by 1 and the index increased by 1.\\n\\nAfter each recursive call, the last character is removed from the string op using op.pop_back() to backtrack and explore different combinations.\\n\\nThe generateParenthesis function initializes the result vector ans and calls the solve function with initial counts and index.\\n\\n# Complexity\\n- Time complexity: O(4^n / sqrt(n))\\nTime complexity: The recursive approach explores all possible combinations, and the total number of valid combinations is bounded by the nth Catalan number, which grows exponentially with n. Thus, the time complexity is exponential, approximately O(4^n / sqrt(n)).\\n\\n- Space complexity:  O(n)\\nSpace complexity: The space complexity is determined by the maximum recursion depth, which is proportional to n. Additionally, the space used by the string op in each recursive call contributes to the space complexity. Therefore, the space complexity is O(n) due to the recursion depth.\\n\\n\\n![5d0bae9a5411b.jpeg](https://assets.leetcode.com/users/images/7a8eeaa3-6860-49ad-a76b-c322ca710c63_1692032658.6172345.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    void solve(int cnt1,int cnt2,int n,vector<string> &ans,string &op,int ind)\\n    {\\n        if(ind>=n*2)\\n        {\\n            ans.push_back(op);\\n            return;}\\n        if(cnt1<n and ind<n*2-1)\\n        {\\n            op+=\\'(\\';\\n            solve(cnt1+1,cnt2,n,ans,op,ind+1);\\n            op.pop_back();\\n        }\\n        \\n        if(cnt2<cnt1 and ind>0)\\n        {\\n            op+=\\')\\';\\n \\n            solve(cnt1,cnt2+1,n,ans,op,ind+1);\\n            op.pop_back();\\n        }\\n        \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n         string op=\"\";\\n        vector<string> ans;\\n        solve(0,0,n,ans,op,0);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private:\\n    void solve(int cnt1,int cnt2,int n,vector<string> &ans,string &op,int ind)\\n    {\\n        if(ind>=n*2)\\n        {\\n            ans.push_back(op);\\n            return;}",
                "codeTag": "Java"
            },
            {
                "id": 10337,
                "title": "my-accepted-java-solution",
                "content": "For 2, it should place one \"()\" and add another one insert it but none tail it,\\n\\n'(' f(1) ')' f(0)\\n\\nor add none insert it but tail it by another one,\\n\\n'(' f(0) ')' f(1)\\n\\nThus for n,  we can insert f(i) and tail f(j) and i+j=n-1,\\n\\n'(' f(i) ')' f(j)              \\n\\n\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tresult.add(\"\");\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\t\\tList<String> insertSub = generateParenthesis(i);\\n\\t\\t\\t\\tList<String> tailSub = generateParenthesis(n - 1 - i);\\n\\t\\t\\t\\tfor (String insert : insertSub) {\\n\\t\\t\\t\\t\\tfor (String tail : tailSub) {\\n\\t\\t\\t\\t\\t\\tresult.add(\"(\" + insert + \")\" + tail);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "For 2, it should place one \"()\" and add another one insert it but none tail it,\\n\\n'(' f(1) ')' f(0)\\n\\nor add none insert it but tail it by another one,\\n\\n'(' f(0) ')' f(1)\\n\\nThus for n,  we can insert f(i) and tail f(j) and i+j=n-1,\\n\\n'(' f(i) ')' f(j)              \\n\\n\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tresult.add(\"\");\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\t\\tList<String> insertSub = generateParenthesis(i);\\n\\t\\t\\t\\tList<String> tailSub = generateParenthesis(n - 1 - i);\\n\\t\\t\\t\\tfor (String insert : insertSub) {\\n\\t\\t\\t\\t\\tfor (String tail : tailSub) {\\n\\t\\t\\t\\t\\t\\tresult.add(\"(\" + insert + \")\" + tail);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 313945,
                "title": "recursion-with-backtracking",
                "content": "The key to this problem is writing a recursive function that operates in a manner similar to how we would generate all valid pairs by hand.\\n\\nAt every step of the way, we choose to add either an open bracket or a close bracket. This can easily be implemented as part of the recursive call. The trick is to also implement the restraint, namely \\'dont add a close bracket if there isnt already an open bracket\\'. AKA: only add if right > left. The restraint for adding open brackets is simple, add one if there are still open brackets to be added.\\n\\nFollowing this logic allows us to only generate valid strings, and we are done generating a particular string when we dont have any more brackets left ot add.\\n\\nParameters:\\n\\t(int) left:       set to n, keep track of open brackets that need to be added\\n\\t(int) right:     set to n, keep track of close brackets that need to be add\\n\\t(str) curr:     set to \"\", used to store the current version of the string\\n\\t(dict()) res:  hold all valid strings, is returned by the function\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \\n\\t\\tdef paren(left, right, curr, res):\\n\\t\\t\\t# \\'evaluate current string\\n\\t\\t\\t# if we are out of brackets to add, we must be at a valid string\\n\\t\\t\\tif left == 0 and right == 0:\\n\\t\\t\\t\\tres.append(curr)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# recursive call: add either open or close\\n\\t\\t\\t# if adding open bracket is valid\\n\\t\\t\\tif left > 0:\\n\\t\\t\\t\\t# add open bracket, decr count\\n\\t\\t\\t\\tparen(left-1, right, curr + \"(\", res)\\n\\n\\t\\t\\t# if adding close bracket is valid\\n\\t\\t\\tif right > left:\\n\\t\\t\\t\\t# add close bracket, decr count\\n\\t\\t\\t\\tparen(left, right-1, curr + \")\", res)\\n\\n\\t\\t\\treturn res\\n\\t\\t# end paren()\\n\\n\\t\\tres = paren(n, n, \\'\\', [])\\n\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \\n\\t\\tdef paren(left, right, curr, res):\\n\\t\\t\\t# \\'evaluate current string\\n\\t\\t\\t# if we are out of brackets to add, we must be at a valid string\\n\\t\\t\\tif left == 0 and right == 0:\\n\\t\\t\\t\\tres.append(curr)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# recursive call: add either open or close\\n\\t\\t\\t# if adding open bracket is valid\\n\\t\\t\\tif left > 0:\\n\\t\\t\\t\\t# add open bracket, decr count\\n\\t\\t\\t\\tparen(left-1, right, curr + \"(\", res)\\n\\n\\t\\t\\t# if adding close bracket is valid\\n\\t\\t\\tif right > left:\\n\\t\\t\\t\\t# add close bracket, decr count\\n\\t\\t\\t\\tparen(left, right-1, curr + \")\", res)\\n\\n\\t\\t\\treturn res\\n\\t\\t# end paren()\\n\\n\\t\\tres = paren(n, n, \\'\\', [])\\n\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10299,
                "title": "c-recursive-iterative",
                "content": "**Recursive (backtracking)**\\n\\nWe use `l` and `r` to denote the number of `(`s and `)`s. If `l < n`, we can add a `(`. If `r < l`, we can add a `)`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parens;\\n        string paren;\\n        generate(n, 0, 0, paren, parens);\\n        return parens;\\n    }\\nprivate:\\n    void generate(int n, int l, int r, string paren, vector<string>& parens) {\\n        if (l == n && r == n) {\\n            parens.push_back(paren);\\n        } else {\\n            if (l < n) {\\n                generate(n, l + 1, r, paren + \\'(\\', parens);\\n            }\\n            if (r < l) {\\n                generate(n, l, r + 1, paren + \\')\\', parens);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Iterative**\\n\\nThis idea is taken from the official solution.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (!n) {\\n            return {\"\"};\\n        }\\n        vector<string> parens;\\n        for (int i = 0; i < n; i++) {\\n            for (string l : generateParenthesis(i)) {\\n                for (string r : generateParenthesis(n - 1 - i)) {\\n                    parens.push_back(\\'(\\' + l + \\')\\' + r);\\n                }\\n            }\\n        }\\n        return parens;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parens;\\n        string paren;\\n        generate(n, 0, 0, paren, parens);\\n        return parens;\\n    }\\nprivate:\\n    void generate(int n, int l, int r, string paren, vector<string>& parens) {\\n        if (l == n && r == n) {\\n            parens.push_back(paren);\\n        } else {\\n            if (l < n) {\\n                generate(n, l + 1, r, paren + \\'(\\', parens);\\n            }\\n            if (r < l) {\\n                generate(n, l, r + 1, paren + \\')\\', parens);\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (!n) {\\n            return {\"\"};\\n        }\\n        vector<string> parens;\\n        for (int i = 0; i < n; i++) {\\n            for (string l : generateParenthesis(i)) {\\n                for (string r : generateParenthesis(n - 1 - i)) {\\n                    parens.push_back(\\'(\\' + l + \\')\\' + r);\\n                }\\n            }\\n        }\\n        return parens;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936271,
                "title": "simple-java-sol",
                "content": "\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList();\\n        findAll(\"(\",1,0,res,n);\\n\\n        return res;\\n    }\\n\\n    void findAll(String current,int op , int cl , List<String> res, int n){\\n        if(current.length()==2*n){\\n            res.add(current);\\n            return;\\n        }\\n        if(op<n)\\n        findAll(current+\"(\", op+1,cl,res,n);\\n        if(cl<op)\\n        findAll(current+\")\",op,cl+1,res,n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList();\\n        findAll(\"(\",1,0,res,n);\\n\\n        return res;\\n    }\\n\\n    void findAll(String current,int op , int cl , List<String> res, int n){\\n        if(current.length()==2*n){\\n            res.add(current);\\n            return;\\n        }\\n        if(op<n)\\n        findAll(current+\"(\", op+1,cl,res,n);\\n        if(cl<op)\\n        findAll(current+\")\",op,cl+1,res,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370756,
                "title": "accepted-c-whiteboard-recursion-tree-easy-please-upvote",
                "content": "**Whiteboard Recursion Tree**\\nHere n = 3\\n* Star marks the string to be pushed in ans vector\\n* When open < close, only then we go further\\n* If open == 0 stop there, as opening parenthesis are exhausted\\n* If open < close, it means some of open are used so only now we can close\\n* If open == close == 0 then no more parenthesis left so add the string to ans vector and return\\n\\n![image](https://assets.leetcode.com/users/images/c33fedf4-ccdd-4ae6-a830-2c18943d1cb4_1627579698.6112955.jpeg)\\n\\nPardon my drawing \\uD83D\\uDE02\\uD83D\\uDE02\\nSuggestions are welcomed. \\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        f(\"\",n,n);\\n        return ans;\\n    }\\n    void f(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        f(\"\",n,n);\\n        return ans;\\n    }\\n    void f(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10400,
                "title": "6-lines-c-3-4-ms-super-easy-to-understand",
                "content": "    vector<string> result;\\n    \\n    void helper(string str, int left, int right){\\n        if(left == 0 && right == 0)  result.push_back(str);\\n        if(left!=0)                  helper(str+'(', left-1, right);\\n        if(right!=0 && right > left) helper(str+')', left, right-1);\\n    }    \\n    \\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\",n,n);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> result;\\n    \\n    void helper(string str, int left, int right){\\n        if(left == 0 && right == 0)  result.push_back(str);\\n        if(left!=0)                  helper(str+'(', left-1, right);\\n        if(right!=0 && right > left) helper(str+')', left, right-1);\\n    }    \\n    \\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\",n,n);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1276049,
                "title": "python-recursive-solution-with-dp-explained",
                "content": "For each valid parentheses there smallest `k`, for which the first `k` symbols compose well-formed parentheses: `(left)right`. Let us `ans[i]` be all valid parentheses of length `i`. Then we can generate them using recursion. For every `k in range(n+1)` and for every `i in range(k)` we choose left part and right part and append it to final answer. Because we memorize our intermediate results, we can also say that we use dp approach here.\\n\\n#### Complexity\\nTime complexity is `O(C_n * n) = O(4^n/n^0.5)`, where `C_n` is Catalan number. Space complexity is the same.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        ans = [[] for _ in range(n+1)]\\n        ans[0] = [\"\"]\\n        for k in range(n + 1):\\n            for i in range(k):\\n                for left in ans[i]:\\n                    for right in ans[k-i-1]:\\n                        ans[k].append(\"(\" + left + \")\" + right)\\n        \\n        return ans[-1]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        ans = [[] for _ in range(n+1)]\\n        ans[0] = [\"\"]\\n        for k in range(n + 1):\\n            for i in range(k):\\n                for left in ans[i]:\\n                    for right in ans[k-i-1]:\\n                        ans[k].append(\"(\" + left + \")\" + right)\\n        \\n        return ans[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10136,
                "title": "easy-java-solution",
                "content": "    public class Solution {\\n    private void helper(List<String> res, String present, int left, int right) {\\n        if (right == 0) {\\n            res.add(present);\\n        }\\n        if (left > 0) {\\n            helper(res, present + \"(\", left - 1, right);\\n        }\\n        if (right > left) {\\n            helper(res, present + \")\", left, right - 1);\\n        }\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        if (n == 0) {\\n            return res;\\n        }\\n        helper(res, \"\", n, n);\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private void helper(List<String> res, String present, int left, int right) {\\n        if (right == 0) {\\n            res.add(present);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3211825,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O((2^2*N)*N). For each of 2^2*N sequences, we need to create and validate the sequence,\\n    which takes O(N) work.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool valid(vector<char> temp){\\n        int balance = 0;\\n        for(auto c : temp){\\n            if(c == \\'(\\') balance++;\\n            else balance--;\\n            if(balance < 0) return false;\\n        }\\n        return balance == 0;\\n    }\\n    void generateAllParenthesis(vector<string>& parenthesesCombinations, vector<char> temp, int position){\\n        if(position == temp.size()){\\n            if(valid(temp)){\\n                string s(temp.begin(), temp.end());\\n                parenthesesCombinations.push_back(s);\\n            }\\n            return;\\n        }\\n        temp[position] = \\'(\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1);\\n        temp[position] = \\')\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1); \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parenthesesCombinations;\\n        vector<char> temp(2*n);\\n        generateAllParenthesis(parenthesesCombinations, temp, 0);\\n        return parenthesesCombinations;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(O(2^2*N)The time complexity of the above code is O(2^(2N)) since in the worst case we\\n    need to consider every possibility of opening and closing brackets where N = the number of pairs we need to\\n    form.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    void recurse(vector<string>& output, string s, int open, int close, int n){\\n        if(open==n and close==n){\\n            output.push_back(s);\\n            return;\\n        }\\n        if(open<n)\\n            recurse(output, s+\"(\" , open+1, close, n);\\n        if(close<open)\\n            recurse(output, s+\")\", open, close+1, n);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> output;\\n        recurse(output, \"\", 0, 0, n);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O((2^2*N)*N). For each of 2^2*N sequences, we need to create and validate the sequence,\\n    which takes O(N) work.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool valid(vector<char> temp){\\n        int balance = 0;\\n        for(auto c : temp){\\n            if(c == \\'(\\') balance++;\\n            else balance--;\\n            if(balance < 0) return false;\\n        }\\n        return balance == 0;\\n    }\\n    void generateAllParenthesis(vector<string>& parenthesesCombinations, vector<char> temp, int position){\\n        if(position == temp.size()){\\n            if(valid(temp)){\\n                string s(temp.begin(), temp.end());\\n                parenthesesCombinations.push_back(s);\\n            }\\n            return;\\n        }\\n        temp[position] = \\'(\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1);\\n        temp[position] = \\')\\';\\n        generateAllParenthesis(parenthesesCombinations, temp, position+1); \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> parenthesesCombinations;\\n        vector<char> temp(2*n);\\n        generateAllParenthesis(parenthesesCombinations, temp, 0);\\n        return parenthesesCombinations;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(O(2^2*N)The time complexity of the above code is O(2^(2N)) since in the worst case we\\n    need to consider every possibility of opening and closing brackets where N = the number of pairs we need to\\n    form.\\n\\n    Space Complexity : O((2^2*N)*N) vector(output) space.\\n\\n    Solved using Array + Backtracking. Brute Force Approach.\\n\\n*/\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    void recurse(vector<string>& output, string s, int open, int close, int n){\\n        if(open==n and close==n){\\n            output.push_back(s);\\n            return;\\n        }\\n        if(open<n)\\n            recurse(output, s+\"(\" , open+1, close, n);\\n        if(close<open)\\n            recurse(output, s+\")\", open, close+1, n);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> output;\\n        recurse(output, \"\", 0, 0, n);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193155,
                "title": "python3-dp-solution-with-explanation-36-ms-beat-99-96",
                "content": "It\\'s intuitive to find the common subproblems, so dp is a natural choice.\\n\\ntwo base cases: \\nif n = 1, result = [\\'()\\']\\nif n = 2, result = [\\'(())\\', \\'()()\\']\\n\\nif n = 3, result = [\\n  \"((()))\",  # pattern: result of dp[2] is around by an outer \\'()\\'\\n  \"(()())\",  # the same pattern as above\\n  \"(())()\",  # pattern: result of dp[2] + result of dp[1]\\n  \"()(())\",  # the same pattern as above with another permutation order: dp[1] + dp[2]\\n  \"()()()\"  #  the same pattern as above\\n]\\n\\nwe can found the same recursive patterns for n > 3:\\n**pattern 1**: candidates = \\'(\\' + x + \\')\\' , where x is element of dp[n-1]\\n**pattern 2**: candidates = [x + y] , where x is element of dp[i] and y is element of dp[n-i] (the range of i is [0 : n])\\n\\n\\n```\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n                \\n        # 1 and 2 is base cases (set is used to deduplicate candidates)\\n        dp = {1: set([\\'()\\']), 2: set([\\'(())\\', \\'()()\\'])}\\n        for i in range(3, n+1):\\n            # pattern 1: outer parenthese + subproblem with length - 1\\n            dp[i] = set([\\'(\\' + x + \\')\\' for x in dp[i-1]])\\n            for j in range(1, i):\\n                # pattern 2: dp[i] is formed by dp[j] + dp[i-j]\\n                dp[i] = dp[i].union([x + y for x in dp[j] for y in dp[i-j]])\\n        return list(dp[n])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n                \\n        # 1 and 2 is base cases (set is used to deduplicate candidates)\\n        dp = {1: set([\\'()\\']), 2: set([\\'(())\\', \\'()()\\'])}\\n        for i in range(3, n+1):\\n            # pattern 1: outer parenthese + subproblem with length - 1\\n            dp[i] = set([\\'(\\' + x + \\')\\' for x in dp[i-1]])\\n            for j in range(1, i):\\n                # pattern 2: dp[i] is formed by dp[j] + dp[i-j]\\n                dp[i] = dp[i].union([x + y for x in dp[j] for y in dp[i-j]])\\n        return list(dp[n])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656798,
                "title": "solution-swift-generate-parentheses-test-cases",
                "content": "```swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        guard n > 0 else { return [\"\"] }\\n        \\n        var map: [Int:[String]] = [:], result: [String] = []\\n        if let parentheses = map[n] { return parentheses }\\n        \\n        for i in 0..<n {\\n            for l in generateParenthesis(i) {\\n                for r in generateParenthesis(n - 1 - i) {\\n                    result.append(\"(\" + l + \")\" + r)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.009 (0.011) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateParenthesis(3)\\n        XCTAssertEqual(value, [\"()()()\",\"()(())\",\"(())()\",\"(()())\",\"((()))\"])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateParenthesis(1)\\n        XCTAssertEqual(value, [\"()\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        guard n > 0 else { return [\"\"] }\\n        \\n        var map: [Int:[String]] = [:], result: [String] = []\\n        if let parentheses = map[n] { return parentheses }\\n        \\n        for i in 0..<n {\\n            for l in generateParenthesis(i) {\\n                for r in generateParenthesis(n - 1 - i) {\\n                    result.append(\"(\" + l + \")\" + r)\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.generateParenthesis(3)\\n        XCTAssertEqual(value, [\"()()()\",\"()(())\",\"(())()\",\"(()())\",\"((()))\"])\\n    }\\n    \\n    func test1() {\\n        let value = solution.generateParenthesis(1)\\n        XCTAssertEqual(value, [\"()\"])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617936,
                "title": "intuitive-javascript-solution-with-bracktracking",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n  const output = [];\\n  /**\\n   * Examples \\n   * n = 1\\n   *  ()\\n   *\\n   *  n = 2\\n   *  (())\\n   *  ()()\\n   *\\n   *  n = 3\\n   *  ((()))\\n   *  (()())\\n   *  (())()\\n   *  ()(())\\n   *  ()()()\\n   */\\n  const dfs = (str, open, close) => {\\n    // Close parentheses can not be more than open parentheses at any \\n    // given time to stay valid.\\n    if (open > close) {\\n      return;\\n    }\\n    // Base case. We now have n pairs of parentheses\\n    if (open === 0 && close === 0) {\\n      output.push(str);\\n      return;\\n    }\\n    // Insert open parenthsis and search for the next valid insertion.\\n    if (open > 0) {\\n      dfs(`${str}(`, open - 1, close);\\n    }\\n    // Insert close parenthsis and search for the next valid insertion.\\n    if (close > 0) {\\n      dfs(`${str})`, open, close - 1);\\n    }\\n  };\\n  dfs(\\'\\', n, n);\\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n  const output = [];\\n  /**\\n   * Examples \\n   * n = 1\\n   *  ()\\n   *\\n   *  n = 2\\n   *  (())\\n   *  ()()\\n   *\\n   *  n = 3\\n   *  ((()))\\n   *  (()())\\n   *  (())()\\n   *  ()(())\\n   *  ()()()\\n   */\\n  const dfs = (str, open, close) => {\\n    // Close parentheses can not be more than open parentheses at any \\n    // given time to stay valid.\\n    if (open > close) {\\n      return;\\n    }\\n    // Base case. We now have n pairs of parentheses\\n    if (open === 0 && close === 0) {\\n      output.push(str);\\n      return;\\n    }\\n    // Insert open parenthsis and search for the next valid insertion.\\n    if (open > 0) {\\n      dfs(`${str}(`, open - 1, close);\\n    }\\n    // Insert close parenthsis and search for the next valid insertion.\\n    if (close > 0) {\\n      dfs(`${str})`, open, close - 1);\\n    }\\n  };\\n  dfs(\\'\\', n, n);\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338278,
                "title": "c-easy-to-understand-fast-and-efficient-recursion",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        helper(ans,\"\",n,0);\\n        return ans;\\n    }\\n    void helper(vector<string> &v,string s,int n,int m)\\n    {\\n     if(n==0&&m==0)\\n     {\\n      v.push_back(s);\\n      return;\\n     }\\n      if(n>0)\\n      helper(v,s+\"(\",n-1,m+1);\\n      if(m>0)\\n       helper(v,s+\")\",n,m-1);   \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        helper(ans,\"\",n,0);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 10269,
                "title": "2ms-ac-java-solution-using-recursive-call",
                "content": "    public class Solution {\\n        public List<String> generateParenthesis(int n) {\\n            ArrayList<String> m=new ArrayList<>();\\n            generate(m, \"\", n, n);\\n            return m;\\n        }\\n        public void generate(ArrayList m, String s, int l, int r){\\n            if(l==0 && r==0){ \\n                m.add(s);\\n                return;\\n            }\\n            if(l>0) generate(m, s+\"(\",  l-1,  r);\\n            if(r>l) generate(m, s+\")\",  l,  r-1);\\n        }\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> generateParenthesis(int n) {\\n            ArrayList<String> m=new ArrayList<>();\\n            generate(m, \"\", n, n);\\n            return m;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3512769,
                "title": "c-java-python-javascript-using-recursion-with-explanation",
                "content": "# Intuition:\\nThe problem requires generating all possible combinations of well-formed parentheses of length 2n. To solve this, we can use a recursive approach. At each step, we have two choices: either add an opening parenthesis \"(\" or add a closing parenthesis \")\". However, we need to make sure that the number of opening parentheses is always greater than or equal to the number of closing parentheses, so that the parentheses remain well-formed.\\n\\n# Approach:\\n1. We define a helper function, `generateParentheses`, that takes the following parameters:\\n   - `result`: a reference to the vector of strings where we store the generated combinations.\\n   - `current`: the current combination being generated.\\n   - `open`: the count of opening parentheses \"(\" included in the current combination.\\n   - `close`: the count of closing parentheses \")\" included in the current combination.\\n   - `n`: the total number of pairs of parentheses to be included.\\n\\n2. In the `generateParentheses` function, we first check if the length of the `current` string is equal to 2n. If it is, we have generated a valid combination, so we add it to the `result` vector and return.\\n\\n3. If the length of `current` is not equal to 2n, we have two choices:\\n   - If the count of opening parentheses `open` is less than n, we can add an opening parenthesis to the current combination and make a recursive call to `generateParentheses`, incrementing the `open` count by 1.\\n   - If the count of closing parentheses `close` is less than the `open` count, we can add a closing parenthesis to the current combination and make a recursive call to `generateParentheses`, incrementing the `close` count by 1.\\n\\n4. In the `generateParenthesis` function, we initialize an empty `result` vector and call the `generateParentheses` function with the initial values of `current` as an empty string, `open` and `close` counts as 0, and `n` as the input value.\\n\\n5. Finally, we return the `result` vector containing all the generated combinations of well-formed parentheses.\\n\\n# Complexity:\\nThe time complexity of this solution is O(4^n / sqrt(n)), where n is the input number of pairs of parentheses.\\nThe space complexity of this solution is O(n). \\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    void generateParentheses(vector<string>& result, string current, int open, int close, int n) {\\n        if (current.size() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n};\\n```\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n\\n    private void generateParentheses(List<String> result, String current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.add(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.generateParentheses(result, \"\", 0, 0, n)\\n        return result\\n\\n    def generateParentheses(self, result, current, open, close, n):\\n        if len(current) == 2 * n:\\n            result.append(current)\\n            return\\n        if open < n:\\n            self.generateParentheses(result, current + \\'(\\', open + 1, close, n)\\n        if close < open:\\n            self.generateParentheses(result, current + \\')\\', open, close + 1, n)\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar generateParenthesis = function(n) {\\n  const result = [];\\n  generateParentheses(result, \\'\\', 0, 0, n);\\n  return result;\\n};\\n\\nconst generateParentheses = (result, current, open, close, n) => {\\n  if (current.length === 2 * n) {\\n    result.push(current);\\n    return;\\n  }\\n  if (open < n) {\\n    generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n  }\\n  if (close < open) {\\n    generateParentheses(result, current + \\')\\', open, close + 1, n);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateParentheses(vector<string>& result, string current, int open, int close, int n) {\\n        if (current.size() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        generateParentheses(result, \"\", 0, 0, n);\\n        return result;\\n    }\\n\\n    private void generateParentheses(List<String> result, String current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.add(current);\\n            return;\\n        }\\n        if (open < n) {\\n            generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n        }\\n        if (close < open) {\\n            generateParentheses(result, current + \\')\\', open, close + 1, n);\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.generateParentheses(result, \"\", 0, 0, n)\\n        return result\\n\\n    def generateParentheses(self, result, current, open, close, n):\\n        if len(current) == 2 * n:\\n            result.append(current)\\n            return\\n        if open < n:\\n            self.generateParentheses(result, current + \\'(\\', open + 1, close, n)\\n        if close < open:\\n            self.generateParentheses(result, current + \\')\\', open, close + 1, n)\\n\\n```\n```\\nvar generateParenthesis = function(n) {\\n  const result = [];\\n  generateParentheses(result, \\'\\', 0, 0, n);\\n  return result;\\n};\\n\\nconst generateParentheses = (result, current, open, close, n) => {\\n  if (current.length === 2 * n) {\\n    result.push(current);\\n    return;\\n  }\\n  if (open < n) {\\n    generateParentheses(result, current + \\'(\\', open + 1, close, n);\\n  }\\n  if (close < open) {\\n    generateParentheses(result, current + \\')\\', open, close + 1, n);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440974,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(string op, int open, int close, vector<string> &ans){\\n        if(open == 0 && close == 0){\\n            ans.push_back(op);\\n            return;\\n        }\\n        //when count of open and close brackets are same then \\n        //we have only one choice to put open bracket \\n        if(open == close){\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else if(open == 0){\\n            //only choice is to put close brackets \\n            string op1 = op;\\n            op1.push_back(\\')\\');\\n            solve(op1, open, close-1, ans);\\n        }\\n        else if(close == 0){\\n            //only choise is to use open bracket \\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(op1, open-1, close, ans);\\n        }\\n        else{\\n            string op1 = op;\\n            string op2 = op;\\n            op1.push_back(\\'(\\');\\n            op2.push_back(\\')\\');\\n            solve(op1, open-1, close, ans);\\n            solve(op2, open, close-1, ans);\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        int open = n;\\n        int close = n;\\n        vector<string> ans;\\n        string op = \"\";\\n        solve(op, open, close, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276139,
                "title": "js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWe can make short work of this problem with a basic branching **recursive** function (**dfs**). Our recursive function will iterate through the index positions (**pos**) of a possible result. At each **pos**, we can add an open parenthesis if there\\'s more remaining space than unclosed parentheses (**open**) and we can add a closed parenthesis if there are any unclosed parentheses. Once we reach the end of the result, we can add it to our answer array (**ans**).\\n\\nTo make things easier, we can use **bit manipulation** to pass the sequence of parentheses (**seq**) for our potential result as an integer to each new recursion level. Then we just have to translate **seq** to a parentheses string before adding it to **ans**.\\n\\nOnce we\\'re all done, we can just **return ans**.\\n\\n - _**Time Complexity: O((2 * N)!/(N! * N!)** reflecting the **2N choose N** possible arrangements of parentheses_\\n - _**Space Complexity: O(N)** for the recursion stack and **res**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 40.4MB** (beats 96% / 25%).\\n```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 14.3MB** (beats 96% / 96%).\\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.7MB** (beats 100% / 93%).\\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 13.7MB** (beats 100% / 57%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656411,
                "title": "c-simple-solution-beats-88",
                "content": "Runtime: 232 ms, faster than 88.71% of C# online submissions for Generate Parentheses.\\nMemory Usage: 32.8 MB, less than 12.50% of C# online submissions for Generate Parentheses.\\n```\\npublic class Solution \\n{\\n    List<string> result = new List<string>();\\n    int maxLen;\\n    \\n    public IList<string> GenerateParenthesis(int n) {\\n        maxLen = n;\\n        GenerateAndCheck(\"\", 0, 0);\\n        return result;\\n    }\\n    \\n    private void GenerateAndCheck(string str, int opened, int closed)\\n    {\\n        if(opened == closed && opened == maxLen)\\n        {\\n            result.Add(str);\\n            return;\\n        }\\n        \\n        if(opened < maxLen)\\n            GenerateAndCheck(str + \"(\", opened + 1, closed);\\n        if(closed < opened)\\n            GenerateAndCheck(str + \")\", opened, closed + 1);\\n    }\\n}\\n```\\n\\nInspired by: https://youtu.be/qBbZ3tS0McI",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    List<string> result = new List<string>();\\n    int maxLen;\\n    \\n    public IList<string> GenerateParenthesis(int n) {\\n        maxLen = n;\\n        GenerateAndCheck(\"\", 0, 0);\\n        return result;\\n    }\\n    \\n    private void GenerateAndCheck(string str, int opened, int closed)\\n    {\\n        if(opened == closed && opened == maxLen)\\n        {\\n            result.Add(str);\\n            return;\\n        }\\n        \\n        if(opened < maxLen)\\n            GenerateAndCheck(str + \"(\", opened + 1, closed);\\n        if(closed < opened)\\n            GenerateAndCheck(str + \")\", opened, closed + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601816,
                "title": "javascript-intuitive-code-with-detailed-explanation",
                "content": "The intuition for many explanations and code is actually the same:\\n- Backtracking and keep track of number of opening and closing brackets have been used either by incrementing or decrementing.\\n- You know you can only start with an opening: `(`\\n- At this point, you have 2 options: add more `(` or now you can add `)` to close it.\\n- When can you add more `(`? Whenever you haven\\'t used up all the `n` openings. `n` pairs = `n` openings and `n` closings. \\n- When can you add more `)`? Whenever you have more openings than closings.\\n- When can you add the combination to the list? When the string you\\'ve generated hits `2*n` length or there\\'s no more opening or closing left.\\n- If you just do it by hands, you\\'ll have something like this:\\n```\\n// Remember: you can either add more closing or opening if you\\'re still within the constraints:\\n\\'(\\'->\\'()\\'->\\'()(\\'->\\'()()\\'->\\'()()(\\'=>\\'()()()\\'\\n                ->\\'()((\\'->\\'()(()\\'=>\\'()(())\\'\\n   ->\\'((\\'->\\'(()\\'->\\'(()(\\'->\\'(()()\\'=>\\'(())())\\'\\n                ->\\'(())\\'->\\'(())(\\'=>\\'(())()\\'\\n         ->\\'(((\\'=>\\'((()))\\'\\n```\\n\\nThe code:\\n```javascript\\n/**\\n * Backtracking solution.\\n * Note: Time and Space complexity is complicated. Catalan number: 4^n/(n*sqrt(n))\\n * Time = O(n*Catalan) because we generat combinations through n steps, each\\n * step takes a Catalan number to backtrack.\\n * Time = O(4^n/(sqrt(n)))\\n * Space = O(4^n/(sqrt(n))) because we need n space to store the sequence.\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    const combinations = [];\\n    // Here we know we can only start with an opening bracket => use 1 open:\\n    // but we can also start with an empty string and 0 like so:\\n    // buildCombinationFrom(\\'\\', 0, 0, n, combinations);\\n    buildCombinationFrom(\\'(\\', 1, 0, n, combinations);\\n    return combinations;\\n};\\n\\n/**\\n * Helper method generates combinations uses backtracking.\\n * @param {string} string \\n * @param {number} openUsed \\n * @param {number} closeUsed \\n * @param {number} n \\n * @param {string[]} combinations \\n */\\nfunction buildCombinationFrom(string, openUsed, closeUsed, n, combinations) {\\n    // Base case: when we reach 2n length\\n    if (string.length === 2*n) {\\n        // Add the string to the list of combination:\\n        combinations.push(string);\\n        // Exit from this recursive call.\\n        return;\\n    }\\n    // Case: when we can add more opening bracket:\\n    // If we haven\\'t used all opening bracket (n pairs = n opens)\\n    if (openUsed < n) {\\n        // Add 1 opening, update opening used:\\n        buildCombinationFrom(string + \\'(\\', openUsed + 1, closeUsed, n, combinations);\\n    }\\n    // Case: when we can add more closing bracket:\\n    // If we have more opening than closing:\\n    if (openUsed > closeUsed) {\\n        // Add 1 closing, update closing used:\\n        buildCombinationFrom(string + \\')\\', openUsed, closeUsed + 1, n, combinations);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n// Remember: you can either add more closing or opening if you\\'re still within the constraints:\\n\\'(\\'->\\'()\\'->\\'()(\\'->\\'()()\\'->\\'()()(\\'=>\\'()()()\\'\\n                ->\\'()((\\'->\\'()(()\\'=>\\'()(())\\'\\n   ->\\'((\\'->\\'(()\\'->\\'(()(\\'->\\'(()()\\'=>\\'(())())\\'\\n                ->\\'(())\\'->\\'(())(\\'=>\\'(())()\\'\\n         ->\\'(((\\'=>\\'((()))\\'\\n```\n```javascript\\n/**\\n * Backtracking solution.\\n * Note: Time and Space complexity is complicated. Catalan number: 4^n/(n*sqrt(n))\\n * Time = O(n*Catalan) because we generat combinations through n steps, each\\n * step takes a Catalan number to backtrack.\\n * Time = O(4^n/(sqrt(n)))\\n * Space = O(4^n/(sqrt(n))) because we need n space to store the sequence.\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    const combinations = [];\\n    // Here we know we can only start with an opening bracket => use 1 open:\\n    // but we can also start with an empty string and 0 like so:\\n    // buildCombinationFrom(\\'\\', 0, 0, n, combinations);\\n    buildCombinationFrom(\\'(\\', 1, 0, n, combinations);\\n    return combinations;\\n};\\n\\n/**\\n * Helper method generates combinations uses backtracking.\\n * @param {string} string \\n * @param {number} openUsed \\n * @param {number} closeUsed \\n * @param {number} n \\n * @param {string[]} combinations \\n */\\nfunction buildCombinationFrom(string, openUsed, closeUsed, n, combinations) {\\n    // Base case: when we reach 2n length\\n    if (string.length === 2*n) {\\n        // Add the string to the list of combination:\\n        combinations.push(string);\\n        // Exit from this recursive call.\\n        return;\\n    }\\n    // Case: when we can add more opening bracket:\\n    // If we haven\\'t used all opening bracket (n pairs = n opens)\\n    if (openUsed < n) {\\n        // Add 1 opening, update opening used:\\n        buildCombinationFrom(string + \\'(\\', openUsed + 1, closeUsed, n, combinations);\\n    }\\n    // Case: when we can add more closing bracket:\\n    // If we have more opening than closing:\\n    if (openUsed > closeUsed) {\\n        // Add 1 closing, update closing used:\\n        buildCombinationFrom(string + \\')\\', openUsed, closeUsed + 1, n, combinations);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919932,
                "title": "easy-java-backtracking-explained-in-comments-1-ms",
                "content": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        String combination = \"\";    //declare and initialize an empty string to hold each valid combination\\n        List<String> listOfValidCombinations = new ArrayList<String>(); //ArrayList to store all the valid combinations\\n        int countOfOpen = 0;    //counter to keep track of no. of open (left) parentheses\\n        int countOfClose = 0;   // counter to keep track of no. of close(right) parentheses\\n        backtrack(listOfValidCombinations, combination, countOfOpen, countOfClose, n); //calling the backtracking method\\n        return listOfValidCombinations; //return the final list of valid combinations computed by the backtacking method\\n    }\\n    \\n    public void backtrack(List<String> listOfValidCombinations, String combination, int countOfOpen, int countOfClose, int maxCount){\\n        /* The main idea here is:\\n        1.  In order to generate valid combinations of parentheses, we need to make sure that\\n            there is a closing parentheses for every open parentheses. This can be achieved by\\n            taking care of the following points:\\n            a.  At any point, no. of open parentheses > no. of closing parentheses\\n            b.  If no. of open parentheses == no. of closing parentheses, we have obtained a valid pattern\\n                (this will be our terminating condition for recursion)\\n            \\n        2.  We can repeat the process in point 1, until we have obatained all the possible combinations.\\n        \\n        */\\n        \\n        /*if no. of open and closing parentheses is equal to n, add the  \\n        combination to the list and return (and thus end the recursion)*/\\n        \\n        if((countOfOpen == maxCount) && (countOfClose == maxCount)){    //terminating condition\\n            listOfValidCombinations.add(combination);   \\n            return;\\n        }\\n        \\n        /*If no. of open parentheses is equal to n, it means we can add\\n        another \\'(\\' to the exisiting pattern and increase the value of countOfOpen by 1*/\\n        \\n        if(countOfOpen < maxCount){\\n            backtrack(listOfValidCombinations, combination + \"(\", countOfOpen + 1, countOfClose, maxCount);\\n        }\\n        \\n        /*If no. of closing parentheses is less than the no. of \\n        open parentheses is equal to n, it means we can add another \\')\\' \\n        to the exisiting pattern and increase the value of countOfClose by 1.\\n        We need to understand here that the second if block will be executed\\n        after the recursion from the first if block ends. In this way, we would\\n        have tried all possible combinations possible at this stage by BACKTRACKING.\\n        This is how backtracking is implemented here.*/\\n        \\n        if(countOfClose < countOfOpen){\\n            backtrack(listOfValidCombinations, combination + \")\", countOfOpen, countOfClose + 1, maxCount);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        String combination = \"\";    //declare and initialize an empty string to hold each valid combination\\n        List<String> listOfValidCombinations = new ArrayList<String>(); //ArrayList to store all the valid combinations\\n        int countOfOpen = 0;    //counter to keep track of no. of open (left) parentheses\\n        int countOfClose = 0;   // counter to keep track of no. of close(right) parentheses\\n        backtrack(listOfValidCombinations, combination, countOfOpen, countOfClose, n); //calling the backtracking method\\n        return listOfValidCombinations; //return the final list of valid combinations computed by the backtacking method\\n    }\\n    \\n    public void backtrack(List<String> listOfValidCombinations, String combination, int countOfOpen, int countOfClose, int maxCount){\\n        /* The main idea here is:\\n        1.  In order to generate valid combinations of parentheses, we need to make sure that\\n            there is a closing parentheses for every open parentheses. This can be achieved by\\n            taking care of the following points:\\n            a.  At any point, no. of open parentheses > no. of closing parentheses\\n            b.  If no. of open parentheses == no. of closing parentheses, we have obtained a valid pattern\\n                (this will be our terminating condition for recursion)\\n            \\n        2.  We can repeat the process in point 1, until we have obatained all the possible combinations.\\n        \\n        */\\n        \\n        /*if no. of open and closing parentheses is equal to n, add the  \\n        combination to the list and return (and thus end the recursion)*/\\n        \\n        if((countOfOpen == maxCount) && (countOfClose == maxCount)){    //terminating condition\\n            listOfValidCombinations.add(combination);   \\n            return;\\n        }\\n        \\n        /*If no. of open parentheses is equal to n, it means we can add\\n        another \\'(\\' to the exisiting pattern and increase the value of countOfOpen by 1*/\\n        \\n        if(countOfOpen < maxCount){\\n            backtrack(listOfValidCombinations, combination + \"(\", countOfOpen + 1, countOfClose, maxCount);\\n        }\\n        \\n        /*If no. of closing parentheses is less than the no. of \\n        open parentheses is equal to n, it means we can add another \\')\\' \\n        to the exisiting pattern and increase the value of countOfClose by 1.\\n        We need to understand here that the second if block will be executed\\n        after the recursion from the first if block ends. In this way, we would\\n        have tried all possible combinations possible at this stage by BACKTRACKING.\\n        This is how backtracking is implemented here.*/\\n        \\n        if(countOfClose < countOfOpen){\\n            backtrack(listOfValidCombinations, combination + \")\", countOfOpen, countOfClose + 1, maxCount);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10403,
                "title": "a-simplified-c-dp-solution-4ms-8-lines",
                "content": "    //dp[0] = \"\"\\n    //dp[i]='('+ dp[k]+')'+dp[i-1-k],k=0..i-i\\n    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector< vector<string> > dp(n+1, vector<string>());\\n            dp[0].push_back(\"\");\\n            for(int i=1; i<=n; ++i){\\n                for(int k=0; k<i; ++k){\\n                    for(string s1: dp[k]){\\n                        for(string s2: dp[i-1-k])\\n                            dp[i].push_back(\"(\"+s1+\")\"+s2);\\n                    }\\n                }\\n            }\\n            return dp[n];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector< vector<string> > dp(n+1, vector<string>());\\n            dp[0].push_back(\"\");\\n            for(int i=1; i<=n; ++i){\\n                for(int k=0; k<i; ++k){\\n                    for(string s1: dp[k]){\\n                        for(string s2: dp[i-1-k])\\n                            dp[i].push_back(\"(\"+s1+\")\"+s2);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 683890,
                "title": "c-backtracking-10-lines-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void f(string s,int open,int close){        //open => \\'(\\' count remaining\\n        if(open==0&&close==0){                  //close=> \\')\\' count remaining\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);    //\\'(\\' must be placed before \\')\\'\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        f(\"\",n,n);                              //Balanced string will have\\n        return ans;                             //n-open and n-closing brackets\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void f(string s,int open,int close){        //open => \\'(\\' count remaining\\n        if(open==0&&close==0){                  //close=> \\')\\' count remaining\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open>0)f(s+\"(\",open-1,close);\\n        if(open<close)f(s+\")\",open,close-1);    //\\'(\\' must be placed before \\')\\'\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        f(\"\",n,n);                              //Balanced string will have\\n        return ans;                             //n-open and n-closing brackets\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450759,
                "title": "0-ms-java-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe time complexity of this solution is O(4^n / sqrt(n)) because there are 2n steps in the backtracking process, and in each step, we can choose to either open or close a bracket. This gives us a total of 2^n possibilities at each step. However, not all of these possibilities are valid since we must ensure that the number of closing brackets is less than or equal to the number of opening brackets at each step. Therefore, we can eliminate half of the possibilities at each step, giving us a total of 2^n / 2 possibilities per step or 2^(2n) / 2^n = 4^n / 2^n = 4^n / (2^(2 * sqrt(n))) = O(4^n / sqrt(n)) possibilities in total.\\n\\nThe space complexity is also O(4^n / sqrt(n)) because this is the maximum number of solutions that we could generate. Since each solution has a length of 2n, the maximum amount of space required to store all solutions is O(2n * 4^n / sqrt(n)) = O(4^n / sqrt(n)).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(4^n / sqrt(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(4^n / sqrt(n))\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/f30b6fb7-d111-4bb1-8f38-6591b7482293_1682345447.5071316.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>(); // initialize the result list\\n        generate(result, \"\", n, n); // call the recursive helper function\\n        return result; // return the result list\\n    }\\n    \\n    public void generate(List<String> result, String s, int left, int right){\\n        if(left == 0 && right == 0){ // base case: no more parentheses to add\\n            result.add(s); // add the generated string to the result list\\n            return; // exit the current recursive call\\n        }\\n        if(left > 0){ // if there are still left parentheses to add\\n            generate(result, s + \"(\", left - 1, right); // add a left parenthesis and recursively call the function\\n        }\\n        if(right > left){ // if there are still right parentheses to add and there are more left parentheses than right parentheses in the current string\\n            generate(result, s + \")\", left, right - 1); // add a right parenthesis and recursively call the function\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>(); // initialize the result list\\n        generate(result, \"\", n, n); // call the recursive helper function\\n        return result; // return the result list\\n    }\\n    \\n    public void generate(List<String> result, String s, int left, int right){\\n        if(left == 0 && right == 0){ // base case: no more parentheses to add\\n            result.add(s); // add the generated string to the result list\\n            return; // exit the current recursive call\\n        }\\n        if(left > 0){ // if there are still left parentheses to add\\n            generate(result, s + \"(\", left - 1, right); // add a left parenthesis and recursively call the function\\n        }\\n        if(right > left){ // if there are still right parentheses to add and there are more left parentheses than right parentheses in the current string\\n            generate(result, s + \")\", left, right - 1); // add a right parenthesis and recursively call the function\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694091,
                "title": "golang-0ms-100",
                "content": "```\\nfunc generateParenthesis(n int) []string {\\n\\tans := make([]string, 0)\\n\\tcurrent := make([]byte, n*2)\\n\\trec22(&ans, n, 0, 0, current)\\n\\treturn ans\\n}\\n```\\n\\n```\\nfunc rec22(ans *[]string, n int, left int, right int, current []byte) {\\n\\tif left+right == n*2 {\\n\\t\\t*ans = append(*ans, string(current))\\n\\t\\treturn\\n\\t}\\n\\n\\tif left < n {\\n\\t\\tcurrent[left+right] = \\'(\\'\\n\\t\\trec22(ans, n, left+1, right, current)\\n\\t}\\n\\n\\tif right < left {\\n\\t\\tcurrent[left+right] = \\')\\'\\n\\t\\trec22(ans, n, left, right+1, current)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateParenthesis(n int) []string {\\n\\tans := make([]string, 0)\\n\\tcurrent := make([]byte, n*2)\\n\\trec22(&ans, n, 0, 0, current)\\n\\treturn ans\\n}\\n```\n```\\nfunc rec22(ans *[]string, n int, left int, right int, current []byte) {\\n\\tif left+right == n*2 {\\n\\t\\t*ans = append(*ans, string(current))\\n\\t\\treturn\\n\\t}\\n\\n\\tif left < n {\\n\\t\\tcurrent[left+right] = \\'(\\'\\n\\t\\trec22(ans, n, left+1, right, current)\\n\\t}\\n\\n\\tif right < left {\\n\\t\\tcurrent[left+right] = \\')\\'\\n\\t\\trec22(ans, n, left, right+1, current)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 916464,
                "title": "python-backtracking-faster-than-98",
                "content": "```\\n# Note: these codes are a python version of this youtube video\\n# https://www.youtube.com/watch?v=qBbZ3tS0McI\\n\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def backtrack(ans, curr, openp, closep, maxp):\\n            if len(curr) == 2*maxp:\\n                ans.append(curr)\\n            if openp < maxp:\\n                backtrack(ans, curr+\\'(\\', openp+1, closep, maxp)\\n            if closep < openp:\\n                backtrack(ans, curr+\\')\\', openp, closep+1, maxp)\\n        \\n        ans = []\\n        openp, closep = 0, 0\\n        curr = \\'\\'\\n        backtrack(ans, curr, openp, closep, n)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n# Note: these codes are a python version of this youtube video\\n# https://www.youtube.com/watch?v=qBbZ3tS0McI\\n\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def backtrack(ans, curr, openp, closep, maxp):\\n            if len(curr) == 2*maxp:\\n                ans.append(curr)\\n            if openp < maxp:\\n                backtrack(ans, curr+\\'(\\', openp+1, closep, maxp)\\n            if closep < openp:\\n                backtrack(ans, curr+\\')\\', openp, closep+1, maxp)\\n        \\n        ans = []\\n        openp, closep = 0, 0\\n        curr = \\'\\'\\n        backtrack(ans, curr, openp, closep, n)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 10312,
                "title": "python-dfs-easy-to-understand",
                "content": "The idea is at every step, check if the current path is a valid path (base case 1) and whether the path has reached the end (base case 2). \\n\\nValid is defined as:\\n\\n 1. Number of left parentheses >= Number of right parentheses\\n 2. Number of left parentheses <= n\\n 3. Number of right parentheses <= n\\n\\nReaching the end is defined as:\\n\\n 1. Total number of parentheses = n*2 (every left parenthesis has to be matched with a right parenthesis)\\n\\nIf the current path is valid and has not reached the end yet, try adding another parenthesis (left and right), respectively) and do this recursively until the path is no longer valid or reached the end. Once we've exhausted all possible options, we can return all valid paths that has reached the end.\\n\\n----------\\n\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.dfs(n,result,'',0,0)\\n        return result\\n    \\n    def dfs(self,n,result,path,left,right):\\n        # check if the current path is valid\\n        if not self.isValid(left,right,n):\\n            return\\n        # check we are at the right length\\n        if len(path) == n*2:\\n            result.append(path)\\n            return\\n        self.dfs(n,result,path+'(',left+1,right)\\n        self.dfs(n,result,path+')',left,right+1)\\n        \\n    def isValid(self,left,right,n):\\n        # left paren <= right paren\\n        # left paren <= n\\n        # right paren >= n\\n        return left >= right and left <= n and right <= n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "The idea is at every step, check if the current path is a valid path (base case 1) and whether the path has reached the end (base case 2). \\n\\nValid is defined as:\\n\\n 1. Number of left parentheses >= Number of right parentheses\\n 2. Number of left parentheses <= n\\n 3. Number of right parentheses <= n\\n\\nReaching the end is defined as:\\n\\n 1. Total number of parentheses = n*2 (every left parenthesis has to be matched with a right parenthesis)\\n\\nIf the current path is valid and has not reached the end yet, try adding another parenthesis (left and right), respectively) and do this recursively until the path is no longer valid or reached the end. Once we've exhausted all possible options, we can return all valid paths that has reached the end.\\n\\n----------\\n\\n    def generateParenthesis(self, n):\\n        result = []\\n        self.dfs(n,result,'',0,0)\\n        return result\\n    \\n    def dfs(self,n,result,path,left,right):\\n        # check if the current path is valid\\n        if not self.isValid(left,right,n):\\n            return\\n        # check we are at the right length\\n        if len(path) == n*2:\\n            result.append(path)\\n            return\\n        self.dfs(n,result,path+'(',left+1,right)\\n        self.dfs(n,result,path+')',left,right+1)\\n        \\n    def isValid(self,left,right,n):\\n        # left paren <= right paren\\n        # left paren <= n\\n        # right paren >= n\\n        return left >= right and left <= n and right <= n",
                "codeTag": "Python3"
            },
            {
                "id": 10425,
                "title": "javascript-solution-in-124ms",
                "content": "    var generateParenthesis = function(n) {\\n      var arr = [];\\n      compose(n, n, '');\\n      return arr;\\n    \\n      function compose(left, right, str) {\\n        if (!left && !right && str.length) return arr.push(str);\\n        if (left) compose(left - 1, right, str + '(');\\n        if (right > left) compose(left, right - 1, str + ')');\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var generateParenthesis = function(n) {\\n      var arr = [];\\n      compose(n, n, '');\\n      return arr;\\n    \\n      function compose(left, right, str) {\\n        if (!left && !right && str.length) return arr.push(str);\\n        if (left) compose(left - 1, right, str + '(');\\n        if (right > left) compose(left, right - 1, str + ')');\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3064146,
                "title": "easy-c-recursive-and-back-tracking-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo recursion and genrate all the possible sequences and also keep checking if open == close and when size of string becomes 2*n then push that string in answer vector.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Recusrive \\n2. Backtracking\\n# Complexity\\n- Time complexity:O(4^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(4^n)$$ recusirve stack + $$O(n)$$ for storing sequences \\n- actually it will be $$4^n/sqrt(n)$$ (it need some calculation but roughly we can take $$4^n$$)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Recursive Approach**\\n```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n)generate(open+1,close,n,s+\"(\");\\n       if(close<open)generate(open,close+1,n,s+\")\");\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```\\n**Back tracking Approach**\\n```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n){\\n           s+=\"(\";\\n           generate(open+1,close,n,s);\\n           s.pop_back();\\n       }\\n       if(close<open){\\n       s+=\")\";\\n       generate(open,close+1,n,s);\\n       s.pop_back();\\n       }\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n)generate(open+1,close,n,s+\"(\");\\n       if(close<open)generate(open,close+1,n,s+\")\");\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<string>ans;\\n   void generate (int open,int close ,int n,string s){\\n       if(s.size()==2*n)ans.push_back(s);\\n       if(open<n){\\n           s+=\"(\";\\n           generate(open+1,close,n,s);\\n           s.pop_back();\\n       }\\n       if(close<open){\\n       s+=\")\";\\n       generate(open,close+1,n,s);\\n       s.pop_back();\\n       }\\n   }\\n    vector<string> generateParenthesis(int n) {\\n        generate(0,0,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712761,
                "title": "beautiful-iterative-python-solution-with-stack",
                "content": "The stack holds all subproblems. The stack gets popped every loop and the possible children of the popped item get appended back on. \\nThe items in the stack are tuples with the following makeup: [parenthesis string, open remaining, closed remaining]. \\nWe initialize the stack with [\"(\",n-1,n] because every valid parenthesis combination starts with \"(\". \\nOnce an item x is popped from the stack, we check if it is complete by checking if the number of open remaining and closed remaining are zero. If it is complete, we append the string stored in x[0] to the return array. \\nIf not, we move to the next step. In the next step, we check if the number of open remaining (x[1]) is less than n. If so, we can append an open parenthesis to x[1], decrement the number of open parentheses remaining, and push it back on the stack. \\nThen, we can check x again to see if the number of closed parentheses remaining (x[2]) is greater than the number of open parentheses remaining (x[1]). If it is, we append a closed parenthesis to x[0], decrement the closed parenthesis counter, then push it back on the stack.\\nOur program finishes when the stack is empty. We return the array of finished strings.\\n\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        rv = []\\n        stack = [(\"(\",n-1,n)]\\n        \\n        while stack:\\n            item = stack.pop()\\n            \\n            s = item[0]\\n            o = item[1]\\n            c = item[2]\\n            \\n            if o == 0 and c == 0:\\n                rv.append(s)\\n            else:\\n                if o != 0:\\n                    stack.append([s+\"(\",o-1,c])\\n                \\n                if o < c:\\n                    stack.append([s+\")\",o,c-1])\\n\\n        return rv\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        rv = []\\n        stack = [(\"(\",n-1,n)]\\n        \\n        while stack:\\n            item = stack.pop()\\n            \\n            s = item[0]\\n            o = item[1]\\n            c = item[2]\\n            \\n            if o == 0 and c == 0:\\n                rv.append(s)\\n            else:\\n                if o != 0:\\n                    stack.append([s+\"(\",o-1,c])\\n                \\n                if o < c:\\n                    stack.append([s+\")\",o,c-1])\\n\\n        return rv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842989,
                "title": "easy-to-understand-time-complexity-analysis-with-pictures",
                "content": "Here is a quick explanation why the time cost to generate all parentheses is `O(nCn)`, where `Cn` is the n-th Catalan number, `n` is the cost to add results.\\n\\nThis problem is very similar with the [95. unique binary search tree II](https://leetcode.com/problems/unique-binary-search-trees-ii/) problem. Let\\'s say `n = 3` and we generated unique binary tree having 3 nodes:\\n```\\nA:          B:              C:       D:        E:\\no            o               o       o          o\\n \\\\         /   \\\\           /          \\\\        /                              \\n  o       o     o         o            o      o             \\n   \\\\                     /            /        \\\\                    \\n    o                   o            o          o \\n```\\n\\nTo convert the unique tree structure to unique parentheses, we just need to apply following rules recursively:\\n* each node corresponds to a pair of parentheses `()`\\n* root node\\'s parentheses will encompass its left child\\'s parenthese (or right, its the same)\\n\\nUsing this rule, we can convert the 5 unique tree structures to unique parentheses:\\nA: `\"()()()\"`; B: `\"(())()\"`; C: `\"((()))\"`; D: `\"()(())\"`; E: `\"(()())\"`\\n\\nNow the question becomes: what is the time complexity of getting all the unique binary tree structure? For a tree with `n` nodes, it\\'s left tree can have `0` to `n - 1` nodes, and its right tree can also have `0` to `n - 1` nodes. So if we know `T(0)` to `T(n - 1)`, then `T(n) = sum_{i = 0}^{n - 1}T[i] * T[n - i - 1]`. This recurrence describes the Catalan number. Let `T[0] = 1` and we can calculate `T[n]` using this recurrence.\\n\\nCheck [problem 95](https://leetcode.com/problems/unique-binary-search-trees-ii/) and [problem 96](https://leetcode.com/problems/unique-binary-search-trees/) for more details!\\n",
                "solutionTags": [],
                "code": "```\\nA:          B:              C:       D:        E:\\no            o               o       o          o\\n \\\\         /   \\\\           /          \\\\        /                              \\n  o       o     o         o            o      o             \\n   \\\\                     /            /        \\\\                    \\n    o                   o            o          o \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327106,
                "title": "easy-to-understand-with-diagram",
                "content": "```\\n public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        backtrack(list, \"\", 0, 0, n);\\n        return list;\\n    }\\n```\\n    \\n    public void backtrack(List<String> list, String str, int open, int close, int max){\\n        \\n        if(str.length() == max*2){\\n            list.add(str);\\n            return;\\n        }\\n        \\n        if(open < max)\\n            backtrack(list, str+\"(\", open+1, close, max);\\n        if(close < open)\\n            backtrack(list, str+\")\", open, close+1, max);\\n    }\\n\\nThis is very easy to understand by first getting all permutations of perenthesis and eliminating based on case 1 and case 2\\n\\n![image](https://assets.leetcode.com/users/raghur/image_1562256962.png)\\n\\n![image](https://assets.leetcode.com/users/raghur/image_1562257162.png)\\n\\n![image](https://assets.leetcode.com/users/raghur/image_1562257179.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public List<String> generateParenthesis(int n) {\\n        List<String> list = new ArrayList<String>();\\n        backtrack(list, \"\", 0, 0, n);\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10250,
                "title": "simple-recursive-solution-0ms-in-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    void search(int left, int right, string path, vector<string>& v) {\\n        if(!left && !right) { v.push_back(path); return ; }\\n        if(left > 0) search(left-1, right, path+\"(\", v);\\n        if(left < right) search(left, right-1, path+\")\", v);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        search(n, n, \"\", v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void search(int left, int right, string path, vector<string>& v) {\\n        if(!left && !right) { v.push_back(path); return ; }\\n        if(left > 0) search(left-1, right, path+\"(\", v);\\n        if(left < right) search(left, right-1, path+\")\", v);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        search(n, n, \"\", v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235446,
                "title": "c-simple-very-easy",
                "content": "The idea is intuitive. Use two integers to count the remaining left parenthesis (left) and the right parenthesis (right) to be added.\\n**At each function call add a left parenthesis and add a right parenthesis if right>left. Add the result if left==0 and right==0.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void fun(int left,int right,string s)\\n    {\\n        if(left<0||right<0)\\n        {\\n          return;\\n        }\\n        if(left==0 and right==0)\\n        {\\n          ans.push_back(s);\\n          return;\\n        }\\n      \\n       fun(left-1,right,s+\"(\");\\n\\t   \\n       if(right>left)\\n\\t   {\\n\\t   fun(left,right-1,s+\")\");\\n\\t   }\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        fun(n,n,\"\");\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void fun(int left,int right,string s)\\n    {\\n        if(left<0||right<0)\\n        {\\n          return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1599246,
                "title": "python-with-detailed-explanation-faster-than-96-54-recursive-iterative-backtracking",
                "content": "##### Lets define our goal, choise and constraints\\n##### Goal (base case) (when to return from the recurresion) --> generate nx2 valid parentheses \\n\\t- to put n*2 valid parentheses\\n\\n##### Choise : (what to do at each recurssion)\\n\\tDo I open a bracket or do I close a bracket\\n\\n##### Constraints (guide the recurssion)\\n\\t- I can\\'t open a braket more than what I\\'ve given --> left < n\\n\\t- I can\\'t close bracket more than what I\\'ve opened --> right < left\\n\\n### Approach as shown in the figure --> this can easily be solved using DFS approach or backtracking\\n\\n### #Then build a recurssion tree using either\\n*  recursive (option 1)\\n* Iterative (option 2)\\n\\n![image](https://assets.leetcode.com/users/images/1e331a2b-7082-46fd-ab41-843d3065e72b_1638037786.9646535.png)\\n\\n#### Option -1 (Recursive)\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"        \\n        out = []\\n        def back_track(par=\\'\\', left=0,right=0):\\n            #base case --> if we generate parthenis with len 2*n we hit our goal\\n            if len(par) == 2*n:\\n                out.append(par)            \\n            if left < n: # if we still have less opened bracket than the allowed n value --> we can still open more\\n                back_track(par+\\'(\\', left+1,right)\\n            if right < left: # we can only close the opened brackets\\n                back_track(par+\\')\\', left, right+1)\\n                \\n        back_track()\\n        return out\\n```\\n\\n#### Option -2 (Iterative)\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        out = []\\n        stack = []\\n        stack.append([\\'(\\',1,0])\\n        while stack:\\n            val, left, right = stack.pop()\\n            if len(val) == 2*n:\\n                out.append(val)                \\n            if left < n:\\n                stack.append([val+\\'(\\', left+1,right])\\n            if right < left:\\n                stack.append([val+\\')\\', left, right+1])                \\n        return out\\n```\\n\\n### If this solution/explanation helps you, don\\'t forget to upvote as a sign of appreciation",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"        \\n        out = []\\n        def back_track(par=\\'\\', left=0,right=0):\\n            #base case --> if we generate parthenis with len 2*n we hit our goal\\n            if len(par) == 2*n:\\n                out.append(par)            \\n            if left < n: # if we still have less opened bracket than the allowed n value --> we can still open more\\n                back_track(par+\\'(\\', left+1,right)\\n            if right < left: # we can only close the opened brackets\\n                back_track(par+\\')\\', left, right+1)\\n                \\n        back_track()\\n        return out\\n```\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        out = []\\n        stack = []\\n        stack.append([\\'(\\',1,0])\\n        while stack:\\n            val, left, right = stack.pop()\\n            if len(val) == 2*n:\\n                out.append(val)                \\n            if left < n:\\n                stack.append([val+\\'(\\', left+1,right])\\n            if right < left:\\n                stack.append([val+\\')\\', left, right+1])                \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545154,
                "title": "java-tc-o-4-n-sqrt-n-sc-o-n-backtracking-iterative-solutions",
                "content": "**Backtracking solution**\\n```\\n/**\\n * Backtracking solution\\n *\\n * Time Complexity: Very loose Upper Bound O(2N * 2^(2N)). As each place has only 2 options.\\n *\\n * Since number of valid combinations is equal to n-th Catalan number. n-th\\n * Catalan number = 1/(n+1) * C(2n, n) which is bounded asymptotically by 4^N /\\n * (N * sqrt(N)). Thus time complexity will be O(4^N / sqrt(N)).\\n *\\n * Space Complexity: O(N) -> Recursion stack size. O(4^N / sqrt(N)) to save the\\n * valid combinations in result list.\\n *\\n * N = Input number.\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        if (n < 0) {\\n            return result;\\n        }\\n        generateParenthesisHelper(result, n, n, new StringBuilder());\\n        return result;\\n    }\\n\\n    private void generateParenthesisHelper(List<String> result, int open, int close, StringBuilder sb) {\\n        if (open == 0 && close == 0) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n\\n        if (open > 0) {\\n            sb.append(\"(\");\\n            generateParenthesisHelper(result, open - 1, close, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n        if (open < close) {\\n            sb.append(\")\");\\n            generateParenthesisHelper(result, open, close - 1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Iterative Solution**\\n\\n```java\\n/**\\n * Iterative Solution\\n *\\n * Time and Space Complexity\\n *      = C0 + 2 (1*C1 + 2*C2 + 3*C3 + 4*C4 + ... + N*CN)\\n *\\n * Where, C0 -> 0th Catalan Number\\n *        C1 -> 1st Catalan Number\\n *        ...\\n *        CN -> Nth Catalan Number = 1/(n+1) * C(2n, n)\\n *              Nth Catalan Number is bounded asymptotically by 4^N / (N * sqrt(N))\\n *\\n * N = Input number\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        if (n < 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        List<List<String>> lists = new ArrayList<>();\\n        lists.add(Collections.singletonList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> list = new ArrayList<>();\\n            for (int j = 0; j < i; j++) {\\n                for (String first : lists.get(j)) {\\n                    for (String second : lists.get(i - 1 - j)) {\\n                        StringBuilder sb = new StringBuilder(\"(\");\\n                        sb.append(first).append(\")\").append(second);\\n                        list.add(sb.toString());\\n                    }\\n                }\\n            }\\n            lists.add(list);\\n        }\\n\\n        return lists.get(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Backtracking solution\\n *\\n * Time Complexity: Very loose Upper Bound O(2N * 2^(2N)). As each place has only 2 options.\\n *\\n * Since number of valid combinations is equal to n-th Catalan number. n-th\\n * Catalan number = 1/(n+1) * C(2n, n) which is bounded asymptotically by 4^N /\\n * (N * sqrt(N)). Thus time complexity will be O(4^N / sqrt(N)).\\n *\\n * Space Complexity: O(N) -> Recursion stack size. O(4^N / sqrt(N)) to save the\\n * valid combinations in result list.\\n *\\n * N = Input number.\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        if (n < 0) {\\n            return result;\\n        }\\n        generateParenthesisHelper(result, n, n, new StringBuilder());\\n        return result;\\n    }\\n\\n    private void generateParenthesisHelper(List<String> result, int open, int close, StringBuilder sb) {\\n        if (open == 0 && close == 0) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n\\n        if (open > 0) {\\n            sb.append(\"(\");\\n            generateParenthesisHelper(result, open - 1, close, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n        if (open < close) {\\n            sb.append(\")\");\\n            generateParenthesisHelper(result, open, close - 1, sb);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Solution\\n *\\n * Time and Space Complexity\\n *      = C0 + 2 (1*C1 + 2*C2 + 3*C3 + 4*C4 + ... + N*CN)\\n *\\n * Where, C0 -> 0th Catalan Number\\n *        C1 -> 1st Catalan Number\\n *        ...\\n *        CN -> Nth Catalan Number = 1/(n+1) * C(2n, n)\\n *              Nth Catalan Number is bounded asymptotically by 4^N / (N * sqrt(N))\\n *\\n * N = Input number\\n */\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        if (n < 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        List<List<String>> lists = new ArrayList<>();\\n        lists.add(Collections.singletonList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> list = new ArrayList<>();\\n            for (int j = 0; j < i; j++) {\\n                for (String first : lists.get(j)) {\\n                    for (String second : lists.get(i - 1 - j)) {\\n                        StringBuilder sb = new StringBuilder(\"(\");\\n                        sb.append(first).append(\")\").append(second);\\n                        list.add(sb.toString());\\n                    }\\n                }\\n            }\\n            lists.add(list);\\n        }\\n\\n        return lists.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276140,
                "title": "generate-parentheses-js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWe can make short work of this problem with a basic branching **recursive** function (**dfs**). Our recursive function will iterate through the index positions (**pos**) of a possible result. At each **pos**, we can add an open parenthesis if there\\'s more remaining space than unclosed parentheses (**open**) and we can add a closed parenthesis if there are any unclosed parentheses. Once we reach the end of the result, we can add it to our answer array (**ans**).\\n\\nTo make things easier, we can use **bit manipulation** to pass the sequence of parentheses (**seq**) for our potential result as an integer to each new recursion level. Then we just have to translate **seq** to a parentheses string before adding it to **ans**.\\n\\nOnce we\\'re all done, we can just **return ans**.\\n\\n - _**Time Complexity: O((2 * N)!/(N! * N!)** reflecting the **2N choose N** possible arrangements of parentheses_\\n - _**Space Complexity: O(N)** for the recursion stack and **res**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 40.4MB** (beats 96% / 25%).\\n```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 14.3MB** (beats 96% / 96%).\\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.7MB** (beats 100% / 93%).\\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 13.7MB** (beats 100% / 57%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942530,
                "title": "from-naive-solution-to-optimal-using-dfs",
                "content": "To start, I wanted to use DFS to generate all combinations of parentheses, and then validate them after. Note for the DFS part, this does not generate **vaild parentheses**, just all combinations. Using DFS is pretty easy to generate them here.\\n\\n```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const dfs = (str, n) => {\\n        if(n == 0) {\\n            res.push(str);\\n            return;\\n        }\\n        dfs(str+\"(\", n-1)\\n        dfs(str+\")\", n-1)\\n    }\\n    dfs(\"\", 2*n)\\n\\t// validate the combinations in the res array\\n    \\n    // ... some code to validate them, remove those that are invalid. \\n    // the solution to https://leetcode.com/problems/valid-parentheses/\\n\\n    // res contains valid combinations now\\n    return res\\n};\\n```\\n\\nWhile this is ok, we can do better. I started to think about the graph that was being genearted by DFS and where I could reduce further recursive calls and found some \\'base\\' cases.\\n\\n![image](https://assets.leetcode.com/users/images/563022d4-95f3-48d8-b30f-f81e5033a244_1605860755.9753644.png)\\n\\nWith this, I knew I could cut down on recursive calls for DFS with better base cases, esentially checking for the valid combinations as I generate them. I needed to translate my base cases into code.\\n\\nBefore, I was using `n` as my depth in DFS, terminating if n reached 0. I knew that the depth was correct for `n`, but I realized that I could keep better track of the number of `(` and `)` by using `n` for `(` and for `)` yeilding the same `2*n` I was using before. We can use those to track how many `(` and `)` have been used in any given call.\\n\\nKnowing this, I was able to translate my 2 additional base cases here, given that I can track the number of `(` and `)` current in use. For the left sub tree, since Its always possible to open with `(` the base case was to stop if the number of `(` exceeded 3. For the right sub tree, if there are more `)` than there currently are `(`, then it would not be possible to have a valid combination from this branch.\\n\\nWith this, we can write optimal code that validates combinations while using DFS\\n\\n```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const dfs = (str, left, right) => {\\n        if(left === 0 && right === 0) {\\n            res.push(str);\\n            return;\\n        }\\n        if(right < left) return\\n        if(left < 0) return\\n        dfs(str+\"(\", left - 1, right)\\n        dfs(str+\")\", left, right - 1)\\n    }\\n    dfs(\"\", n, n)\\n    return res\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const dfs = (str, n) => {\\n        if(n == 0) {\\n            res.push(str);\\n            return;\\n        }\\n        dfs(str+\"(\", n-1)\\n        dfs(str+\")\", n-1)\\n    }\\n    dfs(\"\", 2*n)\\n\\t// validate the combinations in the res array\\n    \\n    // ... some code to validate them, remove those that are invalid. \\n    // the solution to https://leetcode.com/problems/valid-parentheses/\\n\\n    // res contains valid combinations now\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925723,
                "title": "rust-backtracking-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Generate Parentheses.\\nMemory Usage: 2.4 MB, less than 100.00% of Rust online submissions for Generate Parentheses.\\n```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        fn back_track(s: String, open: i32, close: i32) -> Vec<String> {\\n            let mut res = vec![];\\n            if open == 0 && close == 0 {\\n                return vec![s];\\n            }\\n            if open > 0 {\\n                res.append(&mut back_track(s.clone()+\"(\", open-1, close+1));\\n            }\\n            if close > 0 {\\n                res.append(&mut back_track(s.clone()+\")\", open, close-1));\\n            }\\n            res\\n        }\\n        back_track(\"\".to_string(), n, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        fn back_track(s: String, open: i32, close: i32) -> Vec<String> {\\n            let mut res = vec![];\\n            if open == 0 && close == 0 {\\n                return vec![s];\\n            }\\n            if open > 0 {\\n                res.append(&mut back_track(s.clone()+\"(\", open-1, close+1));\\n            }\\n            if close > 0 {\\n                res.append(&mut back_track(s.clone()+\")\", open, close-1));\\n            }\\n            res\\n        }\\n        back_track(\"\".to_string(), n, 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10296,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> ret;\\n            string s = \"\";\\n            if (n <= 0)\\n                return ret;\\n                \\n            recurParenthesis(n, n, ret, s);\\n        }\\n        \\n        void recurParenthesis(int leftNum, int rightNum, vector<string> &ret, string temp)\\n        {\\n            //leftNum means the number of open parenthesis available,rightNum means the number of close parenthesis available\\n            if (leftNum == 0 && rightNum == 0)\\n            {\\n                ret.push_back(temp);\\n                return;\\n            }\\n                \\n            if (leftNum > 0)\\n                recurParenthesis(leftNum-1, rightNum, ret, temp+'(');\\n            \\n            if (rightNum > 0)\\n            {\\n                if (leftNum < rightNum)\\n                    recurParenthesis(leftNum, rightNum-1, ret, temp+')');\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            vector<string> ret;\\n            string s = \"\";\\n            if (n <= 0)\\n                return ret;\\n                \\n            recurParenthesis(n, n, ret, s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3674015,
                "title": "cpp-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ninitially we have number of open bracket is n and closed is also n.\\n\\nnow we can add \\'(\\' in the resultant string(i.e s) without any condition and Decrease the count for this and make the recursive call.\\n\\nbut to add \\')\\' in the resultant string there is a condition. the condition is  we can  add \\')\\'  only when the no of open bracket (i.e noOfOpenBracket) is less then the no of closed bracket\\n (i.e noOfCloseBracket) because all the closed bracket should make  pair with corresponding open bracket.\\n\\nmeans  for n=3 the string \"( ) ****)**** ( ( )\" is not valid beacuse  the 2nd closed bracket doesn\\'t have the corresponding open bracket before it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<string> ans;\\n    void workfunc(int noOfOpenBracket,int noOfCloseBracket,string s)\\n    {\\n        if(noOfOpenBracket==0 && noOfCloseBracket==0)\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(noOfOpenBracket<noOfCloseBracket)\\n        {\\n            workfunc(noOfOpenBracket,noOfCloseBracket-1,s+\\')\\');\\n        }\\n        if(noOfOpenBracket>0)\\n        workfunc(noOfOpenBracket-1,noOfCloseBracket,s+\\'(\\');\\n    }\\n    \\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        workfunc(n,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> ans;\\n    void workfunc(int noOfOpenBracket,int noOfCloseBracket,string s)\\n    {\\n        if(noOfOpenBracket==0 && noOfCloseBracket==0)\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(noOfOpenBracket<noOfCloseBracket)\\n        {\\n            workfunc(noOfOpenBracket,noOfCloseBracket-1,s+\\')\\');\\n        }\\n        if(noOfOpenBracket>0)\\n        workfunc(noOfOpenBracket-1,noOfCloseBracket,s+\\'(\\');\\n    }\\n    \\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        workfunc(n,n,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945298,
                "title": "java-backtracking-with-recursive-tree",
                "content": "**Steps**\\n\\n\\t\\t\\t\\u26ABMake a List ans to add valid strings.\\n\\t\\t\\t\\u26ABMake a recursive function for generating all the possible parentheses.\\n\\t\\t\\t\\u26ABif  String.lengh() == n*2, add the string to the ans list ans return.\\n\\n![image](https://assets.leetcode.com/users/images/b6ae94c1-f29b-46a0-9817-d07778b5b105_1649914093.6822052.jpeg)\\n\\n```\\n public List<String> generateParenthesis(int n) {\\n        ArrayList<String> ans = new ArrayList<>();\\n            bt(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\n    \\n    public void bt(ArrayList<String> ans, String p, int open, int close, int n){\\n        if(p.length() == n*2){\\n            ans.add(p);\\n            return;\\n        }\\n        \\n        if(open < n){\\n            bt(ans, p + \"(\", open + 1, close, n);\\n        }\\n        \\n        if(close < open){\\n            bt(ans, p + \")\", open, close + 1, n);\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n public List<String> generateParenthesis(int n) {\\n        ArrayList<String> ans = new ArrayList<>();\\n            bt(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\n    \\n    public void bt(ArrayList<String> ans, String p, int open, int close, int n){\\n        if(p.length() == n*2){\\n            ans.add(p);\\n            return;\\n        }\\n        \\n        if(open < n){\\n            bt(ans, p + \"(\", open + 1, close, n);\\n        }\\n        \\n        if(close < open){\\n            bt(ans, p + \")\", open, close + 1, n);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1899635,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var res: [String] = []\\n\\n\\n        func backtrack(_ path: [String], _ target: Int) {\\n            var path = path\\n            var count = 0\\n\\n            if path.count == n * 2 {\\n                var string = \"\"\\n                for s in path { string += s }\\n                res.append(string)\\n                return\\n            }\\n\\n            for c in path where c == \"(\" { count += 1 }\\n            for c in [\"(\", \")\"] {\\n                if (c == \"(\" && count >= n) || (c == \")\" && path.count - count >= count)  { continue }\\n                path.append(c)\\n                backtrack(path, target - 1)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n\\n        backtrack([], n * 2)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var res: [String] = []\\n\\n\\n        func backtrack(_ path: [String], _ target: Int) {\\n            var path = path\\n            var count = 0\\n\\n            if path.count == n * 2 {\\n                var string = \"\"\\n                for s in path { string += s }\\n                res.append(string)\\n                return\\n            }\\n\\n            for c in path where c == \"(\" { count += 1 }\\n            for c in [\"(\", \")\"] {\\n                if (c == \"(\" && count >= n) || (c == \")\" && path.count - count >= count)  { continue }\\n                path.append(c)\\n                backtrack(path, target - 1)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n\\n        backtrack([], n * 2)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177483,
                "title": "dfs",
                "content": "**Recursive procedural helper**\\n```\\nclass Solution \\n{\\n    vector<string> out;\\n    \\n    void dfs(string s, int x, int y)\\n    {\\n        if(!y)  out.push_back(s);\\n        if(x)   dfs(s+\\'(\\', x-1, y);\\n        if(x<y) dfs(s+\\')\\', x,   y-1);\\n    }        \\npublic:\\n    vector<string> generateParenthesis(int n) \\n    {\\n        dfs(\"\"s, n, n);\\n        return out;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/0c8c9134-caf3-4ff5-996b-4ad1c2e696de_1619440710.3991406.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    vector<string> out;\\n    \\n    void dfs(string s, int x, int y)\\n    {\\n        if(!y)  out.push_back(s);\\n        if(x)   dfs(s+\\'(\\', x-1, y);\\n        if(x<y) dfs(s+\\')\\', x,   y-1);\\n    }        \\npublic:\\n    vector<string> generateParenthesis(int n) \\n    {\\n        dfs(\"\"s, n, n);\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034005,
                "title": "python-6-approches-visuals-iterative-recursive-dfs-bfs",
                "content": "\\n------------------------------\\n**Approach 1 : Brute-force : Iterative DFS with an explicit stack**\\n- Generate all combinations (geerate recursive tree)\\n- Test each combo (aka path in the space-tree) to see if it\\'s valid -> If yes, add to results\\n- ---------------------------\\n\\n**Idea:**\\n![image](https://assets.leetcode.com/users/images/ef4dec06-d495-4650-a97a-538c63f0db54_1611524590.783094.png)\\n\\n\\n**Big-O:**\\n* **Time**: `O(2^2n) + (4n^2)` \\n\\n\\t* Explanation:\\n\\t\\t* DFS traversal of the space-tree takes `O(E+V)`\\n\\t\\t* space-tree is a binary tree => number of edges is constant and is equal 2 => `E = 2`\\n\\t\\t* `V = number of verticies = (number of paths(leaves) in the space-tree)  * (number of nodes along each path )`  -- See NOTE [1] - choosing and counting\\n\\t\\t* ` V = 2^(2n) * (2n)` for the main logic\\n\\t\\t* Helper is invoked only at the leaves\\n\\t\\t\\t* There are `2n` leaves\\n\\t\\t\\t* A single invokation of `isValid()` costs `O(2n)`\\n\\t\\t\\t* Total cost for helper => `2n*2n` => `4n^2`\\n\\t\\t\\n\\t\\t* Overall big-O main: `O(2^2n)` + helper: `(4n^2)` \\n\\t\\t* **NOTE [1]**\\n\\t\\t![image](https://assets.leetcode.com/users/images/cc712e5e-c3a9-4d59-a7e2-7183d33d50bd_1611524625.0196075.png)\\n\\n\\t\\t\\n* **Space**:  `O(2n)`\\n\\t* Explanation: \\n\\t\\t* Stack contains max of 2n nodes at any given time => thus\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tstack = [(n*2, \"\")]\\n\\twhile stack:\\n\\t\\tbrackets, path = stack.pop()\\n\\t\\t# print(brackets, path)\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tstack.append((brackets-1, path+\")\"))\\n\\t\\t\\tstack.append((brackets-1, path+\"(\"))  \\n\\treturn res\\n```\\n\\n------------------------------\\n**Approach 2 : Brute-force : Iterative BFS with an queue**\\n- Generate all combinations (geerate recursive tree)\\n- Test each combo (aka path in the space-tree) to see if it\\'s valid -> If yes, add to results\\n- ---------------------------\\n**Idea:**\\n* Exactly the same idea as in `Approach 1` except the traversal is BFS using a queue\\n\\n**Big-O:**\\n* Time: `O(2^2n) + (4n^2)` \\n* Space:  `O(2n)`\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((n*2, \"\"))\\n\\twhile q:\\n\\t\\tbrackets, path = q.popleft()\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tq.append((brackets-1, path+\"(\")) \\n\\t\\t\\tq.append((brackets-1, path+\")\"))\\t\\n\\treturn res\\n```\\n------------------------------\\n**Approach 3 : Brute-force : Recursive : Implicit Stack**\\n- Generate all combinations (geerate recursive tree)\\n- Test each combo (aka path in the space-tree) to see if it\\'s valid -> If yes, add to results\\n- ---------------------------\\n\\n**Idea:**\\n* Exactly the same idea as in `Approach 1` except the traversal is done recursively using an implicit stack\\n\\n**Big-O:**\\n* Time: `O(2^2n) + (4n^2)` \\n* Space: `O(2n)` - length of `path`\\n\\n**Code:**\\n\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\t# isValid helper:\\n        def isValid(combo):\\n            stack = []\\n            for br in combo:\\n                if stack:\\n                    prev = stack[-1]\\n                    if prev == \"(\" and br == \")\":\\n                        stack.pop()\\n                    else:\\n                        stack.append(br)\\n                else:\\n                    stack.append(br)\\n            if not stack:\\n                return True\\n            return False\\n        \\n        # recursive helper\\n        def recursive(n, path=\"\", res=[]):\\n            if not n:\\n                if isValid(path):\\n                    res.append(path)\\n            else:\\n                recursive(n-1, path+\"(\", res)\\n                recursive(n-1, path+\")\", res)\\n                \\n            return res\\n            \\n        # main\\n        return recursive(2*n, \"\", [])\\n```\\n\\n\\n------------------------------\\n**Approach 4 : Prune and Search : Discard path As Soon As Possible : Iterative DFS with explicit stack** \\n- ---------------------------\\n**Idea:**\\n![image](https://assets.leetcode.com/users/images/2714606e-9558-48b9-a322-70702a0cb8e6_1611544722.8530722.png)\\n\\n* Don\\'t wait until an entrie combination/path is fully generated only to discard it at the end if proves to be invalid\\n* Instead, only generate comboniations that we know are valid and prune the ones that are invalid\\n\\t* \\tEverytime we add a bracket -> decrement n \\n\\t* \\tOnly add open bracket if open < n\\n\\t* \\tOny add close-bracket if does not exceed number of open-bracket\\n\\t* \\tn here is half the combo/path (aka number of pairs)\\n\\n* **This is Prunning, not backtracking**\\n\\t* For some reason, Leetcode posts insist on using the term \"backtracking\" when describing anything related to a recursive algorithm.\\n\\t* Backtracking is when you have to remove/delete a previous step to reach an earlier state of a solution. Period.\\n\\n**Big-O:**\\n* Time: `<` `O(2^2n * 2n)` - Since many branches will be pruned\\n* Space: `O(2n)` - size of the explicit stack (or, length of `path`)\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\t\\tstack = [(2*n,\"\", 0, 0)] # since out isValid function onlu needs to operate on the basis of (num of pairs / aka half the path) - as opposed to approach 2\\n\\n\\twhile stack:\\n\\t\\tbrackets, path, closeBr, openBr = stack.pop()\\n\\t\\tif not brackets:\\n\\t\\t\\tres.append(path)\\n\\n\\t\\telse:\\n\\t\\t\\tif closeBr < openBr:\\n\\t\\t\\t\\tstack.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\t\\tstack.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\n\\treturn res\\n```\\n\\n------------------------------\\n**Approach 5 : Prune and Search : Discard path As Soon As Possible : Iterative BFS with queue** \\n- ---------------------------\\n\\n**Idea:**\\n\\n**Big-O:**\\n* Time: `<` `O(2^2n * 2n)` - Since many branches will be pruned\\n* Space: `O(2n)` - size of the queue (or, length of `path`)\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((2*n,\"\", 0, 0)) \\n\\nwhile q:\\n\\tbrackets, path, closeBr, openBr = q.popleft()\\n\\tif not brackets:\\n\\t\\tres.append(path)\\n\\n\\telse:\\n\\t\\tif closeBr < openBr:\\n\\t\\t\\tq.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\tq.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\nreturn res\\n```\\n\\n------------------------------\\n**Approach 6 : Prune and Search : Discard path As Soon As Possible : Recursive DFS with Implicit Stack**\\n- ---------------------------\\n\\n**Idea:**\\n* Exactly like `Approach 4` except the traversal is done recursively using an implicit stack\\n\\n**Big-O:**\\n* Time: `<` `O(2^2n * 2n)` - Since many branches will be pruned\\n* Space: `O(2n)` - length of `path`\\n\\n**Code:**\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\n\\t# --- recursive helper --- :\\n\\tdef recursive(brackets, path=\"\", res=[], left=0, right=0):\\n            # print(brackets, path, brackets//2, left, right)\\n            if not brackets:\\n                res.append(path)\\n            else:\\n                if right < left:\\n                    recursive(brackets-1, path+\")\", res, left, right+1)\\n                if left < n: # n should not be decremented as we decrement the number of brackets \\n                    recursive(brackets-1, path+\"(\", res, left+1, right)\\n                \\n            return res\\n        \\n\\t# --- main logic ---\\n\\treturn recursive(2*n, \"\", [], 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tstack = [(n*2, \"\")]\\n\\twhile stack:\\n\\t\\tbrackets, path = stack.pop()\\n\\t\\t# print(brackets, path)\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tstack.append((brackets-1, path+\")\"))\\n\\t\\t\\tstack.append((brackets-1, path+\"(\"))  \\n\\treturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\n\\t# ---- helper to check validity ----\\n\\t# Big-O: O(2n) \\n\\t# this isValid function needs to have the complete path/combination as an input in order to check validity\\n\\tdef isValid(combo):\\n\\t\\tstack = []\\n\\t\\tfor br in combo:\\n\\t\\t\\tif stack:\\n\\t\\t\\t\\tprev = stack[-1]\\n\\t\\t\\t\\tif prev == \"(\" and br == \")\":\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstack.append(br)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(br)\\n\\t\\tif not stack: # brackets have canceled each other out (aka balanced)\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t# ---- main logic -----\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((n*2, \"\"))\\n\\twhile q:\\n\\t\\tbrackets, path = q.popleft()\\n\\t\\tif not brackets:\\n\\t\\t\\tif isValid(path):\\n\\t\\t\\t\\tres.append(path)\\n\\t\\telse:\\n\\t\\t\\t# decrement number od brackets by 1\\n\\t\\t\\t# stack the two options\\n\\t\\t\\tq.append((brackets-1, path+\"(\")) \\n\\t\\t\\tq.append((brackets-1, path+\")\"))\\t\\n\\treturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\t# isValid helper:\\n        def isValid(combo):\\n            stack = []\\n            for br in combo:\\n                if stack:\\n                    prev = stack[-1]\\n                    if prev == \"(\" and br == \")\":\\n                        stack.pop()\\n                    else:\\n                        stack.append(br)\\n                else:\\n                    stack.append(br)\\n            if not stack:\\n                return True\\n            return False\\n        \\n        # recursive helper\\n        def recursive(n, path=\"\", res=[]):\\n            if not n:\\n                if isValid(path):\\n                    res.append(path)\\n            else:\\n                recursive(n-1, path+\"(\", res)\\n                recursive(n-1, path+\")\", res)\\n                \\n            return res\\n            \\n        # main\\n        return recursive(2*n, \"\", [])\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\t\\tstack = [(2*n,\"\", 0, 0)] # since out isValid function onlu needs to operate on the basis of (num of pairs / aka half the path) - as opposed to approach 2\\n\\n\\twhile stack:\\n\\t\\tbrackets, path, closeBr, openBr = stack.pop()\\n\\t\\tif not brackets:\\n\\t\\t\\tres.append(path)\\n\\n\\t\\telse:\\n\\t\\t\\tif closeBr < openBr:\\n\\t\\t\\t\\tstack.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\t\\tstack.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\n\\treturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\tif not n:\\n\\t\\treturn []\\n\\tres = []\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((2*n,\"\", 0, 0)) \\n\\nwhile q:\\n\\tbrackets, path, closeBr, openBr = q.popleft()\\n\\tif not brackets:\\n\\t\\tres.append(path)\\n\\n\\telse:\\n\\t\\tif closeBr < openBr:\\n\\t\\t\\tq.append((brackets-1, path + \")\", closeBr+1, openBr))\\n\\n\\t\\tif openBr < n: # -- SEE NOTE [2]\\n\\t\\t\\tq.append((brackets-1, path + \"(\", closeBr, openBr+1))\\n\\nreturn res\\n```\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t\\n\\t# --- recursive helper --- :\\n\\tdef recursive(brackets, path=\"\", res=[], left=0, right=0):\\n            # print(brackets, path, brackets//2, left, right)\\n            if not brackets:\\n                res.append(path)\\n            else:\\n                if right < left:\\n                    recursive(brackets-1, path+\")\", res, left, right+1)\\n                if left < n: # n should not be decremented as we decrement the number of brackets \\n                    recursive(brackets-1, path+\"(\", res, left+1, right)\\n                \\n            return res\\n        \\n\\t# --- main logic ---\\n\\treturn recursive(2*n, \"\", [], 0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 817715,
                "title": "easy-optimized-concise-and-faster-than-100-00-of-c-submissions",
                "content": "simple backtracking :\\n\\njust adding one by one opening and closing by generating all the combinations\\n\\nif (cur.size()==2*max )   :  we got one combination completely \\n\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\n        vector<string> v;  \\n        ok(v,\"\",0,0,n);\\n        return v;\\n\\t\\t\\n    }\\n    \\n    void ok(vector<string> &v,string cur,int open,int close,int max)\\n    {\\n        if(cur.size()==max*2) // we got the complete combination\\n        {\\n            v.push_back(cur);\\n            return ;\\n        }\\n        \\n        if(open<max) ok(v,cur+\\'(\\',open+1,close,max);     // add opening\\n        if(close<open) ok (v,cur+\\')\\',open,close+1,max);  //add closing\\n        \\n    }",
                "solutionTags": [],
                "code": "simple backtracking :\\n\\njust adding one by one opening and closing by generating all the combinations\\n\\nif (cur.size()==2*max )   :  we got one combination completely \\n\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\n        vector<string> v;  \\n        ok(v,\"\",0,0,n);\\n        return v;\\n\\t\\t\\n    }\\n    \\n    void ok(vector<string> &v,string cur,int open,int close,int max)\\n    {\\n        if(cur.size()==max*2) // we got the complete combination\\n        {\\n            v.push_back(cur);\\n            return ;\\n        }\\n        \\n        if(open<max) ok(v,cur+\\'(\\',open+1,close,max);     // add opening\\n        if(close<open) ok (v,cur+\\')\\',open,close+1,max);  //add closing\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10351,
                "title": "1-ms-beats-92-of-submissions-easy-java-space-optimized-solution",
                "content": "    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        char[] perm = new char[n*2];\\n        perms(n, n, perm, 0, res);\\n        return res;\\n    }\\n    \\n    private void perms(int open, int close, char[] perm, int i, List<String> res) {\\n        if (i == perm.length) {\\n            res.add(new String(perm));\\n            return;\\n        }\\n        if (open > 0 && close >= open) {\\n            perm[i] = '(';\\n            perms(open - 1, close, perm, i+1, res);\\n        }\\n        if (close > 0) {\\n            perm[i] = ')';\\n            perms(open, close - 1, perm, i+1, res);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        char[] perm = new char[n*2];\\n        perms(n, n, perm, 0, res);\\n        return res;\\n    }\\n    \\n    private void perms(int open, int close, char[] perm, int i, List<String> res) {\\n        if (i == perm.length) {\\n            res.add(new String(perm));\\n            return;\\n        }\\n        if (open > 0 && close >= open) {\\n            perm[i] = '(';\\n            perms(open - 1, close, perm, i+1, res);\\n        }\\n        if (close > 0) {\\n            perm[i] = ')';\\n            perms(open, close - 1, perm, i+1, res);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10393,
                "title": "7-lines-in-python-44-ms",
                "content": "n - how many parenthesis can still be opened\\nopen - how many parenthesis are opened\\n\\n    class Solution:\\n        def generateParenthesis(self, n, open=0):\\n            if n == 0: return [')'*open]\\n            if open == 0:\\n                return ['('+x for x in self.generateParenthesis(n-1, 1)]\\n            else:\\n                return [')'+x for x in self.generateParenthesis(n, open-1)] + ['('+x for x in self.generateParenthesis(n-1, open+1)]",
                "solutionTags": [],
                "code": "n - how many parenthesis can still be opened\\nopen - how many parenthesis are opened\\n\\n    class Solution:\\n        def generateParenthesis(self, n, open=0):\\n            if n == 0: return [')'*open]\\n            if open == 0:\\n                return ['('+x for x in self.generateParenthesis(n-1, 1)]\\n            else:\\n                return [')'+x for x in self.generateParenthesis(n, open-1)] + ['('+x for x in self.generateParenthesis(n-1, open+1)]",
                "codeTag": "Java"
            },
            {
                "id": 10198,
                "title": "does-anyone-come-up-with-a-non-recursion-solution",
                "content": "I used recursion as below:\\n\\n    class Solution:\\n    \\n        def generateParenthesis(self, n):\\n            if (n == 0):\\n                return []\\n            string = \"(\"\\n            result = []\\n            left_number = 1\\n            right_number = 0\\n            self.solve(left_number, right_number, string, n, result)\\n            return result\\n            \\n        def solve(self, l_n, r_n, string, n, result):\\n            if (l_n == r_n and r_n == n):\\n                result.append(string)\\n                return\\n            \\n            if (l_n < n):\\n                self.solve(l_n+1, r_n, string+'(', n, result)\\n                \\n            if (r_n < l_n):\\n                self.solve(l_n, r_n+1, string+')', n, result)\\n\\nI am trying to get an iteration solution but haven't got a clue yet.",
                "solutionTags": [],
                "code": "I used recursion as below:\\n\\n    class Solution:\\n    \\n        def generateParenthesis(self, n):\\n            if (n == 0):\\n                return []\\n            string = \"(\"\\n            result = []\\n            left_number = 1\\n            right_number = 0\\n            self.solve(left_number, right_number, string, n, result)\\n            return result\\n            \\n        def solve(self, l_n, r_n, string, n, result):\\n            if (l_n == r_n and r_n == n):\\n                result.append(string)\\n                return\\n            \\n            if (l_n < n):\\n                self.solve(l_n+1, r_n, string+'(', n, result)\\n                \\n            if (r_n < l_n):\\n                self.solve(l_n, r_n+1, string+')', n, result)\\n\\nI am trying to get an iteration solution but haven't got a clue yet.",
                "codeTag": "Java"
            },
            {
                "id": 2422357,
                "title": "everything-explained-using-comment-backtracking-recursion-c-java",
                "content": "```\\n// STEPS TO SOLVE THE PROBLEM:\\n\\n// Create a vector that will store the result.\\n// Call our backtracking function with empty string and initial number of opening and closing parentheses.\\n// Check the base case. If number of opening and closing parentheses are equal to n then we will add the string to the vector and return.\\n// If the base case does not meet then we will check if number of opening parentheses is less than n, If true, then we will add ( to the current string and increment the count of opening parenthesis.\\n// Check if number of closing parentheses is less than open parentheses then we will add ) to the current string and increment the count of closing parentheses.\\n\\n\\n// C++ Solution:\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        \\n        // Resultant vector\\n        vector<string> ans; \\n        /// Recursively generate parentheses\\n        generateParenthesis(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\nprivate:\\n    void generateParenthesis(vector<string> &ans,string s,int open, int close,int n){\\n    // Base case\\n        if (open == n && close == n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(ans, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(ans, s + \")\", open, close + 1, n);\\n        }\\n    }\\n};\\n\\n\\n\\n// JAVA Solution:\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        \\n        // Resultant list\\n        List<String> result = new ArrayList<>();\\n        \\n        /// Recursively generate parentheses\\n        generateParenthesis(result, \"\", 0, 0, n);\\n        \\n        return result;\\n    }\\n    private void generateParenthesis(List<String> result, String s, int open, int close, int n) {\\n        // Base case\\n        if (open == n && close == n) {\\n            result.add(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(result, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(result, s + \")\", open, close + 1, n);\\n        }\\n    }\\n}\\n\\n\\n/* \\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// STEPS TO SOLVE THE PROBLEM:\\n\\n// Create a vector that will store the result.\\n// Call our backtracking function with empty string and initial number of opening and closing parentheses.\\n// Check the base case. If number of opening and closing parentheses are equal to n then we will add the string to the vector and return.\\n// If the base case does not meet then we will check if number of opening parentheses is less than n, If true, then we will add ( to the current string and increment the count of opening parenthesis.\\n// Check if number of closing parentheses is less than open parentheses then we will add ) to the current string and increment the count of closing parentheses.\\n\\n\\n// C++ Solution:\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        \\n        // Resultant vector\\n        vector<string> ans; \\n        /// Recursively generate parentheses\\n        generateParenthesis(ans, \"\", 0, 0, n);\\n        return ans;\\n    }\\nprivate:\\n    void generateParenthesis(vector<string> &ans,string s,int open, int close,int n){\\n    // Base case\\n        if (open == n && close == n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(ans, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(ans, s + \")\", open, close + 1, n);\\n        }\\n    }\\n};\\n\\n\\n\\n// JAVA Solution:\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        \\n        // Resultant list\\n        List<String> result = new ArrayList<>();\\n        \\n        /// Recursively generate parentheses\\n        generateParenthesis(result, \"\", 0, 0, n);\\n        \\n        return result;\\n    }\\n    private void generateParenthesis(List<String> result, String s, int open, int close, int n) {\\n        // Base case\\n        if (open == n && close == n) {\\n            result.add(s);\\n            return;\\n        }\\n        // If the number of open parentheses is less than the given n\\n        if (open < n) {\\n            generateParenthesis(result, s + \"(\", open + 1, close, n);\\n        }\\n        // If we need more close parentheses to balance\\n        if (close < open) {\\n            generateParenthesis(result, s + \")\", open, close + 1, n);\\n        }\\n    }\\n}\\n\\n\\n/* \\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737086,
                "title": "backtracking-solution-with-explanations-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Solve this using ***Backtracking***.\\n- We\\u2019ll have 2*n characters, including n open and n close bracket if it is a valid parenthesis.\\n- We\\u2019ll pass an empty string & open, close tag numbers left.\\n- Base condition: if both open & close equals 0, means we can\\u2019t add any more parenthesis.\\n- if **`open > 0`** means we can add an opening bracket, so add it and decrease its size by 1, **`help(s+\"(\", open-1, close)`.**\\n- if **`open < close`** means we already added 1 or more opening brackets, so now we can add closing one and decrease its size by 1, **`help(s+\")\", open, close-1)`.**\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        help(\"\",n,n);\\n        return ans;\\n    }\\n    void help(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open > 0) help(s+\"(\", open-1, close);\\n        if(open < close) help(s+\")\", open, close-1);\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    vector<string>generateParenthesis(int n) {\\n        help(\"\",n,n);\\n        return ans;\\n    }\\n    void help(string s, int open, int close){\\n        if(open==0 && close==0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(open > 0) help(s+\"(\", open-1, close);\\n        if(open < close) help(s+\")\", open, close-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276582,
                "title": "generate-parentheses-short-easy-solution-w-explanation-beats-100",
                "content": "\\u2714\\uFE0F ***Solution - I (Brute - Force)***\\n\\nWe have `n` pair of parenthesis which means we are required to form a valid parenthesis string of `length == 2*n`. Let\\'s start with the brute-force way. At each position of the string, we can insert **`(`** or **`)`** brackets and so we will try both the options. Atlast, when the length of string becomes `2*n`, we will perform a check and insert into `ans` array if it is valid.\\n\\n```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup> * n)</code>**, for each index in string, we try both the parenthesis which is <code>2`*`2`*`2...2n times = O(2<sup>2n</sup>) = O(4<sup>n</sup>) </code> and lastly, we spend an `O(n)` time to check for the formed string\\'s validity. \\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>** (A tighter bound exists)\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Approach)***\\n\\nInstead of trying out both the brackets at each index of the string, we only try them at places which won\\'t outright invalidate the string. For eg. In the previous approach, we were trying to insert `)` even at the start which would surely not have generated a valid parenthesis. Here, we avoid that. We have 2 cases:\\n\\n* **`(`** can be inserted anywhere till its count is less than `n`\\n* **`)`** can be inserted whenever its count is less than `start` (number of openinig parenthesis)\\n\\nFinally, we will insert the string when its length reaches `2*n`.\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup>)</code>** Here we save the time for string validation at the end and also avoid the extra recursive calls which we know are invalid anyway. \\n**Note**: There exists a tighter bound - <code>O(4<sup>n</sup> / &radic;n)</code>  but without deep analysis of the recursion structure, it\\'s very hard to arrive at it. So, <code>O(4<sup>n</sup>)</code> is good enough for quick estimations\\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>**, Tighter bound - **<code>O(4<sup>n</sup> / &radic;n)</code>**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/001e3d19-b69f-4c1b-96c9-f760343aef54_1623844459.7738905.png  /></td></tr></table>\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729851,
                "title": "no-backtracking-no-recursion-bfs-based-approach-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        //pair of pair, <current_buffer,<open count,closed count>>\\n        queue<pair<string,pair<int,int>>>q;\\n        q.push({\"\",{0,0}});\\n        vector<string>ans;\\n        while(!q.empty())\\n        {\\n            pair<string,pair<int,int>>p = q.front();\\n            q.pop();\\n            //if count of both open and closed parenthesis count is n, we found one permutation, add it to ans;\\n            if(p.second.first==n&&p.second.second==n){\\n                ans.push_back(p.first);\\n            }\\n            else\\n            {\\n                //add open parenthesis if open parenthesis count<n;\\n                if(p.second.first<n){\\n                    q.push({p.first+\"(\",{p.second.first+1,p.second.second}});\\n                }\\n                // add closing parenthesis if closedparenthesis count < open parenthesis count  \\n                if(p.second.second<p.second.first){\\n                    q.push({p.first+\")\",{p.second.first,p.second.second+1}});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThumbs up if you like it. Thanks!",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        //pair of pair, <current_buffer,<open count,closed count>>\\n        queue<pair<string,pair<int,int>>>q;\\n        q.push({\"\",{0,0}});\\n        vector<string>ans;\\n        while(!q.empty())\\n        {\\n            pair<string,pair<int,int>>p = q.front();\\n            q.pop();\\n            //if count of both open and closed parenthesis count is n, we found one permutation, add it to ans;\\n            if(p.second.first==n&&p.second.second==n){\\n                ans.push_back(p.first);\\n            }\\n            else\\n            {\\n                //add open parenthesis if open parenthesis count<n;\\n                if(p.second.first<n){\\n                    q.push({p.first+\"(\",{p.second.first+1,p.second.second}});\\n                }\\n                // add closing parenthesis if closedparenthesis count < open parenthesis count  \\n                if(p.second.second<p.second.first){\\n                    q.push({p.first+\")\",{p.second.first,p.second.second+1}});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248359,
                "title": "extremely-simple-java-dfs-beats-100",
                "content": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        build(n, \"\", output, n, n);\\n        return output;\\n    }\\n    \\n    \\n    public void build(int n, String cur, List output, int left, int right) {\\n        if(left > right) return;\\n        \\n        if((left == 0 && right == 0)) {\\n            output.add(cur);\\n            return;\\n        }\\n        \\n        if(left > 0) {\\n            build(n, cur + \"(\", output, left - 1, right);\\n        }\\n        \\n        \\n        if(right > 0) {\\n            build(n, cur + \")\", output, left, right - 1);\\n        }\\n    }\\n}\\n``",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        build(n, \"\", output, n, n);\\n        return output;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1471383,
                "title": "c-100-faster-than-others",
                "content": "**Please Upvote if like the Solution !**\\n\\n      vector<string> ans;\\n\\n    // Recursive function to generate valid parentheses combinations\\n     void Solve(int open, int close, string curr, int n) {\\n    // Base case: If the current combination\\'s length reaches 2*n, add it to the answer vector\\n    if (curr.size() == 2 * n) {\\n        ans.push_back(curr);\\n        return;\\n    }\\n    \\n    // If we can still add more opening parentheses, do so\\n    if (open < n) {\\n        Solve(open + 1, close, curr + \"(\", n);\\n    }\\n    \\n    // If we have more open parentheses than closing parentheses, add a closing parenthesis\\n    if (close < open) {\\n        Solve(open, close + 1, curr + \")\", n);\\n    }\\n    }\\n\\n    // Function to generate all valid combinations of parentheses\\n    vector<string> generateParenthesis(int n) {\\n    // Clear the answer vector and start generating combinations\\n    ans.clear();\\n    Solve(0, 0, \"\", n);\\n    return ans;\\n\\t}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "**Please Upvote if like the Solution !**\\n\\n      vector<string> ans;\\n\\n    // Recursive function to generate valid parentheses combinations\\n     void Solve(int open, int close, string curr, int n) {\\n    // Base case: If the current combination\\'s length reaches 2*n, add it to the answer vector\\n    if (curr.size() == 2 * n) {\\n        ans.push_back(curr);\\n        return;\\n    }\\n    \\n    // If we can still add more opening parentheses, do so\\n    if (open < n) {\\n        Solve(open + 1, close, curr + \"(\", n);\\n    }\\n    \\n    // If we have more open parentheses than closing parentheses, add a closing parenthesis\\n    if (close < open) {\\n        Solve(open, close + 1, curr + \")\", n);\\n    }\\n    }\\n\\n    // Function to generate all valid combinations of parentheses\\n    vector<string> generateParenthesis(int n) {\\n    // Clear the answer vector and start generating combinations\\n    ans.clear();\\n    Solve(0, 0, \"\", n);\\n    return ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1400055,
                "title": "generate-parentheses-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        permutationBalancedParenthesis(n, n, \"\", output);\\n        return output;\\n    }\\n    \\n    public void permutationBalancedParenthesis(int open, int close, String balancedParentheses, List<String> output) {\\n        /* leaf node in recursive tree */\\n        if(open == 0 && close == 0){\\n            output.add(balancedParentheses);\\n            return;\\n        } \\n        \\n        /* If there is an opening bracket then it is always a choice */\\n        if(open > 0){\\n            String openingBracket = balancedParentheses + \"(\";\\n            permutationBalancedParenthesis(open - 1, close, openingBracket, output);\\n        } \\n        \\n        /* There must be an opening bracket previously, which is yet to be closed. */\\n        if(close > open){\\n            String closingBracket = balancedParentheses + \")\";\\n            permutationBalancedParenthesis(open, close - 1, closingBracket, output);\\n        }\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE .\\nHappy Coding and keep up the good work :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> output = new ArrayList<>();\\n        permutationBalancedParenthesis(n, n, \"\", output);\\n        return output;\\n    }\\n    \\n    public void permutationBalancedParenthesis(int open, int close, String balancedParentheses, List<String> output) {\\n        /* leaf node in recursive tree */\\n        if(open == 0 && close == 0){\\n            output.add(balancedParentheses);\\n            return;\\n        } \\n        \\n        /* If there is an opening bracket then it is always a choice */\\n        if(open > 0){\\n            String openingBracket = balancedParentheses + \"(\";\\n            permutationBalancedParenthesis(open - 1, close, openingBracket, output);\\n        } \\n        \\n        /* There must be an opening bracket previously, which is yet to be closed. */\\n        if(close > open){\\n            String closingBracket = balancedParentheses + \")\";\\n            permutationBalancedParenthesis(open, close - 1, closingBracket, output);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368413,
                "title": "simple-python-backtracking",
                "content": "The idea is that we keep track of a \"sum\" for the current string as we build up towards a valid combination and we enforce \"add 1\" whenever we add a \"(\" and \"minus 1\" whenver we add a \")\". Clearly, with this design, we only need to make sure that 1) \"sum\" never goes to negative and 2)we are not using up available parenthesis to reach valid solution. \\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n        ret=[]\\n        def dfs(s,r_l,r_r,cur):\\n            if s<0 or r_l<0 or r_r<0:\\n                return\\n            if r_l ==0 and r_r==0:\\n                ret.append(cur)\\n            dfs(s+1,r_l-1,r_r,cur+\\'(\\')\\n            dfs(s-1,r_l,r_r-1,cur+\\')\\')\\n        \\n        \\n        dfs(0,n,n,\\'\\')\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n        ret=[]\\n        def dfs(s,r_l,r_r,cur):\\n            if s<0 or r_l<0 or r_r<0:\\n                return\\n            if r_l ==0 and r_r==0:\\n                ret.append(cur)\\n            dfs(s+1,r_l-1,r_r,cur+\\'(\\')\\n            dfs(s-1,r_l,r_r-1,cur+\\')\\')\\n        \\n        \\n        dfs(0,n,n,\\'\\')\\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1181112,
                "title": "easy-to-understand-python-no-recursion",
                "content": "```\\n\"\"\"\\n. represents occurrence of () in new n\\nn = 1, () \\nn = 2, (.), (). = ()(), (())\\nn = 3, .()(), (.)(), ().(), ()(.), ()()., .(()), (.()), ((.)), (().), (()).\\n\\nAvoid duplicates by using a set\\n\"\"\"\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 1:\\n            return [\"()\"]\\n        syms = {\"()\"}\\n        for j in range(n-1):\\n            new_syms = set()\\n            for sym in syms:\\n                for i in range(len(sym)):\\n                    new_syms.add(sym[:i] + \"()\" + sym[i:])\\n            syms = new_syms\\n        return syms",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 1:\\n            return [\"()\"]\\n        syms = {\"()\"}",
                "codeTag": "Java"
            },
            {
                "id": 304042,
                "title": "c-100-91-85-beats-using-c",
                "content": "Beated 100% / 91.85% (0ms / 7.8MB) of C submissions on runtime / memory.\\n\\nIn my solution, there\\'re two highlight points:\\n1. Calculate the returnsize precisely, in order to save memory.\\n1. Use bitwise operation to make my code a beautiful art.\\n\\nTip: I calculate the returnSize by finding the pattern among n=1,2,3,4,5... with the help of OEIS. You can find the integer sequent at here: https://oeis.org/A000108\\n\\nAnd Here\\'s my code:\\n\\n```\\nint size(int);\\n\\nchar ** generateParenthesis(int n, int* returnSize) {\\n    // Calculate the returnSize first for memory saving\\n    *returnSize = size(n);\\n    \\n    // Initiate the answer\\'s memory\\n    char** ans = (char**)malloc(sizeof(char*) * (*returnSize));\\n    memset(ans, 0, sizeof(char*) * (*returnSize));\\n    \\n    // [Explain about each Variable]\\n    // \"sum\" | Checking whether the present result is valide\\n    //\\n    //   \"i\" | Whether every digit is \\'(\\' or \\')\\'\\n    //       | \"i\" can be understood in binary way:\\n    //       | E.g. When n=2 and i=3, then i=0b0011\\n    //       |      Let\\'s define \\'(\\' as 1 and \\')\\' as 0, then:\\n    //       |      0b0011 reverse => 1 1 0 0\\n    //       |                        \\u2193 \\u2193 \\u2193 \\u2193\\n    //       |                        ( ( ) )\\n    //\\n    //   \"j\" | Searching in the sequence\\n    //\\n    //   \"k\" | Count the present index of answer string\\n    int sum, j, k = 0;\\n    \\n    for(int i = 0; i < (1 << (2 * n)); i++) {\\n        // Check Validity\\n        sum = 0;\\n        for(j = 0; j < 2 * n; j++) {\\n            sum += (i&(1<<j)) ? 1 : -1;\\n            if(sum < 0)\\n                break;\\n        }\\n        \\n        // If Valid then Output\\n        if(!sum) {\\n            ans[k] = (char*)malloc(sizeof(char) * 2 * n + 1);\\n            for(j = 0; j < 2 * n; j++)\\n                ans[k][j] = ((i&(1<<j)) ? \\'(\\' : \\')\\');\\n            ans[k][j] = 0;\\n            k++;\\n        }\\n    }\\n    \\n    return ans;\\n}\\n\\n// You can calculate the size by integer sequence A000108 on OEIS \\n// refrence to https://oeis.org/A000108\\nint size(int n) {\\n    int ans = 1;\\n    for(int i = 0; i < n; i++)\\n        ans *= (2 * n - i);\\n    for(int i = 0; i < n; i++)\\n        ans /= (n + 1 - i);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint size(int);\\n\\nchar ** generateParenthesis(int n, int* returnSize) {\\n    // Calculate the returnSize first for memory saving\\n    *returnSize = size(n);\\n    \\n    // Initiate the answer\\'s memory\\n    char** ans = (char**)malloc(sizeof(char*) * (*returnSize));\\n    memset(ans, 0, sizeof(char*) * (*returnSize));\\n    \\n    // [Explain about each Variable]\\n    // \"sum\" | Checking whether the present result is valide\\n    //\\n    //   \"i\" | Whether every digit is \\'(\\' or \\')\\'\\n    //       | \"i\" can be understood in binary way:\\n    //       | E.g. When n=2 and i=3, then i=0b0011\\n    //       |      Let\\'s define \\'(\\' as 1 and \\')\\' as 0, then:\\n    //       |      0b0011 reverse => 1 1 0 0\\n    //       |                        \\u2193 \\u2193 \\u2193 \\u2193\\n    //       |                        ( ( ) )\\n    //\\n    //   \"j\" | Searching in the sequence\\n    //\\n    //   \"k\" | Count the present index of answer string\\n    int sum, j, k = 0;\\n    \\n    for(int i = 0; i < (1 << (2 * n)); i++) {\\n        // Check Validity\\n        sum = 0;\\n        for(j = 0; j < 2 * n; j++) {\\n            sum += (i&(1<<j)) ? 1 : -1;\\n            if(sum < 0)\\n                break;\\n        }\\n        \\n        // If Valid then Output\\n        if(!sum) {\\n            ans[k] = (char*)malloc(sizeof(char) * 2 * n + 1);\\n            for(j = 0; j < 2 * n; j++)\\n                ans[k][j] = ((i&(1<<j)) ? \\'(\\' : \\')\\');\\n            ans[k][j] = 0;\\n            k++;\\n        }\\n    }\\n    \\n    return ans;\\n}\\n\\n// You can calculate the size by integer sequence A000108 on OEIS \\n// refrence to https://oeis.org/A000108\\nint size(int n) {\\n    int ans = 1;\\n    for(int i = 0; i < n; i++)\\n        ans *= (2 * n - i);\\n    for(int i = 0; i < n; i++)\\n        ans /= (n + 1 - i);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3116283,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    void fnc(vector<string> &ans,int n,int open,int close,string curr_str){\\n        if(curr_str.size()==n*2){\\n            ans.push_back(curr_str);\\n            return;\\n        }\\n        if(open<n){\\n            fnc(ans,n,open+1,close,curr_str +\\'(\\');\\n        }\\n         if(close<open){\\n            fnc(ans,n,open,close+1,curr_str +\\')\\');\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        fnc(ans,n,0,0,\"\");\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    void fnc(vector<string> &ans,int n,int open,int close,string curr_str){\\n        if(curr_str.size()==n*2){\\n            ans.push_back(curr_str);\\n            return;\\n        }\\n        if(open<n){\\n            fnc(ans,n,open+1,close,curr_str +\\'(\\');\\n        }\\n         if(close<open){\\n            fnc(ans,n,open,close+1,curr_str +\\')\\');\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        fnc(ans,n,0,0,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066382,
                "title": "99-72-javascript-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/8sZI4b0tlkc\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = []\\n\\n    let iterate = (str, open, close) =>{\\n        if(open > n || close >n || close >open) return;\\n        if(str.length == n *2 && open ==close){\\n            res.push(str)\\n            return;\\n        }\\n        iterate(str +\\'(\\',open+1,close)\\n        iterate(str + \\')\\', open, close+1)\\n    }\\n\\n    iterate(\\'\\',0,0)\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let res = []\\n\\n    let iterate = (str, open, close) =>{\\n        if(open > n || close >n || close >open) return;\\n        if(str.length == n *2 && open ==close){\\n            res.push(str)\\n            return;\\n        }\\n        iterate(str +\\'(\\',open+1,close)\\n        iterate(str + \\')\\', open, close+1)\\n    }\\n\\n    iterate(\\'\\',0,0)\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246389,
                "title": "c-backtracking-methods-with-recursive-tree",
                "content": "RECURSIVE TREE :\\n   for n=3:\\n   ![image](https://assets.leetcode.com/users/images/0a1dbcd3-89d8-4e77-8e7b-610e86c937f4_1657112179.3003967.jpeg)\\n\\nMETHOD_1\\nbacktraking is not invloved \\n```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n           \\n            solve(n,openings+1,closings,temp+\\'(\\',ans);\\n        }\\n        \\n        if(closings<openings){\\n            \\n            solve(n,openings,closings+1,temp+\\')\\',ans);\\n        }\\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD_2\\nbacktracking \\n```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n             temp+=\\'(\\';\\n            solve(n,openings+1,closings,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        if(closings<openings){\\n             temp+=\\')\\';\\n            solve(n,openings,closings+1,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        \\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n           \\n            solve(n,openings+1,closings,temp+\\'(\\',ans);\\n        }\\n        \\n        if(closings<openings){\\n            \\n            solve(n,openings,closings+1,temp+\\')\\',ans);\\n        }\\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(int n, int openings , int closings , string temp, vector<string> &ans){\\n        if(temp.size()==2*n){\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        \\n        if(openings<n){\\n             temp+=\\'(\\';\\n            solve(n,openings+1,closings,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        if(closings<openings){\\n             temp+=\\')\\';\\n            solve(n,openings,closings+1,temp,ans);\\n            temp.pop_back();\\n        }\\n        \\n        \\n          return ;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n,0,0,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043913,
                "title": "c-easy-solution-using-recursion",
                "content": "**[C++] Easy Solution Using Recursion**\\n**For Better Understanding take n=3 and dry run it and draw tree, using recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<string>&ss,string s,int o,int c)\\n    {\\n\\t    if(o==0 && c==0)\\n\\t    {\\n            ss.push_back(s);\\n\\t\\t    return;\\n    \\t}\\n\\t    if(o==c)\\n\\t        solve(ss,s+\"(\",o-1,c);\\n    \\telse if(o==0)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    \\telse if(c>1)\\n    \\t{   \\n\\t    \\tsolve(ss,s+\"(\",o-1,c);\\t\\n\\t    \\tsolve(ss,s+\")\",o,c-1);\\t    \\n    \\t}\\n    \\telse if(c==1)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> s;\\n        solve(s,\"(\",n-1,n);\\n        return s;\\n    }\\n};\\n```\\n**If you find it helpful kindly UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string>&ss,string s,int o,int c)\\n    {\\n\\t    if(o==0 && c==0)\\n\\t    {\\n            ss.push_back(s);\\n\\t\\t    return;\\n    \\t}\\n\\t    if(o==c)\\n\\t        solve(ss,s+\"(\",o-1,c);\\n    \\telse if(o==0)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    \\telse if(c>1)\\n    \\t{   \\n\\t    \\tsolve(ss,s+\"(\",o-1,c);\\t\\n\\t    \\tsolve(ss,s+\")\",o,c-1);\\t    \\n    \\t}\\n    \\telse if(c==1)\\n    \\t\\tsolve(ss,s+\")\",o,c-1);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> s;\\n        solve(s,\"(\",n-1,n);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446245,
                "title": "python3-backtracking-dp",
                "content": "Algorithm: \\nTo clarify, backtracking solves problems recursively by building solutions incrementally and removing those failing to satisfy constraints. For this problem, backtracking is implicitly taken care of by recursion. \\n\\nHere, we define a function `backtrack` which keeps track of remaining number of open & closing parenthesis (denoted as `m` and `n` respectively). If `m == n  == 0`, add the string to answer. If there are open parenthesis left (i.e. `m > 0`), it is possible to append an open parenthesis; if there are more closing parenthesis than open parenthesis (i.e. `n > m`), it is possible to append a closing parenthesis. \\n\\nImplementation (32ms, 90.57%):\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def fn(s, op, cl):\\n            \"\"\"Backtracking to collect parentheses\"\"\"\\n            if cl == n: return ans.append(s)\\n            if op <  n: fn(s+\"(\", op+1, cl)\\n            if cl < op: fn(s+\")\", op, cl+1)\\n                \\n        ans = []\\n        fn(\"\", 0, 0)\\n        return ans \\n```\\n\\nAnalysis:\\nTime complexity `O(4^n/n^1.5)` per [Wikipedia](https://en.wikipedia.org/wiki/Catalan_number) \\nSpace complexity `O(4^n/n^1.5)`\\n\\n+dynamic programming \\n\\nIt is also possible to solve the problem explicitly using dynamic programming. Define `f(n)` as the set of all valid parentheses when there are `n` opening parentheses. Then symbolically, `f(n+1)` follows below recursive equation, \\n`f(n+1) = (f(0))f(n) + (f(1))f(n-1) + ... + (f(n-1))f(1) + (f(n))f(0)` \\n(`(f(i))f(j)` means that the valid parentheses of `f(i)` added by a pair of parentheses outside concatenated with the valid parentheses of `f(j)`, i.e. this is a loop.) \\n\\nTop-down implementation\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(k):\\n            \"\"\"Return k pairs of parentheses\"\"\"\\n            if k == 0: return [\"\"]\\n            ans = []\\n            for i in range(k): ans.extend([f\\'({x}){y}\\' for x in fn(k-i-1) for y in fn(i)])\\n            return ans \\n        \\n        return fn(n)\\n```\\n\\nBottom-up implementation\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = [[\"\"]]\\n        for i in range(1, n+1): \\n            tmp = []\\n            for j in range(i):\\n                for x in ans[j]:\\n                    for y in ans[~j]: \\n                        tmp.append(f\"({x}){y}\")\\n            ans.append(tmp)\\n        return ans[-1]\\n```\\n\\nEdited on 10/31/2021\\n```\\nclass Solution:\\n    @cache\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 0: return [\"\"]\\n        ans = []\\n        for i in range(n):\\n            for x in self.generateParenthesis(n-1-i): \\n                for y in self.generateParenthesis(i): \\n                    ans.append(f\"({x}){y}\")\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        def fn(s, op, cl):\\n            \"\"\"Backtracking to collect parentheses\"\"\"\\n            if cl == n: return ans.append(s)\\n            if op <  n: fn(s+\"(\", op+1, cl)\\n            if cl < op: fn(s+\")\", op, cl+1)\\n                \\n        ans = []\\n        fn(\"\", 0, 0)\\n        return ans \\n```\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(k):\\n            \"\"\"Return k pairs of parentheses\"\"\"\\n            if k == 0: return [\"\"]\\n            ans = []\\n            for i in range(k): ans.extend([f\\'({x}){y}\\' for x in fn(k-i-1) for y in fn(i)])\\n            return ans \\n        \\n        return fn(n)\\n```\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        ans = [[\"\"]]\\n        for i in range(1, n+1): \\n            tmp = []\\n            for j in range(i):\\n                for x in ans[j]:\\n                    for y in ans[~j]: \\n                        tmp.append(f\"({x}){y}\")\\n            ans.append(tmp)\\n        return ans[-1]\\n```\n```\\nclass Solution:\\n    @cache\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        if n == 0: return [\"\"]\\n        ans = []\\n        for i in range(n):\\n            for x in self.generateParenthesis(n-1-i): \\n                for y in self.generateParenthesis(i): \\n                    ans.append(f\"({x}){y}\")\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 296338,
                "title": "python-recursive-solution",
                "content": "This is a Python solution based on ideas from other people\\'s solutions. Basically we rely on recursion to populate all the possible strings and add them to the \"results\" parameter, then return the \"results\" at the end after all the recursions. At each recursive step, we have a \"sofar\" parameter that keeps track of the string we have constructed so far. We add it to the \"results\" in the base case. Otherwise we make 2 recursive calls, with one appending an open paranthesis and the other appending a closing paranthesis.\\n```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        results = []\\n        def helper(sofar, results, left, right):\\n            if left == 0 and right == 0:\\n                results.append(sofar)\\n            if left > 0:\\n                helper(sofar + \"(\", results, left-1, right)\\n            if right > left:\\n                helper(sofar + \")\", results, left, right-1)\\n        helper(\\'\\', results, n, n)\\n        return results\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def generateParenthesis(self, n):\\n        results = []\\n        def helper(sofar, results, left, right):\\n            if left == 0 and right == 0:\\n                results.append(sofar)\\n            if left > 0:\\n                helper(sofar + \"(\", results, left-1, right)\\n            if right > left:\\n                helper(sofar + \")\", results, left, right-1)\\n        helper(\\'\\', results, n, n)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222304,
                "title": "simple-java-dfs-solution",
                "content": "A simple Java DFS solution:\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        dfs(n, n, result, \"\");\\n        return result;\\n    }\\n\\n    private void dfs(int left, int right, List<String> result, String s) {\\n        if (left == 0 && right == 0) result.add(s);\\n        else {\\n            if (left > 0) dfs(left - 1, right, result, s + \"(\");\\n            if (right > left) dfs(left, right - 1, result, s + \")\");\\n        }\\n    }",
                "solutionTags": [],
                "code": "A simple Java DFS solution:\\n\\n\\tpublic List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        dfs(n, n, result, \"\");\\n        return result;\\n    }\\n\\n    private void dfs(int left, int right, List<String> result, String s) {\\n        if (left == 0 && right == 0) result.add(s);\\n        else {\\n            if (left > 0) dfs(left - 1, right, result, s + \"(\");\\n            if (right > left) dfs(left, right - 1, result, s + \")\");\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10185,
                "title": "3-lines-recursion-solution-beats-90",
                "content": "Welcome to tell me if anywhere is not clear and I will add some explanations.\\n```\\n def generateParenthesis(self, n, left=0, right=0, cur=\\'\\'):\\n        if left == n: return [cur + \\')\\' * (n - right)]\\n        if left == right: return self.generateParenthesis(n, left + 1, right, cur + \\'(\\')\\n        return self.generateParenthesis(n, left + 1, right, cur + \\'(\\') \\\\\\n            + self.generateParenthesis(n, left, right + 1, cur + \\')\\')\\n````",
                "solutionTags": [],
                "code": "```\\n def generateParenthesis(self, n, left=0, right=0, cur=\\'\\'):\\n        if left == n: return [cur + \\')\\' * (n - right)]\\n        if left == right: return self.generateParenthesis(n, left + 1, right, cur + \\'(\\')\\n        return self.generateParenthesis(n, left + 1, right, cur + \\'(\\') \\\\\\n            + self.generateParenthesis(n, left, right + 1, cur + \\')\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 10202,
                "title": "detailed-explanation-from-the-view-of-recursion-tree",
                "content": "Re: [Easy to understand Java backtracking solution](/topic/8724/easy-to-understand-java-backtracking-solution)\\n\\nI checked out several solutions. They're very nice and seems like a magic of recursion which I cannot understand and make me upset.\\nThen I try to dig into this problem and see how can I come up nice solution like them.\\n\\nFor this kind of combinatorial problem, typically we use Tree to represent the search space and generate all possible solutions by search.\\nTree is so powerful which is able to represent efficient dicitionary (BST), prefix compression (Trie) or recursion.\\nEssentially, it is **the representation of execution of program**. (In Theory of Computation, it's called Configuration Graph.)\\nTherefore, recursion tree is just a special case but sufficient for analyzing and solving this problem.\\n\\nSo we use Tree to represent the entire search space. Each node is the state of program at that point. What's the state of this problem?\\nSince we'd like to generate all valid parenthesis, **the state we concern is just the String we concat by now**.\\nThen each edge is the choice (precisely, one transition from Transition Function). We only have two options: concat '('' or ')'.\\nThus we can draw the entire tree as follows (which is unique, right?).\\n\\n![0_1482412702046_Untitled Diagram (1).png](/uploads/files/1482412702445-untitled-diagram-1.png) \\n\\nThe characteristic of the Tree is due to that of the problem: \\n\\n + We can choose '(' only if we didn't exceed the max limit\\n + We can choose ')' only if there aren't more )' than '(' by now (otherwise we cannot fix this no matter how we iterate in the following).  \\n\\nNow all those nice solutions seem to be very clear. They're different just because **they use different search technique on this unique tree**.\\nThe first and natural searching approach is DFS which is the green arrow in the diagram above. \\nSince this is not a Complete Tree, we need variables (left/right or open/close) to control.\\nThey help us not to reach non-existing node on the Tree which means syntax wrong state such as ')((())'.\\n\\n```\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ret = new ArrayList<>();\\n        generate(ret, new char[n * 2], 0, 0, n, 0);\\n        return ret;\\n    }\\n    \\n    private void generate(List<String> ret, char[] str, int left, int right, int max, int i) {\\n        if (left == max && right == left) {\\n            ret.add(String.valueOf(str));\\n            return;\\n        }\\n        \\n        if (left < max) {\\n            str[i] = '(';\\n            generate(ret, str, left + 1, right, max, i + 1);\\n        }\\n        if (right < left) {\\n            str[i] = ')';\\n            generate(ret, str, left, right + 1, max, i + 1);\\n        }\\n    }\\n```\\n\\nAt last, let's review the most upvoted solution and see if we can understand now.\\nhttps://discuss.leetcode.com/topic/4485/concise-recursive-c-solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> res;\\n        addingpar(res, \"\", n, 0);\\n        return res;\\n    }\\n    void addingpar(vector<string> &v, string str, int n, int m){\\n        if(n==0 && m==0) {\\n            v.push_back(str);\\n            return;\\n        }\\n        if(m > 0){ addingpar(v, str+\")\", n, m-1); }\\n        if(n > 0){ addingpar(v, str+\"(\", n-1, m+1); }\\n    }\\n};\\n```\\n\\nSee? They turn out to be the same. We start off with left(n)=n, right(m=0).\\nThen if right > 0, we go right. If left > 0, we go left meanwhile increase right by 1.\\nThe blue arrow show the order of this program.",
                "solutionTags": [],
                "code": "```\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ret = new ArrayList<>();\\n        generate(ret, new char[n * 2], 0, 0, n, 0);\\n        return ret;\\n    }\\n    \\n    private void generate(List<String> ret, char[] str, int left, int right, int max, int i) {\\n        if (left == max && right == left) {\\n            ret.add(String.valueOf(str));\\n            return;\\n        }\\n        \\n        if (left < max) {\\n            str[i] = '(';\\n            generate(ret, str, left + 1, right, max, i + 1);\\n        }\\n        if (right < left) {\\n            str[i] = ')';\\n            generate(ret, str, left, right + 1, max, i + 1);\\n        }\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> res;\\n        addingpar(res, \"\", n, 0);\\n        return res;\\n    }\\n    void addingpar(vector<string> &v, string str, int n, int m){\\n        if(n==0 && m==0) {\\n            v.push_back(str);\\n            return;\\n        }\\n        if(m > 0){ addingpar(v, str+\")\", n, m-1); }\\n        if(n > 0){ addingpar(v, str+\"(\", n-1, m+1); }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307006,
                "title": "dfs-with-go",
                "content": "```\\nfunc generateParenthesis(n int) []string {\\n    var res []string\\n    \\n    helper(n, 0, 0, \"\", &res)\\n    \\n    return res\\n}\\n\\nfunc helper(n int, openCount int, closeCount int, currentStr string, result *[]string) {\\n    if openCount == n && closeCount == n {\\n        *result = append(*result, currentStr)\\n        return\\n    }\\n    \\n    if openCount < n {\\n        helper(n, openCount + 1, closeCount, currentStr + \"(\", result)\\n    }\\n    \\n    if openCount > closeCount {\\n        helper(n, openCount, closeCount + 1, currentStr + \")\", result)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc generateParenthesis(n int) []string {\\n    var res []string\\n    \\n    helper(n, 0, 0, \"\", &res)\\n    \\n    return res\\n}\\n\\nfunc helper(n int, openCount int, closeCount int, currentStr string, result *[]string) {\\n    if openCount == n && closeCount == n {\\n        *result = append(*result, currentStr)\\n        return\\n    }\\n    \\n    if openCount < n {\\n        helper(n, openCount + 1, closeCount, currentStr + \"(\", result)\\n    }\\n    \\n    if openCount > closeCount {\\n        helper(n, openCount, closeCount + 1, currentStr + \")\", result)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1787441,
                "title": "c-backtracking-simple-logic-explain",
                "content": "Here are few step need to follow\\n* **Till (open < N) We can put \\'(\\'**\\n* **If (Open>end) We can put \\')\\'**\\n\\n**\\u2B06\\uFE0F Please Upvote**\\n\\n```\\nclass Solution {\\n    vector<string>ans;\\n    void backTrack(int n, int open, int end, string s){\\n        if(open == n && end ==  n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        if(open<n) {\\n            s.push_back(\\'(\\');\\n            backTrack(n, open+1, end, s);\\n            s.pop_back();\\n        }\\n        if(end<open) {\\n            s.push_back(\\')\\');\\n            backTrack(n, open, end+1, s);\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        backTrack(n, 0, 0, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<string>ans;\\n    void backTrack(int n, int open, int end, string s){\\n        if(open == n && end ==  n) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        if(open<n) {\\n            s.push_back(\\'(\\');\\n            backTrack(n, open+1, end, s);\\n            s.pop_back();\\n        }\\n        if(end<open) {\\n            s.push_back(\\')\\');\\n            backTrack(n, open, end+1, s);\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        backTrack(n, 0, 0, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754291,
                "title": "js-easy-heavily-commented-solution-using-backtracking-dfs",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    // Using backtracking and DFS\\n    let res = [];\\n    \\n    const dfs = (str, open, close) => {\\n        // Backtracking case: number of \\')\\' can\\'t be more than number of \\'(\\'\\n        if (open < close) return;\\n        \\n        // Base case: there are n number of open and close parenthesis\\n        if (open === n && close === n) {\\n            res.push(str);\\n            return;\\n        }\\n        \\n        // DFS traversal\\n        if (open < n) dfs(str + \\'(\\', open + 1, close);\\n        if (close < n) dfs(str + \\')\\', open, close + 1);\\n    }\\n    \\n    dfs(\\'\\', 0, 0);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    // Using backtracking and DFS\\n    let res = [];\\n    \\n    const dfs = (str, open, close) => {\\n        // Backtracking case: number of \\')\\' can\\'t be more than number of \\'(\\'\\n        if (open < close) return;\\n        \\n        // Base case: there are n number of open and close parenthesis\\n        if (open === n && close === n) {\\n            res.push(str);\\n            return;\\n        }\\n        \\n        // DFS traversal\\n        if (open < n) dfs(str + \\'(\\', open + 1, close);\\n        if (close < n) dfs(str + \\')\\', open, close + 1);\\n    }\\n    \\n    dfs(\\'\\', 0, 0);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1687595,
                "title": "c-beats-85-backtracking-easy-solution",
                "content": "Please Upvote if it helps you\\n```\\nclass Solution {\\npublic:\\n    void generateAll(vector<string> &ans,int n, int open,int close,string s){\\n\\t\\t// the number of close backets can never be greater than open Brackets as - \"( ) )\" is not valid string \\n        if(open < close || close> n || open>n){\\n            return;\\n        }\\n        if(close==n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        s+=\\'(\\';\\n        generateAll(ans,n,open+1,close,s);\\n        s.pop_back(); //backtrack\\n        \\n        s+=\\')\\';\\n        generateAll(ans,n,open,close+1,s);\\n        \\n    }\\n    vector<string> generateParenthesis(int n) {\\n        \\n        vector<string> ans;\\n        \\n        generateAll(ans,n,0,0,\"\");\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateAll(vector<string> &ans,int n, int open,int close,string s){\\n\\t\\t// the number of close backets can never be greater than open Brackets as - \"( ) )\" is not valid string \\n        if(open < close || close> n || open>n){\\n            return;\\n        }\\n        if(close==n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        s+=\\'(\\';\\n        generateAll(ans,n,open+1,close,s);\\n        s.pop_back(); //backtrack\\n        \\n        s+=\\')\\';\\n        generateAll(ans,n,open,close+1,s);\\n        \\n    }\\n    vector<string> generateParenthesis(int n) {\\n        \\n        vector<string> ans;\\n        \\n        generateAll(ans,n,0,0,\"\");\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402549,
                "title": "very-easy-recursion-aditya-verma",
                "content": "**Upvote,if you like it**\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\tvoid solve(int open,int close,string &op,vector<string> &ans)\\n    {\\n        if(open == 0 and close == 0)\\n        {\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        if(open != 0)\\n        {\\n            string op1 = op;\\n            op1.push_back(\\'(\\');\\n            solve(open - 1,close,op1,ans);\\n        }\\n        \\n        if(close > open)\\n        {\\n            string op2 = op;\\n            op2.push_back(\\')\\');\\n            solve(open,close-1,op2,ans);\\n        }\\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        \\n        vector<string> ans;\\n        string op = \"\";\\n        int close = n;\\n        int open = n;\\n        solve(open,close,op,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\tvoid solve(int open,int close,string &op,vector<string> &ans)\\n    {\\n        if(open == 0 and close == 0)\\n        {\\n            ans.push_back(op);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1276105,
                "title": "c-simple-and-clean-recursive-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void rec(string curr, int open, int close) {\\n        if (open == 0 && close == 0) {\\n            res.push_back(curr);\\n            return;\\n        }\\n        \\n        if (open > 0) rec(curr + \"(\", open-1, close+1);\\n        if (close > 0) rec(curr + \")\", open, close-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        rec(\"\", n, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> res;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(string curr, int open, int close) {\\n        if (open == 0 && close == 0) {\\n            res.push_back(curr);\\n            return;\\n        }\\n        \\n        if (open > 0) rec(curr + \"(\", open-1, close+1);\\n        if (close > 0) rec(curr + \")\", open, close-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        rec(\"\", n, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166698,
                "title": "python-well-explained",
                "content": "In backtracking we use depth-first search to traverse the solution space. We undo previous actions in order to revert back to the state that we branch off from so that we can explore other branches coming from that state.\\n\\nWe backtrack when:\\n- we find a a valid solution (a goal state).\\n- when we find an invalid state.\\n\\nThe two main advantages of backtracking method are:\\n- It prevents us from branching off from invalid/unpromising states.\\n- It is typically space efficient.\\n\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t# Store the valid solutions we encounter\\n\\toutput = []\\n        \\n\\tdef dfs(open_brackets=0, closed_brackets=0, s=\\'\\'):\\n\\t    # If there are n opened and closed brackets\\n\\t    if open_brackets == n and closed_brackets == n:\\n\\t        # Append the valid solution to the output array\\n\\t        output.append(curr)\\n\\t        # Do not continue searching from this state\\n\\t        return\\n            \\n        # If we can place an open bracket\\n        if open_brackets < n:\\n            # Add an open bracket\\n            curr += \\'(\\'\\n            # Explore states based on this one\\n            dfs(open_brackets + 1, closed_brackets, curr)\\n            # Backtrack by removing the open bracket we placed\\n            curr = curr[:-1]\\n                \\n        # If we haven\\'t closed all open brackets\\n        if closed_brackets < open_brackets:\\n            # Add a close bracket\\n            curr += \\')\\'\\n            # Explore states based on this one\\n            dfs(open_brackets, closed_brackets + 1, curr)\\n            # Backtrack by removing the closed bracket\\n            curr = curr[:-1]\\n\\n    # Begin the depth-first search\\n    dfs()\\n        \\n    # Return the array of valid solutions\\n    return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n\\t# Store the valid solutions we encounter\\n\\toutput = []\\n        \\n\\tdef dfs(open_brackets=0, closed_brackets=0, s=\\'\\'):\\n\\t    # If there are n opened and closed brackets\\n\\t    if open_brackets == n and closed_brackets == n:\\n\\t        # Append the valid solution to the output array\\n\\t        output.append(curr)\\n\\t        # Do not continue searching from this state\\n\\t        return\\n            \\n        # If we can place an open bracket\\n        if open_brackets < n:\\n            # Add an open bracket\\n            curr += \\'(\\'\\n            # Explore states based on this one\\n            dfs(open_brackets + 1, closed_brackets, curr)\\n            # Backtrack by removing the open bracket we placed\\n            curr = curr[:-1]\\n                \\n        # If we haven\\'t closed all open brackets\\n        if closed_brackets < open_brackets:\\n            # Add a close bracket\\n            curr += \\')\\'\\n            # Explore states based on this one\\n            dfs(open_brackets, closed_brackets + 1, curr)\\n            # Backtrack by removing the closed bracket\\n            curr = curr[:-1]\\n\\n    # Begin the depth-first search\\n    dfs()\\n        \\n    # Return the array of valid solutions\\n    return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 413718,
                "title": "simple-ruby-solution-using-backtracking",
                "content": "```\\ndef generate_parenthesis(n)\\n  @res = []\\n  backtrack(\"\", 0, 0, n)\\n  @res\\nend\\n\\ndef backtrack(curr, open, close, n)\\n  @res << curr and return if curr.length == n*2\\n  backtrack(curr+\\'(\\', open+1, close, n) if open < n\\n  backtrack(curr+\\')\\', open, close+1, n) if close < open\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Backtracking"
                ],
                "code": "```\\ndef generate_parenthesis(n)\\n  @res = []\\n  backtrack(\"\", 0, 0, n)\\n  @res\\nend\\n\\ndef backtrack(curr, open, close, n)\\n  @res << curr and return if curr.length == n*2\\n  backtrack(curr+\\'(\\', open+1, close, n) if open < n\\n  backtrack(curr+\\')\\', open, close+1, n) if close < open\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3906758,
                "title": "recurison-solution",
                "content": "# **PLS UPVOTE IF YOU LIKE MY SOLUTION AND COMMENT FOR ANY DISCUSSION **\\n# Approach\\nFunction solve: This is a recursive helper function that generates all valid combinations of parentheses.\\n\\nThe base case is when the length of the temp string becomes equal to 2 * n. At this point, you\\'ve formed a valid combination, so you add it to the result vector and return.\\n\\nIf you can still add an opening parenthesis ( (i.e., if start < n), you recursively call solve with an incremented start and append an opening parenthesis to the temp string.\\n\\nIf you can add a closing parenthesis ) without making the combination invalid (i.e., if close < start), you recursively call solve with an incremented close and append a closing parenthesis to the temp string.\\n\\nFunction generateParenthesis: This is the main function that initializes the result vector and starts the recursion by calling the solve function.\\n\\nThe initial call to solve has start and close both set to 0, and an empty temp string.\\nThe idea behind this approach is to generate all possible combinations of parentheses by recursively adding an opening parenthesis when possible and a closing parenthesis when it won\\'t lead to an invalid combination. The recursion explores all possible paths of forming valid combinations.\\n\\nThe result will be a vector of strings containing all the valid combinations of parentheses for the given n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^(2n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(int n , int start , int close, string temp ,vector<string>&result)\\n{\\n    if(temp.size()==n*2)\\n    {\\n        result.push_back(temp);\\n        return ; \\n    }\\n    if(start < n)\\n    {\\n        solve(n,start + 1, close,temp + \"(\", result);\\n    }\\n     if(close < start )\\n    {\\n        solve(n,start, close + 1,temp + \")\", result);\\n    }\\n }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>result;\\n        solve(n,0, 0,\"\", result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(int n , int start , int close, string temp ,vector<string>&result)\\n{\\n    if(temp.size()==n*2)\\n    {\\n        result.push_back(temp);\\n        return ; \\n    }\\n    if(start < n)\\n    {\\n        solve(n,start + 1, close,temp + \"(\", result);\\n    }\\n     if(close < start )\\n    {\\n        solve(n,start, close + 1,temp + \")\", result);\\n    }\\n }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>result;\\n        solve(n,0, 0,\"\", result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855246,
                "title": "beginner-friendly-different-way-of-approach-using-recursion-and-stack",
                "content": "# Intuition\\nGenerate every possible string using recursion and check each string is valid or not.\\n\\n# Complexity\\n- Time complexity:\\nO(2^(2n)*2n).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(string &s){\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\') st.push(\\'(\\');\\n            else {\\n                if(!st.empty()) st.pop();\\n                 else return false;\\n                }\\n        }\\n        if(st.size()==0) return true;\\n        return false;\\n        \\n    }\\n    \\n   void solve(int n1,int n2,string s,vector<string> &ans){\\n        if(n1==0 && n2==0){\\n            if(isvalid(s)){\\n                ans.push_back(s);\\n            }\\n            return;\\n        }\\n        if(n1!=0) {s.push_back(\\'(\\');  solve(n1-1,n2,s,ans); s.pop_back();}\\n       \\n        if(n2!=0) {s.push_back(\\')\\'); solve(n1,n2-1,s,ans);}\\n       \\n   \\n        \\n}\\n\\n    vector<string> generateParenthesis(int n) {\\n\\n        vector<string> ans;\\n        solve(n,n,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(string &s){\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\') st.push(\\'(\\');\\n            else {\\n                if(!st.empty()) st.pop();\\n                 else return false;\\n                }\\n        }\\n        if(st.size()==0) return true;\\n        return false;\\n        \\n    }\\n    \\n   void solve(int n1,int n2,string s,vector<string> &ans){\\n        if(n1==0 && n2==0){\\n            if(isvalid(s)){\\n                ans.push_back(s);\\n            }\\n            return;\\n        }\\n        if(n1!=0) {s.push_back(\\'(\\');  solve(n1-1,n2,s,ans); s.pop_back();}\\n       \\n        if(n2!=0) {s.push_back(\\')\\'); solve(n1,n2-1,s,ans);}\\n       \\n   \\n        \\n}\\n\\n    vector<string> generateParenthesis(int n) {\\n\\n        vector<string> ans;\\n        solve(n,n,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772106,
                "title": "easy-solution-using-recursion-with-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gp(int left,int right,string &s,vector<string> &ans){\\n        if(left==0 && right==0)\\n        ans.push_back(s);\\n\\n        if(left>right || left<0 || right<0){\\n            return ;\\n        }\\n        s.push_back(\\'(\\');\\n        gp(left-1,right,s,ans);\\n        s.pop_back();\\n\\n        s.push_back(\\')\\');\\n        gp(left,right-1,s,ans);\\n        s.pop_back();\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s;\\n        gp(n,n,s,ans);\\n        return ans;\\n    }\\n};\\n/*UPVOTE IF THE SOLUTION WAS HELPFUL FOR YOU.*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void gp(int left,int right,string &s,vector<string> &ans){\\n        if(left==0 && right==0)\\n        ans.push_back(s);\\n\\n        if(left>right || left<0 || right<0){\\n            return ;\\n        }\\n        s.push_back(\\'(\\');\\n        gp(left-1,right,s,ans);\\n        s.pop_back();\\n\\n        s.push_back(\\')\\');\\n        gp(left,right-1,s,ans);\\n        s.pop_back();\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s;\\n        gp(n,n,s,ans);\\n        return ans;\\n    }\\n};\\n/*UPVOTE IF THE SOLUTION WAS HELPFUL FOR YOU.*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613202,
                "title": "valid-parentheses-easy-hai-samjh-aa-jaega",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKch ni krna hai, ye socho ki obviously open bracket close bracket se pehle aaega, to condition open bracket ka lekr chalna hai, or bs code kr dena hai\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOpen bracket daalo, close bracket daalo, jb open N se aage jae ya close open se aage jae to ruk jaana hai, ni to 3 condition likha hai, dekho samjh aa jaega\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNI PTA, SAARA TEST CASE PASS HO GAYA HAI\\n<!-- Contact : c0deblooded   telegram username -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAB RETURN KRNA HAI TO ANS STRING TO BNANA PADEGA NA BHAI\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n\\n    void solve(int n, string &str, int open, int close){\\n        if(open == close and open == n - 1){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open < n){\\n            str.push_back(\\'(\\');\\n            solve(n, str, open + 1, close);\\n            str.pop_back();\\n\\n        }\\n        if(open > close){\\n            str.push_back(\\')\\');\\n            solve(n, str, open, close + 1);\\n            str.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        ans.resize(0);\\n        string str;\\n        solve(n+1, str, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n\\n    void solve(int n, string &str, int open, int close){\\n        if(open == close and open == n - 1){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open < n){\\n            str.push_back(\\'(\\');\\n            solve(n, str, open + 1, close);\\n            str.pop_back();\\n\\n        }\\n        if(open > close){\\n            str.push_back(\\')\\');\\n            solve(n, str, open, close + 1);\\n            str.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        ans.clear();\\n        ans.resize(0);\\n        string str;\\n        solve(n+1, str, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401851,
                "title": "100-detailed-explaination-with-pictures-in-c-java-python-recursion",
                "content": "\\n# Approach\\n- Here the approach is pretty simple Always the number of Open brackets must be Greater than or equal to the closed ones and in the end we must have a balanced parantheses.\\n>- The Decision tree of this approach would be like as shown below in the picture.\\n\\n![pic1.png](https://assets.leetcode.com/users/images/9ca0631b-cc21-4ebc-b3e8-d91f71cf61e8_1681154610.15714.png)\\n\\n- As Above we can observe how the recursion tree is constructed now we push the end product $i.e$ when `open == close == n` we would push the string into the vector of string and `return` the function.\\n\\n>This would be the most obvious way to solve these type of question and also there are some solution of a type where bitmasking is used in common but currently we stick on to this type of solution which is enough in most of the interviews.\\n\\n# Complexity\\n>- Time complexity: Here the Time complexity would be $$O(2^n)$$ and this is because we cannot optimise the recursion call via Creating a Dp array or something so we have to try all the possiblities which results in Exponential complexity i.e $$(2^n)$$.\\n\\n>- Space complexity:Here the Space complexity would Just be storage space complexity of $$O(n)$$ due to stack space and vector of string storage space.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void gen(vector<string>&vs , string &s , int n , int open  , int close)\\n    {\\n        if(open == close && open == n-1)\\n        {\\n            vs.push_back(s);\\n            return;\\n        }\\n        if(open < n)\\n        {\\n            s.push_back(\\'(\\');\\n            gen(vs, s , n , open + 1 ,close);\\n            s.pop_back();\\n        }\\n        if(close < open)\\n        {\\n            s.push_back(\\')\\');\\n            gen(vs,  s,  n , open , close + 1);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>vs;\\n        string s;\\n        gen(vs , s , n+1 , 0 , 0);\\n        return vs;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        dfs (n, 0, 0, 0, sb, result);\\n        return result;\\n    }\\n    private void dfs (int n, int left, int right, int index, StringBuilder sb, List<String> result) {\\n        if (left == n && right == n) {\\n            result.add (sb.toString());\\n            return;\\n        }\\n        if (left < n) {\\n            sb.append (\\'(\\');\\n            dfs (n, left + 1, right, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n\\n        if (right < left) {\\n            sb.append (\\')\\');\\n            dfs (n, left, right + 1, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n\\n        def dfs(left, right, s):\\n            if len(s) == n * 2:\\n                res.append(s)\\n                return \\n\\n            if left < n:\\n                dfs(left + 1, right, s + \\'(\\')\\n\\n            if right < left:\\n                dfs(left, right + 1, s + \\')\\')\\n\\n        res = []\\n        dfs(0, 0, \\'\\')\\n        return res\\n```\\n\\n\\n---\\n\\n\\n\\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/fd222420-993e-4879-87e3-68e203f44d2d_1681153859.3552585.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void gen(vector<string>&vs , string &s , int n , int open  , int close)\\n    {\\n        if(open == close && open == n-1)\\n        {\\n            vs.push_back(s);\\n            return;\\n        }\\n        if(open < n)\\n        {\\n            s.push_back(\\'(\\');\\n            gen(vs, s , n , open + 1 ,close);\\n            s.pop_back();\\n        }\\n        if(close < open)\\n        {\\n            s.push_back(\\')\\');\\n            gen(vs,  s,  n , open , close + 1);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>vs;\\n        string s;\\n        gen(vs , s , n+1 , 0 , 0);\\n        return vs;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        dfs (n, 0, 0, 0, sb, result);\\n        return result;\\n    }\\n    private void dfs (int n, int left, int right, int index, StringBuilder sb, List<String> result) {\\n        if (left == n && right == n) {\\n            result.add (sb.toString());\\n            return;\\n        }\\n        if (left < n) {\\n            sb.append (\\'(\\');\\n            dfs (n, left + 1, right, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n\\n        if (right < left) {\\n            sb.append (\\')\\');\\n            dfs (n, left, right + 1, index + 1, sb, result);\\n            sb.deleteCharAt (sb.length() -1);\\n        }\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n\\n        def dfs(left, right, s):\\n            if len(s) == n * 2:\\n                res.append(s)\\n                return \\n\\n            if left < n:\\n                dfs(left + 1, right, s + \\'(\\')\\n\\n            if right < left:\\n                dfs(left, right + 1, s + \\')\\')\\n\\n        res = []\\n        dfs(0, 0, \\'\\')\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400123,
                "title": "shortest-c-solution-using-recursion",
                "content": "# Complexity\\n- Time complexity: O(4^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(4^n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, vector<string>& ans, string s) {\\n        if (open == 0 && close == 0) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > 0) solve(open - 1, close, ans, s + \\'(\\');\\n        if (close > 0 && close > open) solve(open, close - 1, ans, s + \\')\\');\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n, n, ans, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, vector<string>& ans, string s) {\\n        if (open == 0 && close == 0) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > 0) solve(open - 1, close, ans, s + \\'(\\');\\n        if (close > 0 && close > open) solve(open, close - 1, ans, s + \\')\\');\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        solve(n, n, ans, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152520,
                "title": "python-code-using-dp",
                "content": "# Intuition\\nwe can find all the elements which will come for n using the values of previous elements in n-1.\\neg. if we have [\"(())\",\"()()\"] for n == 2\\nand [\"()\"] for n == 1\\nthe we can find answer for n == 3 using the previous values.\\n\\n# Approach\\nfor n == 3 we can add the \"()\" in any place in elements belonging to n == 2\\neg. taking first value in n == 2 we have \"(())\"\\nnow we add the \"()\" in each index of \"(())\" we get \"()(())\",\"(()())\", and so on ,resulting in a valid parenthesis of n == 3 similarly we can do same for next elements.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        dp ={}\\n        dp[1] = [\"()\"]\\n        dp[2] = [\"(())\",\"()()\"]\\n        for i in range(3,n+1):\\n            d = {}\\n            arr = []\\n            for st in dp[i-1]:\\n                for j in range(0,len(st)):\\n                    new = st[0:j]+\"()\"+st[j:len(st)]\\n                    if new not in d:\\n                        d[new] = 1\\n                        arr.append(new)\\n            dp[i] = arr\\n        # print(dp[n])\\n        return dp[n]\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        dp ={}\\n        dp[1] = [\"()\"]\\n        dp[2] = [\"(())\",\"()()\"]\\n        for i in range(3,n+1):\\n            d = {}\\n            arr = []\\n            for st in dp[i-1]:\\n                for j in range(0,len(st)):\\n                    new = st[0:j]+\"()\"+st[j:len(st)]\\n                    if new not in d:\\n                        d[new] = 1\\n                        arr.append(new)\\n            dp[i] = arr\\n        # print(dp[n])\\n        return dp[n]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777911,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string &st, int fb, int sb, int mx) {\\n        if(st.size() == 2 * mx) {\\n            ans.push_back(st);\\n            return;\\n        }\\n        if(fb < mx) {\\n            st.push_back(\\'(\\');\\n            solve(st, fb+1, sb, mx);\\n            st.pop_back();\\n        }\\n        if(sb < fb) {\\n            st.push_back(\\')\\');\\n            solve(st, fb, sb+1, mx);\\n            st.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        string st;\\n        solve(st, 0, 0, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void solve(string &st, int fb, int sb, int mx) {\\n        if(st.size() == 2 * mx) {\\n            ans.push_back(st);\\n            return;\\n        }\\n        if(fb < mx) {\\n            st.push_back(\\'(\\');\\n            solve(st, fb+1, sb, mx);\\n            st.pop_back();\\n        }\\n        if(sb < fb) {\\n            st.push_back(\\')\\');\\n            solve(st, fb, sb+1, mx);\\n            st.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        string st;\\n        solve(st, 0, 0, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352433,
                "title": "recursive-c-solution-include-or-exclude",
                "content": "```\\nvoid generateParenthesis(int open, int close, string op, vector<string>& ans) {\\n        if(open == 0 && close == 0) {\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        if(open > 0) generateParenthesis(open-1, close, op+\"(\", ans);\\n        \\n        if(close > open) generateParenthesis(open, close-1, op+\")\", ans);\\n        \\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n         vector<string> ans;\\n        int open = n;\\n        int close = n;\\n        string op = \"\";\\n        generateParenthesis(open, close, op, ans);\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid generateParenthesis(int open, int close, string op, vector<string>& ans) {\\n        if(open == 0 && close == 0) {\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        if(open > 0) generateParenthesis(open-1, close, op+\"(\", ans);\\n        \\n        if(close > open) generateParenthesis(open, close-1, op+\")\", ans);\\n        \\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n         vector<string> ans;\\n        int open = n;\\n        int close = n;\\n        string op = \"\";\\n        generateParenthesis(open, close, op, ans);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2136726,
                "title": "aditya-verma-s-solution",
                "content": "```\\n//GOD ADITYA VERMA\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string op=\"\";\\n        vector<string> v;\\n        int o=n,c=n;\\n        solve(o,c,op,v);\\n        return v;\\n    }\\n    void solve(int open,int close,string &op,vector<string> &v)\\n    {\\n        if(open==0 && close==0)\\n        {\\n            v.push_back(op);\\n            return;\\n        }\\n        if(open!=0)\\n        {\\n            string op1=op;\\n            op1.push_back(\\'(\\');\\n            solve(open-1,close,op1,v);\\n            \\n        }\\n        if(close>open)\\n        {\\n            string op2=op;\\n            op2.push_back(\\')\\');\\n            solve(open,close-1,op2,v);\\n            \\n        }\\n    }\\n};\\n```\\n\\nPlease upvote!!",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//GOD ADITYA VERMA\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string op=\"\";\\n        vector<string> v;\\n        int o=n,c=n;\\n        solve(o,c,op,v);\\n        return v;\\n    }\\n    void solve(int open,int close,string &op,vector<string> &v)\\n    {\\n        if(open==0 && close==0)\\n        {\\n            v.push_back(op);\\n            return;\\n        }\\n        if(open!=0)\\n        {\\n            string op1=op;\\n            op1.push_back(\\'(\\');\\n            solve(open-1,close,op1,v);\\n            \\n        }\\n        if(close>open)\\n        {\\n            string op2=op;\\n            op2.push_back(\\')\\');\\n            solve(open,close-1,op2,v);\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806995,
                "title": "using-recursion-backtracking-with-comments-c",
                "content": "**Using Recursion & Backtracking\\nTime Complexity = O(2^N)\\nSpace Complexity = O(1), not considering the ans vector, bcz its a part of output**\\n```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, string output, vector<string> &ans){\\n        \\n        // base case\\n        if(open == 0 && close == 0){\\n            ans.push_back(output);\\n            return;\\n        }\\n        \\n        // always takes open, until & unless its 0\\n        // inside this just append the open bracket and decrease open by 1\\n        if(open != 0){\\n            string openOutput = output + \"(\";\\n            solve(open-1, close, openOutput, ans);    \\n        }\\n        \\n        // take close when close is greater than open, bcz when we will use open, then only we can use close\\n        // inside this just append the close bracket and decrease close by 1\\n        if(close > open){\\n            string closeOutput = output + \")\";\\n            solve(open, close-1, closeOutput, ans);\\n        }\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        \\n        // to store ans\\n        vector<string> ans;\\n        \\n        // we will be having n open & close brackets\\n        int open = n, close = n;\\n        \\n        // will store the combination into this\\n        string output = \"\";\\n        \\n        // helper function to solve the problem\\n        solve(open, close, output, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int open, int close, string output, vector<string> &ans){\\n        \\n        // base case\\n        if(open == 0 && close == 0){\\n            ans.push_back(output);\\n            return;\\n        }\\n        \\n        // always takes open, until & unless its 0\\n        // inside this just append the open bracket and decrease open by 1\\n        if(open != 0){\\n            string openOutput = output + \"(\";\\n            solve(open-1, close, openOutput, ans);    \\n        }\\n        \\n        // take close when close is greater than open, bcz when we will use open, then only we can use close\\n        // inside this just append the close bracket and decrease close by 1\\n        if(close > open){\\n            string closeOutput = output + \")\";\\n            solve(open, close-1, closeOutput, ans);\\n        }\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        \\n        // to store ans\\n        vector<string> ans;\\n        \\n        // we will be having n open & close brackets\\n        int open = n, close = n;\\n        \\n        // will store the combination into this\\n        string output = \"\";\\n        \\n        // helper function to solve the problem\\n        solve(open, close, output, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688977,
                "title": "c-short-clean-easy-to-understand",
                "content": "**Please upvote if you find helpful:)**\\n\\n```\\nclass Solution {\\npublic:\\n    void generateAll(int n, int open, int close, vector<string>&v, string s)\\n    {\\n        if(open>n || close>n || close>open)\\n            return;\\n        if(open==n && close==n)\\n        {\\n            v.push_back(s);\\n            return;\\n        }\\n        generateAll(n, open+1, close, v, s+\\'(\\');\\n        generateAll(n, open, close+1, v, s+\\')\\');\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>v;\\n        generateAll(n, 0, 0, v, \"\");\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateAll(int n, int open, int close, vector<string>&v, string s)\\n    {\\n        if(open>n || close>n || close>open)\\n            return;\\n        if(open==n && close==n)\\n        {\\n            v.push_back(s);\\n            return;\\n        }\\n        generateAll(n, open+1, close, v, s+\\'(\\');\\n        generateAll(n, open, close+1, v, s+\\')\\');\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>v;\\n        generateAll(n, 0, 0, v, \"\");\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318087,
                "title": "easiest-solution-a-using-queue-beats-100-solves-5-problems",
                "content": "For questions like Generate paranthesis, Generate Permutations, Generate Subsets, Generate all bitstrings, Generate all strings without concecutive vowels, Queue approach will easily do the good. Same approach, but just changing the if conditions for adding children should be done relevantly to the question.\\n\\n**1. For Generate-Paranthesis**,\\nMaintain a Queue with [(str, opencount, closecount))] initially, front=0, qlength=1,\\nwhile front<qlength, peek the first element and add two children of it, (str+\\'(\\', opencount+1, closecount) and (str+\\')\\', opencount, closecount+1), increment front pointer. That\\'s all :)\\n```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n    ans = []\\n    queue = [(\\'(\\', 1,0)]  # Item will contain (str, open_nos, close_nos)\\n    f = 0             # front_index\\n    l = 1            # queue_length\\n    while f<l:\\n        cur = queue[f]\\n        if cur[1]+cur[2]==2*n:\\n            ans.append(cur[0])\\n            f+=1\\n            continue\\n        if cur[1] < n:\\n            queue.append((cur[0]+\\'(\\', cur[1]+1, cur[2]))\\n            l+=1\\n        if cur[2] < cur[1]:\\n            queue.append((cur[0]+\\')\\', cur[1], cur[2]+1))\\n            l+=1\\n        f+=1\\n    return ans\\n```\\n\\n**2. For Generate-Permutations**,\\nHaving [(str, visitedchars, len)] as the Queue, its same like previous except that while adding the children to Queue we check if we\\'ve already used the character. \\n```\\ndef permute(self, nums: List[int]) -> List[List[int]]:\\n    n=len(nums)\\n    ans=[]\\n\\n    queue = []\\n    f = 0     # Queue front\\n    for i in nums:\\n        queue.append(([i], set([i]), 1))   # (str, visited_chars, len)\\n    l = len(queue)  # Queue length\\n\\t\\n    while f < l:\\n        cur = queue[f]\\n        if cur[2] == n:\\n            ans.append(cur[0])\\n        else:\\n            for i in nums:\\n                if i not in cur[1]:\\n                    queue.append((cur[0]+[i], cur[1].union([i]), cur[2]+1))\\n                    l += 1\\n        f+=1\\n\\t\\t\\n    return ans\\n```\\n\\n**3. For generating bitstrings of length n** Like n=3 -> 001, 010, 011, 100, 101, 110, 111\\nWe\\'ll have [(str, len)] in queue. Add [(str+\\'0\\', len+1)] and [(str+\\'1\\', len+1)] to the queue until len+1 not greater than n.\\n\\n**4. For generating subsets**, \\nGenerating binary bitstrings and appending the set bits to the ans is one solution. But again, in Queue approach, we\\'ll have [(set, len)] in Queue. Starting from [{}, 0] -> [[{1}, 1], [{2}, 1], ...]] -> [powerset, n] While going all the way to the powerset, we\\'ll add the intermediaries (\"cur\" in code) to the ans array.\\n\\n**5. For generating strings without consecutive vowels**, Like, for n=3, **Valid** strings are aba, abz, zzz, jka, eba. **Invalid** strings = aeb, poi, aaa, ..etc. because there are consecutive vowels\\nSame queue approach, but while adding children to the queue we need to make sure that we are **not** attaching a vowel after a vowel.\\n\\nThank youu :) Happy coding friends!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\ndef generateParenthesis(self, n: int) -> List[str]:\\n    ans = []\\n    queue = [(\\'(\\', 1,0)]  # Item will contain (str, open_nos, close_nos)\\n    f = 0             # front_index\\n    l = 1            # queue_length\\n    while f<l:\\n        cur = queue[f]\\n        if cur[1]+cur[2]==2*n:\\n            ans.append(cur[0])\\n            f+=1\\n            continue\\n        if cur[1] < n:\\n            queue.append((cur[0]+\\'(\\', cur[1]+1, cur[2]))\\n            l+=1\\n        if cur[2] < cur[1]:\\n            queue.append((cur[0]+\\')\\', cur[1], cur[2]+1))\\n            l+=1\\n        f+=1\\n    return ans\\n```\n```\\ndef permute(self, nums: List[int]) -> List[List[int]]:\\n    n=len(nums)\\n    ans=[]\\n\\n    queue = []\\n    f = 0     # Queue front\\n    for i in nums:\\n        queue.append(([i], set([i]), 1))   # (str, visited_chars, len)\\n    l = len(queue)  # Queue length\\n\\t\\n    while f < l:\\n        cur = queue[f]\\n        if cur[2] == n:\\n            ans.append(cur[0])\\n        else:\\n            for i in nums:\\n                if i not in cur[1]:\\n                    queue.append((cur[0]+[i], cur[1].union([i]), cur[2]+1))\\n                    l += 1\\n        f+=1\\n\\t\\t\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1222114,
                "title": "java-clean-concise-optimal-code-backtracking-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public void generateAll (String s, int max, int openBracket, int closeBracket, List<String> answer) {\\n        \\n        if (s.length () == 2 * max) {\\n            answer.add (s);\\n        }\\n        if (openBracket < max) {\\n            generateAll (s + \\'(\\', max, openBracket + 1, closeBracket, answer);\\n        }\\n        if (closeBracket < openBracket) {\\n            generateAll (s + \\')\\', max, openBracket, closeBracket + 1, answer);\\n        }\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        generateAll (\"\", n, 0, 0, answer);\\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public void generateAll (String s, int max, int openBracket, int closeBracket, List<String> answer) {\\n        \\n        if (s.length () == 2 * max) {\\n            answer.add (s);\\n        }\\n        if (openBracket < max) {\\n            generateAll (s + \\'(\\', max, openBracket + 1, closeBracket, answer);\\n        }\\n        if (closeBracket < openBracket) {\\n            generateAll (s + \\')\\', max, openBracket, closeBracket + 1, answer);\\n        }\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> answer = new ArrayList<> ();\\n        \\n        generateAll (\"\", n, 0, 0, answer);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441884,
                "title": "8-lines-recursive-solution-in-scala",
                "content": "```\\ndef generateParenthesis(n: Int): List[String] = n match {\\n\\tcase 0 => List(\"\")\\n\\tcase n =>\\n\\t\\tfor {\\n\\t\\t\\tm <- (0 to n - 1).toList\\n\\t\\t\\tx <- generateParenthesis(m)\\n\\t\\t\\ty <- generateParenthesis(n-1-m)\\n\\t\\t} yield (\"(\" ++ x ++ \")\" ++ y)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef generateParenthesis(n: Int): List[String] = n match {\\n\\tcase 0 => List(\"\")\\n\\tcase n =>\\n\\t\\tfor {\\n\\t\\t\\tm <- (0 to n - 1).toList\\n\\t\\t\\tx <- generateParenthesis(m)\\n\\t\\t\\ty <- generateParenthesis(n-1-m)\\n\\t\\t} yield (\"(\" ++ x ++ \")\" ++ y)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 248837,
                "title": "python-dfs-short-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        return self.dfs(n, n, \"\", [])\\n\\n    def dfs(self, l, r, s, res):\\n        if l:\\n            self.dfs(l-1, r, s + \"(\", res)\\n        if r and l < r:          # l < r is important. \\n            self.dfs(l, r-1, s + \")\", res)\\n        if not r:\\n            res.append(s)\\n        return res\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        return self.dfs(n, n, \"\", [])\\n\\n    def dfs(self, l, r, s, res):\\n        if l:\\n            self.dfs(l-1, r, s + \"(\", res)\\n        if r and l < r:          # l < r is important. \\n            self.dfs(l, r-1, s + \")\", res)\\n        if not r:\\n            res.append(s)\\n        return res\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 139825,
                "title": "valid-parenthesis-invariant",
                "content": "Let\\'s define cntLeft as the number of \\'(\\' met so far, cntRight as the number of  \\')\\' met so far.\\n\\nThere is an **invariant** that a valid combination of parenthesis alwas hold **cntLeft >= cntRight**.\\n\\n```\\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> result = new LinkedList<>();\\n        generateParenthesisFrom(n, 0, 0, new StringBuilder(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void generateParenthesisFrom(int n, int cntLeft, int cntRight, StringBuilder temp, List<String> result) {\\n        \\n        if (cntLeft > n || cntRight > n || cntLeft < cntRight) {\\n            return;\\n        }       \\n        if ((cntLeft == n) && (cntRight == n)) {\\n            result.add(temp.toString());\\n            return;\\n        }\\n\\n        temp.append(\"(\");\\n        generateParenthesisFrom(n, cntLeft + 1, cntRight, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);      \\n        \\n        temp.append(\")\");\\n        generateParenthesisFrom(n, cntLeft, cntRight + 1, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);\\n    }\\n```\\nThanks for **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB)",
                "solutionTags": [],
                "code": "```\\n    public List<String> generateParenthesis(int n) {\\n        \\n        List<String> result = new LinkedList<>();\\n        generateParenthesisFrom(n, 0, 0, new StringBuilder(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void generateParenthesisFrom(int n, int cntLeft, int cntRight, StringBuilder temp, List<String> result) {\\n        \\n        if (cntLeft > n || cntRight > n || cntLeft < cntRight) {\\n            return;\\n        }       \\n        if ((cntLeft == n) && (cntRight == n)) {\\n            result.add(temp.toString());\\n            return;\\n        }\\n\\n        temp.append(\"(\");\\n        generateParenthesisFrom(n, cntLeft + 1, cntRight, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);      \\n        \\n        temp.append(\")\");\\n        generateParenthesisFrom(n, cntLeft, cntRight + 1, temp, result);\\n        temp.deleteCharAt(temp.length() - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133250,
                "title": "backtracking-with-stringbuilder",
                "content": "```\\npublic List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        generate(0, 0, new StringBuilder(), res, n);\\n        return res;\\n    }\\n    private void generate(int open, int closed, StringBuilder sb, List<String> res, int n){\\n        if(closed > open || open > n || closed > n) return;\\n        if(open == closed && open == n){\\n            res.add(new String(sb));\\n            return;\\n        }\\n        sb.append(\"(\");\\n        generate(open+1, closed, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n        sb.append(\")\");\\n        generate(open, closed+1, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<>();\\n        generate(0, 0, new StringBuilder(), res, n);\\n        return res;\\n    }\\n    private void generate(int open, int closed, StringBuilder sb, List<String> res, int n){\\n        if(closed > open || open > n || closed > n) return;\\n        if(open == closed && open == n){\\n            res.add(new String(sb));\\n            return;\\n        }\\n        sb.append(\"(\");\\n        generate(open+1, closed, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n        sb.append(\")\");\\n        generate(open, closed+1, sb, res, n);\\n        sb.setLength(sb.length()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10341,
                "title": "simple-c-sol-backtracking",
                "content": "\\n\\nclass Solution {\\n\\nprivate:\\n    \\nvector<string> res;\\n\\npublic:\\n\\n    void genP(int lc, int rc, string s){\\n        if(lc == 0 && rc ==0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(lc>0)\\n            genP(lc-1,rc,s+'(');\\n        if(rc>lc)\\n            genP(lc,rc-1,s+')');\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        genP(n,n,\"\");\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\nprivate:\\n    \\nvector<string> res;\\n\\npublic:\\n\\n    void genP(int lc, int rc, string s){\\n        if(lc == 0 && rc ==0){\\n            res.push_back(s);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 10385,
                "title": "an-easy-c-solution-using-recursion",
                "content": "    \\n\\n    class Solution {\\n    public:\\n        #include<vector>\\n        vector <string> ans;\\n        \\n        void para(int i,int open,int n,string s)\\n        {\\n            if(open < 0)    return;\\n            if(i==n)\\n            {\\n                if(open==0)\\n                    ans.push_back(s);\\n                return;\\n            }\\n            para(i+1,open+1,n,s+\"(\");   \\n            para(i+1,open-1,n,s+\")\");\\n        }\\n    \\n        vector<string> generateParenthesis(int n) {\\n            \\n            string s = \"\";\\n            para(0,0,2*n,s);\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        #include<vector>\\n        vector <string> ans;\\n        \\n        void para(int i,int open,int n,string s)\\n        {\\n            if(open < 0)    return;\\n            if(i==n)\\n            {\\n                if(open==0)\\n                    ans.push_back(s);\\n                return;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 10459,
                "title": "my-java-solution-using-recursive",
                "content": "    public class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        if(0 == n)\\n            return res;\\n        int l = n;\\n        int r = n;\\n        String item = new String();\\n        putIn(l,r,item,res);\\n        return res;\\n    }\\n    public void putIn(int l, int r, String item, List<String> res)\\n    {\\n        if(l==0 && r==0)\\n        {\\n            res.add(item);\\n            return;\\n        }\\n        if(l>0)\\n            putIn(l-1,r,item+\"(\",res);\\n        if(r>l)\\n            putIn(l,r-1,item+\")\",res);\\n    }\\n}\\n\\nThis is based on recursive thought, we can regard the Parenthesis in a set, when the set is empty, we add the string into result list, otherwise, we get a \"(\" from set and add it to the string, and get \")\" from set, add it to the string. Is this thinking better for us to understand?",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        if(0 == n)\\n            return res;\\n        int l = n;\\n        int r = n;\\n        String item = new String();\\n        putIn(l,r,item,res);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 10352,
                "title": "the-most-concise-solution-i-know-ever",
                "content": "    class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            if(n==0) return vector<string>(1,\"\") ;\\n            if(n==1) return vector<string>(1,\"()\") ;\\n            vector<string> result;\\n            for(int i=0;i!=n;i++)\\n                for(auto inner: generateParenthesis(i))\\n                    for(auto outter:  generateParenthesis(n-i-1))\\n                        result.push_back(\"(\"+inner+\")\"+outter);\\n            return result;\\n        }\\n    };\\n\\nI think this solution must be the most concise one. The idea is very clear. \\n\\nPS: The author is not me. Just share it with you.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> generateParenthesis(int n) {\\n            if(n==0) return vector<string>(1,\"\") ;\\n            if(n==1) return vector<string>(1,\"()\") ;\\n            vector<string> result;\\n            for(int i=0;i!=n;i++)\\n                for(auto inner: generateParenthesis(i))\\n                    for(auto outter:  generateParenthesis(n-i-1))\\n                        result.push_back(\"(\"+inner+\")\"+outter);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3567408,
                "title": "generate-all-valid-parentheses-combinations-backtracking",
                "content": "# Intuition\\nAt first I thought about using part of the paranthesis checker from the last problem but I quickly realized that I needed a new algorithm for this, but I had no clue how to start. I was reading the discussion when I saw someone post a tree graph of the possibilities of one of the samples and I thought, okay, it\\'s possible with backtracking.\\n\\n# Approach\\n1. Create a helper function called **backtrack** that takes the following parameters: **result** (a vector of strings to store valid parentheses combinations), **current** (a string representing the current combination of parentheses), **open** (the count of open parentheses), **close** (the count of close parentheses), and **n** (the desired number of pairs of parentheses).\\n2. The base case of the recursion is when the length of the **current** string is equal to **2 * n**. In this case, all open and close parentheses have been used, so the **current** string represents a valid combination of parentheses. Add the **current** string to the **result** vector and return.\\n3. If the count of open parentheses (**open**) is less than **n**, it means there are still available open parentheses. Append an opening parenthesis \\'(\\' to the **current** string and make a recursive call to **backtrack**, incrementing **open** by 1. This explores the possibility of using an open parenthesis at this position.\\n4. If the count of close parentheses (**close**) is less than **open**, it means there are more open parentheses than close parentheses in the **current** string. Append a closing parenthesis \\')\\' to the **current** string and make a recursive call to **backtrack**, incrementing close by 1. This explores the possibility of using a **close** parenthesis to match an existing open parenthesis.\\n5. After each recursive call, remove the last character from the **current** string to revert it back to the previous state. This is necessary to explore other possibilities and combinations.\\n6. Call the **backtrack** function initially with an empty **current** string, and both **open** and **close** counts set to 0.\\n7. Finally, return the **result** vector containing all valid combinations of parentheses.\\n\\nThe backtracking algorithm explores all possible combinations of parentheses by making recursive calls, adding opening parentheses when there are still available, and adding closing parentheses when there are more openings than closings. This guarantees that all valid combinations of parentheses of length 2 * n are generated.\\n\\n# Complexity\\n- Time complexity:\\n$$O(C(n))$$, where $$C(n)$$ is the Catalan number, which is approximately $$4^n/n^{3/2}$$\\n\\n- Space complexity:\\n$$O(C(n))$$, where $$C(n)$$ is the Catalan number, which is approximately $$4^n/n^{3/2}$$\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    void backtrack(vector<string>& result, string& current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        \\n        if (open < n) {\\n            current.push_back(\\'(\\');\\n            backtrack(result, current, open + 1, close, n);\\n            current.pop_back();\\n        }\\n        \\n        if (close < open) {\\n            current.push_back(\\')\\');\\n            backtrack(result, current, open, close + 1, n);\\n            current.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        string current;\\n        \\n        backtrack(result, current, 0, 0, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void backtrack(vector<string>& result, string& current, int open, int close, int n) {\\n        if (current.length() == 2 * n) {\\n            result.push_back(current);\\n            return;\\n        }\\n        \\n        if (open < n) {\\n            current.push_back(\\'(\\');\\n            backtrack(result, current, open + 1, close, n);\\n            current.pop_back();\\n        }\\n        \\n        if (close < open) {\\n            current.push_back(\\')\\');\\n            backtrack(result, current, open, close + 1, n);\\n            current.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        string current;\\n        \\n        backtrack(result, current, 0, 0, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375419,
                "title": "typescript-javascript-recursive-approach-to-generate-valid-parens",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first i generated all combinations of parens and then filtered them down based on if it was valid\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBetter (this) approach is to add an open or closed paren if either one is a valid option. \\n\\nIf there are any open parens left to add, you can always add an open paren. \\n\\nif there are more open parens then closed ones, you can add a closed paren.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction generateParenthesis(n: number): string[] {\\n    /*\\n        create all possible valid combinations\\n        at each \\n    */\\n    const allCombos = []\\n\\n    function recurse(\\n        openParens: number, closedParens: number, combo: string\\n    ) {\\n        if (openParens === 0 && closedParens === 0) {\\n            allCombos.push(combo)\\n            return\\n        }\\n        \\n        // if there are open parens to close\\n        if (openParens < closedParens) {\\n            recurse(openParens, closedParens - 1, combo + \\')\\')\\n        }\\n\\n        // if there are open parens left to use\\n        if (openParens > 0) {\\n            recurse(openParens - 1, closedParens, combo + \\'(\\')\\n        }\\n    }\\n\\n    recurse(n, n, \\'\\')\\n\\n    return allCombos\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction generateParenthesis(n: number): string[] {\\n    /*\\n        create all possible valid combinations\\n        at each \\n    */\\n    const allCombos = []\\n\\n    function recurse(\\n        openParens: number, closedParens: number, combo: string\\n    ) {\\n        if (openParens === 0 && closedParens === 0) {\\n            allCombos.push(combo)\\n            return\\n        }\\n        \\n        // if there are open parens to close\\n        if (openParens < closedParens) {\\n            recurse(openParens, closedParens - 1, combo + \\')\\')\\n        }\\n\\n        // if there are open parens left to use\\n        if (openParens > 0) {\\n            recurse(openParens - 1, closedParens, combo + \\'(\\')\\n        }\\n    }\\n\\n    recurse(n, n, \\'\\')\\n\\n    return allCombos\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164881,
                "title": "easy-c-solution",
                "content": "# Intuition\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     void helper(vector<string> &v, int n, int oc, int cc, string s)\\n     {\\n         if(oc==n && cc==n){\\n             v.push_back(s);\\n             return ;\\n         }\\n         if(oc<n){\\n             helper(v,n,oc+1,cc,s+\"(\");\\n         }\\n         if(cc < oc){\\n             helper(v,n,oc, cc+1, s+\")\");\\n         }\\n\\n     }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        int oc=0, cc=0;\\n        helper(v,n,oc,cc,\"\");\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void helper(vector<string> &v, int n, int oc, int cc, string s)\\n     {\\n         if(oc==n && cc==n){\\n             v.push_back(s);\\n             return ;\\n         }\\n         if(oc<n){\\n             helper(v,n,oc+1,cc,s+\"(\");\\n         }\\n         if(cc < oc){\\n             helper(v,n,oc, cc+1, s+\")\");\\n         }\\n\\n     }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> v;\\n        int oc=0, cc=0;\\n        helper(v,n,oc,cc,\"\");\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035511,
                "title": "easiest-faang-method-ever",
                "content": "---\\n# \\uD83D\\uDE03***Please do Upvote if it helps \\u2764\\uFE0F***\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^n + n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void parentheses(int open, int closed, string &s, vector<string> &ans){\\n        if(open == 0 && closed == 0){\\n            ans.emplace_back(s);\\n            return;\\n        }\\n        if(open>0){\\n            s+=\"(\";\\n            parentheses(open-1, closed, s, ans);\\n            s.pop_back();\\n        }\\n        if(closed>0 && closed>open){\\n            s+=\")\";\\n            parentheses(open, closed-1, s, ans);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s=\"(\";\\n        int open = n-1;\\n        int closed = n;\\n        parentheses(open, closed, s, ans); \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void parentheses(int open, int closed, string &s, vector<string> &ans){\\n        if(open == 0 && closed == 0){\\n            ans.emplace_back(s);\\n            return;\\n        }\\n        if(open>0){\\n            s+=\"(\";\\n            parentheses(open-1, closed, s, ans);\\n            s.pop_back();\\n        }\\n        if(closed>0 && closed>open){\\n            s+=\")\";\\n            parentheses(open, closed-1, s, ans);\\n            s.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string s=\"(\";\\n        int open = n-1;\\n        int closed = n;\\n        parentheses(open, closed, s, ans); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841085,
                "title": "simple-java-recursion-and-backtracking",
                "content": "\\nIdea is to recursively explore all valid combinations.\\n    There are 2 options in every step.\\n        \\n1. Open: if there are more paranthesis to open. if there is an open paranthesis, there must be a close paranthesis too. So increment closable by 1.\\n1. Cose: recursively do this iff there are any closable paranthesis left.\\n\\n```\\n\\nclass Solution {\\n    \\n    private List<String> res = new ArrayList<>();\\n    \\n    public List<String> generateParenthesis(int n) {\\n         rec(n,0,\"\");\\n        return res;\\n    }\\n\\t\\n    void rec(int rem, int closable, String cur){\\n        \\n        if(rem==0 && closable==0){\\n            res.add(cur);\\n            return;\\n        }\\n        \\n        if(rem>0)\\n            rec(rem-1, closable+1, cur+\"(\");\\n        \\n        if(closable>0)\\n            rec(rem,closable-1,cur+\")\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    private List<String> res = new ArrayList<>();\\n    \\n    public List<String> generateParenthesis(int n) {\\n         rec(n,0,\"\");\\n        return res;\\n    }\\n\\t\\n    void rec(int rem, int closable, String cur){\\n        \\n        if(rem==0 && closable==0){\\n            res.add(cur);\\n            return;\\n        }\\n        \\n        if(rem>0)\\n            rec(rem-1, closable+1, cur+\"(\");\\n        \\n        if(closable>0)\\n            rec(rem,closable-1,cur+\")\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518802,
                "title": "simple-solution-explained",
                "content": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        #Answer will be returned in this result array.\\n        result = []\\n        \\n        #openCount: How many open parentheses ie how many \"(\" are there in the string\\n        #closeCount: How many close parentheses ie how many \")\" are there in the string\\n        def generateSequence(string, openCount, closeCount):\\n            #if string length is 2n ie you have generated the required sequence. \\n            #Now you can add this to the result.\\n            if len(string) == 2*n:\\n                result.append(string)\\n                return\\n            \\n            #Add open parentheses only if openCount is less than 0\\n            #remember open and close count start from 0 and not from 1.\\n            if openCount < n:\\n                generateSequence(string+\"(\", openCount+1, closeCount)\\n            #Add close parentheses only if closeCount is less than 0 and also \\n            #close count is less than open count.\\n            #you cant have close parentheses before you have an open parenteses\\n            #This condition takes care of that. \\n            if closeCount < n and closeCount < openCount:\\n                generateSequence(string+\")\", openCount, closeCount+1)\\n            \\n        #Initially string is empty\\n        #and counts are both 0\\n        generateSequence(\"\", 0, 0)\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        #Answer will be returned in this result array.\\n        result = []\\n        \\n        #openCount: How many open parentheses ie how many \"(\" are there in the string\\n        #closeCount: How many close parentheses ie how many \")\" are there in the string\\n        def generateSequence(string, openCount, closeCount):\\n            #if string length is 2n ie you have generated the required sequence. \\n            #Now you can add this to the result.\\n            if len(string) == 2*n:\\n                result.append(string)\\n                return\\n            \\n            #Add open parentheses only if openCount is less than 0\\n            #remember open and close count start from 0 and not from 1.\\n            if openCount < n:\\n                generateSequence(string+\"(\", openCount+1, closeCount)\\n            #Add close parentheses only if closeCount is less than 0 and also \\n            #close count is less than open count.\\n            #you cant have close parentheses before you have an open parenteses\\n            #This condition takes care of that. \\n            if closeCount < n and closeCount < openCount:\\n                generateSequence(string+\")\", openCount, closeCount+1)\\n            \\n        #Initially string is empty\\n        #and counts are both 0\\n        generateSequence(\"\", 0, 0)\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 2299428,
                "title": "java-c-javascript-100-fully-explained-with-comments-very-easy",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        //Create a list that will store the solution\\n        List<String> sol = new ArrayList<>();\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", sol, n);\\n        return sol;\\n    }\\n    \\n    private void generator(int op, int cl, String str, List<String> sol, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.add(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    //Create a list that will store the solution\\n    vector<string> sol;\\n    \\n    void generator(int op, int cl, string str, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.push_back(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n)\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', n);\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl)\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', n);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", n);\\n        return sol;   \\n    }\\n};\\n```\\n\\n# **Javascript Solution:**\\n```\\nvar generateParenthesis = function(n) {\\n    //Create a list that will store the solution\\n    const sol = [];\\n    //Recursively call backtracking function\\n    generator(0, 0, \"\", sol, n);\\n    return sol;\\n};\\n\\nfunction generator(op, cl, str, sol, n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op === n && cl === n) {\\n            //add the string(str) to the list\\n            sol.push(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        //Create a list that will store the solution\\n        List<String> sol = new ArrayList<>();\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", sol, n);\\n        return sol;\\n    }\\n    \\n    private void generator(int op, int cl, String str, List<String> sol, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.add(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    //Create a list that will store the solution\\n    vector<string> sol;\\n    \\n    void generator(int op, int cl, string str, int n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op == n && cl == n) {\\n            //add the string(str) to the list\\n            sol.push_back(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n)\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', n);\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl)\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', n);\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        //Recursively call backtracking function\\n        generator(0, 0, \"\", n);\\n        return sol;   \\n    }\\n};\\n```\n```\\nvar generateParenthesis = function(n) {\\n    //Create a list that will store the solution\\n    const sol = [];\\n    //Recursively call backtracking function\\n    generator(0, 0, \"\", sol, n);\\n    return sol;\\n};\\n\\nfunction generator(op, cl, str, sol, n) {\\n        //Check the base case.\\n        //If number of opening and closing parentheses are equal to n..\\n        if(op === n && cl === n) {\\n            //add the string(str) to the list\\n            sol.push(str);\\n            return;\\n        }\\n        //if no. of opening parentheses(op) is less than n...\\n        if(op < n) {\\n            //add \\'(\\' to the current string and increment the count of opening parenthesis(op)\\n            generator(op + 1, cl, str + \\'(\\', sol, n);\\n        }\\n        //if no. of closing parentheses is less than open parentheses...\\n        if(cl < n && op > cl) {\\n            //add \\')\\' to the current string and increment the count of closing parentheses(cl)\\n            generator(op, cl + 1, str + \\')\\', sol, n);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140410,
                "title": "java-backtracking-detailed-explanation",
                "content": "```\\n/*\\nClassic Backtracking Problem\\nFor a Backtracking Problem : Remember the 3 Parts\\n1. Choices\\n2. Constraints\\n3. Goal Condition\\n\\n1. The Choices in this case is to either put a \"(\" or \")\"\\n2. The Constraints are\\n   (a) -> The number of openBrackets or ClosedBrackets cannot be more than n\\n   (b) -> A ClosedBracket cannot be added to an empty string, i.e. a corresponding open bracket is needed\\n   (c) -> The count of closedBracket cannot be more than that of OpenBracket at any given time\\n3. The Goal Condition is when the length of the string becomes 2*n\\n\\n*/\\n\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        backTrack(\"\",res,0,0,n);\\n        return res;\\n    }\\n    \\n    public void backTrack(String currWord, List<String> res,int openCount, int closedCount, int n){\\n        //If the Goal Condition is reached\\n        if(currWord.length()==n*2){\\n            res.add(currWord);\\n            return;\\n        }\\n        \\n        //If the number of openBrackets are less than n, keeping recursively calling\\n        if(openCount<n){\\n            backTrack(currWord + \"(\", res, openCount+1, closedCount, n);\\n        }\\n        \\n        //If the count of closedBrackets is less than openCount -> It is valid to add\\n        if(closedCount<openCount){\\n            backTrack(currWord + \")\", res, openCount, closedCount+1, n);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n/*\\nClassic Backtracking Problem\\nFor a Backtracking Problem : Remember the 3 Parts\\n1. Choices\\n2. Constraints\\n3. Goal Condition\\n\\n1. The Choices in this case is to either put a \"(\" or \")\"\\n2. The Constraints are\\n   (a) -> The number of openBrackets or ClosedBrackets cannot be more than n\\n   (b) -> A ClosedBracket cannot be added to an empty string, i.e. a corresponding open bracket is needed\\n   (c) -> The count of closedBracket cannot be more than that of OpenBracket at any given time\\n3. The Goal Condition is when the length of the string becomes 2*n\\n\\n*/\\n\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new ArrayList<String>();\\n        backTrack(\"\",res,0,0,n);\\n        return res;\\n    }\\n    \\n    public void backTrack(String currWord, List<String> res,int openCount, int closedCount, int n){\\n        //If the Goal Condition is reached\\n        if(currWord.length()==n*2){\\n            res.add(currWord);\\n            return;\\n        }\\n        \\n        //If the number of openBrackets are less than n, keeping recursively calling\\n        if(openCount<n){\\n            backTrack(currWord + \"(\", res, openCount+1, closedCount, n);\\n        }\\n        \\n        //If the count of closedBrackets is less than openCount -> It is valid to add\\n        if(closedCount<openCount){\\n            backTrack(currWord + \")\", res, openCount, closedCount+1, n);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519267,
                "title": "brute-force-to-optimized-approach-c",
                "content": "# **Brute Force**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int n,vector<string>&res,int open=0,int close=0,string str=\"\"){\\n        if(open>n || close>n){\\n            return 0;\\n        }\\n        if(open+close==2*n){\\n            res.push_back(str);\\n            return 1;\\n        }\\n        int o=0,c=0;\\n        o=solve(n,res,open+1,close,str+\"(\");\\n        if(open>close){\\n            =solve(n,res,open,close+1,str+\")\");\\n        }\\n        \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>res;\\n        solve(n,res);\\n        return res;\\n    }\\n};\\n```\\n**Time Complexity is O(2^(2*N))** \\n**Space Complexity is O(2*N) (due to stack)**\\nNow this will pass because the constraint n is very small.\\nBut in case of larger n we will have to resort to Some other approach.\\n\\n# **Optimized approach**\\nWhen we look into the pattern we see that it forms overlaping subproblems.\\nSuppose dp[i] contains all the valid parentheses possible of length 2*i. \\nSuppose you got dp[2] which is { (()) , ()() }. Now what will be dp[3]? It can be written as -\\n\\n( + dp[0] + ) + dp[2] = ()(()) and ()()()\\n( + dp[1] + ) + dp[1] = (())()\\n( + dp[2] + ) + dp[0] = ((())) and (()())\\n\\nhere we see that instead of doing the recusion of we store these values \\n**Using Bottom Up DP**\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<vector<string>>dp(n+1);\\n        dp[0]={\"\"};\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**Time Complexity O(N^4)**\\n**Space Complexity O(N*N)**\\n\\n\\n# **Futher Optimization**\\nnow we can decalrte a global variable and checking in the first loop if that had been covered in previous iteration then skip it.\\nThus further reducing time complexity though it increases space complexity.\\n```\\nclass Solution {\\nvector<vector<string>>dp;\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        dp.resize(n+1);\\n        dp[0]={\"\"};\\n        for(int i=1;i<=n;i++){\\n            if(dp[i].size()){\\n                continue;\\n            }\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int n,vector<string>&res,int open=0,int close=0,string str=\"\"){\\n        if(open>n || close>n){\\n            return 0;\\n        }\\n        if(open+close==2*n){\\n            res.push_back(str);\\n            return 1;\\n        }\\n        int o=0,c=0;\\n        o=solve(n,res,open+1,close,str+\"(\");\\n        if(open>close){\\n            =solve(n,res,open,close+1,str+\")\");\\n        }\\n        \\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string>res;\\n        solve(n,res);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<vector<string>>dp(n+1);\\n        dp[0]={\"\"};\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\nvector<vector<string>>dp;\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        dp.resize(n+1);\\n        dp[0]={\"\"};\\n        for(int i=1;i<=n;i++){\\n            if(dp[i].size()){\\n                continue;\\n            }\\n            for(int j=0;j<i;j++){\\n                vector<string>left=dp[j];\\n                vector<string>right=dp[i-j-1];\\n                for(auto &l:left){\\n                    for(auto &r:right){\\n                        dp[i].push_back(\"(\"+l+\")\"+r);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462096,
                "title": "dynamic-programming-java-memory-beats-85",
                "content": "Instead of using backtrack - which is a little bit hard to handle - I used a Dynamic Programming method that does not involve recursion. \\n\\nThe gist is as such:\\n\\nWe create the parenthesis array for n by adding \"()\" inside of, and in parallel with, another \"()\" for every string element in the \"n-1\" parenthesis array. \\n\\nThis may look a bit confusing. Let me explain using an example. \\n\\nThe \"n=1\" array is a single \"( )\".\\n\\nTo create the \"n=2\" array, we add another \"()\" both inside of, and in parrallel with the existing \"()\". Therefore we have such: [ \"( )( )\", \"(( ))\"]\\n\\nTo create the \"n=3\" array, we do the above operation to each and every element in the \"n=2\" array. \\n\\nSo, for \"( ) ( )\", we have \"( ) ( ) ( )\" , \"( ( ) ) ( )\", and \"( ) ( ( ) )\". \\nAnd for \"( ( ) ) \", we have \" ( ( ) ( ) ) \"and \"( ( ( ) ) )\".\\n\\nTherefore, for n=3 we have an array that reads :\\n\\n[\"( ) ( ) ( )\",  \"( ( ) ) ( )\", \"( ) ( ( ) )\",  \"( ( ) ) \", \" ( ( ) ( ) ) \", \"( ( ( ) ) )\"]\\n\\nNote that sometimes, you may end up creating duplicate entries. Luckily we can use a hashset to remove them automatically.\\n\\nwhen n =4, we repeat the same operation to EACH AND EVERY element in the n=3 array.\\n\\n```\\n  public List<String> generateParenthesis(int n) {\\n        List<String> first = Arrays.asList(\"()\");\\n        if (n == 1) return first;\\n        for (int i = 1; i < n; i++) {\\n            HashSet<String> set = this.processStrings(first);\\n            first = new ArrayList<>();\\n            for (String ss : set) {\\n//                System.out.println(ss);\\n                first.add(ss);\\n            }\\n        }\\n        for (String s : first) {\\n            System.out.println(s);\\n        }\\n\\n        return first;\\n    }\\n\\n\\n    private HashSet<String> processStrings(List<String> strings) {\\n\\n        HashSet<String> set = new HashSet<>();\\n\\n        for (String s : strings) {\\n            this.processString(s, set);\\n        }\\n        return set;\\n    }\\n\\n    private void processString(String s, HashSet<String> set) {\\n        int index = 0;\\n        while (s.indexOf(\"()\", index) != -1) {\\n\\n            index = s.indexOf(\"()\", index) + 1;\\n\\n            String newString;\\n            String newString2;\\n            if (index < s.length() - 1) {\\n\\n                s.substring(0, index);\\n                s.substring(index + 2);\\n                newString = s.substring(0, index - 1) + \"()()\" + s.substring(index + 1);\\n                newString2 = s.substring(0, index - 1) + \"(())\" + s.substring(index + 1);\\n\\n                set.add(newString);\\n                set.add(newString2);\\n\\n            } else if (index == s.length() - 1) {\\n                newString = s.substring(0, index - 1) + \"()()\";\\n                newString2 = s.substring(0, index - 1) + \"(())\";\\n\\n                set.add(newString);\\n                set.add(newString2);\\n            }\\n        }\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n  public List<String> generateParenthesis(int n) {\\n        List<String> first = Arrays.asList(\"()\");\\n        if (n == 1) return first;\\n        for (int i = 1; i < n; i++) {\\n            HashSet<String> set = this.processStrings(first);\\n            first = new ArrayList<>();\\n            for (String ss : set) {\\n//                System.out.println(ss);\\n                first.add(ss);\\n            }\\n        }\\n        for (String s : first) {\\n            System.out.println(s);\\n        }\\n\\n        return first;\\n    }\\n\\n\\n    private HashSet<String> processStrings(List<String> strings) {\\n\\n        HashSet<String> set = new HashSet<>();\\n\\n        for (String s : strings) {\\n            this.processString(s, set);\\n        }\\n        return set;\\n    }\\n\\n    private void processString(String s, HashSet<String> set) {\\n        int index = 0;\\n        while (s.indexOf(\"()\", index) != -1) {\\n\\n            index = s.indexOf(\"()\", index) + 1;\\n\\n            String newString;\\n            String newString2;\\n            if (index < s.length() - 1) {\\n\\n                s.substring(0, index);\\n                s.substring(index + 2);\\n                newString = s.substring(0, index - 1) + \"()()\" + s.substring(index + 1);\\n                newString2 = s.substring(0, index - 1) + \"(())\" + s.substring(index + 1);\\n\\n                set.add(newString);\\n                set.add(newString2);\\n\\n            } else if (index == s.length() - 1) {\\n                newString = s.substring(0, index - 1) + \"()()\";\\n                newString2 = s.substring(0, index - 1) + \"(())\";\\n\\n                set.add(newString);\\n                set.add(newString2);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1361937,
                "title": "recursive-tree-and-implementation",
                "content": "![image](https://assets.leetcode.com/users/images/d795b906-b24a-4a0a-9297-11c542243397_1627219155.438998.png)\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void func(string &s , int open , int close){\\n        if (open == 0 and close == 0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > close or open < 0 or close < 0)\\n            return;\\n        s.push_back(\\'(\\');\\n        func(s , open-1 , close);\\n        s.pop_back();\\n        s.push_back(\\')\\');\\n        func(s , open , close-1);\\n        s.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        func(s , n , n);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void func(string &s , int open , int close){\\n        if (open == 0 and close == 0){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (open > close or open < 0 or close < 0)\\n            return;\\n        s.push_back(\\'(\\');\\n        func(s , open-1 , close);\\n        s.pop_back();\\n        s.push_back(\\')\\');\\n        func(s , open , close-1);\\n        s.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        func(s , n , n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322204,
                "title": "c-solution-using-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n   static bool isValid(string m)\\n    {\\n        if(m[0]==\\')\\')\\n            return false;\\n        stack<string> s;\\n        for(int i =0;i<m.length();i++)\\n        {\\n            if(m[i]==\\'(\\')\\n                s.push(\"(\");\\n            else if(s.empty()&&m[i]==\\')\\')\\n                    return false;\\n            else if(m[i]==\\')\\')\\n                s.pop();\\n        }\\n        if(s.empty())\\n            return true;\\n        else\\n            return false;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        vector<string> v;\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\"(\";\\n        }\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\")\";\\n        }\\n        v.push_back(s);\\n        while(next_permutation(s.begin(),s.end()))\\n        {\\n            if(isValid(s))\\n                v.push_back(s);\\n        }      \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static bool isValid(string m)\\n    {\\n        if(m[0]==\\')\\')\\n            return false;\\n        stack<string> s;\\n        for(int i =0;i<m.length();i++)\\n        {\\n            if(m[i]==\\'(\\')\\n                s.push(\"(\");\\n            else if(s.empty()&&m[i]==\\')\\')\\n                    return false;\\n            else if(m[i]==\\')\\')\\n                s.pop();\\n        }\\n        if(s.empty())\\n            return true;\\n        else\\n            return false;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        vector<string> v;\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\"(\";\\n        }\\n        for(int i =0;i<n;i++)\\n        {\\n            s+=\")\";\\n        }\\n        v.push_back(s);\\n        while(next_permutation(s.begin(),s.end()))\\n        {\\n            if(isValid(s))\\n                v.push_back(s);\\n        }      \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295346,
                "title": "100-faster-c-i-e-0ms-with-explanation",
                "content": "\\n    vector<string> ans; //container of  all possible answers\\n    void dfs(string& path, int open, int close){\\n        if(open==0 and close==0){  // here we donot have either of the bracket so add it to our answer\\n            ans.push_back(path);\\n            return ;\\n        }\\n        if(open>0){ // here we still can add more open brackets in out answers\\n            path.push_back(\\'(\\');\\n            dfs(path, open-1, close); // now update the open \\n            path.pop_back(); // yes we did the backtrack here to try out all possibility\\n        }\\n        if(close>0 and open < close){ // if and only if we have close brackets and at this current sopt we have more number of open brackets than close ones.\\n            path.push_back(\\')\\');\\n            dfs(path,open,close-1);\\n            path.pop_back(); // here also we need to backtrack\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s; // initial path ie. blank\\n        // in starting we have n number of open and n number of close brackets \\n        dfs(s,n,n); // ran a sort of dfs tried out all possibility\\n        return ans; // return the ans at last when we are done\\n    }",
                "solutionTags": [],
                "code": "\\n    vector<string> ans; //container of  all possible answers\\n    void dfs(string& path, int open, int close){\\n        if(open==0 and close==0){  // here we donot have either of the bracket so add it to our answer\\n            ans.push_back(path);\\n            return ;\\n        }\\n        if(open>0){ // here we still can add more open brackets in out answers\\n            path.push_back(\\'(\\');\\n            dfs(path, open-1, close); // now update the open \\n            path.pop_back(); // yes we did the backtrack here to try out all possibility\\n        }\\n        if(close>0 and open < close){ // if and only if we have close brackets and at this current sopt we have more number of open brackets than close ones.\\n            path.push_back(\\')\\');\\n            dfs(path,open,close-1);\\n            path.pop_back(); // here also we need to backtrack\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        string s; // initial path ie. blank\\n        // in starting we have n number of open and n number of close brackets \\n        dfs(s,n,n); // ran a sort of dfs tried out all possibility\\n        return ans; // return the ans at last when we are done\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1191129,
                "title": "c-recursive-solution-with-detailed-explanation",
                "content": "An integer value N is given as input. Total number of opening brackets = Total number of closing brackets = N. A recursive function solve is called with parameters open(no. of opening brackets), close(no. of closing brackets), current string and final answer res which is passed by reference.\\n\\nIf number of opening brackets = number of closing brackets = n, this implies leaf node has been reached in recursion tree and thus it is added to the res. If no. of opening brackets is not equal to 0 add an opening bracket to the current string and decrement the count of open and recursively call the function for new values.\\n\\nIf no. of closing brackets is greater than number of opening brackets then a closing bracket is added to the current string and count of close is decremented by 1 and the function is recursively called for new values.\\n\\n\\n    void solve(int open, int close, string str, vector<string>& res)\\n    {\\n        if(open == 0 && close == 0)\\n        {\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(open != 0)\\n        {\\n            string str1 = str;\\n            str1.push_back(\\'(\\');\\n            solve(open - 1, close, str1, res);\\n        }\\n        \\n        if(close > open)\\n        {\\n            string str2 = str;\\n            str2.push_back(\\')\\');\\n            solve(open, close - 1, str2, res);\\n        }\\n        \\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) \\n    {\\n        vector<string> res;\\n        int open = n;\\n        int close = n;\\n        \\n        string str = \"\";\\n        \\n        solve(open, close, str, res);\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "An integer value N is given as input. Total number of opening brackets = Total number of closing brackets = N. A recursive function solve is called with parameters open(no. of opening brackets), close(no. of closing brackets), current string and final answer res which is passed by reference.\\n\\nIf number of opening brackets = number of closing brackets = n, this implies leaf node has been reached in recursion tree and thus it is added to the res. If no. of opening brackets is not equal to 0 add an opening bracket to the current string and decrement the count of open and recursively call the function for new values.\\n\\nIf no. of closing brackets is greater than number of opening brackets then a closing bracket is added to the current string and count of close is decremented by 1 and the function is recursively called for new values.\\n\\n\\n    void solve(int open, int close, string str, vector<string>& res)\\n    {\\n        if(open == 0 && close == 0)\\n        {\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(open != 0)\\n        {\\n            string str1 = str;\\n            str1.push_back(\\'(\\');\\n            solve(open - 1, close, str1, res);\\n        }\\n        \\n        if(close > open)\\n        {\\n            string str2 = str;\\n            str2.push_back(\\')\\');\\n            solve(open, close - 1, str2, res);\\n        }\\n        \\n        return;\\n    }\\n    \\n    vector<string> generateParenthesis(int n) \\n    {\\n        vector<string> res;\\n        int open = n;\\n        int close = n;\\n        \\n        string str = \"\";\\n        \\n        solve(open, close, str, res);\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1134167,
                "title": "60ms-faster-than-100-of-js-submissions",
                "content": "```\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const go = (s=\"\",l=0,r=0)=>{\\n        if(s.length===2*n){\\n            res.push(s);\\n            return;\\n        }\\n        if(l<n) go(s+\\'(\\',l+1,r);\\n        if(r<l) go(s+\\')\\',l,r+1);\\n    }\\n    go();\\n    return res;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar generateParenthesis = function(n) {\\n    let res = [];\\n    const go = (s=\"\",l=0,r=0)=>{\\n        if(s.length===2*n){\\n            res.push(s);\\n            return;\\n        }\\n        if(l<n) go(s+\\'(\\',l+1,r);\\n        if(r<l) go(s+\\')\\',l,r+1);\\n    }\\n    go();\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1056871,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    \\n    List<String> arr = new ArrayList<String>();\\n    int finalLength;\\n    public List<String> generateParenthesis(int n) {\\n        this.finalLength = 2* n;\\n        helper(2*n, \"\");\\n        \\n        List<String> ans = new ArrayList<String>();\\n        for(String str: arr)\\n        {\\n            //System.out.println(str);\\n            if(check(str))\\n                ans.add(str);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    public void helper(int n, String str)\\n    {\\n        if(str.length() == finalLength)\\n            arr.add(str);\\n        if(n <= 0)\\n            return;\\n        \\n        String str1 = new String(str + \"(\");\\n        String str2 = new String(str + \")\");\\n        helper(n-1, str1);\\n        helper(n-1, str2);\\n        \\n    }\\n    \\n    \\n    public boolean check(String str)\\n    {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch: str.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n                stack.push(ch);\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty() || stack.peek()!=\\'(\\')\\n                    return false;\\n                stack.pop();\\n            }\\n        }\\n        if(!stack.isEmpty())\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<String> arr = new ArrayList<String>();\\n    int finalLength;\\n    public List<String> generateParenthesis(int n) {\\n        this.finalLength = 2* n;\\n        helper(2*n, \"\");\\n        \\n        List<String> ans = new ArrayList<String>();\\n        for(String str: arr)\\n        {\\n            //System.out.println(str);\\n            if(check(str))\\n                ans.add(str);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    public void helper(int n, String str)\\n    {\\n        if(str.length() == finalLength)\\n            arr.add(str);\\n        if(n <= 0)\\n            return;\\n        \\n        String str1 = new String(str + \"(\");\\n        String str2 = new String(str + \")\");\\n        helper(n-1, str1);\\n        helper(n-1, str2);\\n        \\n    }\\n    \\n    \\n    public boolean check(String str)\\n    {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch: str.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n                stack.push(ch);\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty() || stack.peek()!=\\'(\\')\\n                    return false;\\n                stack.pop();\\n            }\\n        }\\n        if(!stack.isEmpty())\\n            return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996790,
                "title": "this-c-solution-is-very-easy-to-understand-beats-100-illustration",
                "content": "From the recusrive tree its very easy to find the base cases and operation, Hope it help a lot. (vote - up)\\n```\\nclass Solution {\\n    vector<string> s;\\npublic:\\n    \\n    void solve(string combi, int n, int mimicStack) {\\n        if(n == 0 && mimicStack == 0)\\n            s.push_back(combi);\\n        \\n        if(n > 0)\\n            solve(combi + \\'(\\', n-1, mimicStack+1);\\n\\n        if(mimicStack > 0)\\n            solve(combi + \\')\\', n, mimicStack-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        solve(\"\", n, 0);\\n        return s;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/df18629d-7750-4d86-9dcb-793a36046dfe_1609517768.9531047.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> s;\\npublic:\\n    \\n    void solve(string combi, int n, int mimicStack) {\\n        if(n == 0 && mimicStack == 0)\\n            s.push_back(combi);\\n        \\n        if(n > 0)\\n            solve(combi + \\'(\\', n-1, mimicStack+1);\\n\\n        if(mimicStack > 0)\\n            solve(combi + \\')\\', n, mimicStack-1);\\n    }\\n    \\n    vector<string> generateParenthesis(int n) {\\n        solve(\"\", n, 0);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960608,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(string &str,int open_count,int close_count,vector<string> &ans){\\n        if(open_count==0 && close_count==0){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open_count>0){\\n            str.push_back(\\'(\\');\\n            solve(str,open_count-1,close_count,ans);\\n            str.pop_back();\\n        }\\n        \\n        if(close_count>open_count){\\n            str.push_back(\\')\\');\\n            solve(str,open_count,close_count-1,ans);\\n            str.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string str;\\n        solve(str,n,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(string &str,int open_count,int close_count,vector<string> &ans){\\n        if(open_count==0 && close_count==0){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(open_count>0){\\n            str.push_back(\\'(\\');\\n            solve(str,open_count-1,close_count,ans);\\n            str.pop_back();\\n        }\\n        \\n        if(close_count>open_count){\\n            str.push_back(\\')\\');\\n            solve(str,open_count,close_count-1,ans);\\n            str.pop_back();\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        string str;\\n        solve(str,n,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796042,
                "title": "simple-python-solution",
                "content": "Simple python solution\\n\\n``` python\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        allOutput = set([])\\n        def dfs(output, numOfLeft, numOfRight, n):\\n            if len(output) == n * 2:\\n                allOutput.add(output)\\n                return\\n            if numOfLeft < n:\\n                dfs(output + \\'(\\', numOfLeft + 1, numOfRight, n)\\n            if numOfLeft > numOfRight and numOfRight < n:\\n                dfs(output + \\')\\', numOfLeft, numOfRight + 1, n)\\n        dfs(\\'(\\', 1, 0, n)\\n        return allOutput\\n```",
                "solutionTags": [],
                "code": "``` python\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        allOutput = set([])\\n        def dfs(output, numOfLeft, numOfRight, n):\\n            if len(output) == n * 2:\\n                allOutput.add(output)\\n                return\\n            if numOfLeft < n:\\n                dfs(output + \\'(\\', numOfLeft + 1, numOfRight, n)\\n            if numOfLeft > numOfRight and numOfRight < n:\\n                dfs(output + \\')\\', numOfLeft, numOfRight + 1, n)\\n        dfs(\\'(\\', 1, 0, n)\\n        return allOutput\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 653526,
                "title": "java-dfs",
                "content": "![image](https://assets.leetcode.com/users/chuanqiu/image_1590767732.png)\\n\\n```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new LinkedList<>();\\n        if(n == 0) return res;\\n        dfs(\"\",0,0,n,res);\\n        return res;        \\n    }\\n    \\n     /**\\n     * @param curStr       The result of the current recursion\\n     * @param left          How much left bracket has been used\\n     * @param right  \\n     * @param n      \\n     * @param res         result set\\n     */\\n    \\n    public void dfs(String curstr, int left, int right, int n, List<String> res){\\n        if(left ==n && right ==n){\\n            res.add(curstr);\\n            return;\\n        }\\n        //unsatisfied condition, cut off\\n        if(left < right){\\n            return;\\n        }\\n        \\n        if(left<n){\\n            dfs(curstr+\"(\",left+1,right,n,res);\\n        }\\n        \\n         if(right<n){\\n            dfs(curstr+\")\",left,right+1,n,res);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n        List<String> res = new LinkedList<>();\\n        if(n == 0) return res;\\n        dfs(\"\",0,0,n,res);\\n        return res;        \\n    }\\n    \\n     /**\\n     * @param curStr       The result of the current recursion\\n     * @param left          How much left bracket has been used\\n     * @param right  \\n     * @param n      \\n     * @param res         result set\\n     */\\n    \\n    public void dfs(String curstr, int left, int right, int n, List<String> res){\\n        if(left ==n && right ==n){\\n            res.add(curstr);\\n            return;\\n        }\\n        //unsatisfied condition, cut off\\n        if(left < right){\\n            return;\\n        }\\n        \\n        if(left<n){\\n            dfs(curstr+\"(\",left+1,right,n,res);\\n        }\\n        \\n         if(right<n){\\n            dfs(curstr+\")\",left,right+1,n,res);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607754,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\n    vector<string>res;\\n    void dfs(int n, string curr, int left, int right) {\\n        if (left + right == 2*n)\\n            res.push_back(curr);\\n        \\n        if (left < n) dfs(n, curr + \\'(\\', left+1, right);\\n        if (left > right) dfs(n, curr + \\')\\', left, right+1);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string curr;\\n        dfs(n, curr, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<string>res;\\n    void dfs(int n, string curr, int left, int right) {\\n        if (left + right == 2*n)\\n            res.push_back(curr);\\n        \\n        if (left < n) dfs(n, curr + \\'(\\', left+1, right);\\n        if (left > right) dfs(n, curr + \\')\\', left, right+1);\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string curr;\\n        dfs(n, curr, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575711,
                "title": "c-easy-understand-dfs-solution-both-recursive-iterative-version",
                "content": "Sol1 & Sol2 have the same idea.\\n**Sol1: Recursive version**\\n```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0, 0);\\n        return result;\\n    }\\n    void helper(string s, int n, int l, int r){\\n        if (l < r || l > n || r > n) return;  // exceed the bundary -> return\\n\\t    if (l == n && r == n){\\n\\t        result.push_back(s);\\n\\t        return;\\n\\t    }\\n\\t\\thelper(s + \"(\", n, l+1, r);\\n\\t\\thelper(s + \")\", n, l, r+1);\\n    }\\n};\\n```\\n**Sol2: Iterative version**\\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        stack<pair<string, pair<int, int>>> st;\\n        st.push({\"\", {0, 0}});\\n        int l, r;\\n        string s;\\n        while (!st.empty()){\\n            pair<string, pair<int, int>> p;\\n            p = st.top();\\n            st.pop();\\n            l = p.second.first;\\n            r = p.second.second;\\n            s = p.first;\\n            if (l < r || l > n || r > n) continue;    // exceed the bundary -> skip the process below\\n            if (l == n && r == n) result.push_back(s);\\n            st.push({s+\"(\", {l+1, r}});\\n            st.push({s+\")\", {l, r+1}});\\n        }\\n        return result;\\n    } \\n};\\n```\\nTime & Space complexity: Pls refer to the official solution. (It is complex...)",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    vector<string> generateParenthesis(int n) {\\n        helper(\"\", n, 0, 0);\\n        return result;\\n    }\\n    void helper(string s, int n, int l, int r){\\n        if (l < r || l > n || r > n) return;  // exceed the bundary -> return\\n\\t    if (l == n && r == n){\\n\\t        result.push_back(s);\\n\\t        return;\\n\\t    }\\n\\t\\thelper(s + \"(\", n, l+1, r);\\n\\t\\thelper(s + \")\", n, l, r+1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> result;\\n        stack<pair<string, pair<int, int>>> st;\\n        st.push({\"\", {0, 0}});\\n        int l, r;\\n        string s;\\n        while (!st.empty()){\\n            pair<string, pair<int, int>> p;\\n            p = st.top();\\n            st.pop();\\n            l = p.second.first;\\n            r = p.second.second;\\n            s = p.first;\\n            if (l < r || l > n || r > n) continue;    // exceed the bundary -> skip the process below\\n            if (l == n && r == n) result.push_back(s);\\n            st.push({s+\"(\", {l+1, r}});\\n            st.push({s+\")\", {l, r+1}});\\n        }\\n        return result;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504773,
                "title": "swift-closure",
                "content": "Rather than passing inout array inside the backtrack method, I use closure to pass the values over here.\\n\\n``` swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var result = [String]()\\n        backtrack(\"\", 0, 0, n) { result.append($0) }\\n        return result\\n    }\\n\\n    func backtrack(_ current: String,_ open: Int,_ end: Int,_ max: Int, _ result: (String)->Void) {\\n        if current.count == max * 2 {\\n            result(current)\\n            return\\n        }\\n        \\n        if open < max { backtrack(current + \"(\", open + 1, end, max, result) }\\n        if end < open  { backtrack(current + \")\", open, end + 1, max, result) }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "``` swift\\nclass Solution {\\n    func generateParenthesis(_ n: Int) -> [String] {\\n        var result = [String]()\\n        backtrack(\"\", 0, 0, n) { result.append($0) }\\n        return result\\n    }\\n\\n    func backtrack(_ current: String,_ open: Int,_ end: Int,_ max: Int, _ result: (String)->Void) {\\n        if current.count == max * 2 {\\n            result(current)\\n            return\\n        }\\n        \\n        if open < max { backtrack(current + \"(\", open + 1, end, max, result) }\\n        if end < open  { backtrack(current + \")\", open, end + 1, max, result) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503352,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let result = [];\\n    \\n    function go(str, closedLeft, openLeft) {\\n        if (str.length === n*2) {\\n            result.push(str);\\n        }\\n        if (openLeft > 0) {\\n            go(str + \\'(\\', closedLeft + 1, openLeft - 1);\\n        }\\n        if (closedLeft > 0) {\\n            go(str + \\')\\', closedLeft - 1, openLeft);\\n        }\\n    }\\n   \\n    go(\"\", 0, n);\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[]}\\n */\\nvar generateParenthesis = function(n) {\\n    let result = [];\\n    \\n    function go(str, closedLeft, openLeft) {\\n        if (str.length === n*2) {\\n            result.push(str);\\n        }\\n        if (openLeft > 0) {\\n            go(str + \\'(\\', closedLeft + 1, openLeft - 1);\\n        }\\n        if (closedLeft > 0) {\\n            go(str + \\')\\', closedLeft - 1, openLeft);\\n        }\\n    }\\n   \\n    go(\"\", 0, n);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375856,
                "title": "simple-python-solution-without-recursion",
                "content": "```\\n    def generateParenthesis(self, N):\\n        answer, last_results = [], [(\\'(\\', 1, 0)]\\n        while last_results:\\n            new_results = []\\n            for _ in range(len(last_results)):\\n                (result, left, right) = last_results.pop()  # popping is not required, but it saves memory\\n                if right == N and left == N:\\n                    answer.append(result)\\n                else:\\n                    if left < N:\\n                        new_results.append((result + \\'(\\', left+1, right))\\n                    if right < left:\\n                        new_results.append((result + \\')\\', left, right+1))\\n            last_results = new_results\\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def generateParenthesis(self, N):\\n        answer, last_results = [], [(\\'(\\', 1, 0)]\\n        while last_results:\\n            new_results = []\\n            for _ in range(len(last_results)):\\n                (result, left, right) = last_results.pop()  # popping is not required, but it saves memory\\n                if right == N and left == N:\\n                    answer.append(result)\\n                else:\\n                    if left < N:\\n                        new_results.append((result + \\'(\\', left+1, right))\\n                    if right < left:\\n                        new_results.append((result + \\')\\', left, right+1))\\n            last_results = new_results\\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 297416,
                "title": "rust-0ms-solution",
                "content": "```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        let mut result: Vec<String> = vec![];\\n        Self::_gen(&mut result, n, n, \"\".to_string());\\n        result\\n    }\\n    pub fn _gen(result: &mut Vec<String>, left: i32, right: i32, sublist: String) {\\n        if left == 0 && right == 0 {\\n            result.push(sublist);\\n            return;\\n        }\\n        if left > 0 {\\n            Self::_gen(result, left - 1, right, sublist.clone() + \"(\");\\n        }\\n        if right > left {\\n            Self::_gen(result, left, right - 1, sublist.clone() + \")\");\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\\n        let mut result: Vec<String> = vec![];\\n        Self::_gen(&mut result, n, n, \"\".to_string());\\n        result\\n    }\\n    pub fn _gen(result: &mut Vec<String>, left: i32, right: i32, sublist: String) {\\n        if left == 0 && right == 0 {\\n            result.push(sublist);\\n            return;\\n        }\\n        if left > 0 {\\n            Self::_gen(result, left - 1, right, sublist.clone() + \"(\");\\n        }\\n        if right > left {\\n            Self::_gen(result, left, right - 1, sublist.clone() + \")\");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 253175,
                "title": "sweet-old-ruby-solution",
                "content": "```\\ndef generate_parenthesis(n)\\n  recurse(n, 0, 0, \\'\\', [])\\nend\\n\\ndef recurse(n, o, c, cur, res)\\n  res << cur if o + c == 2 * n\\n\\n  recurse(n, o + 1, c, cur + \\'(\\', res) if o < n\\n  recurse(n, o, c + 1, cur + \\')\\', res) if c < o\\n\\n  res\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef generate_parenthesis(n)\\n  recurse(n, 0, 0, \\'\\', [])\\nend\\n\\ndef recurse(n, o, c, cur, res)\\n  res << cur if o + c == 2 * n\\n\\n  recurse(n, o + 1, c, cur + \\'(\\', res) if o < n\\n  recurse(n, o, c + 1, cur + \\')\\', res) if c < o\\n\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 222314,
                "title": "javascript",
                "content": "```\\nvar generateParenthesis = function(n) {\\n  const r = [];\\n  const gen = (left, right, _r) => {\\n    if (left === n && right === n) {\\n      r.push(_r);\\n      return;\\n    }\\n    if (left < n) gen(left + 1, right, `${_r}(`);\\n    if (left > right && right < n) gen(left, right + 1, `${_r})`);\\n  }\\n  \\n  gen(0, 0, \\'\\');\\n  \\n  return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar generateParenthesis = function(n) {\\n  const r = [];\\n  const gen = (left, right, _r) => {\\n    if (left === n && right === n) {\\n      r.push(_r);\\n      return;\\n    }\\n    if (left < n) gen(left + 1, right, `${_r}(`);\\n    if (left > right && right < n) gen(left, right + 1, `${_r})`);\\n  }\\n  \\n  gen(0, 0, \\'\\');\\n  \\n  return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203137,
                "title": "ruby-backtracking-with-example-and-diagram",
                "content": "```ruby\\n# @param {Integer} n\\n# @return {String[]}\\ndef generate_parenthesis(n)\\n    backtrack(n)\\nend\\n\\ndef backtrack(n, s = \"\", l = 0, r = 0, result = [])\\n    if s.size == 2 * n\\n        result.push(s)\\n        return\\n    end\\n\\n    backtrack(n, s + \"(\", l + 1, r, result) if l < n\\n    backtrack(n, s + \")\", l, r + 1, result) if r < l\\n\\n    result\\nend\\n\\n\\n# 22. Generate Parentheses\\n# https://leetcode.com/problems/generate-parentheses/description/\\n\\n# Complexity Analysis\\n# Our complexity analysis rests on understanding how many elements there are in generateParenthesis(n).\\n# This analysis is outside the scope of this article,\\n# but it turns out this is the n-th Catalan number 1/ (n + 1) * (2nCn), which is bounded asymptotically by 4^n / n * sqrt(n).\\n\\n# Time: O(4^n/sqrt(n), Each valid sequence has at most n steps during the backtracking procedure.\\n# Space: O(4^n/sqrt(n), as described above, and using O(n) space to store the sequence.\\n\\n# *** Example: n = 3 *** Space after each DFS instance\\n# backtrack called with  0 0 []\\n#   backtrack called with ( 1 0 []\\n#     backtrack called with (( 2 0 []\\n#       backtrack called with ((( 3 0 []\\n#         backtrack called with ((() 3 1 []\\n#           backtrack called with ((()) 3 2 []\\n#             backtrack called with ((())) 3 3 []\\n#           backtrack return with ((()) 3 2 [\"((()))\"]\\n#         backtrack return with ((() 3 1 [\"((()))\"]\\n#       backtrack return with ((( 3 0 [\"((()))\"]\\n#       backtrack called with (() 2 1 [\"((()))\"]\\n#         backtrack called with (()( 3 1 [\"((()))\"]\\n#           backtrack called with (()() 3 2 [\"((()))\"]\\n#             backtrack called with (()()) 3 3 [\"((()))\"]\\n#           backtrack return with (()() 3 2 [\"((()))\", \"(()())\"]\\n#         backtrack return with (()( 3 1 [\"((()))\", \"(()())\"]\\n#         backtrack called with (()) 2 2 [\"((()))\", \"(()())\"]\\n#           backtrack called with (())( 3 2 [\"((()))\", \"(()())\"]\\n#             backtrack called with (())() 3 3 [\"((()))\", \"(()())\"]\\n#           backtrack return with (())( 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack return with (()) 2 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack return with (() 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack return with (( 2 0 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack called with () 1 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack called with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack called with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack called with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#             backtrack called with ()(()) 3 3 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack return with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack return with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack called with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack called with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#             backtrack called with ()()() 3 3 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack return with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#         backtrack return with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#       backtrack return with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#     backtrack return with () 1 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#   backtrack return with ( 1 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n# backtrack return with  0 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n\\n# Refer to the attached diagram for recursion,\\n# The numbers next to each node are the counts of left and right parantheses\\n\\n```\\n![image](https://assets.leetcode.com/users/vkommi2/image_1544322836.png)\\n",
                "solutionTags": [],
                "code": "```ruby\\n# @param {Integer} n\\n# @return {String[]}\\ndef generate_parenthesis(n)\\n    backtrack(n)\\nend\\n\\ndef backtrack(n, s = \"\", l = 0, r = 0, result = [])\\n    if s.size == 2 * n\\n        result.push(s)\\n        return\\n    end\\n\\n    backtrack(n, s + \"(\", l + 1, r, result) if l < n\\n    backtrack(n, s + \")\", l, r + 1, result) if r < l\\n\\n    result\\nend\\n\\n\\n# 22. Generate Parentheses\\n# https://leetcode.com/problems/generate-parentheses/description/\\n\\n# Complexity Analysis\\n# Our complexity analysis rests on understanding how many elements there are in generateParenthesis(n).\\n# This analysis is outside the scope of this article,\\n# but it turns out this is the n-th Catalan number 1/ (n + 1) * (2nCn), which is bounded asymptotically by 4^n / n * sqrt(n).\\n\\n# Time: O(4^n/sqrt(n), Each valid sequence has at most n steps during the backtracking procedure.\\n# Space: O(4^n/sqrt(n), as described above, and using O(n) space to store the sequence.\\n\\n# *** Example: n = 3 *** Space after each DFS instance\\n# backtrack called with  0 0 []\\n#   backtrack called with ( 1 0 []\\n#     backtrack called with (( 2 0 []\\n#       backtrack called with ((( 3 0 []\\n#         backtrack called with ((() 3 1 []\\n#           backtrack called with ((()) 3 2 []\\n#             backtrack called with ((())) 3 3 []\\n#           backtrack return with ((()) 3 2 [\"((()))\"]\\n#         backtrack return with ((() 3 1 [\"((()))\"]\\n#       backtrack return with ((( 3 0 [\"((()))\"]\\n#       backtrack called with (() 2 1 [\"((()))\"]\\n#         backtrack called with (()( 3 1 [\"((()))\"]\\n#           backtrack called with (()() 3 2 [\"((()))\"]\\n#             backtrack called with (()()) 3 3 [\"((()))\"]\\n#           backtrack return with (()() 3 2 [\"((()))\", \"(()())\"]\\n#         backtrack return with (()( 3 1 [\"((()))\", \"(()())\"]\\n#         backtrack called with (()) 2 2 [\"((()))\", \"(()())\"]\\n#           backtrack called with (())( 3 2 [\"((()))\", \"(()())\"]\\n#             backtrack called with (())() 3 3 [\"((()))\", \"(()())\"]\\n#           backtrack return with (())( 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack return with (()) 2 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack return with (() 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack return with (( 2 0 [\"((()))\", \"(()())\", \"(())()\"]\\n#     backtrack called with () 1 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#       backtrack called with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#         backtrack called with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack called with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\"]\\n#             backtrack called with ()(()) 3 3 [\"((()))\", \"(()())\", \"(())()\"]\\n#           backtrack return with ()(() 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack return with ()(( 3 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#         backtrack called with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack called with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#             backtrack called with ()()() 3 3 [\"((()))\", \"(()())\", \"(())()\", \"()(())\"]\\n#           backtrack return with ()()( 3 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#         backtrack return with ()() 2 2 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#       backtrack return with ()( 2 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#     backtrack return with () 1 1 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n#   backtrack return with ( 1 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n# backtrack return with  0 0 [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\\n\\n# Refer to the attached diagram for recursion,\\n# The numbers next to each node are the counts of left and right parantheses\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 10173,
                "title": "my-0ms-c-solution-without-recursion-and-dfs",
                "content": "    class Solution {\\n        //\\u8fd9\\u4e00\\u7248\\u4e0d\\u4f7f\\u7528\\u9012\\u5f52\\uff0c\\u901f\\u5ea6\\u66f4\\u5feb\\u3002\\n        //\\u9996\\u5148\\u662f\\u6700\\u539a\\u7684\\u62ec\\u53f7\\u5305\\u88f9\\u72b6\\u6001\\uff0c\\u5373\\u4e00\\u5f00\\u59cb\\u5de6\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u5de6\\u62ec\\u53f7\\uff0c\\u53f3\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u53f3\\u62ec\\u53f7\\uff0c\\u7136\\u540e\\u6267\\u884c\\u4ee5\\u4e0b\\u903b\\u8f91\\uff1a\\n        //1\\u3001\\u53f3\\u62ec\\u53f7\\u4e0d\\u80fd\\u6bd4\\u5de6\\u62ec\\u53f7\\u591a\\uff1b\\n        //2\\u3001\\u5f39\\u51fa\\u53f3\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u9047\\u5230\\u7b2c\\u4e00\\u4e2a\\u5de6\\u62ec\\u53f7\\uff0c\\u5982\\u679c\\u5de6\\u62ec\\u53f7\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\u4ecd\\u7136\\u5408\\u6cd5\\uff0c\\u5219\\u628a\\u5b83\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\uff1b\\u5426\\u5219\\uff0c\\u5de6\\u62ec\\u53f7\\u7ee7\\u7eed\\u5f39\\u51fa\\uff1b\\n        //3\\u3001\\u6539\\u5b8c\\u4e4b\\u540e\\u4e00\\u4e2a\\u52b2\\u52a0\\u5de6\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u6240\\u6709\\u53ef\\u4ee5\\u7528\\u7684\\u5de6\\u62ec\\u53f7\\u90fd\\u52a0\\u5b8c\\u4e3a\\u6b62\\u3002\\n        //4\\u3001\\u5faa\\u73af\\u4e00\\u76f4\\u6267\\u884c\\u5230\\u4e00\\u5f00\\u59cb\\u7684\\u8fde\\u7eed\\u5de6\\u62ec\\u53f7\\u6ca1\\u6709\\u4e3a\\u6b62\\u3002\\n        //\\u8be5\\u7a0b\\u5e8f\\u662f\\u4e0a\\u4e00\\u7248\\u9012\\u5f52\\u7a0b\\u5e8f\\u7684\\u7b49\\u4ef7\\u7248\\u3002\\n    public:\\n        vector<string> generateParenthesis(int n) \\n        {\\n            vector<string> result;\\n            if(n==0)\\n                return result;\\n            string s;\\n            for(int i=0;i<n;i++)\\n                s+=\"(\";\\n            for(int i=0;i<n;i++)\\n                s+=\")\";\\n            int left=n;\\n            int right=n;\\n            do\\n            {\\n                result.push_back(s);\\n                while(s!=\"\"&&(s.back()==')'||left-1<right+1))\\n                {\\n                    if(s.back()==')')\\n                        right--;\\n                    else\\n                        left--;\\n                    s.pop_back();\\n                }\\n                if(s!=\"\")\\n                {\\n                    s.back()=')';\\n                    left--;\\n                    right++;\\n                    while(left<n)\\n                    {\\n                        s+=\"(\";\\n                        left++;\\n                    }\\n                    while(right<n)\\n                    {\\n                        s+=\")\";\\n                        right++;\\n                    }\\n                }\\n            }while(s!=\"\");\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        //\\u8fd9\\u4e00\\u7248\\u4e0d\\u4f7f\\u7528\\u9012\\u5f52\\uff0c\\u901f\\u5ea6\\u66f4\\u5feb\\u3002\\n        //\\u9996\\u5148\\u662f\\u6700\\u539a\\u7684\\u62ec\\u53f7\\u5305\\u88f9\\u72b6\\u6001\\uff0c\\u5373\\u4e00\\u5f00\\u59cb\\u5de6\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u5de6\\u62ec\\u53f7\\uff0c\\u53f3\\u8fb9\\u662f\\u8fde\\u7eed\\u7684\\u53f3\\u62ec\\u53f7\\uff0c\\u7136\\u540e\\u6267\\u884c\\u4ee5\\u4e0b\\u903b\\u8f91\\uff1a\\n        //1\\u3001\\u53f3\\u62ec\\u53f7\\u4e0d\\u80fd\\u6bd4\\u5de6\\u62ec\\u53f7\\u591a\\uff1b\\n        //2\\u3001\\u5f39\\u51fa\\u53f3\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u9047\\u5230\\u7b2c\\u4e00\\u4e2a\\u5de6\\u62ec\\u53f7\\uff0c\\u5982\\u679c\\u5de6\\u62ec\\u53f7\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\u4ecd\\u7136\\u5408\\u6cd5\\uff0c\\u5219\\u628a\\u5b83\\u6539\\u6210\\u53f3\\u62ec\\u53f7\\uff1b\\u5426\\u5219\\uff0c\\u5de6\\u62ec\\u53f7\\u7ee7\\u7eed\\u5f39\\u51fa\\uff1b\\n        //3\\u3001\\u6539\\u5b8c\\u4e4b\\u540e\\u4e00\\u4e2a\\u52b2\\u52a0\\u5de6\\u62ec\\u53f7\\uff0c\\u76f4\\u5230\\u6240\\u6709\\u53ef\\u4ee5\\u7528\\u7684\\u5de6\\u62ec\\u53f7\\u90fd\\u52a0\\u5b8c\\u4e3a\\u6b62\\u3002\\n        //4\\u3001\\u5faa\\u73af\\u4e00\\u76f4\\u6267\\u884c\\u5230\\u4e00\\u5f00\\u59cb\\u7684\\u8fde\\u7eed\\u5de6\\u62ec\\u53f7\\u6ca1\\u6709\\u4e3a\\u6b62\\u3002\\n        //\\u8be5\\u7a0b\\u5e8f\\u662f\\u4e0a\\u4e00\\u7248\\u9012\\u5f52\\u7a0b\\u5e8f\\u7684\\u7b49\\u4ef7\\u7248\\u3002\\n    public:\\n        vector<string> generateParenthesis(int n) \\n        {\\n            vector<string> result;\\n            if(n==0)\\n                return result;\\n            string s;\\n            for(int i=0;i<n;i++)\\n                s+=\"(\";\\n            for(int i=0;i<n;i++)\\n                s+=\")\";\\n            int left=n;\\n            int right=n;\\n            do\\n            {\\n                result.push_back(s);\\n                while(s!=\"\"&&(s.back()==')'||left-1<right+1))\\n                {\\n                    if(s.back()==')')\\n                        right--;\\n                    else\\n                        left--;\\n                    s.pop_back();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 10349,
                "title": "my-java-code-using-dp",
                "content": "The idea is clear. Use cache to store the already calculated results, from f(0) to f(n). For each f(i), get f(j) and f(i - j - 1) from cache, 0 <= j < = j-1.\\n\\n    public static List<String> generateParenthesis(int n) {\\n        List<List<String>> cache = new LinkedList<>();\\n        cache.add(Arrays.asList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> nList = new LinkedList<>();\\n            for (int j = 0; j < i; j++) {\\n                List<String> inside = cache.get(j);\\n                List<String> tail = cache.get(i - j - 1);\\n                for (int k = 0; k < inside.size(); k++) {\\n                    for (int l = 0; l < tail.size(); l++) {\\n                        nList.add(\"(\" + inside.get(k) + \")\" + tail.get(l));\\n                    }\\n                }\\n            }\\n            cache.add(nList);\\n        }\\n        return cache.get(n);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is clear. Use cache to store the already calculated results, from f(0) to f(n). For each f(i), get f(j) and f(i - j - 1) from cache, 0 <= j < = j-1.\\n\\n    public static List<String> generateParenthesis(int n) {\\n        List<List<String>> cache = new LinkedList<>();\\n        cache.add(Arrays.asList(\"\"));\\n\\n        for (int i = 1; i <= n; i++) {\\n            List<String> nList = new LinkedList<>();\\n            for (int j = 0; j < i; j++) {\\n                List<String> inside = cache.get(j);\\n                List<String> tail = cache.get(i - j - 1);\\n                for (int k = 0; k < inside.size(); k++) {\\n                    for (int l = 0; l < tail.size(); l++) {\\n                        nList.add(\"(\" + inside.get(k) + \")\" + tail.get(l));\\n                    }\\n                }\\n            }\\n            cache.add(nList);\\n        }\\n        return cache.get(n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10423,
                "title": "java-recursive-simple-with-8-lines",
                "content": "    List<String> list = new ArrayList<String>();\\n    \\tpublic List<String> generateParenthesis(int n) {\\n        \\tloop(\"(\",n-1,1);\\n        \\treturn list;\\n        }\\n        private void loop(String s, int n, int o){\\n        \\tif (n==0 && o==0) list.add(s);\\n        \\tif (n>0) loop(s+\"(\", n-1, o+1);\\n        \\tif (o>0) loop(s+\")\", n, o-1);\\n        }",
                "solutionTags": [],
                "code": "    List<String> list = new ArrayList<String>();\\n    \\tpublic List<String> generateParenthesis(int n) {\\n        \\tloop(\"(\",n-1,1);\\n        \\treturn list;\\n        }\\n        private void loop(String s, int n, int o){\\n        \\tif (n==0 && o==0) list.add(s);\\n        \\tif (n>0) loop(s+\"(\", n-1, o+1);\\n        \\tif (o>0) loop(s+\")\", n, o-1);\\n        }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564779,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574327,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1566162,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1565657,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574405,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568042,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1980901,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568840,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568013,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1575229,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1564779,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574327,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1566162,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1565657,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1574405,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568042,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1980901,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568840,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1568013,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1575229,
                "content": [
                    {
                        "username": "bonson",
                        "content": "Using different implmentation,the elements will be in different orders. e.g. n = 3.\\nIt can be\\n[\"((()))\",\"(())()\",\"()(())\",\"(()())\",\"()()()\"]\\nwhile the expected answer is\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\\n\\nBoth are correct answers. However, the difference of ordering is reckoned as \"wrong answer\". "
                    },
                    {
                        "username": "theashggl",
                        "content": "It accepts all ordering but that should be specified in the question."
                    },
                    {
                        "username": "gmarus",
                        "content": "still does not"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "January 2023, it accepted different ordered answers for me."
                    },
                    {
                        "username": "barrybecker4",
                        "content": "[@satbekmyrza](/satbekmyrza) Still does not"
                    },
                    {
                        "username": "angelopoulos",
                        "content": "[@4m4nd33p_51ngh](/4m4nd33p_51ngh) I can confirm it still doesn\\'t"
                    },
                    {
                        "username": "4m4nd33p_51ngh",
                        "content": "[@satbekmyrza](/satbekmyrza) no it doesn\\'t"
                    },
                    {
                        "username": "satbekmyrza",
                        "content": "I think it accepts different ordered answers, as of 2022"
                    },
                    {
                        "username": "tejavenkatlanka",
                        "content": "![image](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)\\nclick for view \\n[https://embed.creately.com/cclS6u7Upy3?type=svg] \\n\\nleft path represent possible one parentheses and right represent possible of right parentheses.\\n\\nleaf node contains answer.\\n\\nhope it will help.\\n\\n"
                    },
                    {
                        "username": "leetnote_io",
                        "content": "Thanks, the pic is very intuitive"
                    },
                    {
                        "username": "dominic89231",
                        "content": "Very helpful!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u26A0\\uFE0FEasiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3035511/easiest-faang-method-ever/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "Literally spent about 2hrs on this and came up with a different, more complex (I think) solution that uses recursion. "
                    },
                    {
                        "username": "ChrisMiaoMiao",
                        "content": "Thx, It\\'s very helpful!"
                    },
                    {
                        "username": "aln4739",
                        "content": "very helpful!"
                    },
                    {
                        "username": "KalRadikov",
                        "content": "![image](https://assets.leetcode.com/users/images/40f0296a-7b58-49fb-a72e-e5d8eacf94a4_1604461937.5052783.png)\\n\\nProof:\\n\\n![image](https://assets.leetcode.com/users/images/4bcd2dba-e170-4799-91ae-3e4a1de32731_1605116132.2703443.png)\\n\\n"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "You sneaky bastard!!!!!\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "alex_malevinsky",
                        "content": "Lots of lines of code, without loops or recursion. Really legend!"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "codebuster_",
                        "content": "Habibi, this is a dream come true moment"
                    },
                    {
                        "username": "drMystico",
                        "content": "genius guy downright there! "
                    },
                    {
                        "username": "Cripton",
                        "content": "bros dad works at microsoft"
                    },
                    {
                        "username": "RashCode",
                        "content": "Legend\\uD83E\\uDEE1"
                    },
                    {
                        "username": "milespossing",
                        "content": "Strong hire"
                    },
                    {
                        "username": "sunlins",
                        "content": "I was sure of finding this in the comment section"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Bro is a hacker"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "bro beat the system..."
                    },
                    {
                        "username": "rsharvesh16",
                        "content": "Bro is from another world!"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "This is some big brain stuff"
                    },
                    {
                        "username": "Prasanth2021",
                        "content": "[@kzlatt](/kzlatt) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "AdilARahman",
                        "content": "Use switch case to go even faster XD"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "perfect solution for this problem. it\\'s kind a static problem. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Testcase Oriented Programming \\uD83D\\uDE02"
                    },
                    {
                        "username": "guneetd",
                        "content": "[@ashok0](/ashok0) then you can use Abstract Factory to generate strings :) "
                    },
                    {
                        "username": "kzlatt",
                        "content": "Leetcode :  Choose!!!!  step up or step down\\nKalRadikov:   S.....i......d......e......w......a......y"
                    },
                    {
                        "username": "District_12",
                        "content": "that\\'s what we call to be creative!"
                    },
                    {
                        "username": "a_s_h_o_k",
                        "content": "what if n=100 \\uD83D\\uDE02"
                    },
                    {
                        "username": "aln4739",
                        "content": "chad"
                    },
                    {
                        "username": "leetcodesquad",
                        "content": "No one can beat you since you already had the answer. LOL"
                    },
                    {
                        "username": "undi69",
                        "content": "Dude you are a god"
                    },
                    {
                        "username": "khanuja05",
                        "content": "My solution generates the same set of outputs but the ordering is different. The question should be edited and they should mention that the order matters."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "It seems that problem author expects a sorted array of strings. So if you struggle with incorrect order, just sort the array and it should work fine."
                    },
                    {
                        "username": "fillipe",
                        "content": "[@krjukov](/krjukov) My solution fails at the test case with 6 pairs. I have verified exactly why now. It is for not generating certain patterns. The system considers your solution correct regardless of the order in which the patterns are saved in your solution."
                    },
                    {
                        "username": "krjukov",
                        "content": "It\\'s senseless to demand preserved order in this type of problems. All the strings are of the same length. It is the validation of the solutions to be amended, not the description. Just accept any order "
                    },
                    {
                        "username": "noisrucer",
                        "content": "I solved this problem with 60m/s by generating permutations with duplicates and for each permutation result I used stack to check if it\\'s valid parenthesis and now I came here and ppl post simple/mind-blowing solutions that I never expected and A LOT OF people be like \"yeah~nice solution~i thought kinda the same way~\". WTH!!!!!\\n\\nI started algorithm roughly 3 months ago and I\\'ve been studying 12-14 hrs a day til now and solved probably 200 questions so far. I\\'m kinda confident in BFS DFS DP and some general algorithm but totally new to combinatorics. What should I focus more on? I haven\\'t studied Greedy yet. Can you guys recommend me how I study Greedy? cuz its so vague I\\'ve looked up so much\\n\\nBless to y\\'all\\n\\n- Non-smart Asian sophomore kid-"
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "whats your github and linkedin?"
                    },
                    {
                        "username": "baseballCode",
                        "content": "[@blsd-rus](/blsd-rus) I use the neetcode roadmap, ordering is important and since I started doing the questions in order im starting to get better. "
                    },
                    {
                        "username": "blsd-rus",
                        "content": "[@vishesh014](/vishesh014) i\\'ll recommend neetcode"
                    },
                    {
                        "username": "vishesh014",
                        "content": "bro can you tell me the roadmap how you studied algorithms"
                    },
                    {
                        "username": "andy_r_s",
                        "content": "For n = 4 is following one of the valid combinations?\\n(())(())\\n\\nMy code has this but the leetcode says it\\'s not valid. I don\\'t understand why is it invalid?"
                    },
                    {
                        "username": "fffccc",
                        "content": "I also generated this and the test case doesn\\'t generate this one."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s valid, but maybe you generated it twice?"
                    },
                    {
                        "username": "chiragrajput245",
                        "content": "Draw the recursive tree and think about the conditions when an opening/closing bracket can be appended\\n\\n         (\\n        / \\\\\\n       ((  ()\\n      / \\\\   |\\n    ((( (() ()(\\n     .   .   .\\n     .   .   .\\n\\n... and so on"
                    },
                    {
                        "username": "JenZ",
                        "content": "Is it 2^n? \\nIs any method better than it ?Thank you."
                    },
                    {
                        "username": "panwu5588",
                        "content": "BAD test cases. The order should not matter.\\nFor example, the following should be the same:\\n[\"(())\",\"()()\"]\\n[\"()()\",\"(())\"]"
                    },
                    {
                        "username": "satta_sunder",
                        "content": "I applied recursion and got 55% faster only. I\\'d love to see if there is any more efficient method."
                    },
                    {
                        "username": "Puja__Singh",
                        "content": "check mine it beats 97%"
                    },
                    {
                        "username": "noob-pika",
                        "content": "The system for calculating time complexity is broken for a solution after a certain number of submissions"
                    }
                ]
            },
            {
                "id": 1571058,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1569242,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1928921,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1826653,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1573015,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1571057,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1576172,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 2053376,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 2037019,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1983146,
                "content": [
                    {
                        "username": "billupus",
                        "content": "I got rejected because:\\n\\n    Input:\\t4\\n    Output: \\t[\"()()()()\",\"(()()())\",\"()(()())\",\"((()()))\",\"(()())()\",\"()()(())\",\"(()(()))\",\"()(())()\",\"()((()))\",\"(((())))\",\"((()))()\",\"()(())()\",\"((())())\",\"(())()()\"]\\n    Expected:   [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\n\\nEverything (except for the order) looks fine to me? I don't think that a certain order is necessary at all."
                    },
                    {
                        "username": "fffccc",
                        "content": "I got this error, too. \"(())(())\" is not included in the answer which is weird to me."
                    },
                    {
                        "username": "fillipe",
                        "content": "Your solution allowed a duplicate for the pattern \"()(())()\". Your algorithm is not generate all patterns. \\nI found that my solution starts to fail at test case n=6 for not generating all patterns. \\nMy first solution consisted of generating patterns based on to building blocks: 1) enclose the input pattern with brackets, and if the pattern is formed of with a chain of brackets subpatterns, then generate new patterns by enclosing each brackets subpattern of the input pattern. Right after forming each of the individual patterns, as they are generated, check if they have already been seen, if not, then generate deeper derivates of the newly generated pattern until it runs out of pairs of brackets. 2) For each newly generated pattern, add a new pair of brackets to the right or to the left of the pattern. I thought this was supposed to work but it doesn\\'t solve for all possible test cases. In the end, I had to resort to the solution where patterns are formed by adding a bracket at a time, to the left or to the right."
                    },
                    {
                        "username": "mabingteng",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/mabingteng/image_1529838101.png)\\n"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "[@Crispy_coffee](/Crispy_coffee) seems to be performing depth first search recursively, with one more \"(\" or \")\" depending on if its searching left or right."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Can you explain it please."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Logic:\\nAdd open bracket upto open is less than n given.\\nAdd close bracket upto close is less than open.\\nBy this way close bracket will never come in befor start bracket.\\ni.e )(.\\n\\nTime complexity:\\nT.C=O(2^n) used recursion.\\n\\nSpace complexity:\\nS.C=O(n)\\n------------------------\\nPlease upvote. If Understand the concept...\\nSolution Link:\\nhttps://leetcode.com/problems/generate-parentheses/solutions/3636240/c-python-java-understand-the-concept/"
                    },
                    {
                        "username": "mohmedelngar200211",
                        "content": "not accepted cuz diffierence in the order"
                    },
                    {
                        "username": "divi13",
                        "content": "There seems to be a problem with the grader.\\n\\nIt is saying this:\\n\\n**Input:\\n1\\nOutput:\\n[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\",\"()\"]\\nExpected:\\n[\"()\"]**\\n\\nBut when I run the code with input 1, I am getting the expected [\"()\"] as result. What is the problem?\\n\\n\\n"
                    },
                    {
                        "username": "leetpen",
                        "content": "reminder for people with same situation:\\nprobably because you use a global variable to store the list. The system will run test case n = 1 after n = 3, so those strings of the previous test case (n=3) are still in your list"
                    },
                    {
                        "username": "pandabearnow",
                        "content": "I have a solution that lists all the combinations but my submission fails because it is not in the order that the leetcode answer generates them. Why is that order important?"
                    },
                    {
                        "username": "ab1533489",
                        "content": "I\\'m not able to think of iterative DP solution for this problem, if you know please do share."
                    },
                    {
                        "username": "Demaxl",
                        "content": "I feel so happy that i was able to solve this problem. This is the first backtracking I solved by myself. I feel more motivated to tackle others now"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "To solve this problem, you can use a recursive approach. Here\\'s how you can approach the task and put your mind in the right direction:\\n\\n1. Base Case: Start by identifying the base case. When n is 0, there\\'s only one possible combination: an empty string.\\n\\n2. Recursive Case: For each pair of parentheses, you have two options: open a new parenthesis or close an existing open parenthesis. So, you\\'ll recursively generate combinations by trying both options for each parenthesis.\\n\\n3. Recursion with Backtracking: Use recursion to explore all possibilities. When adding an open parenthesis, decrement n by 1 to indicate that one opening parenthesis has been used. When adding a closing parenthesis, make sure there\\'s a matching open parenthesis available (meaning n hasn\\'t reached 0 yet).\\n\\n4. Build and Return the Combinations: As you explore the possibilities, build and store the combinations in a list. Once you\\'ve exhausted all possibilities for a given state, return the list of combinations.\\n\\n5. Edge Cases: Handle edge cases like if n is negative or zero, and set up the initial call to the recursive function.\\n\\nIn terms of algorithm, the key idea is to generate all possible combinations while ensuring that they\\'re well-formed parentheses. The recursive approach allows you to explore these combinations in a structured manner. Remember to think about the base case, the recursive cases, and how to build and return the combinations as you traverse the recursion tree.\\n\\nIn terms of implementation, you can create a recursive function that takes parameters such as the current combination being built, the remaining open and close parentheses, and the list to store combinations. Each recursive call will decide whether to add an open or close parenthesis, and the parameters will be updated accordingly.\\n\\nRemember that recursive problems often involve thinking about how to break down the problem into smaller, more manageable subproblems, and how to combine the results of those subproblems to get the final solution.\\n\\n "
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "How this question uses dp, I have solved using backtracking"
                    }
                ]
            },
            {
                "id": 1963949,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1901261,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1861473,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1763055,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1572241,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1832940,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 1573326,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2072646,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2049319,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2034589,
                "content": [
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "classic backtracking"
                    },
                    {
                        "username": "jayantee_12",
                        "content": "Does order of solution matter in this problem?"
                    },
                    {
                        "username": "Naumel",
                        "content": "The code works on my machine, but something seems wrongly cached in the browser (as in the result I get from a local run is different than the result from here). Is this some known behaviour? "
                    },
                    {
                        "username": "easycheese",
                        "content": "# Very simple python\\n\\nInsert \"()\" between each character for each i to n \\n\\n```python\\ndef generateParenthesis(self, n: int):\\n        aws = {\"()\"}\\n        for _ in range(n-1):\\n            tmp = set()\\n            for j in aws:\\n                for k in range(len(j)+1):\\n                    tmp.add(j[:k]+\"()\"+j[k:])\\n            aws = tmp\\n        return [i for i in aws]\\n"
                    },
                    {
                        "username": "rajanpupa",
                        "content": "I saw some backtracking algorithm so solve this problem. What is the runtime complexity of the algorithm?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "My code is wrong on `n = 4` and I don\\'t know why? Help me pls!\\n```\\nvoid solver(int n, string str, vector<string> &answer, map<string, bool> &check)\\n    {\\n        if(n == 0)\\n        {\\n            if(check[str] == false)\\n            {\\n                answer.push_back(str);\\n                check[str] = true;\\n            }\\n            else\\n                return;\\n        }\\n        else\\n        {\\n            solver(n-1, \"(\" + str + \")\", answer, check);\\n            solver(n-1, str + \"()\", answer, check);\\n            solver(n-1, \"()\" + str, answer, check);\\n            \\n        }\\n    }\\n```"
                    },
                    {
                        "username": "adi29raj",
                        "content": "I was also doing something similar..let me know if you were able to solve llike this,"
                    },
                    {
                        "username": "SleepNotFound",
                        "content": "it would be missing \"(())(())\""
                    },
                    {
                        "username": "ahcox",
                        "content": "Let\\'s compare timings for the largest problem size that Leetcode will accept (**`11`**). Instructions to take part:\\n1. Go to test cases.\\n1. Delete everything.\\n1. Type `11` in there\\n1. Hit the \\'Run Code\\' button. (repeat a few time to get the best result)\\n1. Add your number as a comment here.\\n\\nMention your language and implementation approach if you like. This is just for fun! :-D\\n"
                    },
                    {
                        "username": "securityma",
                        "content": "Who can tell me the difference of add1 inside of the funtion of dfs  and add1 outside of the function\\n   if(m1<n){\\n       // m1++;\\n       // tmp+=\\'(\\';\\n        dfs(ans,n,m1+1,m2,tmp+\\'(\\');\\n    }\\n    if(m2<m1){\\n   // tmp+=\\')\\';\\n   //m2+=1;\\n    dfs(ans,n,m1,m2+1,tmp+\\')\\');}\\nIt\\'s completely different answer.I\\'ll appreciate it for your answer.  "
                    },
                    {
                        "username": "29ayush",
                        "content": "Consider below 2 codes:\\n\\nIn Code1, I use local vector for a test case, and in case 2 I use a global vector, leet code says 2 code is slower why ?\\n\\nCode1\\nclass Solution {\\npublic:\\n\\n    void refgen(string &s, int open, int close, vector<string> &allPara) {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(s, open - 1, close, allPara);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(s, open, close - 1, allPara);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> newVec;\\n        string s = \"\";\\n        refgen(s, n, n, newVec);\\n        return newVec;\\n    }\\n};\\n\\nCode 2:\\nclass Solution {\\npublic:\\n\\n    vector<string> allPara;\\n    string s;\\n    void refgen(int open, int close)  {\\n        if (close == 0) {\\n            allPara.push_back(s);\\n        }\\n        if (open > 0 ) {\\n            s.push_back(\\'(\\');\\n            refgen(open - 1, close);\\n            s.pop_back();\\n        }\\n\\n        if (close > open) {\\n            s.push_back(\\')\\');\\n            refgen(open, close - 1);\\n            s.pop_back();\\n        }\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        refgen(n, n);\\n        return allPara;\\n    }\\n};\\n\\n\\n\\n"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "count left \"(\" and right \")\" if count of left is less than \"n\" add \"(\" and also if  count \"(\" > \")\"  add \")\" or else if right< n add \")\",\nadd string to ans vector if sizeof string == 2*n"
                    }
                ]
            },
            {
                "id": 2030949,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 2026050,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 2013656,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1991502,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1967225,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1928158,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1891528,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1872258,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1870152,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1852609,
                "content": [
                    {
                        "username": "mayursonowal7",
                        "content": "leetcode getting naughtier day by day"
                    },
                    {
                        "username": "layyy",
                        "content": "keep the condition open brackets<n and close brackets<open brackets and recurse accordingly"
                    },
                    {
                        "username": "atharva2406",
                        "content": "Hi can anyone explain to me why my solution is not working\\nclass Solution {\\npublic:\\n    void backtrack(int open, int closed, int n, vector<string> res, stack<char> &st){\\n        if(open == closed and open == n && st.size() == n*2){\\n            string t = \" \";\\n            while(!st.empty()){\\n                t += st.top();\\n                st.pop();\\n            }\\n            reverse(t.begin(), t.end());\\n            res.push_back(t);\\n            return;\\n        }\\n        if(open < n){\\n            st.push(\\'(\\');\\n            backtrack(open+1, closed, n, res, st);\\n            st.pop();\\n        }\\n        if(closed < open){\\n            st.push(\\')\\');\\n            backtrack(open, closed+1, n, res, st);\\n            st.pop();\\n        }\\n        return;\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        int open = 0, closed = 0;\\n        stack<char> st;\\n        backtrack(open, closed, n, ans, st);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Shiv_1203",
                        "content": "just count opening brackets and closing bracket \\nthere are two conditions \\nif opening brackets are less than n then string+\\'(\\' and increase opening bracket count\\nif closing brackets are less than opening brackets then string+\\')\\' and increase closing bracket count\\nbase condition =  if both are equal store teh string in vector and return"
                    },
                    {
                        "username": "RK_9097",
                        "content": "class Solution {\\n    private boolean isValid(String pString) {\\n        int leftCount = 0;\\n        for (char p : pString.toCharArray()) {\\n            if (p == \\'(\\') {\\n                leftCount++;\\n            } else {\\n                leftCount--;\\n            } \\n\\n            if (leftCount < 0) {\\n                return false;\\n            }\\n        }\\n        return leftCount == 0;\\n    }\\n    \\n    public List<String> generateParenthesis(int n) {\\n        List<String> answer = new ArrayList<>();\\n        Queue<String> queue = new LinkedList<>(Arrays.asList(\"\"));\\n\\n        while (!queue.isEmpty()) {\\n            String curString = queue.poll();\\n\\n            // If the length of curString is 2 * n, add it to `answer` if\\n            // it is valid. \\n            if (curString.length() == 2 * n) {\\n                if (isValid(curString)) {\\n                    answer.add(curString);\\n                }\\n                continue;\\n            }\\n            queue.offer(curString + \")\");\\n            queue.offer(curString + \"(\");\\n        }\\n\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "How can  we solve this iteratively?\n"
                    },
                    {
                        "username": "maurei",
                        "content": "I think in my solution the recursive call be converted to a while loop pretty straightforwardly: https://leetcode.com/problems/generate-parentheses/description/comments/1870152"
                    },
                    {
                        "username": "saurabhDtu15",
                        "content": "Can someone help me with the time and space complexity for the following?\\nMy logic: Keeping count of opening brackets and closing brackets. Opening brackets cannot be more than n in any case and closing brackets should always be less than opening.\\n\\n`class Solution {\\n    List<String> res;\\n    public List<String> generateParenthesis(int n) {\\n        res = new ArrayList<>();\\n        brackets(n*2, 0, 0, \"\", 0);\\n        return res;\\n    }\\n\\n    private void brackets(int n, int strl, int strr, String str, int count) {\\n        if(str.length() == n) {\\n            res.add(str);\\n            return;\\n        }\\n        if(strl < n/2)\\n            brackets(n, strl + 1, strr, str + \\'(\\', count + 1);\\n        if(strr < strl) {\\n            brackets(n, strl, strr + 1, str + \\')\\', count + 1);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "ideintTe",
                        "content": "For n =4;\\nOutput : [\"(((())))\",\"((()))()\",\"()((()))\",\"((())())\",\"(())()()\",\"()(())()\",\"(()(()))\",\"()(())()\",\"()()(())\",\"((()()))\",\"(()())()\",\"()(()())\",\"(()()())\",\"()()()()\"]\\nExpected : [\"(((())))\",\"((()()))\",\"((())())\",\"((()))()\",\"(()(()))\",\"(()()())\",\"(()())()\",\"(())(())\",\"(())()()\",\"()((()))\",\"()(()())\",\"()(())()\",\"()()(())\",\"()()()()\"]\\nI\\'m not using recursion, how can I change the order ?\\nHere\\'s my solution:\\npublic List<String> generateParenthesis(int n) {\\n        List<String> combinations = new ArrayList<String>();\\n        List<String> combinations1 = new ArrayList<String>();\\n        if(n == 0)\\n            return combinations;\\n        combinations.add(\"()\");\\n        if(n == 1) {\\n            return combinations;\\n        }\\n        for( int i = 2; i <= n; i++) {   \\n            combinations1.clear();      \\n            for(String j : combinations) {\\n                String temp1 = j.concat(\"()\");\\n                String temp2 = \"()\".concat(j);\\n                combinations1.add(\"(\" + j + \")\");\\n                if(!temp1.equals(temp2)) {\\n                    combinations1.add(temp1);\\n                    combinations1.add(temp2);\\n                }  \\n                else {\\n                    combinations1.add(temp1);           \\n            }\\n            combinations.clear();\\n            combinations.addAll(combinations1);           \\n        }\\n        return combinations;\\n    }\\n"
                    },
                    {
                        "username": "maurei",
                        "content": "My solution is also recursive but pretty different from keeping track of `openCount` and `closeCount`. I don\\'t really know how my solution relates. Does anyone have a better idea on this?\\n\\n I wrote down the first few cases and observed how I could eg obtain n=3 from n=2. The trick is to iterate over the combinations of n=2 and insert a `()` left and right of every opening `()` UNTIl you run into the first closing bracket `(`.\\n\\nLet me write that out with an example. I use `_()_` to denote which pair of brackets was newly introduced.\\n\\ntake `n=2`. (A)`(())` and (B) `()()`.\\n\\n(A) becomes: `_()_(())`,  `(_()_())` and `((_()_))`. Thats where we stop because after the last insertion, we run into the first closing bracket\\n(B) becomes: `_()_()()` and `(_()_)()`. Thats where we stop, again, because there is a closing bracket next.\\n\\nIt runs pretty damn fast. The code is here (can be written for better space but wanted to keep it readable for discussion here).\\n\\nIt works, but im not sure why.\\n\\n```c#\\npublic class Solution\\n{\\n    public IList<string> GenerateParenthesis(int n) \\n    {\\n        if (n == 0)\\n        {\\n            return Array.Empty<string>();\\n        }\\n\\n        if (n == 1)\\n        {\\n            return new List<string> { \"()\" };\\n        }\\n\\n        List<string> combinations = new List<string>();\\n\\n        IList<string> previousCombinations = GenerateParenthesis(n - 1);\\n\\n        foreach (string previous in previousCombinations)\\n        {\\n            List<string> current = GetCurrentConfig(previous);\\n            combinations.AddRange(current);\\n        }\\n\\n        return combinations;\\n    }\\n\\n    private List<string> GetCurrentConfig(string previous)\\n    {\\n        List<char> characters = previous.ToCharArray().ToList();\\n\\n        List<string> result = new();\\n        \\n        for (int i = 0; i < characters.Count; i++)\\n        {\\n            List<char> clone = new List<char>(characters);\\n            clone.Insert(i, \\')\\');\\n            clone.Insert(i, \\'(\\');\\n            result.Add(new string(clone.ToArray()));\\n            \\n            if (characters[i] == \\')\\')\\n            {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "zalars",
                        "content": "I found that the number of all combinations with N parenthesis pairs consists of two groups:\\n1. \"(\"+C(N-1)+\")\", where C(N-1) - all combiantions with N-1 parenthesis pairs;\\n2. All suitable concatenated sequences of all lower N\\'s combinations.\\n\\nAnd the second group is difficult to program for me even using a hash table. Besides time complexity doesn\\'t seem to be improved as well."
                    }
                ]
            },
            {
                "id": 1844051,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Tối ưu đây\n```\nfunction generateParenthesis(n) {\n    const results = []; // khởi tạo mảng kết quả chứa các chuỗi ngoặc đúng định dạng\n\n    function generate(str, left, right) { // khai báo hàm đệ quy generate với 3 tham số\n        if (left === 0 && right === 0) { // nếu số lượng dấu ngoặc mở và đóng bằng 0\n            results.push(str); // thêm chuỗi str vào mảng kết quả\n            return; // thoát khỏi hàm\n        }\n        if (left > 0) { // nếu còn dấu ngoặc mở chưa sử dụng hết\n            generate(str + \"(\", left - 1, right); // thêm dấu ngoặc mở vào chuỗi str và giảm số lượng dấu ngoặc mở còn lại đi 1\n        }\n        if (right > left) { // nếu số lượng dấu ngoặc đóng còn lại nhiều hơn dấu ngoặc mở\n            generate(str + \")\", left, right - 1); // thêm dấu ngoặc đóng vào chuỗi str và giảm số lượng dấu ngoặc đóng còn lại đi 1\n        }\n    }\n\n    generate(\"\", n, n); // bắt đầu chạy hàm generate với chuỗi rỗng và số lượng dấu ngoặc mở và đóng bằng n\n    return results; // trả về mảng kết quả\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1817918,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Tối ưu đây\n```\nfunction generateParenthesis(n) {\n    const results = []; // khởi tạo mảng kết quả chứa các chuỗi ngoặc đúng định dạng\n\n    function generate(str, left, right) { // khai báo hàm đệ quy generate với 3 tham số\n        if (left === 0 && right === 0) { // nếu số lượng dấu ngoặc mở và đóng bằng 0\n            results.push(str); // thêm chuỗi str vào mảng kết quả\n            return; // thoát khỏi hàm\n        }\n        if (left > 0) { // nếu còn dấu ngoặc mở chưa sử dụng hết\n            generate(str + \"(\", left - 1, right); // thêm dấu ngoặc mở vào chuỗi str và giảm số lượng dấu ngoặc mở còn lại đi 1\n        }\n        if (right > left) { // nếu số lượng dấu ngoặc đóng còn lại nhiều hơn dấu ngoặc mở\n            generate(str + \")\", left, right - 1); // thêm dấu ngoặc đóng vào chuỗi str và giảm số lượng dấu ngoặc đóng còn lại đi 1\n        }\n    }\n\n    generate(\"\", n, n); // bắt đầu chạy hàm generate với chuỗi rỗng và số lượng dấu ngoặc mở và đóng bằng n\n    return results; // trả về mảng kết quả\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1814298,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Tối ưu đây\n```\nfunction generateParenthesis(n) {\n    const results = []; // khởi tạo mảng kết quả chứa các chuỗi ngoặc đúng định dạng\n\n    function generate(str, left, right) { // khai báo hàm đệ quy generate với 3 tham số\n        if (left === 0 && right === 0) { // nếu số lượng dấu ngoặc mở và đóng bằng 0\n            results.push(str); // thêm chuỗi str vào mảng kết quả\n            return; // thoát khỏi hàm\n        }\n        if (left > 0) { // nếu còn dấu ngoặc mở chưa sử dụng hết\n            generate(str + \"(\", left - 1, right); // thêm dấu ngoặc mở vào chuỗi str và giảm số lượng dấu ngoặc mở còn lại đi 1\n        }\n        if (right > left) { // nếu số lượng dấu ngoặc đóng còn lại nhiều hơn dấu ngoặc mở\n            generate(str + \")\", left, right - 1); // thêm dấu ngoặc đóng vào chuỗi str và giảm số lượng dấu ngoặc đóng còn lại đi 1\n        }\n    }\n\n    generate(\"\", n, n); // bắt đầu chạy hàm generate với chuỗi rỗng và số lượng dấu ngoặc mở và đóng bằng n\n    return results; // trả về mảng kết quả\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1803751,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Tối ưu đây\n```\nfunction generateParenthesis(n) {\n    const results = []; // khởi tạo mảng kết quả chứa các chuỗi ngoặc đúng định dạng\n\n    function generate(str, left, right) { // khai báo hàm đệ quy generate với 3 tham số\n        if (left === 0 && right === 0) { // nếu số lượng dấu ngoặc mở và đóng bằng 0\n            results.push(str); // thêm chuỗi str vào mảng kết quả\n            return; // thoát khỏi hàm\n        }\n        if (left > 0) { // nếu còn dấu ngoặc mở chưa sử dụng hết\n            generate(str + \"(\", left - 1, right); // thêm dấu ngoặc mở vào chuỗi str và giảm số lượng dấu ngoặc mở còn lại đi 1\n        }\n        if (right > left) { // nếu số lượng dấu ngoặc đóng còn lại nhiều hơn dấu ngoặc mở\n            generate(str + \")\", left, right - 1); // thêm dấu ngoặc đóng vào chuỗi str và giảm số lượng dấu ngoặc đóng còn lại đi 1\n        }\n    }\n\n    generate(\"\", n, n); // bắt đầu chạy hàm generate với chuỗi rỗng và số lượng dấu ngoặc mở và đóng bằng n\n    return results; // trả về mảng kết quả\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1803743,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Tối ưu đây\n```\nfunction generateParenthesis(n) {\n    const results = []; // khởi tạo mảng kết quả chứa các chuỗi ngoặc đúng định dạng\n\n    function generate(str, left, right) { // khai báo hàm đệ quy generate với 3 tham số\n        if (left === 0 && right === 0) { // nếu số lượng dấu ngoặc mở và đóng bằng 0\n            results.push(str); // thêm chuỗi str vào mảng kết quả\n            return; // thoát khỏi hàm\n        }\n        if (left > 0) { // nếu còn dấu ngoặc mở chưa sử dụng hết\n            generate(str + \"(\", left - 1, right); // thêm dấu ngoặc mở vào chuỗi str và giảm số lượng dấu ngoặc mở còn lại đi 1\n        }\n        if (right > left) { // nếu số lượng dấu ngoặc đóng còn lại nhiều hơn dấu ngoặc mở\n            generate(str + \")\", left, right - 1); // thêm dấu ngoặc đóng vào chuỗi str và giảm số lượng dấu ngoặc đóng còn lại đi 1\n        }\n    }\n\n    generate(\"\", n, n); // bắt đầu chạy hàm generate với chuỗi rỗng và số lượng dấu ngoặc mở và đóng bằng n\n    return results; // trả về mảng kết quả\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1793042,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Tối ưu đây\n```\nfunction generateParenthesis(n) {\n    const results = []; // khởi tạo mảng kết quả chứa các chuỗi ngoặc đúng định dạng\n\n    function generate(str, left, right) { // khai báo hàm đệ quy generate với 3 tham số\n        if (left === 0 && right === 0) { // nếu số lượng dấu ngoặc mở và đóng bằng 0\n            results.push(str); // thêm chuỗi str vào mảng kết quả\n            return; // thoát khỏi hàm\n        }\n        if (left > 0) { // nếu còn dấu ngoặc mở chưa sử dụng hết\n            generate(str + \"(\", left - 1, right); // thêm dấu ngoặc mở vào chuỗi str và giảm số lượng dấu ngoặc mở còn lại đi 1\n        }\n        if (right > left) { // nếu số lượng dấu ngoặc đóng còn lại nhiều hơn dấu ngoặc mở\n            generate(str + \")\", left, right - 1); // thêm dấu ngoặc đóng vào chuỗi str và giảm số lượng dấu ngoặc đóng còn lại đi 1\n        }\n    }\n\n    generate(\"\", n, n); // bắt đầu chạy hàm generate với chuỗi rỗng và số lượng dấu ngoặc mở và đóng bằng n\n    return results; // trả về mảng kết quả\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1777093,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Tối ưu đây\n```\nfunction generateParenthesis(n) {\n    const results = []; // khởi tạo mảng kết quả chứa các chuỗi ngoặc đúng định dạng\n\n    function generate(str, left, right) { // khai báo hàm đệ quy generate với 3 tham số\n        if (left === 0 && right === 0) { // nếu số lượng dấu ngoặc mở và đóng bằng 0\n            results.push(str); // thêm chuỗi str vào mảng kết quả\n            return; // thoát khỏi hàm\n        }\n        if (left > 0) { // nếu còn dấu ngoặc mở chưa sử dụng hết\n            generate(str + \"(\", left - 1, right); // thêm dấu ngoặc mở vào chuỗi str và giảm số lượng dấu ngoặc mở còn lại đi 1\n        }\n        if (right > left) { // nếu số lượng dấu ngoặc đóng còn lại nhiều hơn dấu ngoặc mở\n            generate(str + \")\", left, right - 1); // thêm dấu ngoặc đóng vào chuỗi str và giảm số lượng dấu ngoặc đóng còn lại đi 1\n        }\n    }\n\n    generate(\"\", n, n); // bắt đầu chạy hàm generate với chuỗi rỗng và số lượng dấu ngoặc mở và đóng bằng n\n    return results; // trả về mảng kết quả\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1767681,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Tối ưu đây\n```\nfunction generateParenthesis(n) {\n    const results = []; // khởi tạo mảng kết quả chứa các chuỗi ngoặc đúng định dạng\n\n    function generate(str, left, right) { // khai báo hàm đệ quy generate với 3 tham số\n        if (left === 0 && right === 0) { // nếu số lượng dấu ngoặc mở và đóng bằng 0\n            results.push(str); // thêm chuỗi str vào mảng kết quả\n            return; // thoát khỏi hàm\n        }\n        if (left > 0) { // nếu còn dấu ngoặc mở chưa sử dụng hết\n            generate(str + \"(\", left - 1, right); // thêm dấu ngoặc mở vào chuỗi str và giảm số lượng dấu ngoặc mở còn lại đi 1\n        }\n        if (right > left) { // nếu số lượng dấu ngoặc đóng còn lại nhiều hơn dấu ngoặc mở\n            generate(str + \")\", left, right - 1); // thêm dấu ngoặc đóng vào chuỗi str và giảm số lượng dấu ngoặc đóng còn lại đi 1\n        }\n    }\n\n    generate(\"\", n, n); // bắt đầu chạy hàm generate với chuỗi rỗng và số lượng dấu ngoặc mở và đóng bằng n\n    return results; // trả về mảng kết quả\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1764232,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Tối ưu đây\n```\nfunction generateParenthesis(n) {\n    const results = []; // khởi tạo mảng kết quả chứa các chuỗi ngoặc đúng định dạng\n\n    function generate(str, left, right) { // khai báo hàm đệ quy generate với 3 tham số\n        if (left === 0 && right === 0) { // nếu số lượng dấu ngoặc mở và đóng bằng 0\n            results.push(str); // thêm chuỗi str vào mảng kết quả\n            return; // thoát khỏi hàm\n        }\n        if (left > 0) { // nếu còn dấu ngoặc mở chưa sử dụng hết\n            generate(str + \"(\", left - 1, right); // thêm dấu ngoặc mở vào chuỗi str và giảm số lượng dấu ngoặc mở còn lại đi 1\n        }\n        if (right > left) { // nếu số lượng dấu ngoặc đóng còn lại nhiều hơn dấu ngoặc mở\n            generate(str + \")\", left, right - 1); // thêm dấu ngoặc đóng vào chuỗi str và giảm số lượng dấu ngoặc đóng còn lại đi 1\n        }\n    }\n\n    generate(\"\", n, n); // bắt đầu chạy hàm generate với chuỗi rỗng và số lượng dấu ngoặc mở và đóng bằng n\n    return results; // trả về mảng kết quả\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1754546,
                "content": [
                    {
                        "username": "muan22",
                        "content": "Hi. I don\\'t know how in backtracking approach when we generate one of the combinations, the next combination start?"
                    },
                    {
                        "username": "aswatha",
                        "content": " void solve(string &s,vector<string>&res,int o,int c, int n){\\n        if(o<=0 && c<=0){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(o>0){\\n            s.push_back(\\'(\\');\\n            solve(s,res,o--,c,n);\\n            s.pop_back();\\n        }\\n        if(c>o){\\n            s.push_back(\\')\\');\\n            solve(s,res,o,c--,n);\\n            s.pop_back();\\n        }\\n    }\\n\\nthis is my function but i am getting\\n\\n AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffeb839aff8 (pc 0x000000344937 bp 0x7ffeb839b030 sp 0x7ffeb839b000 T0)\\n==34==ABORTING\\n\\nCan someone tell me why??"
                    },
                    {
                        "username": "hienlemanh2002",
                        "content": "Tối ưu đây\n```\nfunction generateParenthesis(n) {\n    const results = []; // khởi tạo mảng kết quả chứa các chuỗi ngoặc đúng định dạng\n\n    function generate(str, left, right) { // khai báo hàm đệ quy generate với 3 tham số\n        if (left === 0 && right === 0) { // nếu số lượng dấu ngoặc mở và đóng bằng 0\n            results.push(str); // thêm chuỗi str vào mảng kết quả\n            return; // thoát khỏi hàm\n        }\n        if (left > 0) { // nếu còn dấu ngoặc mở chưa sử dụng hết\n            generate(str + \"(\", left - 1, right); // thêm dấu ngoặc mở vào chuỗi str và giảm số lượng dấu ngoặc mở còn lại đi 1\n        }\n        if (right > left) { // nếu số lượng dấu ngoặc đóng còn lại nhiều hơn dấu ngoặc mở\n            generate(str + \")\", left, right - 1); // thêm dấu ngoặc đóng vào chuỗi str và giảm số lượng dấu ngoặc đóng còn lại đi 1\n        }\n    }\n\n    generate(\"\", n, n); // bắt đầu chạy hàm generate với chuỗi rỗng và số lượng dấu ngoặc mở và đóng bằng n\n    return results; // trả về mảng kết quả\n}\n```"
                    },
                    {
                        "username": "hawkpie69",
                        "content": "question can be broken down very easily just by understanding the solution set the primary observation is all the brackets are balanced what we get from this if u are making a call for opening bracket then u have to make a call for \\nclosing bracket and the second point from balanced parenthesis is call for closing bracket can never be applied before the opening bracket call and the base case for this  question will be like all the opening and closing brackets are balanced."
                    },
                    {
                        "username": "hawkpie69",
                        "content": "the most simple way to understand the flow of the question is using bruteforce approach i think the complexity will be around 2*2n but the flow is too easy \\nclass Solution {\\n    public List<String> generateParenthesis(int n) {\\n       List<String> ans=new ArrayList<>();\\n\\n       helper(n*2,\"\",0,0,ans,0);\\n\\n       return ans;\\n    }\\n\\n    public void helper(int n,String asf,int oc,int nc,List<String> ans,int idx)\\n    {\\n        if(idx==n)\\n        {\\n            if(isValid(asf))\\n            {\\n                ans.add(asf);\\n            }\\n            return;\\n        }\\n\\n        helper(n,asf+\"(\",oc+1,nc,ans,idx+1);\\n         helper(n,asf+\")\",oc,nc+1,ans,idx+1);\\n    }\\n     public static boolean isValid(String s) {\\n    // Inilization of Stack\\n        Stack<Character> st = new Stack<>();\\n    // Iterating through the given String\\n        for (int i = 0; i < s.length(); i++) {\\n    // Push Open Brackets in the Stack\\n            if (s.charAt(i) == \\'{\\' || s.charAt(i) == \\'(\\' || s.charAt(i) == \\'[\\') {\\n                st.push(s.charAt(i));\\n            }\\n    // checking for the empty stack because if empty this means there is no open bracket at the start which is an invaild string.\\n            else if(st.empty()){\\n                return false;\\n            }\\n    // Check for the close brackets pair on the top and pop them\\n            else if (st.peek() == \\'{\\' && s.charAt(i) == \\'}\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'(\\' && s.charAt(i) == \\')\\' ) {\\n                st.pop();\\n            } else if (st.peek() == \\'[\\' && s.charAt(i) == \\']\\' ) {\\n                st.pop();\\n            }else{\\n                return false;\\n            }\\n\\n        }\\n        return st.empty();\\n\\n\\n    }\\n\\n\\n}"
                    },
                    {
                        "username": "abhishekgoklani0",
                        "content": "The function generateParenthesis returns a vector<string> that contains all the valid combinations, and the helper function backtrack uses a backtracking approach to construct the combinations.\\n\\nIn backtrack, the function adds an open parenthesis to the current combination (temp+\"(\") and continues the backtracking process if the number of open parentheses is less than max. Similarly, it adds a close parenthesis to the current combination (temp+\")\") and continues the backtracking process if the number of close parentheses is less than the number of open parentheses. When the length of the current combination (temp) is equal to 2 * max, it means that a valid combination has been found, so it is added to the result vector ans."
                    },
                    {
                        "username": "charbino",
                        "content": "My solution is getting marked wrong for n=4 due to including `\\'(())(())\\'` in the results. How is this not valid? It\\'s not included in the expected answer"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n       //vector to store all possible combinations\\n        vector<string> res;\\n        //string to store current combination\\n        string s;\\n        //recursive function to generate all combinations\\n        dfs(n,n,s,res);\\n        return res;  \\n    }\\n    void dfs(int left,int right,string s,vector<string> &res){\\n        //base case, when there are no more left or right parentheses to place\\n        if(left==0 && right==0){\\n            //add current combination to result vector\\n            res.push_back(s);\\n            return;\\n        }\\n        //if there are still left parentheses to place, add one to the current combination\\n        if(left>0) dfs(left-1,right,s+\\'(\\',res);\\n        //if there are more right parentheses to place than left, add one to the current combination\\n        if(right>left) dfs(left,right-1,s+\\')\\',res);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n```"
                    },
                    {
                        "username": "jarvis_413",
                        "content": "I think the best approach on solving problem is using catlan\\n"
                    }
                ]
            },
            {
                "id": 1742960,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1741168,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1710452,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1710412,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1709243,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1694707,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1690739,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1671277,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1670975,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            },
            {
                "id": 1653635,
                "content": [
                    {
                        "username": "runtime_terror_04",
                        "content": "plzzz help not working this recursive code\\n\\nclass Solution {\\n    private:\\n    void gen(string ans,set<string>&st,int n){\\n   if(n==0){\\n    string k=\"\";\\n    st.insert(ans);\\n    return ;\\n\\n   }\\n   gen(ans+\"()\",st,n-1);\\n   gen(\"()\"+ans,st,n-1);\\n   gen(\"(\"+ans+\")\",st,n-1);\\n\\n}\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        set<string>st;\\n        vector<string>ss;\\n        string k=\"(()())\";\\n        gen(\"\",st,n);\\n        for(auto it:st){\\n            ss.push_back(it);\\n        }\\n        if(n==4){\\n            ss.push_back(k);\\n        }\\n       return ss;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "smanjot444",
                        "content": "My code doesn\\'t seem to work\\nPlease HELP\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string ds;\\n        vector<string> res; \\n        generator(n, res, ds, 0, 0);\\n        return res;\\n    }\\n\\n    void generator(int n, vector<string> &res, string ds, int open, int close){\\n        if(close>open || open>n || close>n)\\n            return;\\n        if(open==close==n){\\n            res.push_back(ds);\\n            return;\\n        }\\n        generator(n, res, ds + \\'(\\', open + 1, close);\\n        generator(n, res, ds + \\')\\', open, close + 1);\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        if (n == 0) return {};\\n\\n        vector<string> res;\\n\\n        string track;\\n\\n        backtrack(n, n, track, res);\\n        return res;       \\n    }\\n\\n    void backtrack(int left, int right, string& track, vector<string>& res) {\\n        if (right < left) return;\\n        if (left < 0 || right < 0) return;\\n        if (left == 0 && right == 0) {\\n            res.push_back(track);\\n            return;\\n        }\\n        \\n        track.push_back(\\'(\\'); \\n        backtrack(left - 1, right, track, res);\\n        track.pop_back(); \\n\\n        track.push_back(\\')\\'); \\n        backtrack(left, right - 1, track, res);\\n        track.pop_back(); \\n    }\\n};\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "Bg21460",
                        "content": "Java DFS\\nhttps://leetcode.com/problems/generate-parentheses/submissions/856905486/"
                    },
                    {
                        "username": "wikyyuen",
                        "content": " `var resList []string\\n\\nfunc generateParenthesis(n int) []string {\\n\\tresList = []string{}\\n\\ttraverse(\"(\", 1, n-1, n)\\n\\treturn resList\\n}\\n\\nfunc traverse(s string, need int, left int, right int) {\\n\\tif right == 0 && left == 0 {\\n\\t\\tresList = append(resList, s)\\n\\t}\\n\\tif need > 0 && right > 0 {\\n\\t\\ttraverse(s+\")\", need-1, left, right-1)\\n\\t}\\n\\tif left > 0 {\\n\\t\\ttraverse(s+\"(\", need+1, left-1, right)\\n\\t}\\n}`"
                    },
                    {
                        "username": "sagarbalyan",
                        "content": "Why one works but other doesn\\'t?\\n\\nWhy does this not work?\\n\\n`        if(open<n) {\\n            open++;\\n            helper(result,open,close,str+\"(\",n);\\n        }`\\n\\nBut this does?\\n\\n`        if(open<n) {\\n            helper(result,open+1,close,str+\"(\",n);\\n        }`"
                    },
                    {
                        "username": "ayush1018",
                        "content": "Can someone help what is the error in this solution:\\nIt is showing\\nAddressSanitizer:DEADLYSIGNAL\\n\\n\\nclass Solution {\\npublic:\\n\\nvoid solve(int n, int open, int close, string currComb, vector<string>& ans)\\n{\\n    if(open == n && close == n)\\n    {\\n        ans.push_back(currComb);\\n        return;\\n    }\\n\\n    if(open<n)\\n    {\\n        currComb = currComb + \"(\";\\n        solve(n,open+1,close,currComb,ans);\\n    }\\n\\n    if(close<open)\\n    \\n        currComb = currComb + \")\";\\n        solve(n,open,close+1,currComb,ans);\\n    }\\n\\n    vector<string> generateParenthesis(int n) {\\n        int open=0, close=0;\\n        vector<string>ans;\\n        string currComb =\"\";\\n        solve(n,open,close,currComb,ans);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, JAVA and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-generate-parenthese-problem-solution.html)"
                    },
                    {
                        "username": "Shubham_Awasthi__07",
                        "content": " `class Solution {\\n    public void backTrack(List<String> res ,String s, int n , int left , int right){\\n        if(s.length() == 2 * n){\\n            res.add(s);\\n            return ;\\n        }\\n        if (left < n)\\n            backTrack(res , s + \\'(\\' , n , left + 1 , right);\\n        if (right < left)\\n            backTrack(res , s + \\')\\' , n , left , right + 1);\\n\\n    }\\n    public List<String> generateParenthesis(int n) {\\n        List<String> ans = new ArrayList<>();\\n        backTrack(ans , \"\" , n , 0 , 0);\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "Harshleen_Kaur",
                        "content": "What is the time complexity ?"
                    }
                ]
            }
        ]
    }
]