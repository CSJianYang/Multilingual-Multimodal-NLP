[
    {
        "title": "Reconstruct Itinerary",
        "question_content": "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\nAll of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\n\tFor example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\n\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n&nbsp;\nExample 1:\n\nInput: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\nOutput: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\n\nExample 2:\n\nInput: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\nOutput: [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\nExplanation: Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\n\n&nbsp;\nConstraints:\n\n\t1 <= tickets.length <= 300\n\ttickets[i].length == 2\n\tfromi.length == 3\n\ttoi.length == 3\n\tfromi and toi consist of uppercase English letters.\n\tfromi != toi",
        "solutions": [
            {
                "id": 78768,
                "title": "short-ruby-python-java-c",
                "content": "Just Eulerian path. Greedy DFS, building the route backwards when retreating.\\n\\nMore explanation and example under the codes.\\n\\nIterative versions inspired by [fangyang](https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation) (I had only thought of recursion, d\\'oh).\\n\\n---\\n\\n**Ruby**\\n\\n    def find_itinerary(tickets)\\n      tickets = tickets.sort.reverse.group_by(&:first)\\n      route = []\\n      visit = -> airport {\\n        visit[tickets[airport].pop()[1]] while (tickets[airport] || []).any?\\n        route << airport\\n      }\\n      visit[\"JFK\"]\\n      route.reverse\\n    end\\n\\nIterative version:\\n\\n    def find_itinerary(tickets)\\n      tickets = tickets.sort.reverse.group_by(&:first)\\n      route, stack = [], [\"JFK\"]\\n      while stack.any?\\n        stack << tickets[stack[-1]].pop()[1] while (tickets[stack[-1]] || []).any?\\n        route << stack.pop()\\n      end\\n      route.reverse\\n    end\\n\\n---\\n\\n**Python**\\n\\n    def findItinerary(self, tickets):\\n        targets = collections.defaultdict(list)\\n        for a, b in sorted(tickets)[::-1]:\\n            targets[a] += b,\\n        route = []\\n        def visit(airport):\\n            while targets[airport]:\\n                visit(targets[airport].pop())\\n            route.append(airport)\\n        visit(\\'JFK\\')\\n        return route[::-1]\\n\\nIterative version:\\n\\n    def findItinerary(self, tickets):\\n        targets = collections.defaultdict(list)\\n        for a, b in sorted(tickets)[::-1]:\\n            targets[a] += b,\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while targets[stack[-1]]:\\n                stack += targets[stack[-1]].pop(),\\n            route += stack.pop(),\\n        return route[::-1]\\n\\n---\\n\\n**Java**\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        for (String[] ticket : tickets)\\n            targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);\\n        visit(\"JFK\");\\n        return route;\\n    }\\n    \\n    Map<String, PriorityQueue<String>> targets = new HashMap<>();\\n    List<String> route = new LinkedList();\\n    \\n    void visit(String airport) {\\n        while(targets.containsKey(airport) && !targets.get(airport).isEmpty())\\n            visit(targets.get(airport).poll());\\n        route.add(0, airport);\\n    }\\n\\nIterative version:\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, PriorityQueue<String>> targets = new HashMap<>();\\n        for (String[] ticket : tickets)\\n            targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);\\n        List<String> route = new LinkedList();\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.empty()) {\\n            while (targets.containsKey(stack.peek()) && !targets.get(stack.peek()).isEmpty())\\n                stack.push(targets.get(stack.peek()).poll());\\n            route.add(0, stack.pop());\\n        }\\n        return route;\\n    }\\n\\n---\\n\\n**C++**\\n\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        for (auto ticket : tickets)\\n            targets[ticket.first].insert(ticket.second);\\n        visit(\"JFK\");\\n        return vector<string>(route.rbegin(), route.rend());\\n    }\\n\\n    map<string, multiset<string>> targets;\\n    vector<string> route;\\n\\n    void visit(string airport) {\\n        while (targets[airport].size()) {\\n            string next = *targets[airport].begin();\\n            targets[airport].erase(targets[airport].begin());\\n            visit(next);\\n        }\\n        route.push_back(airport);\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nFirst keep going forward until you get stuck. That\\'s a good main path already. Remaining tickets form cycles which are found on the way back and get merged into that main path. By writing down the path backwards when retreating from recursion, merging the cycles into the main path is easy - the end part of the path has already been written, the start part of the path hasn\\'t been written yet, so just write down the cycle now and then keep backwards-writing the path.\\n\\nExample:\\n\\n![enter image description here][1]\\n\\nFrom JFK we first visit JFK -> A -> C -> D -> A. There we\\'re stuck, so we write down A as the end of the route and retreat back to D. There we see the unused ticket to B and follow it: D -> B -> C -> JFK -> D. Then we\\'re stuck again, retreat and write down the airports while doing so: Write down D before the already written A, then JFK before the D, etc. When we\\'re back from our cycle at D, the written route is D -> B -> C -> JFK -> D -> A. Then we retreat further along the original path, prepending C, A and finally JFK to the route, ending up with the route JFK -> A -> C -> D -> B -> C -> JFK -> D -> A.\\n\\n  [1]: https://www.stefan-pochmann.info/misc/reconstruct-itinerary.png",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "Just Eulerian path. Greedy DFS, building the route backwards when retreating.\\n\\nMore explanation and example under the codes.\\n\\nIterative versions inspired by [fangyang](https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation) (I had only thought of recursion, d\\'oh).\\n\\n---\\n\\n**Ruby**\\n\\n    def find_itinerary(tickets)\\n      tickets = tickets.sort.reverse.group_by(&:first)\\n      route = []\\n      visit = -> airport {\\n        visit[tickets[airport].pop()[1]] while (tickets[airport] || []).any?\\n        route << airport\\n      }\\n      visit[\"JFK\"]\\n      route.reverse\\n    end\\n\\nIterative version:\\n\\n    def find_itinerary(tickets)\\n      tickets = tickets.sort.reverse.group_by(&:first)\\n      route, stack = [], [\"JFK\"]\\n      while stack.any?\\n        stack << tickets[stack[-1]].pop()[1] while (tickets[stack[-1]] || []).any?\\n        route << stack.pop()\\n      end\\n      route.reverse\\n    end\\n\\n---\\n\\n**Python**\\n\\n    def findItinerary(self, tickets):\\n        targets = collections.defaultdict(list)\\n        for a, b in sorted(tickets)[::-1]:\\n            targets[a] += b,\\n        route = []\\n        def visit(airport):\\n            while targets[airport]:\\n                visit(targets[airport].pop())\\n            route.append(airport)\\n        visit(\\'JFK\\')\\n        return route[::-1]\\n\\nIterative version:\\n\\n    def findItinerary(self, tickets):\\n        targets = collections.defaultdict(list)\\n        for a, b in sorted(tickets)[::-1]:\\n            targets[a] += b,\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while targets[stack[-1]]:\\n                stack += targets[stack[-1]].pop(),\\n            route += stack.pop(),\\n        return route[::-1]\\n\\n---\\n\\n**Java**\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        for (String[] ticket : tickets)\\n            targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);\\n        visit(\"JFK\");\\n        return route;\\n    }\\n    \\n    Map<String, PriorityQueue<String>> targets = new HashMap<>();\\n    List<String> route = new LinkedList();\\n    \\n    void visit(String airport) {\\n        while(targets.containsKey(airport) && !targets.get(airport).isEmpty())\\n            visit(targets.get(airport).poll());\\n        route.add(0, airport);\\n    }\\n\\nIterative version:\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, PriorityQueue<String>> targets = new HashMap<>();\\n        for (String[] ticket : tickets)\\n            targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);\\n        List<String> route = new LinkedList();\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.empty()) {\\n            while (targets.containsKey(stack.peek()) && !targets.get(stack.peek()).isEmpty())\\n                stack.push(targets.get(stack.peek()).poll());\\n            route.add(0, stack.pop());\\n        }\\n        return route;\\n    }\\n\\n---\\n\\n**C++**\\n\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        for (auto ticket : tickets)\\n            targets[ticket.first].insert(ticket.second);\\n        visit(\"JFK\");\\n        return vector<string>(route.rbegin(), route.rend());\\n    }\\n\\n    map<string, multiset<string>> targets;\\n    vector<string> route;\\n\\n    void visit(string airport) {\\n        while (targets[airport].size()) {\\n            string next = *targets[airport].begin();\\n            targets[airport].erase(targets[airport].begin());\\n            visit(next);\\n        }\\n        route.push_back(airport);\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nFirst keep going forward until you get stuck. That\\'s a good main path already. Remaining tickets form cycles which are found on the way back and get merged into that main path. By writing down the path backwards when retreating from recursion, merging the cycles into the main path is easy - the end part of the path has already been written, the start part of the path hasn\\'t been written yet, so just write down the cycle now and then keep backwards-writing the path.\\n\\nExample:\\n\\n![enter image description here][1]\\n\\nFrom JFK we first visit JFK -> A -> C -> D -> A. There we\\'re stuck, so we write down A as the end of the route and retreat back to D. There we see the unused ticket to B and follow it: D -> B -> C -> JFK -> D. Then we\\'re stuck again, retreat and write down the airports while doing so: Write down D before the already written A, then JFK before the D, etc. When we\\'re back from our cycle at D, the written route is D -> B -> C -> JFK -> D -> A. Then we retreat further along the original path, prepending C, A and finally JFK to the route, ending up with the route JFK -> A -> C -> D -> B -> C -> JFK -> D -> A.\\n\\n  [1]: https://www.stefan-pochmann.info/misc/reconstruct-itinerary.png",
                "codeTag": "Python3"
            },
            {
                "id": 78766,
                "title": "share-my-solution",
                "content": "See also [here](http://algobox.org/reconstruct-itinerary/)\\n\\nAll the airports are vertices and tickets are directed edges. Then all these tickets form a directed graph.\\n\\nThe graph must be Eulerian since we know that a Eulerian path exists.\\n\\nThus, start from \"JFK\", we can apply the Hierholzer's algorithm to find a Eulerian path in the graph which is a valid reconstruction.\\n\\nSince the problem asks for lexical order smallest solution, we can put the neighbors in a min-heap. In this way, we always visit the smallest possible neighbor first in our trip.\\n\\n    public class Solution {\\n\\n        Map<String, PriorityQueue<String>> flights;\\n        LinkedList<String> path;\\n\\n        public List<String> findItinerary(String[][] tickets) {\\n            flights = new HashMap<>();\\n            path = new LinkedList<>();\\n            for (String[] ticket : tickets) {\\n                flights.putIfAbsent(ticket[0], new PriorityQueue<>());\\n                flights.get(ticket[0]).add(ticket[1]);\\n            }\\n            dfs(\"JFK\");\\n            return path;\\n        }\\n\\n        public void dfs(String departure) {\\n            PriorityQueue<String> arrivals = flights.get(departure);\\n            while (arrivals != null && !arrivals.isEmpty())\\n                dfs(arrivals.poll());\\n            path.addFirst(departure);\\n        }\\n    }\\n\\n    79 / 79 test cases passed.\\n    Status: Accepted\\n    Runtime: 11 ms",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\n        Map<String, PriorityQueue<String>> flights;\\n        LinkedList<String> path;\\n\\n        public List<String> findItinerary(String[][] tickets) {\\n            flights = new HashMap<>();\\n            path = new LinkedList<>();\\n            for (String[] ticket : tickets) {\\n                flights.putIfAbsent(ticket[0], new PriorityQueue<>());\\n                flights.get(ticket[0]).add(ticket[1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 78799,
                "title": "very-straightforward-dfs-solution-with-detailed-explanations",
                "content": "The nice thing about DFS is it tries a path, and if that\\'s wrong (i.e. path does not lead to solution), DFS goes one step back and tries another path. It continues to do so until we\\'ve found the correct path (which leads to the solution). You need to always bear this nice feature in mind when utilizing DFS to solve problems.\\n\\nIn this problem, the path we are going to find is an itinerary which:\\n1. uses all tickets to travel among airports\\n2. preferably in ascending lexical order of airport code\\n\\nKeep in mind that requirement 1 must be satisfied before we consider 2. If we always choose the airport with the smallest lexical order, this would lead to a perfectly lexical-ordered itinerary, but pay attention that when doing so, there can be a \"dead end\" somewhere in the tickets such that we are not able visit all airports (or we can\\'t use all our tickets), which is bad because it fails to satisfy requirement 1 of this problem. Thus we need to take a step back and try other possible airports, which might not give us a perfectly ordered solution, but will use all tickets and cover all airports.\\n\\nThus it\\'s natural to think about the \"backtracking\" feature of DFS. We start by building a graph and then sorting vertices in the adjacency list so that when we traverse the graph later, we can guarantee the lexical order of the itinerary can be as good as possible. When we have generated an itinerary, we check if we have used all our airline tickets. If not, we revert the change and try another ticket. We keep trying until we have used all our tickets.\\n\\n    public class Solution {\\n        private HashMap<String, List<String>> adjList = new HashMap<>();\\n        private LinkedList<String> route = new LinkedList<>();\\n        private int numTickets = 0;\\n        private int numTicketsUsed = 0;\\n        \\n        public List<String> findItinerary(String[][] tickets) {\\n            if (tickets == null || tickets.length == 0) return route;\\n            // build graph\\n            numTickets = tickets.length;\\n            for (int i = 0; i < tickets.length; ++i) {\\n                if (!adjList.containsKey(tickets[i][0])) {\\n                    // create a new list\\n                    List<String> list = new ArrayList<>();\\n                    list.add(tickets[i][1]);\\n                    adjList.put(tickets[i][0], list);\\n                } else {\\n                    // add to existing list\\n                    adjList.get(tickets[i][0]).add(tickets[i][1]);\\n                }\\n            }\\n            // sort vertices in the adjacency list so they appear in lexical order\\n            for (Map.Entry<String, List<String>> entry : adjList.entrySet()) {\\n                Collections.sort(entry.getValue());\\n            }\\n            \\n            // start DFS\\n            route.add(\"JFK\");\\n            dfsRoute(\"JFK\");\\n            return route;\\n        }\\n        \\n        private void dfsRoute(String v) {\\n            // base case: vertex v is not in adjacency list\\n            // v is not a starting point in any itinerary, or we would have stored it\\n            // thus we have reached end point in our DFS\\n            if (!adjList.containsKey(v)) return;\\n            List<String> list = adjList.get(v);\\n            for (int i = 0; i < list.size(); ++i) {\\n                String neighbor = list.get(i);\\n                // remove ticket(route) from graph\\n                list.remove(i);\\n                route.add(neighbor);\\n                numTicketsUsed++;\\n                dfsRoute(neighbor);\\n                // we only return when we have used all tickets\\n                if (numTickets == numTicketsUsed) return;\\n                // otherwise we need to revert the changes and try other tickets\\n                list.add(i, neighbor);\\n                // This line took me a long time to debug\\n                // we must remove the last airport, since in an itinerary, the same airport can appear many times!!\\n                route.removeLast();\\n                numTicketsUsed--;\\n            }\\n        }\\n        \\n    }\\n\\n\\nUpdated solution:\\nSimpler explanation: the idea is DFS backtracking and we greedily pick the smallest lexical order possible first when we iterate over all our paths. In this case local optimum leads to global optimum. If we try airports with smallest lexical order first then we always find the desired solution first.\\n\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // dfs backtracking, each time we go to smallest lexical order airport\\n        HashMap<String, TreeMap<String, Integer>> map = new HashMap<>();   // key: Departure, (Arrival, Number of tickets available)\\n        \\n        for (List<String> ticket : tickets) {\\n            String dep = ticket.get(0);\\n            String arr = ticket.get(1);\\n            if (!map.containsKey(dep)) {\\n                map.put(dep, new TreeMap<>());\\n            }\\n            TreeMap<String, Integer> arrMap = map.get(dep);\\n            if (!arrMap.containsKey(arr)) {\\n                arrMap.put(arr, 0);\\n            }\\n            arrMap.put(arr, arrMap.get(arr)+1);\\n        }\\n        \\n        List<String> itinerary = new LinkedList<>();\\n        dfs(map, tickets.size(), itinerary, \"JFK\");\\n        \\n        itinerary.add(0, \"JFK\");\\n        return itinerary;\\n    }\\n    \\n    private boolean dfs(HashMap<String, TreeMap<String, Integer>> map, int numTickets, List<String> itinerary, String depAirport) {\\n        if (itinerary.size() == numTickets) {\\n            return true;\\n        }\\n        \\n        if (!map.containsKey(depAirport)) {\\n            return false;\\n        }\\n        \\n        TreeMap<String, Integer> arrMap = map.get(depAirport);\\n        for (Map.Entry<String, Integer> entry : arrMap.entrySet()) {\\n            String arrAirport = entry.getKey();\\n            int count = entry.getValue();\\n            // if no ticket availble, continue\\n            if (count == 0) {\\n                continue;\\n            }            \\n            // else make choice\\n            itinerary.add(arrAirport);\\n            arrMap.put(arrAirport, count-1);\\n            if (dfs(map, numTickets, itinerary, arrAirport)) {\\n                return true;\\n            }\\n            // revert back if no answer found\\n            itinerary.remove(itinerary.size()-1);\\n            arrMap.put(arrAirport, count);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // dfs backtracking, each time we go to smallest lexical order airport\\n        HashMap<String, TreeMap<String, Integer>> map = new HashMap<>();   // key: Departure, (Arrival, Number of tickets available)\\n        \\n        for (List<String> ticket : tickets) {\\n            String dep = ticket.get(0);\\n            String arr = ticket.get(1);\\n            if (!map.containsKey(dep)) {\\n                map.put(dep, new TreeMap<>());\\n            }\\n            TreeMap<String, Integer> arrMap = map.get(dep);\\n            if (!arrMap.containsKey(arr)) {\\n                arrMap.put(arr, 0);\\n            }\\n            arrMap.put(arr, arrMap.get(arr)+1);\\n        }\\n        \\n        List<String> itinerary = new LinkedList<>();\\n        dfs(map, tickets.size(), itinerary, \"JFK\");\\n        \\n        itinerary.add(0, \"JFK\");\\n        return itinerary;\\n    }\\n    \\n    private boolean dfs(HashMap<String, TreeMap<String, Integer>> map, int numTickets, List<String> itinerary, String depAirport) {\\n        if (itinerary.size() == numTickets) {\\n            return true;\\n        }\\n        \\n        if (!map.containsKey(depAirport)) {\\n            return false;\\n        }\\n        \\n        TreeMap<String, Integer> arrMap = map.get(depAirport);\\n        for (Map.Entry<String, Integer> entry : arrMap.entrySet()) {\\n            String arrAirport = entry.getKey();\\n            int count = entry.getValue();\\n            // if no ticket availble, continue\\n            if (count == 0) {\\n                continue;\\n            }            \\n            // else make choice\\n            itinerary.add(arrAirport);\\n            arrMap.put(arrAirport, count-1);\\n            if (dfs(map, numTickets, itinerary, arrAirport)) {\\n                return true;\\n            }\\n            // revert back if no answer found\\n            itinerary.remove(itinerary.size()-1);\\n            arrMap.put(arrAirport, count);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375397,
                "title": "simply-simple-python-solution-using-stack-for-dfs-with-comments",
                "content": "\\tclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = {}\\n        # Create a graph for each airport and keep list of airport reachable from it\\n        for src, dst in tickets:\\n            if src in graph:\\n                graph[src].append(dst)\\n            else:\\n                graph[src] = [dst]\\n\\n        for src in graph.keys():\\n            graph[src].sort(reverse=True)\\n            # Sort children list in descending order so that we can pop last element \\n            # instead of pop out first element which is costly operation\\n        stack = []\\n        res = []\\n        stack.append(\"JFK\")\\n        # Start with JFK as starting airport and keep adding the next child to traverse \\n        # for the last airport at the top of the stack. If we reach to an airport from where \\n        # we can\\'t go further then add it to the result. This airport should be the last to go \\n        # since we can\\'t go anywhere from here. That\\'s why we return the reverse of the result\\n        # After this backtrack to the top airport in the stack and continue to traaverse it\\'s children\\n        \\n        while len(stack) > 0:\\n            elem = stack[-1]\\n            if elem in graph and len(graph[elem]) > 0: \\n                # Check if elem in graph as there may be a case when there is no out edge from an airport \\n                # In that case it won\\'t be present as a key in graph\\n                stack.append(graph[elem].pop())\\n            else:\\n                res.append(stack.pop())\\n                # If there is no further children to traverse then add that airport to res\\n                # This airport should be the last to go since we can\\'t anywhere from this\\n                # That\\'s why we return the reverse of the result\\n        return res[::-1]\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = {}",
                "codeTag": "Java"
            },
            {
                "id": 709590,
                "title": "python-short-euler-path-finding-o-e-log-e-explained",
                "content": "Actually, in this problem we are asked to find Euler path, smallest lexically. There is classical algorithm with complexity `O(E)`. Starting from the starting vertex `v`, we build a path by adding at each step an edge that has not yet been passed and is adjacent to the current vertex. The vertices of the path are accumulated in stack `S`. When the moment comes when for the current node `w` all the incident edges have already passed, we write the vertices from `S` in output until we meet the node where the incident has not passed yet edges. Then we continue our traversal of the unattended edges. It can be written both with recursion or with stack, recursion version is shorter.\\n\\nHere is a link, where you can plunge deeper into this:\\nhttp://www.graph-magics.com/articles/euler.php\\n\\nIf you neves saw this problem and even if you know what **Euler path** is, I think it is almost impossible to invent this algorighm by yourself, and this problem should be marked as **hard**.\\n\\n**Complexity**: time and space complexity of usual Euler Path Finding algorighm is `O(E+V) = O(E)`, because we traverse each edge only once and number of edges is more than number of vertixes - 1 in Eulerian graph. However as @ainkartik203 mentioned, here we sort our list for every node, so complexity will be `O(E log E)`.\\n\\n```\\nclass Solution:\\n    def dfs(self, airport):\\n        while self.adj_list[airport]:\\n            candidate = self.adj_list[airport].pop()\\n            self.dfs(candidate)\\n        self.route.append(airport)\\n            \\n    def findItinerary(self, tickets):\\n        self.route = []\\n        self.adj_list = defaultdict(list)\\n        for i,j in tickets:\\n            self.adj_list[i].append(j)\\n        for key in self.adj_list: \\n            self.adj_list[key] = sorted(self.adj_list[key], reverse=True)\\n            \\n        self.dfs(\"JFK\")\\n        return self.route[::-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def dfs(self, airport):\\n        while self.adj_list[airport]:\\n            candidate = self.adj_list[airport].pop()\\n            self.dfs(candidate)\\n        self.route.append(airport)\\n            \\n    def findItinerary(self, tickets):\\n        self.route = []\\n        self.adj_list = defaultdict(list)\\n        for i,j in tickets:\\n            self.adj_list[i].append(j)\\n        for key in self.adj_list: \\n            self.adj_list[key] = sorted(self.adj_list[key], reverse=True)\\n            \\n        self.dfs(\"JFK\")\\n        return self.route[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78835,
                "title": "28ms-c-beats-100-short-and-elegant",
                "content": "I think this algorithm is often called Fleury's algorithm. But actually it is  Hierholzer's algorithm according to the wiki. Anyway, it works like this:\\n\\nKeep going one path until stuck, then retreat and push the vertices along the route to a stack until it reaches a vertex that has alternative paths, then go along that path and repeat the process.\\nThe assumption for this to work is there is guaranteed to exist one Euler path. (This problem is basically to find a Euler path of a graph).\\n\\n      class Solution {\\n            unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n            vector<string> result;\\n            void dfs(string vtex)\\n            {\\n                auto & edges = graph[vtex];\\n                while (!edges.empty())\\n                {\\n                    string to_vtex = edges.top();\\n                    edges.pop();\\n                    dfs(to_vtex);\\n                }\\n                result.push_back(vtex);\\n            }\\n        public:\\n            vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n                for (auto e : tickets)\\n                    graph[e.first].push(e.second);\\n                dfs(\"JFK\");\\n                reverse(result.begin(), result.end());\\n                return result;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n            unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n            vector<string> result;\\n            void dfs(string vtex)\\n            {\\n                auto & edges = graph[vtex];\\n                while (!edges.empty())\\n                {\\n                    string to_vtex = edges.top();\\n                    edges.pop();\\n                    dfs(to_vtex);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4041944,
                "title": "95-76-dfs-recursive-iterative",
                "content": "# Comprehensive Guide to Solving \"Reconstruct Itinerary\": Navigating Airports Like a Pro\\n\\n## Introduction & Problem Statement\\n\\nHello, coding enthusiasts! Today, we\\'ll tackle a problem that combines graph theory and real-world scenarios: \"Reconstruct Itinerary.\" The problem asks you to reconstruct a trip\\'s itinerary given a list of airline tickets. The catch? You start from JFK airport, and if there are multiple valid itineraries, you should return the one that has the smallest lexical order.\\n\\n## Key Concepts and Constraints\\n\\n### What Makes This Problem Unique?\\n\\n1. **Graph Theory**: \\n   The problem can be modeled as a directed graph, where each airport is a node and each ticket represents a directed edge between airports.\\n  \\n2. **Lexical Order**: \\n   Among multiple valid itineraries, the one with the smallest lexical order is preferred.\\n\\n3. **Constraints**: \\n   - 1 <= tickets.length <= 300\\n   - Tickets are given as pairs [fromi, toi] of strings.\\n   - Each string consists of 3 uppercase English letters.\\n\\n### Strategies to Tackle the Problem\\n\\n1. **Recursive DFS**: \\n   This approach leverages the stack memory implicitly during recursion to backtrack and form the itinerary.\\n   \\n2. **Iterative DFS**: \\n   This approach explicitly uses a stack to perform DFS iteratively.\\n\\n---\\n\\n## Live Coding & More in Python\\nhttps://www.youtube.com/watch?v=migy5oXV1Uc\\n\\n## Recursive DFS Explained\\n\\n### Extended Explanation: Logic Behind the \"Find Itinerary\" Solution using Recursive DFS\\n\\n### What is Recursive DFS?\\n\\nDFS, short for Depth-First Search, is a graph-traversal algorithm. In this specific problem, we use the recursive version of DFS, which exploits the call stack to keep track of the airports (vertices) that still need exploration.\\n\\n### The Intricacies of Recursive DFS in \"Find Itinerary\"\\n\\n1. **Initialize the Graph**:  \\n    - We start by initializing an adjacency list `graph` that will serve as a representation of the directed graph of flights. The graph is implemented as a defaultdict containing lists.\\n  \\n    - The adjacency list is constructed by iterating over the given list of ticket pairs, where each pair consists of a source airport and a destination airport.\\n  \\n    - These lists of destinations are sorted in reverse lexical order. This allows us to pop the last element to ensure that we are choosing the smallest lexical order when there are multiple options.\\n\\n2. **DFS Traversal and Exploration**:  \\n    - The traversal starts from the JFK airport, which is our initial point. We initiate a recursive DFS function that takes the current airport as an argument.\\n  \\n    - Inside this function, we enter a loop that continues until we find an airport that has no more destinations left to visit. This is done by checking the adjacency list for each airport and popping the last element (which is the smallest in lexical order).\\n  \\n    - During this process, we recursively call the DFS function for each new destination, essentially diving deeper into the graph.\\n\\n3. **Backtrack and Construct Itinerary**:  \\n    - Once we reach an airport with no outgoing edges, or in other words, no more destinations to visit, we start backtracking.\\n  \\n    - During the backtracking phase, we add the current airport to our `itinerary` list. This list was initially empty and serves as the container for our final solution.\\n\\n    - Importantly, we are essentially building the itinerary in reverse during this phase because of the way DFS works. As we backtrack, we are popping from the call stack, revisiting the airports in the reverse order of how they will eventually appear in the itinerary.\\n\\n4. **Reverse to Get the Final Itinerary**:  \\n    - Since we constructed the itinerary in reverse, the final step is to reverse this list. This gives us the correct order of airports to visit, starting from JFK, and is our final solution.\\n\\n### Time and Space Complexity\\n\\n- **Time Complexity**: $$O(N \\\\log N)$$ due to sorting the tickets.\\n- **Space Complexity**: $$O(N)$$, for storing the graph and the itinerary.\\n\\n# Code Recursive \\n``` Python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        \\n        for src, dst in sorted(tickets, reverse=True):\\n            graph[src].append(dst)\\n            \\n        itinerary = []\\n        def dfs(airport):\\n            while graph[airport]:\\n                dfs(graph[airport].pop())\\n            itinerary.append(airport)\\n        \\n        dfs(\"JFK\")\\n        \\n        return itinerary[::-1]\\n```\\n``` Go []\\nfunc findItinerary(tickets [][]string) []string {\\n\\tgraph := make(map[string][]string)\\n\\t\\n\\tfor _, ticket := range tickets {\\n\\t\\tgraph[ticket[0]] = append(graph[ticket[0]], ticket[1])\\n\\t}\\n\\t\\n\\tfor key := range graph {\\n\\t\\tsort.Sort(sort.Reverse(sort.StringSlice(graph[key])))\\n\\t}\\n\\t\\n\\tvar itinerary []string\\n\\t\\n\\tvar dfs func(airport string)\\n\\tdfs = func(airport string) {\\n\\t\\tfor len(graph[airport]) > 0 {\\n\\t\\t\\tnext := graph[airport][len(graph[airport])-1]\\n\\t\\t\\tgraph[airport] = graph[airport][:len(graph[airport])-1]\\n\\t\\t\\tdfs(next)\\n\\t\\t}\\n\\t\\titinerary = append(itinerary, airport)\\n\\t}\\n\\t\\n\\tdfs(\"JFK\")\\n\\t\\n\\tfor i := 0; i < len(itinerary)/2; i++ {\\n\\t\\titinerary[i], itinerary[len(itinerary)-1-i] = itinerary[len(itinerary)-1-i], itinerary[i]\\n\\t}\\n\\t\\n\\treturn itinerary\\n}\\n```\\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn find_itinerary(tickets: Vec<Vec<String>>) -> Vec<String> {\\n        let mut graph: HashMap<String, Vec<String>> = HashMap::new();\\n        \\n        for ticket in &tickets {\\n            let (src, dst) = (ticket[0].clone(), ticket[1].clone());\\n            graph.entry(src.clone()).or_insert(vec![]).push(dst);\\n        }\\n\\n        for destinations in graph.values_mut() {\\n            destinations.sort_by(|a, b| b.cmp(a));\\n        }\\n        \\n        let mut itinerary = vec![];\\n        \\n        fn dfs(graph: &mut HashMap<String, Vec<String>>, airport: &str, itinerary: &mut Vec<String>) {\\n            while let Some(next) = graph.get_mut(airport).and_then(|dests| dests.pop()) {\\n                dfs(graph, &next, itinerary);\\n            }\\n            itinerary.push(airport.to_string());\\n        }\\n        \\n        dfs(&mut graph, \"JFK\", &mut itinerary);\\n        \\n        itinerary.reverse();\\n        \\n        itinerary\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n        \\n        for (auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto& [_, destinations] : graph) {\\n            sort(destinations.rbegin(), destinations.rend());\\n        }\\n        \\n        vector<string> itinerary;\\n        \\n        function<void(const string&)> dfs = [&](const string& airport) {\\n            while (!graph[airport].empty()) {\\n                string next = graph[airport].back();\\n                graph[airport].pop_back();\\n                dfs(next);\\n            }\\n            itinerary.push_back(airport);\\n        };\\n        \\n        dfs(\"JFK\");\\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        dfs(\"JFK\", graph, itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(String airport, Map<String, PriorityQueue<String>> graph, LinkedList<String> itinerary) {\\n        PriorityQueue<String> nextAirports = graph.get(airport);\\n        while (nextAirports != null && !nextAirports.isEmpty()) {\\n            dfs(nextAirports.poll(), graph, itinerary);\\n        }\\n        itinerary.addFirst(airport);\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var graph = new Dictionary<string, List<string>>();\\n        \\n        foreach (var ticket in tickets) {\\n            if (!graph.ContainsKey(ticket[0])) {\\n                graph[ticket[0]] = new List<string>();\\n            }\\n            graph[ticket[0]].Add(ticket[1]);\\n        }\\n        \\n        foreach (var destinations in graph.Values) {\\n            destinations.Sort((a, b) => b.CompareTo(a));\\n        }\\n        \\n        var itinerary = new List<string>();\\n        \\n        void DFS(string airport) {\\n            while (graph.ContainsKey(airport) && graph[airport].Count > 0) {\\n                var next = graph[airport][^1];\\n                graph[airport].RemoveAt(graph[airport].Count - 1);\\n                DFS(next);\\n            }\\n            itinerary.Add(airport);\\n        }\\n        \\n        DFS(\"JFK\");\\n        itinerary.Reverse();\\n        \\n        return itinerary;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = {};\\n    \\n    for (const [src, dst] of tickets) {\\n        if (!graph[src]) graph[src] = [];\\n        graph[src].push(dst);\\n    }\\n    \\n    for (const key in graph) {\\n        graph[key].sort().reverse();\\n    }\\n    \\n    const itinerary = [];\\n    \\n    function dfs(airport) {\\n        while (graph[airport] && graph[airport].length > 0) {\\n            dfs(graph[airport].pop());\\n        }\\n        itinerary.push(airport);\\n    }\\n    \\n    dfs(\"JFK\");\\n    \\n    return itinerary.reverse();\\n};\\n```\\n``` PHP []\\nclass Solution {\\n    function findItinerary($tickets) {\\n        $graph = [];\\n        \\n        foreach ($tickets as [$src, $dst]) {\\n            $graph[$src][] = $dst;\\n        }\\n        \\n        foreach ($graph as &$destinations) {\\n            rsort($destinations);\\n        }\\n        \\n        $itinerary = [];\\n        \\n        $dfs = function($airport) use (&$graph, &$itinerary, &$dfs) {\\n            while (!empty($graph[$airport])) {\\n                $dfs(array_pop($graph[$airport]));\\n            }\\n            $itinerary[] = $airport;\\n        };\\n        \\n        $dfs(\"JFK\");\\n        \\n        return array_reverse($itinerary);\\n    }\\n}\\n```\\n\\n## Iterative DFS Explained\\n\\n### How Does Iterative DFS Work?\\n\\nIterative DFS also starts by initializing the graph in the same manner as the recursive approach. The difference lies in the traversal and the building of the itinerary.\\n\\n1. **Initialize Stack**:  \\n   - We explicitly initialize a stack with \"JFK\" as the starting point.\\n  \\n2. **Iterative DFS Traversal**:  \\n   - We use the stack to manage the DFS traversal. For each airport on the stack, we keep visiting its next available destination until it has no outgoing edges.\\n  \\n3. **Build Itinerary**:  \\n   - During this process, we keep adding the current airport to the `itinerary` list.\\n  \\n4. **Reverse the Itinerary**:  \\n   - Finally, we reverse the `itinerary` list to get the final itinerary in correct order.\\n\\n### Time and Space Complexity\\n\\n- **Time Complexity**: $$O(N \\\\log N)$$, due to sorting.\\n- **Space Complexity**: $$O(N)$$, for storing the graph and the itinerary.\\n\\n\\n# Code Iterative\\n``` Python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        \\n        for src, dst in sorted(tickets, reverse=True):\\n            graph[src].append(dst)\\n        \\n        stack = [\"JFK\"]\\n        itinerary = []\\n        \\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].pop())\\n            itinerary.append(stack.pop())\\n        \\n        return itinerary[::-1]\\n```\\n``` Go []\\nfunc findItinerary(tickets [][]string) []string {\\n\\tgraph := make(map[string][]string)\\n\\t\\n\\tfor _, ticket := range tickets {\\n\\t\\tgraph[ticket[0]] = append(graph[ticket[0]], ticket[1])\\n\\t}\\n\\t\\n\\tfor key := range graph {\\n\\t\\tsort.Sort(sort.Reverse(sort.StringSlice(graph[key])))\\n\\t}\\n\\t\\n\\tstack := []string{\"JFK\"}\\n\\tvar itinerary []string\\n\\t\\n\\tfor len(stack) > 0 {\\n\\t\\tfor len(graph[stack[len(stack)-1]]) > 0 {\\n\\t\\t\\tlast := len(graph[stack[len(stack)-1]]) - 1\\n\\t\\t\\tstack = append(stack, graph[stack[len(stack)-1]][last])\\n\\t\\t\\tgraph[stack[len(stack)-2]] = graph[stack[len(stack)-2]][:last]\\n\\t\\t}\\n\\t\\titinerary = append(itinerary, stack[len(stack)-1])\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t}\\n\\t\\n\\tfor i := 0; i < len(itinerary)/2; i++ {\\n\\t\\titinerary[i], itinerary[len(itinerary)-1-i] = itinerary[len(itinerary)-1-i], itinerary[i]\\n\\t}\\n\\t\\n\\treturn itinerary\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> findItinerary(std::vector<std::vector<std::string>>& tickets) {\\n        std::unordered_map<std::string, std::vector<std::string>> graph;\\n        \\n        for (auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto& [_, dests] : graph) {\\n            std::sort(dests.rbegin(), dests.rend());\\n        }\\n        \\n        std::vector<std::string> stack = {\"JFK\"};\\n        std::vector<std::string> itinerary;\\n        \\n        while (!stack.empty()) {\\n            std::string curr = stack.back();\\n            if (graph.find(curr) != graph.end() && !graph[curr].empty()) {\\n                stack.push_back(graph[curr].back());\\n                graph[curr].pop_back();\\n            } else {\\n                itinerary.push_back(stack.back());\\n                stack.pop_back();\\n            }\\n        }\\n        \\n        std::reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.computeIfAbsent(ticket.get(0), k -> new PriorityQueue<>()).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> stack = new LinkedList<>();\\n        stack.add(\"JFK\");\\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        while (!stack.isEmpty()) {\\n            while (graph.getOrDefault(stack.peekLast(), new PriorityQueue<>()).size() > 0) {\\n                stack.add(graph.get(stack.peekLast()).poll());\\n            }\\n            itinerary.addFirst(stack.pollLast());\\n        }\\n        \\n        return itinerary;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = {};\\n    \\n    for (const [src, dst] of tickets) {\\n        if (!graph[src]) graph[src] = [];\\n        graph[src].push(dst);\\n    }\\n    \\n    for (const key in graph) {\\n        graph[key].sort((a, b) => b.localeCompare(a));\\n    }\\n    \\n    const stack = [\\'JFK\\'];\\n    const itinerary = [];\\n    \\n    while (stack.length > 0) {\\n        while (graph[stack[stack.length - 1]] && graph[stack[stack.length - 1]].length > 0) {\\n            stack.push(graph[stack[stack.length - 1]].pop());\\n        }\\n        itinerary.push(stack.pop());\\n    }\\n    \\n    return itinerary.reverse();\\n};\\n```\\n``` C# []\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var graph = new Dictionary<string, List<string>>();\\n        \\n        foreach (var ticket in tickets) {\\n            if (!graph.ContainsKey(ticket[0])) {\\n                graph[ticket[0]] = new List<string>();\\n            }\\n            graph[ticket[0]].Add(ticket[1]);\\n        }\\n\\n        foreach (var key in graph.Keys) {\\n            graph[key].Sort((a, b) => b.CompareTo(a));\\n        }\\n        \\n        var stack = new Stack<string>();\\n        stack.Push(\"JFK\");\\n        var itinerary = new List<string>();\\n        \\n        while (stack.Count > 0) {\\n            string curr = stack.Peek();\\n            if (graph.ContainsKey(curr) && graph[curr].Count > 0) {\\n                var next = graph[curr].Last();\\n                graph[curr].RemoveAt(graph[curr].Count - 1);\\n                stack.Push(next);\\n            } else {\\n                itinerary.Add(stack.Pop());\\n            }\\n        }\\n        \\n        itinerary.Reverse();\\n        return itinerary;\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function findItinerary($tickets) {\\n        $graph = [];\\n        foreach ($tickets as $ticket) {\\n            $graph[$ticket[0]][] = $ticket[1];\\n        }\\n        \\n        foreach ($graph as &$dests) {\\n            rsort($dests);\\n        }\\n        \\n        $stack = [\"JFK\"];\\n        $itinerary = [];\\n        \\n        while (!empty($stack)) {\\n            while (!empty($graph[end($stack)])) {\\n                array_push($stack, array_pop($graph[end($stack)]));\\n            }\\n            array_push($itinerary, array_pop($stack));\\n        }\\n        \\n        return array_reverse($itinerary);\\n    }\\n}\\n```\\n\\n## Performance\\n\\n| Language   | Time (ms) | Memory (MB) | Approach  |\\n|------------|-----------|-------------|-----------|\\n| Rust       | 5         | 2.2         | Recursive |\\n| Java       | 5         | 44.1        | Recursive |\\n| Go         | 8         | 6.8         | Recursive |\\n| Go         | 10        | 6.7         | Iterative |\\n| C++        | 12        | 14.6        | Recursive |\\n| PHP        | 18        | 21          | Recursive |\\n| JavaScript | 77        | 47.1        | Recursive |\\n| Python3    | 82        | 16.6        | Recursive |\\n| Python3    | 85        | 16.8        | Iterative |\\n| C#         | 178       | 57.7        | Recursive |\\n\\n![b11.png](https://assets.leetcode.com/users/images/c032f122-5ee0-4d4f-b0f2-1758df340ab5_1694653453.7386682.png)\\n\\n\\n## Live Coding+ & Go\\nhttps://youtu.be/_r9OZwy5x4c?si=P-9OousNlDl-cZnJ\\n\\n## Code Highlights and Best Practices\\n\\n- The Recursive DFS is elegant but uses the system stack, making it susceptible to stack overflow for very large graphs.\\n- The Iterative DFS is more flexible as it explicitly uses a stack, allowing for better control over the traversal process.\\n  \\nMastering these approaches not only helps you solve this problem but also enhances your understanding of graph traversal algorithms, which are widely applicable in various domains. So, are you ready to construct some itineraries? Let\\'s get coding!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        \\n        for src, dst in sorted(tickets, reverse=True):\\n            graph[src].append(dst)\\n            \\n        itinerary = []\\n        def dfs(airport):\\n            while graph[airport]:\\n                dfs(graph[airport].pop())\\n            itinerary.append(airport)\\n        \\n        dfs(\"JFK\")\\n        \\n        return itinerary[::-1]\\n```\n``` Go []\\nfunc findItinerary(tickets [][]string) []string {\\n\\tgraph := make(map[string][]string)\\n\\t\\n\\tfor _, ticket := range tickets {\\n\\t\\tgraph[ticket[0]] = append(graph[ticket[0]], ticket[1])\\n\\t}\\n\\t\\n\\tfor key := range graph {\\n\\t\\tsort.Sort(sort.Reverse(sort.StringSlice(graph[key])))\\n\\t}\\n\\t\\n\\tvar itinerary []string\\n\\t\\n\\tvar dfs func(airport string)\\n\\tdfs = func(airport string) {\\n\\t\\tfor len(graph[airport]) > 0 {\\n\\t\\t\\tnext := graph[airport][len(graph[airport])-1]\\n\\t\\t\\tgraph[airport] = graph[airport][:len(graph[airport])-1]\\n\\t\\t\\tdfs(next)\\n\\t\\t}\\n\\t\\titinerary = append(itinerary, airport)\\n\\t}\\n\\t\\n\\tdfs(\"JFK\")\\n\\t\\n\\tfor i := 0; i < len(itinerary)/2; i++ {\\n\\t\\titinerary[i], itinerary[len(itinerary)-1-i] = itinerary[len(itinerary)-1-i], itinerary[i]\\n\\t}\\n\\t\\n\\treturn itinerary\\n}\\n```\n``` Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn find_itinerary(tickets: Vec<Vec<String>>) -> Vec<String> {\\n        let mut graph: HashMap<String, Vec<String>> = HashMap::new();\\n        \\n        for ticket in &tickets {\\n            let (src, dst) = (ticket[0].clone(), ticket[1].clone());\\n            graph.entry(src.clone()).or_insert(vec![]).push(dst);\\n        }\\n\\n        for destinations in graph.values_mut() {\\n            destinations.sort_by(|a, b| b.cmp(a));\\n        }\\n        \\n        let mut itinerary = vec![];\\n        \\n        fn dfs(graph: &mut HashMap<String, Vec<String>>, airport: &str, itinerary: &mut Vec<String>) {\\n            while let Some(next) = graph.get_mut(airport).and_then(|dests| dests.pop()) {\\n                dfs(graph, &next, itinerary);\\n            }\\n            itinerary.push(airport.to_string());\\n        }\\n        \\n        dfs(&mut graph, \"JFK\", &mut itinerary);\\n        \\n        itinerary.reverse();\\n        \\n        itinerary\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n        \\n        for (auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto& [_, destinations] : graph) {\\n            sort(destinations.rbegin(), destinations.rend());\\n        }\\n        \\n        vector<string> itinerary;\\n        \\n        function<void(const string&)> dfs = [&](const string& airport) {\\n            while (!graph[airport].empty()) {\\n                string next = graph[airport].back();\\n                graph[airport].pop_back();\\n                dfs(next);\\n            }\\n            itinerary.push_back(airport);\\n        };\\n        \\n        dfs(\"JFK\");\\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        dfs(\"JFK\", graph, itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(String airport, Map<String, PriorityQueue<String>> graph, LinkedList<String> itinerary) {\\n        PriorityQueue<String> nextAirports = graph.get(airport);\\n        while (nextAirports != null && !nextAirports.isEmpty()) {\\n            dfs(nextAirports.poll(), graph, itinerary);\\n        }\\n        itinerary.addFirst(airport);\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var graph = new Dictionary<string, List<string>>();\\n        \\n        foreach (var ticket in tickets) {\\n            if (!graph.ContainsKey(ticket[0])) {\\n                graph[ticket[0]] = new List<string>();\\n            }\\n            graph[ticket[0]].Add(ticket[1]);\\n        }\\n        \\n        foreach (var destinations in graph.Values) {\\n            destinations.Sort((a, b) => b.CompareTo(a));\\n        }\\n        \\n        var itinerary = new List<string>();\\n        \\n        void DFS(string airport) {\\n            while (graph.ContainsKey(airport) && graph[airport].Count > 0) {\\n                var next = graph[airport][^1];\\n                graph[airport].RemoveAt(graph[airport].Count - 1);\\n                DFS(next);\\n            }\\n            itinerary.Add(airport);\\n        }\\n        \\n        DFS(\"JFK\");\\n        itinerary.Reverse();\\n        \\n        return itinerary;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = {};\\n    \\n    for (const [src, dst] of tickets) {\\n        if (!graph[src]) graph[src] = [];\\n        graph[src].push(dst);\\n    }\\n    \\n    for (const key in graph) {\\n        graph[key].sort().reverse();\\n    }\\n    \\n    const itinerary = [];\\n    \\n    function dfs(airport) {\\n        while (graph[airport] && graph[airport].length > 0) {\\n            dfs(graph[airport].pop());\\n        }\\n        itinerary.push(airport);\\n    }\\n    \\n    dfs(\"JFK\");\\n    \\n    return itinerary.reverse();\\n};\\n```\n``` PHP []\\nclass Solution {\\n    function findItinerary($tickets) {\\n        $graph = [];\\n        \\n        foreach ($tickets as [$src, $dst]) {\\n            $graph[$src][] = $dst;\\n        }\\n        \\n        foreach ($graph as &$destinations) {\\n            rsort($destinations);\\n        }\\n        \\n        $itinerary = [];\\n        \\n        $dfs = function($airport) use (&$graph, &$itinerary, &$dfs) {\\n            while (!empty($graph[$airport])) {\\n                $dfs(array_pop($graph[$airport]));\\n            }\\n            $itinerary[] = $airport;\\n        };\\n        \\n        $dfs(\"JFK\");\\n        \\n        return array_reverse($itinerary);\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        \\n        for src, dst in sorted(tickets, reverse=True):\\n            graph[src].append(dst)\\n        \\n        stack = [\"JFK\"]\\n        itinerary = []\\n        \\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].pop())\\n            itinerary.append(stack.pop())\\n        \\n        return itinerary[::-1]\\n```\n``` Go []\\nfunc findItinerary(tickets [][]string) []string {\\n\\tgraph := make(map[string][]string)\\n\\t\\n\\tfor _, ticket := range tickets {\\n\\t\\tgraph[ticket[0]] = append(graph[ticket[0]], ticket[1])\\n\\t}\\n\\t\\n\\tfor key := range graph {\\n\\t\\tsort.Sort(sort.Reverse(sort.StringSlice(graph[key])))\\n\\t}\\n\\t\\n\\tstack := []string{\"JFK\"}\\n\\tvar itinerary []string\\n\\t\\n\\tfor len(stack) > 0 {\\n\\t\\tfor len(graph[stack[len(stack)-1]]) > 0 {\\n\\t\\t\\tlast := len(graph[stack[len(stack)-1]]) - 1\\n\\t\\t\\tstack = append(stack, graph[stack[len(stack)-1]][last])\\n\\t\\t\\tgraph[stack[len(stack)-2]] = graph[stack[len(stack)-2]][:last]\\n\\t\\t}\\n\\t\\titinerary = append(itinerary, stack[len(stack)-1])\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t}\\n\\t\\n\\tfor i := 0; i < len(itinerary)/2; i++ {\\n\\t\\titinerary[i], itinerary[len(itinerary)-1-i] = itinerary[len(itinerary)-1-i], itinerary[i]\\n\\t}\\n\\t\\n\\treturn itinerary\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> findItinerary(std::vector<std::vector<std::string>>& tickets) {\\n        std::unordered_map<std::string, std::vector<std::string>> graph;\\n        \\n        for (auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto& [_, dests] : graph) {\\n            std::sort(dests.rbegin(), dests.rend());\\n        }\\n        \\n        std::vector<std::string> stack = {\"JFK\"};\\n        std::vector<std::string> itinerary;\\n        \\n        while (!stack.empty()) {\\n            std::string curr = stack.back();\\n            if (graph.find(curr) != graph.end() && !graph[curr].empty()) {\\n                stack.push_back(graph[curr].back());\\n                graph[curr].pop_back();\\n            } else {\\n                itinerary.push_back(stack.back());\\n                stack.pop_back();\\n            }\\n        }\\n        \\n        std::reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.computeIfAbsent(ticket.get(0), k -> new PriorityQueue<>()).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> stack = new LinkedList<>();\\n        stack.add(\"JFK\");\\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        while (!stack.isEmpty()) {\\n            while (graph.getOrDefault(stack.peekLast(), new PriorityQueue<>()).size() > 0) {\\n                stack.add(graph.get(stack.peekLast()).poll());\\n            }\\n            itinerary.addFirst(stack.pollLast());\\n        }\\n        \\n        return itinerary;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = {};\\n    \\n    for (const [src, dst] of tickets) {\\n        if (!graph[src]) graph[src] = [];\\n        graph[src].push(dst);\\n    }\\n    \\n    for (const key in graph) {\\n        graph[key].sort((a, b) => b.localeCompare(a));\\n    }\\n    \\n    const stack = [\\'JFK\\'];\\n    const itinerary = [];\\n    \\n    while (stack.length > 0) {\\n        while (graph[stack[stack.length - 1]] && graph[stack[stack.length - 1]].length > 0) {\\n            stack.push(graph[stack[stack.length - 1]].pop());\\n        }\\n        itinerary.push(stack.pop());\\n    }\\n    \\n    return itinerary.reverse();\\n};\\n```\n``` C# []\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var graph = new Dictionary<string, List<string>>();\\n        \\n        foreach (var ticket in tickets) {\\n            if (!graph.ContainsKey(ticket[0])) {\\n                graph[ticket[0]] = new List<string>();\\n            }\\n            graph[ticket[0]].Add(ticket[1]);\\n        }\\n\\n        foreach (var key in graph.Keys) {\\n            graph[key].Sort((a, b) => b.CompareTo(a));\\n        }\\n        \\n        var stack = new Stack<string>();\\n        stack.Push(\"JFK\");\\n        var itinerary = new List<string>();\\n        \\n        while (stack.Count > 0) {\\n            string curr = stack.Peek();\\n            if (graph.ContainsKey(curr) && graph[curr].Count > 0) {\\n                var next = graph[curr].Last();\\n                graph[curr].RemoveAt(graph[curr].Count - 1);\\n                stack.Push(next);\\n            } else {\\n                itinerary.Add(stack.Pop());\\n            }\\n        }\\n        \\n        itinerary.Reverse();\\n        return itinerary;\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function findItinerary($tickets) {\\n        $graph = [];\\n        foreach ($tickets as $ticket) {\\n            $graph[$ticket[0]][] = $ticket[1];\\n        }\\n        \\n        foreach ($graph as &$dests) {\\n            rsort($dests);\\n        }\\n        \\n        $stack = [\"JFK\"];\\n        $itinerary = [];\\n        \\n        while (!empty($stack)) {\\n            while (!empty($graph[end($stack)])) {\\n                array_push($stack, array_pop($graph[end($stack)]));\\n            }\\n            array_push($itinerary, array_pop($stack));\\n        }\\n        \\n        return array_reverse($itinerary);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78832,
                "title": "short-c-dfs-iterative-44ms-solution-with-explanation-no-recursive-calls-no-backtracking",
                "content": "    class Solution {\\n    public:\\n    \\tvector<string> findItinerary(vector<pair<string, string>> tickets) {\\n    \\t\\t// Each node (airport) contains a set of outgoing edges (destination).\\n    \\t\\tunordered_map<string, multiset<string>> graph;\\n    \\t\\t// We are always appending the deepest node to the itinerary, \\n    \\t\\t// so will need to reverse the itinerary in the end.\\n    \\t\\tvector<string> itinerary;\\n    \\t\\tif (tickets.size() == 0){\\n    \\t\\t\\treturn itinerary;\\n    \\t\\t}\\n    \\t\\t// Construct the node and assign outgoing edges\\n    \\t\\tfor (pair<string, string> eachTicket : tickets){\\n    \\t\\t\\tgraph[eachTicket.first].insert(eachTicket.second);\\n    \\t\\t}\\n    \\t\\tstack<string> dfs;\\n    \\t\\tdfs.push(\"JFK\");\\n    \\t\\twhile (!dfs.empty()){\\n    \\t\\t\\tstring topAirport = dfs.top();\\n    \\t\\t\\tif (graph[topAirport].empty()){\\n    \\t\\t\\t\\t// If there is no more outgoing edges, append to itinerary\\n    \\t\\t\\t\\t// Two cases: \\n    \\t\\t\\t\\t// 1. If it searchs the terminal end first, it will simply get\\n    \\t\\t\\t\\t//    added to the itinerary first as it should, and the proper route\\n    \\t\\t\\t\\t//    will still be traversed since its entry is still on the stack.\\n    \\t\\t\\t\\t// 2. If it search the proper route first, the dead end route will also\\n    \\t\\t\\t\\t//    get added to the itinerary first.\\n    \\t\\t\\t\\titinerary.push_back(topAirport);\\n    \\t\\t\\t\\tdfs.pop();\\n    \\t\\t\\t}\\n    \\t\\t\\telse {\\n    \\t\\t\\t\\t// Otherwise push the outgoing edge to the dfs stack and \\n    \\t\\t\\t\\t// remove it from the node.\\n    \\t\\t\\t\\tdfs.push(*(graph[topAirport].begin()));\\n    \\t\\t\\t\\tgraph[topAirport].erase(graph[topAirport].begin());\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// Reverse the itinerary.\\n    \\t\\treverse(itinerary.begin(), itinerary.end());\\n    \\t\\treturn itinerary;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<string> findItinerary(vector<pair<string, string>> tickets) {\\n    \\t\\t// Each node (airport) contains a set of outgoing edges (destination).\\n    \\t\\tunordered_map<string, multiset<string>> graph;\\n    \\t\\t// We are always appending the deepest node to the itinerary, \\n    \\t\\t// so will need to reverse the itinerary in the end.\\n    \\t\\tvector<string> itinerary;\\n    \\t\\tif (tickets.size() == 0){\\n    \\t\\t\\treturn itinerary;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 359942,
                "title": "awesome-question-new-algo-to-learn-eulerian-path-full-explanation-code",
                "content": "Will explain things one by one, follow if really wants to understand the algorithm\\n\\n**This problem is based on Eulerian Path in graph**\\nWiki:\\nEulerian path\\n In graph theory, an Eulerian trail (or Eulerian path) is a trail in a finite graph that visits every edge exactly once (allowing for revisiting vertices).\\n Similarly, an Eulerian circuit or Eulerian cycle is an Eulerian trail that starts and ends on the same vertex. They were first discussed by Leonhard Euler while solving the\\n famous Seven Bridges of K\\xF6nigsberg problem in 1736. The problem can be stated mathematically like this:\\n\\n Given the graph in the image, is it possible to construct a path (or a cycle, i.e. a path starting and ending on the same vertex) that visits each edge exactly once?\\n Euler proved that a necessary condition for the existence of Eulerian circuits is that all vertices in the graph have an even degree, and stated without proof that connected\\n graphs with all vertices of even degree have an Eulerian circuit.\\n This is known as Euler\\'s Theorem:\\n\\n**A connected graph has an Euler cycle iff every vertex has even degree**\\n \\n ```\\n A Graph must have nodes with even degree and odd degree. All the odd degree nodes are either start or end but all the even degree node will be only intermediate nodes.\\n But in case when all the nodes has even degree, then it contains the Eulerian Tour, as we we\\'ll start from some node and will end to this same node, as we need to consume all the edges.\\n```\\n\\n* Important:\\n If all nodes in graph has odd degree than its not possible to build Eulerian Path, as for coming and going from/to a node we require even degree for some of the node.\\n\\nWants learn more:\\n* Must Watch:\\nEulerian Path - Intro to Algorithms: https://www.youtube.com/watch?v=ycRuO-u6rt8\\nEulerian Path Solution - Intro to Algorithms: https://www.youtube.com/watch?v=Dx1lpbpSHwI\\n\\nOk now lets do step by step ;\\nFrom: https://leetcode.com/problems/reconstruct-itinerary/discuss/78768/Short-Ruby-Python-Java-C%2B%2B\\nFirst keep going forward until you get stuck. That\\'s a good main path already. Remaining tickets form cycles which are found on the\\nway back and get merged into that main path. By writing down the path backwards when retreating from recursion, merging the cycles into the main path is easy -\\n the end part of the path has already been written, the start part of the path hasn\\'t been written yet, so just write down the cycle now and then keep backwards-writing the path.\\n\\nLets build the graph using input;  PriorityQueue use to achieve lexical order\\n\\n```\\n\\n    private Map<String, PriorityQueue<String>> buildGraph(List<List<String>> tickets) {\\n\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n\\n        for (List<String> ticket : tickets) {\\n            String source = ticket.get(0);\\n            String destination = ticket.get(1);\\n\\n            if (!graph.containsKey(source))\\n                graph.put(source, new PriorityQueue<>());\\n\\n            graph.get(source).add(destination);\\n\\n        }\\n        return graph;\\n    }\\n```\\n ```\\n For input like :\\n [[JFK, A], [JFK, D] , [A,C], [B,C] , [C, JFK], [C , D], [D,A] , [D, B] ]\\n \\n It will build graph like this \\n {\\'JFK\\': [\\'A\\', \\'D\\'], \\'A\\': [\\'C\\'], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\', \\'JFK\\'], \\'D\\': [\\'A\\', \\'B\\']}\\n \\n      targets = {\\'JFK\\': [\\'A\\', \\'D\\'], \\'A\\': [\\'C\\'], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\', \\'JFK\\'], \\'D\\': [\\'A\\', \\'B\\']}\\n     route = []\\n     stack = [\\'JFK\\']\\n     First point at which we get stuck:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\' , \\'JFK\\',], \\'D\\': [\\'B\\']}\\n     route = []\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'A\\']\\n     Update route:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [\\'C\\'], \\'C\\': [\\'JFK\\'], \\'D\\': [\\'B\\']}\\n     route = [\\'A\\']\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\']\\n     Search forward again until stuck:\\n\\n    \\n     targets = {\\'JFK\\': [], \\'A\\': [], \\'B\\': [], \\'C\\': [], \\'D\\': []}\\n     route = [\\'A\\']\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'B\\', \\'C\\', \\'JFK\\', \\'D\\']\\n     Update route:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [], \\'C\\': [\\'JFK\\'], \\'D\\': []}\\n     route = [\\'A\\', \\'D\\', \\'JFK\\', \\'C\\', \\'B\\', \\'D\\', \\'C\\', \\'A\\', \\'JFK\\']\\n     stack = []\\n     Return route in reverse:\\n\\n    \\n     route = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'B\\', \\'C\\', \\'JFK\\', \\'D\\', \\'A\\']\\n\\t \\n\\t```\\n\\t\\n\\tCode:\\n\\t```\\n private void dfs(List<String> itinerary, Map<String, PriorityQueue<String>> graph, String source) {\\n\\n        /**\\n         * if now more destination possible from this source, then we are at the bottom most.\\n         */\\n        if (graph.get(source) == null || graph.get(source).isEmpty()) {\\n            itinerary.add(source);\\n            return;\\n        }\\n\\n\\n        /**\\n         * Try all the destination from this source incrementally.\\n         * This is important for input like [[JFK, KUL], [JFK, NRT], [NRT, JFK]]\\n         * because once you reach Kul, you can\\'t go anywhere but we have tickets left, so we should go NTR first\\n         */\\n        while (!graph.get(source).isEmpty()) {\\n            String nextDestination = graph.get(source).poll();\\n            dfs(itinerary, graph, nextDestination);\\n        }\\n        /**\\n         * We are at the bottom, traverse back\\n         */\\n        itinerary.add(source);\\n\\n    }\\n\\t\\n\\t public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        if (tickets == null || tickets.isEmpty())\\n            return Collections.EMPTY_LIST;\\n\\n        Map<String, PriorityQueue<String>> graph = buildGraph(tickets);\\n\\n        List<String> itinerary = new ArrayList<>(graph.size());\\n        dfs(itinerary, graph, \"JFK\");\\n\\n        Collections.reverse(itinerary);\\n        return itinerary;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n A Graph must have nodes with even degree and odd degree. All the odd degree nodes are either start or end but all the even degree node will be only intermediate nodes.\\n But in case when all the nodes has even degree, then it contains the Eulerian Tour, as we we\\'ll start from some node and will end to this same node, as we need to consume all the edges.\\n```\n```\\n\\n    private Map<String, PriorityQueue<String>> buildGraph(List<List<String>> tickets) {\\n\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n\\n        for (List<String> ticket : tickets) {\\n            String source = ticket.get(0);\\n            String destination = ticket.get(1);\\n\\n            if (!graph.containsKey(source))\\n                graph.put(source, new PriorityQueue<>());\\n\\n            graph.get(source).add(destination);\\n\\n        }\\n        return graph;\\n    }\\n```\n```\\n For input like :\\n [[JFK, A], [JFK, D] , [A,C], [B,C] , [C, JFK], [C , D], [D,A] , [D, B] ]\\n \\n It will build graph like this \\n {\\'JFK\\': [\\'A\\', \\'D\\'], \\'A\\': [\\'C\\'], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\', \\'JFK\\'], \\'D\\': [\\'A\\', \\'B\\']}\\n \\n      targets = {\\'JFK\\': [\\'A\\', \\'D\\'], \\'A\\': [\\'C\\'], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\', \\'JFK\\'], \\'D\\': [\\'A\\', \\'B\\']}\\n     route = []\\n     stack = [\\'JFK\\']\\n     First point at which we get stuck:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [\\'C\\'], \\'C\\': [\\'D\\' , \\'JFK\\',], \\'D\\': [\\'B\\']}\\n     route = []\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'A\\']\\n     Update route:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [\\'C\\'], \\'C\\': [\\'JFK\\'], \\'D\\': [\\'B\\']}\\n     route = [\\'A\\']\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\']\\n     Search forward again until stuck:\\n\\n    \\n     targets = {\\'JFK\\': [], \\'A\\': [], \\'B\\': [], \\'C\\': [], \\'D\\': []}\\n     route = [\\'A\\']\\n     stack = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'B\\', \\'C\\', \\'JFK\\', \\'D\\']\\n     Update route:\\n\\n    \\n     targets = {\\'JFK\\': [\\'D\\'], \\'A\\': [], \\'B\\': [], \\'C\\': [\\'JFK\\'], \\'D\\': []}\\n     route = [\\'A\\', \\'D\\', \\'JFK\\', \\'C\\', \\'B\\', \\'D\\', \\'C\\', \\'A\\', \\'JFK\\']\\n     stack = []\\n     Return route in reverse:\\n\\n    \\n     route = [\\'JFK\\', \\'A\\', \\'C\\', \\'D\\', \\'B\\', \\'C\\', \\'JFK\\', \\'D\\', \\'A\\']\\n\\t \\n\\t```\n```\\n private void dfs(List<String> itinerary, Map<String, PriorityQueue<String>> graph, String source) {\\n\\n        /**\\n         * if now more destination possible from this source, then we are at the bottom most.\\n         */\\n        if (graph.get(source) == null || graph.get(source).isEmpty()) {\\n            itinerary.add(source);\\n            return;\\n        }\\n\\n\\n        /**\\n         * Try all the destination from this source incrementally.\\n         * This is important for input like [[JFK, KUL], [JFK, NRT], [NRT, JFK]]\\n         * because once you reach Kul, you can\\'t go anywhere but we have tickets left, so we should go NTR first\\n         */\\n        while (!graph.get(source).isEmpty()) {\\n            String nextDestination = graph.get(source).poll();\\n            dfs(itinerary, graph, nextDestination);\\n        }\\n        /**\\n         * We are at the bottom, traverse back\\n         */\\n        itinerary.add(source);\\n\\n    }\\n\\t\\n\\t public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        if (tickets == null || tickets.isEmpty())\\n            return Collections.EMPTY_LIST;\\n\\n        Map<String, PriorityQueue<String>> graph = buildGraph(tickets);\\n\\n        List<String> itinerary = new ArrayList<>(graph.size());\\n        dfs(itinerary, graph, \"JFK\");\\n\\n        Collections.reverse(itinerary);\\n        return itinerary;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 78846,
                "title": "very-short-iterative-java-solution",
                "content": "Just using a hashmap and stack to replace recursion.\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        LinkedList<String> ret = new LinkedList<String>();\\n        Map<String, PriorityQueue<String>> map = new HashMap<String, PriorityQueue<String>>();\\n        Stack<String> stack = new Stack<String>();\\n        for(String[] t : tickets) {\\n            if(!map.containsKey(t[0])) map.put(t[0], new PriorityQueue<String>());\\n            map.get(t[0]).offer(t[1]);\\n        }\\n        stack.push(\"JFK\");\\n        while(!stack.isEmpty()) {\\n            String next = stack.peek();\\n            if(map.containsKey(next) && map.get(next).size() > 0) stack.push(map.get(next).poll());\\n            else ret.addFirst(stack.pop());\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "Just using a hashmap and stack to replace recursion.\\n\\n    public List<String> findItinerary(String[][] tickets) {\\n        LinkedList<String> ret = new LinkedList<String>();\\n        Map<String, PriorityQueue<String>> map = new HashMap<String, PriorityQueue<String>>();\\n        Stack<String> stack = new Stack<String>();\\n        for(String[] t : tickets) {\\n            if(!map.containsKey(t[0])) map.put(t[0], new PriorityQueue<String>());\\n            map.get(t[0]).offer(t[1]);\\n        }\\n        stack.push(\"JFK\");\\n        while(!stack.isEmpty()) {\\n            String next = stack.peek();\\n            if(map.containsKey(next) && map.get(next).size() > 0) stack.push(map.get(next).poll());\\n            else ret.addFirst(stack.pop());\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 631629,
                "title": "c-solution-with-detailed-explanation",
                "content": "```\\nThis is the variation of dfs.\\nThe way to tweak the dfs is to not to put a base condition and let the dfs fill and tsack and empty itslef\\nWhat i mean by this is \\n\\nInput: [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\\nLets say we built a graph of this and its adjacenecy list look like this:-\\nJFK - MUC\\nMUC - LHR\\nLHR - SFO\\nSFO - SJC\\n\\nSo when we perform a dfs on JFK\\n\\n|        |\\n|        |\\n|        |   <-----Recursion Stack\\n|        |\\n|__JFK___|\\n\\nWe explore JFKs neighbors \\n\\n|        |\\n|        |\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\nWe explore Muc neighbors\\n\\n|        |\\n|        |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|  SJC   |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\nSince SJC has no neighbors we pus it back to the answer\\n\\n|        |\\n|  SFO   |      ans=SJC\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC \\n|        |\\n|        |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC,JFK \\n|        |\\n|        |\\n|________|\\n\\nWe reverse the array and return it.\\n\\n    unordered_map<string,priority_queue<string,vector<string>,greater<string>>> map;  //We use priority queue for lexographic ordering\\n    vector<string> ans;\\n    void dfs(string s)\\n    {\\n        auto &x=map[s];\\n        while(!x.empty())\\n        {\\n            string to=x.top();\\n            x.pop();\\n            dfs(to);\\n        }\\n        cout<<s<<endl;\\n        ans.push_back(s);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for(auto &x:tickets)\\n            map[x[0]].push(x[1]);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nThis is the variation of dfs.\\nThe way to tweak the dfs is to not to put a base condition and let the dfs fill and tsack and empty itslef\\nWhat i mean by this is \\n\\nInput: [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\\nLets say we built a graph of this and its adjacenecy list look like this:-\\nJFK - MUC\\nMUC - LHR\\nLHR - SFO\\nSFO - SJC\\n\\nSo when we perform a dfs on JFK\\n\\n|        |\\n|        |\\n|        |   <-----Recursion Stack\\n|        |\\n|__JFK___|\\n\\nWe explore JFKs neighbors \\n\\n|        |\\n|        |\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\nWe explore Muc neighbors\\n\\n|        |\\n|        |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|  SJC   |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\nSince SJC has no neighbors we pus it back to the answer\\n\\n|        |\\n|  SFO   |      ans=SJC\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC \\n|        |\\n|        |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC,JFK \\n|        |\\n|        |\\n|________|\\n\\nWe reverse the array and return it.\\n\\n    unordered_map<string,priority_queue<string,vector<string>,greater<string>>> map;  //We use priority queue for lexographic ordering\\n    vector<string> ans;\\n    void dfs(string s)\\n    {\\n        auto &x=map[s];\\n        while(!x.empty())\\n        {\\n            string to=x.top();\\n            x.pop();\\n            dfs(to);\\n        }\\n        cout<<s<<endl;\\n        ans.push_back(s);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for(auto &x:tickets)\\n            map[x[0]].push(x[1]);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4042004,
                "title": "beats-99-17-dfs-recursive-iterative-euler-path-intuition-commented-code",
                "content": "# Problem Description\\nThe task is **reconstructing** an itinerary using a list of airline tickets.\\nEach ticket is represented as a pair of departure and arrival airports, denoted as `tickets[i] = [fromi, toi]`.\\n**The goal** is to create an **ordered** itinerary, starting with the airport `JFK` (the departure point), while ensuring that all tickets are used **once**. If there are multiple valid itineraries, you should return the one with the **smallest lexical order** when read as a single string.\\n\\n- **Constraints:**\\n    - `1 <= tickets.length <= 300`\\n    - `tickets[i].length == 2`\\n    - Each town name is at most **3 letters**\\n    - `fromi` and `toi` consist of uppercase English letters.\\n    - `fromi` != `toi`\\n    - Start from `JFK`\\n    - Use each ticket **once and only once**\\n\\n\\n\\n---\\n\\n# Intuition\\nHi there\\uD83D\\uDE00\\nLet\\'s take a look on this interesting problem. It is also challenging one.\\n\\nFor our airports problem we have two **crucial points** we must put in mind: We must use each ticket once and only once, there is atleast one valid itinerary as a solution of the problem.\\n\\nWhat can we **conclude** from that? \\uD83E\\uDD14\\nThe graph that we will build out of tickets list is something called **Semi Euler Graph** and the path that we want is called **Euler Path**.\\nI won\\'t talk about them in depth because they are advanced topics even for me. \\uD83D\\uDE02 but I will give a simple Intuition.\\n\\n\\nLet\\'s call some graph termenolgies that we want later.\\n- **In-degree** for a node: number of edges that points to a specific node.\\n- **Out-degree** for anode: number of edges coming out from a node.\\n\\nLet\\'s see an **exmaple**:\\n![image.png](https://assets.leetcode.com/users/images/f77a0035-03c5-4866-babf-5158a90eedd5_1694660526.9899151.png)\\n| Node | In-degree | Out-degree | \\n| :--- | ---:| :---: | \\n| a | 1 | 2 | \\n| b | 1 | 1 | \\n| c | 1 | 1 |\\n| d | 1 | 0 |  \\n\\n\\na **Semi Euler Graph** is a graph that has **Euler Path** which mean there is a path from starting node to an ending node and we will use all edges once and only once.\\nHuh looks familiar\\uD83E\\uDD14... Yes ITS OUR PROBLEM!!\\uD83E\\uDD2F\\n\\nFor a **directed graph** to be a **Semi Euler Graph** it must meet some conditions:\\n- **In degree** for all nodes = **Out degree** for `all` nodes\\n- Except for two node: \\n    - `Starting` node should have `Out-degree = In degree + 1`\\n    - `Ending` node should have `In-degree = Out-degree + 1`\\n\\n\\nLet\\'s see some examples for our original problem.\\n\\n![image.png](https://assets.leetcode.com/users/images/f77a0035-03c5-4866-babf-5158a90eedd5_1694660526.9899151.png)\\n\\n\\nIn this example, we can see that `d` airport meets the condition for an ending node and `a` meets the condition for a starting node.\\nAn answer will be `(a, b, c, d)` \\n\\n![image.png](https://assets.leetcode.com/users/images/672954c8-7a41-43ae-aeb1-ca8499802fc9_1694660033.5385113.png)\\n\\nIn this example, we can see that `b` airport meets the condition for an ending node and `a` meets the condition for a starting node.\\nAn answer will be also `(a, b, c, d, b)` \\n\\n![image.png](https://assets.leetcode.com/users/images/09129f1c-1d18-468f-99e0-031b24d6e49e_1694659216.810375.png)\\nIn this example, we can see that the nodes didn\\'t meet the condition to be an **Semi Euler Graph**.\\nAnd if you tried to put it as a test case it will tell you `invalid input`.\\n\\nOkay, I think we have something here\\uD83E\\uDD2F \\nThe Pseudo Code for finding Euler Path is easy the only editing we will do it to sort the edges for the graph to be in the smallest lexical order.\\n\\nand for this problem, we will find for each test case that `JFK` meets the conditions to be a starting node.\\n\\nAnd that\\'s it the solution for our problem only a **Semi Euler Graph** \\uD83D\\uDE02\\n\\n\\n\\n---\\n\\n\\n# Approach\\n## 1. DFS Recursive\\n### Steps\\n- Initialize a `flightGraph` as a `dictionary (map)` to represent flights and an itinerary list to store the final travel sequence.\\n- Iterate through each ticket and populate the `flightGraph` dictionary.\\n- Sort the destinations for each airport in reverse order to visit **lexical smaller** destinations first.\\n- Start the DFS traversal from the `JFK` airport.\\n- Using the **depth-first search** (DFS) method called `dfs` that takes an airport as input and recursively explores its destinations while **maintaining lexical order**. It adds the visited airports to the itinerary list.\\n- **Reverse** the itinerary list to get the correct travel order.\\n- **Return** the itinerary list as the final result.\\n\\n### Complexity\\n- **Time complexity:** $$O(N^2log(N))$$\\nSince we loop over lists of destinations in the flight graph and sorts them. Sorting each list has a time complexity of `O(E * log(E))`, where E is the total number of edges (tickets). Since `E` can be at most `N`, this step has a time complexity of `O(N * log(N))`. and since we loop over `N` city then the total time complexity is `O(N^2log(N))` where `N` is the number of airports.\\n- **Space complexity:** $$O(N+E)$$\\nWe are storing the Flight Graph which is represented using map of lists, which will have at most `N` keys (airports) and a total of `E` values (destinations). Therefore, the space complexity is `O(N + E)`.\\n\\n\\n---\\n\\n## 2. DFS Iterative\\n### Steps\\n- Initialize a `flightGraph` as a `dictionary (map)` to represent flights and an itinerary list to store the final travel sequence.\\n- Iterate through each ticket and populate the `flightGraph` dictionary.\\n- Sort the destinations for each airport in reverse order to visit **lexical smaller** destinations first.\\n- **Start** with `JFK` as the initial airport and create a stack.\\n- While the stack is `not empty`:\\n    - **Explore** destinations:\\n        - Push the next destination onto the stack.\\n    - **Backtrack**:\\n        - Add the current airport to the travel itinerary.\\n        - Pop the current airport from the stack.\\n- **Reverse** the travel itinerary to get the correct order.\\n- **Return** the travel itinerary as the final result.\\n\\n### Complexity\\n- **Time complexity:** $$O(N^2log(N))$$\\nSince we loop over lists of destinations in the flight graph and sorts them. Sorting each list has a time complexity of `O(E * log(E))`, where E is the total number of edges (tickets). Since `E` can be at most `N`, this step has a time complexity of `O(N * log(N))`. and since we loop over `N` city then the total time complexity is `O(N^2log(N))` where `N` is the number of airports.\\n- **Space complexity:** $$O(N+E)$$\\nWe are storing the Flight Graph which is represented using map of lists, which will have at most `N` keys (airports) and a total of `E` values (destinations). Therefore, the space complexity is `O(N + E)`.\\n\\n---\\n\\n# Code\\n## DFS Recursive\\n```C++ []\\nclass Solution {\\nprivate:\\n    // Create an adjacency list to represent the flights\\n    unordered_map<string, vector<string>> flightGraph;\\n    \\n    // Store the final itinerary\\n    vector<string> itinerary;\\n\\npublic:\\n\\n    // Depth-First Search to traverse the flight itinerary\\n    void dfs(string airport) {\\n        vector<string> &destinations = flightGraph[airport];\\n        \\n        // Visit destinations in lexical order\\n        while (!destinations.empty()) {\\n            string nextDestination = destinations.back();\\n            destinations.pop_back();\\n            dfs(nextDestination);\\n        }\\n        \\n        // Add the current airport to the itinerary after visiting all destinations\\n        itinerary.push_back(airport);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Populate the flight graph using ticket information\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string from = tickets[i][0];\\n            string to = tickets[i][1];\\n\\n            flightGraph[from].push_back(to);\\n        }\\n        \\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (auto &entry : flightGraph) {\\n            sort(entry.second.rbegin(), entry.second.rend());\\n        }\\n        \\n        // Start the DFS from the JFK airport\\n        dfs(\"JFK\");\\n        \\n        // Reverse the itinerary to get the correct order\\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private Map<String, List<String>> flightGraph;\\n    private List<String> itinerary;\\n\\n    public Solution() {\\n        flightGraph = new HashMap<>();\\n        itinerary = new ArrayList<>();\\n    }\\n\\n    // Depth-First Search to traverse the flight itinerary\\n    private void dfs(String airport) {\\n        List<String> destinations = flightGraph.get(airport);\\n\\n        // Visit destinations in lexical order\\n        while (destinations != null && !destinations.isEmpty()) {\\n            String nextDestination = destinations.remove(destinations.size() - 1);\\n            dfs(nextDestination);\\n        }\\n\\n        // Add the current airport to the itinerary after visiting all destinations\\n        itinerary.add(airport);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Populate the flight graph using ticket information\\n        for (List<String> ticket : tickets) {\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n\\n            flightGraph.computeIfAbsent(from, k -> new ArrayList<>()).add(to);\\n        }\\n\\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (List<String> destinations : flightGraph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        // Start the DFS from the JFK airport\\n        dfs(\"JFK\");\\n\\n        // Reverse the itinerary to get the correct order\\n        Collections.reverse(itinerary);\\n\\n        return itinerary;\\n    }\\n}\\n```\\n```Python []\\n\\nclass Solution:\\n    def __init__(self):\\n        self.flight_graph = defaultdict(list)\\n        self.itinerary = []\\n\\n    # Depth-First Search to traverse the flight itinerary\\n    def dfs(self, airport:str) -> None:\\n        destinations = self.flight_graph[airport]\\n\\n        # Visit destinations in lexical order\\n        while destinations:\\n            next_destination = destinations.pop()\\n            self.dfs(next_destination)\\n\\n        # Add the current airport to the itinerary after visiting all destinations\\n        self.itinerary.append(airport)\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Populate the flight graph using ticket information\\n        for ticket in tickets:\\n            from_airport, to_airport = ticket\\n\\n            self.flight_graph[from_airport].append(to_airport)\\n\\n        # Sort destinations in reverse order to visit lexical smaller destinations first\\n        for destinations in self.flight_graph.values():\\n            destinations.sort(reverse=True)\\n\\n        # Start the DFS from the JFK airport\\n        self.dfs(\"JFK\")\\n\\n        # Reverse the itinerary to get the correct order\\n        self.itinerary.reverse()\\n\\n        return self.itinerary\\n```\\n\\n## DFS Iterative\\n```C++ []\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<string>> flightGraph; // Represents flights from one airport to another\\n    vector<string> travelItinerary; // Stores the final travel itinerary\\n\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Populate the flight graph using ticket information\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string fromAirport = tickets[i][0];\\n            string toAirport = tickets[i][1];\\n\\n            flightGraph[fromAirport].push_back(toAirport);\\n        }\\n        \\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (auto &entry : flightGraph) {\\n            sort(entry.second.rbegin(), entry.second.rend());\\n        }\\n\\n        stack<string> dfsStack;\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.empty()) {\\n            // Get the current airport from the top of the stack\\n            string currentAirport = dfsStack.top();\\n\\n            vector<string> &destinations = flightGraph[currentAirport];\\n\\n            if (!destinations.empty()) {\\n                // Choose the next destination (the one in lexicographically larger order)\\n                string nextDestination = destinations.back();\\n                destinations.pop_back();\\n\\n                dfsStack.push(nextDestination);\\n            } else {\\n                // If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.push_back(currentAirport);\\n        \\n                dfsStack.pop();\\n            }\\n        }\\n        \\n        // Reverse the itinerary to get the correct order\\n        reverse(travelItinerary.begin(), travelItinerary.end());\\n        return travelItinerary;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private Map<String, List<String>> flightGraph; // Represents flights from one airport to another\\n    private List<String> travelItinerary; // Stores the final travel itinerary\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Initialize the flight graph using ticket information\\n        flightGraph = new HashMap<>();\\n        travelItinerary = new ArrayList<>() ;\\n        for (List<String> ticket : tickets) {\\n            String fromAirport = ticket.get(0);\\n            String toAirport = ticket.get(1);\\n            flightGraph.computeIfAbsent(fromAirport, k -> new ArrayList<>()).add(toAirport);\\n        }\\n\\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (List<String> destinations : flightGraph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        Stack<String> dfsStack = new Stack<>();\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.isEmpty()) {\\n            // Get the current airport from the top of the stack\\n            String currentAirport = dfsStack.peek();\\n            List<String> destinations = flightGraph.get(currentAirport);\\n\\n            if (destinations != null && !destinations.isEmpty()) {\\n                // Choose the next destination (the one in lexicographically larger order)\\n                String nextDestination = destinations.remove(destinations.size() - 1);\\n                dfsStack.push(nextDestination);\\n            } else {\\n                // If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.add(currentAirport);\\n                dfsStack.pop();\\n            }\\n        }\\n\\n        // Reverse the itinerary to get the correct order\\n        Collections.reverse(travelItinerary);\\n        return travelItinerary;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def findItinerary(self, tickets) -> list[str]:\\n        # Initialize the flight graph using ticket information\\n        flightGraph = defaultdict(list)\\n        travelItinerary = []\\n\\n        for ticket in tickets:\\n            fromAirport, toAirport = ticket[0], ticket[1]\\n            flightGraph[fromAirport].append(toAirport)\\n\\n        # Sort destinations in reverse order to visit lexical smaller destinations first\\n        for destinations in flightGraph.values():\\n            destinations.sort(reverse=True)\\n\\n        dfsStack = [\"JFK\"]\\n\\n        while dfsStack:\\n            # Get the current airport from the top of the stack\\n            currentAirport = dfsStack[-1]\\n            destinations = flightGraph.get(currentAirport, [])\\n\\n            if destinations:\\n                # Choose the next destination (the one in lexicographically larger order)\\n                nextDestination = destinations.pop()\\n                dfsStack.append(nextDestination)\\n            else:\\n                # If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.append(currentAirport)\\n                dfsStack.pop()\\n\\n        # Reverse the itinerary to get the correct order\\n        travelItinerary.reverse()\\n        return travelItinerary\\n```\\n\\n\\n---\\n\\n\\n\\n# Further Improvements?\\n[@v4g](/v4g) had a great improvement that gave better time.\\nInstead of sorting we can simply use **multiset** with reverse order and take the last element every time.\\nIn `C++`: Since we are pointing to `multiset.end()` then it will be in `O(1)` and erasing the element given its iterator it also will be `O(1)`.\\n\\n- **Time complexity:** $$O(Elog(N))$$\\nSince we loop over list of tickets with size `E` and each node can have at most `N` airports that you can travel to them. \\n- **Space complexity:** $$O(N+E)$$\\nIt still the same.\\n\\nHere is the code for C++ and the solution can be generalized to other languages as well.\\n\\n## DFS Recursive \\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, multiset<string, greater<string>>> flightGraph;\\n    vector<string> itinerary;\\n\\npublic:\\n    void dfs(string airport) {\\n        auto &destinations = flightGraph[airport];\\n        \\n        while (!destinations.empty()) {\\n            auto nextDestination = *(--destinations.end());\\n            destinations.erase(--destinations.end());\\n            dfs(nextDestination);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string from = tickets[i][0];\\n            string to = tickets[i][1];\\n\\n            flightGraph[from].insert(to);\\n        }\\n        dfs(\"JFK\");\\n        \\n        reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\n};\\n```\\n\\n## DFS Iterative \\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, multiset<string, greater<string>>> flightGraph;\\n    vector<string> travelItinerary;\\n\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string fromAirport = tickets[i][0];\\n            string toAirport = tickets[i][1];\\n\\n            flightGraph[fromAirport].insert(toAirport);\\n        }\\n        stack<string> dfsStack;\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.empty()) {\\n            string currentAirport = dfsStack.top();\\n\\n            auto &destinations = flightGraph[currentAirport];\\n\\n            if (!destinations.empty()) {\\n                auto nextDestination = *(--destinations.end());\\n                destinations.erase(--destinations.end());\\n                \\n                dfsStack.push(nextDestination);\\n            } else {\\n                travelItinerary.push_back(currentAirport);\\n        \\n                dfsStack.pop();\\n            }\\n        }\\n        \\n        reverse(travelItinerary.begin(), travelItinerary.end());\\n        return travelItinerary;\\n    }\\n};\\n```\\n\\n\\n![leet_sol.jpg](https://assets.leetcode.com/users/images/a0442556-19d5-4cdc-8682-0255e2247e1c_1694658839.7230825.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Eulerian Circuit"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    // Create an adjacency list to represent the flights\\n    unordered_map<string, vector<string>> flightGraph;\\n    \\n    // Store the final itinerary\\n    vector<string> itinerary;\\n\\npublic:\\n\\n    // Depth-First Search to traverse the flight itinerary\\n    void dfs(string airport) {\\n        vector<string> &destinations = flightGraph[airport];\\n        \\n        // Visit destinations in lexical order\\n        while (!destinations.empty()) {\\n            string nextDestination = destinations.back();\\n            destinations.pop_back();\\n            dfs(nextDestination);\\n        }\\n        \\n        // Add the current airport to the itinerary after visiting all destinations\\n        itinerary.push_back(airport);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Populate the flight graph using ticket information\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string from = tickets[i][0];\\n            string to = tickets[i][1];\\n\\n            flightGraph[from].push_back(to);\\n        }\\n        \\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (auto &entry : flightGraph) {\\n            sort(entry.second.rbegin(), entry.second.rend());\\n        }\\n        \\n        // Start the DFS from the JFK airport\\n        dfs(\"JFK\");\\n        \\n        // Reverse the itinerary to get the correct order\\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private Map<String, List<String>> flightGraph;\\n    private List<String> itinerary;\\n\\n    public Solution() {\\n        flightGraph = new HashMap<>();\\n        itinerary = new ArrayList<>();\\n    }\\n\\n    // Depth-First Search to traverse the flight itinerary\\n    private void dfs(String airport) {\\n        List<String> destinations = flightGraph.get(airport);\\n\\n        // Visit destinations in lexical order\\n        while (destinations != null && !destinations.isEmpty()) {\\n            String nextDestination = destinations.remove(destinations.size() - 1);\\n            dfs(nextDestination);\\n        }\\n\\n        // Add the current airport to the itinerary after visiting all destinations\\n        itinerary.add(airport);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Populate the flight graph using ticket information\\n        for (List<String> ticket : tickets) {\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n\\n            flightGraph.computeIfAbsent(from, k -> new ArrayList<>()).add(to);\\n        }\\n\\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (List<String> destinations : flightGraph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        // Start the DFS from the JFK airport\\n        dfs(\"JFK\");\\n\\n        // Reverse the itinerary to get the correct order\\n        Collections.reverse(itinerary);\\n\\n        return itinerary;\\n    }\\n}\\n```\n```Python []\\n\\nclass Solution:\\n    def __init__(self):\\n        self.flight_graph = defaultdict(list)\\n        self.itinerary = []\\n\\n    # Depth-First Search to traverse the flight itinerary\\n    def dfs(self, airport:str) -> None:\\n        destinations = self.flight_graph[airport]\\n\\n        # Visit destinations in lexical order\\n        while destinations:\\n            next_destination = destinations.pop()\\n            self.dfs(next_destination)\\n\\n        # Add the current airport to the itinerary after visiting all destinations\\n        self.itinerary.append(airport)\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Populate the flight graph using ticket information\\n        for ticket in tickets:\\n            from_airport, to_airport = ticket\\n\\n            self.flight_graph[from_airport].append(to_airport)\\n\\n        # Sort destinations in reverse order to visit lexical smaller destinations first\\n        for destinations in self.flight_graph.values():\\n            destinations.sort(reverse=True)\\n\\n        # Start the DFS from the JFK airport\\n        self.dfs(\"JFK\")\\n\\n        # Reverse the itinerary to get the correct order\\n        self.itinerary.reverse()\\n\\n        return self.itinerary\\n```\n```C++ []\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<string>> flightGraph; // Represents flights from one airport to another\\n    vector<string> travelItinerary; // Stores the final travel itinerary\\n\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Populate the flight graph using ticket information\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string fromAirport = tickets[i][0];\\n            string toAirport = tickets[i][1];\\n\\n            flightGraph[fromAirport].push_back(toAirport);\\n        }\\n        \\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (auto &entry : flightGraph) {\\n            sort(entry.second.rbegin(), entry.second.rend());\\n        }\\n\\n        stack<string> dfsStack;\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.empty()) {\\n            // Get the current airport from the top of the stack\\n            string currentAirport = dfsStack.top();\\n\\n            vector<string> &destinations = flightGraph[currentAirport];\\n\\n            if (!destinations.empty()) {\\n                // Choose the next destination (the one in lexicographically larger order)\\n                string nextDestination = destinations.back();\\n                destinations.pop_back();\\n\\n                dfsStack.push(nextDestination);\\n            } else {\\n                // If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.push_back(currentAirport);\\n        \\n                dfsStack.pop();\\n            }\\n        }\\n        \\n        // Reverse the itinerary to get the correct order\\n        reverse(travelItinerary.begin(), travelItinerary.end());\\n        return travelItinerary;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private Map<String, List<String>> flightGraph; // Represents flights from one airport to another\\n    private List<String> travelItinerary; // Stores the final travel itinerary\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Initialize the flight graph using ticket information\\n        flightGraph = new HashMap<>();\\n        travelItinerary = new ArrayList<>() ;\\n        for (List<String> ticket : tickets) {\\n            String fromAirport = ticket.get(0);\\n            String toAirport = ticket.get(1);\\n            flightGraph.computeIfAbsent(fromAirport, k -> new ArrayList<>()).add(toAirport);\\n        }\\n\\n        // Sort destinations in reverse order to visit lexical smaller destinations first\\n        for (List<String> destinations : flightGraph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        Stack<String> dfsStack = new Stack<>();\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.isEmpty()) {\\n            // Get the current airport from the top of the stack\\n            String currentAirport = dfsStack.peek();\\n            List<String> destinations = flightGraph.get(currentAirport);\\n\\n            if (destinations != null && !destinations.isEmpty()) {\\n                // Choose the next destination (the one in lexicographically larger order)\\n                String nextDestination = destinations.remove(destinations.size() - 1);\\n                dfsStack.push(nextDestination);\\n            } else {\\n                // If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.add(currentAirport);\\n                dfsStack.pop();\\n            }\\n        }\\n\\n        // Reverse the itinerary to get the correct order\\n        Collections.reverse(travelItinerary);\\n        return travelItinerary;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def findItinerary(self, tickets) -> list[str]:\\n        # Initialize the flight graph using ticket information\\n        flightGraph = defaultdict(list)\\n        travelItinerary = []\\n\\n        for ticket in tickets:\\n            fromAirport, toAirport = ticket[0], ticket[1]\\n            flightGraph[fromAirport].append(toAirport)\\n\\n        # Sort destinations in reverse order to visit lexical smaller destinations first\\n        for destinations in flightGraph.values():\\n            destinations.sort(reverse=True)\\n\\n        dfsStack = [\"JFK\"]\\n\\n        while dfsStack:\\n            # Get the current airport from the top of the stack\\n            currentAirport = dfsStack[-1]\\n            destinations = flightGraph.get(currentAirport, [])\\n\\n            if destinations:\\n                # Choose the next destination (the one in lexicographically larger order)\\n                nextDestination = destinations.pop()\\n                dfsStack.append(nextDestination)\\n            else:\\n                # If there are no more destinations from the current airport, add it to the itinerary\\n                travelItinerary.append(currentAirport)\\n                dfsStack.pop()\\n\\n        # Reverse the itinerary to get the correct order\\n        travelItinerary.reverse()\\n        return travelItinerary\\n```\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, multiset<string, greater<string>>> flightGraph;\\n    vector<string> itinerary;\\n\\npublic:\\n    void dfs(string airport) {\\n        auto &destinations = flightGraph[airport];\\n        \\n        while (!destinations.empty()) {\\n            auto nextDestination = *(--destinations.end());\\n            destinations.erase(--destinations.end());\\n            dfs(nextDestination);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string from = tickets[i][0];\\n            string to = tickets[i][1];\\n\\n            flightGraph[from].insert(to);\\n        }\\n        dfs(\"JFK\");\\n        \\n        reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, multiset<string, greater<string>>> flightGraph;\\n    vector<string> travelItinerary;\\n\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (int i = 0; i < tickets.size(); i++) {\\n            string fromAirport = tickets[i][0];\\n            string toAirport = tickets[i][1];\\n\\n            flightGraph[fromAirport].insert(toAirport);\\n        }\\n        stack<string> dfsStack;\\n        dfsStack.push(\"JFK\");\\n\\n        while (!dfsStack.empty()) {\\n            string currentAirport = dfsStack.top();\\n\\n            auto &destinations = flightGraph[currentAirport];\\n\\n            if (!destinations.empty()) {\\n                auto nextDestination = *(--destinations.end());\\n                destinations.erase(--destinations.end());\\n                \\n                dfsStack.push(nextDestination);\\n            } else {\\n                travelItinerary.push_back(currentAirport);\\n        \\n                dfsStack.pop();\\n            }\\n        }\\n        \\n        reverse(travelItinerary.begin(), travelItinerary.end());\\n        return travelItinerary;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78772,
                "title": "python-dfs-backtracking",
                "content": "I use a dictionary to represent the tickets (start -> [list of possible destinations]).   Then, I start the route at JFK and I dfs from there.  Since I do the dfs in sorted order, the first time that I find a possible route, I can return it and know that it is in the smallest lexigraphic order.  Finally, note that the worked variable either contains None (as a result of a failed search) or the correct route.\\n\\n    def findItinerary(self, tickets):\\n        d = defaultdict(list)\\n        for flight in tickets:\\n            d[flight[0]] += flight[1],\\n        self.route = [\"JFK\"]\\n        def dfs(start = 'JFK'):\\n            if len(self.route) == len(tickets) + 1:\\n                return self.route\\n            myDsts = sorted(d[start])\\n            for dst in myDsts:\\n                d[start].remove(dst)\\n                self.route += dst,\\n                worked = dfs(dst)\\n                if worked:\\n                    return worked\\n                self.route.pop()\\n                d[start] += dst,\\n        return dfs()",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "I use a dictionary to represent the tickets (start -> [list of possible destinations]).   Then, I start the route at JFK and I dfs from there.  Since I do the dfs in sorted order, the first time that I find a possible route, I can return it and know that it is in the smallest lexigraphic order.  Finally, note that the worked variable either contains None (as a result of a failed search) or the correct route.\\n\\n    def findItinerary(self, tickets):\\n        d = defaultdict(list)\\n        for flight in tickets:\\n            d[flight[0]] += flight[1],\\n        self.route = [\"JFK\"]\\n        def dfs(start = 'JFK'):\\n            if len(self.route) == len(tickets) + 1:\\n                return self.route\\n            myDsts = sorted(d[start])\\n            for dst in myDsts:\\n                d[start].remove(dst)\\n                self.route += dst,\\n                worked = dfs(dst)\\n                if worked:\\n                    return worked\\n                self.route.pop()\\n                d[start] += dst,\\n        return dfs()",
                "codeTag": "Python3"
            },
            {
                "id": 437594,
                "title": "super-easy-and-clean-javascript-greedy-dfs-with-detailed-explanations",
                "content": "Greedy strategy  + post order traversal\\n1. build a map to store each departure location and its destinations array.\\n2. sort the destinations array.\\n3. now we assume that the departure airport \\'JFK\\' is the root node for this tree, and its destinations are the children. Since the destinations are sorted, the children are arranged alfabetically from left to right. For each destination, if it is also a departure airport, then its children are the related destinations. Hopefully by now you get an idea of the structure of the tree.\\n4. run a post order traversal of the tree , as a result, \\'JFK\\' now is the last airport visited, hence the Greedy part. \\n5. finally we reverse the result as the return value.\\n\\n\\n```\\nvar findItinerary = function(tickets) {\\n    var map = {};\\n    var res = [];\\n    for(var i=0; i<tickets.length; i++) {\\n        var dep = tickets[i][0];\\n        var des = tickets[i][1];\\n        if(map[dep]) {\\n            map[dep].push(des);\\n        } else {\\n            map[dep] = [des];\\n        }\\n    }\\n    for(let loc in map) {\\n        map[loc].sort();\\n    }  \\n    var dfs = function(node) {\\n        var des = map[node];\\n        while(des && des.length>0) {\\n            dfs(des.shift());\\n        }\\n        res.push(node);\\n    }\\n    dfs(\\'JFK\\');\\n    return res.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar findItinerary = function(tickets) {\\n    var map = {};\\n    var res = [];\\n    for(var i=0; i<tickets.length; i++) {\\n        var dep = tickets[i][0];\\n        var des = tickets[i][1];\\n        if(map[dep]) {\\n            map[dep].push(des);\\n        } else {\\n            map[dep] = [des];\\n        }\\n    }\\n    for(let loc in map) {\\n        map[loc].sort();\\n    }  \\n    var dfs = function(node) {\\n        var des = map[node];\\n        while(des && des.length>0) {\\n            dfs(des.shift());\\n        }\\n        res.push(node);\\n    }\\n    dfs(\\'JFK\\');\\n    return res.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 78841,
                "title": "share-solution-java-greedy-stack-15ms-with-explanation",
                "content": "Noticed some folks are using Hierholzer's algorithm to find a Eulerian path.\\n\\nMy solution is similar, considering this passenger has to be physically in one place before move to another airport, we are considering using up all tickets and choose lexicographically smaller solution if in tie as two constraints.\\n\\nThinking as that passenger, the passenger choose his/her flight greedy as the lexicographical order, once he/she figures out go to an airport without departure with more tickets at hand. the passenger will push current ticket in a stack and look at whether it is possible for him/her to travel to other places from the airport on his/her way.\\n\\nPlease let me know if you have any suggestions.\\n\\n        public List<String> findItinerary(String[][] tickets) {\\n            List<String> ans = new ArrayList<String>();\\n            if(tickets == null || tickets.length == 0) return ans;\\n            Map<String, PriorityQueue<String>> ticketsMap = new HashMap<>();\\n            for(int i = 0; i < tickets.length; i++) {\\n                if(!ticketsMap.containsKey(tickets[i][0])) ticketsMap.put(tickets[i][0], new PriorityQueue<String>());\\n                ticketsMap.get(tickets[i][0]).add(tickets[i][1]);\\n            }\\n    \\n            String curr = \"JFK\";\\n            Stack<String> drawBack = new Stack<String>();\\n            for(int i = 0; i < tickets.length; i++) {\\n                while(!ticketsMap.containsKey(curr) || ticketsMap.get(curr).isEmpty()) {\\n                    drawBack.push(curr);\\n                    curr = ans.remove(ans.size()-1);\\n                }\\n                ans.add(curr);\\n                curr = ticketsMap.get(curr).poll();\\n            }\\n            ans.add(curr);\\n            while(!drawBack.isEmpty()) ans.add(drawBack.pop());\\n            return ans;\\n        }",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "Noticed some folks are using Hierholzer's algorithm to find a Eulerian path.\\n\\nMy solution is similar, considering this passenger has to be physically in one place before move to another airport, we are considering using up all tickets and choose lexicographically smaller solution if in tie as two constraints.\\n\\nThinking as that passenger, the passenger choose his/her flight greedy as the lexicographical order, once he/she figures out go to an airport without departure with more tickets at hand. the passenger will push current ticket in a stack and look at whether it is possible for him/her to travel to other places from the airport on his/her way.\\n\\nPlease let me know if you have any suggestions.\\n\\n        public List<String> findItinerary(String[][] tickets) {\\n            List<String> ans = new ArrayList<String>();\\n            if(tickets == null || tickets.length == 0) return ans;\\n            Map<String, PriorityQueue<String>> ticketsMap = new HashMap<>();\\n            for(int i = 0; i < tickets.length; i++) {\\n                if(!ticketsMap.containsKey(tickets[i][0])) ticketsMap.put(tickets[i][0], new PriorityQueue<String>());\\n                ticketsMap.get(tickets[i][0]).add(tickets[i][1]);\\n            }\\n    \\n            String curr = \"JFK\";\\n            Stack<String> drawBack = new Stack<String>();\\n            for(int i = 0; i < tickets.length; i++) {\\n                while(!ticketsMap.containsKey(curr) || ticketsMap.get(curr).isEmpty()) {\\n                    drawBack.push(curr);\\n                    curr = ans.remove(ans.size()-1);\\n                }\\n                ans.add(curr);\\n                curr = ticketsMap.get(curr).poll();\\n            }\\n            ans.add(curr);\\n            while(!drawBack.isEmpty()) ans.add(drawBack.pop());\\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 78842,
                "title": "c-non-recursive-o-n-time-o-n-space-solution-with-detail-explanations",
                "content": "The idea of this algorithm, which was originally found in fangyang's thread [https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation][1], consists of two steps:\\n\\n- **Step 1**: Store the flight in a hash map. (say `m` in the code below. This map enables us to find all possible destinations from a place in amortized constant time.)\\n\\n- **Step 2**: Use a greedy and trace-back approach to find the optimal itinerary. Specifically, we use greedy method to find a lexicographically-smallest path until we can not move any further (the path can be stored in a vector, say `march` in the code below). Each time we reach such an exhaustive state, we find a place which is exactly the end of the itinerary. (The reason is, the path `march` is an optimal itinerary expect that some loops are omitted. The optimal itinerary can be obtained by inserting some loops into this path, which does not change the last vertex of the path.) Therefore, we can record the last vertex in another place (say `results` in the code below). So and so forth, the vector `results` stores the optimal itinerary reversely, since we always place the optimal last vertex at the end of this vector. Reversing the vertex `results` leads to the correct answer.\\n\\n\\n-----\\n\\n**Example**:\\nThis example is originally shown in  StefanPochmann's thread [https://leetcode.com/discuss/84659/short-ruby-python-java-c][2]\\n\\n\\n![][3]  \\n[ Source of this picture: http://www.stefan-pochmann.info/misc/reconstruct-itinerary.png[][4] ]\\n\\n\\nIn Step 2, we first march greedily, and get the vector `march` as:\\n\\n    march: JFK -> A -> C -> D -> A      (the red path)\\n\\nHowever, the optimal itinerary, is \\n\\n    JFK -> A -> C -> D( -> B -> C -> JFK -> D) -> A\\n\\nwhere the loop (D -> B -> C -> JFK -> D) shall be inserted in the vector `march`. However, we have already found the last vertex A, Therefore, we can record this result. So `march` and `results` become\\n\\n    march: JFK -> A -> C -> D\\n    results: A\\n\\nThen we march greedily again, results in\\n\\n    march: JFK -> A -> C -> D -> B -> C -> JFK -> D\\n    results: A\\n\\nNow all edges are used. Before the final reversion, `march` and `results` become\\n\\n    march: (empty)\\n    results: A <- D <- JFK <- C <- B <- D <- C <- A <- JFK\\n\\n\\n----\\n\\n**Overall Complexities**:\\n\\nLet N be the number of tickets. Let D be the largest outgoing degree of a vertex.\\n\\n- **Time**: *O*(N log D)  \\nStep 1: O(N log D)  \\nStep 2: O(N). Each vertex needs to be put into `march` once and be moved from `march` to `results`. At the very end, `results` is reversed.\\n- **Space**: *O*(N)            \\nThe map `m` needs to store all vertices.\\n\\n\\n-----\\n\\n**Code** (40 ms):\\n\\n    class Solution {\\n    public:\\n        vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n            \\n            // Step 1: Store directed edges in a hash map\\n            unordered_map<string, multiset<string>> m;\\n            for (const pair<string, string> & ticket : tickets) {\\n                m[ticket.first].insert(ticket.second);\\n            }\\n            \\n            // Step 2: March greedily and traceback\\n            vector<string> march = { \"JFK\" }; // the storage for greedy searching\\n            vector<string> results; // store the final results reversely\\n            while (march.empty() == false) {\\n                string & from = march.back();\\n                if ((m.find(from) != m.end()) && (m[from].empty() == false)) { // march further\\n                    multiset<string> & to = m[from];\\n                    march.push_back(*(to.begin()));\\n                    to.erase(to.begin());\\n                } else { // can not march further, trace back\\n                    results.push_back(march.back()); // archive the last place\\n                    march.pop_back();\\n                }\\n            }\\n            reverse(results.begin(), results.end()); // reverse the entries back\\n            return results;\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation\\n  [2]: https://leetcode.com/discuss/84659/short-ruby-python-java-c\\n  [3]: http://www.stefan-pochmann.info/misc/reconstruct-itinerary.png\\n  [4]: https://leetcode.com/discuss/84659/short-ruby-python-java-c",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n            \\n            // Step 1: Store directed edges in a hash map\\n            unordered_map<string, multiset<string>> m;\\n            for (const pair<string, string> & ticket : tickets) {\\n                m[ticket.first].insert(ticket.second);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1490090,
                "title": "java-easy-approach-with-explanation-dfs-euler-topological-sort",
                "content": "```\\nclass Solution\\n{\\n    private HashMap<String, PriorityQueue<String>> map= new HashMap<>();//Starting airport -> Destination airport(lexically asc sorted)\\n    private LinkedList<String> res= new LinkedList<>();//result \\n    \\n    public List<String> findItinerary(List<List<String>> tickets)\\n    {\\n        /*Note::\\n         *->The main idea is to traverse every edge atmost once\\n         *->And we are starting from JFK airport\\n         *->We use Priority Queue to store the adjacent airport in Lexically sorted manner\\n         *->We use a topological sort like approach for displaying the result, i.e, we start from an no in-dependency edge to the most in-dependenncy edge\\n         *->We are considering the euler path to traverse the graph \\n         *->Priority Queue is also helping us keep track of the visited and non-visited edge \\n         *->Hash Map is Used like a adjacency list here \\n         */\\n        \\n        for (List<String> ticket: tickets)\\n        {\\n            String u= ticket.get(0);//starting airport\\n            String v= ticket.get(1);//destination airport\\n            \\n            PriorityQueue<String> temp= map.getOrDefault(u, new PriorityQueue<>());\\n            temp.offer(v);//adding the desitination airport \\n            map.put(u, temp);//adding to the map \\n        }\\n        \\n        dfs(\"JFK\");//Journey Starting Airport\\n        \\n        return res;\\n    }\\n    private void dfs(String src)\\n    {\\n        PriorityQueue<String> pq= map.get(src);//Adjacent Airports\\n        \\n        while (pq != null && pq.size() > 0){//processsing all the destination Airport of the current Airport(src)\\n            String temp= pq.poll();//removing the edge//visited \\n            dfs(temp);//recursing down \\n        }\\n        res.addFirst(src);//adding the Airport while backtracking//least in-dependency as far as possible \\n        return;\\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution\\n{\\n    private HashMap<String, PriorityQueue<String>> map= new HashMap<>();//Starting airport -> Destination airport(lexically asc sorted)\\n    private LinkedList<String> res= new LinkedList<>();//result \\n    \\n    public List<String> findItinerary(List<List<String>> tickets)\\n    {\\n        /*Note::\\n         *->The main idea is to traverse every edge atmost once\\n         *->And we are starting from JFK airport\\n         *->We use Priority Queue to store the adjacent airport in Lexically sorted manner\\n         *->We use a topological sort like approach for displaying the result, i.e, we start from an no in-dependency edge to the most in-dependenncy edge\\n         *->We are considering the euler path to traverse the graph \\n         *->Priority Queue is also helping us keep track of the visited and non-visited edge \\n         *->Hash Map is Used like a adjacency list here \\n         */\\n        \\n        for (List<String> ticket: tickets)\\n        {\\n            String u= ticket.get(0);//starting airport\\n            String v= ticket.get(1);//destination airport\\n            \\n            PriorityQueue<String> temp= map.getOrDefault(u, new PriorityQueue<>());\\n            temp.offer(v);//adding the desitination airport \\n            map.put(u, temp);//adding to the map \\n        }\\n        \\n        dfs(\"JFK\");//Journey Starting Airport\\n        \\n        return res;\\n    }\\n    private void dfs(String src)\\n    {\\n        PriorityQueue<String> pq= map.get(src);//Adjacent Airports\\n        \\n        while (pq != null && pq.size() > 0){//processsing all the destination Airport of the current Airport(src)\\n            String temp= pq.poll();//removing the edge//visited \\n            dfs(temp);//recursing down \\n        }\\n        res.addFirst(src);//adding the Airport while backtracking//least in-dependency as far as possible \\n        return;\\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042491,
                "title": "video-visualized-solution-python-javascript-java-c",
                "content": "# Intuition\\nThis code uses airline ticket information to construct a valid itinerary starting from the departure airport \"JFK\" and organizing destinations into a dictionary-style graph. It manages the routes from departure to arrival using a stack, adding them to a new itinerary when there are no more destinations. The final itinerary is reversed to obtain the correct order.\\n\\n---\\n\\n# Solution Video\\n\\nhttps://youtu.be/7kZKIod8L94\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2310\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n1. Creating the Graph and Organizing Ticket Information:\\n   - Create a dictionary-style graph to store airports and their destinations.\\n   - Sort the ticket information in reverse order based on arrival airports.\\n\\n2. Initializing the Stack and New Itinerary:\\n   - Create a stack initialized with `JFK` as the departure airport.\\n   - Initialize a list to store the new itinerary.\\n\\n3. Constructing the Itinerary Using the Stack:\\n   - Repeat the following process as long as the stack is not empty:\\n   - Add potential destinations departing from the current airport to the stack.\\n   - When there are no more destinations, add the current airport to the new itinerary.\\n\\n4. Reversing the Itinerary:\\n   - Reverse the new itinerary to obtain the correct order of the itinerary.\\n\\n5. Returning the Correct Order Itinerary:\\n   - Return the reversed itinerary as the final result.\\n\\n# How it works\\n\\n```\\nInput: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],\\n[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\\n```\\n\\n## **Step 1:** Graph Initialization\\n\\nIn this step, the graph is initialized. The graph is represented as a dictionary with departure points (airports) as keys and lists of arrival points (other airports) as values. In this initialization, no information has been added yet.\\n\\nIn this step, the provided airline ticket information is sorted in reverse order.\\n\\nAirline tickets sorted in reverse order for lexical order: `[[\\'SFO\\', \\'ATL\\'], [\\'JFK\\', \\'SFO\\'], [\\'JFK\\', \\'ATL\\'], [\\'ATL\\', \\'SFO\\'], [\\'ATL\\', \\'JFK\\']]`\\n\\nThe reason for performing reverse sorting (reverse order) in this code is to use a stack and find the \"lexicographically smallest route\" according to the constraints of the problem. There are two key points in the constraints:\\n\\n1. The departure point must be `JFK.`\\n2. The lexicographically smallest route needs to be found.\\n\\nBy performing reverse sorting, when the departure point is `JFK` the route will start with the ticket that has the smallest destination in lexicographical order. In other words, the route that starts from `JFK` is chosen as the smallest route initially.\\n\\nThe other important reason is that we can use `pop()` and easily get the smallest destination in lexicographical order with `O(1)`. Therefore, reverse sorting is necessary to meet the constraints of the problem.\\n\\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\", \"ATL\"],\\n    \"ATL\": [\"SFO\", \"JFK\"]\\n}\\n```\\n\\nThe graph has been correctly updated as a result of this step.\\n\\n## **Step 2:** Stack and Itinerary Initialization\\n\\nIn this step, the stack `st` and an empty itinerary list `new_itinerary` are initialized.\\n\\n```\\nst: [\"JFK\"]\\nnew_itinerary: []\\n```\\n\\n## **Step 3:** Building the Itinerary Using the Stack\\n\\nIn this step, the itinerary is constructed using a stack. The following operations are repeated in each step of stack operation.\\n\\n1. Check the current airport at the top of the stack. The initial airport is `JFK`.\\n\\n    - `st`: `[\"JFK\"]`\\n    - `new_itinerary`: `[]`\\n\\n2. Find the places reachable from the current airport `JFK`. From the current airport `JFK`, you can go to `SFO` and `ATL`. Add `ATL` to the stack.\\n\\n    - `st`: `[\"JFK\", \"ATL\"]`\\n    - `new_itinerary`: `[]`\\n\\nCurrent graph:\\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\"],\\n    \"ATL\": [\"SFO\", \"JFK\"]\\n}\\n```\\n\\n4. Add the places reachable from `ATL` to the stack. From the current airport `ATL`, you can go to `SFO` and `JFK`. Add `JFK` to the stack.\\n\\n    - `st`: `[\"JFK\", \"ATL\", \"JFK\"]`\\n    - `new_itinerary`: `[]`\\n\\nCurrent graph:\\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\\n\\n5. Add the places reachable from `JFK` to the stack. From the current airport `JFK`, you can go to `SFO`. Add `JFK` to the stack.\\n\\n    - `st`: `[\"JFK\", \"ATL\", \"JFK\", \"SFO\"]`\\n    - `new_itinerary`: `[\"\"]`\\n\\nCurrent graph:\\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\\n\\n6. Add the places reachable from `SFO` to the stack. From the current airport `SFO`, you can go to `ATL`. Add ATL` to the stack.\\n\\n    - `st`: `[\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\"]`\\n    - `new_itinerary`: `[\"\"]`\\n\\nCurrent graph:\\n```\\ngraph = {\\n    \"SFO\": [\"\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\\n\\n7. Add the places reachable from `ATL` to the stack. From the current airport `ATL`, you can go to `SFO`. Add `SFO` to the stack.\\n\\n    - `st`: `[\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]`\\n    - `new_itinerary`: `[\"\"]`\\n\\nCurrent graph:\\n```\\ngraph = {\\n    \"SFO\": [\"\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"\"]\\n}\\n```\\n\\nFinally, pop data from `st` and assign it to `new_itinerary`. This operation is necessary to avoid an infinite loop in the outermost `while` loop.\\n\\n```\\n`st`: `[\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]`\\n\\nnew_itinerary [\\'SFO\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\', \\'ATL\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\', \\'ATL\\', \\'JFK\\']\\n```\\n\\nReverse `new_itinerary` and return it.\\n\\n```\\nOutput: [\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]\\n```\\n\\n# Complexity\\n- Time complexity: O(N log N)\\n    - Let N be the number of tickets. Sorting the tickets in reverse order takes O(N log N) time.\\n    - Processing each ticket using the stack takes O(N) time.\\n\\n\\n\\n- Space complexity: O(N)\\n    - To represent the graph, O(N) space is required.\\n    - O(N) space is needed for the stack and the new itinerary.\\n\\n    \\n```python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Create a graph represented as a dictionary where each airport is a key, and its destinations are values.\\n        graph = defaultdict(list)\\n\\n        for departure, arrival in sorted(tickets, reverse=True):\\n            graph[departure].append(arrival)\\n\\n        # Initialize the stack with the starting airport \"JFK\" and an empty itinerary.\\n        st = [\"JFK\"]\\n        new_itinerary = []\\n\\n        while st:\\n            # If there are destinations from the current airport, add the next destination to the stack.\\n            if graph[st[-1]]:\\n                st.append(graph[st[-1]].pop())\\n            else:\\n                # When there are no more destinations, add the current airport to the new itinerary.\\n                new_itinerary.append(st.pop())\\n\\n        # Reverse the new itinerary to get the correct order.\\n        return new_itinerary[::-1]\\n```\\n```javascript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = new Map();\\n\\n    for (const [departure, arrival] of tickets.sort().reverse()) {\\n        if (!graph.has(departure)) {\\n            graph.set(departure, []);\\n        }\\n        graph.get(departure).push(arrival);\\n    }\\n\\n    const stack = [\"JFK\"];\\n    const newItinerary = [];\\n\\n    while (stack.length > 0) {\\n        const currentAirport = stack[stack.length - 1];\\n\\n        if (graph.has(currentAirport) && graph.get(currentAirport).length > 0) {\\n            stack.push(graph.get(currentAirport).pop());\\n        } else {\\n            newItinerary.push(stack.pop());\\n        }\\n    }\\n\\n    return newItinerary.reverse();    \\n};\\n```\\n```java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, List<String>> graph = new HashMap<>();\\n\\n        for (List<String> ticket : tickets) {\\n            String departure = ticket.get(0);\\n            String arrival = ticket.get(1);\\n\\n            graph.computeIfAbsent(departure, k -> new ArrayList<>()).add(arrival);\\n        }\\n\\n        for (List<String> destinations : graph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        List<String> newItinerary = new ArrayList<>();\\n        Deque<String> stack = new ArrayDeque<>();\\n        stack.push(\"JFK\");\\n\\n        while (!stack.isEmpty()) {\\n            String currentAirport = stack.peek();\\n\\n            if (graph.containsKey(currentAirport) && !graph.get(currentAirport).isEmpty()) {\\n                stack.push(graph.get(currentAirport).remove(graph.get(currentAirport).size() - 1));\\n            } else {\\n                newItinerary.add(stack.pop());\\n            }\\n        }\\n\\n        Collections.reverse(newItinerary);\\n        return newItinerary;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push(ticket[1]);\\n        }\\n\\n        vector<string> newItinerary;\\n        stack<string> st;\\n        st.push(\"JFK\");\\n\\n        while (!st.empty()) {\\n            string currentAirport = st.top();\\n\\n            if (graph.find(currentAirport) != graph.end() && !graph[currentAirport].empty()) {\\n                st.push(graph[currentAirport].top());\\n                graph[currentAirport].pop();\\n            } else {\\n                newItinerary.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n\\n        reverse(newItinerary.begin(), newItinerary.end());\\n        return newItinerary;        \\n    }\\n};\\n```\\n\\n\\n---\\n\\n\\n\\n# Can I make a small request?\\nThank you for watching my video and reading my article!\\n\\n\\u2B50\\uFE0F If you like my video and my article, please subscribe to my youtube channel and upvote the article. My initial goal for youtube is to reach 10,000 subscribers. It\\'s far from done.\\n\\nHave a nice day!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nInput: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],\\n[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\\n```\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\", \"ATL\"],\\n    \"ATL\": [\"SFO\", \"JFK\"]\\n}\\n```\n```\\nst: [\"JFK\"]\\nnew_itinerary: []\\n```\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\"],\\n    \"ATL\": [\"SFO\", \"JFK\"]\\n}\\n```\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"SFO\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\n```\\ngraph = {\\n    \"SFO\": [\"ATL\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\n```\\ngraph = {\\n    \"SFO\": [\"\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"SFO\"]\\n}\\n```\n```\\ngraph = {\\n    \"SFO\": [\"\"],\\n    \"JFK\": [\"\"],\\n    \"ATL\": [\"\"]\\n}\\n```\n```\\n`st`: `[\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]`\\n\\nnew_itinerary [\\'SFO\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\', \\'ATL\\']\\nnew_itinerary [\\'SFO\\', \\'ATL\\', \\'SFO\\', \\'JFK\\', \\'ATL\\', \\'JFK\\']\\n```\n```\\nOutput: [\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]\\n```\n```python []\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Create a graph represented as a dictionary where each airport is a key, and its destinations are values.\\n        graph = defaultdict(list)\\n\\n        for departure, arrival in sorted(tickets, reverse=True):\\n            graph[departure].append(arrival)\\n\\n        # Initialize the stack with the starting airport \"JFK\" and an empty itinerary.\\n        st = [\"JFK\"]\\n        new_itinerary = []\\n\\n        while st:\\n            # If there are destinations from the current airport, add the next destination to the stack.\\n            if graph[st[-1]]:\\n                st.append(graph[st[-1]].pop())\\n            else:\\n                # When there are no more destinations, add the current airport to the new itinerary.\\n                new_itinerary.append(st.pop())\\n\\n        # Reverse the new itinerary to get the correct order.\\n        return new_itinerary[::-1]\\n```\n```javascript []\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    const graph = new Map();\\n\\n    for (const [departure, arrival] of tickets.sort().reverse()) {\\n        if (!graph.has(departure)) {\\n            graph.set(departure, []);\\n        }\\n        graph.get(departure).push(arrival);\\n    }\\n\\n    const stack = [\"JFK\"];\\n    const newItinerary = [];\\n\\n    while (stack.length > 0) {\\n        const currentAirport = stack[stack.length - 1];\\n\\n        if (graph.has(currentAirport) && graph.get(currentAirport).length > 0) {\\n            stack.push(graph.get(currentAirport).pop());\\n        } else {\\n            newItinerary.push(stack.pop());\\n        }\\n    }\\n\\n    return newItinerary.reverse();    \\n};\\n```\n```java []\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, List<String>> graph = new HashMap<>();\\n\\n        for (List<String> ticket : tickets) {\\n            String departure = ticket.get(0);\\n            String arrival = ticket.get(1);\\n\\n            graph.computeIfAbsent(departure, k -> new ArrayList<>()).add(arrival);\\n        }\\n\\n        for (List<String> destinations : graph.values()) {\\n            destinations.sort(Collections.reverseOrder());\\n        }\\n\\n        List<String> newItinerary = new ArrayList<>();\\n        Deque<String> stack = new ArrayDeque<>();\\n        stack.push(\"JFK\");\\n\\n        while (!stack.isEmpty()) {\\n            String currentAirport = stack.peek();\\n\\n            if (graph.containsKey(currentAirport) && !graph.get(currentAirport).isEmpty()) {\\n                stack.push(graph.get(currentAirport).remove(graph.get(currentAirport).size() - 1));\\n            } else {\\n                newItinerary.add(stack.pop());\\n            }\\n        }\\n\\n        Collections.reverse(newItinerary);\\n        return newItinerary;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push(ticket[1]);\\n        }\\n\\n        vector<string> newItinerary;\\n        stack<string> st;\\n        st.push(\"JFK\");\\n\\n        while (!st.empty()) {\\n            string currentAirport = st.top();\\n\\n            if (graph.find(currentAirport) != graph.end() && !graph[currentAirport].empty()) {\\n                st.push(graph[currentAirport].top());\\n                graph[currentAirport].pop();\\n            } else {\\n                newItinerary.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n\\n        reverse(newItinerary.begin(), newItinerary.end());\\n        return newItinerary;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78785,
                "title": "java-11ms-solution-hashmap-sorted-list",
                "content": "    public class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            ArrayList<String> result = new ArrayList<String>();\\n            \\n            if(tickets == null || tickets.length == 0){\\n                return result;\\n            }\\n            \\n            int total = tickets.length + 1;\\n            \\n            HashMap<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();\\n            \\n            for(int i = 0; i < tickets.length; i++){\\n                if(map.containsKey(tickets[i][0])){\\n                    ArrayList<String> tmp = map.get(tickets[i][0]);\\n                    listAdd(tickets[i][1], tmp);\\n                }\\n                else{\\n                    ArrayList<String> tmp = new ArrayList<String>();\\n                    tmp.add(tickets[i][1]);\\n                    map.put(tickets[i][0], tmp);\\n                }\\n            }\\n            \\n            result.add(\"JFK\");\\n            \\n            itineraryHelper(\"JFK\", map, result, total, 1);\\n            \\n            return result;\\n        }\\n        \\n        public boolean itineraryHelper(String current, HashMap<String, ArrayList<String>> map, ArrayList<String> result, int total, int num){\\n            \\n            if(num >= total){\\n                return true;\\n            }\\n            \\n            if(!map.containsKey(current) || map.get(current).size() == 0){\\n                return false;\\n            }\\n            \\n            ArrayList<String> curList = map.get(current);\\n            int i = 0;\\n            \\n            while(i < curList.size()){\\n                String next = curList.remove(i);\\n                result.add(next);\\n                \\n                if(itineraryHelper(next, map, result, total, num + 1)){\\n                    return true;\\n                }\\n                \\n                result.remove(result.size() - 1);\\n                listAdd(next, curList);\\n                i++;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        \\n        public void listAdd(String value, ArrayList<String> list){\\n            if(list.size() == 0){\\n                list.add(value);\\n                return;\\n            }\\n            else{\\n                int i = 0;\\n                while(i < list.size()){\\n                    if(value.compareTo(list.get(i)) <= 0){\\n                        list.add(i, value);\\n                        return;\\n                    }\\n                    i++;\\n                }\\n                list.add(value);\\n                return;\\n            }\\n        }\\n        \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            ArrayList<String> result = new ArrayList<String>();\\n            \\n            if(tickets == null || tickets.length == 0){\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 78789,
                "title": "java-14ms-dfs-backtrack",
                "content": "Calculate Euler path. For each point, try to DFS its out-going point. There is chance that a DFS won't get a result. So, we do backtrack. Out-going points should keep ascending order.\\n\\n    public static List<String> findItinerary(String[][] tickets) {\\n        // construct graph\\n        HashMap<String, ArrayList<String>> graph = new HashMap<String, ArrayList<String>>();\\n        ArrayList<String> al = null;\\n        for (String[] ticket : tickets) {\\n            al = graph.get(ticket[0]);\\n            if (al == null) {\\n                al = new ArrayList<String>();\\n                graph.put(ticket[0], al);\\n            }\\n            al.add(ticket[1]);\\n        }\\n        for (ArrayList<String> curr : graph.values()) {\\n            Collections.sort(curr);\\n        }\\n        ArrayList<String> ans = new ArrayList<>();\\n        itineraryHelper(\"JFK\", ans, graph, tickets.length + 1);\\n        return ans;\\n    }\\n\\n    // n is how many stops totally should contain\\n    public static boolean itineraryHelper(String curr, List<String> ans, HashMap<String, ArrayList<String>> graph, int n) {\\n        ans.add(curr);\\n        if (ans.size() >= n) {\\n            return true;\\n        }\\n        if (!graph.containsKey(curr) || graph.get(curr).isEmpty()) {\\n            return false;\\n        }\\n        ArrayList<String> arrivals = graph.get(curr);\\n        for (int i = 0; i < arrivals.size(); i++) { // iterate each arrival point\\n            String arrival = graph.get(curr).remove(i);\\n            if (itineraryHelper(arrival, ans, graph, n)) {\\n                return true;\\n            }\\n            ans.remove(ans.size() - 1); // backtrack\\n            arrivals.add(i, arrival);\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "Calculate Euler path. For each point, try to DFS its out-going point. There is chance that a DFS won't get a result. So, we do backtrack. Out-going points should keep ascending order.\\n\\n    public static List<String> findItinerary(String[][] tickets) {\\n        // construct graph\\n        HashMap<String, ArrayList<String>> graph = new HashMap<String, ArrayList<String>>();\\n        ArrayList<String> al = null;\\n        for (String[] ticket : tickets) {\\n            al = graph.get(ticket[0]);\\n            if (al == null) {\\n                al = new ArrayList<String>();\\n                graph.put(ticket[0], al);\\n            }\\n            al.add(ticket[1]);\\n        }\\n        for (ArrayList<String> curr : graph.values()) {\\n            Collections.sort(curr);\\n        }\\n        ArrayList<String> ans = new ArrayList<>();\\n        itineraryHelper(\"JFK\", ans, graph, tickets.length + 1);\\n        return ans;\\n    }\\n\\n    // n is how many stops totally should contain\\n    public static boolean itineraryHelper(String curr, List<String> ans, HashMap<String, ArrayList<String>> graph, int n) {\\n        ans.add(curr);\\n        if (ans.size() >= n) {\\n            return true;\\n        }\\n        if (!graph.containsKey(curr) || graph.get(curr).isEmpty()) {\\n            return false;\\n        }\\n        ArrayList<String> arrivals = graph.get(curr);\\n        for (int i = 0; i < arrivals.size(); i++) { // iterate each arrival point\\n            String arrival = graph.get(curr).remove(i);\\n            if (itineraryHelper(arrival, ans, graph, n)) {\\n                return true;\\n            }\\n            ans.remove(ans.size() - 1); // backtrack\\n            arrivals.add(i, arrival);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 138641,
                "title": "logical-thinking-with-clear-java-code",
                "content": "It is intuitive to model the problem as a graph, such that airports are nodes, and tickets are directed edges.\\nWe ought to take two factors into consideration when reconstruct the itinerary:\\n- all tickets are used up; [comments on code `1.`]\\n- the smaller lexical order is preferred;\\n\\nWe simply DFS the graph, and backtrack if the path can not use up all tickets.[comments on code `2.`]\\nTo ensure smallest lexical order, for a departure airport, we sort its arrival airports in the lexical order before DFS.[comments on code `3.`]\\nThen, the first path uses up all tickets should be the final answer. [comments on code `4.`]\\n\\nFor **DFS**,\\nthe **start point** is the airport \"JFK\",\\n**for each departure airport** {\\n\\t\\t\\tit can get an access to any one of its arrival airports, i.e., map.get(start),\\n\\t\\t\\tand move forward to the next step..\\n}\\nthe **end point** is the first path that ensures all tickets to be used up, i.e., result.size() > 0,\\n\\nThe clear code in Java is as below:\\n```\\nList<String> result;\\n\\npublic List<String> findItinerary(String[][] tickets) {\\n    result = new ArrayList<>();\\n    Map<String, List<String>> map = new HashMap<>();\\n    for (String[] ticket : tickets) {\\n        if (!map.containsKey(ticket[0])) {\\n            map.put(ticket[0], new ArrayList<>());\\n        }\\n        map.get(ticket[0]).add(ticket[1]);\\n    }\\n    for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n        Collections.sort(entry.getValue()); // 3.\\n    }\\n    findItineraryFrom(\"JFK\", map, new ArrayList<>(), tickets.length);\\n    result.add(0, \"JFK\");\\n    return result;\\n}\\n\\nprivate void findItineraryFrom(String start, Map<String, List<String>> map, List<String> curRes, int numTickets) {\\n    if (curRes.size() == numTickets) { // 1.all tickets are used up\\n        result.addAll(curRes);\\n        return;\\n    }\\n    if (map.get(start) == null) { // 2.the path can not use up all tickets\\n        return;\\n    }\\n    for (int i = 0; i < map.get(start).size(); i++) {\\n        String dest = map.get(start).get(i);\\n        map.get(start).remove(dest);\\n        curRes.add(dest);\\n        findItineraryFrom(dest, map, curRes, numTickets);\\n        if (result.size() > 0) { // 4.the first valid path is the final answer\\n            return;\\n        }\\n        map.get(start).add(i, dest);\\n        curRes.remove(curRes.size() - 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nList<String> result;\\n\\npublic List<String> findItinerary(String[][] tickets) {\\n    result = new ArrayList<>();\\n    Map<String, List<String>> map = new HashMap<>();\\n    for (String[] ticket : tickets) {\\n        if (!map.containsKey(ticket[0])) {\\n            map.put(ticket[0], new ArrayList<>());\\n        }\\n        map.get(ticket[0]).add(ticket[1]);\\n    }\\n    for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n        Collections.sort(entry.getValue()); // 3.\\n    }\\n    findItineraryFrom(\"JFK\", map, new ArrayList<>(), tickets.length);\\n    result.add(0, \"JFK\");\\n    return result;\\n}\\n\\nprivate void findItineraryFrom(String start, Map<String, List<String>> map, List<String> curRes, int numTickets) {\\n    if (curRes.size() == numTickets) { // 1.all tickets are used up\\n        result.addAll(curRes);\\n        return;\\n    }\\n    if (map.get(start) == null) { // 2.the path can not use up all tickets\\n        return;\\n    }\\n    for (int i = 0; i < map.get(start).size(); i++) {\\n        String dest = map.get(start).get(i);\\n        map.get(start).remove(dest);\\n        curRes.add(dest);\\n        findItineraryFrom(dest, map, curRes, numTickets);\\n        if (result.size() > 0) { // 4.the first valid path is the final answer\\n            return;\\n        }\\n        map.get(start).add(i, dest);\\n        curRes.remove(curRes.size() - 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1161401,
                "title": "c-explaination-transition-from-dfs-to-eulerian-path",
                "content": "The problem can be modelled as a graph, with each node representing a city, and each ticket representing an edge from source city to destination city. The problem asks us to find a connected sequence(path) consisting of all edges in a graph, starting with \"JFK\".\\n\\nOur general intuition is to jump to algorithms like DFS/BFS. The DFS/BFS algorithms help us traverse all nodes in the graph, but fail to cover all edges in the graph, so we need to look for something more special.\\n\\nThis is where Eulerian Path comes into play. An Eulerian Path is a list of all edges in a graph in a sequence such that you can go from point A to all other nodes in the graph multiple times, as long as an edge is not visited. This should solve our problem.\\n\\nEulerian Path can be implemented using a slightly modified version of DFS. A normal DFS algorithm would look like this:\\n\\n```\\n// Normal DFS Pseudo Code\\n\\nDFS(node)\\n{\\n\\tif (visited[node])\\n\\t\\treturn;\\n\\tvisited[node]=true;\\n\\tfor (neighbour : graph[node]) {\\n\\t\\tDFS(neighbour);\\n\\t}\\n}\\n```\\nNote that here, we only check if a node is visited, which does not guarantee if all paths going to the node have been visited or not. One way to track if all edges have been visited to a node, is to track the outdegree of the node and continuously decrementing the outdegree until it becomes 0. So our modified DFS becomes:\\n\\n```\\nModifiedDFS(node)\\n{\\n\\tif (outdegree[node] == 0) // no more outgoing edges to visit\\n\\t\\treturn;\\n\\t\\t--outdegree[node]       // next neighbour will be visited, reduce outdegree\\n\\tfor (next_unvisited_neighbour : graph[node])\\n\\t{\\n\\t\\tModifiedDFS(next_unvisited_neighbour);\\n\\t}\\n}\\n```\\n\\nIn addition to this, we would also like to make sure that while returning, we capture the node that we have completed visiting while returing back. We could either reverse the order at the end of capturing all nodes we visited to get our path, or we could just use list and record our nodes from back to front. I went ahead with linked list.\\n\\nKindly upvote if you found this helpful!\\n\\n```\\nvoid findPath(string currNode, list <string> &path, map <string, \\n                    vector <string>>& graph, map <string, int> &outDegree)\\n    {\\n\\t    while (outDegree[currNode]) {\\n            findPath(graph[currNode][--outDegree[currNode]],path, graph, outDegree);\\n\\t    }\\n\\t    path.push_front(currNode);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        list <string> path;\\n\\t    string startNode = \"JFK\";\\n\\t    map <string, vector <string>> graph;\\n        map <string, int> outDegree;\\n\\n\\t    for (auto e : tickets) {\\n\\t\\t    graph[e[0]].push_back(e[1]);\\n\\t\\t    outDegree[e[0]]++;\\n\\t    }\\n       \\n        for (auto &g: graph) {\\n            sort(g.second.begin(), g.second.end(), greater<string>());\\n        }\\n\\n\\t    findPath(startNode, path, graph, outDegree);\\n\\t    return vector <string> (path.begin(), path.end());\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n// Normal DFS Pseudo Code\\n\\nDFS(node)\\n{\\n\\tif (visited[node])\\n\\t\\treturn;\\n\\tvisited[node]=true;\\n\\tfor (neighbour : graph[node]) {\\n\\t\\tDFS(neighbour);\\n\\t}\\n}\\n```\n```\\nModifiedDFS(node)\\n{\\n\\tif (outdegree[node] == 0) // no more outgoing edges to visit\\n\\t\\treturn;\\n\\t\\t--outdegree[node]       // next neighbour will be visited, reduce outdegree\\n\\tfor (next_unvisited_neighbour : graph[node])\\n\\t{\\n\\t\\tModifiedDFS(next_unvisited_neighbour);\\n\\t}\\n}\\n```\n```\\nvoid findPath(string currNode, list <string> &path, map <string, \\n                    vector <string>>& graph, map <string, int> &outDegree)\\n    {\\n\\t    while (outDegree[currNode]) {\\n            findPath(graph[currNode][--outDegree[currNode]],path, graph, outDegree);\\n\\t    }\\n\\t    path.push_front(currNode);\\n    }\\n\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        list <string> path;\\n\\t    string startNode = \"JFK\";\\n\\t    map <string, vector <string>> graph;\\n        map <string, int> outDegree;\\n\\n\\t    for (auto e : tickets) {\\n\\t\\t    graph[e[0]].push_back(e[1]);\\n\\t\\t    outDegree[e[0]]++;\\n\\t    }\\n       \\n        for (auto &g: graph) {\\n            sort(g.second.begin(), g.second.end(), greater<string>());\\n        }\\n\\n\\t    findPath(startNode, path, graph, outDegree);\\n\\t    return vector <string> (path.begin(), path.end());\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042140,
                "title": "96-90-beats-c-hard-easy-easy-to-understand-beginner",
                "content": "# Intuition\\n- The problem requires finding a valid itinerary for a given list of flight tickets. \\n- The itinerary must start from \"JFK\" (John F. Kennedy International Airport) and visit all airports exactly once. \\n- This problem can be solved using depth-first search (DFS) on a directed graph, treating each airport as a node and each ticket as a directed edge.\\n\\n\\n\\n# Approach\\n1. Create an adjacency list representation of the flights. Use an unordered_map where the key is the source airport, and the value is a multiset (sorted set) of destination airports. This allows multiple tickets to have the same source airport.\\n\\n1. Initialize an empty vector called `result` to store the final itinerary.\\n\\n1. Start the DFS traversal from the \"JFK\" airport. The goal is to visit all airports in a way that respects the lexicographically smallest order.\\n\\n1. In the DFS function:\\n\\n   - While there are destinations connected to the current airport:\\n   - Get the next destination by picking the smallest destination lexicographically (because it\\'s stored in a multiset).\\n   - Remove this destination from the list to ensure it\\'s not visited again.\\n   - Recursively explore this destination.\\n 1. After finishing the DFS traversal, reverse the `result` vector. This is necessary because the DFS builds the itinerary in reverse order.\\n\\n1. Return the reversed `result` vector, which now contains the valid itinerary.\\n\\n\\n\\n\\n\\n# Complexity\\n- **Time complexity:**\\n  **O(n * log(n))**\\n\\n  - **The time complexity is O(n * log(n)) for building the adjacency list and O(n * log(n)) for DFS traversal, which is often the dominant factor**\\n\\n\\n\\n- Space complexity:\\n   **O(n * log(n))**\\n\\n    - **The space complexity is O(n * log(n)) for the adjacency list and O(n) for other data structures.**\\n\\n\\n# PLEASE UPVOTE\\u2763\\uD83D\\uDE0D\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    void dfs(unordered_map<string, multiset<string>>& adj, vector<string>& result, string s){\\n        // While there are destinations connected to the current airport\\n        while(adj[s].size()){\\n            // Get the next destination\\n            string v = *(adj[s].begin());\\n            // Remove this destination from the list\\n            adj[s].erase(adj[s].begin());\\n            // Recursively explore this destination\\n            dfs(adj, result, v);\\n        }\\n        // Add the current airport to the result\\n        result.push_back(s);\\n    }\\npublic:\\n    // Main function to find the itinerary\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Create an adjacency list to represent the flights\\n        unordered_map<string, multiset<string>> adj;\\n        for(vector<string>& t: tickets)\\n            // Add each destination to the multiset connected to its source airport\\n            adj[t[0]].insert(t[1]);\\n        \\n        // Initialize the result vector\\n        vector<string> result;\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        reverse(result.begin(), result.end());\\n        // Return the itinerary\\n        return result;\\n    }\\n};\\n\\n```\\n# JAVA\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    private void dfs(Map<String, PriorityQueue<String>> adj, List<String> result, String s) {\\n        // Check if the airport exists in the adjacency list\\n        if (adj.containsKey(s)) {\\n            // While there are destinations connected to the current airport\\n            while (!adj.get(s).isEmpty()) {\\n                // Get the next destination\\n                String v = adj.get(s).poll();\\n                // Recursively explore this destination\\n                dfs(adj, result, v);\\n            }\\n        }\\n        // Add the current airport to the result\\n        result.add(s);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Create an adjacency list to represent the flights\\n        Map<String, PriorityQueue<String>> adj = new HashMap<>();\\n        for (List<String> t : tickets) {\\n            adj.computeIfAbsent(t.get(0), k -> new PriorityQueue<>()).offer(t.get(1));\\n        }\\n\\n        // Initialize the result list\\n        List<String> result = new ArrayList<>();\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        Collections.reverse(result);\\n        // Return the itinerary\\n        return result;\\n    }\\n}\\n\\n```\\n# JAVASCRIPT\\n```\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    dfs(adj, result, s) {\\n        // While there are destinations connected to the current airport\\n        while (adj[s].size) {\\n            // Get the next destination\\n            let v = adj[s].values().next().value;\\n            // Remove this destination from the list\\n            adj[s].delete(v);\\n            // Recursively explore this destination\\n            this.dfs(adj, result, v);\\n        }\\n        // Add the current airport to the result\\n        result.push(s);\\n    }\\n\\n    findItinerary(tickets) {\\n        // Create an adjacency list to represent the flights\\n        const adj = new Map();\\n        for (const t of tickets) {\\n            if (!adj.has(t[0])) {\\n                adj.set(t[0], new Set());\\n            }\\n            adj.get(t[0]).add(t[1]);\\n        }\\n\\n        // Initialize the result array\\n        const result = [];\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        this.dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        result.reverse();\\n        // Return the itinerary\\n        return result;\\n    }\\n}\\n\\n```\\n# PYTHON\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def dfs(self, adj, result, s):\\n        if s in adj:\\n            destinations = adj[s][:]\\n            while destinations:\\n                dest = destinations[0]\\n                adj[s].pop(0)  # Remove the used ticket\\n                self.dfs(adj, result, dest)\\n                destinations = adj[s][:]\\n        result.append(s)\\n\\n    def findItinerary(self, tickets):\\n        # Create an adjacency list to represent the flights\\n        adj = defaultdict(list)\\n        for t in tickets:\\n            adj[t[0]].append(t[1])\\n        \\n        # Sort the destinations in lexicographical order to get the correct itinerary\\n        for key in adj:\\n            adj[key].sort()\\n\\n        # Initialize the result list\\n        result = []\\n        # Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        self.dfs(adj, result, \"JFK\")\\n        # Reverse the result to get the correct itinerary\\n        result.reverse()\\n\\n        # Check if all tickets have been used\\n        total_tickets = len(tickets) + 1  # Plus one for the starting airport JFK\\n        if len(result) != total_tickets:\\n            return []\\n\\n        # Return the itinerary\\n        return result\\n\\n```\\n# GO\\n```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n\\t\"sort\"\\n)\\n\\ntype Solution struct{}\\n\\n// Depth-first search function to find the itinerary\\nfunc (s Solution) dfs(adj map[string]*PriorityQueue, result *[]string, s string) {\\n\\t// While there are destinations connected to the current airport\\n\\tfor adj[s].Len() > 0 {\\n\\t\\t// Get the next destination\\n\\t\\tv := heap.Pop(adj[s]).(string)\\n\\t\\t// Recursively explore this destination\\n\\t\\ts.dfs(adj, result, v)\\n\\t}\\n\\t// Add the current airport to the result\\n\\t*result = append(*result, s)\\n}\\n\\n// Main function to find the itinerary\\nfunc (s Solution) findItinerary(tickets [][]string) []string {\\n\\t// Create an adjacency list to represent the flights\\n\\tadj := make(map[string]*PriorityQueue)\\n\\tfor _, t := range tickets {\\n\\t\\tsrc, dest := t[0], t[1]\\n\\t\\tif _, ok := adj[src]; !ok {\\n\\t\\t\\tadj[src] = &PriorityQueue{}\\n\\t\\t\\theap.Init(adj[src])\\n\\t\\t}\\n\\t\\theap.Push(adj[src], dest)\\n\\t}\\n\\n\\t// Initialize the result slice\\n\\tvar result []string\\n\\t// Start the depth-first search from JFK (John F. Kennedy International Airport)\\n\\ts.dfs(adj, &result, \"JFK\")\\n\\t// Reverse the result to get the correct itinerary\\n\\tsort.Sort(sort.Reverse(sort.StringSlice(result)))\\n\\t// Return the itinerary\\n\\treturn result\\n}\\n\\n// PriorityQueue is a simple priority queue implemented using a slice\\ntype PriorityQueue []string\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i] < pq[j] }\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\t*pq = append(*pq, x.(string))\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n```\\n# PLEASE UPVOTE\\u2763\\uD83D\\uDE0D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    void dfs(unordered_map<string, multiset<string>>& adj, vector<string>& result, string s){\\n        // While there are destinations connected to the current airport\\n        while(adj[s].size()){\\n            // Get the next destination\\n            string v = *(adj[s].begin());\\n            // Remove this destination from the list\\n            adj[s].erase(adj[s].begin());\\n            // Recursively explore this destination\\n            dfs(adj, result, v);\\n        }\\n        // Add the current airport to the result\\n        result.push_back(s);\\n    }\\npublic:\\n    // Main function to find the itinerary\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Create an adjacency list to represent the flights\\n        unordered_map<string, multiset<string>> adj;\\n        for(vector<string>& t: tickets)\\n            // Add each destination to the multiset connected to its source airport\\n            adj[t[0]].insert(t[1]);\\n        \\n        // Initialize the result vector\\n        vector<string> result;\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        reverse(result.begin(), result.end());\\n        // Return the itinerary\\n        return result;\\n    }\\n};\\n\\n```\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    private void dfs(Map<String, PriorityQueue<String>> adj, List<String> result, String s) {\\n        // Check if the airport exists in the adjacency list\\n        if (adj.containsKey(s)) {\\n            // While there are destinations connected to the current airport\\n            while (!adj.get(s).isEmpty()) {\\n                // Get the next destination\\n                String v = adj.get(s).poll();\\n                // Recursively explore this destination\\n                dfs(adj, result, v);\\n            }\\n        }\\n        // Add the current airport to the result\\n        result.add(s);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        // Create an adjacency list to represent the flights\\n        Map<String, PriorityQueue<String>> adj = new HashMap<>();\\n        for (List<String> t : tickets) {\\n            adj.computeIfAbsent(t.get(0), k -> new PriorityQueue<>()).offer(t.get(1));\\n        }\\n\\n        // Initialize the result list\\n        List<String> result = new ArrayList<>();\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        Collections.reverse(result);\\n        // Return the itinerary\\n        return result;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    // Depth-first search function to find the itinerary\\n    dfs(adj, result, s) {\\n        // While there are destinations connected to the current airport\\n        while (adj[s].size) {\\n            // Get the next destination\\n            let v = adj[s].values().next().value;\\n            // Remove this destination from the list\\n            adj[s].delete(v);\\n            // Recursively explore this destination\\n            this.dfs(adj, result, v);\\n        }\\n        // Add the current airport to the result\\n        result.push(s);\\n    }\\n\\n    findItinerary(tickets) {\\n        // Create an adjacency list to represent the flights\\n        const adj = new Map();\\n        for (const t of tickets) {\\n            if (!adj.has(t[0])) {\\n                adj.set(t[0], new Set());\\n            }\\n            adj.get(t[0]).add(t[1]);\\n        }\\n\\n        // Initialize the result array\\n        const result = [];\\n        // Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        this.dfs(adj, result, \"JFK\");\\n        // Reverse the result to get the correct itinerary\\n        result.reverse();\\n        // Return the itinerary\\n        return result;\\n    }\\n}\\n\\n```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def dfs(self, adj, result, s):\\n        if s in adj:\\n            destinations = adj[s][:]\\n            while destinations:\\n                dest = destinations[0]\\n                adj[s].pop(0)  # Remove the used ticket\\n                self.dfs(adj, result, dest)\\n                destinations = adj[s][:]\\n        result.append(s)\\n\\n    def findItinerary(self, tickets):\\n        # Create an adjacency list to represent the flights\\n        adj = defaultdict(list)\\n        for t in tickets:\\n            adj[t[0]].append(t[1])\\n        \\n        # Sort the destinations in lexicographical order to get the correct itinerary\\n        for key in adj:\\n            adj[key].sort()\\n\\n        # Initialize the result list\\n        result = []\\n        # Start the depth-first search from JFK (John F. Kennedy International Airport)\\n        self.dfs(adj, result, \"JFK\")\\n        # Reverse the result to get the correct itinerary\\n        result.reverse()\\n\\n        # Check if all tickets have been used\\n        total_tickets = len(tickets) + 1  # Plus one for the starting airport JFK\\n        if len(result) != total_tickets:\\n            return []\\n\\n        # Return the itinerary\\n        return result\\n\\n```\n```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n\\t\"sort\"\\n)\\n\\ntype Solution struct{}\\n\\n// Depth-first search function to find the itinerary\\nfunc (s Solution) dfs(adj map[string]*PriorityQueue, result *[]string, s string) {\\n\\t// While there are destinations connected to the current airport\\n\\tfor adj[s].Len() > 0 {\\n\\t\\t// Get the next destination\\n\\t\\tv := heap.Pop(adj[s]).(string)\\n\\t\\t// Recursively explore this destination\\n\\t\\ts.dfs(adj, result, v)\\n\\t}\\n\\t// Add the current airport to the result\\n\\t*result = append(*result, s)\\n}\\n\\n// Main function to find the itinerary\\nfunc (s Solution) findItinerary(tickets [][]string) []string {\\n\\t// Create an adjacency list to represent the flights\\n\\tadj := make(map[string]*PriorityQueue)\\n\\tfor _, t := range tickets {\\n\\t\\tsrc, dest := t[0], t[1]\\n\\t\\tif _, ok := adj[src]; !ok {\\n\\t\\t\\tadj[src] = &PriorityQueue{}\\n\\t\\t\\theap.Init(adj[src])\\n\\t\\t}\\n\\t\\theap.Push(adj[src], dest)\\n\\t}\\n\\n\\t// Initialize the result slice\\n\\tvar result []string\\n\\t// Start the depth-first search from JFK (John F. Kennedy International Airport)\\n\\ts.dfs(adj, &result, \"JFK\")\\n\\t// Reverse the result to get the correct itinerary\\n\\tsort.Sort(sort.Reverse(sort.StringSlice(result)))\\n\\t// Return the itinerary\\n\\treturn result\\n}\\n\\n// PriorityQueue is a simple priority queue implemented using a slice\\ntype PriorityQueue []string\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i] < pq[j] }\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\t*pq = append(*pq, x.(string))\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729185,
                "title": "easy-c-solution-dfs-backtracking-explained",
                "content": "```\\nclass Solution {\\n    //using multiset instead of set because values maybe repeated. Also set/ multiset is sorted so it gets sorted in lexical order itself\\n    unordered_map <string, multiset <string>> maptickets;       \\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (vector <string> t: tickets)     //building graph\\n            maptickets[t[0]].insert(t[1]); \\n        \\n        vector <string> result;\\n        dfs (result, \"JFK\");                 //starting from JFK\\n        reverse (result.begin(), result.end());//result is created during return time of recursion thus reverse needed\\n        return result;                       //returning result\\n    }\\n    \\n    void dfs (vector <string> &result, string source) {\\n        while (!maptickets[source].empty()) {\\n            string dest = *maptickets[source].begin();     //declaring iterator for finding dest\\n            maptickets[source].erase (maptickets[source].begin());  //deleting after travelling\\n            dfs (result, dest);                                  \\n        }\\n        result.push_back(source);                                   //pushing into result\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    //using multiset instead of set because values maybe repeated. Also set/ multiset is sorted so it gets sorted in lexical order itself\\n    unordered_map <string, multiset <string>> maptickets;       \\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (vector <string> t: tickets)     //building graph\\n            maptickets[t[0]].insert(t[1]); \\n        \\n        vector <string> result;\\n        dfs (result, \"JFK\");                 //starting from JFK\\n        reverse (result.begin(), result.end());//result is created during return time of recursion thus reverse needed\\n        return result;                       //returning result\\n    }\\n    \\n    void dfs (vector <string> &result, string source) {\\n        while (!maptickets[source].empty()) {\\n            string dest = *maptickets[source].begin();     //declaring iterator for finding dest\\n            maptickets[source].erase (maptickets[source].begin());  //deleting after travelling\\n            dfs (result, dest);                                  \\n        }\\n        result.push_back(source);                                   //pushing into result\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709877,
                "title": "python3-dfs-solution",
                "content": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = {}\\n        \\n        tickets.sort(key=lambda x: x[1])\\n\\n        for u, v in tickets:\\n            if u in graph:\\n                graph[u].append(v)\\n            else:\\n                graph[u] = [v]\\n        \\n        itinerary, stack = [], [(\"JFK\")]\\n        \\n        while stack:\\n            curr = stack[-1]\\n            \\n            if curr in graph and len(graph[curr]) > 0:\\n                stack.append(graph[curr].pop(0))\\n            else:\\n                itinerary.append(stack.pop())\\n        return itinerary[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = {}\\n        \\n        tickets.sort(key=lambda x: x[1])\\n\\n        for u, v in tickets:\\n            if u in graph:\\n                graph[u].append(v)\\n            else:\\n                graph[u] = [v]\\n        \\n        itinerary, stack = [], [(\"JFK\")]\\n        \\n        while stack:\\n            curr = stack[-1]\\n            \\n            if curr in graph and len(graph[curr]) > 0:\\n                stack.append(graph[curr].pop(0))\\n            else:\\n                itinerary.append(stack.pop())\\n        return itinerary[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395765,
                "title": "java-simple-solution-with-comments",
                "content": "\\tclass Solution {\\n\\n\\t\\tHashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\t\\tList<String> res = new LinkedList<>();\\n\\n\\t\\tpublic List<String> findItinerary(List<List<String>> tickets) {\\n\\t\\t\\tfor (List<String> ticket : tickets) {\\n\\t\\t\\t\\t// map.putIfAbsent() is to put value if key does not exist, here we setup a pq if we meet the key the first time.\\n\\t\\t\\t\\tmap.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n\\t\\t\\t\\t// add the \"destination\" to pq for dfs search, in lexical order by default\\n\\t\\t\\t\\tmap.get(ticket.get(0)).offer(ticket.get(1));\\n\\t\\t\\t}\\n\\t\\t\\thelper(\"JFK\");\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic void helper(String departure) {\\n\\t\\t\\t// If destination exists. When arriving the last departure, add it to res directly\\n\\t\\t\\twhile (map.containsKey(departure) && !map.get(departure).isEmpty()) {\\n\\t\\t\\t\\t// get the next destination, departure and iterate\\n\\t\\t\\t\\thelper(map.get(departure).poll());\\n\\t\\t\\t}\\n\\t\\t\\tres.add(0, departure);\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\t\\tHashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\t\\tList<String> res = new LinkedList<>();\\n\\n\\t\\tpublic List<String> findItinerary(List<List<String>> tickets) {\\n\\t\\t\\tfor (List<String> ticket : tickets) {\\n\\t\\t\\t\\t// map.putIfAbsent() is to put value if key does not exist, here we setup a pq if we meet the key the first time.\\n\\t\\t\\t\\tmap.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n\\t\\t\\t\\t// add the \"destination\" to pq for dfs search, in lexical order by default\\n\\t\\t\\t\\tmap.get(ticket.get(0)).offer(ticket.get(1));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 78843,
                "title": "c-solution-using-dfs",
                "content": "            \\n      class Solution {\\n        public:\\n            vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n                vector<string> ans;\\n                int n = tickets.size();\\n                for(int i = 0; i < n; ++ i){\\n                    g[tickets[i].first].insert(tickets[i].second);\\n                }\\n                dfs(\"JFK\", ans, 1, n);\\n           //     puts(\" -- \");\\n                reverse(ans.begin(), ans.end());\\n                return ans;\\n            }\\n        private:\\n            void dfs(string u, vector<string> &ans, int dep, int tot){\\n                while(g[u].size()){\\n                    string v = *g[u].begin();\\n                    g[u].erase(g[u].begin());\\n                    dfs(v, ans, dep + 1, tot);\\n                }\\n                ans.push_back(u);\\n            }\\n        private:\\n        unordered_map<string, multiset<string> > g;\\n        //unordered_map<string, set<string>::iterator> vis;\\n        };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        public:\\n            vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n                vector<string> ans;\\n                int n = tickets.size();\\n                for(int i = 0; i < n; ++ i){\\n                    g[tickets[i].first].insert(tickets[i].second);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4042456,
                "title": "93-short-concise-explanation-with-visualization-dfs",
                "content": "![image.png](https://assets.leetcode.com/users/images/736fb831-a617-41b1-9741-cb1f01e8e186_1694666659.6518433.png)\\n\\n# Approach\\nWe need to find the itirenary such that it has a smallest `lexical` order.\\n\\nSo we start by making a `graph` with the help of a `map`. We do this by pushing destination `ticket[1]` city to every source `Aicket[0]` city.\\n\\nAfter this we need to `sort our destination cities in reverse order so that we visit lexically smaller destinations`.\\n\\nCreate an array of strings `itinerary` to store our answer.\\n\\nCall` dfs `function on our source, i.e `JFK airport`.\\n\\nThe `dfs` function works like this -\\n- It check if there is a destination city to current airport, if there is, it stores the city in `next` variable. We do `graph[airport].back()` so that we get the` lexically smallest destination`, this is why we sorted in reverse order since we can\\'t pop lexically smallest string from front.\\n- After choosing `next`, pop_back() the lexically smallest destination.\\n- Call` dfs` on this `next` city.\\n- After all calls are made,` push_back() `our original city `Airport`.\\n\\nAt last, we `reverse` our `itinerary` and `return` it.\\n\\n# I\\'ve explained the first test case below for better understanding-\\n\\n![image.png](https://assets.leetcode.com/users/images/2889617b-fcb4-4c82-9980-837feb7b582c_1694668292.608793.png)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(string& airport, unordered_map<string, vector<string>>& graph,vector<string>& itinerary){\\n        while(!graph[airport].empty()){\\n            string next = graph[airport].back();\\n            graph[airport].pop_back();\\n            dfs(next, graph, itinerary);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n\\n        for(auto& ticket : tickets){\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        for(auto& temp : graph){\\n            sort(temp.second.rbegin(), temp.second.rend());\\n        }\\n\\n        vector<string> itinerary;\\n        string jfk = \"JFK\";\\n        dfs(jfk, graph, itinerary);\\n\\n        reverse(itinerary.begin(), itinerary.end());\\n\\n        return itinerary;\\n        \\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        dfs(\"JFK\", graph, itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(String airport, Map<String, PriorityQueue<String>> graph, LinkedList<String> itinerary) {\\n        PriorityQueue<String> nextAirports = graph.get(airport);\\n        while (nextAirports != null && !nextAirports.isEmpty()) {\\n            dfs(nextAirports.poll(), graph, itinerary);\\n        }\\n        itinerary.addFirst(airport);\\n    }\\n}\\n```\\nJava code from @vanAmsen",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(string& airport, unordered_map<string, vector<string>>& graph,vector<string>& itinerary){\\n        while(!graph[airport].empty()){\\n            string next = graph[airport].back();\\n            graph[airport].pop_back();\\n            dfs(next, graph, itinerary);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n\\n        for(auto& ticket : tickets){\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        for(auto& temp : graph){\\n            sort(temp.second.rbegin(), temp.second.rend());\\n        }\\n\\n        vector<string> itinerary;\\n        string jfk = \"JFK\";\\n        dfs(jfk, graph, itinerary);\\n\\n        reverse(itinerary.begin(), itinerary.end());\\n\\n        return itinerary;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        \\n        LinkedList<String> itinerary = new LinkedList<>();\\n        \\n        dfs(\"JFK\", graph, itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(String airport, Map<String, PriorityQueue<String>> graph, LinkedList<String> itinerary) {\\n        PriorityQueue<String> nextAirports = graph.get(airport);\\n        while (nextAirports != null && !nextAirports.isEmpty()) {\\n            dfs(nextAirports.poll(), graph, itinerary);\\n        }\\n        itinerary.addFirst(airport);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699214,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        ## RC ##\\n        ## APPROACH : GRAPH DFS ##\\n        ## EDGE CASE : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        def dfs(city):\\n            while(len(graph[city]) > 0):\\n                dfs(graph[city].pop(0))\\n            res.insert(0, city)                  # last airport\\n            \\n        graph = collections.defaultdict(list)\\n        for u, v in (tickets):\\n            graph[u].append(v)\\n            graph[u].sort()\\n        res=[]                \\n        dfs(\"JFK\")\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        ## RC ##\\n        ## APPROACH : GRAPH DFS ##\\n        ## EDGE CASE : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        def dfs(city):\\n            while(len(graph[city]) > 0):\\n                dfs(graph[city].pop(0))\\n            res.insert(0, city)                  # last airport\\n            \\n        graph = collections.defaultdict(list)\\n        for u, v in (tickets):\\n            graph[u].append(v)\\n            graph[u].sort()\\n        res=[]                \\n        dfs(\"JFK\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424365,
                "title": "python-topological-sort",
                "content": "By looking at the question, it must be clear that all the edges have to be visited. (not unlike regular DFS where we visit every node once)\\n```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    \\n    def _DFS(self, graph, node):\\n        neighbors = graph[node]\\n        while neighbors:\\n            nei = neighbors.pop(0)\\n            self._DFS(graph, nei)\\n        self.itinerary.append(node)\\n    \\n    def _makeGraph(self, edges):\\n        graph = defaultdict(list)\\n        for e in edges:\\n            graph[e[0]].append(e[1])\\n        return graph\\n\\n    def findItinerary(self, tickets):\\n        tickets.sort(key= lambda x: x[1])\\n        graph = self._makeGraph(tickets)\\n        self.itinerary = []\\n        self._DFS(graph, \"JFK\")\\n        return self.itinerary[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    \\n    def _DFS(self, graph, node):\\n        neighbors = graph[node]\\n        while neighbors:\\n            nei = neighbors.pop(0)\\n            self._DFS(graph, nei)\\n        self.itinerary.append(node)\\n    \\n    def _makeGraph(self, edges):\\n        graph = defaultdict(list)\\n        for e in edges:\\n            graph[e[0]].append(e[1])\\n        return graph\\n\\n    def findItinerary(self, tickets):\\n        tickets.sort(key= lambda x: x[1])\\n        graph = self._makeGraph(tickets)\\n        self.itinerary = []\\n        self._DFS(graph, \"JFK\")\\n        return self.itinerary[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709951,
                "title": "cpp-bfs-topological-sort",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> graph;\\n        for (auto ticket : tickets) {\\n            graph[ticket[0]].insert(ticket[1]);\\n        }\\n        vector<string> res;\\n        stack<string> q;\\n        q.push(\"JFK\");\\n        while (!q.empty()) {\\n            auto from = q.top();\\n            if (!graph[from].size()) {\\n                res.push_back(from);\\n                q.pop();\\n            } else {\\n                auto to = graph[from].begin();\\n                q.push(*to);\\n                graph[from].erase(to);\\n            }\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> graph;\\n        for (auto ticket : tickets) {\\n            graph[ticket[0]].insert(ticket[1]);\\n        }\\n        vector<string> res;\\n        stack<string> q;\\n        q.push(\"JFK\");\\n        while (!q.empty()) {\\n            auto from = q.top();\\n            if (!graph[from].size()) {\\n                res.push_back(from);\\n                q.pop();\\n            } else {\\n                auto to = graph[from].begin();\\n                q.push(*to);\\n                graph[from].erase(to);\\n            }\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020041,
                "title": "detailed-explanation-and-easiest-solution-in-java-upvote-if-you-like-the-explanation-and-the-code",
                "content": "# Approach\\nThe approach used in this code is to find an itinerary that visits all of the destination airports in a given list of tickets using a depth-first search algorithm.\\nThe intuition behind using a depth-first search to find an itinerary is that it is a relatively simple way to explore all of the possible itineraries and return the one that visits all of the destination airports. By sorting the destination airports in lexicographic order and always choosing the destination that comes first in that order, the algorithm is able to find a valid itinerary that is lexicographically smallest.\\n# Complexity\\nThe complexity of this code depends on the size of the input, which is the list of tickets.\\n\\nThe time complexity of the findItinerary method is O(n log n) because it iterates over the list of tickets once to construct the map variable, and it sorts each list of destinations in the map using the Collections.sort method, which has a time complexity of O(n log n).\\n\\nThe time complexity of the findItenaryDFS method is O(n) because it performs a constant amount of work for each destination airport in the destination list.\\n\\nThe space complexity of both methods is O(n) because they both use a hash map and a linked list to store the input data and the result, and the size of these data structures is directly proportional to the size of the input.\\n\\n# why I have used a linked list:\\n LinkedList is used to store the lists of destination airports for each starting airport in the HashMap.The LinkedList was chosen because it allows elements to be added or removed from the beginning or end of the list in constant time. This is useful in the findItenaryDFS method, where we need to efficiently remove the first destination airport from the list and perform a depth-first search starting at that airport.\\nThe LinkedList data structure is also used to store the final itinerary,This allows the final itinerary to be constructed in the correct order without the need to reverse the list at the end.\\n\\n# how do we know that the airport is only visited once:\\nIn this implementation, each destination airport is visited only once because it is removed from the list of destinations for its starting airport as soon as it is visited. This is done using the pollFirst method, which removes and returns the first element of the list.\\nFor example, when the DFS reaches \"SFO\" as the starting airport, it removes \"ATL\" from the list of destinations for \"SFO\" using pollFirst. This ensures that \"ATL\" is not visited again from \"SFO\" during the DFS.\\nThis approach ensures that each airport is visited only once because the DFS will not revisit an airport if it is not present in the list of destinations for any starting airport.\\n\\n# Code\\n```\\nclass Solution {\\n    // map: keys are starting airports and values are lists of destination airports\\n    HashMap<String, LinkedList<String>> map;\\n    // list of airports visited in order\\n    LinkedList<String> result;\\n    // given a list of tickets, returns the itinerary in the form of a list of airports visited\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        result = new LinkedList<>();\\n        map = new HashMap<>();\\n         // for each ticket, add the destination to the list of destinations for the ticket\\'s starting airport\\n        for (List<String> t : tickets) {\\n            String src = t.get(0);\\n            map.putIfAbsent(src, new LinkedList<>());\\n            map.get(src).add(t.get(1));\\n        }\\n        // sort the lists of destinations so they are in lexicographic order\\n        map.forEach((key, value) -> Collections.sort(value));\\n        // start at JFK and find the itinerary using depth-first search\\n        findItenaryDFS(\"JFK\");\\n        return result;\\n    }\\n    // finds the itinerary starting at the given airport using depth-first search\\n    public void findItenaryDFS(String start){\\n        if (map.containsKey(start)){\\n            LinkedList<String> destination = map.get(start);\\n            // for each destination, find the itinerary starting at that destination\\n            while (!destination.isEmpty()) {\\n                String des = destination.pollFirst();\\n                findItenaryDFS(des);\\n            }\\n        }\\n    // once there are no more destinations, add the current airport to the front of the result list\\n        result.offerFirst(start);\\n    }\\n}\\n\\n// findItinerary(tickets)\\n\\n// 1. Create empty result list and map\\n// 2. Add destinations to map for each ticket\\n// 3. Sort destinations for each source airport\\n// 4. Call findItenaryDFS(\"JFK\")\\n\\n// findItenaryDFS(\"JFK\")\\n\\n// 5. If JFK is in map:\\n//     6. Get destinations for JFK from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add JFK to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"ATL\")\\n\\n// 5. If ATL is in map:\\n//     6. Get destinations for ATL from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add ATL to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"SFO\")\\n\\n// 5. If SFO is in map:\\n//     6. Get destinations for SFO from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add SFO to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"SFO\") returns\\n// findItenaryDFS(\"ATL\") returns\\n// findItenaryDFS(\"JFK\") returns\\n\\n// findItinerary(tickets) returns reversed result list\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // map: keys are starting airports and values are lists of destination airports\\n    HashMap<String, LinkedList<String>> map;\\n    // list of airports visited in order\\n    LinkedList<String> result;\\n    // given a list of tickets, returns the itinerary in the form of a list of airports visited\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        result = new LinkedList<>();\\n        map = new HashMap<>();\\n         // for each ticket, add the destination to the list of destinations for the ticket\\'s starting airport\\n        for (List<String> t : tickets) {\\n            String src = t.get(0);\\n            map.putIfAbsent(src, new LinkedList<>());\\n            map.get(src).add(t.get(1));\\n        }\\n        // sort the lists of destinations so they are in lexicographic order\\n        map.forEach((key, value) -> Collections.sort(value));\\n        // start at JFK and find the itinerary using depth-first search\\n        findItenaryDFS(\"JFK\");\\n        return result;\\n    }\\n    // finds the itinerary starting at the given airport using depth-first search\\n    public void findItenaryDFS(String start){\\n        if (map.containsKey(start)){\\n            LinkedList<String> destination = map.get(start);\\n            // for each destination, find the itinerary starting at that destination\\n            while (!destination.isEmpty()) {\\n                String des = destination.pollFirst();\\n                findItenaryDFS(des);\\n            }\\n        }\\n    // once there are no more destinations, add the current airport to the front of the result list\\n        result.offerFirst(start);\\n    }\\n}\\n\\n// findItinerary(tickets)\\n\\n// 1. Create empty result list and map\\n// 2. Add destinations to map for each ticket\\n// 3. Sort destinations for each source airport\\n// 4. Call findItenaryDFS(\"JFK\")\\n\\n// findItenaryDFS(\"JFK\")\\n\\n// 5. If JFK is in map:\\n//     6. Get destinations for JFK from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add JFK to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"ATL\")\\n\\n// 5. If ATL is in map:\\n//     6. Get destinations for ATL from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add ATL to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"SFO\")\\n\\n// 5. If SFO is in map:\\n//     6. Get destinations for SFO from map\\n//     7. While destinations is not empty:\\n//         8. Remove first destination from list\\n//         9. Call findItenaryDFS(first destination)\\n// 10. Add SFO to front of result list\\n// 11. Return\\n\\n// findItenaryDFS(\"SFO\") returns\\n// findItenaryDFS(\"ATL\") returns\\n// findItenaryDFS(\"JFK\") returns\\n\\n// findItinerary(tickets) returns reversed result list\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897615,
                "title": "c-dfs-euler-walk-o-e-log-e-solution",
                "content": "Runtime: 44 ms, faster than 68.22% of C++ online submissions for Reconstruct Itinerary.\\nMemory Usage: 15 MB, less than 5.01% of C++ online submissions for Reconstruct Itinerary.\\n\\nReconstruct Itinerary solution comes from Euler walk (visit each edge only once) where we choose edge\\nwhose destination node is lexicographically smaller. Push node in to result vector while all its edges are\\nalready visited which insures that lexical smaller nodes are inserted first in to result vector. \\nFinally our itenary order will be the reverse of the result vector as node that finished\\nfirst are inserted first in the result vector and it is lexically smaller.\\n    \\n```\\nExample: [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]] \\n\\nSimulation of DFS Euler Walk for above graph is shown below,\\n\\nBlack edges are unvisited\\nGreen edges are visited \\nBrown edges are backtrack edge\\n\\nRed nodes are backtrack nodes (all edges visited) which are pushed in to stack.\\n\\nItinerary : [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/93deb98f-7e38-4af8-9e82-b1d14e9898f7_1602878480.6458232.png)\\n\\n![image](https://assets.leetcode.com/users/images/8c4e63d6-23f2-4c20-b80e-a87666374c3a_1602878491.4597306.png)\\n\\n\\n```\\n// comparator for sorting tickets based on destination\\nbool comparator(const vector<string>&a,const vector<string>&b)\\n{\\n    return a[1]<b[1];        \\n}\\n\\nclass Solution {\\npublic:\\n\\n    // itenary list\\n    vector<string>result;\\n    \\n    void dfs(string node, map<string,queue<string>>&graph)\\n    {\\n        // process node\\'s edges \\n        if(graph.count(node))\\n        {\\n            // If node has any edge call DFS with the edge destination node\\n            // also remove the edge as we will not visit the edge again (Euler walk)\\n            while(!graph[node].empty())\\n            {\\n                string child = graph[node].front();\\n                graph[node].pop();\\n                dfs(child,graph);\\n            }  \\n        }\\n        \\n        // push node in to result when all its edges are processed\\n        result.push_back(node);        \\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        // sort tickets based on destination to get lexical smaller desitantion edge first\\n        sort(tickets.begin(),tickets.end(),comparator);\\n        \\n        // graph adjacency list\\n        map<string,queue<string>>graph;\\n\\n        // populate graph adjacency list\\n        for(int i=0;i<tickets.size();i++)      \\n            graph[tickets[i][0]].push(tickets[i][1]);\\n        \\n        // run DFS starting from JFK\\n        dfs(\"JFK\",graph);\\n        \\n        // reverse result vector to get itenary list order\\n        reverse(result.begin(),result.end());\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nExample: [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]] \\n\\nSimulation of DFS Euler Walk for above graph is shown below,\\n\\nBlack edges are unvisited\\nGreen edges are visited \\nBrown edges are backtrack edge\\n\\nRed nodes are backtrack nodes (all edges visited) which are pushed in to stack.\\n\\nItinerary : [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\\n```\n```\\n// comparator for sorting tickets based on destination\\nbool comparator(const vector<string>&a,const vector<string>&b)\\n{\\n    return a[1]<b[1];        \\n}\\n\\nclass Solution {\\npublic:\\n\\n    // itenary list\\n    vector<string>result;\\n    \\n    void dfs(string node, map<string,queue<string>>&graph)\\n    {\\n        // process node\\'s edges \\n        if(graph.count(node))\\n        {\\n            // If node has any edge call DFS with the edge destination node\\n            // also remove the edge as we will not visit the edge again (Euler walk)\\n            while(!graph[node].empty())\\n            {\\n                string child = graph[node].front();\\n                graph[node].pop();\\n                dfs(child,graph);\\n            }  \\n        }\\n        \\n        // push node in to result when all its edges are processed\\n        result.push_back(node);        \\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        // sort tickets based on destination to get lexical smaller desitantion edge first\\n        sort(tickets.begin(),tickets.end(),comparator);\\n        \\n        // graph adjacency list\\n        map<string,queue<string>>graph;\\n\\n        // populate graph adjacency list\\n        for(int i=0;i<tickets.size();i++)      \\n            graph[tickets[i][0]].push(tickets[i][1]);\\n        \\n        // run DFS starting from JFK\\n        dfs(\"JFK\",graph);\\n        \\n        // reverse result vector to get itenary list order\\n        reverse(result.begin(),result.end());\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587548,
                "title": "dfs-priority-queue-concise",
                "content": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        LinkedList<String> result = new LinkedList<>();\\n        Map<String, PriorityQueue<String>> graph = buildGraph(tickets);\\n        dfs(result, graph, \"JFK\");\\n        return result;\\n    }\\n    \\n    void dfs(LinkedList<String> result, Map<String, PriorityQueue<String>> graph, String from) {\\n        PriorityQueue<String> destinations = graph.getOrDefault(from, new PriorityQueue<>());\\n        \\n        while (!destinations.isEmpty()) {\\n            String to = destinations.poll();\\n            dfs(result, graph, to);\\n        }\\n        \\n        result.addFirst(from);\\n    }\\n    \\n    Map<String, PriorityQueue<String>> buildGraph(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> result = new HashMap<>();\\n        \\n        for (List<String> path : tickets) {\\n            String from = path.get(0);\\n            String to   = path.get(1); \\n            \\n            result.putIfAbsent(from, new PriorityQueue<>());\\n            \\n            result.get(from).offer(to);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        LinkedList<String> result = new LinkedList<>();\\n        Map<String, PriorityQueue<String>> graph = buildGraph(tickets);\\n        dfs(result, graph, \"JFK\");\\n        return result;\\n    }\\n    \\n    void dfs(LinkedList<String> result, Map<String, PriorityQueue<String>> graph, String from) {\\n        PriorityQueue<String> destinations = graph.getOrDefault(from, new PriorityQueue<>());\\n        \\n        while (!destinations.isEmpty()) {\\n            String to = destinations.poll();\\n            dfs(result, graph, to);\\n        }\\n        \\n        result.addFirst(from);\\n    }\\n    \\n    Map<String, PriorityQueue<String>> buildGraph(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> result = new HashMap<>();\\n        \\n        for (List<String> path : tickets) {\\n            String from = path.get(0);\\n            String to   = path.get(1); \\n            \\n            result.putIfAbsent(from, new PriorityQueue<>());\\n            \\n            result.get(from).offer(to);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78780,
                "title": "java-stack-solution-hierholzer-u2019s-algorithm",
                "content": "[Here](http://www.graph-magics.com/articles/euler.php)'s the details of finding Euler path using Hierholzer\\u2019s Algorithm. I implemented it in Java. \\n\\nThe main steps are as follows.\\n\\n1. Start with an empty stack and an empty circuit (eulerian path).\\n   - If all vertices have same out-degrees as in-degrees - choose any of them.\\n   - If all but 2 vertices have same out-degree as in-degree, and one of those 2 vertices has out-degree with one greater than its in-degree, and the other has in-degree with one greater than its out-degree - then choose the vertex that has its out-degree with one greater than its in-degree.\\n   - Otherwise no euler circuit or path exists.\\n\\n2. If current vertex has no out-going edges (i.e. neighbors) - add it to circuit, remove the last vertex from the stack and set it as the current one. Otherwise (in case it has out-going edges, i.e. neighbors) - add the vertex to the stack, take any of its neighbors, remove the edge between that vertex and selected neighbor, and set that neighbor as the current vertex.\\n\\n3. Repeat step 2 until the current vertex has no more out-going edges (neighbors) and the stack is empty.\\nNote that obtained circuit will be in reverse order - from end vertex to start vertex.\\n\\nCode:\\n```\\npublic class Solution {\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, PriorityQueue<String>> map = new HashMap<>();\\n        LinkedList<String> route = new LinkedList<>();\\n        Stack<String> stack = new Stack<>();\\n        \\n        for (String[] t : tickets) {\\n            map.putIfAbsent(t[0], new PriorityQueue<>());\\n            map.putIfAbsent(t[1], new PriorityQueue<>()); //construct a queue for every node (even those without neighbors)\\n            map.get(t[0]).add(t[1]);\\n        }\\n        \\n        String cur = \"JFK\";\\n        while (map.get(cur).size() != 0 || !stack.isEmpty()){\\n            if (map.get(cur).size() == 0){\\n                route.add(cur);\\n                cur = stack.pop();\\n            } else {\\n                stack.add(cur);\\n                cur = map.get(cur).poll();\\n            }\\n        }\\n        route.add(cur);\\n        Collections.reverse(route);\\n        return route;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, PriorityQueue<String>> map = new HashMap<>();\\n        LinkedList<String> route = new LinkedList<>();\\n        Stack<String> stack = new Stack<>();\\n        \\n        for (String[] t : tickets) {\\n            map.putIfAbsent(t[0], new PriorityQueue<>());\\n            map.putIfAbsent(t[1], new PriorityQueue<>()); //construct a queue for every node (even those without neighbors)\\n            map.get(t[0]).add(t[1]);\\n        }\\n        \\n        String cur = \"JFK\";\\n        while (map.get(cur).size() != 0 || !stack.isEmpty()){\\n            if (map.get(cur).size() == 0){\\n                route.add(cur);\\n                cur = stack.pop();\\n            } else {\\n                stack.add(cur);\\n                cur = map.get(cur).poll();\\n            }\\n        }\\n        route.add(cur);\\n        Collections.reverse(route);\\n        return route;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78851,
                "title": "two-java-solution-dfs-stack-backtrace-recursion-very-easy-to-understand",
                "content": "I have used two method to solve this problem, the first one is a DFS using stack, the second one is backtrace. The backtrace one only uses 14ms, and the one with stack used 25ms. Personally, I prefer to use backtrace methods, because it is easy to understand, and it kind of has a \"template\" which you can apply to almost all backtrace problems.\\n\\nThis is a DFS using stack:\\n\\n    public class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            List<String> result = new ArrayList();\\n            if(tickets == null || tickets.length == 0){\\n                return result;\\n            }\\n            Map<String, ArrayList<String>> graph = new HashMap();\\n        \\n            for(int i=0; i<tickets.length; i++){\\n                if(!graph.containsKey(tickets[i][0])){\\n                    ArrayList<String> adj = new ArrayList();\\n                    adj.add(tickets[i][1]);\\n                    graph.put(tickets[i][0], adj);\\n                }else{\\n                    ArrayList<String> newadj = graph.get(tickets[i][0]);\\n                    newadj.add(tickets[i][1]);\\n                    graph.put(tickets[i][0], newadj);\\n                }\\n            }\\n            for(ArrayList<String> a : graph.values()){\\n                Collections.sort(a);\\n            }\\n            \\n            Stack<String> stack = new Stack();\\n            stack.push(\"JFK\");\\n            \\n            while(!stack.isEmpty()){\\n                \\n                while(graph.containsKey(stack.peek()) && !graph.get(stack.peek()).isEmpty()){\\n                    stack.push(graph.get(stack.peek()).remove(0));\\n                }\\n                result.add(0,stack.pop());\\n            }\\n            return result;\\n        }\\n    }\\n\\nThis one is a backtrace method with recursion:\\n\\n    public class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            List<String> result = new ArrayList();\\n            if(tickets == null || tickets.length == 0){\\n                return result;\\n            }\\n            \\n            Map<String, ArrayList<String>> graph = new HashMap();\\n            for(int i=0; i<tickets.length; i++){\\n                if(!graph.containsKey(tickets[i][0])){\\n                    ArrayList<String> adj = new ArrayList();\\n                    adj.add(tickets[i][1]);\\n                    graph.put(tickets[i][0], adj);\\n                }else{\\n                    ArrayList<String> newadj = graph.get(tickets[i][0]);\\n                    newadj.add(tickets[i][1]);\\n                    graph.put(tickets[i][0], newadj);\\n                }\\n            }\\n            \\n            for(ArrayList<String> a : graph.values()){\\n                Collections.sort(a);\\n            }\\n            \\n            backtracing(result, \"JFK\", graph);\\n            \\n            return result;\\n        }\\n        \\n        public void backtracing(List<String> result, String current, Map<String, ArrayList<String>> graph){\\n            while(graph.containsKey(current) && !graph.get(current).isEmpty()){\\n                String s = graph.get(current).remove(0);\\n                backtracing(result, s, graph);\\n            }\\n            result.add(0,current);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            List<String> result = new ArrayList();\\n            if(tickets == null || tickets.length == 0){\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 838099,
                "title": "javascript-dfs-easy-solution-beats-98",
                "content": "```\\nvar findItinerary = function(tickets) {\\n    let result = [];\\n    let adjacencyList = {};\\n    \\n    //CREATING ADJACENCY LIST\\n    tickets.forEach(ticket => {\\n        if (!adjacencyList[ticket[0]]) {\\n            adjacencyList[ticket[0]] = []\\n        }\\n        adjacencyList[ticket[0]].push(ticket[1])\\n    })\\n    \\n    //SORTING LEXOGRAPHICALLY\\n    for (let ticket in adjacencyList) {\\n        adjacencyList[ticket].sort()\\n    }\\n    \\n    //DFS AND BACKTRACKING\\n    function dfs(ticket){\\n        let destination = adjacencyList[ticket] \\n        while(destination && destination.length){\\n            dfs(destination.shift())\\n        }\\n        result.push(ticket)\\n    }\\n    dfs(\"JFK\")\\n    return result.reverse();\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar findItinerary = function(tickets) {\\n    let result = [];\\n    let adjacencyList = {};\\n    \\n    //CREATING ADJACENCY LIST\\n    tickets.forEach(ticket => {\\n        if (!adjacencyList[ticket[0]]) {\\n            adjacencyList[ticket[0]] = []\\n        }\\n        adjacencyList[ticket[0]].push(ticket[1])\\n    })\\n    \\n    //SORTING LEXOGRAPHICALLY\\n    for (let ticket in adjacencyList) {\\n        adjacencyList[ticket].sort()\\n    }\\n    \\n    //DFS AND BACKTRACKING\\n    function dfs(ticket){\\n        let destination = adjacencyList[ticket] \\n        while(destination && destination.length){\\n            dfs(destination.shift())\\n        }\\n        result.push(ticket)\\n    }\\n    dfs(\"JFK\")\\n    return result.reverse();\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4042826,
                "title": "c-priority-queue-multiset-dfs-variant-for-hierholzer-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n Solve Eulerian path problem using hash table & priority queue/multiset by DFS. \\n\\nThe method is a variant for Hierholzer\\u2019s algorithm whose standard version solves the following problem:\\n[Leetcode 2097. Valid Arrangement of Pairs](https://leetcode.com/problems/valid-arrangement-of-pairs/solutions/4044209/c-euler-path-dfs-beats-94-74/)\\n\\nThat\\'s Euler\\'s path problem, probably for finding path passing every edge once and only once. There exists an Eulerian path $\\\\iff$\\nThe initial $v_0$ must have $indeg(v_0)+1=outdeg(v_0)$ or $indeg(v_0)=outdeg(v_0)$ (if an Euler cycle) the terminal vertex $v_{n-1}$ has $indeg(v_{n-1})=outdeg(v_{n-1})+1$ or $indeg(v_{n-1})=outdeg(v_{n-1})$ (if an Euler cycle $v_0=v_{n-1}$)\\nFor other vertex $v_i$ has $indeg(v_i)=outdeg(v_i)$\\n\\n# K\\xF6nigsberg  7 bridges problem\\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)\\nFor undirected graph the equivilant condition for the existence of an Eulerian cycle is changed to: Every vertex $v$ has $\\\\deg(v)=0\\\\pmod{0}$. It is surely the graph for K\\xF6nigsberg  7 bridges problem does not satisfy this condition. Neither Eulerian cycle nor Eulerian path does have the graph for K\\xF6nigsberg  7 bridges problem!!!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLC wants the answer following the rule: \"If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\"\\n\\nTherefore, sorting cannot be avoided. Instead of applying sort, the priority queues( MinHeaps )or multisets are used.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n \\\\log k)$$ where k=max(outdegree)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>   \\n    fly; // fly[From] is a MinHeap\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].push(To);\\n        }\\n    }\\n    vector<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            string To=fly[From].top();\\n            fly[From].pop();\\n            dfs(To);\\n        }\\n        ans.push_back(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n# Code using deque for ans\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>   \\n    fly; // fly[From] is a MinHeap\\n    //unordered_map<string, int> indeg, outdeg;\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].push(To);\\n        }\\n    }\\n    deque<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            string To=fly[From].top();\\n            fly[From].pop();\\n            dfs(To);\\n        }\\n        ans.push_front(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        return vector<string>(ans.begin(), ans.end());\\n    }\\n};\\n```\\n# Code using multiset\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, multiset<string>>   \\n    fly; // fly[From] is a MinHeap\\n    //unordered_map<string, int> indeg, outdeg;\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].insert(To);\\n        }\\n    }\\n    deque<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            auto it=fly[From].begin();\\n            string To=*it;\\n            fly[From].erase(it);\\n            dfs(To);\\n        }\\n        ans.push_front(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        return vector<string>(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>   \\n    fly; // fly[From] is a MinHeap\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].push(To);\\n        }\\n    }\\n    vector<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            string To=fly[From].top();\\n            fly[From].pop();\\n            dfs(To);\\n        }\\n        ans.push_back(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>   \\n    fly; // fly[From] is a MinHeap\\n    //unordered_map<string, int> indeg, outdeg;\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].push(To);\\n        }\\n    }\\n    deque<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            string To=fly[From].top();\\n            fly[From].pop();\\n            dfs(To);\\n        }\\n        ans.push_front(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        return vector<string>(ans.begin(), ans.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, multiset<string>>   \\n    fly; // fly[From] is a MinHeap\\n    //unordered_map<string, int> indeg, outdeg;\\n    void build_graph(vector<vector<string>>& tickets){\\n        for(auto& edge: tickets){\\n            string From=edge[0], To=edge[1];\\n            fly[From].insert(To);\\n        }\\n    }\\n    deque<string> ans;\\n    void dfs(string From){\\n        while(!fly[From].empty()){\\n            auto it=fly[From].begin();\\n            string To=*it;\\n            fly[From].erase(it);\\n            dfs(To);\\n        }\\n        ans.push_front(From);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        build_graph(tickets);\\n        dfs(\"JFK\");\\n        return vector<string>(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473415,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using DFS && Backtracking***\\n\\n* ***Time Complexity :- O(N * N * logN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    // adjacency list\\n    \\n    unordered_map<string, multiset<string>> mp;\\n    \\n    bool dfs(string u, int n)\\n    {\\n        // if we have traversed all the edges, then return 1\\n        \\n        if(res.size() == n + 1)\\n            return true;\\n        \\n        // if if there is no. adjacent of curr node, then return false\\n        \\n        if(mp[u].size() == 0)\\n            return false;\\n        \\n        multiset<string> s = mp[u];\\n        \\n        // check for all the adjacents of curr node\\n       \\n        for(auto v : s)\\n        {   \\n            // find the address of adjacent node\\n            \\n            auto it = mp[u].find(v);\\n            \\n            // erase the adjacent node\\n            \\n            mp[u].erase(it);\\n            \\n            // push the adjacent node into res\\n            \\n            res.push_back(v);\\n            \\n            // if the curr path lead to result then return true\\n            \\n            if(dfs(v, n))\\n                return true;\\n            \\n            // else backtrack\\n            \\n            else\\n            {\\n                res.pop_back();\\n                \\n                mp[u].insert(v);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        int n = tickets.size();\\n        \\n        // make adjacency list\\n       \\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            string u = tickets[i][0];\\n            \\n            string v = tickets[i][1];\\n            \\n            mp[u].insert(v);\\n        }\\n        \\n        // push the initial value\\n        \\n        res.push_back(\"JFK\");\\n        \\n        dfs(\"JFK\", n);\\n       \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    // adjacency list\\n    \\n    unordered_map<string, multiset<string>> mp;\\n    \\n    bool dfs(string u, int n)\\n    {\\n        // if we have traversed all the edges, then return 1\\n        \\n        if(res.size() == n + 1)\\n            return true;\\n        \\n        // if if there is no. adjacent of curr node, then return false\\n        \\n        if(mp[u].size() == 0)\\n            return false;\\n        \\n        multiset<string> s = mp[u];\\n        \\n        // check for all the adjacents of curr node\\n       \\n        for(auto v : s)\\n        {   \\n            // find the address of adjacent node\\n            \\n            auto it = mp[u].find(v);\\n            \\n            // erase the adjacent node\\n            \\n            mp[u].erase(it);\\n            \\n            // push the adjacent node into res\\n            \\n            res.push_back(v);\\n            \\n            // if the curr path lead to result then return true\\n            \\n            if(dfs(v, n))\\n                return true;\\n            \\n            // else backtrack\\n            \\n            else\\n            {\\n                res.pop_back();\\n                \\n                mp[u].insert(v);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        int n = tickets.size();\\n        \\n        // make adjacency list\\n       \\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            string u = tickets[i][0];\\n            \\n            string v = tickets[i][1];\\n            \\n            mp[u].insert(v);\\n        }\\n        \\n        // push the initial value\\n        \\n        res.push_back(\"JFK\");\\n        \\n        dfs(\"JFK\", n);\\n       \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597192,
                "title": "python-simple-faster-98",
                "content": "```\\nclass Solution(object):\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        graph = defaultdict(list)\\n        \\n        for src, dest in tickets:\\n            graph[src].append(dest)\\n        \\n        for key in graph:\\n            graph[key].sort(reverse = True)\\n            \\n        ans = []\\n        \\n        def dfs(node):\\n            \\n            while graph[node]:\\n                dfs(graph[node].pop())\\n            \\n            ans.append(node)\\n        \\n        dfs(\"JFK\")\\n        return ans[::-1]\\n                \\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        graph = defaultdict(list)\\n        \\n        for src, dest in tickets:\\n            graph[src].append(dest)\\n        \\n        for key in graph:\\n            graph[key].sort(reverse = True)\\n            \\n        ans = []\\n        \\n        def dfs(node):\\n            \\n            while graph[node]:\\n                dfs(graph[node].pop())\\n            \\n            ans.append(node)\\n        \\n        dfs(\"JFK\")\\n        return ans[::-1]\\n                \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 297787,
                "title": "java-topological-sort",
                "content": "```\\nprivate static final String INITIAL_AIRPORT = \"JFK\";\\n\\n  public List<String> findItinerary(List<List<String>> tickets) {\\n    if (tickets == null || tickets.size() == 0)\\n      return new ArrayList<>();\\n    Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n    for (List<String> ticket : tickets) {\\n      graph.putIfAbsent(ticket.get(0), new PriorityQueue<>(String::compareTo));\\n      graph.get(ticket.get(0)).add(ticket.get(1));\\n    }\\n\\n    LinkedList<String> result = new LinkedList<>();\\n    topologicalSort(INITIAL_AIRPORT, graph, result);\\n\\n    return result;\\n  }\\n\\n  private void topologicalSort(String vertex, Map<String, PriorityQueue<String>> graph, LinkedList<String> result) {\\n    PriorityQueue<String> queue = graph.get(vertex);\\n    while (queue != null && !queue.isEmpty()) {\\n      String adj = queue.poll();\\n      topologicalSort(adj, graph, result);\\n\\n    }\\n    result.addFirst(vertex);\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate static final String INITIAL_AIRPORT = \"JFK\";\\n\\n  public List<String> findItinerary(List<List<String>> tickets) {\\n    if (tickets == null || tickets.size() == 0)\\n      return new ArrayList<>();\\n    Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n    for (List<String> ticket : tickets) {\\n      graph.putIfAbsent(ticket.get(0), new PriorityQueue<>(String::compareTo));\\n      graph.get(ticket.get(0)).add(ticket.get(1));\\n    }\\n\\n    LinkedList<String> result = new LinkedList<>();\\n    topologicalSort(INITIAL_AIRPORT, graph, result);\\n\\n    return result;\\n  }\\n\\n  private void topologicalSort(String vertex, Map<String, PriorityQueue<String>> graph, LinkedList<String> result) {\\n    PriorityQueue<String> queue = graph.get(vertex);\\n    while (queue != null && !queue.isEmpty()) {\\n      String adj = queue.poll();\\n      topologicalSort(adj, graph, result);\\n\\n    }\\n    result.addFirst(vertex);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 78830,
                "title": "10-ms-short-java-solution-using-dfs-topological-sort-beats-96-well-explained",
                "content": "         /**\\n             * When you run random custom test cases in editor you will get to know that they require a topological sort to be done on the input.\\n             * For ex feeding [[\"JFK\",NRT],[\"JFK\",KUL]] returns [\"JFK\",\"NRT\",\"KUL\"] which seems wrong as per the explanation but since input is not a valid itinerary hence the result.\\n             * This problem needs a topological sort in short. Hence do a topological sort after storing nodes in a sorted order. \\n             * Note :- \\n             **Topological sort is used only for DAGs** hence we need to *remove the edges* once it is visited. Thats why the solution uses a priority queue which sorts the nodes as well as helps in removing it in an efficient way. \\n             */\\n            public List<String> findItinerary(String[][] tickets) {\\n                LinkedList<String> result = new LinkedList<>();\\n                HashMap<String,PriorityQueue<String>> graph = new HashMap<>();\\n                for(String[] edge : tickets){\\n                    if(!graph.containsKey(edge[0]))\\n                        graph.put(edge[0],new PriorityQueue<>());\\n                    graph.get(edge[0]).offer(edge[1]);\\n                }\\n                DFS(\"JFK\",graph,result); // we need to do DFS/topological sort only from \"JFK\"\\n                return result;\\n            }\\n            /*DFS doing topological sort*/\\n            private void DFS(String node,HashMap<String,PriorityQueue<String>> graph,LinkedList<String> result ){\\n                PriorityQueue<String> nodes = graph.get(node);\\n                while(nodes!= null && !nodes.isEmpty())\\n                    DFS(nodes.poll(),graph,result);\\n                result.addFirst(node); // this is the key, instead of reversing add to the head of linkelist.\\n            }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "         /**\\n             * When you run random custom test cases in editor you will get to know that they require a topological sort to be done on the input.\\n             * For ex feeding [[\"JFK\",NRT],[\"JFK\",KUL]] returns [\"JFK\",\"NRT\",\"KUL\"] which seems wrong as per the explanation but since input is not a valid itinerary hence the result.\\n             * This problem needs a topological sort in short. Hence do a topological sort after storing nodes in a sorted order. \\n             * Note :- \\n             **Topological sort is used only for DAGs** hence we need to *remove the edges* once it is visited. Thats why the solution uses a priority queue which sorts the nodes as well as helps in removing it in an efficient way. \\n             */\\n            public List<String> findItinerary(String[][] tickets) {\\n                LinkedList<String> result = new LinkedList<>();\\n                HashMap<String,PriorityQueue<String>> graph = new HashMap<>();\\n                for(String[] edge : tickets){\\n                    if(!graph.containsKey(edge[0]))\\n                        graph.put(edge[0],new PriorityQueue<>());\\n                    graph.get(edge[0]).offer(edge[1]);\\n                }\\n                DFS(\"JFK\",graph,result); // we need to do DFS/topological sort only from \"JFK\"\\n                return result;\\n            }\\n            /*DFS doing topological sort*/\\n            private void DFS(String node,HashMap<String,PriorityQueue<String>> graph,LinkedList<String> result ){\\n                PriorityQueue<String> nodes = graph.get(node);\\n                while(nodes!= null && !nodes.isEmpty())\\n                    DFS(nodes.poll(),graph,result);\\n                result.addFirst(node); // this is the key, instead of reversing add to the head of linkelist.\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 78831,
                "title": "short-python-solution-dfs-backtracking",
                "content": "\\n    \\n    class Solution(object):\\n        def findItinerary(self, tickets):\\n    \\n            def build_graph(tickets):\\n                G = {}\\n                for t in tickets:\\n                    S, E = t\\n                    G[S] = G.get(S, []) + [E]\\n                for A in G:\\n                    G[A].sort(reverse=True)\\n                    G[A] = deque(G[A])\\n                return G\\n            \\n            def dfs(G, S):\\n                trip.append(S)\\n                if len(trip) == length:\\n                    return True\\n                if S in G:\\n                    n, i = len(G[S]), 0\\n                    while i < n:\\n                        A = G[S].pop()\\n                        if dfs(G, A):\\n                            return True\\n                        G[S].appendleft(A)\\n                        i += 1\\n                trip.pop()\\n                return False\\n                \\n                \\n            G = build_graph(tickets)\\n            trip, length = [], len(tickets) + 1\\n            dfs(G, \"JFK\")\\n            return trip",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution(object):\\n        def findItinerary(self, tickets):\\n    \\n            def build_graph(tickets):\\n                G = {}",
                "codeTag": "Java"
            },
            {
                "id": 2696171,
                "title": "python-3-7-lines-recursion-w-explanation-t-s-97-88",
                "content": "\\nThe problem reduces to finding the left-most leaf in level `n` (where `n  = len(tickets)`) of an *n*-ary tree. For example,\\n```\\ntickets = [[JFK,SFO],[JFK,ATL],[SFO,ATL],[ATL,JFK],[ATL,SFO]]\\n\\n           d = {JFK:[ATL,SFO], ATL:[JFK,SFO], SFO:[ATL]}\\n\\n                               ________ JFK __\\n                             /          ^     \\\\\\n             ______________ ATL __            SFO \\n            /                ^    \\\\\\n          JFK ________            SFO \\n           ^          \\\\\\n                   __ SFO \\n                  /    ^\\n              ATL __ \\n                ^     \\\\\\n                     SFO \\n                      ^        \\n#                   ```\\n    \\nThe path is [JFK,ATL,JFK,SFO,ATL,SFO].\\n\\n```\\nHere\\' the code:\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        path, d = [], defaultdict(list)\\n        for a,b in tickets: insort(d[a], b)      # build the graph; insort to return lex-smallest route\\n        \\n        def dfs(loc):                            # check for a path including each flight\\n            while d[loc]: dfs(d[loc].pop(0))     # pop off the flight\\n            path.append(loc)\\n            \\n        dfs(\"JFK\")\\n        return path[::-1]                        # Reverse the path after recursion\\n```\\n[https://leetcode.com/submissions/detail/821202317/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*), in which *N* ~ `len(tickets)`.",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ntickets = [[JFK,SFO],[JFK,ATL],[SFO,ATL],[ATL,JFK],[ATL,SFO]]\\n\\n           d = {JFK:[ATL,SFO], ATL:[JFK,SFO], SFO:[ATL]}\\n\\n                               ________ JFK __\\n                             /          ^     \\\\\\n             ______________ ATL __            SFO \\n            /                ^    \\\\\\n          JFK ________            SFO \\n           ^          \\\\\\n                   __ SFO \\n                  /    ^\\n              ATL __ \\n                ^     \\\\\\n                     SFO \\n                      ^        \\n#                   ```\n```\\nHere\\' the code:\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 709703,
                "title": "euler-path-hierholzer-s-algorithm-c",
                "content": "The problem is an example of euler path finding since we need to traverse each edge exactly once in the graph created lexicographically and since it is always guaranteed that a solution exists then Hierholzer\\'s algorithm will work. \\n\\n**Edit:** The time complexity here is O(E logE) since we require sorting the lists. A better approach would be to use heaps instead of lists and even then pushing each element one by one would require O(E logE) thus Instead we can create a heap for the individual lists using make_heap (STL) function which should reduce the time complexity to O(E).\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(string src,unordered_map<string,vector<string>>& m,vector<string>& ans){\\n        while(!m[src].empty()){\\n            string s=m[src].back();\\n            m[src].pop_back();\\n            dfs(s,m,ans);\\n        }\\n        ans.push_back(src);\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string,vector<string>> m;\\n\\t\\t// Create Graph\\n        for(auto i:tickets)\\n            m[i[0]].push_back(i[1]);\\n\\t\\t// Sorting in descending order since we will be popping elements from the end\\n        for(auto &i:m)\\n            sort(i.second.begin(),i.second.end(),greater<string>());  \\n\\n        vector<string> ans;\\n        dfs(\"JFK\",m,ans);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(string src,unordered_map<string,vector<string>>& m,vector<string>& ans){\\n        while(!m[src].empty()){\\n            string s=m[src].back();\\n            m[src].pop_back();\\n            dfs(s,m,ans);\\n        }\\n        ans.push_back(src);\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string,vector<string>> m;\\n\\t\\t// Create Graph\\n        for(auto i:tickets)\\n            m[i[0]].push_back(i[1]);\\n\\t\\t// Sorting in descending order since we will be popping elements from the end\\n        for(auto &i:m)\\n            sort(i.second.begin(),i.second.end(),greater<string>());  \\n\\n        vector<string> ans;\\n        dfs(\"JFK\",m,ans);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709699,
                "title": "python-by-dfs-and-stack-w-visualization",
                "content": "Python by DFS and stack\\n\\n---\\n\\n**Hint and abstract model**:\\n\\nThink of **DFS**, and **graph traversal** with **all edges visited exactly once**\\n\\nUse a **dictionary** with list to maintain **fly map**(i.e., **source -> destination relationship** )\\n\\n**Airport** <-> **Node**\\n\\n**Airline ticket** <-> **Edge**\\n\\n**From** airport <-> **source node** of Edge\\n\\n**To** airport <-> **destination node** of Edge\\n\\n**Itinerary begin with JFK** <-> Start **DFS from JFK**, under lexical order, with **all edges visited exactly once**.\\n\\nDuring DFS, once current airport has no available flight anymore, add current airport into traversal stack.\\n\\nFinally, the visit order of Itinerary begin with JFK is **reversed traversal stack**.\\n\\n---\\n\\n**Visualization**:\\n\\n![image](https://assets.leetcode.com/users/images/23541f63-275f-476b-bd0e-35d82af0ca6c_1593336685.563326.png)\\n\\n\\n---\\n\\n**Implementation** by DFS and stack\\n\\n```\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        \\n        # each ticket maps to one source <-> destination flight\\n        src_dest_dict = defaultdict(list)\\n        \\n        # update fly map\\n        for src, dst in tickets:    \\n            src_dest_dict[src].append(dst)\\n\\n        \\n\\t\\t# keep fly map with lexical order in minHeap\\n        for airport in src_dest_dict:\\n            heapq.heapify( src_dest_dict[airport] )\\n        \\n        # record of traversal path\\n        traverse_stack = []\\n\\n        path = [\"JFK\"]\\n\\n        def dfs(fly_map, airport):\\n\\n            while src_dest_dict[airport]:\\n                dest = heapq.heappop( src_dest_dict[airport] )\\n                dfs(fly_map, dest)\\n\\n            traverse_stack.append(airport)\\n\\n        # -------------------------------------------------------\\n        \\n        # Start traverl from JFK with all ticket used exactly once (i.e., all edges visited exactly once)\\n        dfs(fly_map=src_dest_dict, airport=\"JFK\")\\n        \\n        return [*reversed(traverse_stack)]\\n        \\n        \\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official doscs about bisect.insort( ... )](https://docs.python.org/3/library/bisect.html#bisect.insort_left)\\n\\n[2] [Python official docs about defaultdict](https://docs.python.org/3/library/collections.html?highlight=defaultdict#collections.defaultdict)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        \\n        # each ticket maps to one source <-> destination flight\\n        src_dest_dict = defaultdict(list)\\n        \\n        # update fly map\\n        for src, dst in tickets:    \\n            src_dest_dict[src].append(dst)\\n\\n        \\n\\t\\t# keep fly map with lexical order in minHeap\\n        for airport in src_dest_dict:\\n            heapq.heapify( src_dest_dict[airport] )\\n        \\n        # record of traversal path\\n        traverse_stack = []\\n\\n        path = [\"JFK\"]\\n\\n        def dfs(fly_map, airport):\\n\\n            while src_dest_dict[airport]:\\n                dest = heapq.heappop( src_dest_dict[airport] )\\n                dfs(fly_map, dest)\\n\\n            traverse_stack.append(airport)\\n\\n        # -------------------------------------------------------\\n        \\n        # Start traverl from JFK with all ticket used exactly once (i.e., all edges visited exactly once)\\n        dfs(fly_map=src_dest_dict, airport=\"JFK\")\\n        \\n        return [*reversed(traverse_stack)]\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 624915,
                "title": "c-solution-dfs",
                "content": "```\\nclass Solution {\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>hm;\\n    \\n    void dfs(string v, vector<string>& res) {\\n        \\n        while (hm[v].size() != 0) {\\n            string p = hm[v].top();\\n            hm[v].pop();\\n            dfs(p, res);\\n        }\\n        \\n        res.push_back(v);\\n    }\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        for (int i = 0; i < tickets.size(); i++) {\\n            hm[tickets[i][0]].push(tickets[i][1]);\\n        }\\n        \\n        vector<string>res;\\n        dfs(\"JFK\", res);\\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>>hm;\\n    \\n    void dfs(string v, vector<string>& res) {\\n        \\n        while (hm[v].size() != 0) {\\n            string p = hm[v].top();\\n            hm[v].pop();\\n            dfs(p, res);\\n        }\\n        \\n        res.push_back(v);\\n    }\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        for (int i = 0; i < tickets.size(); i++) {\\n            hm[tickets[i][0]].push(tickets[i][1]);\\n        }\\n        \\n        vector<string>res;\\n        dfs(\"JFK\", res);\\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256161,
                "title": "c-94-solution-o-e-time-with-explanation",
                "content": "**Idea**\\n\\nThe idea behind this solution is based on Hierholzer\\'s algorithm (Link below). Learning how the algorithm works is left as an exercise to the reader. (It is very intuitive). \\n\\nhttps://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/\\n\\nThe algorithm is designed to find an eulerian path, assuming the graph is eulerian. An eulerian path is basically a path that starts on some node and traverses across all the edges exactly once. It requires that the graph is eulerian, which for a directed graph implies that each node has an equal number of ins and outs, or exactly two nodes has an odd degree. \\n\\nThis is very similar to what we need for this problem, which is to find a way to visit all the locations. If we look at the problem, each airport must be either a transitional stop, the start, or the final destination. This corresponds to an eulerian graph with exactly two nodes with an odd degree. We must start from the starting airport, so the start cannot be even (there must be more edges leaving than entering), and we must end at the destination (must be more edges ending than leaving). All other airports must have an even degree, because we cannot stay there (must leave the same number of times we enter). Thus, this problem can be directly reduced to finding an eulerian path from the graph made from the vector of edges.\\n\\nHowever, we are given the condition that for solutions with multiple possible paths, we need to pick the one that puts the lowest by alphabetical name airports first. Thus, we need to modify the algorithm so that when it selects an edge, it selects the edge with the lowest alphabetical name first. \\n\\n**Implementation**\\n\\nThe first thing is the representation of the graph. I opted for an unordered_map because the graph is sparse. Each unordered_map uses a priority queue to keep track of the edges and returns the lowest alphabetical edge. \\n\\nFor the implementation of the algorithm, I opted to insert the elements into the current list by reverse, because if they were inserted normally I would have to start moving and deleting by reverse, and I was not able to find a good method to do that. Inserting in reverse allows me to delete and move using normal iterators, which can be done using normal erase operation.\\n\\n\\n**Runtime**\\n\\nThe run time of this algorithm is the same as that for Hierholzer\\'s algorithm, which is O(E), where E is the number of edges. In this case that would be linear to the input edge vector.\\n\\n\\n```\\nstruct cmp {\\n\\t  bool operator()(const string &lhs, const string &rhs) {\\n\\t\\treturn lhs > rhs;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    static void dfs(unordered_map<string, priority_queue<string, vector<string>, cmp>>& edges, string start, list<string>& cur) {\\n        auto it = edges.find(start);\\n        while(it != edges.end()) {\\n            string next = it->second.top(); it->second.pop();\\n            if(it->second.empty()) edges.erase(it);\\n            cur.push_front(next);\\n            it = edges.find(next);\\n        }\\n    }\\n\\n    const vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n\\t\\n        unordered_map<string, priority_queue<string, vector<string>, cmp>> edges;\\n        for(auto &edge: tickets) edges[edge.first].push(edge.second);\\n        if(edges.empty()) return {};\\n\\n        list<string> cur{\"JFK\"}, overall;\\n        string next = \"JFK\";\\n        while(!cur.empty()) {\\n            dfs(edges, next, cur);\\n            auto it = cur.begin();\\n            while(it != cur.end() && edges.find(*it) == edges.end()) {\\n                overall.push_front(*it);\\n                cur.erase(it++);\\n            }\\n            if(!cur.empty()) next = *it;\\n        }\\n        return vector<string>(overall.begin(), overall.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct cmp {\\n\\t  bool operator()(const string &lhs, const string &rhs) {\\n\\t\\treturn lhs > rhs;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    static void dfs(unordered_map<string, priority_queue<string, vector<string>, cmp>>& edges, string start, list<string>& cur) {\\n        auto it = edges.find(start);\\n        while(it != edges.end()) {\\n            string next = it->second.top(); it->second.pop();\\n            if(it->second.empty()) edges.erase(it);\\n            cur.push_front(next);\\n            it = edges.find(next);\\n        }\\n    }\\n\\n    const vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n\\t\\n        unordered_map<string, priority_queue<string, vector<string>, cmp>> edges;\\n        for(auto &edge: tickets) edges[edge.first].push(edge.second);\\n        if(edges.empty()) return {};\\n\\n        list<string> cur{\"JFK\"}, overall;\\n        string next = \"JFK\";\\n        while(!cur.empty()) {\\n            dfs(edges, next, cur);\\n            auto it = cur.begin();\\n            while(it != cur.end() && edges.find(*it) == edges.end()) {\\n                overall.push_front(*it);\\n                cur.erase(it++);\\n            }\\n            if(!cur.empty()) next = *it;\\n        }\\n        return vector<string>(overall.begin(), overall.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772331,
                "title": "c-dfs-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    bool dfs(unordered_map<string,vector<string>>& m, vector<string>& res, string s, int n) {\\n        if(res.size() == n+1) return true;\\n        if(m[s].size() == 0) return false;\\n\\n        for(int i = 0; i < m[s].size(); i++) {\\n            string temp = m[s][i];\\n            res.push_back(temp);\\n            m[s].erase(m[s].begin() + i);\\n            bool x = dfs(m, res, temp, n);\\n\\n            if(x) return true;\\n            m[s].insert(m[s].begin()+i, temp);\\n            res.pop_back();\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        int n = tickets.size();\\n        sort(tickets.begin(), tickets.end());\\n        unordered_map<string,vector<string>> m;\\n\\n        for(int i = 0; i < n; i++) {\\n            m[tickets[i][0]].push_back(tickets[i][1]);\\n        }\\n\\n        vector<string> res;\\n        res.push_back(\"JFK\");\\n        bool x = dfs(m, res, \"JFK\", n);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(unordered_map<string,vector<string>>& m, vector<string>& res, string s, int n) {\\n        if(res.size() == n+1) return true;\\n        if(m[s].size() == 0) return false;\\n\\n        for(int i = 0; i < m[s].size(); i++) {\\n            string temp = m[s][i];\\n            res.push_back(temp);\\n            m[s].erase(m[s].begin() + i);\\n            bool x = dfs(m, res, temp, n);\\n\\n            if(x) return true;\\n            m[s].insert(m[s].begin()+i, temp);\\n            res.pop_back();\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        int n = tickets.size();\\n        sort(tickets.begin(), tickets.end());\\n        unordered_map<string,vector<string>> m;\\n\\n        for(int i = 0; i < n; i++) {\\n            m[tickets[i][0]].push_back(tickets[i][1]);\\n        }\\n\\n        vector<string> res;\\n        res.push_back(\"JFK\");\\n        bool x = dfs(m, res, \"JFK\", n);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219170,
                "title": "c-euler-path-dfs-comments",
                "content": "20 ms ,14 MB\\ncopied from \\nhttps://leetcode.com/problems/reconstruct-itinerary/discuss/897615/C%2B%2B-DFS-Euler-Walk-O(E-Log-E)-Solution\\n\\n```\\n// comparator for sorting tickets based on destination\\nbool comparator(const vector<string>&a,const vector<string>&b)\\n{\\n    return a[1]<b[1];        \\n}\\n\\nclass Solution {\\npublic:\\n\\n    // itenary list\\n    vector<string>result;\\n    \\n    void dfs(string node, map<string,queue<string>>&graph)\\n    {\\n        // process node\\'s edges \\n        if(graph.count(node))\\n        {\\n            // If node has any edge call DFS with the edge destination node\\n            // also remove the edge as we will not visit the edge again (Euler walk)\\n            while(!graph[node].empty())\\n            {\\n                string child = graph[node].front();\\n                graph[node].pop();\\n                dfs(child,graph);\\n            }  \\n        }\\n        \\n        // push node in to result when all its edges are processed\\n        result.push_back(node);        \\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        // sort tickets based on destination to get lexical smaller desitantion edge first\\n        sort(tickets.begin(),tickets.end(),comparator);\\n        \\n        // graph adjacency list\\n        map<string,queue<string>>graph;\\n\\n        // populate graph adjacency list\\n        for(int i=0;i<tickets.size();i++)      \\n            graph[tickets[i][0]].push(tickets[i][1]);\\n        \\n        // run DFS starting from JFK\\n        dfs(\"JFK\",graph);\\n        \\n        // reverse result vector to get itenary list order\\n        reverse(result.begin(),result.end());\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    // itenary list\\n    vector<string>result;\\n    \\n    void dfs(string node, map<string,queue<string>>&graph)\\n    {\\n        // process node\\'s edges \\n        if(graph.count(node))\\n        {\\n            // If node has any edge call DFS with the edge destination node\\n            // also remove the edge as we will not visit the edge again (Euler walk)\\n            while(!graph[node].empty())\\n            {\\n                string child = graph[node].front();\\n                graph[node].pop();\\n                dfs(child,graph);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 989535,
                "title": "simple-python-solutions-dfs-solution-and-iterative-solution-with-stack",
                "content": "#DFS\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n\\t\\n        def _visit(stop):\\n            while flights[stop]:\\n                _visit(flights[stop].pop())\\n            result.append(stop)\\n\\t\\t\\t\\n        flights = defaultdict(list)\\n        for fr, to in sorted(tickets, reverse=True):\\n            flights[fr].append(to)\\n        result = []\\n        _visit(\"JFK\")\\n        return result[::-1]\\n\\t\\t\\n#Iterative with stack\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        flights = defaultdict(list)\\n        for t in sorted(tickets, reverse=True):\\n            flights[t[0]].append(t[1])\\n\\n        stack, result = [], []\\n        stop = \"JFK\"\\n        while stop:\\n            if not flights[stop]:\\n                result.append(stop)\\n                stop = None if not stack else stack.pop()\\n            else:\\n                stack.append(stop)\\n                stop = flights[stop].pop()\\n        return result[::-1]",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "#DFS\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n\\t\\n        def _visit(stop):\\n            while flights[stop]:\\n                _visit(flights[stop].pop())\\n            result.append(stop)\\n\\t\\t\\t\\n        flights = defaultdict(list)\\n        for fr, to in sorted(tickets, reverse=True):\\n            flights[fr].append(to)\\n        result = []\\n        _visit(\"JFK\")\\n        return result[::-1]\\n\\t\\t\\n#Iterative with stack\\n\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        flights = defaultdict(list)\\n        for t in sorted(tickets, reverse=True):\\n            flights[t[0]].append(t[1])\\n\\n        stack, result = [], []\\n        stop = \"JFK\"\\n        while stop:\\n            if not flights[stop]:\\n                result.append(stop)\\n                stop = None if not stack else stack.pop()\\n            else:\\n                stack.append(stop)\\n                stop = flights[stop].pop()\\n        return result[::-1]",
                "codeTag": "Python3"
            },
            {
                "id": 645501,
                "title": "simple-and-clean-c-solution-with-comments",
                "content": "```cpp\\nusing graph = unordered_map<string, priority_queue<string, vector<string>, greater<>>>;\\n\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        graph flights;\\n        for (const auto& ticket : tickets) {\\n            // build the graph. note there we\\'re using\\n            // a min heap so the destinations will be\\n            // sorted in lexicographical order\\n            flights[ticket[0]].emplace(ticket[1]);\\n        }\\n        vector<string> itinerary;\\n        buildItinerary(\"JFK\", &flights, &itinerary);\\n        reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\nprivate:\\n    \\n    void buildItinerary(const string& airport, graph* flights_ptr, vector<string>* itinerary_ptr) {\\n        auto& flights = *flights_ptr;\\n\\t\\t// the point that we got stuck would be the last airport that we visit\\n        while (!empty(flights[airport])) {\\n            auto destination = flights[airport].top();\\n            flights[airport].pop();\\n            buildItinerary(destination, flights_ptr, itinerary_ptr);\\n        }\\n        itinerary_ptr->emplace_back(airport);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nusing graph = unordered_map<string, priority_queue<string, vector<string>, greater<>>>;\\n\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        graph flights;\\n        for (const auto& ticket : tickets) {\\n            // build the graph. note there we\\'re using\\n            // a min heap so the destinations will be\\n            // sorted in lexicographical order\\n            flights[ticket[0]].emplace(ticket[1]);\\n        }\\n        vector<string> itinerary;\\n        buildItinerary(\"JFK\", &flights, &itinerary);\\n        reverse(itinerary.begin(), itinerary.end());\\n        return itinerary;\\n    }\\nprivate:\\n    \\n    void buildItinerary(const string& airport, graph* flights_ptr, vector<string>* itinerary_ptr) {\\n        auto& flights = *flights_ptr;\\n\\t\\t// the point that we got stuck would be the last airport that we visit\\n        while (!empty(flights[airport])) {\\n            auto destination = flights[airport].top();\\n            flights[airport].pop();\\n            buildItinerary(destination, flights_ptr, itinerary_ptr);\\n        }\\n        itinerary_ptr->emplace_back(airport);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509936,
                "title": "c-solution-find-the-eulerian-path",
                "content": "Each ticket is essentially a directed edge in our graph of airports.\\nTo reconstruct the person\\'s itinerary, we need to ensure that our path through the airports passes through all of these edges (takes all of the flights represented by tickets).\\nThis is essentially trying to find an Eulerian path in the graph, which can be solved using Hierholzer\\'s algorithm.\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<string>> graph;\\n    unordered_map<string, int> outgoing;\\n    \\n    void hierholzer(const string& curr, vector<string>& itinerary) {\\n        while (outgoing[curr] > 0) {\\n            hierholzer(graph[curr][--outgoing[curr]], itinerary);\\n        }\\n        \\n        itinerary.push_back(curr);\\n    }\\n    \\npublic:\\n    vector<string> findItinerary(const vector<vector<string>>& tickets) {\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n            ++outgoing[ticket[0]];\\n        }\\n        \\n        // Ensure smallest lexical eulerian path is found\\n        for (auto& kv : graph) {\\n            sort(kv.second.begin(), kv.second.end(), greater<string>());\\n        }\\n        \\n        vector<string> itinerary;\\n        hierholzer(\"JFK\", itinerary);\\n        \\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<string>> graph;\\n    unordered_map<string, int> outgoing;\\n    \\n    void hierholzer(const string& curr, vector<string>& itinerary) {\\n        while (outgoing[curr] > 0) {\\n            hierholzer(graph[curr][--outgoing[curr]], itinerary);\\n        }\\n        \\n        itinerary.push_back(curr);\\n    }\\n    \\npublic:\\n    vector<string> findItinerary(const vector<vector<string>>& tickets) {\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n            ++outgoing[ticket[0]];\\n        }\\n        \\n        // Ensure smallest lexical eulerian path is found\\n        for (auto& kv : graph) {\\n            sort(kv.second.begin(), kv.second.end(), greater<string>());\\n        }\\n        \\n        vector<string> itinerary;\\n        hierholzer(\"JFK\", itinerary);\\n        \\n        reverse(itinerary.begin(), itinerary.end());\\n        \\n        return itinerary;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446479,
                "title": "javascript-topological-sorting",
                "content": "```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n  const graph =  buildGraph(tickets);\\n  const ans = [];\\n  \\n  topoSorting(\"JFK\", graph, ans)\\n     \\n  return ans.reverse();\\n};\\n\\nconst topoSorting = (airport, graph, ans) => {  \\n  let stops =  graph[airport];\\n  \\n  while (stops.length) {\\n    topoSorting(stops.shift(), graph, ans);\\n  }\\n  \\n  ans.push(airport);\\n}\\n\\n\\nconst buildGraph = (tickets) => {\\n  const graph = {};\\n  \\n  tickets.forEach((it) => { \\n    graph[it[0]] = graph[it[0]] || [];\\n    graph[it[1]] = graph[it[1]] || [];\\n    \\n    graph[it[0]].push(it[1]);         \\n  });\\n  \\n  for (let key of Object.keys(graph)) {\\n    graph[key].sort();\\n  }\\n\\n  return graph;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n  const graph =  buildGraph(tickets);\\n  const ans = [];\\n  \\n  topoSorting(\"JFK\", graph, ans)\\n     \\n  return ans.reverse();\\n};\\n\\nconst topoSorting = (airport, graph, ans) => {  \\n  let stops =  graph[airport];\\n  \\n  while (stops.length) {\\n    topoSorting(stops.shift(), graph, ans);\\n  }\\n  \\n  ans.push(airport);\\n}\\n\\n\\nconst buildGraph = (tickets) => {\\n  const graph = {};\\n  \\n  tickets.forEach((it) => { \\n    graph[it[0]] = graph[it[0]] || [];\\n    graph[it[1]] = graph[it[1]] || [];\\n    \\n    graph[it[0]].push(it[1]);         \\n  });\\n  \\n  for (let key of Object.keys(graph)) {\\n    graph[key].sort();\\n  }\\n\\n  return graph;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252980,
                "title": "python-dfs-with-comments",
                "content": "```\\nclass Solution(object):\\n    def __init__(self):\\n        self.valid_length = -1\\n        \\n    def buildMap(self, tickets):\\n        # first lets put everything into a dict for easy lookup\\n        # format is start as key and [ends] as value\\n        ticket_map = {}\\n        for ticket in tickets:\\n            #print(ticket)\\n            start = ticket[0]\\n            dest = ticket[1]\\n            if not start in ticket_map:\\n                ticket_map[start] = [dest]\\n            else:\\n                ticket_map[start].append(dest)\\n                \\n        self.valid_length = len(tickets) + 1\\n        return ticket_map\\n        \\n    def findItinerary(self, tickets):\\n        \\n        if tickets == None or len(tickets) == 0:\\n            return None\\n        \\n        # First make an adjacency map out of the tickets\\n        ticket_map = self.buildMap(tickets)\\n        #print(ticket_map)\\n        \\n        # Add the root and start the DFS\\n        route = [\\'JFK\\']\\n        self.dfs(\\'JFK\\', route, ticket_map)\\n        \\n        return route\\n        \\n    def dfs(self, node, route, ticket_map):\\n        \\n        if node in ticket_map and len(ticket_map[node]) > 0:\\n            # Sort them so we\\'ll pick the first lexographic path if there are several results\\n            children = sorted(ticket_map[node])\\n\\n            for child in children:\\n                route.append(child)                \\n                \\n                # first remove this path from the map\\n                ticket_map[node].remove(child)\\n                # Now go down to the next level\\n                result = self.dfs(child, route, ticket_map)\\n                \\n                # See if the DFS on that child produced a valid result, if so return it\\n                if len(result) == self.valid_length:\\n                    return result\\n                \\n                # The DFS did not produce the result, so undo the changes and try the next child\\n                else:\\n                    del route[-1]\\n                    ticket_map[node].append(child)\\n            \\n        return route\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def __init__(self):\\n        self.valid_length = -1\\n        \\n    def buildMap(self, tickets):\\n        # first lets put everything into a dict for easy lookup\\n        # format is start as key and [ends] as value\\n        ticket_map = {}\\n        for ticket in tickets:\\n            #print(ticket)\\n            start = ticket[0]\\n            dest = ticket[1]\\n            if not start in ticket_map:\\n                ticket_map[start] = [dest]\\n            else:\\n                ticket_map[start].append(dest)\\n                \\n        self.valid_length = len(tickets) + 1\\n        return ticket_map\\n        \\n    def findItinerary(self, tickets):\\n        \\n        if tickets == None or len(tickets) == 0:\\n            return None\\n        \\n        # First make an adjacency map out of the tickets\\n        ticket_map = self.buildMap(tickets)\\n        #print(ticket_map)\\n        \\n        # Add the root and start the DFS\\n        route = [\\'JFK\\']\\n        self.dfs(\\'JFK\\', route, ticket_map)\\n        \\n        return route\\n        \\n    def dfs(self, node, route, ticket_map):\\n        \\n        if node in ticket_map and len(ticket_map[node]) > 0:\\n            # Sort them so we\\'ll pick the first lexographic path if there are several results\\n            children = sorted(ticket_map[node])\\n\\n            for child in children:\\n                route.append(child)                \\n                \\n                # first remove this path from the map\\n                ticket_map[node].remove(child)\\n                # Now go down to the next level\\n                result = self.dfs(child, route, ticket_map)\\n                \\n                # See if the DFS on that child produced a valid result, if so return it\\n                if len(result) == self.valid_length:\\n                    return result\\n                \\n                # The DFS did not produce the result, so undo the changes and try the next child\\n                else:\\n                    del route[-1]\\n                    ticket_map[node].append(child)\\n            \\n        return route\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186273,
                "title": "python3-eulerian-path",
                "content": "``` python\\nclass Solution:\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        G = collections.defaultdict(list)\\n        for u, v in tickets: G[u].append(v)\\n        for u in G: G[u].sort()        \\n        \\n        route = []\\n        def dfs(at):\\n            while G[at]:\\n                to = G[at].pop(0)\\n                dfs(to)\\n            route.append(at)\\n\\n        dfs(\"JFK\")\\n        return route[::-1]\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        G = collections.defaultdict(list)\\n        for u, v in tickets: G[u].append(v)\\n        for u in G: G[u].sort()        \\n        \\n        route = []\\n        def dfs(at):\\n            while G[at]:\\n                to = G[at].pop(0)\\n                dfs(to)\\n            route.append(at)\\n\\n        dfs(\"JFK\")\\n        return route[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78771,
                "title": "c-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>>m;\\n        vector<string>res;\\n        for(auto x: tickets) m[x.first].push(x.second);\\n        DFS(\"JFK\", res, m);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void DFS(string cur, vector<string>& res, unordered_map<string, priority_queue<string, vector<string>, greater<string>>>& m){\\n        while(!m[cur].empty()){\\n            string s = m[cur].top();\\n            m[cur].pop();\\n            DFS(s, res, m);\\n        }\\n        res.push_back(cur);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>>m;\\n        vector<string>res;\\n        for(auto x: tickets) m[x.first].push(x.second);\\n        DFS(\"JFK\", res, m);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void DFS(string cur, vector<string>& res, unordered_map<string, priority_queue<string, vector<string>, greater<string>>>& m){\\n        while(!m[cur].empty()){\\n            string s = m[cur].top();\\n            m[cur].pop();\\n            DFS(s, res, m);\\n        }\\n        res.push_back(cur);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78791,
                "title": "c-iterative-version-with-detail-comments",
                "content": "this solution will be shorter if C# has built-in priority queue library.....\\n\\nInspired by @StefanPochmann approach, basically it's his idea in C# verison. \\n\\nIt works well and can handle test cases that contains invalid itineraries. Like [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"]] .\\n\\nTime: Assume we have N itineraries, each itinerary has two string=> 2N strings. \\n\\n1. we build hashtable for all itineraries. O(N) time\\n2. we sort values string for each key. O(N* NlogN) time\\n3. we backtracking to find the next city we want, until all city has added. Since we use hashtable in the searching so it's O(N).\\n4.Convert out result linkedlist to a list, not sure if it's O(N) or O(1) in C# but can never greater than O(N).\\n\\nAdding together it\\u2019s O(N*logN) time.\\n\\nSpace: we use a hash table and a stack, so it's O(2N)=>O(N) space\\n\\n```\\n           public IList<string> FindItinerary(string[,] tickets)\\n            {\\n                LinkedList<string> res= new LinkedList<string>();\\n                //invalid input\\n                if (tickets == null || tickets.Length == 0) return res.ToList();\\n                //Build a hashtable/dict for route. \\n                //key is the source city, value are all the destination city from source city.\\n                var routeDict = new Dictionary<string, List<string>>();\\n                \\n                int count = tickets.GetLength(0);   //tickets number\\n                for (int i = 0; i < count; i++)\\n                {\\n                    var source = tickets[i, 0];\\n                    var dest = tickets[i, 1];\\n\\n                    if(!routeDict.ContainsKey(source))\\n                        routeDict.Add(source, new List<string>());\\n\\n                    routeDict[source].Add(dest);\\n                }\\n                //keep asce order \\n                foreach (var list in routeDict.Values)  list.Sort();\\n\\n                //need a stack as like a backtracking route from final.\\n                Stack<string> stack = new Stack<string>();\\n                stack.Push(\"JFK\");    //Add start city\\n                while (stack.Any())\\n                {\\n                    while (routeDict.ContainsKey(stack.Peek()) && routeDict[stack.Peek()].Any())\\n                    {\\n                        var next = routeDict[stack.Peek()].First();  //the next city from the source city in lexical order\\n                        routeDict[stack.Peek()].RemoveAt(0);         //remove the next city from the hash table.(since List<T> doesn't has Poll/Pop/Dequeue)\\n                        stack.Push(next);                            //push next city into the stack\\n                    }\\n                    res.AddFirst(stack.Pop());                      //Pop all the city from stack, Add them in the head of res.\\n                }\\n                return res.ToList();\\n            }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n           public IList<string> FindItinerary(string[,] tickets)\\n            {\\n                LinkedList<string> res= new LinkedList<string>();\\n                //invalid input\\n                if (tickets == null || tickets.Length == 0) return res.ToList();\\n                //Build a hashtable/dict for route. \\n                //key is the source city, value are all the destination city from source city.\\n                var routeDict = new Dictionary<string, List<string>>();\\n                \\n                int count = tickets.GetLength(0);   //tickets number\\n                for (int i = 0; i < count; i++)\\n                {\\n                    var source = tickets[i, 0];\\n                    var dest = tickets[i, 1];\\n\\n                    if(!routeDict.ContainsKey(source))\\n                        routeDict.Add(source, new List<string>());\\n\\n                    routeDict[source].Add(dest);\\n                }\\n                //keep asce order \\n                foreach (var list in routeDict.Values)  list.Sort();\\n\\n                //need a stack as like a backtracking route from final.\\n                Stack<string> stack = new Stack<string>();\\n                stack.Push(\"JFK\");    //Add start city\\n                while (stack.Any())\\n                {\\n                    while (routeDict.ContainsKey(stack.Peek()) && routeDict[stack.Peek()].Any())\\n                    {\\n                        var next = routeDict[stack.Peek()].First();  //the next city from the source city in lexical order\\n                        routeDict[stack.Peek()].RemoveAt(0);         //remove the next city from the hash table.(since List<T> doesn't has Poll/Pop/Dequeue)\\n                        stack.Push(next);                            //push next city into the stack\\n                    }\\n                    res.AddFirst(stack.Pop());                      //Pop all the city from stack, Add them in the head of res.\\n                }\\n                return res.ToList();\\n            }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 78811,
                "title": "sharing-my-44ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n            unordered_map<string, multiset<string>> myGraph;\\n            int i, n = tickets.size();\\n            string first, second;\\n            for(i=0; i<n; i++)\\n            {\\n                first  = tickets[i].first;\\n                second = tickets[i].second;\\n                myGraph[first].insert(second);\\n            }\\n            \\n            vector<string> marching;\\n            vector<string> itinerary;\\n            marching.push_back(\"JFK\");\\n            \\n            while(marching.size()>0)\\n            {\\n                string from = marching.back();\\n                if(myGraph.count(from)>0 && myGraph[from].size()>0)\\n                {\\n                    multiset<string>& to = myGraph[from];\\n                    marching.push_back(*to.begin());\\n                    to.erase(to.begin());\\n                }\\n                else\\n                {\\n                    itinerary.push_back(from);\\n                    marching.pop_back();\\n                }\\n            }\\n            \\n            reverse(itinerary.begin(), itinerary.end());\\n            return itinerary;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n            unordered_map<string, multiset<string>> myGraph;\\n            int i, n = tickets.size();\\n            string first, second;\\n            for(i=0; i<n; i++)\\n            {\\n                first  = tickets[i].first;\\n                second = tickets[i].second;\\n                myGraph[first].insert(second);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3244732,
                "title": "332-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe first create a heap for each source vertex, containing the destinations in lexicographical order. Then, during the DFS traversal, we pop the smallest destination from the heap instead of sorting the destinations each time. This small optimization reduces the time complexity of sorting destinations from O(NlogN) to O(NlogM), where N is the total number of tickets and M is the average number of destinations per source vertex.\\n\\n# Complexity\\n- Time complexity:\\n61.24%\\n\\n- Space complexity:\\n83.91%\\n\\n# Code\\n```\\nimport collections\\nimport heapq\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        ans = []\\n        graph = collections.defaultdict(list)\\n\\n        for a, b in tickets:\\n            graph[a].append(b)\\n\\n        for u in graph:\\n            heapq.heapify(graph[u])\\n\\n        def dfs(u: str) -> None:\\n            while u in graph and graph[u]:\\n                dfs(heapq.heappop(graph[u]))\\n            ans.append(u)\\n\\n        dfs(\\'JFK\\')\\n        return ans[::-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph",
                    "Eulerian Circuit"
                ],
                "code": "```\\nimport collections\\nimport heapq\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        ans = []\\n        graph = collections.defaultdict(list)\\n\\n        for a, b in tickets:\\n            graph[a].append(b)\\n\\n        for u in graph:\\n            heapq.heapify(graph[u])\\n\\n        def dfs(u: str) -> None:\\n            while u in graph and graph[u]:\\n                dfs(heapq.heappop(graph[u]))\\n            ans.append(u)\\n\\n        dfs(\\'JFK\\')\\n        return ans[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188293,
                "title": "c-easiest-explanation-ever-guaranteed-beginner-friendly-detailed-iterative-dfs",
                "content": "**CONCEPT:** The idea here is to use DFS and Eulerian Paths concept to solve the problem. Why? Because in the question, we\\'re basically asked to visit all the nodes in a graph only once even when there\\'s a cycle in the graph.\\n\\nSo the question boils down to visiting each node once (printing them) and all nodes must be visited.\\n\\n**OBSERVATIONS:** Here, we\\'re asked to generate a path such that we only traverse in lexical order (remember that priority_queue and set can be used for this, they store things in sorted order) and no edge should be traversed more than once (just like the condition for semi-eulerian paths).\\n\\nBut now you\\'ll ask, how can we not traverse an edge more than once? Aren\\'t we having an undirected graph? And you\\'ll be right but remember, an undirected graph is just a directed graph with an edge from source to target and target to source.\\n\\nSo, it\\'s obvious that we\\'re going to start from the node called \"JFK\" (as asked in the question). Then we\\'re going to choose a node that is a neighbor of/adjacent to the node \"JFK\". We\\'re treating airports as nodes here. When we choose a neighbor of JFK, we\\'ll choose the one that\\'s on top in lexical ordering. Then we\\'ll go to that node and find the top lexical ordering neighbor of that node. So all we\\'re doing is hopping from one node to its neighbor and then to that neighbor\\'s neighbor and so on.\\n\\n**SOLUTION:** We can use simple iterative DFS for this. In DFS, we pick a node, take its neighbor, then go there, then find that neighbor\\'s neighbor and go there and just like that, we\\'ll have a solved problem.\\n\\nSo first, we know that we don\\'t have integers as nodes here, we have strings. So we cannot really use a vector to identify nodes with an index. So we can use a map, specifically unordered_map since we don\\'t need to sort these nodes (only their neighbors). So the map will take a node (string) and have a multiset ready for it as its neighbors (multiset because there can be duplicate nodes).\\n\\nNow we\\'ll fill the neighbors according to what we\\'re given. Loop through all the tickets and extract the source and target node first, then set the target node as a neighbor of source node in the map.\\n\\nNext, ready an empty stack. This stack is used for iterative DFS, we\\'re following the standard process of DFS algorithm. Now we know we have to start with the node \"JFK\" so we push it into the stack (starting point of DFS). Also create an ans vector, we\\'ll return this as our answer.\\n\\nStart the DFS, while stack is not empty, run a loop.\\nTake the top of the stack, this is our current node.\\nNow, if current node has no neighbors, meaning that the map value (multiset) of current node has size equal to 0, we will stop the DFS by pushing the current node into the ans and popping the stack\\'s top.\\n\\nIf current node has neighbors, we\\'ll first select the top neighbor that\\'s supposedly already in the lexical order, and push it into the stack (meaning that we\\'ll visit it next). Since we\\'re visiting this neighbor, eulerian path requires us to never visit this edge again, so we\\'ll remove neighbor from current node\\'s neighbors list.\\n\\nDuring this process, we\\'ll be picking a node, traverse its first neighbor (top of lexical ordering), delete this edge (remove this neighbor from neighbors list) and repeat these 3 steps until we arrive at a node that has no more neighbors. Once we find a node with no neighbors, we add this node in our answer vector and return to its parent, if the parent again has no more neighbors, we add the parent in our answer vector and this process goes on and on till no more nodes are left in the DFS stack.\\n\\nDuring this process, note that whatever path we were taking, we were pushing the last node before its parent, which means our answer vector will contain the correct path but in reverse order. This is a thing to remember about DFS, we traverse the nodes in reverse order when returning.\\n\\nSo, that\\'s all, just reverse the answer vector and return it. Problem solved :)\\nCode with comments: https://leetcode.com/submissions/detail/736548077/\\n\\nHere\\'s the code, I hope you liked the explanation :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> neighbors;\\n        \\n        for(auto ticket: tickets){\\n            string node1 = ticket[0];\\n            string node2 = ticket[1];\\n            \\n            neighbors[node1].insert(node2);\\n        }\\n        \\n        stack<string> q;\\n        q.push(\"JFK\");\\n        \\n        vector<string> ans;\\n        while(!q.empty()){\\n            string curr = q.top();\\n            \\n            if(neighbors[curr].size() == 0){\\n                ans.push_back(curr);\\n                q.pop();\\n            } else {\\n                auto neighborPointer = neighbors[curr].begin();\\n                q.push(*neighborPointer);\\n                neighbors[curr].erase(neighborPointer);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> neighbors;\\n        \\n        for(auto ticket: tickets){\\n            string node1 = ticket[0];\\n            string node2 = ticket[1];\\n            \\n            neighbors[node1].insert(node2);\\n        }\\n        \\n        stack<string> q;\\n        q.push(\"JFK\");\\n        \\n        vector<string> ans;\\n        while(!q.empty()){\\n            string curr = q.top();\\n            \\n            if(neighbors[curr].size() == 0){\\n                ans.push_back(curr);\\n                q.pop();\\n            } else {\\n                auto neighborPointer = neighbors[curr].begin();\\n                q.push(*neighborPointer);\\n                neighbors[curr].erase(neighborPointer);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032136,
                "title": "c-euler-path-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/reconstruct-itinerary/\\n    \\n    This problem is about finding the Euler path. Euler path is a path\\n    which involves traversing all the edges only once.\\n    The way the algo works is, we start with a source and start traversing the outward\\n    edges it has, each time we remove that edge so that we don\\'t process that edge even if come \\n    back to this node again. We keep traversing till we hit a node, from where we can\\'t move forward\\n    either due to all the outward edges being used already or lack of outward edges.\\n    When we hit a terminal node, we know that this is a node that should come after any remaining unvisited nodes.\\n    because we pick an edge without any core logic, we might traverse a path that skips other nodes,\\n    so when in this path we hit a roadblock we need to store that node in such a way that this comes after \\n    the nodes that are yet to traversed. \\n    So we save the node in a stack, return to the previous node. There check if there are any other edges are yet\\n    not traversed, if yes then traverse else add this node as well and return to the previous stack call.\\n    Since all the nodes are stored in a stack manner, path starts from the top element.\\n    \\n    TC: O(V + E) + O(ElogE) + O(E) // graph construction + sorting + Euler traversal\\n    SC: O(V + E)\\n*/\\nclass Solution {\\npublic:\\n    void eulerPath(string curr, \\n               unordered_map<string, deque<string>>& g,\\n               vector<string>& order) {\\n        // traverse the neighboring edges\\n        while(!g[curr].empty()) {\\n            // use the current edge, since in a euler path\\n            // each edge is used only once, remove it\\n            auto edge = g[curr].front();\\n            g[curr].pop_front();\\n            eulerPath(edge, g, order);\\n        }\\n        // add the curr node, as there is no other way from here\\n        order.emplace_back(curr);\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // create the graph, all the edges need to be sorted lexographically\\n        unordered_map<string, deque<string>> g;\\n        for(auto edge: tickets)\\n            g[edge[0]].emplace_back(edge[1]);\\n        \\n        // sort the edges lexographically\\n        for(auto [vertex, edges]: g)\\n            sort(g[vertex].begin(), g[vertex].end());\\n        \\n        vector<string> order;\\n        eulerPath(\"JFK\", g, order);\\n        // During finding the Euler path, the nodes which should be visited\\n        // later can be found in front of order vector, so reverse it\\n        reverse(order.begin(), order.end());\\n        return order;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/reconstruct-itinerary/\\n    \\n    This problem is about finding the Euler path. Euler path is a path\\n    which involves traversing all the edges only once.\\n    The way the algo works is, we start with a source and start traversing the outward\\n    edges it has, each time we remove that edge so that we don\\'t process that edge even if come \\n    back to this node again. We keep traversing till we hit a node, from where we can\\'t move forward\\n    either due to all the outward edges being used already or lack of outward edges.\\n    When we hit a terminal node, we know that this is a node that should come after any remaining unvisited nodes.\\n    because we pick an edge without any core logic, we might traverse a path that skips other nodes,\\n    so when in this path we hit a roadblock we need to store that node in such a way that this comes after \\n    the nodes that are yet to traversed. \\n    So we save the node in a stack, return to the previous node. There check if there are any other edges are yet\\n    not traversed, if yes then traverse else add this node as well and return to the previous stack call.\\n    Since all the nodes are stored in a stack manner, path starts from the top element.\\n    \\n    TC: O(V + E) + O(ElogE) + O(E) // graph construction + sorting + Euler traversal\\n    SC: O(V + E)\\n*/\\nclass Solution {\\npublic:\\n    void eulerPath(string curr, \\n               unordered_map<string, deque<string>>& g,\\n               vector<string>& order) {\\n        // traverse the neighboring edges\\n        while(!g[curr].empty()) {\\n            // use the current edge, since in a euler path\\n            // each edge is used only once, remove it\\n            auto edge = g[curr].front();\\n            g[curr].pop_front();\\n            eulerPath(edge, g, order);\\n        }\\n        // add the curr node, as there is no other way from here\\n        order.emplace_back(curr);\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // create the graph, all the edges need to be sorted lexographically\\n        unordered_map<string, deque<string>> g;\\n        for(auto edge: tickets)\\n            g[edge[0]].emplace_back(edge[1]);\\n        \\n        // sort the edges lexographically\\n        for(auto [vertex, edges]: g)\\n            sort(g[vertex].begin(), g[vertex].end());\\n        \\n        vector<string> order;\\n        eulerPath(\"JFK\", g, order);\\n        // During finding the Euler path, the nodes which should be visited\\n        // later can be found in front of order vector, so reverse it\\n        reverse(order.begin(), order.end());\\n        return order;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372618,
                "title": "c-dfs-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void solve(string curNode, unordered_map<string, priority_queue<string,vector<string>,greater<string>>> &graph){\\n        priority_queue<string,vector<string>,greater<string>> &pq = graph[curNode];\\n        while(!pq.empty()){\\n            string childNode = pq.top();\\n            pq.pop();\\n            solve(childNode, graph);\\n        }\\n        ans.insert(ans.begin()+0,curNode);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string,vector<string>,greater<string>>> graph;\\n        for(auto &t : tickets){\\n            graph[t[0]].push(t[1]);\\n        }\\n        solve(\"JFK\",graph);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void solve(string curNode, unordered_map<string, priority_queue<string,vector<string>,greater<string>>> &graph){\\n        priority_queue<string,vector<string>,greater<string>> &pq = graph[curNode];\\n        while(!pq.empty()){\\n            string childNode = pq.top();\\n            pq.pop();\\n            solve(childNode, graph);\\n        }\\n        ans.insert(ans.begin()+0,curNode);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string,vector<string>,greater<string>>> graph;\\n        for(auto &t : tickets){\\n            graph[t[0]].push(t[1]);\\n        }\\n        solve(\"JFK\",graph);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264208,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    int flights = 0;\\n    Dictionary<string,List<string>> adjList = new Dictionary<string,List<string>>();\\n    Dictionary<string,int[]> visitedBits = new Dictionary<string,int[]>();\\n    \\n    public IList<string> FindItinerary(IList<IList<string>> tickets) \\n    {\\n        foreach(var tkt in tickets)\\n        {\\n            adjList.TryAdd(tkt[0],new List<string>());\\n            adjList[tkt[0]].Add(tkt[1]);\\n        }\\n        \\n        foreach(var kv in adjList)\\n        {\\n            kv.Value.Sort((x,y)=>x.CompareTo(y));\\n            visitedBits.Add(kv.Key,new int[kv.Value.Count]);\\n        }\\n        \\n        flights = tickets.Count+1;\\n        \\n        IList<string> path = new List<string>(){\"JFK\"};\\n        Backtrack(\"JFK\", path);\\n        return path;\\n        \\n    }\\n    \\n    private bool Backtrack(string city, IList<string> path)\\n    {\\n        if(path.Count==flights)\\n            return true;\\n        \\n        if(!adjList.ContainsKey(city))\\n            return false;\\n        \\n        int[] vBits = visitedBits[city];\\n        List<string> cities = adjList[city];\\n        \\n        for(int i=0;i<cities.Count;i++)\\n        {\\n            \\n            if(vBits[i]==0)\\n            {\\n                vBits[i] = 1;\\n                path.Add(cities[i]);\\n                if(Backtrack(cities[i],path))\\n                    return true;\\n                vBits[i] = 0;\\n                path.RemoveAt(path.Count-1);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    int flights = 0;\\n    Dictionary<string,List<string>> adjList = new Dictionary<string,List<string>>();\\n    Dictionary<string,int[]> visitedBits = new Dictionary<string,int[]>();\\n    \\n    public IList<string> FindItinerary(IList<IList<string>> tickets) \\n    {\\n        foreach(var tkt in tickets)\\n        {\\n            adjList.TryAdd(tkt[0],new List<string>());\\n            adjList[tkt[0]].Add(tkt[1]);\\n        }\\n        \\n        foreach(var kv in adjList)\\n        {\\n            kv.Value.Sort((x,y)=>x.CompareTo(y));\\n            visitedBits.Add(kv.Key,new int[kv.Value.Count]);\\n        }\\n        \\n        flights = tickets.Count+1;\\n        \\n        IList<string> path = new List<string>(){\"JFK\"};\\n        Backtrack(\"JFK\", path);\\n        return path;\\n        \\n    }\\n    \\n    private bool Backtrack(string city, IList<string> path)\\n    {\\n        if(path.Count==flights)\\n            return true;\\n        \\n        if(!adjList.ContainsKey(city))\\n            return false;\\n        \\n        int[] vBits = visitedBits[city];\\n        List<string> cities = adjList[city];\\n        \\n        for(int i=0;i<cities.Count;i++)\\n        {\\n            \\n            if(vBits[i]==0)\\n            {\\n                vBits[i] = 1;\\n                path.Add(cities[i]);\\n                if(Backtrack(cities[i],path))\\n                    return true;\\n                vBits[i] = 0;\\n                path.RemoveAt(path.Count-1);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114799,
                "title": "very-simple-java-solution",
                "content": "\\n\\tprivate Map<String, PriorityQueue<String>> map;\\n    private LinkedList<String> result;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        this.map = new HashMap<>();\\n        this.result = new LinkedList<>();\\n        \\n        for (List<String> ticket: tickets) {\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n            \\n            PriorityQueue<String> destinations = map.get(from);\\n            \\n            if (destinations == null) {\\n                destinations = new PriorityQueue<String>();\\n                map.put(from, destinations);\\n            }\\n            \\n            destinations.add(to);\\n        }\\n        \\n        dfs(\"JFK\");\\n        return result;\\n    }\\n    \\n    private void dfs(String from) {\\n        PriorityQueue<String> arrivals = map.get(from);\\n        \\n        while (arrivals != null && !arrivals.isEmpty()) \\n            dfs(arrivals.remove());\\n        \\n        result.addFirst(from);\\n    }",
                "solutionTags": [],
                "code": "\\n\\tprivate Map<String, PriorityQueue<String>> map;\\n    private LinkedList<String> result;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        this.map = new HashMap<>();\\n        this.result = new LinkedList<>();\\n        \\n        for (List<String> ticket: tickets) {\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n            \\n            PriorityQueue<String> destinations = map.get(from);\\n            \\n            if (destinations == null) {\\n                destinations = new PriorityQueue<String>();\\n                map.put(from, destinations);\\n            }\\n            \\n            destinations.add(to);\\n        }\\n        \\n        dfs(\"JFK\");\\n        return result;\\n    }\\n    \\n    private void dfs(String from) {\\n        PriorityQueue<String> arrivals = map.get(from);\\n        \\n        while (arrivals != null && !arrivals.isEmpty()) \\n            dfs(arrivals.remove());\\n        \\n        result.addFirst(from);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1018032,
                "title": "c-beats-98-easy-and-concise-solution-using-multimap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multimap<string, bool>> graph;\\n        for (vector<string> data : tickets)\\n            graph[data[0]].insert({data[1], false});\\n        \\n        vector<string> out;\\n        \\n        dfs(out, {\"JFK\", 0}, graph);\\n        \\n        reverse(out.begin(), out.end());\\n        return out;\\n    }\\n    \\n    void dfs(vector<string>& out, pair<string, bool> node, unordered_map<string, multimap<string, bool>>& graph) {  \\n        for (auto& data : graph[node.first]) {\\n            if (!data.second) {\\n                data.second = true;\\n                dfs(out, data, graph);\\n            }\\n        }\\n        out.push_back(node.first);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multimap<string, bool>> graph;\\n        for (vector<string> data : tickets)\\n            graph[data[0]].insert({data[1], false});\\n        \\n        vector<string> out;\\n        \\n        dfs(out, {\"JFK\", 0}, graph);\\n        \\n        reverse(out.begin(), out.end());\\n        return out;\\n    }\\n    \\n    void dfs(vector<string>& out, pair<string, bool> node, unordered_map<string, multimap<string, bool>>& graph) {  \\n        for (auto& data : graph[node.first]) {\\n            if (!data.second) {\\n                data.second = true;\\n                dfs(out, data, graph);\\n            }\\n        }\\n        out.push_back(node.first);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798737,
                "title": "java-solution-using-priority-queue-and-stack",
                "content": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> mapEdges = new HashMap<>();\\n        \\n        for(List<String> ticket : tickets) {\\n            PriorityQueue<String> q = mapEdges.getOrDefault(ticket.get(0), new PriorityQueue<String>( (s1, s2) -> s1.compareTo(s2) )) ;\\n            q.offer(ticket.get(1));\\n            mapEdges.put(ticket.get(0), q);\\n        }\\n        \\n        \\n        Stack<String> s = new Stack<>();\\n        s.push(\"JFK\"); // Starting point is JFK\\n        \\n        List<String> finalIternary = new ArrayList<>();\\n        while(!s.isEmpty()) {\\n\\n            String source = s.peek();\\n            PriorityQueue<String> q = mapEdges.get(source);\\n            \\n            if(q == null || q.isEmpty()) {\\n                finalIternary.add(s.pop());\\n            } else {\\n                s.push(q.poll());\\n            }\\n        }\\n        \\n        Collections.reverse(finalIternary);      \\n        return finalIternary;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, PriorityQueue<String>> mapEdges = new HashMap<>();\\n        \\n        for(List<String> ticket : tickets) {\\n            PriorityQueue<String> q = mapEdges.getOrDefault(ticket.get(0), new PriorityQueue<String>( (s1, s2) -> s1.compareTo(s2) )) ;\\n            q.offer(ticket.get(1));\\n            mapEdges.put(ticket.get(0), q);\\n        }\\n        \\n        \\n        Stack<String> s = new Stack<>();\\n        s.push(\"JFK\"); // Starting point is JFK\\n        \\n        List<String> finalIternary = new ArrayList<>();\\n        while(!s.isEmpty()) {\\n\\n            String source = s.peek();\\n            PriorityQueue<String> q = mapEdges.get(source);\\n            \\n            if(q == null || q.isEmpty()) {\\n                finalIternary.add(s.pop());\\n            } else {\\n                s.push(q.poll());\\n            }\\n        }\\n        \\n        Collections.reverse(finalIternary);      \\n        return finalIternary;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711550,
                "title": "rust-solution",
                "content": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::{BinaryHeap, HashMap};\\n\\nimpl Solution {\\n    pub fn find_itinerary(tickets: Vec<Vec<String>>) -> Vec<String> {\\n        let mut graph: HashMap<&str, BinaryHeap<Reverse<&str>>> = HashMap::new();\\n        for ticket in tickets.iter() {\\n            graph\\n                .entry(&ticket[0])\\n                .or_insert_with(BinaryHeap::new)\\n                .push(Reverse(&ticket[1]));\\n        }\\n        let mut answer: Vec<String> = Vec::with_capacity(tickets.len() + 1);\\n        let mut stack: Vec<&str> = vec![\"JFK\"];\\n        while let Some(src) = stack.last() {\\n            if let Some(dsts) = graph.get_mut(src) {\\n                if !dsts.is_empty() {\\n                    if let Some(dst) = dsts.pop() {\\n                        stack.push(dst.0);\\n                    }\\n                    continue;\\n                }\\n            }\\n            if let Some(last) = stack.pop() {\\n                answer.push(last.to_string());\\n            }\\n        }\\n        answer.reverse();\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::{BinaryHeap, HashMap};\\n\\nimpl Solution {\\n    pub fn find_itinerary(tickets: Vec<Vec<String>>) -> Vec<String> {\\n        let mut graph: HashMap<&str, BinaryHeap<Reverse<&str>>> = HashMap::new();\\n        for ticket in tickets.iter() {\\n            graph\\n                .entry(&ticket[0])\\n                .or_insert_with(BinaryHeap::new)\\n                .push(Reverse(&ticket[1]));\\n        }\\n        let mut answer: Vec<String> = Vec::with_capacity(tickets.len() + 1);\\n        let mut stack: Vec<&str> = vec![\"JFK\"];\\n        while let Some(src) = stack.last() {\\n            if let Some(dsts) = graph.get_mut(src) {\\n                if !dsts.is_empty() {\\n                    if let Some(dst) = dsts.pop() {\\n                        stack.push(dst.0);\\n                    }\\n                    continue;\\n                }\\n            }\\n            if let Some(last) = stack.pop() {\\n                answer.push(last.to_string());\\n            }\\n        }\\n        answer.reverse();\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 710763,
                "title": "c-dfs-with-priority-queue",
                "content": "```\\nclass Solution {\\n    vector<string> ans;\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>> mp;\\n    \\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (auto& ticket : tickets) {\\n            mp[ticket[0]].push(ticket[1]);\\n        }\\n        \\n        dfs(\"JFK\");\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(string src) {\\n        while (!mp[src].empty()) {\\n            string dst = mp[src].top();\\n            mp[src].pop();\\n            \\n            dfs(dst);\\n        }\\n        \\n        ans.push_back(src);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> ans;\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>> mp;\\n    \\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (auto& ticket : tickets) {\\n            mp[ticket[0]].push(ticket[1]);\\n        }\\n        \\n        dfs(\"JFK\");\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(string src) {\\n        while (!mp[src].empty()) {\\n            string dst = mp[src].top();\\n            mp[src].pop();\\n            \\n            dfs(dst);\\n        }\\n        \\n        ans.push_back(src);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520274,
                "title": "good-problem-terrible-description",
                "content": "It\\'s a shame this problem was writen so poorly. It could be a good problem had the intention been clearer. As a result of the shoddy explanation, this one had me going around in circles until I finally checked some of the solutions. Pointless frustration, as it turns out, as the missing information made the problem requirements seem a lot more difficult than they actually are. And the \"accepted\" solution (taken after others posted) gives nonsensical answers in a number of cases.\\n\\nFor example, if I set up a graph that looks like this:\\n```\\nJFK->[SFO, DUB]\\n```\\nthe solution my \"correct\" answer gives me is ` JFK SFO DUB.` Which is actually impossible. In a production environment, an impossible state should give null or an error. The instructions neglect to mention any error state. \\n\\nHere\\'s another:\\n```\\nDUB->[SFO] JFK->[SFO, DUB] SFO->[DUB]\\n```\\nThe order called for by the instructions (i.e. the lexically smallest) would be `JFK DUB SFO DUB` (with one leg impossible to reach). What it actually gives is `JFK SFO DUB SFO DUB` which is incorrect because it\\'s not lexically the smallest, and it lists the trip from SFO to DUB that doesn\\'t exist in the tickets. \\n\\nSo apparently there is some kind of guarantee that the data has an unspecified shape that\\'s key to solving the problem, but you\\'re going to make us just guess? That\\'s not a very worthwhile game. Edge cases should be important, but the way this problem is written, it ignores all of them. A good programmer should worry about them, but that makes the problem ridiculously difficult, because the real requirements were not clearly stated. \\n\\nThere are a lot of well-written problems on Leetcode. This is not one of them. \\n\\n```java\\n    void dfs(Map<String, List<String>> graph, List<String> rs, String here) {\\n        List<String> adj=graph.computeIfAbsent(here, e-> new ArrayList<>() );\\n        while (!adj.isEmpty())\\n            dfs(graph, rs, adj.remove(adj.size()-1));\\n        rs.add(here);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tix) {\\n        tix.sort(Comparator\\n            .comparing((List<String> a) -> (a.get(0) + a.get(1)))\\n            .reversed());\\n        Map<String, List<String>> graph = new HashMap<>();\\n        tix.forEach( t -> graph\\n            .computeIfAbsent(t.get(0), (e -> new ArrayList<>()))\\n            .add(t.get(1)) );\\n\\n        List<String> rs=new ArrayList<>();\\n        dfs(graph, rs, \"JFK\");\\n        Collections.reverse(rs);\\n        return rs;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nJFK->[SFO, DUB]\\n```\n```\\nDUB->[SFO] JFK->[SFO, DUB] SFO->[DUB]\\n```\n```java\\n    void dfs(Map<String, List<String>> graph, List<String> rs, String here) {\\n        List<String> adj=graph.computeIfAbsent(here, e-> new ArrayList<>() );\\n        while (!adj.isEmpty())\\n            dfs(graph, rs, adj.remove(adj.size()-1));\\n        rs.add(here);\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tix) {\\n        tix.sort(Comparator\\n            .comparing((List<String> a) -> (a.get(0) + a.get(1)))\\n            .reversed());\\n        Map<String, List<String>> graph = new HashMap<>();\\n        tix.forEach( t -> graph\\n            .computeIfAbsent(t.get(0), (e -> new ArrayList<>()))\\n            .add(t.get(1)) );\\n\\n        List<String> rs=new ArrayList<>();\\n        dfs(graph, rs, \"JFK\");\\n        Collections.reverse(rs);\\n        return rs;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 424837,
                "title": "python-recursive-dfs-beats-95",
                "content": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        adjMap = self.makeAdjMap(tickets)\\n        res = []\\n        self.dfs(adjMap, \"JFK\", res)\\n        return res[::-1]\\n    \\n    def dfs(self, adjMap, airport, res):\\n        if airport in adjMap and len(adjMap[airport]) > 0:        \\n            while len(adjMap[airport]) > 0:\\n                destination = adjMap[airport].pop()\\n                self.dfs(adjMap, destination, res)\\n        res.append(airport)\\n        \\n    def makeAdjMap(self, tickets):\\n        adjMap = {}\\n        for ticket in tickets:\\n            if ticket[0] not in adjMap:\\n                adjMap[ticket[0]] = [ticket[1]]\\n            else:\\n                adjMap[ticket[0]].append(ticket[1])\\n        for ticket in tickets:\\n            adjMap[ticket[0]].sort(reverse=True)\\n        return adjMap    \\n        \\n        \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        adjMap = self.makeAdjMap(tickets)\\n        res = []\\n        self.dfs(adjMap, \"JFK\", res)\\n        return res[::-1]\\n    \\n    def dfs(self, adjMap, airport, res):\\n        if airport in adjMap and len(adjMap[airport]) > 0:        \\n            while len(adjMap[airport]) > 0:\\n                destination = adjMap[airport].pop()\\n                self.dfs(adjMap, destination, res)\\n        res.append(airport)\\n        \\n    def makeAdjMap(self, tickets):\\n        adjMap = {}\\n        for ticket in tickets:\\n            if ticket[0] not in adjMap:\\n                adjMap[ticket[0]] = [ticket[1]]\\n            else:\\n                adjMap[ticket[0]].append(ticket[1])\\n        for ticket in tickets:\\n            adjMap[ticket[0]].sort(reverse=True)\\n        return adjMap    \\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 420174,
                "title": "python-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        result=[]\\n        graph = collections.defaultdict(list)\\n        for frm, to in tickets:     #create a graph\\n            graph[frm].append(to)   #rearrange the destination of same start together\\n                        \\n        for frm, tos in graph.items():      #get key and value from dictionary #sort the destination\\n            tos.sort(reverse=True)          #we want small to large order\\n        \\n        def dfs(graph, source, result):\\n            while graph[source]:                #when the destination is not empty\\n                new_source = graph[source].pop()         #let the destination empty if we choose it to pop (pop() means the right one)\\n                dfs(graph, new_source, result)\\n            result.append(source)\\n            \\n        dfs(graph, \"JFK\", result)         \\n        return result[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        result=[]\\n        graph = collections.defaultdict(list)\\n        for frm, to in tickets:     #create a graph\\n            graph[frm].append(to)   #rearrange the destination of same start together\\n                        \\n        for frm, tos in graph.items():      #get key and value from dictionary #sort the destination\\n            tos.sort(reverse=True)          #we want small to large order\\n        \\n        def dfs(graph, source, result):\\n            while graph[source]:                #when the destination is not empty\\n                new_source = graph[source].pop()         #let the destination empty if we choose it to pop (pop() means the right one)\\n                dfs(graph, new_source, result)\\n            result.append(source)\\n            \\n        dfs(graph, \"JFK\", result)         \\n        return result[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348511,
                "title": "java-dfs",
                "content": "```\\n\\nclass Solution {\\n    \\n    Map<String, PriorityQueue<String>> map = new HashMap<>();\\n    List<String> route = new ArrayList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        for(List<String> ticket: tickets) {\\n            if(!map.containsKey(ticket.get(0))) {\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n                pq.add(ticket.get(1));\\n                map.put(ticket.get(0),pq);\\n            }\\n            else {\\n                map.get(ticket.get(0)).add(ticket.get(1));\\n            }\\n        }  \\n        visit(\"JFK\");\\n        return route;\\n    }\\n    \\n    public void visit(String airport) {\\n        while(map.containsKey(airport) && !map.get(airport).isEmpty()) {\\n            PriorityQueue<String> dests = map.get(airport);\\n            String dest = dests.poll();\\n            visit(dest);\\n        }\\n        route.add(0,airport); \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    Map<String, PriorityQueue<String>> map = new HashMap<>();\\n    List<String> route = new ArrayList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        for(List<String> ticket: tickets) {\\n            if(!map.containsKey(ticket.get(0))) {\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n                pq.add(ticket.get(1));\\n                map.put(ticket.get(0),pq);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 185738,
                "title": "leetcode-bug-memory-limit-exceeded-when-i-try-submit-following-code",
                "content": "It\\'s weird that I can pass the test case \\n[[\"JFK\",\"SFO\"]]\\nfrom customize test case.\\n\\nBut when I try to submit my code, it always reporting \"Memory Limit Exceeded\":\\n\\nI didn\\'t see my code has problem for test case [[\"JFK\",\"SFO\"]].\\n\\nAny Master can give me a help on this? Or it\\'s a leetcode\\'s bug?\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        unordered_map < string, priority_queue<string, vector<string>, greater<string>>> f2tos;\\n        for (auto ft : tickets) {\\n            f2tos[ft.first].push(ft.second);\\n        }\\n\\n        vector<string> result;\\n        if (tickets.empty() || f2tos.find(\"JFK\") == f2tos.end()) {\\n            return result;\\n        }\\n\\n        string start = \"JFK\";\\n        while (!f2tos.empty()) {\\n            auto pq2 = f2tos[start];\\n            result.push_back(start);\\n            auto next = pq2.top();\\n            pq2.pop();\\n            if (pq2.empty()) {\\n                f2tos.erase(start);\\n            }\\n\\n            start = next;\\n        }\\n\\n        result.push_back(start);\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\\n        unordered_map < string, priority_queue<string, vector<string>, greater<string>>> f2tos;\\n        for (auto ft : tickets) {\\n            f2tos[ft.first].push(ft.second);\\n        }\\n\\n        vector<string> result;\\n        if (tickets.empty() || f2tos.find(\"JFK\") == f2tos.end()) {\\n            return result;\\n        }\\n\\n        string start = \"JFK\";\\n        while (!f2tos.empty()) {\\n            auto pq2 = f2tos[start];\\n            result.push_back(start);\\n            auto next = pq2.top();\\n            pq2.pop();\\n            if (pq2.empty()) {\\n                f2tos.erase(start);\\n            }\\n\\n            start = next;\\n        }\\n\\n        result.push_back(start);\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78797,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with detailed explanation** https://discuss.leetcode.com/topic/76788/python-solution-with-detailed-explanation\\n\\n**Reconstruct Itinerary** https://leetcode.com/problems/reconstruct-itinerary/\\n\\nAn Euler path is a path that uses every edge of a graph exactly once. An Euler path starts and ends at different vertices.\\n* First build a graph as a dictionary with key as vertex and value as list of edges with edge_id.\\n* Now the algorithm to find the Euler path is simple backtracking DFS.\\n* Note the Euler path may have cycles - Example 2 shows that. And Euler path allows an edge to be visited just once. Hence we will use edge_seen set to mark the edges visited. We will not mark vertices since we can visit vertices multiple times - cycles are allowed.\\n* We start with the first departure - JFK. \\n* We then find all the nbr,edge_id we can go to. We choose an edge that has not been visited before.\\n* Before we do a DFS, we add this to an edge_seen set and add to so_far\\n* touw - implements DFS and returns True when a path is found. We prune out search at that point.\\n\\n```\\nclass Solution(object):\\n    def build_graph(self, tickets):\\n        g, ticket_id = {}, 0\\n        for trip in tickets:\\n            v, w = trip[0], trip[1]\\n            g.setdefault(v, [])\\n            g[v].append((w, ticket_id))\\n            ticket_id = ticket_id + 1\\n        for k in g:\\n            g[k].sort(key=lambda x:x[0])\\n        return g\\n    \\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        g = self.build_graph(tickets)\\n        tickets_used, itenary = set([]), [\"JFK\"]\\n        self.tour(g, itenary, tickets_used, len(tickets)+1)\\n        return itenary\\n    \\n    def tour(self, g, itenary, tickets_used, N):\\n        if len(itenary) == N:\\n            return True\\n        else:\\n            s = itenary[-1]\\n            if s in g:\\n                candidates = ((nbr, ticket_id) for nbr, ticket_id in g[s] if ticket_id not in tickets_used)\\n                for nbr, ticket_id in candidates:\\n                    tickets_used.add(ticket_id)\\n                    itenary.append(nbr)\\n                    if self.tour(g, itenary, tickets_used, N):\\n                        return True\\n                    itenary.pop()\\n                    tickets_used.remove(ticket_id)\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def build_graph(self, tickets):\\n        g, ticket_id = {}, 0\\n        for trip in tickets:\\n            v, w = trip[0], trip[1]\\n            g.setdefault(v, [])\\n            g[v].append((w, ticket_id))\\n            ticket_id = ticket_id + 1\\n        for k in g:\\n            g[k].sort(key=lambda x:x[0])\\n        return g\\n    \\n    def findItinerary(self, tickets):\\n        \"\"\"\\n        :type tickets: List[List[str]]\\n        :rtype: List[str]\\n        \"\"\"\\n        g = self.build_graph(tickets)\\n        tickets_used, itenary = set([]), [\"JFK\"]\\n        self.tour(g, itenary, tickets_used, len(tickets)+1)\\n        return itenary\\n    \\n    def tour(self, g, itenary, tickets_used, N):\\n        if len(itenary) == N:\\n            return True\\n        else:\\n            s = itenary[-1]\\n            if s in g:\\n                candidates = ((nbr, ticket_id) for nbr, ticket_id in g[s] if ticket_id not in tickets_used)\\n                for nbr, ticket_id in candidates:\\n                    tickets_used.add(ticket_id)\\n                    itenary.append(nbr)\\n                    if self.tour(g, itenary, tickets_used, N):\\n                        return True\\n                    itenary.pop()\\n                    tickets_used.remove(ticket_id)\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78802,
                "title": "javascript-122ms-recursive-solution",
                "content": "I have a JS solution that runs at 122ms (beating 100% of JS solutions yet). Any improvements or suggestions, please feel free to comment.\\n\\n```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    \\n    var length = tickets.length;\\n    \\n    var map = {\\n        JFK: []\\n    };\\n    \\n    var result = [];\\n    \\n    for(var i=0; i<length; i++){\\n        \\n        var from = tickets[i][0];\\n        var to = tickets[i][1];\\n        \\n        if(!map[from]){\\n            map[from] = [];\\n            map[from].push(to);\\n        } else {\\n            map[from].push(to);\\n        }\\n    }\\n    \\n    for(var prop in map){\\n        map[prop].sort();\\n    }    \\n    \\n    makeItinerary(\"JFK\");    // dfs\\n    \\n    function makeItinerary(from){        \\n        var tos = map[from];        \\n        while(tos && tos.length > 0){\\n            makeItinerary(tos.shift()); \\n        }        \\n        result.unshift(from);\\n    }\\n    \\n    return result;    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    \\n    var length = tickets.length;\\n    \\n    var map = {\\n        JFK: []\\n    };\\n    \\n    var result = [];\\n    \\n    for(var i=0; i<length; i++){\\n        \\n        var from = tickets[i][0];\\n        var to = tickets[i][1];\\n        \\n        if(!map[from]){\\n            map[from] = [];\\n            map[from].push(to);\\n        } else {\\n            map[from].push(to);\\n        }\\n    }\\n    \\n    for(var prop in map){\\n        map[prop].sort();\\n    }    \\n    \\n    makeItinerary(\"JFK\");    // dfs\\n    \\n    function makeItinerary(from){        \\n        var tos = map[from];        \\n        while(tos && tos.length > 0){\\n            makeItinerary(tos.shift()); \\n        }        \\n        result.unshift(from);\\n    }\\n    \\n    return result;    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2769245,
                "title": "c-easy-solution-min-heap-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(string curr, unordered_map<string, priority_queue<string, vector<string>, greater<string>>> &adj, vector<string> &ans) {\\n        while(adj[curr].size()) {\\n            string temp=adj[curr].top(); adj[curr].pop();\\n            dfs(temp, adj, ans);\\n        }\\n        ans.push_back(curr);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        vector<string> ans;\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> adj;\\n        for(auto x: tickets) {\\n            adj[x[0]].push(x[1]);\\n        }\\n        dfs(\"JFK\", adj, ans);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(string curr, unordered_map<string, priority_queue<string, vector<string>, greater<string>>> &adj, vector<string> &ans) {\\n        while(adj[curr].size()) {\\n            string temp=adj[curr].top(); adj[curr].pop();\\n            dfs(temp, adj, ans);\\n        }\\n        ans.push_back(curr);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        vector<string> ans;\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> adj;\\n        for(auto x: tickets) {\\n            adj[x[0]].push(x[1]);\\n        }\\n        dfs(\"JFK\", adj, ans);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370916,
                "title": "c-concise-straightfoward-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Build the directed graph\\n        unordered_map<string, vector<string>> graph;\\n        int numOfEdges = tickets.size();\\n        for (vector<string> &ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto &it : graph) {\\n            sort(begin(it.second), end(it.second));\\n        }\\n        \\n        vector<string> result;\\n        vector<string> path = { \"JFK\" };\\n        dfs(\"JFK\", path, result, graph, numOfEdges);\\n        return result;\\n    }\\n    \\n    void dfs(string cur, vector<string> &path, vector<string> &result, unordered_map<string, vector<string>> &graph, int numOfEdges) {\\n        if (result.empty() == false) {\\n            return;\\n        }\\n        if (numOfEdges == 0) {\\n            result = path;\\n            return;\\n        }\\n        for (int i = 0; i < graph[cur].size(); i++) {\\n            string neighbor = graph[cur][i];\\n            if (neighbor != \"#\") {\\n                // Mark the edge\\n                graph[cur][i] = \"#\";\\n                path.push_back(neighbor);\\n                dfs(neighbor, path, result, graph, numOfEdges - 1);\\n                // Backtrack\\n                graph[cur][i] = neighbor;\\n                path.pop_back();\\n            }   \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // Build the directed graph\\n        unordered_map<string, vector<string>> graph;\\n        int numOfEdges = tickets.size();\\n        for (vector<string> &ticket : tickets) {\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        \\n        for (auto &it : graph) {\\n            sort(begin(it.second), end(it.second));\\n        }\\n        \\n        vector<string> result;\\n        vector<string> path = { \"JFK\" };\\n        dfs(\"JFK\", path, result, graph, numOfEdges);\\n        return result;\\n    }\\n    \\n    void dfs(string cur, vector<string> &path, vector<string> &result, unordered_map<string, vector<string>> &graph, int numOfEdges) {\\n        if (result.empty() == false) {\\n            return;\\n        }\\n        if (numOfEdges == 0) {\\n            result = path;\\n            return;\\n        }\\n        for (int i = 0; i < graph[cur].size(); i++) {\\n            string neighbor = graph[cur][i];\\n            if (neighbor != \"#\") {\\n                // Mark the edge\\n                graph[cur][i] = \"#\";\\n                path.push_back(neighbor);\\n                dfs(neighbor, path, result, graph, numOfEdges - 1);\\n                // Backtrack\\n                graph[cur][i] = neighbor;\\n                path.pop_back();\\n            }   \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357384,
                "title": "euler-path-template-c",
                "content": "A Euler Path in a graph is a path which visits all the edges. A Eulerian Circuit is a Eulerian Path with the same Start and End node.\\nHere are the conditions to check if a graph contains a Euler Path or not.\\n\\n![image](https://assets.leetcode.com/users/images/15396511-dab4-4f26-b1af-96470ad6fce8_1627049659.1972127.png)\\n\\nIf we know that a graph has a Eulerian Path or Circuit, then for graph that satisfies Eulerian Circuit conditions we may begin with any node. But for a directed graph with two odd degree nodes we must begin with the node having outdegree > indegree and end at node having indegree > outdegree. And for undirected graph with two odd degree nodes Start at any of the 2 odd degree nodes.\\n\\nThis is the Hierholzer\\'s algorithm to find a Eulerian Path ( Knowing that the graph has one ). \\nThe algorithm is to perform dfs and keep removing edges traversed from the graph until we get stuck. Now the intuition is that we have missed the Eulerian path because we might have missed some edges in between which will be forming some sort of a cycle to bring us back to some middle node. Anyhow, the node which we are stuck on will be coming at last. So push it and backtrack to completely visit those leftover cycles.\\n\\t\\n\\tvector<int> path;\\n    \\n    void F(int u, vector<vector<int>>& G){\\n        \\n        while(!G[u].empty()){\\n            int v = G[u].top();\\n            G[u].pop();\\n            F(v, G);\\n        }\\n        path.push_back(u);\\n        \\n    }\\n    \\n    vector<int> eulerPath(int src, vector<vector<int>>& G){\\n        \\n        F(src, G);\\n        \\n        reverse(path.begin(), path.end());\\n        return path;\\n        \\n    }",
                "solutionTags": [],
                "code": "A Euler Path in a graph is a path which visits all the edges. A Eulerian Circuit is a Eulerian Path with the same Start and End node.\\nHere are the conditions to check if a graph contains a Euler Path or not.\\n\\n![image](https://assets.leetcode.com/users/images/15396511-dab4-4f26-b1af-96470ad6fce8_1627049659.1972127.png)\\n\\nIf we know that a graph has a Eulerian Path or Circuit, then for graph that satisfies Eulerian Circuit conditions we may begin with any node. But for a directed graph with two odd degree nodes we must begin with the node having outdegree > indegree and end at node having indegree > outdegree. And for undirected graph with two odd degree nodes Start at any of the 2 odd degree nodes.\\n\\nThis is the Hierholzer\\'s algorithm to find a Eulerian Path ( Knowing that the graph has one ). \\nThe algorithm is to perform dfs and keep removing edges traversed from the graph until we get stuck. Now the intuition is that we have missed the Eulerian path because we might have missed some edges in between which will be forming some sort of a cycle to bring us back to some middle node. Anyhow, the node which we are stuck on will be coming at last. So push it and backtrack to completely visit those leftover cycles.\\n\\t\\n\\tvector<int> path;\\n    \\n    void F(int u, vector<vector<int>>& G){\\n        \\n        while(!G[u].empty()){\\n            int v = G[u].top();\\n            G[u].pop();\\n            F(v, G);\\n        }\\n        path.push_back(u);\\n        \\n    }\\n    \\n    vector<int> eulerPath(int src, vector<vector<int>>& G){\\n        \\n        F(src, G);\\n        \\n        reverse(path.begin(), path.end());\\n        return path;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1311284,
                "title": "20ms-c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string,priority_queue<string, vector<string>, greater<string>>> mp;\\n    void dfs(string str)\\n    {\\n        while(!mp[str].empty())\\n        {\\n        auto tp = mp[str].top();\\n        mp[str].pop();\\n        dfs(tp);\\n        }\\n        ans.push_back(str);\\n        return;\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) \\n    {\\n        for(auto x: tickets)\\n        {\\n            mp[x[0]].push(x[1]);\\n        }\\n        string str = \"JFK\";\\n        dfs(str);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string,priority_queue<string, vector<string>, greater<string>>> mp;\\n    void dfs(string str)\\n    {\\n        while(!mp[str].empty())\\n        {\\n        auto tp = mp[str].top();\\n        mp[str].pop();\\n        dfs(tp);\\n        }\\n        ans.push_back(str);\\n        return;\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) \\n    {\\n        for(auto x: tickets)\\n        {\\n            mp[x[0]].push(x[1]);\\n        }\\n        string str = \"JFK\";\\n        dfs(str);\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309356,
                "title": "explained-golang-backtrack-dfs-12ms",
                "content": "```go\\nimport \"sort\"\\n\\nfunc findItinerary(tickets [][]string) []string {\\n    // make a graph, map to keep tickets from source => []destinations\\n\\tadjancency := make(map[string][]string)\\n\\tfor i := 0; i < len(tickets); i++ {\\n\\t\\tadjancency[tickets[i][0]] = append(adjancency[tickets[i][0]], tickets[i][1])\\n\\t}\\n   \\n   // constraint is to give preferrence to lexicographically sorted solution, lets sort all destinations in asc order\\n   // we do it in a separate loop and not the above loop because we should call sort once for a list of destinations\\n\\tfor i := 0; i < len(tickets); i++ {\\n\\t\\tsort.Strings(adjancency[tickets[i][0]])\\n\\t}\\n\\n\\titinerary := []string{}\\n\\t\\n\\t// dfs function made inside this function only because, it is much cleaner this way\\n\\t// you need to pass less variables around with the recursive DFS calls\\n\\tvar dfs func(source string) bool\\n\\tdfs = func(source string) bool {\\n\\t\\titinerary = append(itinerary, source)\\n\\n        // we only want to check solutions only for totalChances, if solution\\n\\t\\t// is not found in that, means the solution is somewhere else and we backtrack!\\n\\t\\ttotalChances := len(adjancency[source])\\n\\t\\tchances := 0\\n\\t\\t\\n\\t\\t// find all the other possible destinations\\n\\t\\tfor len(adjancency[source]) > 0 && chances < totalChances {\\n\\t\\t\\tdestination := adjancency[source][0]\\n\\t\\t\\tadjancency[source] = adjancency[source][1:]\\n\\t\\t\\tif !dfs(destination) { // backtrack, destination is not a possible destination\\n\\t\\t\\t\\tchances += 1\\n\\t\\t\\t\\titinerary = itinerary[:len(itinerary)-1]\\n\\t\\t\\t\\tadjancency[source] = append(adjancency[source], destination)\\n\\t\\t\\t} else { // hurrah! we found our solution\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// so when the iteneary is made up of all tickets we have found our solution else not\\n\\t\\t// if not we trigger backtrack!\\n\\t\\tif len(itinerary)-1 != len(tickets) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n         // solution found\\n\\t\\treturn true\\n\\t}\\n\\n\\tdfs(\"JFK\")\\n\\n\\treturn itinerary\\n}\\n```\\n\\nLet me know if you have any questions",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```go\\nimport \"sort\"\\n\\nfunc findItinerary(tickets [][]string) []string {\\n    // make a graph, map to keep tickets from source => []destinations\\n\\tadjancency := make(map[string][]string)\\n\\tfor i := 0; i < len(tickets); i++ {\\n\\t\\tadjancency[tickets[i][0]] = append(adjancency[tickets[i][0]], tickets[i][1])\\n\\t}\\n   \\n   // constraint is to give preferrence to lexicographically sorted solution, lets sort all destinations in asc order\\n   // we do it in a separate loop and not the above loop because we should call sort once for a list of destinations\\n\\tfor i := 0; i < len(tickets); i++ {\\n\\t\\tsort.Strings(adjancency[tickets[i][0]])\\n\\t}\\n\\n\\titinerary := []string{}\\n\\t\\n\\t// dfs function made inside this function only because, it is much cleaner this way\\n\\t// you need to pass less variables around with the recursive DFS calls\\n\\tvar dfs func(source string) bool\\n\\tdfs = func(source string) bool {\\n\\t\\titinerary = append(itinerary, source)\\n\\n        // we only want to check solutions only for totalChances, if solution\\n\\t\\t// is not found in that, means the solution is somewhere else and we backtrack!\\n\\t\\ttotalChances := len(adjancency[source])\\n\\t\\tchances := 0\\n\\t\\t\\n\\t\\t// find all the other possible destinations\\n\\t\\tfor len(adjancency[source]) > 0 && chances < totalChances {\\n\\t\\t\\tdestination := adjancency[source][0]\\n\\t\\t\\tadjancency[source] = adjancency[source][1:]\\n\\t\\t\\tif !dfs(destination) { // backtrack, destination is not a possible destination\\n\\t\\t\\t\\tchances += 1\\n\\t\\t\\t\\titinerary = itinerary[:len(itinerary)-1]\\n\\t\\t\\t\\tadjancency[source] = append(adjancency[source], destination)\\n\\t\\t\\t} else { // hurrah! we found our solution\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// so when the iteneary is made up of all tickets we have found our solution else not\\n\\t\\t// if not we trigger backtrack!\\n\\t\\tif len(itinerary)-1 != len(tickets) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n         // solution found\\n\\t\\treturn true\\n\\t}\\n\\n\\tdfs(\"JFK\")\\n\\n\\treturn itinerary\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1265296,
                "title": "simple-python",
                "content": "```class Solution:\\n    def findItinerary(self, tickets):\\n        graph = defaultdict(list)\\n\\n        tickets.sort(key=lambda x: x[1])\\n\\n        for u, v in tickets:\\n            graph[u].append(v)\\n\\n        itinerary, stack = [], [\"JFK\"]\\n\\n        while stack:\\n            curr = stack[-1]\\n\\n            if curr in graph and len(graph[curr]) > 0:\\n                stack.append(graph[curr].pop(0))\\n            else:\\n                itinerary.append(stack.pop())\\n        return itinerary[::-1]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def findItinerary(self, tickets):\\n        graph = defaultdict(list)\\n\\n        tickets.sort(key=lambda x: x[1])\\n\\n        for u, v in tickets:\\n            graph[u].append(v)\\n\\n        itinerary, stack = [], [\"JFK\"]\\n\\n        while stack:\\n            curr = stack[-1]\\n\\n            if curr in graph and len(graph[curr]) > 0:\\n                stack.append(graph[curr].pop(0))\\n            else:\\n                itinerary.append(stack.pop())\\n        return itinerary[::-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1146076,
                "title": "dfs-with-priority-queue",
                "content": "```\\nclass Solution {\\n    HashMap<String, PriorityQueue<String>>  graph = new HashMap<>();\\n    LinkedList<String> result  = new LinkedList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        this.buildGraph(tickets);\\n        this.dfs(\"JFK\");\\n        return this.result;\\n    }\\n    \\n    private void dfs(String origin) {\\n        if (this.graph.containsKey(origin)) {\\n          PriorityQueue<String> set = this.graph.get(origin);\\n          while (!set.isEmpty()) {\\n            this.dfs(set.poll());\\n          }\\n        }\\n        this.result.offerFirst(origin);\\n    }\\n    \\n    private void buildGraph(List<List<String>> tickets) {\\n        for(List<String> list: tickets) {\\n            PriorityQueue<String> set = graph.getOrDefault(list.get(0), new PriorityQueue<String>());\\n            set.add(list.get(1));\\n            graph.put(list.get(0), set);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<String, PriorityQueue<String>>  graph = new HashMap<>();\\n    LinkedList<String> result  = new LinkedList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        this.buildGraph(tickets);\\n        this.dfs(\"JFK\");\\n        return this.result;\\n    }\\n    \\n    private void dfs(String origin) {\\n        if (this.graph.containsKey(origin)) {\\n          PriorityQueue<String> set = this.graph.get(origin);\\n          while (!set.isEmpty()) {\\n            this.dfs(set.poll());\\n          }\\n        }\\n        this.result.offerFirst(origin);\\n    }\\n    \\n    private void buildGraph(List<List<String>> tickets) {\\n        for(List<String> list: tickets) {\\n            PriorityQueue<String> set = graph.getOrDefault(list.get(0), new PriorityQueue<String>());\\n            set.add(list.get(1));\\n            graph.put(list.get(0), set);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811482,
                "title": "java-simple-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) { \\n        Map<String,PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for(List<String> l : tickets) {\\n            if(map.containsKey(l.get(0)))\\n                map.get(l.get(0)).add(l.get(1));\\n            else {\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n                pq.add(l.get(1));\\n                map.put(l.get(0),pq);\\n            }\\n        }\\n        \\n        List<String> ans = new ArrayList<>();\\n        dfs(map, ans, \"JFK\");\\n        \\n        Collections.reverse(ans);\\n        \\n        return ans;\\n    }\\n    \\n    public static void dfs(Map<String,PriorityQueue<String>> map, List<String> ans, String index) {\\n        PriorityQueue<String> pq = map.get(index);\\n        \\n        while(pq != null && !pq.isEmpty()) {\\n            String i = pq.poll();\\n            dfs(map,ans,i);\\n        }\\n        \\n        ans.add(index);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) { \\n        Map<String,PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for(List<String> l : tickets) {\\n            if(map.containsKey(l.get(0)))\\n                map.get(l.get(0)).add(l.get(1));\\n            else {\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n                pq.add(l.get(1));\\n                map.put(l.get(0),pq);\\n            }\\n        }\\n        \\n        List<String> ans = new ArrayList<>();\\n        dfs(map, ans, \"JFK\");\\n        \\n        Collections.reverse(ans);\\n        \\n        return ans;\\n    }\\n    \\n    public static void dfs(Map<String,PriorityQueue<String>> map, List<String> ans, String index) {\\n        PriorityQueue<String> pq = map.get(index);\\n        \\n        while(pq != null && !pq.isEmpty()) {\\n            String i = pq.poll();\\n            dfs(map,ans,i);\\n        }\\n        \\n        ans.add(index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797507,
                "title": "python-east-to-read-explanation-w-graph-stacks",
                "content": "```\\n\"\"\"\\nMultiple Iternaries\\n\\nDeparts from JFK\\n\\nJFK: [SFO,ATL]\\nSFO: [ATL]\\nATL: [JFK]\\n\\nJFK: [xxx,xxx]  -> [ATL,SFO]\\nSFO: [xxx]      --> [ATL]\\nATL: [xxx,xxx]  --> [JFK,SFO]\\n** key is only visit once\\n\\nstack: [JFK,ATL,JFK,SFO,ATL,SFO]\\nwhen we see nothing is in graph -> pop it!\\n\\nIdea:\\nGRAPH + conditional Stack:\\n\\n- create directed graph start to ending locations\\n- sort the arrays lexicographically\\n- create a stack and evaulate last item on stack\\n  - get one of its edges from graph, if non exists pop it out of stack and add to output\\n  - when evaulating an edge, pop it from the graph so it doesnt get reevaluated\\n- eventually you will have empty edge for location (exhausted places to visit) and pop to output from stack.\\n- return reverse output\\n\\n\"\"\"\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        if not tickets: return []\\n        \\n        graph = defaultdict(list)\\n        \\n        for ticket in tickets:\\n            t1 = ticket[0]\\n            t2 = ticket[1]\\n            graph[t1].append(t2)\\n            if t2 not in graph:\\n                graph[t2] = []\\n        \\n        for v in graph.values():\\n            v = v.sort(reverse=True)\\n        \\n        # use stack to evaluate\\n        stack = []\\n        stack.append(\\'JFK\\')\\n        \\n        output = []\\n        while stack:\\n            curr = stack[-1]\\n            # print(\\'curr\\',curr,\\'stack\\',stack,\\'graph\\',graph[curr])\\n            if len(graph[curr]) == 0:\\n                \\n                output.append(stack.pop())\\n            else:\\n                nbr = graph[curr].pop()\\n                stack.append(nbr)\\n        # print(output)\\n        return output[::-1]\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\n\"\"\"\\nMultiple Iternaries\\n\\nDeparts from JFK\\n\\nJFK: [SFO,ATL]\\nSFO: [ATL]\\nATL: [JFK]\\n\\nJFK: [xxx,xxx]  -> [ATL,SFO]\\nSFO: [xxx]      --> [ATL]\\nATL: [xxx,xxx]  --> [JFK,SFO]\\n** key is only visit once\\n\\nstack: [JFK,ATL,JFK,SFO,ATL,SFO]\\nwhen we see nothing is in graph -> pop it!\\n\\nIdea:\\nGRAPH + conditional Stack:\\n\\n- create directed graph start to ending locations\\n- sort the arrays lexicographically\\n- create a stack and evaulate last item on stack\\n  - get one of its edges from graph, if non exists pop it out of stack and add to output\\n  - when evaulating an edge, pop it from the graph so it doesnt get reevaluated\\n- eventually you will have empty edge for location (exhausted places to visit) and pop to output from stack.\\n- return reverse output\\n\\n\"\"\"\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        if not tickets: return []\\n        \\n        graph = defaultdict(list)\\n        \\n        for ticket in tickets:\\n            t1 = ticket[0]\\n            t2 = ticket[1]\\n            graph[t1].append(t2)\\n            if t2 not in graph:\\n                graph[t2] = []\\n        \\n        for v in graph.values():\\n            v = v.sort(reverse=True)\\n        \\n        # use stack to evaluate\\n        stack = []\\n        stack.append(\\'JFK\\')\\n        \\n        output = []\\n        while stack:\\n            curr = stack[-1]\\n            # print(\\'curr\\',curr,\\'stack\\',stack,\\'graph\\',graph[curr])\\n            if len(graph[curr]) == 0:\\n                \\n                output.append(stack.pop())\\n            else:\\n                nbr = graph[curr].pop()\\n                stack.append(nbr)\\n        # print(output)\\n        return output[::-1]\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 741820,
                "title": "python-solution-faster-than-99-53-solutions-memory-usage-less-than-94-12-solutions",
                "content": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph=collections.defaultdict(list)\\n        for edge in tickets:\\n            graph[edge[0]].append(edge[1])\\n        for i in graph:\\n            graph[i].sort(reverse=True)\\n        ans=[]\\n        def visit(current):\\n            while graph[current]:\\n                visit(graph[current].pop())\\n            ans.append(current)\\n        visit(\"JFK\")\\n        return ans[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph=collections.defaultdict(list)\\n        for edge in tickets:\\n            graph[edge[0]].append(edge[1])\\n        for i in graph:\\n            graph[i].sort(reverse=True)\\n        ans=[]\\n        def visit(current):\\n            while graph[current]:\\n                visit(graph[current].pop())\\n            ans.append(current)\\n        visit(\"JFK\")\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711795,
                "title": "c-post-order-traversal-explained",
                "content": "```\\nclass Solution {//BEST1: post-order traversal + ordered set\\npublic: // Time/Space: O(NlogN), O(N)\\n    vector<string> findItinerary(vector<vector<string> > tickets) {\\n        vector<string> res;\\n        unordered_map<string, multiset<string> > m;  //this is how to represent the graph        \\n        for (auto& a : tickets)  m[a[0]].insert(a[1]);\\n        string start(\"JFK\");\\n        dfs(m, start, res);  //post-order traversal\\n        //return vector<string> (res.rbegin(), res.rend()); // ok\\n        return {res.rbegin(), res.rend()}; // better\\n    }\\n    \\n    void dfs(unordered_map<string, multiset<string> > &m, string& s, vector<string> &res) {    \\n        while (m[s].size()) {\\n            auto cur = m[s].begin();\\n            string t = *cur;\\n            m[s].erase(cur);  //cur ticket is used, so need to be removed\\n            dfs(m, t, res);\\n        }\\n        res.emplace_back(s); // since the root info is consumed in the last, so this is post-order traversal\\n    }\\n};\\n\\n```\\n\\nPython\\n```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Representing the graph as an ordered set (which is a dictionary in Python)\\n        m = defaultdict(list)\\n        \\n        # Sorting the tickets so that we can pop from the end (smallest lexical order) in O(1) time.\\n        tickets.sort(reverse=True)\\n        \\n        # Filling the dictionary\\n        for a, b in tickets:\\n            m[a].append(b)\\n        \\n        # List to store the result\\n        res = []\\n        \\n        # Post-order traversal\\n        self.dfs(m, \"JFK\", res)\\n        \\n        return res[::-1]  # Reversing to get the result\\n    \\n    def dfs(self, m: dict, s: str, res: List[str]):\\n        while m[s]:\\n            # pop() gives us the smallest lexical order while removing the ticket\\n            self.dfs(m, m[s].pop(), res)\\n        \\n        res.append(s)\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution {//BEST1: post-order traversal + ordered set\\npublic: // Time/Space: O(NlogN), O(N)\\n    vector<string> findItinerary(vector<vector<string> > tickets) {\\n        vector<string> res;\\n        unordered_map<string, multiset<string> > m;  //this is how to represent the graph        \\n        for (auto& a : tickets)  m[a[0]].insert(a[1]);\\n        string start(\"JFK\");\\n        dfs(m, start, res);  //post-order traversal\\n        //return vector<string> (res.rbegin(), res.rend()); // ok\\n        return {res.rbegin(), res.rend()}; // better\\n    }\\n    \\n    void dfs(unordered_map<string, multiset<string> > &m, string& s, vector<string> &res) {    \\n        while (m[s].size()) {\\n            auto cur = m[s].begin();\\n            string t = *cur;\\n            m[s].erase(cur);  //cur ticket is used, so need to be removed\\n            dfs(m, t, res);\\n        }\\n        res.emplace_back(s); // since the root info is consumed in the last, so this is post-order traversal\\n    }\\n};\\n\\n```\n```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Representing the graph as an ordered set (which is a dictionary in Python)\\n        m = defaultdict(list)\\n        \\n        # Sorting the tickets so that we can pop from the end (smallest lexical order) in O(1) time.\\n        tickets.sort(reverse=True)\\n        \\n        # Filling the dictionary\\n        for a, b in tickets:\\n            m[a].append(b)\\n        \\n        # List to store the result\\n        res = []\\n        \\n        # Post-order traversal\\n        self.dfs(m, \"JFK\", res)\\n        \\n        return res[::-1]  # Reversing to get the result\\n    \\n    def dfs(self, m: dict, s: str, res: List[str]):\\n        while m[s]:\\n            # pop() gives us the smallest lexical order while removing the ticket\\n            self.dfs(m, m[s].pop(), res)\\n        \\n        res.append(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710205,
                "title": "python-solution-dfs-using-stack",
                "content": "```\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        result, map_ = [], {}\\n        stack = [\"JFK\"]\\n\\n        for i in tickets:\\n            if i[0] in map_:\\n                map_[i[0]].append(i[1])\\n            else:\\n                map_[i[0]] = [i[1]]\\n        \\n        for i in map_:\\n            map_[i].sort()\\n\\n        while(stack):\\n            curr = stack[-1]\\n            if curr in map_ and len(map_[curr]) > 0:\\n                stack.append(map_[curr].pop(0))\\n            else:\\n                result.append(stack.pop())\\n        \\n        return result[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        result, map_ = [], {}\\n        stack = [\"JFK\"]\\n\\n        for i in tickets:\\n            if i[0] in map_:\\n                map_[i[0]].append(i[1])\\n            else:\\n                map_[i[0]] = [i[1]]\\n        \\n        for i in map_:\\n            map_[i].sort()\\n\\n        while(stack):\\n            curr = stack[-1]\\n            if curr in map_ and len(map_[curr]) > 0:\\n                stack.append(map_[curr].pop(0))\\n            else:\\n                result.append(stack.pop())\\n        \\n        return result[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677867,
                "title": "c-euler-s-path",
                "content": "Request you to visit the 15 minute video (link below) to get the clear picture of what\\'s happening.\\n```\\n//https://www.youtube.com/watch?v=8MpoO2zA2l4\\n//watch this video, everthing will sort out in your mind :-)\\nclass Solution{\\npublic:\\n    map<string,multiset<string>> graph;\\n    vector<string> res;\\n    void go(string d){\\n        while(graph[d].size()){\\n            auto next = *graph[d].begin();\\n            graph[d].erase(graph[d].begin());\\n            go(next);\\n        } \\n        res.push_back(d);\\n    }\\n    vector<string> findItinerary(vector<vector<string>> tickets) {\\n        for(auto& t: tickets) graph[t[0]].insert(t[1]);\\n        go(\"JFK\");\\n        return vector<string>(res.rbegin(),res.rend());\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//https://www.youtube.com/watch?v=8MpoO2zA2l4\\n//watch this video, everthing will sort out in your mind :-)\\nclass Solution{\\npublic:\\n    map<string,multiset<string>> graph;\\n    vector<string> res;\\n    void go(string d){\\n        while(graph[d].size()){\\n            auto next = *graph[d].begin();\\n            graph[d].erase(graph[d].begin());\\n            go(next);\\n        } \\n        res.push_back(d);\\n    }\\n    vector<string> findItinerary(vector<vector<string>> tickets) {\\n        for(auto& t: tickets) graph[t[0]].insert(t[1]);\\n        go(\"JFK\");\\n        return vector<string>(res.rbegin(),res.rend());\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373897,
                "title": "java-solution",
                "content": "```\\nMap<String, Queue<String>> graph = new HashMap<>();\\nList<String> ans = new LinkedList<>();\\npublic List<String> findItinerary(List<List<String>> tickets) {\\n\\tfor (List<String> ticket :\\n\\t\\t\\ttickets) {\\n\\t\\tgraph.putIfAbsent(ticket.get(0), new PriorityQueue<>(Comparator.naturalOrder()));\\n\\t\\tgraph.get(ticket.get(0)).add(ticket.get(1));\\n\\t}\\n\\n\\tdfs(\"JFK\");\\n\\treturn ans;\\n}\\n\\nprivate void dfs(String departure) {\\n\\tQueue<String> destinations = graph.get(departure);\\n\\twhile (destinations != null && !destinations.isEmpty())\\n\\t\\tdfs(destinations.poll());\\n\\tans.add(0, departure);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nMap<String, Queue<String>> graph = new HashMap<>();\\nList<String> ans = new LinkedList<>();\\npublic List<String> findItinerary(List<List<String>> tickets) {\\n\\tfor (List<String> ticket :\\n\\t\\t\\ttickets) {\\n\\t\\tgraph.putIfAbsent(ticket.get(0), new PriorityQueue<>(Comparator.naturalOrder()));\\n\\t\\tgraph.get(ticket.get(0)).add(ticket.get(1));\\n\\t}\\n\\n\\tdfs(\"JFK\");\\n\\treturn ans;\\n}\\n\\nprivate void dfs(String departure) {\\n\\tQueue<String> destinations = graph.get(departure);\\n\\twhile (destinations != null && !destinations.isEmpty())\\n\\t\\tdfs(destinations.poll());\\n\\tans.add(0, departure);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 219121,
                "title": "java-very-short-iterative-solution-using-stack-and-hashmap",
                "content": "```\\npublic List<String> findItinerary(String[][] tickets) {\\n        LinkedList<String> res = new LinkedList<>();\\n        if (tickets.length == 0) return res;\\n        \\n        Map<String, PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for (String[] ticket : tickets) {\\n            if (!map.containsKey(ticket[0])) {\\n                map.put(ticket[0], new PriorityQueue<>());\\n            }\\n            map.get(ticket[0]).offer(ticket[1]);\\n        }\\n        \\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.isEmpty()) {\\n            String top = stack.peek();\\n            if (!map.containsKey(top) || map.get(top).isEmpty()) {\\n                res.addFirst(stack.pop());\\n            } else {\\n                stack.push(map.get(top).poll());\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> findItinerary(String[][] tickets) {\\n        LinkedList<String> res = new LinkedList<>();\\n        if (tickets.length == 0) return res;\\n        \\n        Map<String, PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for (String[] ticket : tickets) {\\n            if (!map.containsKey(ticket[0])) {\\n                map.put(ticket[0], new PriorityQueue<>());\\n            }\\n            map.get(ticket[0]).offer(ticket[1]);\\n        }\\n        \\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.isEmpty()) {\\n            String top = stack.peek();\\n            if (!map.containsKey(top) || map.get(top).isEmpty()) {\\n                res.addFirst(stack.pop());\\n            } else {\\n                stack.push(map.get(top).poll());\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 188260,
                "title": "java-using-iteration-by-stack",
                "content": "```\\n/**\\n\\u975E\\u9012\\u5F52---\\u8FED\\u4EE3\\u7684\\u65B9\\u6CD5\\uFF0C\\u4F7F\\u7528\\u6808\\n*/\\n\\nclass Solution {\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String[] ticket : tickets) {\\n            String start = ticket[0];\\n            String end = ticket[1];\\n            if (!map.containsKey(start)) {\\n                map.put(start, new ArrayList<>());\\n            }\\n            map.get(start).add(end);\\n        }\\n        for (String node : map.keySet()) {\\n            Collections.sort(map.get(node));\\n        }\\n        List<String> res = new ArrayList<>();\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.isEmpty()) {\\n            String cur = stack.peek();\\n            if (map.containsKey(cur) && map.get(cur).size() > 0) {  //\\u8FD8\\u80FD\\u524D\\u8FDB\\n                String next = map.get(cur).get(0);\\n                map.get(cur).remove(0);\\n                stack.push(next);\\n            } else {  //\\u4E0D\\u80FD\\u524D\\u8FDB\\u4E86\\uFF0C\\u5219\\u51FA\\u6808\\uFF0C\\u52A0\\u5165\\u7ED3\\u679C\\n                res.add(cur);\\n                stack.pop();\\n            }\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n\\u975E\\u9012\\u5F52---\\u8FED\\u4EE3\\u7684\\u65B9\\u6CD5\\uFF0C\\u4F7F\\u7528\\u6808\\n*/\\n\\nclass Solution {\\n    public List<String> findItinerary(String[][] tickets) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String[] ticket : tickets) {\\n            String start = ticket[0];\\n            String end = ticket[1];\\n            if (!map.containsKey(start)) {\\n                map.put(start, new ArrayList<>());\\n            }\\n            map.get(start).add(end);\\n        }\\n        for (String node : map.keySet()) {\\n            Collections.sort(map.get(node));\\n        }\\n        List<String> res = new ArrayList<>();\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"JFK\");\\n        while (!stack.isEmpty()) {\\n            String cur = stack.peek();\\n            if (map.containsKey(cur) && map.get(cur).size() > 0) {  //\\u8FD8\\u80FD\\u524D\\u8FDB\\n                String next = map.get(cur).get(0);\\n                map.get(cur).remove(0);\\n                stack.push(next);\\n            } else {  //\\u4E0D\\u80FD\\u524D\\u8FDB\\u4E86\\uFF0C\\u5219\\u51FA\\u6808\\uFF0C\\u52A0\\u5165\\u7ED3\\u679C\\n                res.add(cur);\\n                stack.pop();\\n            }\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044248,
                "title": "easy-beginner-solution-c-98-users-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push(ticket[1]);\\n        }\\n        vector<string> newItinerary;\\n        stack<string> st;\\n        st.push(\"JFK\");\\n        while (!st.empty()){\\n            string currentAirport = st.top();\\n            if (graph.find(currentAirport) != graph.end() && !graph[currentAirport].empty()) {\\n                st.push(graph[currentAirport].top());\\n                graph[currentAirport].pop();\\n            } else {\\n                newItinerary.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        reverse(newItinerary.begin(), newItinerary.end());\\n        return newItinerary;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> graph;\\n        for (const auto& ticket : tickets) {\\n            graph[ticket[0]].push(ticket[1]);\\n        }\\n        vector<string> newItinerary;\\n        stack<string> st;\\n        st.push(\"JFK\");\\n        while (!st.empty()){\\n            string currentAirport = st.top();\\n            if (graph.find(currentAirport) != graph.end() && !graph[currentAirport].empty()) {\\n                st.push(graph[currentAirport].top());\\n                graph[currentAirport].pop();\\n            } else {\\n                newItinerary.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        reverse(newItinerary.begin(), newItinerary.end());\\n        return newItinerary;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043058,
                "title": "priority-queue-c-o-n-fastest-and-simplest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to construct a graph where each airport is a node, and there\\'s a directed edge from one airport to another if there is a valid flight ticket from the first airport to the second. The goal is to find a valid itinerary that visits all the airports exactly once and returns it in lexical order.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code is **Depth-First Search (DFS)** to explore possible routes. The flight function builds a graph representation of the tickets, and the dfs function performs the **DFS traversal starting from the \"JFK\" airport**. During the traversal, it keeps picking the **smallest lexical airport (due to the use of a priority queue)** from the available options and continues exploring until there are no more options. This ensures that the final ans vector will contain a **valid itinerary in lexical order**.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. Constructing the graph (in the flight function) takes **O(n)**, where n is the number of flight tickets.\\n1. The **DFS traversal** (in the dfs function) explores each airport at most once, so it takes **O(n)** time as well.\\n1. Reversing the ans vector takes **O(n)**.\\n1. Overall, the time complexity of the code is **O(n)**.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. The code uses an **unordered map f** to store the graph representation, which can take up to **O(n)** space since there can be a ticket for each unique airport.\\n1. The **priority queue** for each airport can have a maximum of n entries (in the worst case), so the space complexity of the priority queues is also **O(n)**.\\n1. The **ans vector** can also take up to **O(n)** space.\\n1. Overall, the space complexity of the code is **O(n)**.\\n\\n**In summary, the code efficiently finds a valid itinerary in lexical order using a graph representation and DFS traversal. It has a time complexity of O(n) and a space complexity of O(n).**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,priority_queue<string,vector<string>,greater<string>>>f;\\n    vector<string>ans;\\n\\n    void dfs(string dept){\\n        while(!f[dept].empty()){\\n            string to=f[dept].top();\\n            f[dept].pop();\\n            dfs(to);\\n        }\\n        ans.push_back(dept);\\n    }\\n\\n    void flight(vector<vector<string>> &tickets){\\n        for(auto &it: tickets){\\n            string from=it[0];\\n            string to=it[1];\\n            f[from].push(to);\\n        }\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        flight(tickets);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(),ans.end());\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,priority_queue<string,vector<string>,greater<string>>>f;\\n    vector<string>ans;\\n\\n    void dfs(string dept){\\n        while(!f[dept].empty()){\\n            string to=f[dept].top();\\n            f[dept].pop();\\n            dfs(to);\\n        }\\n        ans.push_back(dept);\\n    }\\n\\n    void flight(vector<vector<string>> &tickets){\\n        for(auto &it: tickets){\\n            string from=it[0];\\n            string to=it[1];\\n            f[from].push(to);\\n        }\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        flight(tickets);\\n        dfs(\"JFK\");\\n        reverse(ans.begin(),ans.end());\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042259,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private void dfs(String s, Map<String, PriorityQueue<String>> map, LinkedList<String> list){\\n\\n        PriorityQueue<String> pq = map.get(s);\\n\\n        while(pq!=null && !pq.isEmpty()){\\n\\n            dfs(pq.poll(), map, list);\\n\\n        }\\n\\n        list.addFirst(s);\\n\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        HashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\n        for(int i=0; i<tickets.size(); i++){\\n\\n            if(!map.containsKey(tickets.get(i).get(0))){\\n\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n\\n                map.put(tickets.get(i).get(0), pq);\\n\\n            }\\n\\n            map.get(tickets.get(i).get(0)).add(tickets.get(i).get(1));\\n\\n        } \\n\\n        LinkedList<String> list = new LinkedList<>();\\n\\n        dfs(\"JFK\", map, list);\\n\\n        return list;\\n\\n    }\\n\\n}\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private void dfs(String s, Map<String, PriorityQueue<String>> map, LinkedList<String> list){\\n\\n        PriorityQueue<String> pq = map.get(s);\\n\\n        while(pq!=null && !pq.isEmpty()){\\n\\n            dfs(pq.poll(), map, list);\\n\\n        }\\n\\n        list.addFirst(s);\\n\\n    }\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        HashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\n        for(int i=0; i<tickets.size(); i++){\\n\\n            if(!map.containsKey(tickets.get(i).get(0))){\\n\\n                PriorityQueue<String> pq = new PriorityQueue<>();\\n\\n                map.put(tickets.get(i).get(0), pq);\\n\\n            }\\n\\n            map.get(tickets.get(i).get(0)).add(tickets.get(i).get(1));\\n\\n        } \\n\\n        LinkedList<String> list = new LinkedList<>();\\n\\n        dfs(\"JFK\", map, list);\\n\\n        return list;\\n\\n    }\\n\\n}\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973238,
                "title": "c-fast-code-18ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define pq priority_queue<string,vector<string>,greater<string>>\\n    map<string,pq>mp;\\n    vector<string>ans;\\n    void dfs(string start){\\n        if(mp[start].size()==0){\\n            ans.push_back(start);\\n            return;\\n        }\\n\\n        auto &s=mp[start];\\n\\n        while(!s.empty()){\\n            auto temp=s.top();\\n            s.pop();\\n\\n            dfs(temp);\\n        }   \\n        ans.push_back(start);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        mp.clear();\\n        ans.clear();\\n        \\n        for(auto i:tickets){\\n            mp[i[0]].push(i[1]);\\n        }\\n\\n        dfs(\"JFK\");\\n\\n        reverse(ans.begin(),end(ans));\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Ordered Set",
                    "Eulerian Circuit"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define pq priority_queue<string,vector<string>,greater<string>>\\n    map<string,pq>mp;\\n    vector<string>ans;\\n    void dfs(string start){\\n        if(mp[start].size()==0){\\n            ans.push_back(start);\\n            return;\\n        }\\n\\n        auto &s=mp[start];\\n\\n        while(!s.empty()){\\n            auto temp=s.top();\\n            s.pop();\\n\\n            dfs(temp);\\n        }   \\n        ans.push_back(start);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        mp.clear();\\n        ans.clear();\\n        \\n        for(auto i:tickets){\\n            mp[i[0]].push(i[1]);\\n        }\\n\\n        dfs(\"JFK\");\\n\\n        reverse(ans.begin(),end(ans));\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490774,
                "title": "easiest-more-optimized-javascript-solution-with-full-explanation",
                "content": "```\\nPlease Up-Vote If This Helps You. Thanks In Advance .\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code implements a solution to find the itinerary of a traveler given a list of flight tickets represented as a two-dimensional array, where each element of the array represents a flight ticket from one airport to another.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code is to first build a map of all the possible destinations for each airport. Then, starting from the initial airport JFK, the code performs a depth-first search (DFS) to visit all the airports in the itinerary in a lexicographically sorted order, i.e., if there are multiple destinations available from an airport, then the code picks the one that comes first in alphabetical order. The itinerary is stored in the res array, which is then reversed and returned as the final answer.\\n\\n# Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The first for-loop runs through all the tickets once, therefore takes `O(n)` time where n is the number of tickets.\\n- The second for-loop iterates through each airport in the map and sorts the destinations. The time complexity of the sorting operation is `O(m log m)` where m is the number of destinations for an airport. Since the total number of destinations across all airports is equal to n-1 (where n is the total number of tickets), the time complexity of this loop is `O(n log n)`.\\n- The DFS function is called once for each airport in the map, which takes `O(m)` time where m is the number of destinations for an airport. Since the total number of destinations across all airports is equal to n-1, the time complexity of this function is `O(n)`.\\n- Finally, reversing the res array takes `O(n)` time.\\n\\n\\nTherefore, the overall time complexity of the code is **`O(n log n)`**, where n is the number of tickets.\\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of the code is dominated by the map object, which stores the destinations for each airport. Since there are n distinct airports, the space complexity of the map is `O(n).`\\n- The DFS function uses a recursive call stack, which can have a depth of up to n, therefore the space complexity of the DFS function is `O(n)`.\\n- The res array stores the itinerary, which can have a maximum size of n+1, therefore the space complexity of the res array is also `O(n)`.\\n- The rest of the variables used in the code have constant space complexity.\\n\\nTherefore, the overall space complexity of the code is `O(n)`.\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    var map = {};\\n    var res = [];\\n    for(var i=0; i<tickets.length; i++) {\\n        var dep = tickets[i][0];\\n        var des = tickets[i][1];\\n        if(map[dep]) {\\n            map[dep].push(des);\\n        } else {\\n            map[dep] = [des];\\n        }\\n    }\\n    for(let loc in map) {\\n        map[loc].sort();\\n    }  \\n    var dfs = function(node) {\\n        var des = map[node];\\n        while(des && des.length>0) {\\n            dfs(des.shift());\\n        }\\n        res.push(node);\\n    }\\n    dfs(\\'JFK\\');\\n    return res.reverse();\\n};\\n```\\n\\n\\n> # My Section\\n```\\nThanks For Reading This Solution . \\n\\nNow You Can Solve This Problem .\\n \\nHope You Will Give A Up-Vote To My Solution .\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nPlease Up-Vote If This Helps You. Thanks In Advance .\\n```\n```\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    var map = {};\\n    var res = [];\\n    for(var i=0; i<tickets.length; i++) {\\n        var dep = tickets[i][0];\\n        var des = tickets[i][1];\\n        if(map[dep]) {\\n            map[dep].push(des);\\n        } else {\\n            map[dep] = [des];\\n        }\\n    }\\n    for(let loc in map) {\\n        map[loc].sort();\\n    }  \\n    var dfs = function(node) {\\n        var des = map[node];\\n        while(des && des.length>0) {\\n            dfs(des.shift());\\n        }\\n        res.push(node);\\n    }\\n    dfs(\\'JFK\\');\\n    return res.reverse();\\n};\\n```\n```\\nThanks For Reading This Solution . \\n\\nNow You Can Solve This Problem .\\n \\nHope You Will Give A Up-Vote To My Solution .\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2817769,
                "title": "c-dfs-19ms-beats-98-8-13-6-beats-97-12",
                "content": "[@ayush_gupta4](https://leetcode.com/ayush_gupta4/) proposed this [method](https://leetcode.com/problems/reconstruct-itinerary/solutions/2769245/c-easy-solution-min-heap-dfs/) and I refactor the code.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static vector<string> findItinerary(const vector<vector<string>>& tickets) {\\n        vector<string> ret;\\n        unordered_map<string_view, priority_queue<string_view, vector<string_view>, greater<>>> adj;\\n        for (auto& x : tickets)\\n            adj[x[0]].emplace(x[1]);\\n        \\n        function<void(string_view)> dfs = [&] (string_view curr) {\\n            auto& adj_nodes = adj[curr];\\n            while (!adj_nodes.empty()) {\\n                auto temp = adj_nodes.top();\\n                adj_nodes.pop();\\n                dfs(temp);\\n            }\\n            ret.emplace_back(curr);\\n        };\\n\\n        dfs(\"JFK\");\\n        reverse(begin(ret), end(ret));\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static vector<string> findItinerary(const vector<vector<string>>& tickets) {\\n        vector<string> ret;\\n        unordered_map<string_view, priority_queue<string_view, vector<string_view>, greater<>>> adj;\\n        for (auto& x : tickets)\\n            adj[x[0]].emplace(x[1]);\\n        \\n        function<void(string_view)> dfs = [&] (string_view curr) {\\n            auto& adj_nodes = adj[curr];\\n            while (!adj_nodes.empty()) {\\n                auto temp = adj_nodes.top();\\n                adj_nodes.pop();\\n                dfs(temp);\\n            }\\n            ret.emplace_back(curr);\\n        };\\n\\n        dfs(\"JFK\");\\n        reverse(begin(ret), end(ret));\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360823,
                "title": "hierholzer-algorithm-short-implementation-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    stack<string> s;\\n    map<string, queue<string>> adj;\\n    \\n    void hierthing(string &src){\\n        // pushing to stack\\n        s.push(src);\\n        \\n        // recursing till outdegree is 0\\n        while (!adj[src].empty()){\\n            string v = adj[src].front();\\n            adj[src].pop();\\n            hierthing(v);\\n        }\\n        \\n        // popping from stack and adding to the answer\\n        ans.push_back(s.top());\\n        s.pop();\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // sorting to ensure lexical order\\n        sort(tickets.begin(), tickets.end());\\n        \\n        for (auto trip: tickets){\\n            // pushing destination to a queue\\n            adj[trip[0]].push(trip[1]);\\n        }\\n        \\n        string s = \"JFK\";\\n        hierthing(s);\\n        \\n        // reversed answer\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    stack<string> s;\\n    map<string, queue<string>> adj;\\n    \\n    void hierthing(string &src){\\n        // pushing to stack\\n        s.push(src);\\n        \\n        // recursing till outdegree is 0\\n        while (!adj[src].empty()){\\n            string v = adj[src].front();\\n            adj[src].pop();\\n            hierthing(v);\\n        }\\n        \\n        // popping from stack and adding to the answer\\n        ans.push_back(s.top());\\n        s.pop();\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // sorting to ensure lexical order\\n        sort(tickets.begin(), tickets.end());\\n        \\n        for (auto trip: tickets){\\n            // pushing destination to a queue\\n            adj[trip[0]].push(trip[1]);\\n        }\\n        \\n        string s = \"JFK\";\\n        hierthing(s);\\n        \\n        // reversed answer\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607024,
                "title": "neetcode-video-translation",
                "content": "```\\nclass Solution {\\n    bool dfs(string src, unordered_map<string, multiset<string>>& adj, vector<string>& res, const int num_tickets)\\n    {\\n        if(res.size() == (num_tickets + 1))\\n        {\\n            return true;\\n        }\\n        if (!adj.count(src)) return false;\\n        multiset<string> temp = adj[src];\\n        for(auto v: temp){\\n            adj[src].erase(adj[src].find(v));\\n            res.push_back(v);\\n            if(dfs(v, adj, res, num_tickets))\\n               return true;\\n            adj[src].insert(v);\\n            res.pop_back();\\n        }\\n        \\n        return false;  \\n    }\\n    \\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> adj;\\n        for(auto ticket: tickets)\\n        {\\n            adj[ticket[0]].insert(ticket[1]);\\n        }\\n        vector<string> res;\\n        res.push_back(\"JFK\");\\n        dfs(\"JFK\", adj, res, tickets.size());\\n        return res;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    bool dfs(string src, unordered_map<string, multiset<string>>& adj, vector<string>& res, const int num_tickets)\\n    {\\n        if(res.size() == (num_tickets + 1))\\n        {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1478509,
                "title": "straight-forward-dfs-solution-without-a-separate-visited-array",
                "content": "I have explained in comments on almost each line explaining why I am doing that.\\nThe basic logic is to DFS from all points, starting from JFK and find an itinerary where all tickets are exhausted, (visited all edges in other words).  \\nBut since there could be multiple answers, and we need return the intinerary that occurs first in lexical order, I have sorted that tickets in adjaceny list before starting the DFS and hence at every point when we decide the next stop, we always choose the destination that occurs first in lexical order greedily, and once we get the first solution, that will be the first one.\\nA small optimization I did instead of having a seperate visited array is to alter the adjacency list once we use a ticket, and fix it back once checking the possibility for exploring other possibilities, while backtracking.\\n\\n```\\nclass Solution:\\n    def checkPaths(self, adjList,start, res, totalTickets, stack = []):\\n        stack.append(start)\\n        if len(stack) == totalTickets and not res:  # if no itenerary has been found yet and if len is number of tickets.\\n            res.append(stack) \\n            return  # we got the answer.\\n        for i, nextPoint in enumerate(adjList[start]):\\n            if nextPoint != -1:\\n                adjList[start][i] = -1 # ticket has been used\\n                self.checkPaths(adjList, nextPoint, res, totalTickets, stack)\\n                adjList[start][i] = nextPoint # add it back after exploring if that option worked.\\n            if res: return  # if we found the route, then return no need to check for more possibilities.\\n        stack.pop()\\n            \\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # build adjacency list in sorted order. It always helps us select the lexical order, \\n        # and if we exhaust all ticket, thats the itinerary first in lexical order.\\n        tickets.sort() # O(ELOGE)\\n        adjList = collections.defaultdict(list)\\n        for s,d in tickets: adjList[s].append(d)\\n        res = []\\n        totalTickets = len(tickets) + 1\\n        start = \\'JFK\\'\\n        self.checkPaths(adjList, start, res, totalTickets, []) # DFS from JFK to all destination.\\n        return res[0]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def checkPaths(self, adjList,start, res, totalTickets, stack = []):\\n        stack.append(start)\\n        if len(stack) == totalTickets and not res:  # if no itenerary has been found yet and if len is number of tickets.\\n            res.append(stack) \\n            return  # we got the answer.\\n        for i, nextPoint in enumerate(adjList[start]):\\n            if nextPoint != -1:\\n                adjList[start][i] = -1 # ticket has been used\\n                self.checkPaths(adjList, nextPoint, res, totalTickets, stack)\\n                adjList[start][i] = nextPoint # add it back after exploring if that option worked.\\n            if res: return  # if we found the route, then return no need to check for more possibilities.\\n        stack.pop()\\n            \\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # build adjacency list in sorted order. It always helps us select the lexical order, \\n        # and if we exhaust all ticket, thats the itinerary first in lexical order.\\n        tickets.sort() # O(ELOGE)\\n        adjList = collections.defaultdict(list)\\n        for s,d in tickets: adjList[s].append(d)\\n        res = []\\n        totalTickets = len(tickets) + 1\\n        start = \\'JFK\\'\\n        self.checkPaths(adjList, start, res, totalTickets, []) # DFS from JFK to all destination.\\n        return res[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477207,
                "title": "c-solution-for-332-reconstruct-itinerary",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string,priority_queue<string, vector<string>, greater<string>>> umap;\\n    \\n    void dfs(string s)\\n    {\\n        while(!umap[s].empty())\\n        {\\n            auto node = umap[s].top();// cout<<node<<endl;\\n            umap[s].pop();\\n            dfs(node);\\n        }\\n        ans.push_back(s);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) \\n    {\\n        for(auto str : tickets)\\n        {\\n            umap[str[0]].push(str[1]);\\n        }\\n        string src = \"JFK\" ;\\n        dfs(src);\\n        reverse(ans.begin(), ans.end());\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    unordered_map<string,priority_queue<string, vector<string>, greater<string>>> umap;\\n    \\n    void dfs(string s)\\n    {\\n        while(!umap[s].empty())\\n        {\\n            auto node = umap[s].top();// cout<<node<<endl;\\n            umap[s].pop();\\n            dfs(node);\\n        }\\n        ans.push_back(s);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& tickets) \\n    {\\n        for(auto str : tickets)\\n        {\\n            umap[str[0]].push(str[1]);\\n        }\\n        string src = \"JFK\" ;\\n        dfs(src);\\n        reverse(ans.begin(), ans.end());\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1394684,
                "title": "a-solution-dfs-in-python",
                "content": "```\\n\\ndef findItinerary(tickets):\\n    graph = {}\\n\\n    tickets.sort(key=lambda x: x[1])\\n    expected = len(tickets) + 1\\n\\n    for index in range(len(tickets)):\\n        ticket = tickets[index]\\n        frm = ticket[0]\\n        to = ticket[1]\\n\\n        if frm not in graph:\\n            graph[frm] = []\\n        if to not in graph:\\n            graph[to] = []\\n        graph[frm].append((to, \\'{}{}\\'.format(index,to)))\\n\\n    def dfs(node, path, visited):\\n\\n        if len(path) == expected:\\n\\n            return path\\n\\n        for info in graph[node]:\\n            neighbor, _id = info\\n\\n            edge = (node, _id)\\n            if edge not in visited:\\n                visited.add(edge)\\n                path.append(neighbor)\\n                potential = dfs(neighbor, path, visited)\\n\\n                if potential:\\n                    return potential\\n\\n                visited.remove(edge)\\n                path.pop()\\n\\n        return None\\n\\n    return dfs(\"JFK\", [\"JFK\"], set())\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\ndef findItinerary(tickets):\\n    graph = {}\\n\\n    tickets.sort(key=lambda x: x[1])\\n    expected = len(tickets) + 1\\n\\n    for index in range(len(tickets)):\\n        ticket = tickets[index]\\n        frm = ticket[0]\\n        to = ticket[1]\\n\\n        if frm not in graph:\\n            graph[frm] = []\\n        if to not in graph:\\n            graph[to] = []\\n        graph[frm].append((to, \\'{}{}\\'.format(index,to)))\\n\\n    def dfs(node, path, visited):\\n\\n        if len(path) == expected:\\n\\n            return path\\n\\n        for info in graph[node]:\\n            neighbor, _id = info\\n\\n            edge = (node, _id)\\n            if edge not in visited:\\n                visited.add(edge)\\n                path.append(neighbor)\\n                potential = dfs(neighbor, path, visited)\\n\\n                if potential:\\n                    return potential\\n\\n                visited.remove(edge)\\n                path.pop()\\n\\n        return None\\n\\n    return dfs(\"JFK\", [\"JFK\"], set())\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1316171,
                "title": "using-hierholzer-s-algorithm-for-euler-path-in-python",
                "content": "Eulerian path/circuit: a path in a graph that traverse every edge exactly once. This is what the question is asking for. Only twist is that you need to ensure lexicographical order (which we do by sorting the adjacency list).\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # 206-219 (13min)\\n\\t\\t# starts at JFK\\n        # if multiple, return one with smallest lexographical order\\n        \\n        # 1. Create digraph where edge (u,v) represents flight from u->v\\n        # 2. Find a path that goes along every edge (Eulerian path/circuit)\\n            # use Hierholzer\\'s algorithm\\n            # if multiple options, choose lexo smallest (i.e. ATL over SFO)\\n            \\n            \\n        #1\\n        \\n        adj_list = {} # rly a map\\n        \\n        for t in tickets:\\n            if t[0] in adj_list:\\n                adj_list[t[0]].append(t[1])\\n            else:\\n                adj_list[t[0]] = [t[1]]\\n                \\n        for airport in adj_list:\\n            adj_list[airport].sort(reverse=True)\\n            \\n        #2 Hierholzer\\n        \\n        stack = [\"JFK\"]\\n        path = []\\n        while len(stack) > 0:\\n            t = stack[-1]\\n            if t not in adj_list or len(adj_list[t]) == 0:\\n                path.append(t)\\n                stack.pop()\\n            else:\\n                stack.append(adj_list[t][-1])\\n                adj_list[t].pop()                \\n        \\n        path.reverse()\\n        return path\\n    \\n```\\n        \\n\\t`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # 206-219 (13min)\\n\\t\\t# starts at JFK\\n        # if multiple, return one with smallest lexographical order\\n        \\n        # 1. Create digraph where edge (u,v) represents flight from u->v\\n        # 2. Find a path that goes along every edge (Eulerian path/circuit)\\n            # use Hierholzer\\'s algorithm\\n            # if multiple options, choose lexo smallest (i.e. ATL over SFO)\\n            \\n            \\n        #1\\n        \\n        adj_list = {} # rly a map\\n        \\n        for t in tickets:\\n            if t[0] in adj_list:\\n                adj_list[t[0]].append(t[1])\\n            else:\\n                adj_list[t[0]] = [t[1]]\\n                \\n        for airport in adj_list:\\n            adj_list[airport].sort(reverse=True)\\n            \\n        #2 Hierholzer\\n        \\n        stack = [\"JFK\"]\\n        path = []\\n        while len(stack) > 0:\\n            t = stack[-1]\\n            if t not in adj_list or len(adj_list[t]) == 0:\\n                path.append(t)\\n                stack.pop()\\n            else:\\n                stack.append(adj_list[t][-1])\\n                adj_list[t].pop()                \\n        \\n        path.reverse()\\n        return path\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257561,
                "title": "hashmap-solution-in-java-and-c-with-explanation",
                "content": "**Explanation**\\n```\\nThis is the variation of dfs.\\nThe way to tweak the dfs is to not to put a base condition and let the dfs fill and tsack and empty itslef\\nWhat i mean by this is \\n\\nInput: [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\\nLets say we built a graph of this and its adjacenecy list look like this:-\\nJFK - MUC\\nMUC - LHR\\nLHR - SFO\\nSFO - SJC\\n\\nSo when we perform a dfs on JFK\\n\\n|        |\\n|        |\\n|        |   <-----Recursion Stack\\n|        |\\n|__JFK___|\\n\\nWe explore JFKs neighbors \\n\\n|        |\\n|        |\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\nWe explore Muc neighbors\\n\\n|        |\\n|        |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|  SJC   |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\nSince SJC has no neighbors we pus it back to the answer\\n\\n|        |\\n|  SFO   |      ans=SJC\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC \\n|        |\\n|        |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC,JFK \\n|        |\\n|        |\\n|________|\\n\\n```\\n**Java**\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n        for (List<String> i: tickets)\\n            map.computeIfAbsent(i.get(0), k -> new PriorityQueue<>()).add(i.get(1));\\n        Stack<String> st = new Stack<>();\\n        List<String> ans = new ArrayList<>();\\n        st.add(\"JFK\");\\n        while (!st.empty()) {\\n            while ( map.containsKey(st.peek()) && !map.get(st.peek()).isEmpty() ) {\\n                st.push(map.get(st.peek()).poll());\\n            }\\n            ans.add(0, st.pop());\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>> map;\\n    vector<string> ans;\\n    void dfs(string s) {\\n        auto &x = map[s];\\n        while (!x.empty()) {\\n            string val = x.top();\\n            x.pop();\\n            dfs(val);\\n        }\\n        ans.insert(ans.begin(), s);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (auto &i: tickets)\\n            map[i[0]].push(i[1]);\\n        dfs(\"JFK\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nThis is the variation of dfs.\\nThe way to tweak the dfs is to not to put a base condition and let the dfs fill and tsack and empty itslef\\nWhat i mean by this is \\n\\nInput: [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\\nLets say we built a graph of this and its adjacenecy list look like this:-\\nJFK - MUC\\nMUC - LHR\\nLHR - SFO\\nSFO - SJC\\n\\nSo when we perform a dfs on JFK\\n\\n|        |\\n|        |\\n|        |   <-----Recursion Stack\\n|        |\\n|__JFK___|\\n\\nWe explore JFKs neighbors \\n\\n|        |\\n|        |\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\nWe explore Muc neighbors\\n\\n|        |\\n|        |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|  SJC   |\\n|  SFO   |\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\nSince SJC has no neighbors we pus it back to the answer\\n\\n|        |\\n|  SFO   |      ans=SJC\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO\\n|  LHR   |\\n|  MUC   |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR\\n|        |\\n|  MUC   |\\n|__JFK___|\\n\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC \\n|        |\\n|        |\\n|__JFK___|\\n\\n|        |\\n|        |      ans=SJC,SFO,LHR,MUC,JFK \\n|        |\\n|        |\\n|________|\\n\\n```\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n        for (List<String> i: tickets)\\n            map.computeIfAbsent(i.get(0), k -> new PriorityQueue<>()).add(i.get(1));\\n        Stack<String> st = new Stack<>();\\n        List<String> ans = new ArrayList<>();\\n        st.add(\"JFK\");\\n        while (!st.empty()) {\\n            while ( map.containsKey(st.peek()) && !map.get(st.peek()).isEmpty() ) {\\n                st.push(map.get(st.peek()).poll());\\n            }\\n            ans.add(0, st.pop());\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, priority_queue<string, vector<string>, greater<string>>> map;\\n    vector<string> ans;\\n    void dfs(string s) {\\n        auto &x = map[s];\\n        while (!x.empty()) {\\n            string val = x.top();\\n            x.pop();\\n            dfs(val);\\n        }\\n        ans.insert(ans.begin(), s);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        for (auto &i: tickets)\\n            map[i[0]].push(i[1]);\\n        dfs(\"JFK\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212542,
                "title": "python-3-simple-using-hierholzer-s-algorithm-with-comments",
                "content": "```python\\ndef findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        res = deque()\\n        \\n\\t\\t# build graph\\n        for u,v in tickets:\\n            graph[u].append(v)\\n        \\n\\t\\t# sort outgoing edges in order to process in lexicographical order\\n        for u in graph:\\n            graph[u].sort(reverse=True)\\n        \\n\\t\\t# start from \\'JFK\\', dfs on outgoing edges and append current when there are no more outgoing edges\\n        def dfs(u=\\'JFK\\'):\\n            while graph[u]:\\n                dfs(graph[u].pop())\\n            res.appendleft(u)\\n              \\n        dfs()\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = defaultdict(list)\\n        res = deque()\\n        \\n\\t\\t# build graph\\n        for u,v in tickets:\\n            graph[u].append(v)\\n        \\n\\t\\t# sort outgoing edges in order to process in lexicographical order\\n        for u in graph:\\n            graph[u].sort(reverse=True)\\n        \\n\\t\\t# start from \\'JFK\\', dfs on outgoing edges and append current when there are no more outgoing edges\\n        def dfs(u=\\'JFK\\'):\\n            while graph[u]:\\n                dfs(graph[u].pop())\\n            res.appendleft(u)\\n              \\n        dfs()\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1204313,
                "title": "c-dfs-explained",
                "content": "It is understood that we have a directed graph. The basic requirement of the question is a **path that traverses all the edges** and it should be **lexographically smallest path.**\\nThus we would be using DFS based approach. We should start from the starting node \"JFK\" and keep moving deep into the graph until we encounter a **DEAD END**\\nBy DEAD END we mean a node which either has no edges directing out from it ( *outDegree = 0* ) or it has no edges directing out from it which havent been included in the path already.\\nIn both the case, this very node would be our last node in the itinerary and thus we would push it in the stack. \\nFollowing the recursive approach, we do this for the entire path from that node onwards. \\nFinally we reverse the stack and output the path.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // build graph (mapping each string node to an interger)\\n        unordered_map<string,int> umap; //mapping: string node -> int node\\n        vector<string> mapping; // stores all the nodes as strings\\n        for(int i = 0; i<tickets.size(); i++){\\n            if(umap.find(tickets[i][0])==umap.end()){// using umap to check if the node has been added already\\n                umap[tickets[i][0]]=1;\\n                mapping.push_back(tickets[i][0]);\\n            }\\n            if(umap.find(tickets[i][1])==umap.end()){// using umap to check if the node has been added already\\n                umap[tickets[i][1]]=1;\\n                mapping.push_back(tickets[i][1]);\\n            }\\n        }\\n        // now mapping stores all the DISTINCT nodes as strings\\n        sort(mapping.begin(), mapping.end()); // sorting the nodes lexographically\\n        int n = mapping.size(); // n = number of nodes\\n        unordered_map<int,string> umap1; // mapping: int node -> string node\\n        for(int i = 0; i<n; i++){ //generating the map\\n            umap[mapping[i]]=i;\\n            umap1[i]=mapping[i];\\n        }\\n        int startNode = umap[\"JFK\"];// declaring the starting node (mapping it from string to int)\\n        vector<pair<int,int> > adj[n]; // pair<int, int> = pair<next node, visited/notvisited (1/0)>\\n        // building the graph\\n        for(int i = 0; i<tickets.size(); i++){\\n            int u = umap[tickets[i][0]];\\n            int v = umap[tickets[i][1]];\\n            adj[u].push_back(make_pair(v,1));\\n        }\\n        // sorting all adjacent nodes lexographically\\n        for(int i = 0; i<n; i++){\\n            sort(adj[i].begin(),adj[i].end());\\n        }\\n        stack<int> ans; // to store the path\\n        dfs(startNode,adj,ans);\\n        vector<string> an;\\n        while(!ans.empty()){\\n            an.push_back(umap1[ans.top()]);\\n            ans.pop();\\n        }\\n        return an;\\n    }\\nprivate:\\n    void dfs(int node, vector<pair<int,int> > adj[], stack<int> &ans){\\n        for(int i = 0; i<adj[node].size(); i++){\\n            if(adj[node][i].second){\\n                adj[node][i].second=0; //marking the edge visited\\n                dfs(adj[node][i].first,adj,ans);\\n            }\\n        }\\n        ans.push(node);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        // build graph (mapping each string node to an interger)\\n        unordered_map<string,int> umap; //mapping: string node -> int node\\n        vector<string> mapping; // stores all the nodes as strings\\n        for(int i = 0; i<tickets.size(); i++){\\n            if(umap.find(tickets[i][0])==umap.end()){// using umap to check if the node has been added already\\n                umap[tickets[i][0]]=1;\\n                mapping.push_back(tickets[i][0]);\\n            }\\n            if(umap.find(tickets[i][1])==umap.end()){// using umap to check if the node has been added already\\n                umap[tickets[i][1]]=1;\\n                mapping.push_back(tickets[i][1]);\\n            }\\n        }\\n        // now mapping stores all the DISTINCT nodes as strings\\n        sort(mapping.begin(), mapping.end()); // sorting the nodes lexographically\\n        int n = mapping.size(); // n = number of nodes\\n        unordered_map<int,string> umap1; // mapping: int node -> string node\\n        for(int i = 0; i<n; i++){ //generating the map\\n            umap[mapping[i]]=i;\\n            umap1[i]=mapping[i];\\n        }\\n        int startNode = umap[\"JFK\"];// declaring the starting node (mapping it from string to int)\\n        vector<pair<int,int> > adj[n]; // pair<int, int> = pair<next node, visited/notvisited (1/0)>\\n        // building the graph\\n        for(int i = 0; i<tickets.size(); i++){\\n            int u = umap[tickets[i][0]];\\n            int v = umap[tickets[i][1]];\\n            adj[u].push_back(make_pair(v,1));\\n        }\\n        // sorting all adjacent nodes lexographically\\n        for(int i = 0; i<n; i++){\\n            sort(adj[i].begin(),adj[i].end());\\n        }\\n        stack<int> ans; // to store the path\\n        dfs(startNode,adj,ans);\\n        vector<string> an;\\n        while(!ans.empty()){\\n            an.push_back(umap1[ans.top()]);\\n            ans.pop();\\n        }\\n        return an;\\n    }\\nprivate:\\n    void dfs(int node, vector<pair<int,int> > adj[], stack<int> &ans){\\n        for(int i = 0; i<adj[node].size(); i++){\\n            if(adj[node][i].second){\\n                adj[node][i].second=0; //marking the edge visited\\n                dfs(adj[node][i].first,adj,ans);\\n            }\\n        }\\n        ans.push(node);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069543,
                "title": "java-hierholzer-algorithm-beats-99-64-4ms-o-tickets-length-log-tickets-length",
                "content": "\\n    \\n    // O(tickets.length*log(tickets.length))\\n\\tpublic List<String> findItinerary(List<List<String>> tickets) {\\n\\n\\t\\tHashMap<String, PriorityQueue<String>> graph = new HashMap<String, PriorityQueue<String>>();\\n\\t\\tfor (List<String> ticket : tickets) {\\n\\t\\t\\tString from = ticket.get(0);\\n\\t\\t\\tString to = ticket.get(1);\\n\\t\\t\\tif (!graph.containsKey(from))\\n\\t\\t\\t\\tgraph.put(from, new PriorityQueue<String>());\\n\\t\\t\\tgraph.get(from).add(to);\\n\\t\\t}\\n\\t\\tLinkedList<String> eularianPath = new LinkedList<String>();\\n\\t\\tHierHolzer(graph, \"JFK\", eularianPath);\\n\\t\\treturn eularianPath;\\n\\t}\\n\\n\\t// O(tickets.length*log(tickets.length))\\n\\tpublic void HierHolzer(HashMap<String, PriorityQueue<String>> graph, String curr, LinkedList<String> eularianPath) {\\n\\n\\t\\tPriorityQueue<String> heap = graph.get(curr);\\n\\t\\twhile (heap != null && heap.size() != 0) {\\n\\t\\t\\tString temp = heap.poll();\\n\\t\\t\\tHierHolzer(graph, temp, eularianPath);\\n\\t\\t}\\n\\t\\teularianPath.addFirst(curr);\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    \\n    // O(tickets.length*log(tickets.length))\\n\\tpublic List<String> findItinerary(List<List<String>> tickets) {\\n\\n\\t\\tHashMap<String, PriorityQueue<String>> graph = new HashMap<String, PriorityQueue<String>>();\\n\\t\\tfor (List<String> ticket : tickets) {\\n\\t\\t\\tString from = ticket.get(0);\\n\\t\\t\\tString to = ticket.get(1);\\n\\t\\t\\tif (!graph.containsKey(from))\\n\\t\\t\\t\\tgraph.put(from, new PriorityQueue<String>());\\n\\t\\t\\tgraph.get(from).add(to);\\n\\t\\t}\\n\\t\\tLinkedList<String> eularianPath = new LinkedList<String>();\\n\\t\\tHierHolzer(graph, \"JFK\", eularianPath);\\n\\t\\treturn eularianPath;\\n\\t}\\n\\n\\t// O(tickets.length*log(tickets.length))\\n\\tpublic void HierHolzer(HashMap<String, PriorityQueue<String>> graph, String curr, LinkedList<String> eularianPath) {\\n\\n\\t\\tPriorityQueue<String> heap = graph.get(curr);\\n\\t\\twhile (heap != null && heap.size() != 0) {\\n\\t\\t\\tString temp = heap.poll();\\n\\t\\t\\tHierHolzer(graph, temp, eularianPath);\\n\\t\\t}\\n\\t\\teularianPath.addFirst(curr);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1036205,
                "title": "topological-sort",
                "content": "```\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n//1.to have the adjacency list in sorted order we have used a priority queue.. this will resolve the problem of     lexographical order. you can dry run any tc in you will get it.\\n        HashMap<String,PriorityQueue<String>> map=new HashMap<>();\\n   \\n  //2. I have make the adjaceny list. I have add all the from(source) in my hashmap and corrosponding to that added to(destination) also..     \\n       for(List<String> ticket:tickets){\\n           String from=ticket.get(0);\\n           String to=ticket.get(1);\\n           \\n           if(map.containsKey(from)){\\n               map.get(from).add(to);\\n           }else{\\n               PriorityQueue<String> pq=new PriorityQueue<>();\\n               pq.add(to);\\n               map.put(from,pq);\\n           }\\n       }\\n        \\n      //3. I have used ArrayList here to return the list. can use linkedlist also to avoid the collection.reverse in line after topological sort(can use addFirst in linkedlist to avoid reverse).. but i have used arraylist here\\n        List<String> list=new ArrayList<>();\\n        topological_sort(map,\"JFK\",list);\\n        \\n        Collections.reverse(list);\\n        return list;\\n    }\\n    \\n    public static void topological_sort(HashMap<String,PriorityQueue<String>> map,String src,List<String> list){\\n  \\n            PriorityQueue<String> pq=map.get(src);\\n //4. we know that if there is something not present in map then map return null value.. so i have used pq!=null and if the size==0 means we have iterated all the neighbours..      \\n            while(pq!=null && pq.size()>0){\\n                String nbr=pq.remove();\\n                topological_sort(map,nbr,list);\\n            }\\n   //5.adding here (in post area of code ==> read topological sort if u not got it) because know i cannot visit anyplace from here.\\n         list.add(src);\\n    }\\n```\\n",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n//1.to have the adjacency list in sorted order we have used a priority queue.. this will resolve the problem of     lexographical order. you can dry run any tc in you will get it.\\n        HashMap<String,PriorityQueue<String>> map=new HashMap<>();\\n   \\n  //2. I have make the adjaceny list. I have add all the from(source) in my hashmap and corrosponding to that added to(destination) also..     \\n       for(List<String> ticket:tickets){\\n           String from=ticket.get(0);\\n           String to=ticket.get(1);\\n           \\n           if(map.containsKey(from)){\\n               map.get(from).add(to);\\n           }else{\\n               PriorityQueue<String> pq=new PriorityQueue<>();\\n               pq.add(to);\\n               map.put(from,pq);\\n           }\\n       }\\n        \\n      //3. I have used ArrayList here to return the list. can use linkedlist also to avoid the collection.reverse in line after topological sort(can use addFirst in linkedlist to avoid reverse).. but i have used arraylist here\\n        List<String> list=new ArrayList<>();\\n        topological_sort(map,\"JFK\",list);\\n        \\n        Collections.reverse(list);\\n        return list;\\n    }\\n    \\n    public static void topological_sort(HashMap<String,PriorityQueue<String>> map,String src,List<String> list){\\n  \\n            PriorityQueue<String> pq=map.get(src);\\n //4. we know that if there is something not present in map then map return null value.. so i have used pq!=null and if the size==0 means we have iterated all the neighbours..      \\n            while(pq!=null && pq.size()>0){\\n                String nbr=pq.remove();\\n                topological_sort(map,nbr,list);\\n            }\\n   //5.adding here (in post area of code ==> read topological sort if u not got it) because know i cannot visit anyplace from here.\\n         list.add(src);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 885386,
                "title": "java-dfs-solutions-using-stack-and-map",
                "content": "\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String , PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for(List<String> ll : tickets){\\n           if(!graph.containsKey(ll.get(0))){\\n               graph.put(ll.get(0) , new PriorityQueue<>());\\n           }\\n           graph.get(ll.get(0)).add(ll.get(1));\\n        }\\n        Stack<String> st = new Stack<>();\\n        List<String> res = new ArrayList<>();\\n        dfs(graph , \"JFK\" , st);\\n        while(st.size()!=0){\\n          res.add(st.pop());\\n        }\\n        return res;\\n    }\\n   public void dfs(HashMap<String , PriorityQueue<String>> graph , String src , Stack<String> st){\\n      \\n        \\n        while(graph.containsKey(src) && graph.get(src).size()!=0){\\n          String nbr = graph.get(src).remove();\\n          dfs(graph , nbr , st);\\n        }\\n       st.push(src);\\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String , PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for(List<String> ll : tickets){\\n           if(!graph.containsKey(ll.get(0))){\\n               graph.put(ll.get(0) , new PriorityQueue<>());\\n           }\\n           graph.get(ll.get(0)).add(ll.get(1));\\n        }\\n        Stack<String> st = new Stack<>();\\n        List<String> res = new ArrayList<>();\\n        dfs(graph , \"JFK\" , st);\\n        while(st.size()!=0){\\n          res.add(st.pop());\\n        }\\n        return res;\\n    }\\n   public void dfs(HashMap<String , PriorityQueue<String>> graph , String src , Stack<String> st){\\n      \\n        \\n        while(graph.containsKey(src) && graph.get(src).size()!=0){\\n          String nbr = graph.get(src).remove();\\n          dfs(graph , nbr , st);\\n        }\\n       st.push(src);\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843252,
                "title": "c-dfs-with-recursion",
                "content": "```csharp\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var map = new Dictionary<string, List<string>>();\\n        foreach (var ticket in tickets) {\\n            if (!map.TryGetValue(ticket[0], out var adj))  {\\n                adj = new List<string>();\\n                map.Add(ticket[0], adj);\\n            }\\n            adj.Add(ticket[1]);\\n        }\\n        \\n        foreach (var adj in map.Values) {\\n            adj.Sort(Comparer<string>.Create((a, b) => string.Compare(b, a)));\\n        }\\n        \\n        var ans = new Stack<string>();\\n        Visit(map, \"JFK\", ans);\\n        return ans.ToList();\\n    }\\n    \\n    private void Visit(Dictionary<string, List<string>> map, string src, Stack<string> ans) {\\n        if (map.TryGetValue(src, out var adj)) {\\n            while (adj.Count > 0) {\\n                var next = adj.Last();\\n                adj.RemoveAt(adj.Count - 1);\\n                Visit(map, next, ans);\\n            }\\n        }\\n        ans.Push(src);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var map = new Dictionary<string, List<string>>();\\n        foreach (var ticket in tickets) {\\n            if (!map.TryGetValue(ticket[0], out var adj))  {\\n                adj = new List<string>();\\n                map.Add(ticket[0], adj);\\n            }\\n            adj.Add(ticket[1]);\\n        }\\n        \\n        foreach (var adj in map.Values) {\\n            adj.Sort(Comparer<string>.Create((a, b) => string.Compare(b, a)));\\n        }\\n        \\n        var ans = new Stack<string>();\\n        Visit(map, \"JFK\", ans);\\n        return ans.ToList();\\n    }\\n    \\n    private void Visit(Dictionary<string, List<string>> map, string src, Stack<string> ans) {\\n        if (map.TryGetValue(src, out var adj)) {\\n            while (adj.Count > 0) {\\n                var next = adj.Last();\\n                adj.RemoveAt(adj.Count - 1);\\n                Visit(map, next, ans);\\n            }\\n        }\\n        ans.Push(src);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747113,
                "title": "c-dfs-and-backtracking",
                "content": "Naive Recursive Dfs + Backtracking solution. However the stack approach solution would be better/ easier.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<string, vector<pair<string,int>>>&hash, int e, string index, vector<string>&ans, int count, vector<string>&fin){\\n        ans.push_back(index);\\n        if(count == e){\\n            fin = ans;\\n            return;\\n        }\\n        //vector<pair<string, int>> t = hash[index];\\n        for(int i = 0 ; i  < hash[index].size(); i++){\\n            if(!hash[index][i].second){\\n                hash[index][i].second = 1;\\n                dfs(hash,e,hash[index][i].first, ans, count+1,fin);\\n                if(fin == ans){\\n                    return;\\n                }\\n                hash[index][i].second = 0;\\n            }\\n        }\\n        ans.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& A) {\\n        int n = A.size();\\n        unordered_map<string, vector<pair<string,int>>>hash;\\n        for(int i = 0 ; i  < n ; i++){\\n            hash[A[i][0]].push_back({A[i][1], 0});\\n        }\\n        unordered_map<string, vector<pair<string,int>>>:: iterator it;\\n        for(it = hash.begin(); it !=hash.end(); it++){\\n            sort(it->second.begin(), it->second.end());\\n        }\\n        vector<string>ans;\\n        string src = \"JFK\";\\n        vector<string>fin;\\n        dfs(hash,n,src,ans,0,fin);\\n        return fin;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<string, vector<pair<string,int>>>&hash, int e, string index, vector<string>&ans, int count, vector<string>&fin){\\n        ans.push_back(index);\\n        if(count == e){\\n            fin = ans;\\n            return;\\n        }\\n        //vector<pair<string, int>> t = hash[index];\\n        for(int i = 0 ; i  < hash[index].size(); i++){\\n            if(!hash[index][i].second){\\n                hash[index][i].second = 1;\\n                dfs(hash,e,hash[index][i].first, ans, count+1,fin);\\n                if(fin == ans){\\n                    return;\\n                }\\n                hash[index][i].second = 0;\\n            }\\n        }\\n        ans.pop_back();\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& A) {\\n        int n = A.size();\\n        unordered_map<string, vector<pair<string,int>>>hash;\\n        for(int i = 0 ; i  < n ; i++){\\n            hash[A[i][0]].push_back({A[i][1], 0});\\n        }\\n        unordered_map<string, vector<pair<string,int>>>:: iterator it;\\n        for(it = hash.begin(); it !=hash.end(); it++){\\n            sort(it->second.begin(), it->second.end());\\n        }\\n        vector<string>ans;\\n        string src = \"JFK\";\\n        vector<string>fin;\\n        dfs(hash,n,src,ans,0,fin);\\n        return fin;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712324,
                "title": "aggregating-understandings-of-discussion-with-code",
                "content": "Before going into details about the problem some pre-requiste \\n\\n-Euler path:- It is a path in a graph which visists each edges exactly onces.\\n\\t\\t\\t\\t\\texample:- A->B,B->C,C->D,D->E,E->C\\n-Euler Circuit-> it is a Euler Path , where starting and end nodes are same.\\n\\t\\t\\t\\t\\texample:- A->B,B->C,C->D,D->E,E->C,C->A.\\n\\n\\nThe problem is  exactly printing the Euler path/Circuit.\\nExample:- A->B,A->C,C->D,D->E,E->C,C->A.\\n\\t\\t\\t\\t\\t![image](https://assets.leetcode.com/users/images/dc8e312f-b06e-4845-8356-17ee02810722_1593480106.6716752.png)\\n\\n\\nBecause the Euler Path for above graph is only one :- A->C->D->E->C->A->B.\\n\\nIf we carefully look into the above graph, the problem seems very similar to topological sort in reverse order(topological sort can be applied to only acylic DAG).To overcome the cyclic nature that can be present in this question, we will remove the edge once visited(making it acyclic).\\nNow we kinda do a topological sort and add nodes to result list in reverse.\\nTime complexity will remain O(V+E) and space as O(E)\\n\\n\\nInspired from @StefanPochmann soln , \\n\\n1st Solution is Recursive \\n2nd Soltuion is Stack based Iterative\\n```\\nclass Solution {\\n    Map<String, PriorityQueue<String>> targetMap = new HashMap<>();\\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> findOrderRec(List<List<String>> tickets) {\\n      \\n        for(List<String> tick : tickets) {\\n            if(targetMap.get(tick.get(0)) == null) {\\n                targetMap.put(tick.get(0), new PriorityQueue<String>());\\n            } \\n            targetMap.get(tick.get(0)).add(tick.get(1));\\n        }\\n        visitDFS(\"JFK\");\\n        return ans;\\n    }\\n    \\n    public void visitDFS(String airport) {\\n        \\n        while(targetMap.get(airport) != null && targetMap.get(airport).size() > 0) {\\n            String nextAirport = targetMap.get(airport).poll();\\n            visitDFS(nextAirport);\\n        }\\n        \\n        ans.add(0, airport);\\n    }\\n    \\n    \\n    public List<String> findOrderIter(List<List<String>> tickets) {\\n        \\n        Map<String, PriorityQueue<String>> mapIter = new HashMap<>();\\n        List<String> resIter = new ArrayList<>();\\n        \\n        for(int i =0;i<tickets.size();i++) {\\n            \\n            if(mapIter.get(tickets.get(i).get(0)) == null) {\\n                mapIter.put(tickets.get(i).get(0), new PriorityQueue<String>());\\n            }\\n            mapIter.get(tickets.get(i).get(0)).add(tickets.get(i).get(1));\\n        }\\n        \\n        Stack<String> stack = new Stack<String> ();\\n        stack.push(\"JFK\");\\n        while(!stack.isEmpty()) {\\n            \\n            while(mapIter.get(stack.peek()) != null && mapIter.get(stack.peek()).size() > 0) {\\n                String nextAirport = mapIter.get(stack.peek()).poll();\\n                stack.push(nextAirport);\\n            }\\n            resIter.add(0, stack.pop());\\n            \\n        }\\n        return resIter;\\n    }\\n    \\n    \\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n//         O(V+E) time complexity and O(V) Space complexity\\n        // return findOrderRec(tickets);\\n        \\n        \\n//         Iterative Appraoch using Stack Based Approach\\n        return findOrderIter(tickets);\\n        \\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, PriorityQueue<String>> targetMap = new HashMap<>();\\n    List<String> ans = new ArrayList<>();\\n    \\n    public List<String> findOrderRec(List<List<String>> tickets) {\\n      \\n        for(List<String> tick : tickets) {\\n            if(targetMap.get(tick.get(0)) == null) {\\n                targetMap.put(tick.get(0), new PriorityQueue<String>());\\n            } \\n            targetMap.get(tick.get(0)).add(tick.get(1));\\n        }\\n        visitDFS(\"JFK\");\\n        return ans;\\n    }\\n    \\n    public void visitDFS(String airport) {\\n        \\n        while(targetMap.get(airport) != null && targetMap.get(airport).size() > 0) {\\n            String nextAirport = targetMap.get(airport).poll();\\n            visitDFS(nextAirport);\\n        }\\n        \\n        ans.add(0, airport);\\n    }\\n    \\n    \\n    public List<String> findOrderIter(List<List<String>> tickets) {\\n        \\n        Map<String, PriorityQueue<String>> mapIter = new HashMap<>();\\n        List<String> resIter = new ArrayList<>();\\n        \\n        for(int i =0;i<tickets.size();i++) {\\n            \\n            if(mapIter.get(tickets.get(i).get(0)) == null) {\\n                mapIter.put(tickets.get(i).get(0), new PriorityQueue<String>());\\n            }\\n            mapIter.get(tickets.get(i).get(0)).add(tickets.get(i).get(1));\\n        }\\n        \\n        Stack<String> stack = new Stack<String> ();\\n        stack.push(\"JFK\");\\n        while(!stack.isEmpty()) {\\n            \\n            while(mapIter.get(stack.peek()) != null && mapIter.get(stack.peek()).size() > 0) {\\n                String nextAirport = mapIter.get(stack.peek()).poll();\\n                stack.push(nextAirport);\\n            }\\n            resIter.add(0, stack.pop());\\n            \\n        }\\n        return resIter;\\n    }\\n    \\n    \\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n//         O(V+E) time complexity and O(V) Space complexity\\n        // return findOrderRec(tickets);\\n        \\n        \\n//         Iterative Appraoch using Stack Based Approach\\n        return findOrderIter(tickets);\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 712050,
                "title": "java-clean-concise-optimal-code-depth-first-search-algorithm-100-faster-solution",
                "content": "```\\nclass Solution {\\n \\n\\tHashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\tList<String> ans = new LinkedList<>();\\n\\t\\n\\tprivate void itineraryHelper (String s) {\\n\\t\\t\\n\\t\\tPriorityQueue<String> queue = map.get (s);\\n        \\n\\t\\twhile (queue != null && !queue.isEmpty ()) {\\n\\t\\t\\titineraryHelper (queue.poll ());\\n\\t\\t}\\n\\t\\t\\n\\t\\tans.add (0, s);\\n\\t}\\n\\t\\n\\tpublic List<String> findItinerary (List<List<String>> tickets) {\\n \\n\\t\\tfor (List<String> ticket : tickets) {\\n            if (!map.containsKey (ticket.get (0))) {\\n                map.put (ticket.get (0), new PriorityQueue<> ());\\n            }\\n            \\n            map.get (ticket.get (0)).offer (ticket.get (1));\\n\\t\\t}\\n\\t\\n\\t\\titineraryHelper (\"JFK\");\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n \\n\\tHashMap<String, PriorityQueue<String>> map = new HashMap<>();\\n\\tList<String> ans = new LinkedList<>();\\n\\t\\n\\tprivate void itineraryHelper (String s) {\\n\\t\\t\\n\\t\\tPriorityQueue<String> queue = map.get (s);\\n        \\n\\t\\twhile (queue != null && !queue.isEmpty ()) {\\n\\t\\t\\titineraryHelper (queue.poll ());\\n\\t\\t}\\n\\t\\t\\n\\t\\tans.add (0, s);\\n\\t}\\n\\t\\n\\tpublic List<String> findItinerary (List<List<String>> tickets) {\\n \\n\\t\\tfor (List<String> ticket : tickets) {\\n            if (!map.containsKey (ticket.get (0))) {\\n                map.put (ticket.get (0), new PriorityQueue<> ());\\n            }\\n            \\n            map.get (ticket.get (0)).offer (ticket.get (1));\\n\\t\\t}\\n\\t\\n\\t\\titineraryHelper (\"JFK\");\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710861,
                "title": "python-another-greedy-dfs-explained-beats-97",
                "content": "The logic of this solution is very straight forward and efficient:\\n\\n1. Greedy Travel to get a **main path**, probably miss couple of sites.\\n2. Backtrack all **crossing sites**(`departure` with multiple `arrive`), from which we choose the smallest `arrive` thus miss others.\\n\\t-  We use `stack` here so that the last crossing site pop out first (LIFO).\\n3. Redo greedy travel beginning at crossing site.\\n4. Insert the missing travel **cycle path** into **main path**.\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        # Store all tickets into dict and sort\\n        self.path = collections.defaultdict(list)\\n        for depart, arrive in tickets:\\n            heapq.heappush(self.path[depart], arrive)\\n        \\n        return self.dfs(\\'JFK\\', [\\'JFK\\'], [])\\n        \\n    def dfs(self, depart, pre_path, cross):\\n        \"\"\"\\n        Greedy Travel!\\n        \\n        For each depart, start travelling with lexical order.\\n        For each cross point, add the point index into stack.\\n        After main path finished, backtrack each cross point and insert previously missing cycle branch path into main path.\\n        \\n        Args:\\n            depart: String, departure airport \\n            pre_path: List, visited path\\n            cross: List, stack to store crossings\\n        \\n        Returns: List, travel path\\n            \\n        \"\"\"\\n        while self.path[depart]:\\n            \\n            # Meet crossing, add index into cross\\n            if len(self.path[depart]) > 1:\\n                cross.append(len(pre_path) - 1)\\n            \\n            # Travel with the lexcial smallest airport\\n            depart = heapq.heappop(self.path[depart])\\n            pre_path.append(depart)\\n            \\n        # Check if there\\'s any crossing\\n        while cross:\\n            cross_idx = cross.pop()\\n            cross_depart = pre_path[cross_idx]\\n            \\n            # Insert the circle path into the crossing point\\n            pre_path[cross_idx:cross_idx + 1] = self.dfs(cross_depart, [cross_depart], [])\\n        return pre_path\\n```\\nPlease **Upvote** if it helps! \\uD83D\\uDE00",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        # Store all tickets into dict and sort\\n        self.path = collections.defaultdict(list)\\n        for depart, arrive in tickets:\\n            heapq.heappush(self.path[depart], arrive)\\n        \\n        return self.dfs(\\'JFK\\', [\\'JFK\\'], [])\\n        \\n    def dfs(self, depart, pre_path, cross):\\n        \"\"\"\\n        Greedy Travel!\\n        \\n        For each depart, start travelling with lexical order.\\n        For each cross point, add the point index into stack.\\n        After main path finished, backtrack each cross point and insert previously missing cycle branch path into main path.\\n        \\n        Args:\\n            depart: String, departure airport \\n            pre_path: List, visited path\\n            cross: List, stack to store crossings\\n        \\n        Returns: List, travel path\\n            \\n        \"\"\"\\n        while self.path[depart]:\\n            \\n            # Meet crossing, add index into cross\\n            if len(self.path[depart]) > 1:\\n                cross.append(len(pre_path) - 1)\\n            \\n            # Travel with the lexcial smallest airport\\n            depart = heapq.heappop(self.path[depart])\\n            pre_path.append(depart)\\n            \\n        # Check if there\\'s any crossing\\n        while cross:\\n            cross_idx = cross.pop()\\n            cross_depart = pre_path[cross_idx]\\n            \\n            # Insert the circle path into the crossing point\\n            pre_path[cross_idx:cross_idx + 1] = self.dfs(cross_depart, [cross_depart], [])\\n        return pre_path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709649,
                "title": "c-dfs-detailed-explanation",
                "content": "The question is simple to understand. We just need to form an itinerary which will contain the names of airports which the person will visit in the same order. Our job is to find the order in which the person will visit the airport.\\n\\nWe will first create the adjacency list which will contain the information about the source and destination airports. One source airport may have multiple destinations in `tickets`; for example `[[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"ATL\", \"JFK\"]]`. We have to print the lexicographically smallest order. That is, our output for the above example should be `[\"JFK\", \"ATL\", \"JFK\", \"SFO\"]`. We can create a map of vector and sort for each key in the map.\\n\\nHowever, we can ease our pain by using a map of min heap instead. It will give us the lexicographically smallest airport. \\n\\nAfter reaching one destination, we have to reach the next destination according to our ticket, so it is better to use DFS instead of BFS. \\n\\nFor each visited node (airport), pop it from the priority_queue and perform dfs on the popped node. The implementation is as follows.\\n\\nPlease let me know in case you need any clarifications or if you find any mistake.\\n\\n```\\nclass Solution {\\nprivate:\\n\\tmap<string, priority_queue<string, vector<string>, greater<string>>> adj;\\n\\tvector<string> ans;\\n\\tvoid dfs(string src)\\n\\t{\\n\\t\\twhile(!adj[src].empty())\\n\\t\\t{\\n\\t\\t\\tstring s = adj[src].top();\\n\\t\\t\\tadj[src].pop();\\n\\t\\t\\tdfs(s);\\n\\t\\t}\\n\\t\\tans.insert(ans.begin(), src);\\n\\t}\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        adj.clear(), ans.clear();\\n        for(auto v : tickets)\\n            adj[v[0]].push(v[1]);\\n        dfs(\"JFK\"); // We have to start with JFK\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you liked my explanation, could you please upvote? It gives me motivation to explain more problems in a simple way so that everyone can understand.",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tmap<string, priority_queue<string, vector<string>, greater<string>>> adj;\\n\\tvector<string> ans;\\n\\tvoid dfs(string src)\\n\\t{\\n\\t\\twhile(!adj[src].empty())\\n\\t\\t{\\n\\t\\t\\tstring s = adj[src].top();\\n\\t\\t\\tadj[src].pop();\\n\\t\\t\\tdfs(s);\\n\\t\\t}\\n\\t\\tans.insert(ans.begin(), src);\\n\\t}\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        adj.clear(), ans.clear();\\n        for(auto v : tickets)\\n            adj[v[0]].push(v[1]);\\n        dfs(\"JFK\"); // We have to start with JFK\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537998,
                "title": "java-dfs-backtracking",
                "content": "Full Detail:  https://medium.com/@hch.hkcontact/goldman-sachs-top-50-leetcode-questions-q25-reconstruct-itinerary-53130444b672\\n\\nSteps:\\nLoop over tickets,\\n- store the source position as a key and a sorted linked list of destination position as value in a hashmap\\n\\nWe need to backtrack all possible route\\n- the parameters are result list, the original map & a map contains boolean array to mark down which destination visited\\n- in each iteration, add the current point to the result list, mark down that it is visited in the map. After that, mark it back as not visited\\n- Recursion until the length of linked list = total flight + 1\\n\\n\\n```\\nclass Solution {\\n    List<String> rl;\\n    boolean found;\\n    \\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String, LinkedList<String>> map = new HashMap<>();\\n        HashMap<String, boolean[]> vedMap = new HashMap<String, boolean[]>();\\n        \\n        for(List<String> ticket:tickets){\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n            LinkedList<String> ls = map.getOrDefault(from, new LinkedList<String>());\\n            ls.add(to);\\n            map.put(from, ls);\\n        }\\n        \\n        for(String key:map.keySet()){\\n            int size = map.get(key).size();\\n            vedMap.put(key, new boolean[size]);\\n            Collections.sort(map.get(key), (a,b)->{\\n                return a.compareTo(b);\\n            });\\n        }\\n        \\n        // System.out.println(map);\\n        // System.out.println(vedMap);\\n                \\n        found=false;\\n        rl = new ArrayList<String>();\\n        List<String> ol = new ArrayList<String>(Arrays.asList(\"JFK\"));\\n        \\n        backTrack(map, vedMap, ol, \"JFK\", tickets.size()+1);\\n        \\n        return rl;\\n        \\n    }\\n    \\n    private void backTrack(HashMap<String, LinkedList<String>> map, HashMap<String, boolean[]> vedMap, List<String> result, String cur, int n){\\n        if(found) return;\\n        if(result.size()==n){\\n            rl= new ArrayList<>(result);\\n            found=true;\\n            return;\\n        }\\n        \\n        List<String> nextLs = map.get(cur);\\n        if(nextLs==null){\\n            return;\\n        }\\n        boolean[] ved = vedMap.get(cur);\\n        for(int i=0;i<nextLs.size();i++){\\n            if(ved[i]==true) continue;\\n            String to = nextLs.get(i);\\n            result.add(to);\\n            // System.out.println(result);\\n            vedMap.get(cur)[i]=true;\\n            \\n            backTrack(map, vedMap, result, to, n);\\n            \\n            result.remove(result.size()-1);\\n            vedMap.get(cur)[i]=false;\\n            \\n        }\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> rl;\\n    boolean found;\\n    \\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        HashMap<String, LinkedList<String>> map = new HashMap<>();\\n        HashMap<String, boolean[]> vedMap = new HashMap<String, boolean[]>();\\n        \\n        for(List<String> ticket:tickets){\\n            String from = ticket.get(0);\\n            String to = ticket.get(1);\\n            LinkedList<String> ls = map.getOrDefault(from, new LinkedList<String>());\\n            ls.add(to);\\n            map.put(from, ls);\\n        }\\n        \\n        for(String key:map.keySet()){\\n            int size = map.get(key).size();\\n            vedMap.put(key, new boolean[size]);\\n            Collections.sort(map.get(key), (a,b)->{\\n                return a.compareTo(b);\\n            });\\n        }\\n        \\n        // System.out.println(map);\\n        // System.out.println(vedMap);\\n                \\n        found=false;\\n        rl = new ArrayList<String>();\\n        List<String> ol = new ArrayList<String>(Arrays.asList(\"JFK\"));\\n        \\n        backTrack(map, vedMap, ol, \"JFK\", tickets.size()+1);\\n        \\n        return rl;\\n        \\n    }\\n    \\n    private void backTrack(HashMap<String, LinkedList<String>> map, HashMap<String, boolean[]> vedMap, List<String> result, String cur, int n){\\n        if(found) return;\\n        if(result.size()==n){\\n            rl= new ArrayList<>(result);\\n            found=true;\\n            return;\\n        }\\n        \\n        List<String> nextLs = map.get(cur);\\n        if(nextLs==null){\\n            return;\\n        }\\n        boolean[] ved = vedMap.get(cur);\\n        for(int i=0;i<nextLs.size();i++){\\n            if(ved[i]==true) continue;\\n            String to = nextLs.get(i);\\n            result.add(to);\\n            // System.out.println(result);\\n            vedMap.get(cur)[i]=true;\\n            \\n            backTrack(map, vedMap, result, to, n);\\n            \\n            result.remove(result.size()-1);\\n            vedMap.get(cur)[i]=false;\\n            \\n        }\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515336,
                "title": "java-simple-topological-sort-using-priority-queue",
                "content": "Solved it thinking its Topological Sort. Apparently its some fancy Algo :-/\\n\\n```\\npublic List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for(List<String> t : tickets) {\\n            String src = t.get(0);\\n            String dest = t.get(1);\\n            PriorityQueue<String> queue = new PriorityQueue<>();\\n            if(graph.containsKey(src)){\\n                queue = graph.get(src);\\n            }\\n            queue.offer(dest);\\n            graph.put(src, queue);\\n        }\\n        \\n        List<String> path = new ArrayList<>(); \\n        dfs(graph, path, \"JFK\");\\n        return path;\\n        \\n    }\\n    \\n    public static void dfs(Map<String, PriorityQueue<String>> graph, List<String> path, String cur) {\\n            PriorityQueue<String> queue = graph.get(cur);\\n            while(queue != null && !queue.isEmpty()) {\\n                String next = queue.poll();\\n                dfs(graph, path, next);\\n            }\\n            path.add(0,cur);\\n        }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "Solved it thinking its Topological Sort. Apparently its some fancy Algo :-/\\n\\n```\\npublic List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for(List<String> t : tickets) {\\n            String src = t.get(0);\\n            String dest = t.get(1);\\n            PriorityQueue<String> queue = new PriorityQueue<>();\\n            if(graph.containsKey(src)){\\n                queue = graph.get(src);\\n            }\\n            queue.offer(dest);\\n            graph.put(src, queue);\\n        }\\n        \\n        List<String> path = new ArrayList<>(); \\n        dfs(graph, path, \"JFK\");\\n        return path;\\n        \\n    }\\n    \\n    public static void dfs(Map<String, PriorityQueue<String>> graph, List<String> path, String cur) {\\n            PriorityQueue<String> queue = graph.get(cur);\\n            while(queue != null && !queue.isEmpty()) {\\n                String next = queue.poll();\\n                dfs(graph, path, next);\\n            }\\n            path.add(0,cur);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 471849,
                "title": "java-dfs-and-why-it-is-medium",
                "content": "//Need to explain this, since we have to loop all the edges, that means dfs will have to loop all arrivals until arrive the destination.\\n    //This is a perfect solvable graph, that is why it is medium question. If not perfect, we can return null, it becomes hard.\\n\\t\\n```\\nclass Solution {\\n    private Map<String, PriorityQueue<String>> m = new HashMap<>();\\n    private List<String> res =  new ArrayList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> t) {\\n        int l = t.size();\\n        \\n        if (l == 0) return res;\\n        if (l == 1) return t.get(0);\\n        \\n        for (List<String> trip : t){\\n            String dep = trip.get(0);\\n            String arr = trip.get(1);\\n            PriorityQueue<String> q = new PriorityQueue<String>();\\n            if (m.containsKey(dep)){\\n                q = m.get(dep);\\n            }\\n            q.add(arr);\\n            m.put(dep, q);\\n        }\\n        \\n        dfs(\"JFK\");\\n        return res;\\n    }\\n\\n    private void dfs(String dep){\\n        PriorityQueue<String> q = m.get(dep);\\n        while(q != null && !q.isEmpty()){\\n            dfs(q.poll());\\n        }\\n        res.add(0, dep);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<String, PriorityQueue<String>> m = new HashMap<>();\\n    private List<String> res =  new ArrayList<>();\\n    \\n    public List<String> findItinerary(List<List<String>> t) {\\n        int l = t.size();\\n        \\n        if (l == 0) return res;\\n        if (l == 1) return t.get(0);\\n        \\n        for (List<String> trip : t){\\n            String dep = trip.get(0);\\n            String arr = trip.get(1);\\n            PriorityQueue<String> q = new PriorityQueue<String>();\\n            if (m.containsKey(dep)){\\n                q = m.get(dep);\\n            }\\n            q.add(arr);\\n            m.put(dep, q);\\n        }\\n        \\n        dfs(\"JFK\");\\n        return res;\\n    }\\n\\n    private void dfs(String dep){\\n        PriorityQueue<String> q = m.get(dep);\\n        while(q != null && !q.isEmpty()){\\n            dfs(q.poll());\\n        }\\n        res.add(0, dep);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457815,
                "title": "javascript-solution-dfs-backtracking",
                "content": "### The idea\\n1. Use DFS to explore every possible path, use backtracking to reset values during invalid paths.\\n``` javascript\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    tickets.sort()\\n    let hash = {};\\n    for (let ticket of tickets) {\\n        if (!hash[ticket[0]]) hash[ticket[0]] = []; // \"from\" key\\n        if (!hash[ticket[1]]) hash[ticket[1]] = []; // \"to\" key\\n        hash[ticket[0]].push(ticket[1]);\\n    }\\n\\n    let res = [];\\n    let dfs = function(from, itinerary) {\\n        if (itinerary.length == tickets.length + 1) {\\n            res = itinerary;\\n            return true;\\n        }\\n        let len = hash[from].length;\\n        for (let i=0;i<len;i++) {\\n            let to = hash[from].shift();\\n            if (dfs(to, [...itinerary, to])) return itinerary;\\n            hash[from].push(to);\\n        }\\n        return false\\n    }\\n\\n    dfs(\"JFK\", [\"JFK\"]);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n    tickets.sort()\\n    let hash = {};\\n    for (let ticket of tickets) {\\n        if (!hash[ticket[0]]) hash[ticket[0]] = []; // \"from\" key\\n        if (!hash[ticket[1]]) hash[ticket[1]] = []; // \"to\" key\\n        hash[ticket[0]].push(ticket[1]);\\n    }\\n\\n    let res = [];\\n    let dfs = function(from, itinerary) {\\n        if (itinerary.length == tickets.length + 1) {\\n            res = itinerary;\\n            return true;\\n        }\\n        let len = hash[from].length;\\n        for (let i=0;i<len;i++) {\\n            let to = hash[from].shift();\\n            if (dfs(to, [...itinerary, to])) return itinerary;\\n            hash[from].push(to);\\n        }\\n        return false\\n    }\\n\\n    dfs(\"JFK\", [\"JFK\"]);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449355,
                "title": "java-backtrack",
                "content": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        List<String> ans = new ArrayList<>();\\n        Map<String, List<String>> graph = new HashMap<>();\\n        for (List<String> ticket : tickets) {\\n            String s1 = ticket.get(0);\\n            String s2 = ticket.get(1);\\n            graph.putIfAbsent(s1, new ArrayList<>());\\n            graph.get(s1).add(s2);\\n        }\\n        for (List<String> neibs : graph.values()) {\\n            Collections.sort(neibs);\\n        }\\n        ans.add(\"JFK\");\\n        backTrack(\"JFK\", graph, ans, tickets.size() + 1);\\n        return ans;\\n    }\\n    public boolean backTrack(String cur, Map<String, List<String>> graph, List<String> ans, int n) {\\n        if (ans.size() == n) return true;\\n        List<String> neibs = graph.get(cur);\\n        if (neibs == null || neibs.isEmpty()) return false;\\n        int size = neibs.size();\\n        for (int i = 0; i < size; i++) {\\n            String neib = neibs.remove(i);\\n            ans.add(neib);\\n            if (backTrack(neib, graph, ans, n)) return true;\\n            ans.remove(ans.size() - 1);\\n            neibs.add(i, neib);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        List<String> ans = new ArrayList<>();\\n        Map<String, List<String>> graph = new HashMap<>();\\n        for (List<String> ticket : tickets) {\\n            String s1 = ticket.get(0);\\n            String s2 = ticket.get(1);\\n            graph.putIfAbsent(s1, new ArrayList<>());\\n            graph.get(s1).add(s2);\\n        }\\n        for (List<String> neibs : graph.values()) {\\n            Collections.sort(neibs);\\n        }\\n        ans.add(\"JFK\");\\n        backTrack(\"JFK\", graph, ans, tickets.size() + 1);\\n        return ans;\\n    }\\n    public boolean backTrack(String cur, Map<String, List<String>> graph, List<String> ans, int n) {\\n        if (ans.size() == n) return true;\\n        List<String> neibs = graph.get(cur);\\n        if (neibs == null || neibs.isEmpty()) return false;\\n        int size = neibs.size();\\n        for (int i = 0; i < size; i++) {\\n            String neib = neibs.remove(i);\\n            ans.add(neib);\\n            if (backTrack(neib, graph, ans, n)) return true;\\n            ans.remove(ans.size() - 1);\\n            neibs.add(i, neib);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447582,
                "title": "java-clean-code-dfs-hierholzer-s-algorithm",
                "content": "``` \\npublic List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        if (tickets == null || tickets.size() == 0) return null;\\n        \\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());    \\n            graph.get(ticket.get(0)).offer(ticket.get(1));  // Assumption : The edge is [from, to] format\\n        }\\n        \\n        List<String> itinerary = new ArrayList<>();\\n        \\n        dfs(graph, \"JFK\", itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(Map<String, PriorityQueue<String>> graph, \\n                     String from, List<String> itinerary) {\\n     \\n        PriorityQueue<String> adjacents = graph.getOrDefault(from, new PriorityQueue<>());\\n        \\n        while (!adjacents.isEmpty()) \\n            dfs(graph, adjacents.poll(), itinerary);\\n        \\n        itinerary.add(0, from); // Once all adjacents are traversed, add the graph node into itinerary\\n    }",
                "solutionTags": [],
                "code": "``` \\npublic List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        if (tickets == null || tickets.size() == 0) return null;\\n        \\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        \\n        for (List<String> ticket : tickets) {\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());    \\n            graph.get(ticket.get(0)).offer(ticket.get(1));  // Assumption : The edge is [from, to] format\\n        }\\n        \\n        List<String> itinerary = new ArrayList<>();\\n        \\n        dfs(graph, \"JFK\", itinerary);\\n        \\n        return itinerary;\\n    }\\n    \\n    private void dfs(Map<String, PriorityQueue<String>> graph, \\n                     String from, List<String> itinerary) {\\n     \\n        PriorityQueue<String> adjacents = graph.getOrDefault(from, new PriorityQueue<>());\\n        \\n        while (!adjacents.isEmpty()) \\n            dfs(graph, adjacents.poll(), itinerary);\\n        \\n        itinerary.add(0, from); // Once all adjacents are traversed, add the graph node into itinerary\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 445833,
                "title": "java-dfs-beats-100-map-with-priorityqueue",
                "content": "```\\nclass Solution {\\n    HashMap<String, PriorityQueue<String>> map;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        List<String> res = new ArrayList<>();\\n        if(tickets == null || tickets.size() == 0) return res;\\n\\n        map = new HashMap<>();\\n        for(List<String> ticket: tickets) {\\n            map.putIfAbsent(ticket.get(0), new PriorityQueue<String>());\\n            map.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        if(!map.containsKey(\"JFK\")) return res;\\n        dfs(\"JFK\", res);\\n        return res;\\n    }\\n    \\n    private void dfs(String start, List<String> res) {\\n        PriorityQueue<String> pq = map.get(start);\\n        while(pq != null && !pq.isEmpty()) {\\n            dfs(pq.poll(), res);\\n        }\\n        res.add(0, start);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, PriorityQueue<String>> map;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        List<String> res = new ArrayList<>();\\n        if(tickets == null || tickets.size() == 0) return res;\\n\\n        map = new HashMap<>();\\n        for(List<String> ticket: tickets) {\\n            map.putIfAbsent(ticket.get(0), new PriorityQueue<String>());\\n            map.get(ticket.get(0)).add(ticket.get(1));\\n        }\\n        if(!map.containsKey(\"JFK\")) return res;\\n        dfs(\"JFK\", res);\\n        return res;\\n    }\\n    \\n    private void dfs(String start, List<String> res) {\\n        PriorityQueue<String> pq = map.get(start);\\n        while(pq != null && !pq.isEmpty()) {\\n            dfs(pq.poll(), res);\\n        }\\n        res.add(0, start);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438846,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n     \\n        length= len(tickets)+1\\n        graph= collections.defaultdict(list)\\n        \\n        for ticket in tickets:\\n            graph[ticket[0]].append(ticket[1])\\n        \\n        for g in graph:\\n            graph[g].sort()\\n            \\n        self.answer=[]\\n        def dfs(node, result):\\n            if len(result)== length:\\n                self.answer= result\\n                return True\\n            res= False\\n            for i,n in enumerate(graph[node]):\\n                if n!= \\'#\\':\\n                    city= n\\n                    graph[node][i]= \\'#\\'\\n                    result.append(city)\\n                    res= dfs(city, result)\\n                    if res:\\n                        return res\\n                    graph[node][i]= city\\n                    result.pop()\\n            return res\\n            \\n        dfs(\\'JFK\\', [\\'JFK\\'])\\n        \\n        return self.answer\\n            \\n        \\n        \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n     \\n        length= len(tickets)+1\\n        graph= collections.defaultdict(list)\\n        \\n        for ticket in tickets:\\n            graph[ticket[0]].append(ticket[1])\\n        \\n        for g in graph:\\n            graph[g].sort()\\n            \\n        self.answer=[]\\n        def dfs(node, result):\\n            if len(result)== length:\\n                self.answer= result\\n                return True\\n            res= False\\n            for i,n in enumerate(graph[node]):\\n                if n!= \\'#\\':\\n                    city= n\\n                    graph[node][i]= \\'#\\'\\n                    result.append(city)\\n                    res= dfs(city, result)\\n                    if res:\\n                        return res\\n                    graph[node][i]= city\\n                    result.pop()\\n            return res\\n            \\n        dfs(\\'JFK\\', [\\'JFK\\'])\\n        \\n        return self.answer\\n            \\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 389327,
                "title": "super-short-clear-c-dfs-with-priority-queue-95",
                "content": "```\\nclass Solution {\\n    typedef unordered_map<string, priority_queue<string, vector<string>, greater<string>>> GraphType;\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        GraphType graph;\\n        vector<string> res;\\n        \\n        for (auto t : tickets)\\n            graph[t[0]].push(t[1]);\\n        \\n        dfs(\"JFK\", graph, res);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void dfs(string str, GraphType& graph, vector<string>& res) {\\n        \\n        auto & v = graph[str];\\n        while (!v.empty()) {\\n            \\n            auto cur = v.top();\\n            v.pop();\\n            dfs(cur, graph, res);\\n        }\\n        \\n        res.push_back(str);\\n     }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef unordered_map<string, priority_queue<string, vector<string>, greater<string>>> GraphType;\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        \\n        GraphType graph;\\n        vector<string> res;\\n        \\n        for (auto t : tickets)\\n            graph[t[0]].push(t[1]);\\n        \\n        dfs(\"JFK\", graph, res);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void dfs(string str, GraphType& graph, vector<string>& res) {\\n        \\n        auto & v = graph[str];\\n        while (!v.empty()) {\\n            \\n            auto cur = v.top();\\n            v.pop();\\n            dfs(cur, graph, res);\\n        }\\n        \\n        res.push_back(str);\\n     }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352144,
                "title": "python3-simple-stack-solution",
                "content": "1, sort from/to pairs in lexical order, and store them in dict.\\n2, start the route with current city in the smallest lexical order, it may not cover all the cities, but it is still a valid route because eventually you will go through.\\n3, append the last city to the end, and loop 2 -> 3 till all cities are visited.\\n \\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = collections.defaultdict(collections.deque)\\n        for i, j in sorted(tickets):\\n            graph[i].append(j)\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].popleft())\\n            route += stack.pop(),\\n        return route[::-1]",
                "solutionTags": [],
                "code": "1, sort from/to pairs in lexical order, and store them in dict.\\n2, start the route with current city in the smallest lexical order, it may not cover all the cities, but it is still a valid route because eventually you will go through.\\n3, append the last city to the end, and loop 2 -> 3 till all cities are visited.\\n \\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        graph = collections.defaultdict(collections.deque)\\n        for i, j in sorted(tickets):\\n            graph[i].append(j)\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].popleft())\\n            route += stack.pop(),\\n        return route[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 335448,
                "title": "python3-dfs",
                "content": "```\\nfrom collections import defaultdict, deque\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        def make_graph():\\n            for depart, arrival in tickets:\\n                tickets_graph[depart].append(arrival)\\n            return tickets_graph\\n                \\n        def dfs_helper(curr_city = \"JFK\", temp_itenary = []):\\n            \\n            if len(temp_itenary) == len_itenary:\\n                return temp_itenary + [curr_city]\\n            \\n            if curr_city not in tickets_graph: # we have reached a deadend\\n                return None\\n            \\n            for next_city in sorted(tickets_graph[curr_city]):\\n                tickets_graph[curr_city].remove(next_city) #to avoid indefinite cycles\\n                solution = dfs_helper(next_city, temp_itenary+[curr_city])\\n                if solution: return solution #return as soon as path found\\n                tickets_graph[curr_city].append(next_city)\\n            \\n        tickets_graph = defaultdict(list)\\n        make_graph()\\n        len_itenary = len(tickets)\\n        return dfs_helper()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        \\n        def make_graph():\\n            for depart, arrival in tickets:\\n                tickets_graph[depart].append(arrival)\\n            return tickets_graph\\n                \\n        def dfs_helper(curr_city = \"JFK\", temp_itenary = []):\\n            \\n            if len(temp_itenary) == len_itenary:\\n                return temp_itenary + [curr_city]\\n            \\n            if curr_city not in tickets_graph: # we have reached a deadend\\n                return None\\n            \\n            for next_city in sorted(tickets_graph[curr_city]):\\n                tickets_graph[curr_city].remove(next_city) #to avoid indefinite cycles\\n                solution = dfs_helper(next_city, temp_itenary+[curr_city])\\n                if solution: return solution #return as soon as path found\\n                tickets_graph[curr_city].append(next_city)\\n            \\n        tickets_graph = defaultdict(list)\\n        make_graph()\\n        len_itenary = len(tickets)\\n        return dfs_helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327635,
                "title": "python3-hierholzer-s-algorithm",
                "content": "Following this article: https://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/\\nAnd find a circuit. Hmm maybe to get this optimal solution in an interview I need to memorize this.\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        tickets.sort(key=lambda x: x[1], reverse=True)\\n        m = {}\\n        for t in tickets:\\n            if t[0] not in m:\\n                m[t[0]] = [t[1]]\\n            else:\\n                m[t[0]].append(t[1])\\n        \\n        circuit = []\\n        curpath = [\\'JFK\\']\\n        while curpath:\\n            if curpath[-1] in m and m[curpath[-1]]:\\n                next = m[curpath[-1]].pop()\\n                curpath.append(next)\\n            else:\\n                circuit.append(curpath[-1])\\n                curpath.pop()\\n        return circuit[::-1]\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        tickets.sort(key=lambda x: x[1], reverse=True)\\n        m = {}\\n        for t in tickets:\\n            if t[0] not in m:\\n                m[t[0]] = [t[1]]\\n            else:\\n                m[t[0]].append(t[1])\\n        \\n        circuit = []\\n        curpath = [\\'JFK\\']\\n        while curpath:\\n            if curpath[-1] in m and m[curpath[-1]]:\\n                next = m[curpath[-1]].pop()\\n                curpath.append(next)\\n            else:\\n                circuit.append(curpath[-1])\\n                curpath.pop()\\n        return circuit[::-1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 322050,
                "title": "javascript-solution",
                "content": "https://github.com/bobwei/leetcode-v7/blob/master/src/leetcode/reconstruct-itinerary/index.js\\n\\n```js\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n  const graph = createGraph(tickets);\\n  const output = dfs(graph, \\'JFK\\');\\n  return output.reverse();\\n};\\n\\nfunction dfs(graph, u, output = []) {\\n  const neighbors = graph[u] || [];\\n  while (neighbors.length) {\\n    const v = neighbors.shift();\\n    dfs(graph, v, output);\\n  }\\n  output.push(u);\\n  return output;\\n}\\n\\nfunction createGraph(tickets) {\\n  const graph = {};\\n  for (const [from, to] of tickets) {\\n    if (!(from in graph)) graph[from] = [];\\n    graph[from].push(to);\\n  }\\n  for (const key in graph) {\\n    graph[key].sort();\\n  }\\n  return graph;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {string[][]} tickets\\n * @return {string[]}\\n */\\nvar findItinerary = function(tickets) {\\n  const graph = createGraph(tickets);\\n  const output = dfs(graph, \\'JFK\\');\\n  return output.reverse();\\n};\\n\\nfunction dfs(graph, u, output = []) {\\n  const neighbors = graph[u] || [];\\n  while (neighbors.length) {\\n    const v = neighbors.shift();\\n    dfs(graph, v, output);\\n  }\\n  output.push(u);\\n  return output;\\n}\\n\\nfunction createGraph(tickets) {\\n  const graph = {};\\n  for (const [from, to] of tickets) {\\n    if (!(from in graph)) graph[from] = [];\\n    graph[from].push(to);\\n  }\\n  for (const key in graph) {\\n    graph[key].sort();\\n  }\\n  return graph;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308872,
                "title": "c-dfs-add-result-after-go-through-all-paths-remove-node-for-circular",
                "content": "```\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var adjacencyMatrix = new Dictionary<string, List<string>>();\\n\\n        var result = new List<string>();\\n\\n        foreach (var ticket in tickets) {\\n            var from = ticket[0];\\n            var to = ticket[1];\\n\\n            if (!adjacencyMatrix.ContainsKey(from)) {\\n                adjacencyMatrix[from] = new List<string>();\\n            }\\n\\n            if (!adjacencyMatrix.ContainsKey(to)) {\\n                adjacencyMatrix[to] = new List<string>();\\n            }\\n\\n            adjacencyMatrix[from].Add(to);\\n        }\\n\\n        // Sort all lists\\n        foreach (var value in adjacencyMatrix.Values) {\\n            value.Sort();\\n        }\\n\\n        DFS(adjacencyMatrix, \"JFK\", result);\\n\\n        result.Reverse();\\n\\n        return result;\\n    }\\n\\n    private void DFS(Dictionary<string, List<string>> adjacencyMatrix, string cur, IList<string> result) {\\n        while (adjacencyMatrix[cur].Any()) {\\n            var next = adjacencyMatrix[cur].First();\\n            adjacencyMatrix[cur].Remove(next);\\n            DFS(adjacencyMatrix, next, result);\\n        }\\n        result.Add(cur);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        var adjacencyMatrix = new Dictionary<string, List<string>>();\\n\\n        var result = new List<string>();\\n\\n        foreach (var ticket in tickets) {\\n            var from = ticket[0];\\n            var to = ticket[1];\\n\\n            if (!adjacencyMatrix.ContainsKey(from)) {\\n                adjacencyMatrix[from] = new List<string>();\\n            }\\n\\n            if (!adjacencyMatrix.ContainsKey(to)) {\\n                adjacencyMatrix[to] = new List<string>();\\n            }\\n\\n            adjacencyMatrix[from].Add(to);\\n        }\\n\\n        // Sort all lists\\n        foreach (var value in adjacencyMatrix.Values) {\\n            value.Sort();\\n        }\\n\\n        DFS(adjacencyMatrix, \"JFK\", result);\\n\\n        result.Reverse();\\n\\n        return result;\\n    }\\n\\n    private void DFS(Dictionary<string, List<string>> adjacencyMatrix, string cur, IList<string> result) {\\n        while (adjacencyMatrix[cur].Any()) {\\n            var next = adjacencyMatrix[cur].First();\\n            adjacencyMatrix[cur].Remove(next);\\n            DFS(adjacencyMatrix, next, result);\\n        }\\n        result.Add(cur);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298491,
                "title": "treeset-vs-priorityqueue-can-someone-explain",
                "content": "I don\\'t understand why this code doesn\\'t work. TreeSet is sorted so as PriorityQueue, to me it looks the same, if I replace TreeSet with PriorityQueue everything works just fine and pass all the tests. I\\'m stuck.\\n\\n```\\nprivate Map<String, TreeSet<String>> graph;\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        graph = new HashMap<>();\\n\\n        for (List<String> pair : tickets) {\\n            if (!graph.containsKey(pair.get(0)))\\n                graph.put(pair.get(0), new TreeSet<String>());\\n\\n            graph.get(pair.get(0)).add(pair.get(1));\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n\\n        dfs(\"JFK\", graph, result);\\n\\n        return result;\\n    }\\n\\n    private void dfs(String origin, Map<String, TreeSet<String>> graph, List<String> result) {\\n        while (graph.containsKey(origin) && !graph.get(origin).isEmpty()) {\\n            String destination = graph.get(origin).pollFirst();\\n            dfs(destination, graph, result);\\n        }\\n\\n        result.add(0, origin);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate Map<String, TreeSet<String>> graph;\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        graph = new HashMap<>();\\n\\n        for (List<String> pair : tickets) {\\n            if (!graph.containsKey(pair.get(0)))\\n                graph.put(pair.get(0), new TreeSet<String>());\\n\\n            graph.get(pair.get(0)).add(pair.get(1));\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n\\n        dfs(\"JFK\", graph, result);\\n\\n        return result;\\n    }\\n\\n    private void dfs(String origin, Map<String, TreeSet<String>> graph, List<String> result) {\\n        while (graph.containsKey(origin) && !graph.get(origin).isEmpty()) {\\n            String destination = graph.get(origin).pollFirst();\\n            dfs(destination, graph, result);\\n        }\\n\\n        result.add(0, origin);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293270,
                "title": "assumption-3-makes-this-problem-no-brainer",
                "content": "Shouldn\\'t have assumption 3 there. \\n\\n```\\nYou may assume all tickets form at least one valid itinerary.\\n```\\n\\nI don\\'t see any \\'backtracking\\' operation with this assumpt being there. \\n\\nIt should say\\n\\n```\\nAll tickets should be used. \\nReturn the itinerary with smallest lexical order, or null if we cannot find a valid itinerary\\n```",
                "solutionTags": [],
                "code": "```\\nYou may assume all tickets form at least one valid itinerary.\\n```\n```\\nAll tickets should be used. \\nReturn the itinerary with smallest lexical order, or null if we cannot find a valid itinerary\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 180895,
                "title": "swift-solution-100ms",
                "content": "```\\nclass Solution {\\n    var targets = [String : [String]]()\\n    var route = [String]()\\n   \\n    func findItinerary(_ tickets: [[String]]) -> [String] {\\n        for ticket in tickets {\\n            if targets[ticket[0]] == nil {\\n                targets[ticket[0]] = [ticket[1]]\\n            } else {\\n                targets[ticket[0]]!.append(ticket[1])\\n            }\\n        }\\n        for ticket in tickets {\\n            targets[ticket[0]] = targets[ticket[0]]!.sorted()\\n        }\\n        visit(\"JFK\")\\n        return route.reversed()\\n    }\\n    \\n    func visit(_ airport: String) {\\n        if targets[airport] != nil {\\n            while targets[airport]!.count > 0 {\\n                if let next = targets[airport]!.first {\\n                    targets[airport]!.removeFirst()\\n                    visit(next)\\n                }\\n            }\\n        }\\n        route.append(airport)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var targets = [String : [String]]()\\n    var route = [String]()\\n   \\n    func findItinerary(_ tickets: [[String]]) -> [String] {\\n        for ticket in tickets {\\n            if targets[ticket[0]] == nil {\\n                targets[ticket[0]] = [ticket[1]]\\n            } else {\\n                targets[ticket[0]]!.append(ticket[1])\\n            }\\n        }\\n        for ticket in tickets {\\n            targets[ticket[0]] = targets[ticket[0]]!.sorted()\\n        }\\n        visit(\"JFK\")\\n        return route.reversed()\\n    }\\n    \\n    func visit(_ airport: String) {\\n        if targets[airport] != nil {\\n            while targets[airport]!.count > 0 {\\n                if let next = targets[airport]!.first {\\n                    targets[airport]!.removeFirst()\\n                    visit(next)\\n                }\\n            }\\n        }\\n        route.append(airport)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148387,
                "title": "python-easy-to-understand-solution-with-no-dfs-just-sort-and-hash-table",
                "content": "I think this is more intuitive. You process all the tickets then sort the destinations by lexical order. Afterwards you process each itinerary one by one using your sorted destinations. The end array is for processing final destinations in the end.\\n```\\nclass Solution:\\n    def findItinerary(self, tickets):\\n        d = {}\\n        for ticket in tickets:\\n            if ticket[0] not in d:\\n                d[ticket[0]] = [ticket[1]]\\n            else:\\n                d[ticket[0]].append(ticket[1])\\n                \\n        for ticket in d:\\n            d[ticket].sort()\\n        \\n        res = [\\'JFK\\']\\n        end = []\\n        while d:\\n            if res[-1] not in d:\\n                end.append(res[-1])\\n                res.pop()\\n                continue\\n            fr, to = res[-1], d[res[-1]].pop(0)\\n            res.append(to)\\n            if len(d[fr]) == 0:\\n                d.pop(fr)\\n        \\n        if end:\\n            res += end[::-1]\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets):\\n        d = {}\\n        for ticket in tickets:\\n            if ticket[0] not in d:\\n                d[ticket[0]] = [ticket[1]]\\n            else:\\n                d[ticket[0]].append(ticket[1])\\n                \\n        for ticket in d:\\n            d[ticket].sort()\\n        \\n        res = [\\'JFK\\']\\n        end = []\\n        while d:\\n            if res[-1] not in d:\\n                end.append(res[-1])\\n                res.pop()\\n                continue\\n            fr, to = res[-1], d[res[-1]].pop(0)\\n            res.append(to)\\n            if len(d[fr]) == 0:\\n                d.pop(fr)\\n        \\n        if end:\\n            res += end[::-1]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126087,
                "title": "i-don-t-understand-this-test-case-output",
                "content": "For the given input\\n\\n```[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],[\"TIA\",\"AUA\"],[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ADL\"],[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]```\\n\\nhere\\'s the expected output\\n```[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]```\\n\\nhere\\'s my output\\n```[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"AUA\",\"AXA\",\"TIA\",\"HBA\"]```\\n\\nmy output divert from the expected output at ```TIA -> ADL``` vs. ```TIA -> AUA```. From lexical order, isn\\'t my output is smaller than the expected output?",
                "solutionTags": [],
                "code": "```[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],[\"TIA\",\"AUA\"],[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ADL\"],[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]```\n```[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]```\n```[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"AUA\",\"AXA\",\"TIA\",\"HBA\"]```\n```TIA -> ADL```\n```TIA -> AUA```",
                "codeTag": "Unknown"
            },
            {
                "id": 78844,
                "title": "javascript-solution-160ms-inspired-by-java-greedy-solution",
                "content": "Inspired by [Java Greedy Solution][1] , here is the javascript code. Here is the thought:\\n\\n1. Sort the tickets with alphabetical, then generate a \"hash map\" to store all tickets with key-value.\\n\\n2. After got the alphabetical hash map, get the results with greedy strategy. This is like the DFS.\\n \\n3. Once got one best way and there are still tickets left, need to go back (say point x) and find another way. Since there always a way to have all tickets, so at point x, there wil be one or more circles. \\n\\n`\\n\\n    var findItinerary = function(tickets) {\\n        if (tickets == null || tickets.length == 0) return [];\\n        var map = {};\\n        var result = [];\\n        \\n        tickets.sort(sortArray);\\n        for(var i = 0; i < tickets.length; i++) {\\n            if(tickets[i][0] in map) map[tickets[i][0]].push(tickets[i][1]);\\n            else map[tickets[i][0]] = [tickets[i][1]];\\n        }\\n        \\n        var key = 'JFK';\\n        var drawback = [];\\n        for(var i = 0; i < tickets.length; i++) {\\n            while(!(key in map) || map[key].length == 0) {\\n                drawback.push(key);\\n                key = result.pop();\\n            }\\n            result.push(key);\\n            key = map[key].shift();\\n        }\\n        result.push(key);\\n        while(drawback.length > 0) result.push(drawback.pop());\\n    \\n        return result;\\n        \\n                        \\n    };\\n    \\n    function sortArray(a,b) {\\n        if(a[0] == b[0]) return (a[1] < b[1] ? -1: (a[1] > b[1] ? 1: 0));\\n    \\n        return (a[0] < b[0] ? -1 : 1);\\n    }\\n\\n\\n\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "Inspired by [Java Greedy Solution][1] , here is the javascript code. Here is the thought:\\n\\n1. Sort the tickets with alphabetical, then generate a \"hash map\" to store all tickets with key-value.\\n\\n2. After got the alphabetical hash map, get the results with greedy strategy. This is like the DFS.\\n \\n3. Once got one best way and there are still tickets left, need to go back (say point x) and find another way. Since there always a way to have all tickets, so at point x, there wil be one or more circles. \\n\\n`\\n\\n    var findItinerary = function(tickets) {\\n        if (tickets == null || tickets.length == 0) return [];\\n        var map = {};\\n        var result = [];\\n        \\n        tickets.sort(sortArray);\\n        for(var i = 0; i < tickets.length; i++) {\\n            if(tickets[i][0] in map) map[tickets[i][0]].push(tickets[i][1]);\\n            else map[tickets[i][0]] = [tickets[i][1]];\\n        }\\n        \\n        var key = 'JFK';\\n        var drawback = [];\\n        for(var i = 0; i < tickets.length; i++) {\\n            while(!(key in map) || map[key].length == 0) {\\n                drawback.push(key);\\n                key = result.pop();\\n            }\\n            result.push(key);\\n            key = map[key].shift();\\n        }\\n        result.push(key);\\n        while(drawback.length > 0) result.push(drawback.pop());\\n    \\n        return result;\\n        \\n                        \\n    };\\n    \\n    function sortArray(a,b) {\\n        if(a[0] == b[0]) return (a[1] < b[1] ? -1: (a[1] > b[1] ? 1: 0));\\n    \\n        return (a[0] < b[0] ? -1 : 1);\\n    }\\n\\n\\n\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation",
                "codeTag": "Unknown"
            },
            {
                "id": 78866,
                "title": "share-my-clean-java-code-with-comments-standard-dfs",
                "content": "    /*\\n        -- dfs\\n        -- JFK -- ATL\\n               |\\n               |- SFO\\n               |\\n               --\\n           hashmap <from, list_of_to>, and list_of_to should be sorted.\\n        -- \\u53ea\\u8981\\u641c\\u7d22\\u5230\\u90a3\\u4e2a\\u6700\\u5c0f\\u7684\\u7ed3\\u679c\\u5373\\u53ef\\u505c\\u6b62\\n    */\\n    public class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            Map<String, List<String>> ticketInfo = new HashMap<>();\\n            for (String[] ticket: tickets) {\\n                List<String> destList = ticketInfo.get(ticket[0]);\\n                if (destList == null) {\\n                    destList = new ArrayList<String>();\\n                    ticketInfo.put(ticket[0], destList);\\n                }\\n                destList.add(ticket[1]);\\n            }\\n            for (List<String> destList: ticketInfo.values()) {\\n                Collections.sort(destList);\\n            }\\n            List<String> ans = new ArrayList<>();\\n            ans.add(\"JFK\");\\n            dfs(ans, new ArrayList<String>(), ticketInfo, \"JFK\", tickets.length);\\n            return ans;\\n        }\\n        \\n        private void dfs(List<String> ans, List<String> cur, Map<String, List<String>> ticketInfo, String src, int targetSize) {\\n            if (ans.size() > 1) { return; }  // only need to find the smallest answer\\n            if (cur.size() == targetSize) {  // the smallest answer found\\n                ans.addAll(cur);\\n                return;\\n            }\\n            List<String> destList = ticketInfo.get(src);\\n            if (destList != null) {\\n                for (int i = 0; i < destList.size(); ++i) {\\n                    String dest = destList.remove(i);  // remove this dest so that it will not be visited again\\n                    cur.add(dest);\\n                    dfs(ans, cur, ticketInfo, dest, targetSize);\\n                    cur.remove(cur.size() - 1);\\n                    destList.add(i, dest);  // add this dest back in the list, at its original position\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> findItinerary(String[][] tickets) {\\n            Map<String, List<String>> ticketInfo = new HashMap<>();\\n            for (String[] ticket: tickets) {\\n                List<String> destList = ticketInfo.get(ticket[0]);\\n                if (destList == null) {\\n                    destList = new ArrayList<String>();\\n                    ticketInfo.put(ticket[0], destList);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4043426,
                "title": "graph-java-easy-arraylist-map",
                "content": "This qus is basically the extension of the graph qus **where we have to find the path from the given  virteces  to the whole virteces in directed graph ... **\\n\\nThere we deal with the integer here we are dealing with the string .. \\nOne thing to check is the we have to use backtraking first delete that node from the list and then add after that in dfs .. **Why ?**\\nBcz if we have adjList like  = \"jfk\" - {\"atl\",\"now\"} , \"atl\" - {\"jfk\"} \\nfirst we go the jfk as given in the qus and then will go the atl as lexically smaller and when we go the adjList of atl it will go the jfk and then again we call the atl .. So , this will create a cycle and will trap into it .. so to get out of that trap we have to remove the \"atl\" from the \"jfk\" adjList .. \\n\\n```\\nclass Solution {\\n    \\n    Map<String ,List<String>> h = new HashMap<>();\\n    \\n    List<String > ans = new ArrayList<>();\\n    int totalticket =0;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        \\n        int n = tickets.size();\\n        \\n        totalticket = n+1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            String u = tickets.get(i).get(0);\\n            String v = tickets.get(i).get(1);\\n            \\n            if(h.containsKey(u)){\\n                \\n                h.get(u).add(v);\\n            }else{\\n                \\n                h.put(u,new ArrayList<>());\\n                h.get(u).add(v);\\n            }\\n            \\n        }\\n        \\n        for(List<String> i : h.values()){\\n            \\n            Collections.sort(i);\\n            System.out.println(i);\\n        }\\n        \\n        \\n        dfs(\"JFK\",new ArrayList<String>());\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public boolean dfs(String from, List<String> path){\\n        \\n        path.add(from);\\n        \\n        if(path.size()==totalticket){\\n            ans.addAll(path);\\n            return true;\\n        }\\n        \\n        List<String> neigh = h.get(from);\\n        \\n        if(neigh==null){\\n            \\n            path.remove(from);\\n            return false;\\n        }\\n            \\n        \\n        for(int i=0;i<neigh.size();i++){\\n            \\n            String to = neigh.get(i);\\n            neigh.remove(i);\\n            \\n            if(dfs(to,path)){\\n                return true;\\n            }\\n            \\n            neigh.add(i,to);\\n            \\n        }\\n        \\n        path.remove(path.size()-1);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<String ,List<String>> h = new HashMap<>();\\n    \\n    List<String > ans = new ArrayList<>();\\n    int totalticket =0;\\n    \\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        \\n        \\n        int n = tickets.size();\\n        \\n        totalticket = n+1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            String u = tickets.get(i).get(0);\\n            String v = tickets.get(i).get(1);\\n            \\n            if(h.containsKey(u)){\\n                \\n                h.get(u).add(v);\\n            }else{\\n                \\n                h.put(u,new ArrayList<>());\\n                h.get(u).add(v);\\n            }\\n            \\n        }\\n        \\n        for(List<String> i : h.values()){\\n            \\n            Collections.sort(i);\\n            System.out.println(i);\\n        }\\n        \\n        \\n        dfs(\"JFK\",new ArrayList<String>());\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public boolean dfs(String from, List<String> path){\\n        \\n        path.add(from);\\n        \\n        if(path.size()==totalticket){\\n            ans.addAll(path);\\n            return true;\\n        }\\n        \\n        List<String> neigh = h.get(from);\\n        \\n        if(neigh==null){\\n            \\n            path.remove(from);\\n            return false;\\n        }\\n            \\n        \\n        for(int i=0;i<neigh.size();i++){\\n            \\n            String to = neigh.get(i);\\n            neigh.remove(i);\\n            \\n            if(dfs(to,path)){\\n                return true;\\n            }\\n            \\n            neigh.add(i,to);\\n            \\n        }\\n        \\n        path.remove(path.size()-1);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043338,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        hashm=defaultdict(list)\\n        for i in tickets:\\n            if i[0] in hashm:\\n                hashm[i[0]].append(i[1])\\n            else:\\n                hashm[i[0]]=[i[1]]\\n        for i in hashm:\\n            hashm[i]=sorted(hashm[i], reverse=True)\\n        res=[]\\n        \\n        def dfs(i):\\n            while hashm[i]:\\n                dfs(hashm[i].pop())\\n            res.append(i)\\n            \\n        dfs(\\'JFK\\')\\n        return res[::-1]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        hashm=defaultdict(list)\\n        for i in tickets:\\n            if i[0] in hashm:\\n                hashm[i[0]].append(i[1])\\n            else:\\n                hashm[i[0]]=[i[1]]\\n        for i in hashm:\\n            hashm[i]=sorted(hashm[i], reverse=True)\\n        res=[]\\n        \\n        def dfs(i):\\n            while hashm[i]:\\n                dfs(hashm[i].pop())\\n            res.append(i)\\n            \\n        dfs(\\'JFK\\')\\n        return res[::-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043296,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition and approach discussed in detail in video solution:\\nhttps://youtu.be/jgds9O1RSas\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> graph;\\n        for (auto ticket : tickets){\\n            graph[ticket[0]].insert(ticket[1]);\\n        }\\n        vector<string> path;\\n        builtItn(\"JFK\", graph, path);\\n        return vector<string>(path.rbegin(), path.rend());\\n    }\\n\\n    \\nprivate:\\n    void builtItn(string src, unordered_map<string, multiset<string>> & graph, vector<string> & path) {\\n        while (graph[src].size()) {\\n            string next = *graph[src].begin();\\n            graph[src].erase(graph[src].begin());\\n            builtItn(next, graph, path);\\n        }\\n        path.push_back(src);\\n    }    \\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n      HashMap<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for (var ticket : tickets){\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).offer(ticket.get(1));\\n        }\\n        List<String> path = new ArrayList<>();\\n        builtItn(\"JFK\", graph, path);\\n        return path;\\n    }\\n\\n   \\n    void builtItn(String src, HashMap<String, PriorityQueue<String>> graph, List<String> path) {\\n        PriorityQueue<String> airports = graph.get(src);\\n\\n        while (airports != null && !airports.isEmpty()) {\\n            builtItn(airports.poll(), graph, path);\\n        }\\n        path.add(0, src);\\n    }    \\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, multiset<string>> graph;\\n        for (auto ticket : tickets){\\n            graph[ticket[0]].insert(ticket[1]);\\n        }\\n        vector<string> path;\\n        builtItn(\"JFK\", graph, path);\\n        return vector<string>(path.rbegin(), path.rend());\\n    }\\n\\n    \\nprivate:\\n    void builtItn(string src, unordered_map<string, multiset<string>> & graph, vector<string> & path) {\\n        while (graph[src].size()) {\\n            string next = *graph[src].begin();\\n            graph[src].erase(graph[src].begin());\\n            builtItn(next, graph, path);\\n        }\\n        path.push_back(src);\\n    }    \\n};\\n```\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n      HashMap<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for (var ticket : tickets){\\n            graph.putIfAbsent(ticket.get(0), new PriorityQueue<>());\\n            graph.get(ticket.get(0)).offer(ticket.get(1));\\n        }\\n        List<String> path = new ArrayList<>();\\n        builtItn(\"JFK\", graph, path);\\n        return path;\\n    }\\n\\n   \\n    void builtItn(String src, HashMap<String, PriorityQueue<String>> graph, List<String> path) {\\n        PriorityQueue<String> airports = graph.get(src);\\n\\n        while (airports != null && !airports.isEmpty()) {\\n            builtItn(airports.poll(), graph, path);\\n        }\\n        path.add(0, src);\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043091,
                "title": "this-isn-t-hard-really-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to **build a directed graph representing airport connections** and **use a depth-first search to traverse the graph while ensuring that destinations are visited in lexicographically smallest order**. The reverse order of traversal is corrected by reversing the result list at the end. This approach guarantees the lexicographically smallest itinerary, which is the key requirement of the problem.\\n# Upvote if it helps \\uD83D\\uDE0A\\n1. **LexiSmallerComparator**: This is a custom comparator class that implements the `Comparator` interface. It is used to compare two strings (`s1` and `s2`) lexicographically. The `compare` method returns the result of the `compareTo` method, which uses the natural ordering of strings to determine their lexicographic order. **This comparator is used to order destinations for each airport**.\\n\\n2. **dfs Method**: This is a depth-first search (DFS) traversal method. It takes three parameters: `graph` (a map representing the directed graph of airports), `curr` (the current airport being visited), and `ans` (a list to store the itinerary).\\n\\n   - Inside the method, it checks if the `graph` contains the current airport (`curr`) and if its priority queue (representing destinations) is not empty.\\n   - If the conditions are met, it dequeues the next airport `next` from the priority queue of the current airport.\\n   - Then, it recursively calls `dfs` with the `next` airport as the current one.\\n   - This process continues until there are no more destinations from the current airport.\\n   - Finally, the current airport `curr` is added to the `ans` list, effectively reversing the order of the itinerary (as it\\'s added in a depth-first manner).\\n\\n3. **findItinerary Method**: \\n   - It starts by initializing an empty `graph`, which is a map where each **airport is a key, and the value is a priority queue of destinations (sorted lexicographically)**.\\n   - It then iterates through the `tickets` list, extracting the \"from\" and \"to\" airports from each ticket.\\n   - For each ticket, it checks if the `from` airport is already in the `graph`. If not, it adds an entry with an empty priority queue.\\n   - It then adds the \"to\" airport to the priority queue of the \"from\" airport, ensuring that destinations are sorted lexicographically.\\n   - Next, it initializes an empty `ans` list to store the itinerary.\\n   - It starts the DFS traversal by calling `dfs` with \"JFK\" (the starting airport) as the current airport.\\n   - After the DFS traversal is complete, the `ans` list contains the itinerary in reverse order (due to the depth-first traversal).\\n   - To obtain the correct order, it reverses the `ans` list using `Collections.reverse`.\\n\\n4. Finally, it returns the lexicographically smallest itinerary as a list of strings.\\n\\n# DFS Handles dead-end cases \\nDepth-First Search (DFS) handles dead-end cases by backtracking to the previous valid choice when there are no more unvisited options from the current state. This is achieved through recursion, and in the context of finding an itinerary with the given problem, it means that if there\\'s a dead-end at an airport, the DFS will backtrack to the previous airport where there are unvisited destinations and continue the exploration from there.\\n\\nLet\\'s illustrate this with the provided `tickets` example: ` [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`.\\n\\n1. The DFS starts from \"JFK,\" which is the initial airport.\\n2. From \"JFK,\" there are two options: \"KUL\" and \"NRT.\"\\n   - It chooses \"KUL\" because it\\'s lexicographically smaller and marks it as visited.\\n   - The DFS continues from \"KUL,\" but there are no more unvisited destinations from \"KUL.\"\\n   - At this point, it backtracks to the previous airport, which is \"JFK,\" and checks if there are other unvisited destinations.\\n3. From \"JFK,\" there is still an unvisited option, \"NRT.\"\\n   - It chooses \"NRT\" because it\\'s the only remaining option and marks it as visited.\\n   - The DFS continues from \"NRT,\" but again, there are no more unvisited destinations from \"NRT.\"\\n   - It backtracks to \"JFK\" once more.\\n4. Now, from \"JFK,\" there are no more unvisited destinations.\\n   - It backtracks again, but this time, there\\'s no previous airport to backtrack to because \"JFK\" is the starting point.\\n   - At this point, the DFS traversal ends.\\n\\nThe key point to understand is that when a dead-end is encountered (i.e., no more unvisited destinations from the current airport), the DFS algorithm automatically backtracks to the previous airport where there are unvisited destinations. It keeps doing this until it reaches an airport with unvisited destinations or returns to the starting airport. In this way, it explores all possible routes through the airports to find the lexicographically smallest itinerary.\\n\\nIn the example provided, the algorithm explores all available routes and returns the itinerary: `[\"JFK\", \"NRT\", \"JFK\", \"KUL\"]`, which is the lexicographically smallest valid itinerary for the given tickets.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N * log N)\\n# Code\\n```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        //directed graph mapping \"from\" airport to all its \"to\" airport according to tickets\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for(List<String>t :tickets){\\n            String from = t.get(0), to = t.get(1);\\n            if(!graph.containsKey(from)){\\n                graph.put(from, new PriorityQueue<>(new LexiSmallerComparator()));\\n            }\\n            graph.get(from).add(to);\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        dfs(graph, \"JFK\", ans);//depart from JFK\\n        \\n        //reverse to get correct order\\n        Collections.reverse(ans);\\n\\n        return ans;\\n    }\\n\\n\\n    // Custom comparator for lexicographically smaller strings\\n    static class LexiSmallerComparator implements Comparator<String> {\\n        @Override\\n        public int compare(String s1, String s2) {\\n            return s1.compareTo(s2); // Use the natural ordering of strings\\n        }\\n    }\\n\\n    // Helper method for DFS traversal\\n    private void dfs(Map<String, PriorityQueue<String>> graph, String curr, List<String> ans) {\\n        while (graph.containsKey(curr) && !graph.get(curr).isEmpty()) {\\n            String next = graph.get(curr).poll();\\n            dfs(graph, next, ans);\\n        }\\n        ans.add(curr);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n\\n        //directed graph mapping \"from\" airport to all its \"to\" airport according to tickets\\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\\n        for(List<String>t :tickets){\\n            String from = t.get(0), to = t.get(1);\\n            if(!graph.containsKey(from)){\\n                graph.put(from, new PriorityQueue<>(new LexiSmallerComparator()));\\n            }\\n            graph.get(from).add(to);\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        dfs(graph, \"JFK\", ans);//depart from JFK\\n        \\n        //reverse to get correct order\\n        Collections.reverse(ans);\\n\\n        return ans;\\n    }\\n\\n\\n    // Custom comparator for lexicographically smaller strings\\n    static class LexiSmallerComparator implements Comparator<String> {\\n        @Override\\n        public int compare(String s1, String s2) {\\n            return s1.compareTo(s2); // Use the natural ordering of strings\\n        }\\n    }\\n\\n    // Helper method for DFS traversal\\n    private void dfs(Map<String, PriorityQueue<String>> graph, String curr, List<String> ans) {\\n        while (graph.containsKey(curr) && !graph.get(curr).isEmpty()) {\\n            String next = graph.get(curr).poll();\\n            dfs(graph, next, ans);\\n        }\\n        ans.add(curr);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042919,
                "title": "reconstruct-itinerary-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(string& airport, unordered_map<string, vector<string>>& graph,vector<string>& itinerary){\\n        while(!graph[airport].empty()){\\n            string next = graph[airport].back();\\n            graph[airport].pop_back();\\n            dfs(next, graph, itinerary);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n\\n        for(auto& ticket : tickets){\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        for(auto& temp : graph){\\n            sort(temp.second.rbegin(), temp.second.rend());\\n        }\\n\\n        vector<string> itinerary;\\n        string jfk = \"JFK\";\\n        dfs(jfk, graph, itinerary);\\n\\n        reverse(itinerary.begin(), itinerary.end());\\n\\n        return itinerary;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Eulerian Circuit"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(string& airport, unordered_map<string, vector<string>>& graph,vector<string>& itinerary){\\n        while(!graph[airport].empty()){\\n            string next = graph[airport].back();\\n            graph[airport].pop_back();\\n            dfs(next, graph, itinerary);\\n        }\\n        itinerary.push_back(airport);\\n    }\\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\\n        unordered_map<string, vector<string>> graph;\\n\\n        for(auto& ticket : tickets){\\n            graph[ticket[0]].push_back(ticket[1]);\\n        }\\n        for(auto& temp : graph){\\n            sort(temp.second.rbegin(), temp.second.rend());\\n        }\\n\\n        vector<string> itinerary;\\n        string jfk = \"JFK\";\\n        dfs(jfk, graph, itinerary);\\n\\n        reverse(itinerary.begin(), itinerary.end());\\n\\n        return itinerary;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042807,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        adj={}\\n        for ticket in tickets:\\n            adj[ticket[0]]=[]\\n            adj[ticket[1]]=[]\\n\\n        for ticket in tickets:\\n            adj[ticket[0]].append(ticket[1])\\n\\n        for l in adj.values():\\n            l.sort()\\n\\n        ans=[]\\n        def helper(node):\\n            while adj[node]:\\n                helper(adj[node].pop(0))\\n\\n            ans.append(node)\\n        helper(\"JFK\")\\n        return reversed(ans)                   \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        adj={}\\n        for ticket in tickets:\\n            adj[ticket[0]]=[]\\n            adj[ticket[1]]=[]\\n\\n        for ticket in tickets:\\n            adj[ticket[0]].append(ticket[1])\\n\\n        for l in adj.values():\\n            l.sort()\\n\\n        ans=[]\\n        def helper(node):\\n            while adj[node]:\\n                helper(adj[node].pop(0))\\n\\n            ans.append(node)\\n        helper(\"JFK\")\\n        return reversed(ans)                   \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042764,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Create a graph for each airport and keep list of airport reachable from it\\n        graph = defaultdict(list)\\n        for src, dst in sorted(tickets)[::-1]:\\n            graph[src].append(dst)\\n\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].pop())\\n            route.append(stack.pop())\\n\\n        return route[::-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        # Create a graph for each airport and keep list of airport reachable from it\\n        graph = defaultdict(list)\\n        for src, dst in sorted(tickets)[::-1]:\\n            graph[src].append(dst)\\n\\n        route, stack = [], [\\'JFK\\']\\n        while stack:\\n            while graph[stack[-1]]:\\n                stack.append(graph[stack[-1]].pop())\\n            route.append(stack.pop())\\n\\n        return route[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042221,
                "title": "c-solution-for-reconstruct-itinerary-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to construct a graph where airports are nodes, and directed edges represent flight routes. Then, perform a depth-first search (DFS) starting from the \\u201CJFK\\u201D airport while ensuring that you use all the given tickets and choose the lexicographically smallest path when multiple options are available.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.\\tBuild a directed graph where the keys are departure airports, and values are lists of arrival airports. Sort these lists lexicographically.\\n2.\\tInitialize an empty list for the itinerary.\\n3.\\tStart the DFS from \\u201CJFK\\u201D, repeatedly choosing the smallest lexicographically destination while removing edges as you go.\\n4.\\tReverse the final itinerary since DFS appends nodes in reverse order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\u2022\\tConstructing the graph takes O(NlogN), where N is the number of tickets. Sorting the destinations for each airport takes O(NlogN) in total.\\n\\u2022\\tThe DFS traversal explores each edge exactly once, taking O(N) time.\\n\\u2022\\tOverall, the time complexity is O(NlogN) for graph construction and O(N) for DFS, resulting in O(NlogN) in total.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\u2022\\tThe space complexity is dominated by the graph data structure, which requires O(N) space for storing the airport nodes and their destinations.\\n\\u2022\\tAdditionally, the DFS call stack can go as deep as the number of tickets, resulting in a space complexity of O(N).\\n\\u2022\\tOverall, the space complexity is O(N).\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        Dictionary<string, List<string>> graph = new Dictionary<string, List<string>>();\\n        List<string> itinerary = new List<string>();\\n\\n        // Build the graph from the given tickets\\n        foreach (var ticket in tickets) {\\n            string from = ticket[0];\\n            string to = ticket[1];\\n            if (!graph.ContainsKey(from)) {\\n                graph[from] = new List<string>();\\n            }\\n            graph[from].Add(to);\\n        }\\n\\n        // Sort the destinations in lexical order\\n        foreach (var key in graph.Keys) {\\n            graph[key].Sort();\\n        }\\n\\n        // Start the DFS from JFK\\n        DFS(graph, \"JFK\", itinerary);\\n\\n        // Reverse the itinerary since DFS appends in reverse order\\n        itinerary.Reverse();\\n        return itinerary;\\n    }\\n\\n    private void DFS(Dictionary<string, List<string>> graph, string airport, List<string> itinerary) {\\n        if (graph.ContainsKey(airport) && graph[airport].Count > 0) {\\n            List<string> destinations = graph[airport];\\n            while (destinations.Count > 0) {\\n                string nextAirport = destinations[0];\\n                destinations.RemoveAt(0);\\n                DFS(graph, nextAirport, itinerary);\\n            }\\n        }\\n        itinerary.Add(airport);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\\n        Dictionary<string, List<string>> graph = new Dictionary<string, List<string>>();\\n        List<string> itinerary = new List<string>();\\n\\n        // Build the graph from the given tickets\\n        foreach (var ticket in tickets) {\\n            string from = ticket[0];\\n            string to = ticket[1];\\n            if (!graph.ContainsKey(from)) {\\n                graph[from] = new List<string>();\\n            }\\n            graph[from].Add(to);\\n        }\\n\\n        // Sort the destinations in lexical order\\n        foreach (var key in graph.Keys) {\\n            graph[key].Sort();\\n        }\\n\\n        // Start the DFS from JFK\\n        DFS(graph, \"JFK\", itinerary);\\n\\n        // Reverse the itinerary since DFS appends in reverse order\\n        itinerary.Reverse();\\n        return itinerary;\\n    }\\n\\n    private void DFS(Dictionary<string, List<string>> graph, string airport, List<string> itinerary) {\\n        if (graph.ContainsKey(airport) && graph[airport].Count > 0) {\\n            List<string> destinations = graph[airport];\\n            while (destinations.Count > 0) {\\n                string nextAirport = destinations[0];\\n                destinations.RemoveAt(0);\\n                DFS(graph, nextAirport, itinerary);\\n            }\\n        }\\n        itinerary.Add(airport);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023548,
                "title": "eulerian-path-easy-implementation-c",
                "content": "# Intuition\\nRefer This Video By PepCoding\\n\\nhttps://www.youtube.com/watch?v=U33blOQRaJ0\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<string> findItinerary(vector<vector<string>> &tickets)\\n    {\\n        unordered_map<string,vector<string>>graph;\\n\\n        for (const auto ticket : tickets){\\n            string departure = ticket[0];\\n            string arrival = ticket[1];\\n            graph[departure].push_back(arrival);\\n        }\\n\\n        for (auto &destinations : graph){\\n            sort(destinations.second.begin() , destinations.second.end());\\n        }\\n\\n        stack<string>st;\\n        vector<string>circuit;\\n        st.push(\"JFK\");\\n\\n        while(!st.empty()){\\n            auto curr = st.top();\\n\\n            if(graph.find(curr) == graph.end() || graph[curr].empty()){ // if we have reached a dead end or we have no more outgoing edges\\n                circuit.push_back(curr);\\n                st.pop();\\n            } else {\\n                string next = graph[curr][0];   // take the first edge\\n                graph[curr].erase(graph[curr].begin()); // remove the edge\\n                st.push(next);\\n            }\\n        }\\n        reverse(circuit.begin() , circuit.end());\\n        return circuit;\\n    }\\n};\\n\\n/*\\n\\nEulerian Circuit {\\n    src -> extra outdegree  \\n    dest -> extra indegree\\n    other nodes -> indegree == outdegree\\n\\n    Eulerian Path is a path in a graph that visits every edge exactly once. Eulerian Circuit is an Eulerian Path that starts and ends on the same vertex\\n}\\n\\ncharacteristics of Eulerian Path {\\n    1. Undirected graph\\n    2. All vertices with non-zero degree are connected\\n    3. All vertices have even degree\\n}\\n \\nAlgorithm {\\n    1. Find the number of vertices with odd degree. Let this number be n.\\n    2. If n is greater than 2, then no Eulerian path exists. If n is 0, then all Eulerian cycles and paths are possible. If n is 2, then a Eulerian path exists\\n    3. If n is 1, then there is no Eulerian path\\n    4. Let u be one vertex with odd degree. If u is connected to all other vertices, then print Eulerian Path starts with u. Else print Eulerian Path starts with v\\n}\\n\\nConnect Me - Avijit Sen\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<string> findItinerary(vector<vector<string>> &tickets)\\n    {\\n        unordered_map<string,vector<string>>graph;\\n\\n        for (const auto ticket : tickets){\\n            string departure = ticket[0];\\n            string arrival = ticket[1];\\n            graph[departure].push_back(arrival);\\n        }\\n\\n        for (auto &destinations : graph){\\n            sort(destinations.second.begin() , destinations.second.end());\\n        }\\n\\n        stack<string>st;\\n        vector<string>circuit;\\n        st.push(\"JFK\");\\n\\n        while(!st.empty()){\\n            auto curr = st.top();\\n\\n            if(graph.find(curr) == graph.end() || graph[curr].empty()){ // if we have reached a dead end or we have no more outgoing edges\\n                circuit.push_back(curr);\\n                st.pop();\\n            } else {\\n                string next = graph[curr][0];   // take the first edge\\n                graph[curr].erase(graph[curr].begin()); // remove the edge\\n                st.push(next);\\n            }\\n        }\\n        reverse(circuit.begin() , circuit.end());\\n        return circuit;\\n    }\\n};\\n\\n/*\\n\\nEulerian Circuit {\\n    src -> extra outdegree  \\n    dest -> extra indegree\\n    other nodes -> indegree == outdegree\\n\\n    Eulerian Path is a path in a graph that visits every edge exactly once. Eulerian Circuit is an Eulerian Path that starts and ends on the same vertex\\n}\\n\\ncharacteristics of Eulerian Path {\\n    1. Undirected graph\\n    2. All vertices with non-zero degree are connected\\n    3. All vertices have even degree\\n}\\n \\nAlgorithm {\\n    1. Find the number of vertices with odd degree. Let this number be n.\\n    2. If n is greater than 2, then no Eulerian path exists. If n is 0, then all Eulerian cycles and paths are possible. If n is 2, then a Eulerian path exists\\n    3. If n is 1, then there is no Eulerian path\\n    4. Let u be one vertex with odd degree. If u is connected to all other vertices, then print Eulerian Path starts with u. Else print Eulerian Path starts with v\\n}\\n\\nConnect Me - Avijit Sen\\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3576873,
                "title": "using-eulerian-circuit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve the problem using Eulerian Circuit, we can follow these steps:\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n 1. Create a graph using the given tickets, where each airport is represented as a node, and the flights between airports are represented as edges.\\n\\n 2. Sort the destinations (arrival airports) in lexicographic order for each departure airport. This ensures that we visit the smaller destination\\n first in case of multiple flights from the same departure airport.\\n\\n 3. Initialize an empty stack and push the starting airport, \"JFK\", onto the stack.\\n\\n 4. While the stack is not empty, do the following:\\n - Peek the top airport from the stack.\\n - If the airport has any remaining destinations, select the smallest lexicographic destination and push it onto the stack.\\n - If the airport has no remaining destinations, pop the airport from the stack and add it to the itinerary list.\\n\\n 5. Reverse the itinerary list to get the correct order of airports visited.\\n\\n 6. Return the itinerary list.\\n\\n For the given example:\\n\\n Input: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\\n\\n The itinerary using Eulerian Circuit will be:\\n\\n 1. Create a graph: JFK -> MUC -> LHR -> SFO -> SJC\\n 2. Sort destinations: JFK -> MUC -> LHR -> SFO -> SJC\\n 3. Start with JFK, push JFK onto the stack.\\n 4. Stack: [JFK]\\n 5. JFK has destinations MUC. Push MUC onto the stack.\\n 6. Stack: [JFK, MUC]\\n 7. MUC has destinations LHR. Push LHR onto the stack.\\n 8. Stack: [JFK, MUC, LHR]\\n 9. LHR has destinations SFO. Push SFO onto the stack.\\n 10. Stack: [JFK, MUC, LHR, SFO]\\n 11. SFO has destination SJC. Push SJC onto the stack.\\n 12. Stack: [JFK, MUC, LHR, SFO, SJC]\\n 13. SJC has no remaining destinations. Pop SJC from the stack and add it to the itinerary list.\\n 14. Stack: [JFK, MUC, LHR, SFO]\\n 15. SFO has no remaining destinations. Pop SFO from the stack and add it to the itinerary list.\\n 16. Stack: [JFK, MUC, LHR]\\n 17. LHR has no remaining destinations. Pop LHR from the stack and add it to the itinerary list.\\n 18. Stack: [JFK, MUC]\\n 19. MUC has no remaining destinations. Pop MUC from the stack and add it to the itinerary list.\\n 20. Stack: [JFK]\\n 21. JFK has no remaining destinations. Pop JFK from the stack and add it to the itinerary list.\\n 22. Stack: []\\n\\n Reverse the itinerary list: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\\n\\n Return the itinerary list: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\\n\\n# Complexity\\n- Time complexity:O(E log E).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nimport java.util.*;\\n\\npublic class ReconstructItineraryUsingEulerianCircuit2 {\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, List<String>> graph = new HashMap<>();\\n\\n        // Step 1: Construct the graph\\n        for (List<String> ticket : tickets) {\\n            String departure = ticket.get(0);\\n            String arrival = ticket.get(1);\\n\\n            graph.putIfAbsent(departure, new ArrayList<>());\\n            graph.get(departure).add(arrival);\\n        }\\n\\n        // Step 3: Sort the lists of destinations\\n        for (List<String> destinations : graph.values()) {\\n            Collections.sort(destinations);\\n        }\\n\\n        Stack<String> stack = new Stack<>();\\n        List<String> circuit = new ArrayList<>();\\n\\n        // Step 6: Push the starting airport to the stack\\n        stack.push(\"JFK\");\\n\\n        // Step 7: Perform DFS using stack\\n        while (!stack.isEmpty()) {\\n            String current = stack.peek();\\n\\n            // Step 7b: If current airport has no outgoing edges, add it to the circuit\\n            if (!graph.containsKey(current) || graph.get(current).isEmpty()) {\\n                circuit.add(stack.pop());\\n            } else {\\n                // Step 7c: Push the next unvisited destination to the stack and remove the edge from the graph\\n                stack.push(graph.get(current).remove(0));\\n            }\\n        }\\n\\n        // Step 8: Reverse the circuit to get the correct order\\n        Collections.reverse(circuit);\\n\\n        return circuit;\\n    }\\n    public static void main(String[] args) {\\n        List<List<String>> tickets = new ArrayList<>();\\n//        tickets.add(Arrays.asList(\"MUC\", \"LHR\"));\\n//        tickets.add(Arrays.asList(\"JFK\", \"MUC\"));\\n//        tickets.add(Arrays.asList(\"SFO\", \"SJC\"));\\n//        tickets.add(Arrays.asList(\"LHR\", \"SFO\"));\\n\\n        tickets.add(Arrays.asList(\"JFK\",\"SFO\"));\\n        tickets.add(Arrays.asList(\"JFK\",\"ATL\"));\\n        tickets.add(Arrays.asList(\"SFO\",\"ATL\"));\\n        tickets.add(Arrays.asList(\"ATL\",\"JFK\"));\\n        tickets.add(Arrays.asList(\"ATL\",\"SFO\"));\\n\\n\\n        ReconstructItineraryUsingEulerianCircuit solution = new ReconstructItineraryUsingEulerianCircuit();\\n        List<String> itinerary = solution.findItinerary(tickets);\\n        System.out.println(itinerary);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Eulerian Circuit"
                ],
                "code": "```\\n\\nimport java.util.*;\\n\\npublic class ReconstructItineraryUsingEulerianCircuit2 {\\n\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n        Map<String, List<String>> graph = new HashMap<>();\\n\\n        // Step 1: Construct the graph\\n        for (List<String> ticket : tickets) {\\n            String departure = ticket.get(0);\\n            String arrival = ticket.get(1);\\n\\n            graph.putIfAbsent(departure, new ArrayList<>());\\n            graph.get(departure).add(arrival);\\n        }\\n\\n        // Step 3: Sort the lists of destinations\\n        for (List<String> destinations : graph.values()) {\\n            Collections.sort(destinations);\\n        }\\n\\n        Stack<String> stack = new Stack<>();\\n        List<String> circuit = new ArrayList<>();\\n\\n        // Step 6: Push the starting airport to the stack\\n        stack.push(\"JFK\");\\n\\n        // Step 7: Perform DFS using stack\\n        while (!stack.isEmpty()) {\\n            String current = stack.peek();\\n\\n            // Step 7b: If current airport has no outgoing edges, add it to the circuit\\n            if (!graph.containsKey(current) || graph.get(current).isEmpty()) {\\n                circuit.add(stack.pop());\\n            } else {\\n                // Step 7c: Push the next unvisited destination to the stack and remove the edge from the graph\\n                stack.push(graph.get(current).remove(0));\\n            }\\n        }\\n\\n        // Step 8: Reverse the circuit to get the correct order\\n        Collections.reverse(circuit);\\n\\n        return circuit;\\n    }\\n    public static void main(String[] args) {\\n        List<List<String>> tickets = new ArrayList<>();\\n//        tickets.add(Arrays.asList(\"MUC\", \"LHR\"));\\n//        tickets.add(Arrays.asList(\"JFK\", \"MUC\"));\\n//        tickets.add(Arrays.asList(\"SFO\", \"SJC\"));\\n//        tickets.add(Arrays.asList(\"LHR\", \"SFO\"));\\n\\n        tickets.add(Arrays.asList(\"JFK\",\"SFO\"));\\n        tickets.add(Arrays.asList(\"JFK\",\"ATL\"));\\n        tickets.add(Arrays.asList(\"SFO\",\"ATL\"));\\n        tickets.add(Arrays.asList(\"ATL\",\"JFK\"));\\n        tickets.add(Arrays.asList(\"ATL\",\"SFO\"));\\n\\n\\n        ReconstructItineraryUsingEulerianCircuit solution = new ReconstructItineraryUsingEulerianCircuit();\\n        List<String> itinerary = solution.findItinerary(tickets);\\n        System.out.println(itinerary);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756709,
                "title": "java-solution-short-and-concise",
                "content": "class Solution {\\n    List<String> res= new ArrayList<>();\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n     \\n        HashMap<String,PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            String to = tickets.get(i).get(0);\\n            String from = tickets.get(i).get(1);\\n            \\n            if(!map.containsKey(to)){\\n                map.put(to,new PriorityQueue<>());\\n            }\\n            map.get(to).add(from);\\n        }\\n        \\n        dfs(map,\"JFK\");\\n        Collections.reverse(res);\\n        return res;\\n    }\\n    private void dfs(HashMap<String,PriorityQueue<String>> map,String source){\\n        \\n        PriorityQueue<String> temp = map.get(source);\\n        if(temp != null){\\n            while(!temp.isEmpty()){\\n                dfs(map,temp.poll());\\n            }\\n        }\\n        res.add(source);\\n    }\\n}\\n\\n// For faster approach you can also use linkedList instead of PriorityQueue As remove will change to 0(1) time complexity But first you will have to sort the linkedList in the map.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    List<String> res= new ArrayList<>();\\n    public List<String> findItinerary(List<List<String>> tickets) {\\n     \\n        HashMap<String,PriorityQueue<String>> map = new HashMap<>();\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            String to = tickets.get(i).get(0);\\n            String from = tickets.get(i).get(1);\\n            \\n            if(!map.containsKey(to)){\\n                map.put(to,new PriorityQueue<>());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2412359,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> findItinerary(List<List<String>> t) {\\n        Stack<String> kk=new Stack<>();\\n        Map<String,PriorityQueue<String>> nm=new HashMap<>();\\n        for(int i=0;i<t.size();i++)\\n        {\\n            String k=t.get(i).get(0);\\n            if(!nm.containsKey(k))\\n                nm.put(k, new PriorityQueue<String>());\\n            nm.get(k).offer(t.get(i).get(1));\\n        }\\n        List<String> p=new ArrayList<>();\\n        kk.push(\"JFK\");\\n        while(!kk.isEmpty())\\n        {\\n            String f=kk.peek();\\n            if(nm.containsKey(f) && nm.get(f).size()>0)\\n                kk.push(nm.get(f).poll());\\n            else\\n                p.add(0,kk.pop());\\n        }\\n        return p;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public List<String> findItinerary(List<List<String>> t) {\\n        Stack<String> kk=new Stack<>();\\n        Map<String,PriorityQueue<String>> nm=new HashMap<>();\\n        for(int i=0;i<t.size();i++)\\n        {\\n            String k=t.get(i).get(0);\\n            if(!nm.containsKey(k))\\n                nm.put(k, new PriorityQueue<String>());\\n            nm.get(k).offer(t.get(i).get(1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2299450,
                "title": "c-simple-code-but-hard-question",
                "content": "```\\n#include <bits/stdc++.h>\\n#define mp unordered_map<string, priority_queue<string, vector<string>, greater<string>>>\\n\\nclass Solution {\\npublic:\\n    \\n    void dfs(string start, mp& adj, stack<string>& stk ){\\n        auto& minPQ= adj[start];\\n    \\n        while(!minPQ.empty()){\\n            string baccha= minPQ.top(); // lexixographical chota baccha\\n            minPQ.pop(); // after using edge, delete it so that we can ever use it again\\n\\n            dfs(baccha, adj, stk);\\n        }\\n\\n        stk.push(start);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& ticket) {\\n        mp adj;\\n        \\n        for(int i=0; i<ticket.size(); i++){\\n            string u= ticket[i][0];  string v= ticket[i][1];\\n            adj[u].push(v);\\n        }\\n        \\n        stack<string> stk;\\n        // no need of visited array. As we can visit node multiple time. We just need to visit every edge only once\\n        dfs(\"JFK\", adj, stk); \\n        \\n        vector<string> ans; \\n        while(!stk.empty()){  ans.push_back(stk.top());  stk.pop();  }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n#define mp unordered_map<string, priority_queue<string, vector<string>, greater<string>>>\\n\\nclass Solution {\\npublic:\\n    \\n    void dfs(string start, mp& adj, stack<string>& stk ){\\n        auto& minPQ= adj[start];\\n    \\n        while(!minPQ.empty()){\\n            string baccha= minPQ.top(); // lexixographical chota baccha\\n            minPQ.pop(); // after using edge, delete it so that we can ever use it again\\n\\n            dfs(baccha, adj, stk);\\n        }\\n\\n        stk.push(start);\\n        return;\\n    }\\n    \\n    vector<string> findItinerary(vector<vector<string>>& ticket) {\\n        mp adj;\\n        \\n        for(int i=0; i<ticket.size(); i++){\\n            string u= ticket[i][0];  string v= ticket[i][1];\\n            adj[u].push(v);\\n        }\\n        \\n        stack<string> stk;\\n        // no need of visited array. As we can visit node multiple time. We just need to visit every edge only once\\n        dfs(\"JFK\", adj, stk); \\n        \\n        vector<string> ans; \\n        while(!stk.empty()){  ans.push_back(stk.top());  stk.pop();  }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 2056751,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 2056733,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1564686,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1564987,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 2056771,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1573824,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1567957,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1568233,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1568031,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1567323,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 2056751,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 2056733,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1564686,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1564987,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 2056771,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1573824,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1567957,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1568233,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1568031,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1567323,
                "content": [
                    {
                        "username": "TangoBee",
                        "content": "ME:\\n![LeetCode Hardcore](https://i.imgflip.com/7z2hed.jpg)"
                    },
                    {
                        "username": "ssglob",
                        "content": "..."
                    },
                    {
                        "username": "Not_Mahak_Gupta",
                        "content": "same..."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "US*"
                    },
                    {
                        "username": "mochy",
                        "content": "It\\'s not the weekend yet..."
                    },
                    {
                        "username": "salilrr",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow could \"NRT\" have a higher lexical ordering than \"KUL\"?"
                    },
                    {
                        "username": "Omkar_Alase",
                        "content": "Is this based on the outbound count - Let\\'s say if the the their are more than one \"TO\" associated with \"FROM\" then we choose the one with maximum outbound - if their is clash then we go for lexicographical "
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "You must use all the tickets once."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "7 years later I got the same doubt initially. \\uD83D\\uDE05"
                    },
                    {
                        "username": "bparanj",
                        "content": "The output is incorrect because the solution didn\\'t account for the case where going to a lexicographically larger destination (\"NRT\" in this case) would actually allow using all the tickets.\\n\\nIn this example, if you go from \"JFK\" to \"KUL\" first, you won\\'t be able to use the [\"NRT\", \"JFK\"] ticket. The lexicographically smaller choice traps you into a suboptimal itinerary.\\n\\nSo, while it\\'s tempting to always pick the lexicographically smaller airport, it\\'s essential to consider the entire itinerary to make sure all tickets are used. This case highlights the need for backtracking or other methods to explore multiple paths."
                    },
                    {
                        "username": "code_mode",
                        "content": "you are right, first we go to KUL, and then we call ```if dfs(\"KUL\")``` return False since we do not have any destination from KUL in our adjacency list. That\\'s why we go and execute res.pop() to pop out KUL. And then we go to NRT, from NRT back to JFK. Here len(res) is 3[JFK, NRT, JFK]. After we run for v in adj[\"JFK\"] here we go to KUL and call ```dfs(\"KUL\")``` here. if len(res) == len(tickets) + 1 is TRUE now so it returns TRUE it returns res."
                    },
                    {
                        "username": "AndrasCsanyi",
                        "content": "[@heman10pandey](/heman10pandey) I assume this sentence covers what you say. \"You must use all the tickets once and only once.\"\\n\\nSo, this is the reason why this exercise is hard. You have to write logic of when there is no further path however not all \"tickets\" used up you have to find another path using up all the tickets."
                    },
                    {
                        "username": "heman10pandey",
                        "content": "KUL cannot be before NRT because from KUL  we cannot go anywhere and in the question it is mentioned that we have to go to all the places so ...for that reason first we have to go to NRT and after coming from NRT we have to visit KUL at the end..."
                    },
                    {
                        "username": "flame5659",
                        "content": "up vote"
                    },
                    {
                        "username": "soham6",
                        "content": "When input is [ [\"JFK\",\"LHR\"] ,[\"JFK\",\"MUC\"] ]\\n\\nthe output expected is [\"JFK\", \"LHR\",\"MUC\" ]\\n\\nthis is wrong because the person does not have a ticket from LHR to MUC at all! where did the concept of \"from\" and \"to\" go ??"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "now it\\'s a failed test case"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The expected output [\"JFK\", \"LHR\", \"MUC\"] is incorrect based on the problem statement. According to the given tickets, you can only fly from \"JFK\" to either \"LHR\" or \"MUC.\" There is no ticket allowing a flight from \"LHR\" to \"MUC,\" so the expected output violates the problem\\'s constraints.\\n\\nThe concept of \"from\" and \"to\" must be strictly adhered to when reconstructing the itinerary. If there\\'s no ticket for a specific leg, that path is not valid. Based on the input [[\"JFK\",\"LHR\"],[\"JFK\",\"MUC\"]], the only valid itineraries are [\"JFK\", \"LHR\"] or [\"JFK\", \"MUC\"], not [\"JFK\", \"LHR\", \"MUC\"]."
                    },
                    {
                        "username": "nandoaires",
                        "content": "This fails the description, where it\\'s stated that \"You may assume all tickets form at least one valid itinerary.\""
                    },
                    {
                        "username": "anwendeng",
                        "content": "That's Euler's path problem, probably for finding path.\nThe initial v   must have indeg(v)+1=outdeg(v) or indeg(v)=outdeg(v) (if an Euler cycle) the terminal vertex w has indeg(w)=outdeg(w)+1 or indeg(w)=outdeg(w) (if an Euler cycle v=w)\nFor other vertex vi has indeg(vi)=outdeg(vi).\nHopefully, it's useful for solving question\nProvide a solution using priority_queue different from others.\nSolve Leetcode 2097. Valid Arrangement of Pairs!!!\n# Knigsberg  7 bridges problem\n![images.jfif](https://assets.leetcode.com/users/images/44b9b15a-6e6b-4ee1-bdff-95c952ff421d_1694703689.5281713.jpeg)"
                    },
                    {
                        "username": "lolok123",
                        "content": "If the cities/airports are considered the nodes of a graph and the tickets from one city to another the directed edges of this graph, this problem reduces to that of finding an Eulerian path in a directed graph.\\nFirst consider the related problem of finding an Eulerian circuit in the graph. There are multiple algorithms proposed for this, one of them follows:\\n**Algorithm 1**\\n1. Choose any starting vertex.\\n2. Find any cycle starting and ending at this vertex.\\n3. Find the Eulerian circuit starting at this vertex, after removing all the edges in the cycle chosen in the previous step.\\n4. Prepend all the edges in this cycle to the path found in the previous step.\\n5. The path so obtained is an Eulerian circuit in this graph.\\n\\nAssume a fixed starting vertex. Of all the circuits possible starting and ending at this vertex, one of them must be the lexicographical smallest (the set of all Eulerian circuits is finite as all the edges can be traversed exactly once, and thus this set is a subset of all permutations of the edges, which is finite; and the lexicographical order is a total order). This can be found greedily.\\nThe algorithm is as follows:\\n**Algorithm 2**\\n1. Choose the lexicographically smallest cycle passing through the starting vertex.\\n2. Remove all edges in this cycle from the graph. Find the lexicographically smallest Eulerian circuit in the remaining graph.\\n3. Prepend the edges in the cycle in step 2 to the circuit in step 3.\\n4. The circuit so obtained is the Eulerian circuit of the graph.\\n\\nThis greedy algorithm is correct as it satisfies the two properties of a greedy algorithm.\\n1. Greedy choice: \\n\\tConsider the first cycle in the lexicographically smallest circuit. It is either the same cycle chosen by Algorithm 2, or it is a lexicographically larger cycle. If it is a lexicographically larger cycle, then it is a part of a lexicographically larger circuit than the circuit produced by this algorithm; a contradiction. Thus it must be the same cycle. Hence, a solution with the greedy choice exists.\\n2. Optimal substructure:\\n\\tConsider an optimal circuit for the subproblem. It must consist entirely of cycles not sharing any edges with the cycle chosen by Algorithm 2. Prepending this cycle to the circuit gives a circuit lexicographically lesser than or equal to that proposed in the greedy choice section. Since that circuit was the lexicographically smallest, so must this.\\n\\t\\nThus this algorithm is correct.\\n\\nNow to the original problem. An Eulerian path is clearly made up of one path connecting two vertices, on each of whose vertices there are Eulerian circuits, possibly empty. Thus the final algorithm:\\n\\n**Algorithm 3**\\n1. Let the starting node be the one corresponding to JFK.\\n2. Perform a DFS from this node choosing the lexicographically smallest target city at each stage, removing each edge from the graph as it is traversed and storing it separately. Some cycles may be found in this process. It is of no concern.\\n3. At some point, an edge will be reached from where there are no outgoing edges. There may have been edges coming into and going out of this node earlier, which were removed and stored earlier. Also there must have been exactly one more incoming edge than there were outgoing edges. This node exists because the question guarantees the existence of an Eulerian path, and it is a property of Eulerian paths that such a node must exist. In fact, there should also be a node with one extra outgoing edge, which in this question is the node corresponding to JFK.\\n4. Having found the path connecting the starting and ending vertices of the Eulerian path, the rest of the edges must form Eulerian sub-circuits, the lexicographically smallest of which can be found by Algorithm 2. Also, these sub-circuits must be \"attached\" at the last occurrence of the vertex in the path found in step 3, as the edges chosen in step 2 were the lexicographically smallest, and must come before the edges in this sub-circuit.\\n5. This way, the lexicographically smallest Eulerian circuit is formed.\\n\\nThis algorithm can be easily implemented using a stack."
                    },
                    {
                        "username": "maxtang",
                        "content": "Input:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nCould some one explain the output of this test case for me?"
                    },
                    {
                        "username": "richmanpoorman",
                        "content": "[@SMajumder2003](/SMajumder2003) Why is do you have to start with JFK? You can go start with the second ticket, starting at ATL, then going to JFK, then using the first ticket to go back to ATL, so it should look like ATL-->JFK-->ATL; what is the problem with that?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "See first is JFK-ATL, after that the pair is ATL JFK, so there are three stoppages, JFK is common in both pair, as well as ATL too. So, here first stoppage is JFK and go to ATL, then halt. Finally, return path from ATL to JFK, so output graph would be JFK ----->ATL, return ATL<------JFK.\\nSo, final graph has two paths forward path and backward path and two nodes (JFK, ATL), Left node is JFK and right node is ATL, and there are two paths between them like in the example 2 given in the question a triangle one."
                    },
                    {
                        "username": "ReLLiK12",
                        "content": "The itenary must mandatorly start from \"JFK\", then look for lexicographical order."
                    },
                    {
                        "username": "atulcoe",
                        "content": "How we have derived ouput as \\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"] \\n\\nfor  input \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nIf we have source as JFK then we have two destination i.e KUL and NRT. As per descripiton we should choose smallest  lexical order. And that should be \"KUL\"\\nAm  I missing anything ?"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "watch this - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "shivam_7777",
                        "content": "To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "omkarsk98",
                        "content": "Same question. Existing explanations didnt help much\\n"
                    },
                    {
                        "username": "cincin3",
                        "content": "Input:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nAs KUL has a smaller lexical order than NRT, that is chosen. Isn\\'t that expected? Why does the expected output have JFK, NRT?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement specifies that if there are multiple valid itineraries, you should return the itinerary with the smallest lexical order. However, lexical order applies when you have choices at a single airport. \\n\\nIn this case, you start at \"JFK\" and have two choices: \"KUL\" and \"NRT.\" Lexically, \"KUL\" comes first. But choosing \"KUL\" first doesn\\'t allow you to use all the tickets. That violates the constraint of using all tickets exactly once. \\n\\nOn the other hand, if you choose \"NRT\" first, you can go from \"NRT\" back to \"JFK,\" and then from \"JFK\" to \"KUL,\" thus using all tickets. Therefore, even though \"KUL\" has a smaller lexical order, the constraint of using all tickets takes precedence. That\\'s why the expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@shivam_7777](/shivam_7777) To handle this situation keep track if any destination has only one connection which means that will be the last."
                    },
                    {
                        "username": "shivam_7777",
                        "content": "[@c5yhr213](/c5yhr213) Because after reaching to KUL you cant travel after that so even KUL is lexically smaller than NRT you cant visit KUL but NRT to complete the journey."
                    },
                    {
                        "username": "c5yhr213",
                        "content": "You have to use all the tickets."
                    },
                    {
                        "username": "zarkle",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/zarkle/image_1535694788.png)\\nwhat\\'s wrong with this picture? I don\\'t understand where it is getting \\'KUL\\' from when that is not in the last executed input at all... do these not sync up? is the last executed input from the last successful test case and not the one that gave the error? Makes no sense! How am I supposed to debug when it makes no sense! Doing a search in the discussions, I\\'m guessing the error is probably from this test case, `[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]` but that\\'s just a guess. This test case would make way more sense but why isn\\'t it showing up as the Last executed input!!\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Try to refresh the page and run again"
                    }
                ]
            },
            {
                "id": 1568657,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 2056820,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 2057491,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1570775,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1575083,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1570329,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1573546,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1569752,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1569501,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1569081,
                "content": [
                    {
                        "username": "phaniram28",
                        "content": "Could anyone help me understand why does Hierholzer\\'s algorithm work in this problem??\\nI see that the problme mentions there exists an answer, is that the valid reason, why if we keep traversing and backtracking on a dead end, would give us a valid answer??\\n\\nI\\'m looking for more formal explaination/logic than simple words, could anyone help??\\n\\n\\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@bparanj](/bparanj) Can u please tell what would be the time complexity of backtracking approach ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Hierholzer\\'s algorithm is typically used to find an Eulerian path or circuit in a graph. An Eulerian path is a trail in a graph that visits every edge exactly once. The algorithm works well in this problem because of a few key properties:\\n\\n1. **Existence of Eulerian Path**: The problem guarantees that an Eulerian path exists, i.e., you can travel every \\'ticket\\' exactly once. This is confirmed by the problem\\'s condition that an answer always exists.\\n\\n2. **Directed Graph**: The tickets can be considered as directed edges in a graph. You can only go from the \"from\" airport to the \"to\" airport as specified on each ticket. Hierholzer\\'s algorithm can easily adapt to directed graphs.\\n\\n3. **Degree of Vertices**: In an Eulerian path, each vertex (except possibly for the start and end vertex) has an equal in-degree and out-degree. This means you can \\'enter\\' and \\'leave\\' each vertex the same number of times. In the problem, the number of tickets to enter an airport would be the same as the number to leave, except for JFK (the start) and possibly another airport if the path is not a circuit.\\n\\n4. **Dead Ends and Backtracking**: Hierholzer\\'s algorithm naturally handles dead ends via backtracking. When you hit a dead-end, you know you\\'ve traversed all outgoing edges (tickets) for that vertex (airport). You can then backtrack and continue traversing other unexplored edges, eventually forming the Eulerian path.\\n\\n5. **Lexicographic Ordering**: While Hierholzer\\'s doesn\\'t inherently give a lexicographically minimal path, you can achieve this by always choosing the smallest available vertex to visit next, which aligns well with the problem\\'s constraints.\\n\\nThe formal reasoning behind why Hierholzer\\'s works is fundamentally based on the properties of Eulerian paths and the constraints of the problem. Given the existence of an Eulerian path and the balanced in-degree and out-degree for each vertex, Hierholzer\\'s will construct the path by traversing each edge exactly once, thus providing a valid answer."
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Hint : Use DFS with a stack, sort destinations, and mark used tickets to find the itinerary!"
                    },
                    {
                        "username": "c910335",
                        "content": "Whoever wrote the program that produces the expected answer, well done!\\n\\n```rb\\n[[\"JFK\",\"YZZ\"], [\"YZZ\", \"JFK\"], [\"JFK\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"], [\"AAA\", \"AAB\"], [\"AAB\", \"AAA\"]]\\n```\\n\\n![](https://i.imgur.com/UMAEfvY.png)"
                    },
                    {
                        "username": "c910335",
                        "content": "[@lucasscodes](/lucasscodes) 100% reproducible"
                    },
                    {
                        "username": "kenlau",
                        "content": "Looks like the online judge got TLE ..."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "cannot reproduce?"
                    },
                    {
                        "username": "advfeature",
                        "content": "That means you might have to visit certain edges multiple times. That broke my first submission!"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "yes you have to use all the ticket even revisiting it \\nknow more about from here  - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "kwonkyu",
                        "content": "At 29th test case, \\n[[\"EZE\",\"TIA\"],[\"EZE\",\"HBA\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AXA\"],[\"ANU\",\"JFK\"],[\"ADL\",\"ANU\"],**[\"TIA\",\"AUA\"]**,[\"ANU\",\"AUA\"],[\"ADL\",\"EZE\"],[\"ADL\",\"EZE\"],[\"EZE\",\"ADL\"],[\"AXA\",\"EZE\"],[\"AUA\",\"AXA\"],[\"JFK\",\"AXA\"],[\"AXA\",\"AUA\"],[\"AUA\",\"ADL\"],[\"ANU\",\"EZE\"],**[\"TIA\",\"ADL\"]**,[\"EZE\",\"ANU\"],[\"AUA\",\"ANU\"]]\\n\\nThere\\'re two destinations from \"TIA\", which are \"ADL\" and \"AUA\".\\nSo I thought the result should be like [..., \"TIA\", \"ADL\", ..., \"TIA\", \"AUA\", ...] but test case shows [..., \"TIA\", \"AUA\", ..., \"TIA\", \"ADL\", ...].\\n~~Isn\\'t \"ADL\" is prior to \"AUA\" in lexical order? Or should I manually select ticket to use all of my tickets even if it\\'s not in lexical order?~~\\n\\n~~I\\'m not native speaker so I may missed some points but I can\\'t tell what it is. Does anyone know?~~\\n\\nOh I was stupid\\uD83D\\uDE05 Description said \"You must use all tickets\" so...\\ngotta get some sleep. my brain\\'s not working."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@user5400vw](/user5400vw)  I got this and solved it too, then got stuck at the 33rd testcase."
                    },
                    {
                        "username": "user5400vw",
                        "content": "if u guys get this test case you\\'re halfway there."
                    },
                    {
                        "username": "segfz",
                        "content": "Consider test case [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nexpected result: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\nI expect the result to be : [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\nAm I correct to say \"NRT\" is lexically larger than \"KUL\"?\\n\\nI am sure I have gotten it wrong but what is it?\\n\\nThank you so much"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "but after selecting jul you get dead end you cannot go anywhere \\nknow more about this here - https://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "princy_malhotra",
                        "content": "The answer should be: [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] since there is no path from KUL to NRT, so [\"JFK\",\"KUL\",\"NRT\",\"JFK\"] cannot be a valid answer. We need to return the lexicographically smallest VALID answer."
                    },
                    {
                        "username": "mohitgupta1194",
                        "content": "Are there questions similar to this problem i.e. which uses this eulerian path algorithm?"
                    },
                    {
                        "username": "Kajal_Joshi",
                        "content": "As per the problem, smaller lexical value string should come before in itinerary sequence.\\n\\nso [\"JFK\",\"KUL\"] is smaller than [\"JFK\",\"NRT\"],\\nso ouput should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]\\n\\nbut expected output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nPlease someone explain how this output is calculated?"
                    },
                    {
                        "username": "90K2",
                        "content": "The test case is [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\n\\nAnd the expected answer is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"] but why? If [JFK, KUL] < [JFK, NRT]"
                    },
                    {
                        "username": "ysingh",
                        "content": "I tried [[\"JFK\", \"LGA\"],[\"JFK\", \"LGB\"]] as a test case and got this as expected answer:\\n[\"JFK\",\"LGB\",\"LGA\"].\\n\\nTwo concerns regarding the expected answer:\\n1) How could this be valid answer when there is no flight between LGB->LGA? \\nDoes the itinerary [\"JFK\",\"LGB\",\"LGA\"] implies that there should be a valid flight between \"JFK\"->\"LGB\" &  \"LGB\" ->\"LGA\".\\n2) Also shouldn't LGA come before LGB as per lexical ordering?"
                    }
                ]
            },
            {
                "id": 1569084,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2056967,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 1567958,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2057609,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2057580,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2057435,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2057429,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2056950,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 2056915,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 1962030,
                "content": [
                    {
                        "username": "suexcxine",
                        "content": "Thanks!\\nWhatever I return, \\nIt shows that what I returned is [],\\nI just don't know why.\\n\\nAnd what confuses me very much is that the parameter *returnSize is 0..."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I seriously respect how brave you are bro, I can\\'t event think of solving it in C in a million years."
                    },
                    {
                        "username": "JerryLife",
                        "content": "Why does the problem description never mention that there are *duplicate* edges?\\n\\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`"
                    },
                    {
                        "username": "kerash",
                        "content": "so that they can cheat your submit once lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "they did us dirty"
                    },
                    {
                        "username": "ajithcherukad",
                        "content": "I believe there is an error in one of the test cases for this question.\\n\\nMy solution doesn't work for the below test case which I believe is wrong.\\n\\nInput:\\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput:\\n[\"JFK\",\"KUL\"]\\nExpected:\\n[\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nCorrect me if I'm wrong here."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Is this question is more difficult to understand than life ?"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\n\n\n\n\n\nSPOILER\n```\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        edge = defaultdict(lambda:[]) #get O(1) access\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\n        for k in edge.keys(): edge[k].sort() #lexical order\n\n        used = [False]*len(tickets) #used position indices or -1\n        res = [\"JFK\"] #store reached positions\n        def rec(i=0,start=\"JFK\"): #for flight n from start\n            if i==len(tickets): return True #did the dfs\n            for target,pos in edge[start]: #for each edge\n                if not used[pos]: #unused\n                    used[pos] = True #store pos used\n                    res.append(target) #fly there\n                    if rec(i+1,target): return True #pass up valid dfs choice\n                    else: #bad choice revert stored values\n                        res.pop()\n                        used[pos] = False\n            return False #no acces in this dfs traversal\n        assert rec() #dfs error\n\n        return res\n```"
                    },
                    {
                        "username": "purvi_jha",
                        "content": "by by my 2 day streak :("
                    },
                    {
                        "username": "lucasscodes",
                        "content": "graph theory, depth first search/breadth first search.\\nnext thing i applied is hashing to get every edge possible in O(1).\\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\\notherwise in bfs i would have to store all possible ways found yet and not only the single result.\\n\\nSPOILER\\n\\n```\\nclass Solution:\\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\\n        edge = defaultdict(lambda:[]) #get O(1) access\\n        for i,(a,b) in enumerate(tickets): edge[a].append((b,i))\\n        for k in edge.keys(): edge[k].sort() #lexical order\\n\\n        used = [False]*len(tickets) #used position indices or -1\\n        res = [\"JFK\"] #store reached positions\\n        def rec(i=0,start=\"JFK\"): #for flight n from start\\n            if i==len(tickets): return True #did the dfs\\n            for target,pos in edge[start]: #for each edge\\n                if not used[pos]: #unused\\n                    used[pos] = True #store pos used\\n                    res.append(target) #fly there\\n                    if rec(i+1,target): return True #pass up valid dfs choice\\n                    else: #bad choice revert stored values\\n                        res.pop()\\n                        used[pos] = False\\n            return False #no acces in this dfs traversal\\n        assert rec() #dfs error\\n\\n        return res\\n```"
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "I can solve it so the given test cases will pass, but I can come up with such test cases myself, so it will fail."
                    },
                    {
                        "username": "mstuebs",
                        "content": "I can confirm that."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I opened LC at 7pm, and it\\'s a HARD problem, DESTROYED"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I visualized and explained in a [concise way here](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042456/93-short-concise-explanation-with-visualization-dfs/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here's some useful test cases:\n\nDuplicate routes/edges:\n`[[\"EZE\",\"AXA\"],[\"TIA\",\"ANU\"],[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"TIA\",\"ANU\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\nDead ends:\n`[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]`"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "happy after solving it"
                    }
                ]
            },
            {
                "id": 1576757,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1575311,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1575170,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1574969,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1573578,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1573541,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1573403,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1573318,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1572997,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1572307,
                "content": [
                    {
                        "username": "VoidedName",
                        "content": "I don\\'t believe the error reporting for the typescript version is correct. The string ATLJFKATL is < JFKATLJFK (same length and first letter already decides A < J). Unless the use of lexical in the desciption differs from the common definition. And since the input is a cycle, both paths should be candidates.\\n\\n![image](https://assets.leetcode.com/users/images/7ea9207b-a052-4451-b1da-2df858b28850_1652559354.383964.png)\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "JFK must always be the starting point. It is written in the description."
                    },
                    {
                        "username": "codemaster2911",
                        "content": "[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nwhat shoul be the output of this\\n"
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "For example 886 Possible Bipartition, the time complexity for the DFS solution that put the \"dislike\" relation on to a graph, is O(V+E).\\nO(V+E) means you have to visit each vertex and edge for at lease once. \\nWhy this question is not the case? \\nCan anyone give detailed explanation, thanks!"
                    },
                    {
                        "username": "IamVaibhave53",
                        "content": "Whats the proof that the point where we get stuck is the end point??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "When all edges are visited, that\\'s the endpoint."
                    },
                    {
                        "username": "Paras132",
                        "content": "Input : [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]]\\nOutput : [\"JFK\",\"KUL\"]\\nExpected : [\"JFK\",\"NRT\",\"JFK\",\"KUL\"]\\n\\nHow the values in \"Expected\" holds true ? question says ned to return lexical order so in that case \"KUL\" is smaller than \"NRT\".\\n\\nPlease explain.\\n\\n"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "I can think of some intuition behind solving this problem, but I\\'m struggling to understand why itineraries can come back to an airport that has already been visited?\\nIn graph search, we don\\'t process the same node twice, right? So how are any of these test cases given in the question valid in any way?"
                    },
                    {
                        "username": "Hugheym",
                        "content": "This is what I\\'m getting:\\n\\nInput:\\n[[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput:\\n[\"ATL\",\"JFK\",\"ATL\"]\\nExpected:\\n[\"JFK\",\"ATL\",\"JFK\"]\\n\\nIf read as a single string, wouldn\\'t the sequence starting with ATL be first?"
                    },
                    {
                        "username": "kargreat",
                        "content": "for test case: [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"],[\"LHR\",\"SEA\"]]\\nleetcode output is: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\",\"SEA\"]\\n\\nThis is absurd."
                    },
                    {
                        "username": "JiaweiZhang1994",
                        "content": "I have solved the problem by the top 1 answer. However I still have a problem about Eulerian path.\\nTest case: [[\"E\", \"F\"], [\"JFK\", \"A\"], [\"A\", \"D\"], [\"D\", \"E\"],[\"F\",\"A\"],[\"JFK\",\"B\"],[\"B\", \"F\"]]\\nI am not sure about the expected answer.\\nThe expected answer is [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\",\"A\"],\\nHowever I think it should be [\"JFK\",\"B\",\"F\",\"A\",\"D\",\"E\",\"F\"]\\nSo the graph should looks like:\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1568312939.png)\\n\\n\\nDoes Anyone can help me with my confusing?\\nI would appreciate that."
                    },
                    {
                        "username": "sssss29",
                        "content": "In this test case \\n[[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]] why output is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"].\\nKUL is alphabetically ahead of NRT,m so it should be [\"JFK\",\"KUL\",\"NRT\",\"JFK\"]??"
                    }
                ]
            },
            {
                "id": 1571592,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 1571593,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 1571594,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 1571595,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 1571596,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 1569082,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 2056868,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 2056714,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 2071356,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 2057916,
                "content": [
                    {
                        "username": "strisunshine",
                        "content": "[[\"SJC\",\"MUC\"],[\"JFK\",\"MUC\"],[\"JFK\",\"SJC\"],[\"MUC\",\"SFO\"],[\"SFO\",\"LHR\"]]? \\n\\nIs JFK->SJC->MUC->SFO->LHR a valid itinerary ?"
                    },
                    {
                        "username": "mysun",
                        "content": "For example: the tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]], and how can we find the start airport, that is \"JFK\""
                    },
                    {
                        "username": "lindan_xmu",
                        "content": "Input [[\"JFK\",\"KUL\"],[\"JFK\",\"NRT\"],[\"NRT\",\"JFK\"]], \\n why the result is [\"JFK\",\"NRT\",\"JFK\",\"KUL\"], not [\"JFK\",\"KUL\"]"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "How do we analyze the time complexity in this case?"
                    },
                    {
                        "username": "nikhil72",
                        "content": "Hi,\\n\\nPlease explain how and why my output is wrong. Is ADL not lexically smaller than AUA? Or is it that the AXA following AUA has to be taken into consideration?\\n\\nOutput:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"ADL\",\"EZE\",\"HBA\",\"AUA\",\"AXA\",\"TIA\"]\\nExpected:\\n[\"JFK\",\"AXA\",\"AUA\",\"ADL\",\"ANU\",\"AUA\",\"ANU\",\"EZE\",\"ADL\",\"EZE\",\"ANU\",\"JFK\",\"AXA\",\"EZE\",\"TIA\",\"AUA\",\"AXA\",\"TIA\",\"ADL\",\"EZE\",\"HBA\"]\\n\\nThanks,\\nNikhil"
                    },
                    {
                        "username": "slords",
                        "content": "\\nInput: [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]\\nOutput: [\"ATL\",\"JFK\",\"ATL\"]\\nExpected: [\"JFK\",\"ATL\",\"JFK\"]\\n\\nDoes it mean that  [\"ATL\",\"JFK\",\"ATL\"] is larger than [\"JFK\",\"ATL\",\"JFK\"] in lexical order?"
                    },
                    {
                        "username": "quan_mai",
                        "content": "tip: backtracking :-)"
                    },
                    {
                        "username": "wafsinc",
                        "content": "What? No."
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I got the solution accepted in March 2023 but retrying the same solution in Sept 2023 is giving TLE :-("
                    },
                    {
                        "username": "alexmanuylenko",
                        "content": "Well, I solved it and it works on the given test cases.\\n\\nBut, like I said, I cannot guarantee, that it will work on ANY set of input data.\\n\\nFor example, it will likely fail if we have a disconnected graph, i. e. a graph with more than 1 component of connectivity/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "We know the tickets are from a single itinerary, so they have to be connected and a solution is guaranteed to exist."
                    }
                ]
            },
            {
                "id": 2057904,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057903,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057851,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057800,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057771,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057752,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057751,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057450,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057357,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057356,
                "content": [
                    {
                        "username": "Shivam_verma24",
                        "content": "Medium level sorting + DFS problem tagged hard"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "What is going on with this testcase?\n`tickets = [[\"JFK\",\"ATL\"],[\"ATL\",\"JFK\"]]`\n\nMy output:\n`[\"ATL\",\"JFK\",\"ATL\"]`\n\nExpected:\n`[\"JFK\",\"ATL\",\"JFK\"]`\n\nEdit: I missed that you always start at JFK."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hints in increasing levels of spoilers: (Hints for this question are kind of hard to do unfortunately)\\n\\n1) Actually this is the biggest spoiler, but tbh I would just read the wikipedia page on Eulerian Paths. \\n\\n2) If you tried to construct a path and then failed because you didn\\'t hit every single node, is all of the work you did for nothing? Do you need to restart? or can you reuse the result you got somehow? \\nIs there any structure to the part you missed? "
                    },
                    {
                        "username": "z3eg",
                        "content": "and there goes my third hard problems solved completely by myself. ~300 lines of code and several hours of time and here we go! don\\'t give up, guys, this one doesnt seem to require some special approach, i solved it with a very very common one (surprisingly lol)"
                    },
                    {
                        "username": "thewickeffect",
                        "content": "This is a fun problem.  Here are a couple hints if you are stuck:\\n\\n* solving the lexical ordering problem first will increase the efficiency and ease of finding the final solution.\\n\\n* The relatively small amount of tickets opens up a solution method that could be extremely consumptive on large data sets. 1 <= tickets.length <= 300\\n\\nGood Luck!"
                    },
                    {
                        "username": "mstuebs",
                        "content": "I have found that for this challenge the leetcode solution might crash. I got a TLE for empty code for this testcase:\n```\n[[\"JFK\",\"KLO\"],[\"KLO\",\"VRU\"],[\"VRU\",\"JFK\"],[\"JFK\",\"IWC\"],[\"IWC\",\"EXD\"],[\"EXD\",\"VMC\"],[\"VMC\",\"EWR\"],[\"EWR\",\"PDS\"],[\"PDS\",\"PIT\"],[\"PIT\",\"YSM\"],[\"YSM\",\"HKO\"],[\"HKO\",\"RSW\"],[\"RSW\",\"HFM\"],[\"HFM\",\"HMN\"],[\"HMN\",\"IEM\"],[\"IEM\",\"MED\"],[\"MED\",\"NGX\"],[\"NGX\",\"FLL\"],[\"FLL\",\"BYC\"],[\"BYC\",\"SFO\"],[\"SFO\",\"XVS\"],[\"XVS\",\"FUQ\"],[\"FUQ\",\"XBK\"],[\"XBK\",\"DHW\"],[\"DHW\",\"YJO\"],[\"YJO\",\"ODN\"],[\"ODN\",\"XQT\"],[\"XQT\",\"ARH\"],[\"ARH\",\"DTW\"],[\"DTW\",\"MEI\"],[\"MEI\",\"DTW\"],[\"DTW\",\"GPP\"],[\"GPP\",\"WIE\"],[\"WIE\",\"ICJ\"],[\"ICJ\",\"VYX\"],[\"VYX\",\"TLS\"],[\"TLS\",\"NUB\"],[\"NUB\",\"YSM\"],[\"YSM\",\"CSD\"],[\"CSD\",\"CTI\"],[\"CTI\",\"LTU\"],[\"LTU\",\"YAE\"],[\"YAE\",\"KMO\"],[\"KMO\",\"AIT\"],[\"AIT\",\"IWC\"],[\"IWC\",\"OJB\"],[\"OJB\",\"DFV\"],[\"DFV\",\"HSS\"],[\"HSS\",\"EAN\"],[\"EAN\",\"SRT\"],[\"SRT\",\"BUF\"],[\"BUF\",\"EUH\"],[\"EUH\",\"KTE\"],[\"KTE\",\"TPA\"],[\"TPA\",\"SMF\"],[\"SMF\",\"AKP\"],[\"AKP\",\"MMB\"],[\"MMB\",\"TPA\"],[\"TPA\",\"VTO\"],[\"VTO\",\"LBT\"],[\"LBT\",\"GPP\"],[\"GPP\",\"KLO\"],[\"KLO\",\"LAX\"],[\"LAX\",\"MIA\"],[\"MIA\",\"LBT\"],[\"LBT\",\"THM\"],[\"THM\",\"WIB\"],[\"WIB\",\"ORO\"],[\"ORO\",\"IAD\"],[\"IAD\",\"GDP\"],[\"GDP\",\"HMN\"],[\"HMN\",\"CVO\"],[\"CVO\",\"LBT\"],[\"LBT\",\"UGU\"],[\"UGU\",\"HNL\"],[\"HNL\",\"JNQ\"],[\"JNQ\",\"YJO\"],[\"YJO\",\"UGU\"],[\"UGU\",\"ERQ\"],[\"ERQ\",\"XMP\"],[\"XMP\",\"DFF\"],[\"DFF\",\"BWI\"],[\"BWI\",\"MDW\"],[\"MDW\",\"XQT\"],[\"XQT\",\"PBI\"],[\"PBI\",\"IND\"],[\"IND\",\"MJN\"],[\"MJN\",\"SFO\"],[\"SFO\",\"RGS\"],[\"RGS\",\"NVP\"],[\"NVP\",\"LAS\"],[\"LAS\",\"KMO\"],[\"KMO\",\"RSW\"],[\"RSW\",\"HEW\"],[\"HEW\",\"NAT\"],[\"NAT\",\"SJU\"],[\"SJU\",\"FLM\"],[\"FLM\",\"DHL\"],[\"DHL\",\"LPI\"],[\"LPI\",\"QCD\"],[\"QCD\",\"HEW\"],[\"HEW\",\"MFN\"],[\"MFN\",\"YBC\"],[\"YBC\",\"CTX\"],[\"CTX\",\"IWC\"],[\"IWC\",\"BNG\"],[\"BNG\",\"QSH\"],[\"QSH\",\"ANC\"],[\"ANC\",\"EQC\"],[\"EQC\",\"MFN\"],[\"MFN\",\"FBW\"],[\"FBW\",\"NML\"],[\"NML\",\"AUR\"],[\"AUR\",\"LAS\"],[\"LAS\",\"EQC\"],[\"EQC\",\"KKC\"],[\"KKC\",\"LAS\"],[\"LAS\",\"QHN\"],[\"QHN\",\"MDW\"],[\"MDW\",\"KTL\"],[\"KTL\",\"BMQ\"],[\"BMQ\",\"UUH\"],[\"UUH\",\"VTO\"],[\"VTO\",\"CLF\"],[\"CLF\",\"XWB\"],[\"XWB\",\"JWA\"],[\"JWA\",\"STL\"],[\"STL\",\"BPF\"],[\"BPF\",\"MBD\"],[\"MBD\",\"HJT\"],[\"HJT\",\"UYU\"],[\"UYU\",\"HPE\"],[\"HPE\",\"VTO\"],[\"VTO\",\"OJB\"],[\"OJB\",\"SJU\"],[\"SJU\",\"MSY\"],[\"MSY\",\"QWV\"],[\"QWV\",\"OUC\"],[\"OUC\",\"XOY\"],[\"XOY\",\"GPW\"],[\"GPW\",\"OSC\"],[\"OSC\",\"MGL\"],[\"MGL\",\"VRF\"],[\"VRF\",\"XBK\"],[\"XBK\",\"PHL\"],[\"PHL\",\"QAW\"],[\"QAW\",\"YYQ\"],[\"YYQ\",\"BVI\"],[\"BVI\",\"LGA\"],[\"LGA\",\"VLT\"],[\"VLT\",\"UJJ\"],[\"UJJ\",\"BWI\"],[\"BWI\",\"LBT\"],[\"LBT\",\"DTW\"],[\"DTW\",\"MJN\"],[\"MJN\",\"HSS\"],[\"HSS\",\"OHW\"],[\"OHW\",\"BMT\"],[\"BMT\",\"IWC\"],[\"IWC\",\"UJJ\"],[\"UJJ\",\"PDS\"],[\"PDS\",\"EGK\"],[\"EGK\",\"TLS\"],[\"TLS\",\"SIX\"],[\"SIX\",\"AOT\"],[\"AOT\",\"SSH\"],[\"SSH\",\"VGK\"],[\"VGK\",\"JSF\"],[\"JSF\",\"GDP\"],[\"GDP\",\"BOL\"],[\"BOL\",\"JGH\"],[\"JGH\",\"IWC\"],[\"IWC\",\"AOX\"],[\"AOX\",\"FRI\"],[\"FRI\",\"LWV\"],[\"LWV\",\"PDX\"],[\"PDX\",\"STL\"],[\"STL\",\"AIT\"],[\"AIT\",\"CSD\"],[\"CSD\",\"SIX\"],[\"SIX\",\"BUF\"],[\"BUF\",\"VDB\"],[\"VDB\",\"XOY\"],[\"XOY\",\"TBV\"],[\"TBV\",\"BNG\"],[\"BNG\",\"HWF\"],[\"HWF\",\"LPI\"],[\"LPI\",\"JCB\"],[\"JCB\",\"DUI\"],[\"DUI\",\"IIK\"],[\"IIK\",\"YBC\"],[\"YBC\",\"VYX\"],[\"VYX\",\"YNS\"],[\"YNS\",\"BQH\"],[\"BQH\",\"WRM\"],[\"WRM\",\"SCY\"],[\"SCY\",\"DFY\"],[\"DFY\",\"BLC\"],[\"BLC\",\"PHX\"],[\"PHX\",\"DFY\"],[\"DFY\",\"BOS\"],[\"BOS\",\"WIB\"],[\"WIB\",\"SEA\"],[\"SEA\",\"THM\"],[\"THM\",\"TTY\"],[\"TTY\",\"HEW\"],[\"HEW\",\"YSM\"],[\"YSM\",\"BNN\"],[\"BNN\",\"MGY\"],[\"MGY\",\"PAR\"],[\"PAR\",\"IRJ\"],[\"IRJ\",\"VDB\"],[\"VDB\",\"ANC\"],[\"ANC\",\"SAN\"],[\"SAN\",\"RDU\"],[\"RDU\",\"REF\"],[\"REF\",\"BWI\"],[\"BWI\",\"HNL\"],[\"HNL\",\"AAP\"],[\"AAP\",\"CVO\"],[\"CVO\",\"JIR\"],[\"JIR\",\"AIT\"],[\"AIT\",\"NEE\"],[\"NEE\",\"HIN\"],[\"HIN\",\"TPU\"],[\"TPU\",\"AHF\"],[\"AHF\",\"MSY\"],[\"MSY\",\"HFM\"],[\"HFM\",\"ATW\"],[\"ATW\",\"KKC\"],[\"KKC\",\"CFB\"],[\"CFB\",\"HPE\"],[\"HPE\",\"BPF\"],[\"BPF\",\"XWB\"],[\"XWB\",\"XVS\"],[\"XVS\",\"FKN\"],[\"FKN\",\"SMF\"],[\"SMF\",\"AIT\"],[\"AIT\",\"MDW\"],[\"MDW\",\"CRG\"],[\"CRG\",\"VRU\"],[\"VRU\",\"FGD\"],[\"FGD\",\"GJK\"],[\"GJK\",\"WSR\"],[\"WSR\",\"FLM\"],[\"FLM\",\"OFX\"],[\"OFX\",\"GVU\"],[\"GVU\",\"UGU\"],[\"UGU\",\"DFV\"],[\"DFV\",\"DEN\"],[\"DEN\",\"NRE\"],[\"NRE\",\"PDX\"],[\"PDX\",\"CWG\"],[\"CWG\",\"TLS\"],[\"TLS\",\"HSS\"],[\"HSS\",\"BQI\"],[\"BQI\",\"HSB\"],[\"HSB\",\"CGT\"],[\"CGT\",\"OFX\"],[\"OFX\",\"TBV\"],[\"TBV\",\"NAT\"],[\"NAT\",\"JGH\"],[\"JGH\",\"NBP\"],[\"NBP\",\"AIT\"],[\"AIT\",\"AKP\"],[\"AKP\",\"SRT\"],[\"SRT\",\"NBP\"],[\"NBP\",\"JGH\"],[\"JGH\",\"VDB\"],[\"VDB\",\"YXT\"],[\"YXT\",\"CLF\"],[\"CLF\",\"KKC\"],[\"KKC\",\"KLO\"],[\"KLO\",\"BWT\"],[\"BWT\",\"LBT\"],[\"LBT\",\"ODN\"],[\"ODN\",\"SMF\"],[\"SMF\",\"GHP\"],[\"GHP\",\"BQI\"],[\"BQI\",\"EXD\"],[\"EXD\",\"ODN\"],[\"ODN\",\"BWT\"],[\"BWT\",\"PDX\"],[\"PDX\",\"IRU\"],[\"IRU\",\"SMJ\"],[\"SMJ\",\"UBB\"],[\"UBB\",\"SIX\"],[\"SIX\",\"XVS\"],[\"XVS\",\"ATW\"],[\"ATW\",\"AAP\"],[\"AAP\",\"RDU\"],[\"RDU\",\"TBV\"],[\"TBV\",\"JCB\"],[\"JCB\",\"TBV\"],[\"TBV\",\"IWC\"],[\"IWC\",\"VTO\"]]\n```\n![image](https://github.com/mquintus/l33tcode-reload/assets/515945/2e6b511e-d801-4f2f-a232-61793fc892c6)"
                    },
                    {
                        "username": "chrisblueeyes",
                        "content": "lol this was a sample google interview question... this brilliant high schooler solved it!! using graphs, heres the video, no code just the theory\n\nhttps://www.youtube.com/watch?v=qz9tKlF431k"
                    },
                    {
                        "username": "realitant",
                        "content": "I think it's worthwhile to explicitly state if the tickets are unique or not.\nEDIT: To anyone else wondering, the tickets are not necessarily unique"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Note- There can be multiple same direction tickets between 2 cities."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Today\\'s question was easy \\uD83E\\uDEE1\\uD83E\\uDEE1\\n\\nhttps://github.com/iamkuldeep05/Leetcode-Daily-challenges-Solution.git"
                    }
                ]
            },
            {
                "id": 2057325,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057303,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057196,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057190,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057184,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057181,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057165,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057161,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057154,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057065,
                "content": [
                    {
                        "username": "itsyeshu",
                        "content": "`tickets` can have mutiple `ticket [from, to]` with same `from` and `to`.\n\nExample :\n `tickets` = `[[\"EZE\",\"AXA\"]`,`[\"TIA\",\"ANU\"],[\"TIA\",\"ANU\"]`,`[\"ANU\",\"JFK\"],[\"JFK\",\"ANU\"],[\"ANU\",\"EZE\"],[\"AXA\",\"TIA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"TIA\"],[\"JFK\",\"TIA\"]]`\n\n Check `[\"TIA\", \"ANU\"]` appears twice."
                    },
                    {
                        "username": "psionl0",
                        "content": "It looks like the choice for me is either cheat or give up my streak. This is an interesting problem and I will solve it eventually but 24 hours (less time for the biological world) is not enough for me."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@lucasscodes](/lucasscodes) I set up an adjacency matrix with the cities sorted in alphabetical order (except that \"JFK\" is first) and ran a dfs. This greedy approach doesn\\'t work so I need to add backtracking to the mix. I wasn\\'t aware that two cities can have multiple paths between them so this complicates things."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "you will get there padawan!\ngraph theory, depth first search/breadth first search.\nnext thing i applied is hashing to get every edge possible in O(1).\ni finally did this in dfs-recursion, this allowed to pick something + store the new used possible value for res.\notherwise in bfs i would have to store all possible ways found yet and not only the single result."
                    },
                    {
                        "username": "anonymouss_01",
                        "content": "Think of Eulerian Path."
                    },
                    {
                        "username": "vennyvirtuoso",
                        "content": "End of my streak!!"
                    },
                    {
                        "username": "vinitabai",
                        "content": "Excellent problem to revise dfs. "
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "This will an easy problem if you know Hierholzer\\'s Algorithm for Euler Path/Circuit. Basically it is just naive dfs over edges, instead of nodes. You don\\'t need to check if given graph contains Euler Path/Circuit, because in the problem constraints it is said a vaild itinerary will always exist. Just create a graph from the given tickets (edges), use min heap inside hash-map to store the edges in lexicographical order for current node. Then just apply simple dfs and keep poping edges from the heap, whenever the current node is out of edges, add it to the beginning of the answer array. (Search for William Fiset\\'s video on Euler Paths/Circuits on yt)"
                    },
                    {
                        "username": "aitachii",
                        "content": "If you\\'re sorting the vertices connected to each vertex, is the time complexity `V * KlogK`?\\nwhere \\n`V = total number of vertices`\\n`K = number of vertices/destinations connected to a vertex`"
                    },
                    {
                        "username": "DilemmaRabbit",
                        "content": "Does every ticket [from, to] unique in testcase?\\nIs there have duplicate same ticket [from, to]? "
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All that the problem is asking you to do is traverse every edge in a graph while maintaining the tiniest lexicographic order possible. \nNote that there is always at least one solution. `Tip`"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Being a avigeek, I got excited after seeing code names of one of my favorite airports JFK,LHR,SFO <3"
                    }
                ]
            },
            {
                "id": 2057006,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056913,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056895,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056887,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056886,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056821,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056780,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056763,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056749,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            },
            {
                "id": 2056723,
                "content": [
                    {
                        "username": "saumyagupta1",
                        "content": "aayein? baigan"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I\\'m so scared"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "plz check for understanding question and getting answer\\nhttps://youtu.be/dDb9x3rzDh0"
                    },
                    {
                        "username": "harsha335",
                        "content": "Can anyone help me out ... i can\\'t get this test case\\nInput\\ntickets =\\n[[\"EZE\",\"TIA\"],[\"EZE\",\"AXA\"],[\"AUA\",\"EZE\"],[\"EZE\",\"JFK\"],[\"JFK\",\"ANU\"],[\"JFK\",\"ANU\"],[\"AXA\",\"TIA\"],[\"JFK\",\"AUA\"],[\"TIA\",\"JFK\"],[\"ANU\",\"EZE\"],[\"ANU\",\"EZE\"],[\"TIA\",\"AUA\"]]\\n\\nOutput\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"TIA\",\"JFK\",\"ANU\",\"EZE\",\"JFK\",\"AUA\"]\\nExpected\\n[\"JFK\",\"ANU\",\"EZE\",\"AXA\",\"TIA\",\"AUA\",\"EZE\",\"JFK\",\"ANU\",\"EZE\",\"TIA\",\"JFK\",\"AUA\"]"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Expected answer is lexicographically smaller than yours, that\\'s why."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I give up without even trying and feeling relaxed \\uD83E\\uDD71"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Why? It\\'s only Thursday."
                    },
                    {
                        "username": "___lovesh1808___",
                        "content": "what in the leetcode is this"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to solve this with best time complexity as well as space complexity solution"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Because you have to use every ticket one time, the length of a valid itinerary will be equal to the length of tickets + 1. If you always try using the lexically shortest destinations first, then your first time reaching an itinerary of length (tickets.Length + 1) will be your answer."
                    },
                    {
                        "username": "that_himanshu",
                        "content": "can anyone give their intuition or  some hint"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "[@wentland](/wentland) Can u please explain the time complexity of this ?"
                    },
                    {
                        "username": "wentland",
                        "content": "Build a list of possible destinations for each airport. Sort the lists in lexical order. Then try traversing through by picking the first element in the array and removing it. If it doesn\\'t work then add it back to the array and go to the next element. Continue until you get a success. "
                    }
                ]
            }
        ]
    }
]