[
    {
        "title": "Super Ugly Number",
        "question_content": "A super ugly number is a positive integer whose prime factors are in the array primes.\nGiven an integer n and an array of integers primes, return the nth super ugly number.\nThe nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n&nbsp;\nExample 1:\n\nInput: n = 12, primes = [2,7,13,19]\nOutput: 32\nExplanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\n\nExample 2:\n\nInput: n = 1, primes = [2,3,5]\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 105\n\t1 <= primes.length <= 100\n\t2 <= primes[i] <= 1000\n\tprimes[i] is guaranteed to be a prime number.\n\tAll the values of primes are unique and sorted in ascending order.",
        "solutions": [
            {
                "id": 277313,
                "title": "my-view-of-this-question-hope-it-can-help-you-understand",
                "content": "It is actually like how we merge k sorted list:\\n``` \\nugly number                       k sorted list\\n    1                            2     7    13   19     1 * [2,7,13,19]\\n    |                            |     |    |    |\\n    2                            4     14   26   38     2 * [2,7,13,19]\\n    |                            |     |    |    |\\n    4                            8     28   52   76     4 * [2,7,13,19]\\n    |                            |     |    |    |              \\n    7                            14    49   91   133    7 * [2,7,13,19]\\n    |                            |     |    |    |\\n    8                            16    56   ...   ...   8 * [2,7,13,19]\\n    |                            |     |    |     |\\n    .                            .     .     .    .\\n    .                            .     .     .    .\\n    .                            .     .     .    .\\n```\\n\\nWe can see that each prime number in ```primes[]``` form a sorted list, and now our job is to merge them and find the ```nth``` minimum.\\n\\nHere we don\\'t have the ```next``` pointer for each node to trace the next potential candidate. But as we can see in the graph, we can make use of the ugly number we have produced so far!\\n\\nI just refer the @zorro77\\'s solution here:\\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        PriorityQueue<int[]> queue=new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        for (int i=0;i<primes.length;i++)\\n            queue.offer(new int[]{primes[i], primes[i], 0});\\n\\n        int[] nums=new int[n+1];\\n        nums[0]=1;\\n        \\n        int i=1;\\n        while (i<n){\\n            int[] entry=queue.poll();\\n            int num=entry[0], prime=entry[1], index=entry[2];\\n\\t\\t\\t// remove duplicate\\n            if (num!=nums[i-1]){\\n                nums[i]=num;\\n                i++;\\n            }\\n            queue.offer(new int[]{prime*nums[index+1], prime, index+1});\\n        }\\n        return nums[n-1];\\n    }\\n}\\n```\\n\\nHere, each entry has three parts: ```{num, prime, index}```, ```num``` represents the value of the node, ```prime``` means which sorted list this node is in, and ```index``` tells us how far we have gone in that list, it works like the ```next``` pointer in linkedlist, help us find the next node in that sorted list.\\n\\nTime: ```O(nlogk)```\\nSpace: ```O(n+k)```\\n",
                "solutionTags": [],
                "code": "``` \\nugly number                       k sorted list\\n    1                            2     7    13   19     1 * [2,7,13,19]\\n    |                            |     |    |    |\\n    2                            4     14   26   38     2 * [2,7,13,19]\\n    |                            |     |    |    |\\n    4                            8     28   52   76     4 * [2,7,13,19]\\n    |                            |     |    |    |              \\n    7                            14    49   91   133    7 * [2,7,13,19]\\n    |                            |     |    |    |\\n    8                            16    56   ...   ...   8 * [2,7,13,19]\\n    |                            |     |    |     |\\n    .                            .     .     .    .\\n    .                            .     .     .    .\\n    .                            .     .     .    .\\n```\n```primes[]```\n```nth```\n```next```\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        PriorityQueue<int[]> queue=new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        for (int i=0;i<primes.length;i++)\\n            queue.offer(new int[]{primes[i], primes[i], 0});\\n\\n        int[] nums=new int[n+1];\\n        nums[0]=1;\\n        \\n        int i=1;\\n        while (i<n){\\n            int[] entry=queue.poll();\\n            int num=entry[0], prime=entry[1], index=entry[2];\\n\\t\\t\\t// remove duplicate\\n            if (num!=nums[i-1]){\\n                nums[i]=num;\\n                i++;\\n            }\\n            queue.offer(new int[]{prime*nums[index+1], prime, index+1});\\n        }\\n        return nums[n-1];\\n    }\\n}\\n```\n```{num, prime, index}```\n```num```\n```prime```\n```index```\n```next```\n```O(nlogk)```\n```O(n+k)```",
                "codeTag": "Java"
            },
            {
                "id": 76291,
                "title": "java-three-methods-23ms-36-ms-58ms-with-heap-performance-explained",
                "content": "Basic idea is same as ugly number II, new ugly number is generated by multiplying a prime with previous generated ugly number. One catch is need to remove duplicate\\n\\nLet's start with the **common solution** from ugly number II **36 ms, Theoretically O(kN)**\\n\\n    public int nthSuperUglyNumberI(int n, int[] primes) {\\n        int[] ugly = new int[n];\\n        int[] idx = new int[primes.length];\\n    \\n        ugly[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            //find next\\n            ugly[i] = Integer.MAX_VALUE;\\n            for (int j = 0; j < primes.length; j++)\\n                ugly[i] = Math.min(ugly[i], primes[j] * ugly[idx[j]]);\\n            \\n            //slip duplicate\\n            for (int j = 0; j < primes.length; j++) {\\n                while (primes[j] * ugly[idx[j]] <= ugly[i]) idx[j]++;\\n            }\\n        }\\n    \\n        return ugly[n - 1];\\n    }\\n\\n\\nIf you look at the above solution, it has **redundant multiplication** can be avoided, and also two for loops can be consolidated into one. This **trade-off space for speed. 23 ms, Theoretically O(kN)**\\n\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n            int[] ugly = new int[n];\\n            int[] idx = new int[primes.length];\\n            int[] val = new int[primes.length];\\n            Arrays.fill(val, 1);\\n    \\n            int next = 1;\\n            for (int i = 0; i < n; i++) {\\n                ugly[i] = next;\\n                \\n                next = Integer.MAX_VALUE;\\n                for (int j = 0; j < primes.length; j++) {\\n                    //skip duplicate and avoid extra multiplication\\n                    if (val[j] == ugly[i]) val[j] = ugly[idx[j]++] * primes[j];\\n                    //find next ugly number\\n                    next = Math.min(next, val[j]);\\n                }\\n            }\\n    \\n            return ugly[n - 1];\\n        }\\n\\nCan we do better? Theoretically yes, by keep the one candidates for each prime in a **heap**, it can improve the theoretical bound to **O( log(k)N )**, but in reality it's **58 ms**. I think it's the result of using higher level object instead of primitive. Can be improved by writing an **index heap** (http://algs4.cs.princeton.edu/24pq/IndexMinPQ.java.html)\\n\\n\\n    public int nthSuperUglyNumberHeap(int n, int[] primes) {\\n        int[] ugly = new int[n];\\n    \\n        PriorityQueue<Num> pq = new PriorityQueue<>();\\n        for (int i = 0; i < primes.length; i++) pq.add(new Num(primes[i], 1, primes[i]));\\n        ugly[0] = 1;\\n    \\n        for (int i = 1; i < n; i++) {\\n            ugly[i] = pq.peek().val;\\n            while (pq.peek().val == ugly[i]) {\\n                Num nxt = pq.poll();\\n                pq.add(new Num(nxt.p * ugly[nxt.idx], nxt.idx + 1, nxt.p));\\n            }\\n        }\\n    \\n        return ugly[n - 1];\\n    }\\n    \\n    private class Num implements Comparable<Num> {\\n        int val;\\n        int idx;\\n        int p;\\n    \\n        public Num(int val, int idx, int p) {\\n            this.val = val;\\n            this.idx = idx;\\n            this.p = p;\\n        }\\n    \\n        @Override\\n        public int compareTo(Num that) {\\n            return this.val - that.val;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "Basic idea is same as ugly number II, new ugly number is generated by multiplying a prime with previous generated ugly number. One catch is need to remove duplicate\\n\\nLet's start with the **common solution** from ugly number II **36 ms, Theoretically O(kN)**\\n\\n    public int nthSuperUglyNumberI(int n, int[] primes) {\\n        int[] ugly = new int[n];\\n        int[] idx = new int[primes.length];\\n    \\n        ugly[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            //find next\\n            ugly[i] = Integer.MAX_VALUE;\\n            for (int j = 0; j < primes.length; j++)\\n                ugly[i] = Math.min(ugly[i], primes[j] * ugly[idx[j]]);\\n            \\n            //slip duplicate\\n            for (int j = 0; j < primes.length; j++) {\\n                while (primes[j] * ugly[idx[j]] <= ugly[i]) idx[j]++;\\n            }\\n        }\\n    \\n        return ugly[n - 1];\\n    }\\n\\n\\nIf you look at the above solution, it has **redundant multiplication** can be avoided, and also two for loops can be consolidated into one. This **trade-off space for speed. 23 ms, Theoretically O(kN)**\\n\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n            int[] ugly = new int[n];\\n            int[] idx = new int[primes.length];\\n            int[] val = new int[primes.length];\\n            Arrays.fill(val, 1);\\n    \\n            int next = 1;\\n            for (int i = 0; i < n; i++) {\\n                ugly[i] = next;\\n                \\n                next = Integer.MAX_VALUE;\\n                for (int j = 0; j < primes.length; j++) {\\n                    //skip duplicate and avoid extra multiplication\\n                    if (val[j] == ugly[i]) val[j] = ugly[idx[j]++] * primes[j];\\n                    //find next ugly number\\n                    next = Math.min(next, val[j]);\\n                }\\n            }\\n    \\n            return ugly[n - 1];\\n        }\\n\\nCan we do better? Theoretically yes, by keep the one candidates for each prime in a **heap**, it can improve the theoretical bound to **O( log(k)N )**, but in reality it's **58 ms**. I think it's the result of using higher level object instead of primitive. Can be improved by writing an **index heap** (http://algs4.cs.princeton.edu/24pq/IndexMinPQ.java.html)\\n\\n\\n    public int nthSuperUglyNumberHeap(int n, int[] primes) {\\n        int[] ugly = new int[n];\\n    \\n        PriorityQueue<Num> pq = new PriorityQueue<>();\\n        for (int i = 0; i < primes.length; i++) pq.add(new Num(primes[i], 1, primes[i]));\\n        ugly[0] = 1;\\n    \\n        for (int i = 1; i < n; i++) {\\n            ugly[i] = pq.peek().val;\\n            while (pq.peek().val == ugly[i]) {\\n                Num nxt = pq.poll();\\n                pq.add(new Num(nxt.p * ugly[nxt.idx], nxt.idx + 1, nxt.p));\\n            }\\n        }\\n    \\n        return ugly[n - 1];\\n    }\\n    \\n    private class Num implements Comparable<Num> {\\n        int val;\\n        int idx;\\n        int p;\\n    \\n        public Num(int val, int idx, int p) {\\n            this.val = val;\\n            this.idx = idx;\\n            this.p = p;\\n        }\\n    \\n        @Override\\n        public int compareTo(Num that) {\\n            return this.val - that.val;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 169815,
                "title": "python-dp-solution-beats-93-7-extremely-detailed-explanation",
                "content": "First, let\\u2019s determine the route to solve this problem.\\n\\nWe need to find **N**th number. So, what we need to do is:\\n1. Find the 1st smallest number\\n2. Find the 2nd smallest number\\n3. Find the 3rd smallest number\\n4. .....\\n5. Finally, we find the **N**th number\\n\\nThis is actually Dynamic Programming.\\n\\nTake `primes = [2, 7, 13, 19]`, `n = 12` as an example:\\n1. `n = 1`, of course, we return 1\\n2. `n = 2`, we already have `[1]`, so, we do the calculation: `2 x 1, 7 x 1, 13 x 1, 19 x 1`, \\nwe got `[2, 7, 13, 19]`, the smallest number is `2`, so, we return `2`.\\n3. `n = 3`,  we already have `[1, 2]`. Last time, we chose `2` from `[2, 7, 13, 19]`, so, we do the calculation: `2 x 2` to replace the `2`. So, we got `[4, 7, 13, 19`, the smallest number is `4`, so, we return `4`.\\n\\n**Hold on ! Hold on !  Why we compute `2 x 2`  ????, not `2 x 3` or `7 x 2` or anything else ?**\\n\\nLet us figure out this problem !!!\\n<br>\\nWhat we need to do at each step is to find the next smallest number based on the numbers we have found.\\nWe use Multiplication to produce the new number, so, what is the strategy for producing as small a number as possible?\\n**We choose the smallest numbers to multiply !!!**\\n<br>\\nSo, at step 3, we already have `[1, 2]`, the primes are `[2, 7, 13, 19]`. Since we have compute `1 x primes`, this time, we just need to compute `2 x primes`.\\nBut do we really need to do the calculation: `7 x 2`, `13 x 2`, `19 x 2` ???  \\nNo! We have not chose `7 x 1, 13 x 1, 19 x 1` yet !!! There is no possibility that we will choose the smallest number from `[ 7 x 2, 13 x 2, 19 x 2]`.  So, we just need to compute `2 x 2` to get `[4, 7, 13, 19]`.\\n\\nThings get easy, right ???\\n\\nLet us keep on:\\n\\n4. n = 4\\n```python\\ndp = [1, 2, 4] # the numbers we have found\\n\\n# the index of the factors we choose from dp to multiply primes\\n# e.g if we choose nth number as ugly number, then, index[n-1] += 1\\n# so index will move to the right, which means we will replace the number\\nindex = [2, 0, 0, 0]\\n\\n# ** number ** means we will choose this number\\nugly_nums = [ 2 x dp[index[0]], **7 x dp[index[1]]**, 13 x dp[index[2]], 19 x dp[index[3]] ]\\n```\\n5. n = 5\\n```python\\ndp = [1, 2, 4, 7]\\nindex  = [2, 1, 0, 0]\\nugly_nums = [ **2 x 4**, 7 x 2, 13 x 1, 19 x 1 ]\\n```\\n6. n = 6\\n```python\\ndp = [1, 2, 4, 7, 8]\\nindex  = [3, 1, 0, 0]\\nugly_nums = [ 2 x 7, 7 x 2, **13 x 1**, 19 x 1 ]\\n```\\n7. n = 7\\n```python\\ndp = [1, 2, 4, 7, 8]\\nindex  = [3, 1, 1, 0]\\nugly_nums = [ **2 x 7**, **7 x 2**, 13 x 2, 19 x 1 ]\\n```\\nIf we have some same numbers, we choose only one value, but we will replace all of them at next step.\\n8. n = 8\\n```python\\ndp = [1, 2, 4, 7, 8]\\nindex  = [4, 2, 1, 0]\\nugly_nums = [ **2 x 8**, 7 x 4, 13 x 2, 19 x 1 ]\\n```\\n......\\nFinally, we will got the answers. \\n**As you can see, we need to keep:**\\n1.  The ugly number we found last time\\n2.  All the ugly numbers we have found\\n3.  The indexes in `dp` to multiply the prime number.\\n\\n**My code is as follows:**\\n```python\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        size = len(primes)\\n        ugly, dp, index, ugly_nums = 1, [1], [0] * size, [1] * size\\n        for i in range(1, n):\\n            # compute possibly ugly numbers and update index\\n            for j in range(0, size):\\n                if ugly_nums[j] == ugly:\\n                    ugly_nums[j] = dp[index[j]] * primes[j]\\n                    index[j] += 1\\n            # get the minimum\\n            ugly = min(ugly_nums)\\n            dp.append(ugly)\\n        return dp[-1]\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndp = [1, 2, 4] # the numbers we have found\\n\\n# the index of the factors we choose from dp to multiply primes\\n# e.g if we choose nth number as ugly number, then, index[n-1] += 1\\n# so index will move to the right, which means we will replace the number\\nindex = [2, 0, 0, 0]\\n\\n# ** number ** means we will choose this number\\nugly_nums = [ 2 x dp[index[0]], **7 x dp[index[1]]**, 13 x dp[index[2]], 19 x dp[index[3]] ]\\n```\n```python\\ndp = [1, 2, 4, 7]\\nindex  = [2, 1, 0, 0]\\nugly_nums = [ **2 x 4**, 7 x 2, 13 x 1, 19 x 1 ]\\n```\n```python\\ndp = [1, 2, 4, 7, 8]\\nindex  = [3, 1, 0, 0]\\nugly_nums = [ 2 x 7, 7 x 2, **13 x 1**, 19 x 1 ]\\n```\n```python\\ndp = [1, 2, 4, 7, 8]\\nindex  = [3, 1, 1, 0]\\nugly_nums = [ **2 x 7**, **7 x 2**, 13 x 2, 19 x 1 ]\\n```\n```python\\ndp = [1, 2, 4, 7, 8]\\nindex  = [4, 2, 1, 0]\\nugly_nums = [ **2 x 8**, 7 x 4, 13 x 2, 19 x 1 ]\\n```\n```python\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        size = len(primes)\\n        ugly, dp, index, ugly_nums = 1, [1], [0] * size, [1] * size\\n        for i in range(1, n):\\n            # compute possibly ugly numbers and update index\\n            for j in range(0, size):\\n                if ugly_nums[j] == ugly:\\n                    ugly_nums[j] = dp[index[j]] * primes[j]\\n                    index[j] += 1\\n            # get the minimum\\n            ugly = min(ugly_nums)\\n            dp.append(ugly)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76298,
                "title": "7-line-consice-o-kn-c-solution",
                "content": " Keep k pointers and update them in each iteration.   Time complexity is O(kn).\\n\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n            vector<int> index(primes.size(), 0), ugly(n, INT_MAX);\\n            ugly[0]=1;\\n            for(int i=1; i<n; i++){\\n                for(int j=0; j<primes.size(); j++) ugly[i]=min(ugly[i],ugly[index[j]]*primes[j]);\\n                for(int j=0; j<primes.size(); j++) index[j]+=(ugly[i]==ugly[index[j]]*primes[j]);\\n            }\\n            return ugly[n-1];\\n    }",
                "solutionTags": [],
                "code": " Keep k pointers and update them in each iteration.   Time complexity is O(kn).\\n\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n            vector<int> index(primes.size(), 0), ugly(n, INT_MAX);\\n            ugly[0]=1;\\n            for(int i=1; i<n; i++){\\n                for(int j=0; j<primes.size(); j++) ugly[i]=min(ugly[i],ugly[index[j]]*primes[j]);\\n                for(int j=0; j<primes.size(); j++) index[j]+=(ugly[i]==ugly[index[j]]*primes[j]);\\n            }\\n            return ugly[n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 76301,
                "title": "python-generators-on-a-heap",
                "content": "**Solution 1** ... ~550 ms (updated July 2016, originally was ~1570 ms)\\n\\nUsing generators and `heapq.merge`. Too bad there's no `itertools.unique`.\\n\\n    def nthSuperUglyNumber(self, n, primes):\\n        uglies = [1]\\n        def gen(prime):\\n            for ugly in uglies:\\n                yield ugly * prime\\n        merged = heapq.merge(*map(gen, primes))\\n        while len(uglies) < n:\\n            ugly = next(merged)\\n            if ugly != uglies[-1]:\\n                uglies.append(ugly)\\n        return uglies[-1]\\n\\n---\\n\\n**Solution 2** ... ~500 ms (updated July 2016, originally was ~1400 ms)\\n\\nSame thing done differently and it's a bit faster.\\n\\n    def nthSuperUglyNumber(self, n, primes):\\n        uglies = [1]\\n        merged = heapq.merge(*map(lambda p: (u*p for u in uglies), primes))\\n        uniqed = (u for u, _ in itertools.groupby(merged))\\n        map(uglies.append, itertools.islice(uniqed, n-1))\\n        return uglies[-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1** ... ~550 ms (updated July 2016, originally was ~1570 ms)\\n\\nUsing generators and `heapq.merge`. Too bad there's no `itertools.unique`.\\n\\n    def nthSuperUglyNumber(self, n, primes):\\n        uglies = [1]\\n        def gen(prime):\\n            for ugly in uglies:\\n                yield ugly * prime\\n        merged = heapq.merge(*map(gen, primes))\\n        while len(uglies) < n:\\n            ugly = next(merged)\\n            if ugly != uglies[-1]:\\n                uglies.append(ugly)\\n        return uglies[-1]\\n\\n---\\n\\n**Solution 2** ... ~500 ms (updated July 2016, originally was ~1400 ms)\\n\\nSame thing done differently and it's a bit faster.\\n\\n    def nthSuperUglyNumber(self, n, primes):\\n        uglies = [1]\\n        merged = heapq.merge(*map(lambda p: (u*p for u in uglies), primes))\\n        uniqed = (u for u, _ in itertools.groupby(merged))\\n        map(uglies.append, itertools.islice(uniqed, n-1))\\n        return uglies[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 76343,
                "title": "108ms-easy-to-understand-java-solution",
                "content": "    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[] ret    = new int[n];\\n              ret[0] = 1;\\n\\n        int[] indexes  = new int[primes.length];\\n       \\n        for(int i = 1; i < n; i++){\\n            ret[i] = Integer.MAX_VALUE;\\n            \\n            for(int j = 0; j < primes.length; j++){\\n                ret[i] = Math.min(ret[i], primes[j] * ret[indexes[j]]);\\n            }\\n            \\n            for(int j = 0; j < indexes.length; j++){\\n                if(ret[i] == primes[j] * ret[indexes[j]]){\\n                    indexes[j]++;\\n                }\\n            }\\n        }\\n        \\n        return ret[n - 1];\\n    }",
                "solutionTags": [],
                "code": "    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[] ret    = new int[n];\\n              ret[0] = 1;\\n\\n        int[] indexes  = new int[primes.length];\\n       \\n        for(int i = 1; i < n; i++){\\n            ret[i] = Integer.MAX_VALUE;\\n            \\n            for(int j = 0; j < primes.length; j++){\\n                ret[i] = Math.min(ret[i], primes[j] * ret[indexes[j]]);\\n            }\\n            \\n            for(int j = 0; j < indexes.length; j++){\\n                if(ret[i] == primes[j] * ret[indexes[j]]){\\n                    indexes[j]++;\\n                }\\n            }\\n        }\\n        \\n        return ret[n - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 76292,
                "title": "java-solution-uff0c21ms-uff0c-u8be6-u7ec6-u7684-u4e2d-u6587-u89e3-u91ca",
                "content": "\\u89e3\\u9898\\u601d\\u8def\\uff1a\\n\\u8981\\u4f7f\\u5f97super ugly number\\u4e0d\\u6f0f\\u6389\\uff0c\\u90a3\\u4e48\\u9700\\u8981\\u4f7f\\u7528\\u6bcf\\u4e2a\\u56e0\\u5b50\\u53bb\\u4e58\\u4ee5\\u5176\\u5bf9\\u5e94\\u7684\\u201c\\u7b2c\\u4e00\\u4e2a\\u201d\\u4e11\\u6570\\u3002\\u90a3\\u4e48\\u4f55\\u4e3a\\u5bf9\\u5e94\\u7684\\u201c\\u7b2c\\u4e00\\u4e2a\\u201d\\u4e11\\u6570\\uff1f\\n\\n\\u9996\\u5148\\uff0c\\u5229\\u7528ugly[]\\u6570\\u7ec4\\u6765\\u4fdd\\u5b58\\u6240\\u6709\\u7684\\u8d85\\u7ea7\\u4e11\\u6570\\uff0cugly[i]\\u8868\\u793a\\u7b2ci+1\\u4e2a\\u8d85\\u7ea7\\u4e11\\u6570\\uff1b\\n\\n\\u63a5\\u7740\\u5229\\u7528pointer[]\\u6570\\u7ec4\\u6765\\u8868\\u793a\\u6bcf\\u4e2a\\u56e0\\u5b50\\u5bf9\\u5e94\\u7684\\u201c\\u7b2c\\u4e00\\u4e2a\\u201d\\u4e11\\u6570\\u7684\\u4e0b\\u6807\\u3002pointer\\u6570\\u7ec4\\u957f\\u5ea6\\u5f53\\u7136\\u9700\\u8981\\u548cprimes\\u957f\\u5ea6\\u4e00\\u81f4\\uff0c\\u4e14\\u521d\\u59cb\\u5316\\u4e3a0\\uff0c\\u4ee3\\u8868\\u7740\\u6bcf\\u4e2a\\u56e0\\u5b50\\u5bf9\\u5e94\\u7684\\u201c\\u7b2c\\u4e00\\u4e2a\\u201d\\u4e11\\u6570\\u90fd\\u662fugly[0]\\uff1b\\n\\n\\u63a5\\u4e0b\\u6765\\u6211\\u4eec\\u4ee5primes[2,7,13,19],pointer[0,0,0,0],ugly[0]=1\\u4f5c\\u4e3a\\u521d\\u59cb\\u6761\\u4ef6\\u5f80\\u4e0b\\u770b\\uff1a\\n\\n\\u904d\\u5386primes\\u6570\\u7ec4\\uff0c\\u7528\\u6bcf\\u4e2a\\u56e0\\u5b50\\u90fd\\u4e58\\u4ee5\\u5176\\u5bf9\\u5e94\\u7684\\u7b2c\\u4e00\\u4e2a\\u4e11\\u6570\\uff0c\\u5373ugly[0]=1,\\u53ef\\u4ee5\\u53d1\\u73b01x2=2\\u662f\\u6700\\u5c0f\\u503c\\uff0c\\u6545ugly[1]=2;\\u4f46\\u8981\\u6ce8\\u610f\\uff0c\\u6b64\\u65f6\\u7684pointer\\u6570\\u7ec4\\u53d1\\u751f\\u4e86\\u53d8\\u5316\\uff1a\\n\\n\\u7531\\u4e8e\\u5f53\\u524d\\u4ea7\\u751f\\u7684\\u4e11\\u65702\\u662f\\u75312\\u8fd9\\u4e2a\\u56e0\\u5b50\\u4e58\\u4ee5\\u5b83\\u7684\\u5bf9\\u5e94\\u201c\\u7b2c\\u4e00\\u4e2a\\u201d\\u4e11\\u6570\\u5f97\\u5230\\u7684\\uff0c\\u56e0\\u6b64\\u9700\\u8981\\u5c06pointer[0]\\u52a0\\u4e00\\u3002pointer[0]\\u662f2\\u8fd9\\u4e2a\\u56e0\\u5b50\\u5bf9\\u5e94\\u7684\\u201c\\u7b2c\\u4e00\\u4e2a\\u201d\\u4e11\\u6570\\u7684\\u4e0b\\u6807\\uff0c\\u56e0\\u4e3a\\u5f53\\u524d\\u5df2\\u7ecf\\u4f7f\\u7528\\u4e862x1\\uff0c\\u5982\\u679c\\u4e0d\\u66f4\\u65b0\\uff0c\\u5219\\u4e0b\\u4e00\\u8f6e\\u8fd8\\u662f\\u4f1a\\u75282\\u8fd9\\u4e2a\\u56e0\\u5b50\\u53bb\\u4e58\\u4ee5\\u7b2c\\u4e00\\u4e2a\\u4e11\\u6570(ugly[0]).\\u5c06\\u5176\\u66f4\\u65b0\\u540e\\uff0c\\u5219\\u610f\\u5473\\u77402\\u8fd9\\u4e2a\\u56e0\\u5b50\\u5bf9\\u5e94\\u7684\\u7b2c\\u4e00\\u4e2a\\u4e11\\u6570\\u5df2\\u7ecf\\u6539\\u53d8\\u4e86\\uff0c\\u53d8\\u6210\\u4e86ugly[1].\\u800c\\u5176\\u4ed6\\u4e09\\u4e2a\\u5bf9\\u5e94\\u7684\\u201c\\u7b2c\\u4e00\\u4e2a\\u201d\\u4e11\\u6570\\u8fd8\\u662fugly[0]\\u3002\\n\\n\\u6211\\u4eec\\u63a5\\u7740\\u770b\\u4e0b\\u4e00\\u8f6e\\uff1a2x2\\u3010\\u5373ugly[pointer[1]]x2\\u3011,1x7,1x13,1x19\\uff0c\\u53d1\\u73b0\\u8fd8\\u662f2\\u8fd9\\u4e2a\\u56e0\\u5b50\\u5f97\\u5230\\u7684\\u6570\\u6700\\u5c0f\\uff0c\\u6545\\u66f4\\u65b0\\uff1augly[2]=2x2=4,pointer[0]=2\\uff1b\\n\\n\\u4e0b\\u4e00\\u8f6e\\uff1a4x2,1x7,1x13,1x19,\\u53ef\\u4ee5\\u53d1\\u73b0\\u5f53\\u524d\\u8fd9\\u4e00\\u8f6e\\u6700\\u5c0f\\u503c\\u662f7\\uff0c\\u4e14\\u7531\\u56e0\\u5b507\\u4ea7\\u751f\\uff0c\\u6545\\u66f4\\u65b0\\uff1augly[3]=7,pointer[1]=1\\uff1b\\n\\n\\u4ee5\\u6b64\\u7c7b\\u63a8....\\n\\u5982\\u679c\\u66f4\\u65b0\\u8fc7\\u7a0b\\u4e2d\\uff0c\\u51fa\\u73b0\\u6700\\u5c0f\\u503c\\u4e0d\\u6b62\\u4e00\\u4e2a\\u7684\\u8bdd\\uff0c\\u5219\\u5176\\u5bf9\\u5e94\\u7684pointer\\u7684\\u503c\\u90fd\\u9700\\u8981\\u589e\\u52a01\\u3002\\n```\\npublic int nthSuperUglyNumber(int n, int[] primes) {\\n        int[] ugly = new int[n+1];\\n        ugly[0]=1;\\n        int[] pointer = new int[primes.length];\\n        for(int i=1;i<n;i++) {\\n            int min=Integer.MAX_VALUE;\\n            int minIndex = 0;\\n            for(int j=0;j<primes.length;j++) {\\n                if(ugly[pointer[j]]*primes[j]<min) {\\n                    min=ugly[pointer[j]]*primes[j];\\n                    minIndex = j;\\n                }else if(ugly[pointer[j]]*primes[j]==min) {\\n                    pointer[j]++;\\n                }\\n            }\\n            ugly[i]=min;\\n            pointer[minIndex]++;\\n        }\\n        return ugly[n-1];\\n    }\\n````",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int nthSuperUglyNumber(int n, int[] primes) {\\n        int[] ugly = new int[n+1];\\n        ugly[0]=1;\\n        int[] pointer = new int[primes.length];\\n        for(int i=1;i<n;i++) {\\n            int min=Integer.MAX_VALUE;\\n            int minIndex = 0;\\n            for(int j=0;j<primes.length;j++) {\\n                if(ugly[pointer[j]]*primes[j]<min) {\\n                    min=ugly[pointer[j]]*primes[j];\\n                    minIndex = j;\\n                }else if(ugly[pointer[j]]*primes[j]==min) {\\n                    pointer[j]++;\\n                }\\n            }\\n            ugly[i]=min;\\n            pointer[minIndex]++;\\n        }\\n        return ugly[n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332400,
                "title": "python-o-nlogk-concise-heap-solution-and-detailed-explanation",
                "content": "The high level idea is to generate all ugly numbers in an array. To keep them in order, we need to pick a prime to multiply with a generated ugly number to generate the \"next\" ugly number, or the smallest ugly number that hasn\\'t been generated.\\n\\nSo we can generate a candidate minheap that guarantees to contain the next smallest ugly number and we can easily pop the smallest ugly number from it and add it to the ugly list. Any ugly number must be in form of ```p * u``` where ```p``` is a prime from ```primes``` list and ```u``` is a generated number in ugly list. So we just need to track currently smallest ```p * u``` that each ```p``` can generate and add them to the minheap. \\n\\nInitially, candidate minheap contains all the ```p``` in primes. Then each time we pop out a ```p * u```, we add ```p * u\\'``` with the smallest ```u\\'``` that ```p``` yet to use to the candidate list to ensure there is no ```p * u\\'\\'``` that can be smaller than ```p * u\\'``` and missed by candidate list. Since ugly list is actually sorted, ```u\\'``` is the next element of ```u```. \\n\\nIn such way, the candidates minheap limit its size within ```primes.length``` and won\\'t miss any smallest ugly number as well.\\n\\nI tracked which ```p``` generates one specific ugly number ```x = p * u```, and an index ```i``` to track the smallest ```u``` or ```ugly[i]``` that specific ```p``` hasn\\'t been multiplied with. Thus each heap element is a triple of ```(p*u, p, i)```\\nAnd there could be identical value generated by different ```p```. e.g. 14 = 2 * 7 = 7 * 2. So I used a while loop to pop all identical ugly number in candidate list.\\n```\\ndef nthSuperUglyNumber(n, primes):\\n\\tcand = [(p, p, 1) for p in primes]\\n\\tugly = [1]\\n\\tfor _ in range(n-1):\\n\\t\\tugly.append(cand[0][0])\\n\\t\\twhile cand[0][0] == ugly[-1]:\\n\\t\\t\\tx, p, i = heapq.heappop(cand)\\n\\t\\t\\theapq.heappush(cand, (p*ugly[i], p, i+1))\\n\\treturn ugly[-1]\\n```\\nSo the time complexity is O(n * logk) where k is the size of primes. Its efficiency is lit when k is large.",
                "solutionTags": [],
                "code": "```p * u```\n```p```\n```primes```\n```u```\n```p * u```\n```p```\n```p```\n```p * u```\n```p * u\\'```\n```u\\'```\n```p```\n```p * u\\'\\'```\n```p * u\\'```\n```u\\'```\n```u```\n```primes.length```\n```p```\n```x = p * u```\n```i```\n```u```\n```ugly[i]```\n```p```\n```(p*u, p, i)```\n```p```\n```\\ndef nthSuperUglyNumber(n, primes):\\n\\tcand = [(p, p, 1) for p in primes]\\n\\tugly = [1]\\n\\tfor _ in range(n-1):\\n\\t\\tugly.append(cand[0][0])\\n\\t\\twhile cand[0][0] == ugly[-1]:\\n\\t\\t\\tx, p, i = heapq.heappop(cand)\\n\\t\\t\\theapq.heappush(cand, (p*ugly[i], p, i+1))\\n\\treturn ugly[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 868948,
                "title": "python3-l-faster-than-99-35-using-heapq",
                "content": "Instead of checking the numbers one by one, here we are generating the numbers from the already available ugly numbers and keeping a count.\\nFor example: primes = [2,3,5] and n = 16\\nHere catch is there are multiple additions to heap like 6 = 2\\\\*3 and also 6 = 3\\\\*2\\nso what we do is :\\nfor 2, we find multiples of 2 like 2\\\\*2 = 4 \\nfor 3, we find multiples of 2 and 3 like 3\\\\*2 , 3\\\\*3 = 6,9\\nfor 5, we find multiples of 2, 3 and 5 like 5\\\\*2, 5\\\\*3, 5\\\\*5  = 10,15,25\\n```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        nums = primes.copy() # do a deep copy \\n        heapq.heapify(nums) #create a heap\\n        p = 1\\n        for i in range(n - 1):\\n            p = heapq.heappop(nums) #take the smallest element\\n            for prime in primes:\\n                heapq.heappush(nums, p * prime) #add all those multiples with the smallest number\\n                if p % prime == 0:\\n\\t\\t\\t\\t\\tbreak\\n        return p\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        nums = primes.copy() # do a deep copy \\n        heapq.heapify(nums) #create a heap\\n        p = 1\\n        for i in range(n - 1):\\n            p = heapq.heappop(nums) #take the smallest element\\n            for prime in primes:\\n                heapq.heappush(nums, p * prime) #add all those multiples with the smallest number\\n                if p % prime == 0:\\n\\t\\t\\t\\t\\tbreak\\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76330,
                "title": "using-min-heap-accepted-java-and-python-code",
                "content": "The idea is similar to 264 Ugly Number II. The insight is that each new ugly number is generated from the previous ugly number by multiplying one of the prime. Thus we can maintain a pointer for each prime which indicates the current position of the generated ugly number list. Then there is a new ugly number from each prime, then we find the minimum one from them. Naturally the minimum one can be found by min-heap.\\n\\nThe Java version is accepted by 474 ms, but not the python version. \\n\\n**UPDATE**: Thanks **Stefan** for pointing out that the complexity of this algorithm is **NOT** O(nlog(k)). I have modified the Python code and it was just accepted by 800 ms; the modified Java code is accepted by 160 ms. I will keep the original inefficient code here and Please check the updated code below...\\n\\nJava\\n\\n    import java.util.Comparator;\\n    import java.util.PriorityQueue;\\n    public class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n\\t\\tComparator<Number> comparator = new NumberCompare();\\n\\t\\tPriorityQueue<Number> queue = \\n\\t            new PriorityQueue<Number>(primes.length, comparator);\\n\\t\\tfor(int i = 0; i < primes.length; i ++) \\n\\t\\t\\tqueue.add(new Number(primes[i], 0, primes[i]));\\n\\t\\tint[] uglyNums = new int[n];\\n\\t\\tuglyNums[0] = 1;\\n\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\tNumber min = queue.peek();\\n\\t\\t\\tuglyNums[i] = min.un;\\n\\t\\t\\twhile(queue.peek().un == min.un){\\n\\t\\t\\t\\tNumber tmp = queue.poll();\\n\\t\\t\\t\\tqueue.add(new Number(uglyNums[tmp.pos + 1] * tmp.prime, tmp.pos+1, tmp.prime)); \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn uglyNums[n-1];\\n    }\\n    \\n\\tpublic class Number{\\n\\t\\tint un;\\n\\t\\tint pos;\\n\\t\\tint prime;\\n\\t\\tNumber(int un, int pos, int prime){\\n\\t\\t\\tthis.un = un;\\n\\t\\t\\tthis.pos = pos;\\n\\t\\t\\tthis.prime = prime;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic class NumberCompare implements Comparator<Number>{\\n\\n\\t\\t@Override\\n\\t\\tpublic int compare(Number x, Number y) {\\n\\t\\t\\t// TODO Auto-generated method stub\\n\\t\\t\\tif (x.un > y.un)\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\telse if (x.un < y.un)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n}\\n\\n\\n\\nPython \\n\\n    class Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Use the heap to find the next one\\n        import heapq\\n        q, uglyNums = [], [1]\\n        k = len(primes)\\n        for i in range(k): heapq.heappush(q, (primes[i], 0, primes[i]))\\n        while len(uglyNums) < n:\\n            x, i, p = q[0]\\n            uglyNums += [x]\\n            while q and q[0][0] == x:\\n                x, i, p = heapq.heappop(q)\\n                heapq.heappush(q, (p * uglyNums[i+1], i+1, p))\\n        return uglyNums[-1]",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n\\t\\tComparator<Number> comparator = new NumberCompare();\\n\\t\\tPriorityQueue<Number> queue = \\n\\t            new PriorityQueue<Number>(primes.length, comparator);\\n\\t\\tfor(int i = 0; i < primes.length; i ++) \\n\\t\\t\\tqueue.add(new Number(primes[i], 0, primes[i]));\\n\\t\\tint[] uglyNums = new int[n];\\n\\t\\tuglyNums[0] = 1;\\n\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\tNumber min = queue.peek();\\n\\t\\t\\tuglyNums[i] = min.un;\\n\\t\\t\\twhile(queue.peek().un == min.un){\\n\\t\\t\\t\\tNumber tmp = queue.poll();\\n\\t\\t\\t\\tqueue.add(new Number(uglyNums[tmp.pos + 1] * tmp.prime, tmp.pos+1, tmp.prime)); \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 76331,
                "title": "clear-c-solution-inspired-by-ugly-number-ii",
                "content": "    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n    \\tint k = primes.size();\\n    \\tvector<int> pos(k, 0);\\n    \\tvector<int> res(n);\\n    \\tres[0] = 1;\\n    \\tfor (int i = 1; i < n; i++) {\\n    \\t\\tint temp = INT_MAX;\\n    \\t\\tfor (int j = 0; j < k; j++) \\n    \\t\\t\\ttemp = min(temp, res[pos[j]] * primes[j]);\\n    \\t\\tfor (int j = 0; j < k; j++) {\\n    \\t\\t\\tif (temp == res[pos[j]] * primes[j])\\n    \\t\\t\\t\\tpos[j]++;\\n    \\t\\t}\\n    \\t\\tres[i] = temp;\\n    \\t}\\n    \\treturn res[n - 1];\\n    }",
                "solutionTags": [],
                "code": "    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n    \\tint k = primes.size();\\n    \\tvector<int> pos(k, 0);\\n    \\tvector<int> res(n);\\n    \\tres[0] = 1;\\n    \\tfor (int i = 1; i < n; i++) {\\n    \\t\\tint temp = INT_MAX;\\n    \\t\\tfor (int j = 0; j < k; j++) \\n    \\t\\t\\ttemp = min(temp, res[pos[j]] * primes[j]);\\n    \\t\\tfor (int j = 0; j < k; j++) {\\n    \\t\\t\\tif (temp == res[pos[j]] * primes[j])\\n    \\t\\t\\t\\tpos[j]++;\\n    \\t\\t}\\n    \\t\\tres[i] = temp;\\n    \\t}\\n    \\treturn res[n - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 768762,
                "title": "c-heap-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        ll top, i=0;\\n        vector<int> arr(n, -1);\\n        priority_queue<ll, vector<ll>, greater<ll>> pq={};\\n        pq.push(1);\\n        while(!pq.empty() && arr[n-1]==-1){\\n            top=pq.top();\\n            arr[i++]=top;\\n            pq.pop();\\n            for(auto elt:primes)\\n                pq.push(top*elt);\\n            while(!pq.empty() && top==pq.top())\\n                pq.pop();\\n        }\\n        return arr[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        ll top, i=0;\\n        vector<int> arr(n, -1);\\n        priority_queue<ll, vector<ll>, greater<ll>> pq={};\\n        pq.push(1);\\n        while(!pq.empty() && arr[n-1]==-1){\\n            top=pq.top();\\n            arr[i++]=top;\\n            pq.pop();\\n            for(auto elt:primes)\\n                pq.push(top*elt);\\n            while(!pq.empty() && top==pq.top())\\n                pq.pop();\\n        }\\n        return arr[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76369,
                "title": "fast-python-solution-based-on-solution-for-ugly-number-ii",
                "content": "Just an extrapolation of @dietpepsi's solution for Ugly Number II\\nhttps://leetcode.com/discuss/61443/ac-python-solution-o-n-time-o-n-space\\n\\n\\n\\n\\n    class Solution(object):\\n        def nthSuperUglyNumber(self, n, primes):\\n            \"\"\"\\n            :type n: int\\n            :type primes: List[int]\\n            :rtype: int\\n            \"\"\"\\n            ugly = [1] * n\\n            i_list = [-1] * len(primes)\\n            v_list = [1] * len(primes)\\n            k = 0\\n            while k < n:\\n                x = min(v_list)\\n                ugly[k] = x\\n                for v in xrange(len(v_list)):\\n                    if x == v_list[v]:\\n                        i_list[v] += 1\\n                        v_list[v] = ugly[i_list[v]] * primes[v]\\n                k += 1\\n            return ugly[k-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Just an extrapolation of @dietpepsi's solution for Ugly Number II\\nhttps://leetcode.com/discuss/61443/ac-python-solution-o-n-time-o-n-space\\n\\n\\n\\n\\n    class Solution(object):\\n        def nthSuperUglyNumber(self, n, primes):\\n            \"\"\"\\n            :type n: int\\n            :type primes: List[int]\\n            :rtype: int\\n            \"\"\"\\n            ugly = [1] * n\\n            i_list = [-1] * len(primes)\\n            v_list = [1] * len(primes)\\n            k = 0\\n            while k < n:\\n                x = min(v_list)\\n                ugly[k] = x\\n                for v in xrange(len(v_list)):\\n                    if x == v_list[v]:\\n                        i_list[v] += 1\\n                        v_list[v] = ugly[i_list[v]] * primes[v]\\n                k += 1\\n            return ugly[k-1]",
                "codeTag": "Java"
            },
            {
                "id": 1603378,
                "title": "c-priority-queue-with-explanation",
                "content": "```\\n    class Solution {\\n    public:\\n        using P = pair<long long, int>;\\n        int nthSuperUglyNumber(int n, vector<int>& primes) {\\n            vector<int> index(primes.size(), 0);\\n            vector<long long> nums;\\n            nums.push_back(1);      \\n            \\n            priority_queue<P, vector<P>, greater<P>> pq;    // remember pair(the ugly number, who generated this ugly)\\n            for (int i = 0; i < primes.size(); i++)\\n                pq.emplace(primes[i], i);   // initial ugly = prime  * 1\\n            \\n            while (nums.size() < n)\\n            {\\n                auto [value, id] = pq.top();    // get the smallest ugly\\n                pq.pop();\\n                \\n                if (value != nums.back())       // check the dupe\\n                    nums.push_back(value);\\n                \\n                index[id]++;                             // the prime generated this small ugly number should move forward to multiply next ugly number\\n                pq.emplace(nums[index[id]] * primes[id], id);         // push the new ugly number to pq to participate sorting\\n            }\\n            \\n            return nums.back();\\n        }\\n    };\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    class Solution {\\n    public:\\n        using P = pair<long long, int>;\\n        int nthSuperUglyNumber(int n, vector<int>& primes) {\\n            vector<int> index(primes.size(), 0);\\n            vector<long long> nums;\\n            nums.push_back(1);      \\n            \\n            priority_queue<P, vector<P>, greater<P>> pq;    // remember pair(the ugly number, who generated this ugly)\\n            for (int i = 0; i < primes.size(); i++)\\n                pq.emplace(primes[i], i);   // initial ugly = prime  * 1\\n            \\n            while (nums.size() < n)\\n            {\\n                auto [value, id] = pq.top();    // get the smallest ugly\\n                pq.pop();\\n                \\n                if (value != nums.back())       // check the dupe\\n                    nums.push_back(value);\\n                \\n                index[id]++;                             // the prime generated this small ugly number should move forward to multiply next ugly number\\n                pq.emplace(nums[index[id]] * primes[id], id);         // push the new ugly number to pq to participate sorting\\n            }\\n            \\n            return nums.back();\\n        }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701051,
                "title": "c-dynamic-programming-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon analyzing the code, here are my initial thoughts on how to solve the problem:\\n\\n1. Understand the problem: The goal is to find the nth super ugly number given a list of prime numbers. A super ugly number is a positive integer whose prime factors are limited to the given list of primes.\\n\\n2. Approach: The code follows a dynamic programming approach. It uses an array, `superUgly`, to store the super ugly numbers. The algorithm iterates from 1 to n, calculating each super ugly number based on the prime number multiples and their corresponding indices.\\n\\n3. Key variables:\\n   - `n`: The input representing the position of the super ugly number to find.\\n   - `primes`: A vector containing the prime numbers to be used as factors.\\n   - `numPrimes`: The number of prime numbers in the `primes` vector.\\n   - `primeIndices`: A vector storing the current indices for each prime number.\\n   - `superUgly`: An array that will hold the super ugly numbers.\\n\\n4. Algorithm:\\n   - Check if n is 1, in which case the first super ugly number is 1.\\n   - Initialize the vector `primeIndices` with zeros for each prime number.\\n   - Initialize the first element of `superUgly` as 1 since 1 is always a super ugly number.\\n   - Iterate from 1 to n (exclusive):\\n     - Find the minimum value, `minVal`, among the prime number multiples.\\n     - Store `minVal` as the current super ugly number.\\n     - Increment the indices of the prime number multiples that contribute to the minimum value.\\n   - Return the nth super ugly number.\\n\\nOverall, the code efficiently calculates the nth super ugly number by iteratively finding the minimum value among the prime number multiples.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve the problem of finding the nth super ugly number given a list of prime numbers, here\\'s the approach I would take:\\n\\n1. Initialize a list or array to store the super ugly numbers.\\n2. Since the first super ugly number is always 1, add it to the list.\\n3. Create a separate list to keep track of the indices for each prime number in the given list. Initialize all indices to 0.\\n4. Iterate from 1 to n (exclusive) to find the remaining super ugly numbers.\\n5. For each iteration:\\n   a. Find the minimum value among the products of each prime number with its corresponding super ugly number at the respective index.\\n   b. Add the minimum value to the list of super ugly numbers.\\n   c. Update the indices for the prime numbers that contributed to the minimum value by incrementing them.\\n   d. Repeat steps a-c until all n super ugly numbers are found.\\n6. Return the nth super ugly number from the list.\\n\\nThis approach takes advantage of the fact that each super ugly number can be obtained by multiplying a prime number with a previously generated super ugly number. By keeping track of the indices for each prime number, we can efficiently generate the super ugly numbers in ascending order.\\n\\n# Complexity\\n- Time complexity: O(n * k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n + k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Finds the nth super ugly number given a list of prime numbers.\\n\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if (n == 1)\\n            return 1;\\n\\n        int numPrimes = primes.size();  // Number of prime numbers\\n        vector<int> primeIndices(numPrimes, 0);  // Indices to track prime number multiples\\n\\n        int superUgly[n];  // Array to store super ugly numbers\\n        // memset(superUgly, 0, sizeof(superUgly));  // Initialize the array (commented out since it\\'s unnecessary)\\n        superUgly[0] = 1;  // First super ugly number is always 1\\n\\n        for (int i = 1; i < n; i++) {\\n            long minVal = INT_MAX;  // Minimum value among the prime number multiples\\n\\n            // Find the minimum value among the prime number multiples\\n            for (int j = 0; j < numPrimes; j++) {\\n                minVal = min(minVal, (long)primes[j] * superUgly[primeIndices[j]]);\\n            }\\n\\n            superUgly[i] = (int)minVal;  // Store the minimum value as the next super ugly number\\n\\n            // Increment the indices for prime number multiples that contribute to the minimum value\\n            for (int j = 0; j < numPrimes; j++) {\\n                if (minVal == (long)primes[j] * superUgly[primeIndices[j]]) {\\n                    primeIndices[j]++;\\n                }\\n            }\\n\\n            // cout<<superUgly[i]<<\",\";  // Print the current super ugly number (commented out for clarity)\\n        }\\n\\n        return superUgly[n - 1];  // Return the nth super ugly number\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/7ad5c196-b2e4-43fd-bd89-e2245f9a1cdb_1688138793.3109202.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Finds the nth super ugly number given a list of prime numbers.\\n\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if (n == 1)\\n            return 1;\\n\\n        int numPrimes = primes.size();  // Number of prime numbers\\n        vector<int> primeIndices(numPrimes, 0);  // Indices to track prime number multiples\\n\\n        int superUgly[n];  // Array to store super ugly numbers\\n        // memset(superUgly, 0, sizeof(superUgly));  // Initialize the array (commented out since it\\'s unnecessary)\\n        superUgly[0] = 1;  // First super ugly number is always 1\\n\\n        for (int i = 1; i < n; i++) {\\n            long minVal = INT_MAX;  // Minimum value among the prime number multiples\\n\\n            // Find the minimum value among the prime number multiples\\n            for (int j = 0; j < numPrimes; j++) {\\n                minVal = min(minVal, (long)primes[j] * superUgly[primeIndices[j]]);\\n            }\\n\\n            superUgly[i] = (int)minVal;  // Store the minimum value as the next super ugly number\\n\\n            // Increment the indices for prime number multiples that contribute to the minimum value\\n            for (int j = 0; j < numPrimes; j++) {\\n                if (minVal == (long)primes[j] * superUgly[primeIndices[j]]) {\\n                    primeIndices[j]++;\\n                }\\n            }\\n\\n            // cout<<superUgly[i]<<\",\";  // Print the current super ugly number (commented out for clarity)\\n        }\\n\\n        return superUgly[n - 1];  // Return the nth super ugly number\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 388800,
                "title": "python-simple-to-understand-dp-with-heapq-beats-95-56-292-ms",
                "content": "The essence of this problem is to inserting elements into an array with some pattern while keep the array sorted.\\n\\nUse the given primes example [2,7,13,19]\\n\\n- At first step, we add 1 to the array since the first ugly number is 1, we have\\n\\n\\tarray = [1]\\n\\n- Then we use the smallest newly added element to multiply all given primes numbers and add it to the array\\n\\n\\tarray = [1, 1x2, 1x7,1x13,1x19] = [1,2,7,13,19]\\n\\n- Since 2 is the smallest newly added element, so next step we need to add [2x2, 2x7,2x13,2x19], note that since 2x2 less than 1x7, so the resulting sorted array is:\\n\\n\\tarray = [1, 2, 4, 7, 13, 14, 19, 26, 38], then we use 4 to multiple primes as the next step.\\n\\nI found that the number I use to multiple with the primes is exactly the number (n-1)^th ugly number. So it\\'s trival to solve it recursively:\\n\\n```python\\ndef nthSuperUglyNumber(self, n: int, primes) -> int:\\n\\tl = [1]\\n\\td = defaultdict(lambda: False)\\n\\td[1] = True\\n\\tdef recur(n):\\n\\t\\tif n == 1:\\n\\t\\t\\treturn 1\\n\\t\\telse:\\n\\t\\t\\tlast = recur(n-1)\\n\\t\\t\\tfor p in primes:\\n\\t\\t\\t\\tnum = p*last\\n\\t\\t\\t\\tif num > l[-1]:\\n\\t\\t\\t\\t\\tl.append(num)\\n\\t\\t\\t\\t\\td[num] = True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif not d[num]:\\n\\t\\t\\t\\t\\t\\tbisect.insort_left(l, num)\\n\\t\\t\\t\\t\\t\\td[num] = True\\n\\t\\t\\treturn l[n-1]\\n        return recur(n)\\n```\\n\\nHowever, it easily fails at 81 / 83, because of python\\'s RecursionError: maximum recursion depth exceeded in comparison. It\\'s pretty annoying you find a solution but it exceeds the time limit. So I tried using an iteration approach:\\n\\n```python\\ndef nthSuperUglyNumber(self, n: int, primes) -> int:\\n\\tpq = []\\n\\td = defaultdict(lambda: False)\\n\\tpq = [1]\\n\\td[1] = True\\n\\tfor i in range(0, n):\\n\\t\\tfor p in primes:\\n\\t\\t\\tr = p*pq[i]\\n\\t\\t\\tif not d[r]:\\n\\t\\t\\t\\tif r > pq[-1]:\\n\\t\\t\\t\\t\\tpq.append(r)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbisect.insort_left(pq, r)\\n\\t\\t\\t\\td[r] = True\\n\\treturn pq[n-1]\\n```\\n\\nIt indeed avoids the curse of recursion but still TLE on 81/83 because of the overhead of adding way more elements than we actually need and maintaining the order of them. So the last hope is dp, (should be the first).\\n\\nHowever, it does require some deep thoughts than brute force with recursion. Note that since elements are products with each other or with itself. i.e. the first one is 1, is the min of all primes of power 0. The second element is min of all elements of power 1. Starting from the third, we have to compare 2^2 with 7^1 in the given example, or 2^2 with 3^1, if the second given prime number is 3. It\\'s not easy to get the pattern since the order depends on the difference/distance between the given prime numbers. Using a table to illustrate the final given example [2,7,13,19] when n=12.\\n\\n```\\n2^1  7^1*1      13^1*1    19^1*1\\n2^2  7^1*2^1    13^1*2^1\\n2^3  7^1*2^2\\n2^4 \\n2^5\\n```\\n\\nNote that the first element is special since the smallest value it can get given a under a certain power constrain is to multiply by itself. Starting from the second one, it actually grows with itself multiply by the ith ugly number given by its row e.g. the third row of 7 is 7 * array[2] (zero based), which is 7\\\\*4 = 28. Based on this observation, we can add one number at a time until we hit n.\\n\\n```python\\ndef nthSuperUglyNumber(self, n: int, primes) -> int:\\n\\tlp = len(primes)\\n\\tindices = [0]*lp\\n\\tl = [1]*n\\n\\tpq = list(zip(primes, range(lp)))\\n\\theapq.heapify(pq)\\n\\tc, mx = 1, 1\\n\\twhile c < n:\\n\\t\\tval, i = heapq.heappop(pq)\\n\\t\\tindices[i] += 1\\n\\t\\tif val > mx:\\n\\t\\t\\tl[c] = val\\n\\t\\t\\tmx = val\\n\\t\\t\\tc += 1\\n\\t\\tif i == 0:\\n\\t\\t\\tval *= primes[i]\\n\\t\\telse:\\n\\t\\t\\tval = primes[i] * l[indices[i]]\\n\\t\\theapq.heappush(pq, (val, i))\\n        return l[-1]\\n```\\n\\nWe use a min priority queue to keep the different values in order and pop up the lowest value we should add to the array, after added, we push it back to the pq. In order to know how to update the value, we also saved it\\'s index in primes, so that we can know which number it should multiply to as the next val when it pops out. Fortunately the size of the primes is small so the cost of using priority queue is acceptable.\\n\\nIt\\'s not a straight forward problem, I did spend quite some time to figure this out. Hope it helps.\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\ndef nthSuperUglyNumber(self, n: int, primes) -> int:\\n\\tl = [1]\\n\\td = defaultdict(lambda: False)\\n\\td[1] = True\\n\\tdef recur(n):\\n\\t\\tif n == 1:\\n\\t\\t\\treturn 1\\n\\t\\telse:\\n\\t\\t\\tlast = recur(n-1)\\n\\t\\t\\tfor p in primes:\\n\\t\\t\\t\\tnum = p*last\\n\\t\\t\\t\\tif num > l[-1]:\\n\\t\\t\\t\\t\\tl.append(num)\\n\\t\\t\\t\\t\\td[num] = True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif not d[num]:\\n\\t\\t\\t\\t\\t\\tbisect.insort_left(l, num)\\n\\t\\t\\t\\t\\t\\td[num] = True\\n\\t\\t\\treturn l[n-1]\\n        return recur(n)\\n```\n```python\\ndef nthSuperUglyNumber(self, n: int, primes) -> int:\\n\\tpq = []\\n\\td = defaultdict(lambda: False)\\n\\tpq = [1]\\n\\td[1] = True\\n\\tfor i in range(0, n):\\n\\t\\tfor p in primes:\\n\\t\\t\\tr = p*pq[i]\\n\\t\\t\\tif not d[r]:\\n\\t\\t\\t\\tif r > pq[-1]:\\n\\t\\t\\t\\t\\tpq.append(r)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbisect.insort_left(pq, r)\\n\\t\\t\\t\\td[r] = True\\n\\treturn pq[n-1]\\n```\n```\\n2^1  7^1*1      13^1*1    19^1*1\\n2^2  7^1*2^1    13^1*2^1\\n2^3  7^1*2^2\\n2^4 \\n2^5\\n```\n```python\\ndef nthSuperUglyNumber(self, n: int, primes) -> int:\\n\\tlp = len(primes)\\n\\tindices = [0]*lp\\n\\tl = [1]*n\\n\\tpq = list(zip(primes, range(lp)))\\n\\theapq.heapify(pq)\\n\\tc, mx = 1, 1\\n\\twhile c < n:\\n\\t\\tval, i = heapq.heappop(pq)\\n\\t\\tindices[i] += 1\\n\\t\\tif val > mx:\\n\\t\\t\\tl[c] = val\\n\\t\\t\\tmx = val\\n\\t\\t\\tc += 1\\n\\t\\tif i == 0:\\n\\t\\t\\tval *= primes[i]\\n\\t\\telse:\\n\\t\\t\\tval = primes[i] * l[indices[i]]\\n\\t\\theapq.heappush(pq, (val, i))\\n        return l[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 234588,
                "title": "easy-python-solution-use-heap",
                "content": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        h, heap = set([1]), [1]\\n        while n:\\n            a = heappop(heap)\\n            for i in primes:\\n                m = a * i\\n                if not m in h:\\n                    heappush(heap, m)\\n                    h.add(m)\\n            n -= 1\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        h, heap = set([1]), [1]\\n        while n:\\n            a = heappop(heap)\\n            for i in primes:\\n                m = a * i\\n                if not m in h:\\n                    heappush(heap, m)\\n                    h.add(m)\\n            n -= 1\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76308,
                "title": "my-easy-understanding-java-solution-with-priorityqueue",
                "content": "```\\npublic int nthSuperUglyNumber(int n, int[] primes) {\\n        if (n == 1) {\\n            return 1;\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int x : primes) {\\n            pq.offer(x);\\n        }\\n        for (int i=0; i<n-2; ++i) {\\n            int cur = pq.poll();\\n            for (int x : primes) {  //each one pop out should multiply the array\\n                long mult = (long)cur * (long)x;\\n                if (mult < Integer.MAX_VALUE) {\\n                    pq.offer((int)mult);\\n                }\\n            }\\n            while (pq.peek() == cur) {  // It is sorted, so if duplicate, only happen at root, poll it\\n                pq.poll();\\n            }\\n        }\\n        return pq.poll();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int nthSuperUglyNumber(int n, int[] primes) {\\n        if (n == 1) {\\n            return 1;\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int x : primes) {\\n            pq.offer(x);\\n        }\\n        for (int i=0; i<n-2; ++i) {\\n            int cur = pq.poll();\\n            for (int x : primes) {  //each one pop out should multiply the array\\n                long mult = (long)cur * (long)x;\\n                if (mult < Integer.MAX_VALUE) {\\n                    pq.offer((int)mult);\\n                }\\n            }\\n            while (pq.peek() == cur) {  // It is sorted, so if duplicate, only happen at root, poll it\\n                pq.poll();\\n            }\\n        }\\n        return pq.poll();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828266,
                "title": "heapq-did-the-job",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        hp=[1]\\n        dc={1}\\n        i=1\\n        while(n):\\n            mn=heapq.heappop(hp)\\n            if(n==1):\\n                return mn\\n            for p in primes:\\n                newno=mn*p\\n                if(newno in dc):\\n                    continue\\n                heapq.heappush(hp,newno)\\n                dc.add(newno)\\n            n-=1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        hp=[1]\\n        dc={1}\\n        i=1\\n        while(n):\\n            mn=heapq.heappop(hp)\\n            if(n==1):\\n                return mn\\n            for p in primes:\\n                newno=mn*p\\n                if(newno in dc):\\n                    continue\\n                heapq.heappush(hp,newno)\\n                dc.add(newno)\\n            n-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416982,
                "title": "c-solution-of-super-ugly-number-using-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int cnt=0;\\n        long long val=0;\\n        priority_queue<long long,vector<long long>,greater<long long>> pq;\\n        pq.push(1);\\n        int i=0;\\n        while(!pq.empty() && cnt!=n){\\n           long long mx=pq.top();\\n           val=mx;\\n           for(int j=0;j<primes.size();j++){\\n               pq.push(mx*primes[j]);\\n           }\\n           while(!pq.empty()&& mx==pq.top()){\\n               pq.pop();\\n           }\\n           cnt++;\\n        }\\n        return val;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int cnt=0;\\n        long long val=0;\\n        priority_queue<long long,vector<long long>,greater<long long>> pq;\\n        pq.push(1);\\n        int i=0;\\n        while(!pq.empty() && cnt!=n){\\n           long long mx=pq.top();\\n           val=mx;\\n           for(int j=0;j<primes.size();j++){\\n               pq.push(mx*primes[j]);\\n           }\\n           while(!pq.empty()&& mx==pq.top()){\\n               pq.pop();\\n           }\\n           cnt++;\\n        }\\n        return val;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240609,
                "title": "313-space-96-61-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nThe idea of this problem is similar to the Ugly Number II problem. We start with the smallest super ugly number, which is 1. Then, we generate each subsequent super ugly number by multiplying each prime number in the array with the previously generated super ugly numbers, and choosing the smallest one.\\n\\nWe can maintain a list of indices, one for each prime number, indicating the index of the last super ugly number that was multiplied by that prime number. We use these indices to avoid generating duplicates.\\n\\nAlgorithm:\\n\\n1. Initialize a list dp of size n to store the first n super ugly numbers.\\n2. Initialize a list idx of size k, where k is the length of primes, to store the index of the last super ugly number that was multiplied by each prime number. Initialize each element of idx to 0.\\n3. Initialize a list nums of size k to store the product of each prime number with the previously generated super ugly numbers. Initialize each element of nums to the corresponding prime number.\\n4, Initialize a variable i to 1, representing the index of the next super ugly number to be generated.\\n5. While i < n:\\na. Generate the ith super ugly number by choosing the minimum number in nums, and add it to dp.\\nb. For each j from 0 to k-1, if nums[j] is equal to the ith super ugly number, increment idx[j] by 1 and update nums[j] to be primes[j] times dp[idx[j]].\\nc. Increment i by 1.\\n6. Return the last element of dp.\\n\\nTime Complexity: O(nk), where n is the input integer and k is the length of the primes array.\\n\\nSpace Complexity: O(n+k), where n is the input integer and k is the length of the primes array.\\n\\n# Complexity\\n- Time complexity:\\n65.62%\\n\\n- Space complexity:\\n96.61%\\n\\n# Code\\n```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        # create a list to store the super ugly numbers, initialize with 1\\n        super_ugly = [1]\\n        # create a list to store the indices for each prime number\\n        idx = [0] * len(primes)\\n        # create a list to store the product of prime numbers with their corresponding indices\\n        # this will be used to find the next super ugly number\\n        prod = [p for p in primes]\\n        \\n        # loop until we find the nth super ugly number\\n        while len(super_ugly) < n:\\n            # find the minimum value in prod, which will be the next super ugly number\\n            next_ugly = min(prod)\\n            # append it to the list of super ugly numbers\\n            super_ugly.append(next_ugly)\\n            \\n            # update the index for each prime number whose product is equal to next_ugly\\n            for i in range(len(primes)):\\n                if next_ugly == prod[i]:\\n                    idx[i] += 1\\n                    prod[i] = primes[i] * super_ugly[idx[i]]\\n        \\n        # return the last element in the list of super ugly numbers, which is the nth super ugly number\\n        return super_ugly[-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        # create a list to store the super ugly numbers, initialize with 1\\n        super_ugly = [1]\\n        # create a list to store the indices for each prime number\\n        idx = [0] * len(primes)\\n        # create a list to store the product of prime numbers with their corresponding indices\\n        # this will be used to find the next super ugly number\\n        prod = [p for p in primes]\\n        \\n        # loop until we find the nth super ugly number\\n        while len(super_ugly) < n:\\n            # find the minimum value in prod, which will be the next super ugly number\\n            next_ugly = min(prod)\\n            # append it to the list of super ugly numbers\\n            super_ugly.append(next_ugly)\\n            \\n            # update the index for each prime number whose product is equal to next_ugly\\n            for i in range(len(primes)):\\n                if next_ugly == prod[i]:\\n                    idx[i] += 1\\n                    prod[i] = primes[i] * super_ugly[idx[i]]\\n        \\n        # return the last element in the list of super ugly numbers, which is the nth super ugly number\\n        return super_ugly[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582401,
                "title": "c-priority-queue-nlogk",
                "content": "```\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>nums(n);\\n        vector<int>indices(primes.size()); // index of the prime number inside nums array\\n        nums[0] = 1;\\n\\t\\t// first item is value of ugly number, second item is identity of the prime\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>>pq;\\n        for(int i=0; i<primes.size(); ++i)  pq.emplace(primes[i], i);\\n        for(int i=1; i<n; ){\\n            auto [val, id] = pq.top();\\n            pq.pop();\\n            if(val != nums[i-1])    nums[i++] = val; // avoid duplicate\\n            if(INT_MAX/primes[id]>nums[indices[id]+1]) // prevent overflow\\n                pq.emplace(nums[++indices[id]] * primes[id], id);\\n        }\\n        return nums.back();\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>nums(n);\\n        vector<int>indices(primes.size()); // index of the prime number inside nums array\\n        nums[0] = 1;\\n\\t\\t// first item is value of ugly number, second item is identity of the prime\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>>pq;\\n        for(int i=0; i<primes.size(); ++i)  pq.emplace(primes[i], i);\\n        for(int i=1; i<n; ){\\n            auto [val, id] = pq.top();\\n            pq.pop();\\n            if(val != nums[i-1])    nums[i++] = val; // avoid duplicate\\n            if(INT_MAX/primes[id]>nums[indices[id]+1]) // prevent overflow\\n                pq.emplace(nums[++indices[id]] * primes[id], id);\\n        }\\n        return nums.back();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1441519,
                "title": "clean-python-solution",
                "content": "```python\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        p = [0]*len(primes) #p[i] stores the index of ugly number in ans that not yet times primes[i] yet\\n        ans = [1]\\n        h = []\\n        \\n        for i in xrange(len(primes)):\\n            heapq.heappush(h, (primes[i]*ans[p[i]], i))\\n            \\n        for _ in xrange(n-1):\\n            curr = h[0][0]\\n            ans.append(curr)\\n            \\n            while h and h[0][0]==curr:\\n                i = h[0][1]\\n                heapq.heappop(h)\\n                p[i] += 1\\n                heapq.heappush(h, (primes[i]*ans[p[i]], i))\\n        \\n        return ans[-1]\\n\"\"\"\\nRelated Problems:\\nUgly Number, Ugly Number II\\nSuper Ugly Number\\nFind K Pairs with Smallest Sums from two arrays\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        p = [0]*len(primes) #p[i] stores the index of ugly number in ans that not yet times primes[i] yet\\n        ans = [1]\\n        h = []\\n        \\n        for i in xrange(len(primes)):\\n            heapq.heappush(h, (primes[i]*ans[p[i]], i))\\n            \\n        for _ in xrange(n-1):\\n            curr = h[0][0]\\n            ans.append(curr)\\n            \\n            while h and h[0][0]==curr:\\n                i = h[0][1]\\n                heapq.heappop(h)\\n                p[i] += 1\\n                heapq.heappush(h, (primes[i]*ans[p[i]], i))\\n        \\n        return ans[-1]\\n\"\"\"\\nRelated Problems:\\nUgly Number, Ugly Number II\\nSuper Ugly Number\\nFind K Pairs with Smallest Sums from two arrays\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807024,
                "title": "scala-lazylist",
                "content": "```\\nimport scala.collection.SortedSet\\n\\nobject Solution {\\n  def nthSuperUglyNumber(n: Int, primes: Array[Int]): Int = {\\n    def f(ugly: SortedSet[Long]): LazyList[Long] = {\\n      ugly.head #:: f(ugly.tail ++ primes.map(_ * ugly.head))\\n    }\\n    f(SortedSet(1))(n - 1).toInt\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.SortedSet\\n\\nobject Solution {\\n  def nthSuperUglyNumber(n: Int, primes: Array[Int]): Int = {\\n    def f(ugly: SortedSet[Long]): LazyList[Long] = {\\n      ugly.head #:: f(ugly.tail ++ primes.map(_ * ugly.head))\\n    }\\n    f(SortedSet(1))(n - 1).toInt\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 76295,
                "title": "c-o-n-2k-o-n-k-o-n-k-logk-solutions",
                "content": "**Time:** O(n*2k), 36ms.\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>dp(n);\\n        dp[0] = 1;\\n        vector<int>p(primes.size());\\n        for(int i = 1; i < n; i++){\\n            dp[i] = INT_MAX;\\n            for(int j = 0; j < p.size(); j++) dp[i] = min(dp[i], dp[p[j]] * primes[j]);\\n            for(int j = 0; j < p.size(); j++) if(dp[p[j]] * primes[j] == dp[i]) p[j]++;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\\n***\\nImprove from 2 inner loops to one loop, idea from this [post](https://discuss.leetcode.com/topic/34841/java-three-methods-23ms-36-ms-58ms-with-heap-performance-explained).\\n**Time:** O(nk), 23ms, beats 97.16%\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>dp(n);\\n        vector<int>p(primes.size());\\n        vector<int>val(primes.size());\\n        int next = 1;\\n        for(int i = 0; i < n; i++){\\n            dp[i] = next;\\n            next = INT_MAX;\\n            for(int j = 0; j < val.size(); j++){\\n                if(dp[i] >= val[j]) val[j] = dp[p[j]++] * primes[j];\\n                next = min(next, val[j]);\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\\n***\\nAlso, I wrote the last `heap` C++ version from the same post, but I think its time complexity is in worst case O(nklogk) rather than O(nlogk), which is actually slower than above solution.\\n**Time:** O(nklogk), 65ms. \\n```\\nstruct triple{\\n    int val;\\n    int prime;\\n    int p;\\n    triple(int x, int y, int z):val(x), prime(y), p(z){};\\n};\\n\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>dp(n);\\n        dp[0] = 1;\\n        auto cmp = [](triple* t1, triple* t2){ return t1->val > t2->val; };\\n        priority_queue<triple*, vector<triple*>, decltype(cmp)>pq(cmp);\\n        for(int i = 0; i < primes.size(); i++) pq.push(new triple(primes[i], primes[i], 1));\\n        for(int i = 1; i < n; i++){\\n            dp[i] = pq.top()->val;\\n            while(pq.top()->val == dp[i]){\\n                triple* t = pq.top();\\n                pq.pop();\\n                pq.push(new triple(t->prime * dp[t->p], t->prime, t->p + 1));\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>dp(n);\\n        dp[0] = 1;\\n        vector<int>p(primes.size());\\n        for(int i = 1; i < n; i++){\\n            dp[i] = INT_MAX;\\n            for(int j = 0; j < p.size(); j++) dp[i] = min(dp[i], dp[p[j]] * primes[j]);\\n            for(int j = 0; j < p.size(); j++) if(dp[p[j]] * primes[j] == dp[i]) p[j]++;\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>dp(n);\\n        vector<int>p(primes.size());\\n        vector<int>val(primes.size());\\n        int next = 1;\\n        for(int i = 0; i < n; i++){\\n            dp[i] = next;\\n            next = INT_MAX;\\n            for(int j = 0; j < val.size(); j++){\\n                if(dp[i] >= val[j]) val[j] = dp[p[j]++] * primes[j];\\n                next = min(next, val[j]);\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\n```\\nstruct triple{\\n    int val;\\n    int prime;\\n    int p;\\n    triple(int x, int y, int z):val(x), prime(y), p(z){};\\n};\\n\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>dp(n);\\n        dp[0] = 1;\\n        auto cmp = [](triple* t1, triple* t2){ return t1->val > t2->val; };\\n        priority_queue<triple*, vector<triple*>, decltype(cmp)>pq(cmp);\\n        for(int i = 0; i < primes.size(); i++) pq.push(new triple(primes[i], primes[i], 1));\\n        for(int i = 1; i < n; i++){\\n            dp[i] = pq.top()->val;\\n            while(pq.top()->val == dp[i]){\\n                triple* t = pq.top();\\n                pq.pop();\\n                pq.push(new triple(t->prime * dp[t->p], t->prime, t->p + 1));\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76303,
                "title": "python-beat-93-68",
                "content": "    class Solution(object):\\n        def nthSuperUglyNumber(self, n, primes):\\n            \"\"\"\\n            :type n: int\\n            :type primes: List[int]\\n            :rtype: int\\n            \"\"\"\\n            nums=[1]*len(primes)\\n            idx=[0]*len(primes)\\n            best=[1]\\n            cur=1\\n            for i in xrange(n-1):\\n                for j in xrange(len(idx)):\\n                    if nums[j]==cur:\\n                        nums[j]=best[idx[j]]*primes[j]\\n                        idx[j]+=1\\n                cur=min(nums)\\n                best.append(cur)\\n            return best[-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def nthSuperUglyNumber(self, n, primes):\\n            \"\"\"\\n            :type n: int\\n            :type primes: List[int]\\n            :rtype: int\\n            \"\"\"\\n            nums=[1]*len(primes)\\n            idx=[0]*len(primes)\\n            best=[1]\\n            cur=1\\n            for i in xrange(n-1):\\n                for j in xrange(len(idx)):\\n                    if nums[j]==cur:\\n                        nums[j]=best[idx[j]]*primes[j]\\n                        idx[j]+=1\\n                cur=min(nums)\\n                best.append(cur)\\n            return best[-1]",
                "codeTag": "Java"
            },
            {
                "id": 1738931,
                "title": "java-easiest-solution",
                "content": "Ugly numbers ii--->[https://leetcode.com/problems/ugly-number-ii/discuss/1738926/Java-easiest-solution](http://)\\nThe only difference is we here are using factors as given in array.\\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[]dp=new int[n];\\n        dp[0]=1;\\n        int[]index=new int[primes.length];\\n        for(int i=1;i<n;i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=0;j<primes.length;j++){\\n                min=Math.min(min,primes[j]*dp[index[j]]);\\n            }\\n            dp[i]=min;\\n            for(int j=0;j<primes.length;j++){\\n                if(min==primes[j]*dp[index[j]])index[j]++;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n\\nAlso adding an optimized solution where we are storing next values of all factors so that we dont have to calculate them again and again\\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[]dp=new int[n];\\n        int[]index=new int[primes.length];\\n        int[]val=new int[primes.length];\\n        Arrays.fill(val,1);\\n        int next=1;\\n        for(int i=0;i<n;i++){\\n            dp[i]=next;\\n            next=Integer.MAX_VALUE;\\n            for(int j=0;j<primes.length;j++){\\n                if(dp[i]==val[j])val[j]=dp[index[j]++]*primes[j];\\n                next=Math.min(next,val[j]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[]dp=new int[n];\\n        dp[0]=1;\\n        int[]index=new int[primes.length];\\n        for(int i=1;i<n;i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=0;j<primes.length;j++){\\n                min=Math.min(min,primes[j]*dp[index[j]]);\\n            }\\n            dp[i]=min;\\n            for(int j=0;j<primes.length;j++){\\n                if(min==primes[j]*dp[index[j]])index[j]++;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[]dp=new int[n];\\n        int[]index=new int[primes.length];\\n        int[]val=new int[primes.length];\\n        Arrays.fill(val,1);\\n        int next=1;\\n        for(int i=0;i<n;i++){\\n            dp[i]=next;\\n            next=Integer.MAX_VALUE;\\n            for(int j=0;j<primes.length;j++){\\n                if(dp[i]==val[j])val[j]=dp[index[j]++]*primes[j];\\n                next=Math.min(next,val[j]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635851,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        \\n        if (primes.length == 0 || n == 0)\\n            return 0;\\n        \\n        int[] uglies = new int[n];\\n        int[] counters = new int[primes.length];\\n        \\n        uglies[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            int nextMin = Integer.MAX_VALUE;\\n            \\n            // loop through the primes and find the next smallest one\\n            for (int j = 0; j < primes.length; j++)\\n                // we found a smaller value -- also don\\'t add duplicates\\n                if (nextMin > uglies[counters[j]] * primes[j])\\n                    nextMin = uglies[counters[j]] * primes[j];\\n            \\n            uglies[i] = nextMin;\\n            \\n            // advance all matching counters to avoid duplicates\\n            for (int j = 0; j < primes.length; j++)\\n                if (uglies[counters[j]] * primes[j] == nextMin)\\n                    counters[j]++;\\n        }\\n        \\n        return uglies[n - 1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        \\n        if (primes.length == 0 || n == 0)\\n            return 0;\\n        \\n        int[] uglies = new int[n];\\n        int[] counters = new int[primes.length];\\n        \\n        uglies[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            int nextMin = Integer.MAX_VALUE;\\n            \\n            // loop through the primes and find the next smallest one\\n            for (int j = 0; j < primes.length; j++)\\n                // we found a smaller value -- also don\\'t add duplicates\\n                if (nextMin > uglies[counters[j]] * primes[j])\\n                    nextMin = uglies[counters[j]] * primes[j];\\n            \\n            uglies[i] = nextMin;\\n            \\n            // advance all matching counters to avoid duplicates\\n            for (int j = 0; j < primes.length; j++)\\n                if (uglies[counters[j]] * primes[j] == nextMin)\\n                    counters[j]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 329498,
                "title": "heavily-commented-javascript-bottom-up-dp-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[]} primes\\n * @return {number}\\n */\\nvar nthSuperUglyNumber = function(n, primes) {\\n    // General idea is to build up an array with super ugly numbers till we reach n-1\\n    // So we will iterate multiples of [primes] and record them.\\n    // Let\\'s say primes is [2,3,5] -\\n    // If we just store 2,3,5 - 4,6,10 - 6,9,15 etc we\\'d be going out of order\\n    // So we need to increase the indeces for [primes] more wisely.\\n    \\n    // we record our prime indeces here in an array that starts out as zeroes\\n    // e.g [2,1,0] would imply that we used the first prime twice and second prime once\\n    // and the 3rd prime is yet unused. For 2,3,5 that means we\\'d have recorded\\n    // [2,3,4] \\n    \\n    let indeces = [];\\n    let currents = [];\\n    let i, l;\\n    // fill up our indeces array with zeroes to start\\n    for (i = 0, l = primes.length; i < l; i++) {\\n        indeces[i] = 0;\\n    }\\n    let out = [1]; // we will record or prime multiples here\\n    \\n    while (!out[n-1]) { \\n        // simply calculate the next multiple of all the primes\\n        for (i = 0, l = primes.length; i < l; i++) {\\n            currents[i] = out[indeces[i]] * primes[i]; \\n            // so in the case of 2,3,5 , currents would come out as [2,3,5] first round.\\n            // Then we use 2 and increase the index of that prime. Next round it would calculate to [4,3,5], then use 3, then calculate to [4,6,5] etc\\n        }\\n        \\n        // select the lowest one next so we stay in order\\n        let next = Math.min(...currents);\\n        out.push(next);\\n        \\n        // and for that prime we increase the index so next round we find the next multiple of that prime\\n        for (i = 0, l = primes.length; i < l; i++) {\\n            if (next === out[indeces[i]] * primes[i]) {\\n                indeces[i] = indeces[i] + 1;\\n            }\\n        }\\n    }\\n    \\n    return out[n-1];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} primes\\n * @return {number}\\n */\\nvar nthSuperUglyNumber = function(n, primes) {\\n    // General idea is to build up an array with super ugly numbers till we reach n-1\\n    // So we will iterate multiples of [primes] and record them.\\n    // Let\\'s say primes is [2,3,5] -\\n    // If we just store 2,3,5 - 4,6,10 - 6,9,15 etc we\\'d be going out of order\\n    // So we need to increase the indeces for [primes] more wisely.\\n    \\n    // we record our prime indeces here in an array that starts out as zeroes\\n    // e.g [2,1,0] would imply that we used the first prime twice and second prime once\\n    // and the 3rd prime is yet unused. For 2,3,5 that means we\\'d have recorded\\n    // [2,3,4] \\n    \\n    let indeces = [];\\n    let currents = [];\\n    let i, l;\\n    // fill up our indeces array with zeroes to start\\n    for (i = 0, l = primes.length; i < l; i++) {\\n        indeces[i] = 0;\\n    }\\n    let out = [1]; // we will record or prime multiples here\\n    \\n    while (!out[n-1]) { \\n        // simply calculate the next multiple of all the primes\\n        for (i = 0, l = primes.length; i < l; i++) {\\n            currents[i] = out[indeces[i]] * primes[i]; \\n            // so in the case of 2,3,5 , currents would come out as [2,3,5] first round.\\n            // Then we use 2 and increase the index of that prime. Next round it would calculate to [4,3,5], then use 3, then calculate to [4,6,5] etc\\n        }\\n        \\n        // select the lowest one next so we stay in order\\n        let next = Math.min(...currents);\\n        out.push(next);\\n        \\n        // and for that prime we increase the index so next round we find the next multiple of that prime\\n        for (i = 0, l = primes.length; i < l; i++) {\\n            if (next === out[indeces[i]] * primes[i]) {\\n                indeces[i] = indeces[i] + 1;\\n            }\\n        }\\n    }\\n    \\n    return out[n-1];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 212084,
                "title": "python-priority-queue",
                "content": "1. The idea is to use a priority queue to keep track of the ```smallest``` ugly number. \\n2. For the next ugly generator, the priority queue saves the first ```index``` of the ugly number that haven\\'t been multiplied by the ```prime```. \\n\\n```\\nimport heapq\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not primes:\\n            return 0\\n        \\n        ugly_number = [1 for _ in xrange(n)]\\n        hq = [(primes[i], 1, primes[i]) for i in xrange(len(primes))]\\n        heapq.heapify(hq)\\n        \\n        for i in xrange(1, n):\\n            ugly_number[i] = hq[0][0]\\n            while ugly_number[i] == hq[0][0]:\\n                value, idx, prime = heapq.heappop(hq)\\n                heapq.heappush(hq, (ugly_number[idx] * prime, idx + 1, prime))\\n        \\n        return ugly_number[-1]        \\n        \\n```",
                "solutionTags": [],
                "code": "```smallest```\n```index```\n```prime```\n```\\nimport heapq\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not primes:\\n            return 0\\n        \\n        ugly_number = [1 for _ in xrange(n)]\\n        hq = [(primes[i], 1, primes[i]) for i in xrange(len(primes))]\\n        heapq.heapify(hq)\\n        \\n        for i in xrange(1, n):\\n            ugly_number[i] = hq[0][0]\\n            while ugly_number[i] == hq[0][0]:\\n                value, idx, prime = heapq.heappop(hq)\\n                heapq.heappush(hq, (ugly_number[idx] * prime, idx + 1, prime))\\n        \\n        return ugly_number[-1]        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 76328,
                "title": "very-simple-and-clean-java-code",
                "content": "    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[] a = new int[n];\\n        int k = primes.length;\\n        int[] p = new int[k];\\n        a[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < k; j++) {\\n                while (primes[j] * a[p[j]] <= a[i - 1]) {\\n                    p[j]++;\\n                }\\n            }\\n            a[i] = Integer.MAX_VALUE;\\n            for (int j = 0; j < k; j++) {\\n                a[i] = Math.min(a[i], primes[j] * a[p[j]]);\\n            }\\n        }\\n        return a[n - 1];\\n    }",
                "solutionTags": [],
                "code": "    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[] a = new int[n];\\n        int k = primes.length;\\n        int[] p = new int[k];\\n        a[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < k; j++) {\\n                while (primes[j] * a[p[j]] <= a[i - 1]) {\\n                    p[j]++;\\n                }\\n            }\\n            a[i] = Integer.MAX_VALUE;\\n            for (int j = 0; j < k; j++) {\\n                a[i] = Math.min(a[i], primes[j] * a[p[j]]);\\n            }\\n        }\\n        return a[n - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2454068,
                "title": "cpp-solution-beginner-s-friendly",
                "content": "Please Upvote The solution-\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> vec(n,0);\\n        vec[0]=1;\\n        int total_primes=primes.size();\\n        vector<int> pointers(total_primes,0);\\n        for(int i=1;i<n;i++){\\n            long long mn=INT_MAX;\\n            for(int j=0;j<total_primes;j++){\\n                mn=min(mn,(long long)primes[j]*(long long)vec[pointers[j]]);\\n                \\n            }\\n            vec[i]=mn;\\n            for(int j=0;j<total_primes;j++){\\n                if(mn == (long long)primes[j] * (long long)vec[pointers[j]])\\n                {\\n                    pointers[j]++;\\n                }\\n            }\\n        }\\n        return vec[n-1];\\n    }\\n};\\n \\n```\\nHappy Coding :-)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> vec(n,0);\\n        vec[0]=1;\\n        int total_primes=primes.size();\\n        vector<int> pointers(total_primes,0);\\n        for(int i=1;i<n;i++){\\n            long long mn=INT_MAX;\\n            for(int j=0;j<total_primes;j++){\\n                mn=min(mn,(long long)primes[j]*(long long)vec[pointers[j]]);\\n                \\n            }\\n            vec[i]=mn;\\n            for(int j=0;j<total_primes;j++){\\n                if(mn == (long long)primes[j] * (long long)vec[pointers[j]])\\n                {\\n                    pointers[j]++;\\n                }\\n            }\\n        }\\n        return vec[n-1];\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682459,
                "title": "dp-beats-87-with-explanation-java",
                "content": "/this question is same as ugly number 2 the only diffrence is we are given an array of\\nn length instead of calcultaing prime factor of 2 , 3 , 5  and giving the nth ugly number in output.\\nThe output is same in both cases to give nth integer\\nSo we apply the same trick as applied in ugly number 2 we use pointers as used in last question\\nbut it will be hectic  task  to assign a diffrent pointer to each number given in array.\\nso what we will do is that we\\'ll create an array of length n and fill it with 1 initially\\n(as all the pointer are pointing to 1 initially ) and we use them to store  the \\ncurrent position at which pointer is pointing. and then update the pointer we recently used. \\n THATS\\'all.\\n** Strongly recommend you to do ugly number 2 (leetcode 264) first for better understanding \\nof this question.**\\n**Discuss link for previos question https://leetcode.com/problems/ugly-number-ii/discuss/1682470/java-oror-with-comments**\\n*/\\n\\n\\n```\\nclass Solution {\\n\\tpublic int nthSuperUglyNumber(int n, int[] primes) {\\n\\t\\t\\n         int pointers[] = new int[primes.length];\\n\\n            Arrays.fill(pointers, 1);\\n\\n            int dp[] = new int[n + 1];\\n\\n            dp[1] = 1;\\n            for (int i = 2; i <= n; i++) {\\n                  int min = Integer.MAX_VALUE;\\n\\t\\t\\t\\t  //calculating result.\\n                  for (int j = 0; j < primes.length; j++) {\\n                        min = Math.min(min, primes[j] * dp[pointers[j]]);\\n                  }\\n                  dp[i] = min;\\n\\t\\t\\t\\t  //updating pointer\\n                  for (int j = 0; j < primes.length; j++) {\\n                        if (primes[j] * dp[pointers[j]] == min) {\\n                              pointers[j]++;\\n                        }\\n                  }\\n            }\\n\\n            return dp[n];\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int nthSuperUglyNumber(int n, int[] primes) {\\n\\t\\t\\n         int pointers[] = new int[primes.length];\\n\\n            Arrays.fill(pointers, 1);\\n\\n            int dp[] = new int[n + 1];\\n\\n            dp[1] = 1;\\n            for (int i = 2; i <= n; i++) {\\n                  int min = Integer.MAX_VALUE;\\n\\t\\t\\t\\t  //calculating result.\\n                  for (int j = 0; j < primes.length; j++) {\\n                        min = Math.min(min, primes[j] * dp[pointers[j]]);\\n                  }\\n                  dp[i] = min;\\n\\t\\t\\t\\t  //updating pointer\\n                  for (int j = 0; j < primes.length; j++) {\\n                        if (primes[j] * dp[pointers[j]] == min) {\\n                              pointers[j]++;\\n                        }\\n                  }\\n            }\\n\\n            return dp[n];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308730,
                "title": "c-68ms-solution",
                "content": "elmt[i] represents (i+1)th ugly number\\nptr[i] represents pointer ith prime factor. Think of this, lets assume we have found 7 using 7x1 and we don\\'t want 7x1 again so we increase the pointer of 7 by 1. Next time if we need a 7 to multiply , we will multiply with minimum number greater than 1. i.e our pointer will point to required element. 7x2 in this case.\\nFor example, [2,7,13,19]\\nEverytime we try to multiply 2,7,13,19 with previous some element to get new multiple in ascending order.\\nHere are all the multiples using prime factors:\\n```\\n2^0 7^0 13^0 19^0   = 1\\n2^1 7^0 13^0 19^0   = 2\\n2^2 7^0 13^0 19^0   = 4\\n2^0 7^1 13^0 19^0   = 7\\n2^3 7^0 13^0 19^0   = 8\\n2^0 7^0 13^1 19^0   = 13\\n2^1 7^1 13^0 19^0   = 14\\n.\\n.\\n.\\n\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if(n==1 ) return 1;\\n        \\n        vector<int> ptr(primes.size(),0);\\n        vector<int> elmt(n,0);\\n        elmt[0]=1;\\n        int t;        \\n        for(int i=1; i<n ; i++){\\n            int mini=INT_MAX;\\n            int idx=0;\\n            for(int j=0; j<primes.size(); j++){\\n                t=primes[j]*elmt[ptr[j]];\\n                if(t<mini){\\n                    mini=t;\\n                    idx=j;\\n                }\\n            }\\n            for(int j=0; j<primes.size(); j++){\\n                if(mini==primes[j]*elmt[ptr[j]]){\\n                    ptr[j]++;\\n                }\\n            }\\n            elmt[i]=mini;\\n        }\\n        return elmt[n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n2^0 7^0 13^0 19^0   = 1\\n2^1 7^0 13^0 19^0   = 2\\n2^2 7^0 13^0 19^0   = 4\\n2^0 7^1 13^0 19^0   = 7\\n2^3 7^0 13^0 19^0   = 8\\n2^0 7^0 13^1 19^0   = 13\\n2^1 7^1 13^0 19^0   = 14\\n.\\n.\\n.\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if(n==1 ) return 1;\\n        \\n        vector<int> ptr(primes.size(),0);\\n        vector<int> elmt(n,0);\\n        elmt[0]=1;\\n        int t;        \\n        for(int i=1; i<n ; i++){\\n            int mini=INT_MAX;\\n            int idx=0;\\n            for(int j=0; j<primes.size(); j++){\\n                t=primes[j]*elmt[ptr[j]];\\n                if(t<mini){\\n                    mini=t;\\n                    idx=j;\\n                }\\n            }\\n            for(int j=0; j<primes.size(); j++){\\n                if(mini==primes[j]*elmt[ptr[j]]){\\n                    ptr[j]++;\\n                }\\n            }\\n            elmt[i]=mini;\\n        }\\n        return elmt[n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140817,
                "title": "java-simple-short-concise-priority-queue-beginner",
                "content": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        PriorityQueue<Long> pq = new PriorityQueue<>();\\n        pq.add(1L);\\n        \\n        for(int prime : primes){\\n            pq.add(1L * prime);\\n        }\\n        \\n        long ans=-1L;\\n        \\n        while(n>0){\\n            long curr = pq.poll();\\n            if(curr!=ans){\\n                n--;\\n                for(int prime : primes){\\n                    pq.add(curr*prime);\\n                }\\n            }\\n            \\n            ans = curr;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        PriorityQueue<Long> pq = new PriorityQueue<>();\\n        pq.add(1L);\\n        \\n        for(int prime : primes){\\n            pq.add(1L * prime);\\n        }\\n        \\n        long ans=-1L;\\n        \\n        while(n>0){\\n            long curr = pq.poll();\\n            if(curr!=ans){\\n                n--;\\n                for(int prime : primes){\\n                    pq.add(curr*prime);\\n                }\\n            }\\n            \\n            ans = curr;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966532,
                "title": "python-straightforward-o-nklogk-time-o-n-space-solution",
                "content": "```\\nfrom heapq import *\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=[]\\n        heap=[]\\n        seen={1,}\\n        heappush(heap,1)\\n        \\n        for _ in range(n):\\n            curr_ugly=heappop(heap)\\n            nums.append(curr_ugly)\\n            for prime in primes:\\n                new_ugly=curr_ugly*prime\\n                if new_ugly not in seen:\\n                    seen.add(new_ugly)\\n                    heappush(heap,new_ugly)\\n        \\n        return nums[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import *\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=[]\\n        heap=[]\\n        seen={1,}\\n        heappush(heap,1)\\n        \\n        for _ in range(n):\\n            curr_ugly=heappop(heap)\\n            nums.append(curr_ugly)\\n            for prime in primes:\\n                new_ugly=curr_ugly*prime\\n                if new_ugly not in seen:\\n                    seen.add(new_ugly)\\n                    heappush(heap,new_ugly)\\n        \\n        return nums[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657288,
                "title": "easy-c-solution-o-n-k",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> cpr(primes.begin(),primes.end());\\n        vector<int> ind(primes.size(),0);\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<n;i++){\\n            long long int m=1e18;\\n            for(auto p:primes){\\n                m=min(m,(long long)p);\\n            }\\n            dp[i]=m;\\n            for(int j=0;j<primes.size();j++){\\n                if(m==primes[j]){\\n                    ind[j]++;\\n                    primes[j]=dp[ind[j]]*cpr[j];\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> cpr(primes.begin(),primes.end());\\n        vector<int> ind(primes.size(),0);\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<n;i++){\\n            long long int m=1e18;\\n            for(auto p:primes){\\n                m=min(m,(long long)p);\\n            }\\n            dp[i]=m;\\n            for(int j=0;j<primes.size();j++){\\n                if(m==primes[j]){\\n                    ind[j]++;\\n                    primes[j]=dp[ind[j]]*cpr[j];\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573736,
                "title": "99-c-solution",
                "content": "```\\n int i,j,k;\\n        vector<int>dp(n,0);\\n        dp[0]=1;\\n        k=p.size();\\n        vector<int>last(p.size(),0);\\n        vector<int>value(p.size(),0);\\n        for(i=0;i<k;i++)\\n        {\\n            value[i]=p[i];\\n        }\\n        int m;\\n        for(i=1;i<n;i++)\\n        {    \\n            m=INT_MAX;\\n            for(j=0;j<k;j++)\\n            {\\n                if(value[j]<m)\\n                {\\n                    m=value[j];\\n                }\\n            }\\n            \\n            dp[i]=m;\\n\\n            for(j=0;j<k;j++)\\n            {\\n                if(m==value[j])\\n                {\\n                    last[j]++;\\n                    value[j]=p[j]*dp[last[j]];\\n    \\n                }\\n            }\\n            \\n            \\n        }\\n\\n        return  dp[n-1];\\n        \\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n int i,j,k;\\n        vector<int>dp(n,0);\\n        dp[0]=1;\\n        k=p.size();\\n        vector<int>last(p.size(),0);\\n        vector<int>value(p.size(),0);\\n        for(i=0;i<k;i++)\\n        {\\n            value[i]=p[i];\\n        }\\n        int m;\\n        for(i=1;i<n;i++)\\n        {    \\n            m=INT_MAX;\\n            for(j=0;j<k;j++)\\n            {\\n                if(value[j]<m)\\n                {\\n                    m=value[j];\\n                }\\n            }\\n            \\n            dp[i]=m;\\n\\n            for(j=0;j<k;j++)\\n            {\\n                if(m==value[j])\\n                {\\n                    last[j]++;\\n                    value[j]=p[j]*dp[last[j]];\\n    \\n                }\\n            }\\n            \\n            \\n        }\\n\\n        return  dp[n-1];\\n        \\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 400386,
                "title": "easiest-to-understand-solution",
                "content": "Somehow I find the available solutions are not that straight forward to understand.\\nThis one is using heap. What it does is:\\n1. Maintain a heap for all generated ugly numbers.\\n2. Once at a time, pop the minimal number from the heap. (for n times)\\n3. For each new generated number, we push it into the heap if it has never show up. We use a set to make sure that the number in the heap is not duplicated.\\n\\nThis one is slow by the way. But it is easier to understand.\\nO(N log(N*k))\\n```\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        if n==1: return 1\\n        hp = [1] +  [i for i in primes]\\n        used = set(hp)\\n        heapq.heapify(hp)\\n        num = 1\\n        while n:\\n            n-=1\\n            num = heapq.heappop(hp)\\n            for p in primes:\\n                if num*p not in used:\\n                    heapq.heappush(hp, num*p)\\n                    used.add(num*p)\\n        return num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        if n==1: return 1\\n        hp = [1] +  [i for i in primes]\\n        used = set(hp)\\n        heapq.heapify(hp)\\n        num = 1\\n        while n:\\n            n-=1\\n            num = heapq.heappop(hp)\\n            for p in primes:\\n                if num*p not in used:\\n                    heapq.heappush(hp, num*p)\\n                    used.add(num*p)\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207112,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>ugly(n,0);\\n        ugly[0]=1;\\n        sort(primes.begin(),primes.end());\\n        vector<int>ptr(primes.size(),0);\\n        for(int i=1;i<n;i++){\\n            int mn=INT_MAX;\\n            for(int j=0;j<primes.size();j++)\\n                mn=min(mn,primes[j]*ugly[ptr[j]]);\\n            ugly[i]=mn;\\n            for(int j=0;j<primes.size();j++){\\n                if(mn%primes[j]==0)\\n                    ptr[j]++;\\n            }\\n        }\\n        return ugly[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>ugly(n,0);\\n        ugly[0]=1;\\n        sort(primes.begin(),primes.end());\\n        vector<int>ptr(primes.size(),0);\\n        for(int i=1;i<n;i++){\\n            int mn=INT_MAX;\\n            for(int j=0;j<primes.size();j++)\\n                mn=min(mn,primes[j]*ugly[ptr[j]]);\\n            ugly[i]=mn;\\n            for(int j=0;j<primes.size();j++){\\n                if(mn%primes[j]==0)\\n                    ptr[j]++;\\n            }\\n        }\\n        return ugly[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76333,
                "title": "simple-cpp-code-with-own-explanation",
                "content": "    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        // The same idea as Ugly number II. Use primes and priveious ugly number to calcute. In this question, there are vector of pramaters for calculation. So I need an array of idx, idx[i] mark for the last position I use that ith primes to caluate the ugly number.\\n        vector<int>ugly(n);\\n        vector<int>index(primes.size());\\n        ugly[0] = 1;\\n        for (int j = 1; j < n; j++) {\\n            int res = INT_MAX;\\n            for (int i = 0; i < primes.size(); i++) {\\n                res = min(res, primes[i] * ugly[index[i]]);\\n            }\\n            for (int i = 0; i < primes.size(); i++) {\\n                if (res == primes[i] * ugly[index[i]]) {\\n                    index[i]++;\\n                }\\n            }\\n            ugly[j] = res;\\n        }\\n        return ugly[n - 1];\\n    }",
                "solutionTags": [],
                "code": "    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        // The same idea as Ugly number II. Use primes and priveious ugly number to calcute. In this question, there are vector of pramaters for calculation. So I need an array of idx, idx[i] mark for the last position I use that ith primes to caluate the ugly number.\\n        vector<int>ugly(n);\\n        vector<int>index(primes.size());\\n        ugly[0] = 1;\\n        for (int j = 1; j < n; j++) {\\n            int res = INT_MAX;\\n            for (int i = 0; i < primes.size(); i++) {\\n                res = min(res, primes[i] * ugly[index[i]]);\\n            }\\n            for (int i = 0; i < primes.size(); i++) {\\n                if (res == primes[i] * ugly[index[i]]) {\\n                    index[i]++;\\n                }\\n            }\\n            ugly[j] = res;\\n        }\\n        return ugly[n - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 76384,
                "title": "my-priority-queue-based-c-code-276ms",
                "content": "The straightforward solution is to use a big heap (i.e. priority_queue in C++) to store all currently generated ugly numbers and keep track of  the minimum one. Everytime, we remove the minimum one and add the newly generated ugly numbers in the queue (i.e the minimum one X primes[i], for i=[0,K-1] and remove the duplicates). This will require roughly O(NK) space and O(Nlog(NK), worst case) time.\\nIt is very slow since there are many ordering information we didn't use in the above algorithm (e.g. min*prime[i]< min*prime[j], if i<j). So we should try to use such information to speed up our algorithm. Can we regroup the currently generated ugly number in a way that each group is in a ascending order and we only need to use a heap to find the min of the first elements of all the groups? \\n\\nOne option would be divide all the currently generated ugly numbers in K groups, each time, we remove the top (i.e. min) number from priority_queue, we put the newly generated ugly number top()*primes[i] to the i-th group so that the i-th group includes all the currently generated ugly numbers that are multiple of primes[i]. Of course, this will include some duplicates (e.g 6 will be in the group of 2 and also in the group of 3). Since in this way, all the groups are in the ascending order (i.e. Group[i][m] > Group[i][n], if m>n). So we only need to use a K-element heap to track the next minimum ugly number. So the time complexity goes down. However, the memory complexity is still O(NK). We will get  MLE error.\\n\\nCan we do better? One thing we notice is that for all elements in the i_th group has the format Ugly[m]*primes[i]. So we don't need to save all those elements but just Ugly[0..n-1]. The i_th group (i.e. multiple of primes[i]) has elements [Ugly[0] * primes[i], Ugly[1] * primes[i], ..., Ugly[m] * primes[i]]. We just need to track the index of Ugly (which indicates which Ugly element) should be used to generate the next minimum element in the i_th group, which will be push in the priority_queue. Now we reduce the memory complexity to O(N). But due to the duplicates issue, the time complexity could be O(NKlogK). Can we do further optimization? \\nThe below code has run time of 1020ms\\n\\n    class Solution {\\n    public:\\n        int nthSuperUglyNumber(int n, vector<int>& primes) { // assuming inputs are valid\\n            int K = primes.size(), res[n], lastMul[n] ={0}, i, curVal, curIdx; //lastMul is the indices of K groups   \\n            priority_queue<pair<int, int>> headHeap; // K-element heap to find the minimum of the minimum of K groups\\n            for(res[0]=-1, i=0; i<K;++i) // initialize the heap\\n                headHeap.push(make_pair(-primes[i], i)); // first the ugly number value (change to negative to get the minimum one), second is the index of ugly number queues, i.e. candidates[i]\\n    \\n            for(i=0;i<n;)  //generate the first n ugly number\\n            { // the elements in the priority_queue are negative to help us find the minimum\\n                curVal = headHeap.top().first;\\n                curIdx = headHeap.top().second; // group index of the current minum ugly number\\n                headHeap.pop();\\n                if(curVal!=res[i]) res[++i] = curVal; // if it is not a duplicate, the top one will the ++i_th ugly number\\n                headHeap.push(make_pair(res[++lastMul[curIdx]] * primes[curIdx], curIdx)); // generate the next minimum element of the curIdx_th group and push it in the heap\\n            }\\n            return -res[n-1];\\n        }\\n    };\\n\\n (Thanks for StefanPochmann's comments that inspired this optimization)\\nTo avoid duplicates, we can use extra memory (i.e.pIdx) to save the index of the maximum prime factor of each ugly number that treat each ugly number only as multiple of its maximum prime factor. For example 6 is treated only as multiple of 3 , not multiple of 2. So it can only be generated as 2 x 3, not 3x2. In that way, no duplicate will occur. The below version has N heap insert operations  and run time of 230ms.\\n\\n    class Solution {\\n    public:\\n        int nthSuperUglyNumber(int n, vector<int>& primes) {\\n            int K = primes.size(), res[n], pIdx[n], lastMul[n] ={}, i, curVal, curIdx;\\n    \\n            priority_queue<pair<int, int>> headHeap; // \\n            for(res[0]=-1, i=0; i<K;++i)   headHeap.push(make_pair(-primes[i], i)); // first the ugly number value (change to negative to get the minimum one), second is the index of ugly number queues, i.e. candidates[i]\\n    \\n            for(i=1;i<n;++i)\\n            {\\n                curVal = headHeap.top().first;\\n                curIdx = headHeap.top().second;\\n                headHeap.pop();\\n                res[i] = curVal; pIdx[i] = curIdx; // pIdx is the index of the maximum prime factor\\n                while(pIdx[++lastMul[curIdx]]>curIdx); // skip ugly numbers whose maximum factor index is larger than curIdx.\\n                headHeap.push(make_pair(res[lastMul[curIdx]] * primes[curIdx], curIdx));\\n            }\\n            return -res[n-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int nthSuperUglyNumber(int n, vector<int>& primes) { // assuming inputs are valid\\n            int K = primes.size(), res[n], lastMul[n] ={0}",
                "codeTag": "Java"
            },
            {
                "id": 76388,
                "title": "o-n-k-java-and-c-solution",
                "content": "I would just like to thank lixx2100 for point out a very good point that after we find the min we can just update all necessary pointers in one more pass. \\n\\nC code:\\n\\n    #define MIN(a,b)  (a) ^ (((b) ^ (a)) & -((b) < (a)))\\n    \\n    int nthSuperUglyNumber(int n, int* primes, int primesSize) {\\n        int* indexes = (int*) calloc(primesSize, sizeof(int));\\n        int* uglyNums = (int*) malloc(sizeof(int)*n);\\n        \\n        *uglyNums = 1;\\n        \\n        for(int i = 1; i < n; ++i){\\n            int min = 0x7FFFFFFF;\\n            \\n            for(int j = 0; j < primesSize; ++j)\\n                min = MIN(min, uglyNums[indexes[j]]*primes[j]);\\n                \\n            uglyNums[i] = min;\\n            for(int j = 0; j < primesSize; ++j)\\n                if(uglyNums[indexes[j]]*primes[j] == min)\\n                    ++indexes[j];\\n        }\\n        return uglyNums[n-1];\\n    }\\n\\n\\nJava Code:\\n\\n    public class Solution {\\n        public int nthSuperUglyNumber(int n, int[] primes) {\\n    \\n            int[] indexs = new int[primes.length];\\n            int[] uglyNums = new int[n];\\n            uglyNums[0] = 1;\\n            \\n            for(int i = 1; i < n; ++i){\\n                int min = uglyNums[indexs[0]]*primes[0];\\n                \\n                for(int j = 1; j < primes.length; ++j){\\n                    int temp = uglyNums[indexs[j]]*primes[j];\\n                    \\n                    if(min > temp & temp > 0)\\n                        min = temp;\\n                }\\n                uglyNums[i] = min;\\n                for(int j = 0; j < primes.length; ++j){\\n                    if(uglyNums[indexs[j]]*primes[j] == min)\\n                        ++indexs[j];\\n                }\\n            }\\n            return uglyNums[n-1];\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int nthSuperUglyNumber(int n, int[] primes) {\\n    \\n            int[] indexs = new int[primes.length];\\n            int[] uglyNums = new int[n];\\n            uglyNums[0] = 1;\\n            \\n            for(int i = 1; i < n; ++i){\\n                int min = uglyNums[indexs[0]]*primes[0];\\n                \\n                for(int j = 1; j < primes.length; ++j){\\n                    int temp = uglyNums[indexs[j]]*primes[j];\\n                    \\n                    if(min > temp & temp > 0)\\n                        min = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3900210,
                "title": "c-detailed-explanation-beats-98-easy-approach",
                "content": "# Intuition\\nThe problem requires generating the nth super ugly number, which is a positive integer that is a multiple of a given set of prime numbers. We need to find an efficient approach to generate these super ugly numbers in ascending order.\\n\\n# Approach\\nTo solve this problem, we use a dynamic programming approach. We maintain an array `uglyNumbers` to store the generated super ugly numbers. We initialize it with the first two numbers, 0 and 1. We also create a vector of pairs, `primeIndices`, to keep track of the prime factors and their current indices.\\n\\nWe iterate from `i = 2` up to `n`, where `n` is the desired index of the super ugly number to generate. For each `i`, we find the next smallest super ugly number among the multiples of the given prime factors using the `primeIndices` vector. We store this value in the `uglyNumbers` array.\\n\\nWe then update the indices in the `primeIndices` vector based on which prime factor was chosen to generate the current super ugly number.\\n\\nFinally, we return the nth super ugly number stored in the `uglyNumbers` array.\\n\\n# Complexity\\n- Time complexity: $$O(n * k)$$, where n is the index of the super ugly number to generate and k is the number of prime factors.\\n- Space complexity: $$O(n)$$, where n is the index of the super ugly number to generate.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        long long uglyNumbers[n + 1];  // Array to store super ugly numbers\\n        uglyNumbers[0] = 0;  // Not mandatory, just for clarity\\n        uglyNumbers[1] = 1;  // The first super ugly number is 1\\n\\n        // Create a vector of pairs to store prime factors and their indices\\n        vector<pair<int, int>> primeIndices;\\n        for (int i = 0; i < primes.size(); i++) {\\n            primeIndices.push_back(make_pair(primes[i], 1));\\n        }\\n\\n        for (int i = 2; i <= n; i++) {\\n            long long nextUgly = LLONG_MAX;  // Initialize nextUgly to a large value\\n            for (int j = 0; j < primes.size(); j++) {\\n                // Find the next smallest super ugly number among primes\\' multiples\\n                nextUgly = min(nextUgly, uglyNumbers[primeIndices[j].second] * (long long)primeIndices[j].first);\\n            }\\n            uglyNumbers[i] = nextUgly;  // Store the next super ugly number\\n            \\n            // Update the indices based on which prime factor was chosen\\n            for (int j = 0; j < primes.size(); j++) {\\n                if (nextUgly == uglyNumbers[primeIndices[j].second] * (long long)primeIndices[j].first) {\\n                    primeIndices[j].second++;\\n                }\\n            }\\n        }\\n        \\n        return uglyNumbers[n];  // Return the nth super ugly number\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        long long uglyNumbers[n + 1];  // Array to store super ugly numbers\\n        uglyNumbers[0] = 0;  // Not mandatory, just for clarity\\n        uglyNumbers[1] = 1;  // The first super ugly number is 1\\n\\n        // Create a vector of pairs to store prime factors and their indices\\n        vector<pair<int, int>> primeIndices;\\n        for (int i = 0; i < primes.size(); i++) {\\n            primeIndices.push_back(make_pair(primes[i], 1));\\n        }\\n\\n        for (int i = 2; i <= n; i++) {\\n            long long nextUgly = LLONG_MAX;  // Initialize nextUgly to a large value\\n            for (int j = 0; j < primes.size(); j++) {\\n                // Find the next smallest super ugly number among primes\\' multiples\\n                nextUgly = min(nextUgly, uglyNumbers[primeIndices[j].second] * (long long)primeIndices[j].first);\\n            }\\n            uglyNumbers[i] = nextUgly;  // Store the next super ugly number\\n            \\n            // Update the indices based on which prime factor was chosen\\n            for (int j = 0; j < primes.size(); j++) {\\n                if (nextUgly == uglyNumbers[primeIndices[j].second] * (long long)primeIndices[j].first) {\\n                    primeIndices[j].second++;\\n                }\\n            }\\n        }\\n        \\n        return uglyNumbers[n];  // Return the nth super ugly number\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812768,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>arri(primes.size());\\n  vector<long>arrn(primes.size());\\n    vector<long>dp(n+1);\\n    dp[0]=1;\\n    for(int j=0;j<n;j++){\\n        long  mini=INT_MAX;\\n        for(int i=0;i<arri.size();i++){\\n            arrn[i]=dp[arri[i]]*primes[i];\\n            mini=min(mini,arrn[i]);\\n        }\\n      for(int i=0;i<arri.size();i++){\\n          if(mini==arrn[i]){\\n              dp[j+1]=arrn[i];\\n              arri[i]++;\\n          }\\n      }\\n  \\n    }\\n\\n  return dp[n-1]; \\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>arri(primes.size());\\n  vector<long>arrn(primes.size());\\n    vector<long>dp(n+1);\\n    dp[0]=1;\\n    for(int j=0;j<n;j++){\\n        long  mini=INT_MAX;\\n        for(int i=0;i<arri.size();i++){\\n            arrn[i]=dp[arri[i]]*primes[i];\\n            mini=min(mini,arrn[i]);\\n        }\\n      for(int i=0;i<arri.size();i++){\\n          if(mini==arrn[i]){\\n              dp[j+1]=arrn[i];\\n              arri[i]++;\\n          }\\n      }\\n  \\n    }\\n\\n  return dp[n-1]; \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363522,
                "title": "c-simple-c-code-90-time-similar-to-ugly-number-ii",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int m = primes.size();\\n        vector<int> value(m,0);\\n        vector<int> result(n+1,0);\\n        result[0] = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            long long val = INT_MAX;\\n            //vector<long long> store(m,0);\\n            for(int j = 0; j < m; j++)\\n            {\\n                long long ans = (long long)result[value[j]]*(long long)primes[j];\\n                //store[j] = ans;\\n                val = min(ans, val);\\n            }\\n            for(int j = 0; j < m; j++)\\n            {\\n                if((long long)result[value[j]]*(long long)primes[j] == val)\\n                    value[j]++;\\n            }\\n            result[i] = val;\\n        }\\n        return result[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int m = primes.size();\\n        vector<int> value(m,0);\\n        vector<int> result(n+1,0);\\n        result[0] = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            long long val = INT_MAX;\\n            //vector<long long> store(m,0);\\n            for(int j = 0; j < m; j++)\\n            {\\n                long long ans = (long long)result[value[j]]*(long long)primes[j];\\n                //store[j] = ans;\\n                val = min(ans, val);\\n            }\\n            for(int j = 0; j < m; j++)\\n            {\\n                if((long long)result[value[j]]*(long long)primes[j] == val)\\n                    value[j]++;\\n            }\\n            result[i] = val;\\n        }\\n        return result[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981581,
                "title": "c-heap-logic-explained",
                "content": "\\ttypedef pair<long long,pair<long long,long long>> ppi;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint nthSuperUglyNumber(int n, vector<int>& primes) {\\n\\t\\t\\tpriority_queue<ppi,vector<ppi>,greater<ppi>>minh; // min heap of pairs {values, prime No, index of dp}\\n\\t\\t\\tlong long dp[n];\\n\\t\\t\\tdp[0]=1;                                         // 1 is the first ugly number\\n\\t\\t\\tfor(auto &i:primes)\\n\\t\\t\\t{\\n\\t\\t\\t\\tminh.push({i,{i,0}});   // {value,{prime No,index}}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1;i<n;)\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto it = minh.top();   \\n\\t\\t\\t\\tminh.pop(); \\n\\t\\t\\t\\tlong long prime = it.second.first;    // current prime no. \\n\\t\\t\\t\\tlong long ind = it.second.second;     // index \\n\\t\\t\\t\\tlong long val = it.first;             // next minimum ugly number (prime no. * dp[ind])\\n\\t\\t\\t\\tif(dp[i-1] != val)dp[i++] = val;      // to not allow repeatation of same ugly number\\n\\t\\t\\t\\tind++;                                // incrementing the index \\n\\t\\t\\t\\tit.second.second = ind;           \\n\\t\\t\\t\\tit.first = prime*dp[ind];             // the updated value\\n\\t\\t\\t\\tminh.push(it);                        // inserting in heap after updating\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n-1];                           // returning nth ugly number\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint nthSuperUglyNumber(int n, vector<int>& primes) {\\n\\t\\t\\tpriority_queue<ppi,vector<ppi>,greater<ppi>>minh; // min heap of pairs {values, prime No, index of dp}",
                "codeTag": "Java"
            },
            {
                "id": 1874372,
                "title": "java-solution-fast-2-solutions",
                "content": "Same as Ugly Number II ([https://leetcode.com/problems/ugly-number-ii/](http://)) :\\ndifference is that there 2,3,5 are given as primes[]\\nhere array is given!\\nSolution of Ugly Number II ->\\n```\\npublic int dp[]; //global variable\\n    public int nthUglyNumber(int n) {\\n         dp=new int[n];\\n        int a=0,b=0,c=0;\\n        dp[0]=1;\\n        for(int i=1;i<n;i++) {\\n            int two=dp[a]*2;\\n            int three=dp[b]*3;\\n            int five=dp[c]*5;\\n            \\n            int min=Math.min(two,Math.min(three,five));\\n            \\n            if(min==two) a++;\\n            if(min==three) b++;\\n            if(min==five) c++;\\n            \\n            dp[i]=min;\\n        }\\n        return dp[n-1];\\n    }\\n```\\n\\nNow in this question two approaches are given first one is same is the discussed above and the second is optimisation\\nover first using PriorityQueue!\\n First Approach: Time-O(n*k) where k is no. of primes and n is the nth no. to be found\\n ```\\n public int nthSuperUglyNumber(int n, int[] primes) {\\n        int dp[]=new int[n];\\n        dp[0]=1;\\n        \\n        int indexes[]=new int[primes.length]; //indexes of different no. in prime\\n        for(int i=1;i<n;i++) {\\n            int min=dp[indexes[0]]*primes[0];\\n            for(int j=1;j<primes.length;j++) {\\n                if(min>dp[indexes[j]]*primes[j]) {\\n                    min=dp[indexes[j]]*primes[j];\\n                }\\n            }\\n            \\n            for(int j=0;j<primes.length;j++) {\\n                if(min==dp[indexes[j]]*primes[j])\\n                    indexes[j]++;       \\n            }\\n            \\n            dp[i]=min;\\n        }\\n        // System.out.println(Arrays.toString(dp));\\n        return dp[n-1];\\n    }\\n ```\\n \\n Second Approach: optimisation over the first one!\\n Time-O(n*log(k))\\n ```\\n class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        //OPTIMISED APPROACH USING PRIORITY QUEUE \\n        //above method\\'s optimisation\\n        int dp[]=new int[n];\\n        dp[0]=1;\\n        int i=1;\\n        \\n        \\n        Queue<Pair> pq=new PriorityQueue<>();\\n        //initising priority queue\\n        for(int j=0;j<primes.length;j++)\\n            pq.add(new Pair(0,primes[j],dp[0]*primes[j]));\\n        \\n        while(i<n) {\\n            Pair p=pq.remove();\\n            if(dp[i-1]!=p.value) {\\n                dp[i]=p.value;\\n                i++;\\n            }\\n            p.index++;\\n            p.value=dp[p.index]*p.prime;\\n            pq.add(p);\\n        }\\n        // System.out.println(Arrays.toString(dp));\\n        return dp[n-1];\\n    }\\n    \\n    public static class Pair implements Comparable<Pair>{\\n        int index;\\n        int prime;\\n        int value;\\n            \\n        Pair(int index,int prime,int value) {\\n            this.index=index;\\n            this.prime=prime;\\n            this.value=value;\\n        }\\n            \\n        public int compareTo(Pair second) {\\n            return this.value-second.value;\\n        }\\n    }\\n}\\n ```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int dp[]; //global variable\\n    public int nthUglyNumber(int n) {\\n         dp=new int[n];\\n        int a=0,b=0,c=0;\\n        dp[0]=1;\\n        for(int i=1;i<n;i++) {\\n            int two=dp[a]*2;\\n            int three=dp[b]*3;\\n            int five=dp[c]*5;\\n            \\n            int min=Math.min(two,Math.min(three,five));\\n            \\n            if(min==two) a++;\\n            if(min==three) b++;\\n            if(min==five) c++;\\n            \\n            dp[i]=min;\\n        }\\n        return dp[n-1];\\n    }\\n```\n```\\n public int nthSuperUglyNumber(int n, int[] primes) {\\n        int dp[]=new int[n];\\n        dp[0]=1;\\n        \\n        int indexes[]=new int[primes.length]; //indexes of different no. in prime\\n        for(int i=1;i<n;i++) {\\n            int min=dp[indexes[0]]*primes[0];\\n            for(int j=1;j<primes.length;j++) {\\n                if(min>dp[indexes[j]]*primes[j]) {\\n                    min=dp[indexes[j]]*primes[j];\\n                }\\n            }\\n            \\n            for(int j=0;j<primes.length;j++) {\\n                if(min==dp[indexes[j]]*primes[j])\\n                    indexes[j]++;       \\n            }\\n            \\n            dp[i]=min;\\n        }\\n        // System.out.println(Arrays.toString(dp));\\n        return dp[n-1];\\n    }\\n ```\n```\\n class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        //OPTIMISED APPROACH USING PRIORITY QUEUE \\n        //above method\\'s optimisation\\n        int dp[]=new int[n];\\n        dp[0]=1;\\n        int i=1;\\n        \\n        \\n        Queue<Pair> pq=new PriorityQueue<>();\\n        //initising priority queue\\n        for(int j=0;j<primes.length;j++)\\n            pq.add(new Pair(0,primes[j],dp[0]*primes[j]));\\n        \\n        while(i<n) {\\n            Pair p=pq.remove();\\n            if(dp[i-1]!=p.value) {\\n                dp[i]=p.value;\\n                i++;\\n            }\\n            p.index++;\\n            p.value=dp[p.index]*p.prime;\\n            pq.add(p);\\n        }\\n        // System.out.println(Arrays.toString(dp));\\n        return dp[n-1];\\n    }\\n    \\n    public static class Pair implements Comparable<Pair>{\\n        int index;\\n        int prime;\\n        int value;\\n            \\n        Pair(int index,int prime,int value) {\\n            this.index=index;\\n            this.prime=prime;\\n            this.value=value;\\n        }\\n            \\n        public int compareTo(Pair second) {\\n            return this.value-second.value;\\n        }\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1799107,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int index[] = new int[primes.length];\\n        int result[] = new int[n];\\n        \\n        result[0]=1;\\n        for (int i = 1; i < n; i++) {\\n            int min = Integer.MAX_VALUE;\\n            for(int j=0;j<primes.length;j++){\\n                min = Math.min(min, primes[j]*result[index[j]]);\\n            }\\n            result[i] = min;\\n            \\n            for(int j=0;j<primes.length;j++){\\n                if(result[i] == primes[j]*result[index[j]]){\\n                    index[j]++;   \\n                }\\n            }\\n        }\\n         return result[n-1];\\n    }\\n       \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int index[] = new int[primes.length];\\n        int result[] = new int[n];\\n        \\n        result[0]=1;\\n        for (int i = 1; i < n; i++) {\\n            int min = Integer.MAX_VALUE;\\n            for(int j=0;j<primes.length;j++){\\n                min = Math.min(min, primes[j]*result[index[j]]);\\n            }\\n            result[i] = min;\\n            \\n            for(int j=0;j<primes.length;j++){\\n                if(result[i] == primes[j]*result[index[j]]){\\n                    index[j]++;   \\n                }\\n            }\\n        }\\n         return result[n-1];\\n    }\\n       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786189,
                "title": "c-accepted-solution-2-method-o-nk-and-o-nlog-k",
                "content": "class Solution {\\npublic:\\n\\n    //1. without priority queue by moving pointer. time complexity O(nk)\\n\\tint nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int dp[n+1]; int k=primes.size();\\n        memset(dp,0,sizeof(dp));\\n        dp[0]=1;\\n        int pointer[k];\\n        memset(pointer,0,sizeof(pointer));\\n        for(int i=1; i<n; i++){\\n            int mn=INT_MAX;\\n            for(int j=0; j<k; j++){\\n                mn=min(primes[j]*dp[pointer[j]],mn);\\n            }\\n            dp[i]=mn;\\n            for(int j=0; j<k; j++){\\n                if(primes[j]*dp[pointer[j]]==mn){\\n                    pointer[j]++;\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n\\n    //2. using priority queue. time complexity O(nlogk)\\n\\tstruct node{\\n        long long prime,pointer,val;\\n        node(long long p,long long po,long long v){\\n            prime=p;\\n            pointer=po;\\n            val=v;\\n        }\\n    };\\n    struct compare{\\n        bool operator()(const node &a,const node &b){\\n            return a.val>b.val;\\n        }\\n    };\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        long long dp[n+1]; long long k=primes.size();\\n        memset(dp,0,sizeof(dp));\\n        dp[1]=1;\\n        priority_queue<node,vector<node>,compare> pq;\\n        for(long long i=0; i<k; i++){\\n            pq.push(node(primes[i],1,primes[i]));\\n        }\\n        for(long long i=2; i<=n;){\\n            node mn=pq.top(); pq.pop();\\n            if(dp[i-1]!=mn.val){\\n                dp[i]=mn.val; i++;\\n            }\\n            node p=node(mn.prime,1+mn.pointer,mn.prime*dp[mn.pointer+1]);\\n            pq.push(p);\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    //1. without priority queue by moving pointer. time complexity O(nk)\\n\\tint nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int dp[n+1]; int k=primes.size();\\n        memset(dp,0,sizeof(dp));\\n        dp[0]=1;\\n        int pointer[k];\\n        memset(pointer,0,sizeof(pointer));\\n        for(int i=1; i<n; i++){\\n            int mn=INT_MAX;\\n            for(int j=0; j<k; j++){\\n                mn=min(primes[j]*dp[pointer[j]],mn);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1765461,
                "title": "extended-concept-of-ugly-number-ii-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        long long dp[n]; //To Store the answer\\n        long long m = primes.size(); \\n        vector<long long> index(m,0); //To store the index of each prime number and track it\\'s increment\\n        vector<long long> nxt(m,0); //To track next min possible number using jth prime number\\n        long long next=1;\\n        dp[0]=1;\\n        for(int i=0;i<m;i++)\\n            nxt[i] = primes[i]; //Storing all prime number in an array Basically indexing them\\n        long long inf=1e18;\\n        for(int i=1;i<n;i++)\\n        {\\n            next=inf;\\n            for(int j=0;j<m;j++)\\n                next = min(nxt[j],next);//Find next possible ans\\n            dp[i]=next;//Assign it\\n            for(int j=0;j<m;j++)\\n            {\\n                if(next%nxt[j]==0) //If that next number multiple of particular prime number then assign its next multiple to the array tracking  their record\\n                {\\n                    index[j]++; //Just by incrementing index to get next multiple of the prime\\n                    nxt[j] = dp[index[j]]*primes[j];\\n                }\\n            }\\n        }\\n        return dp[n-1];//Return ans\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        long long dp[n]; //To Store the answer\\n        long long m = primes.size(); \\n        vector<long long> index(m,0); //To store the index of each prime number and track it\\'s increment\\n        vector<long long> nxt(m,0); //To track next min possible number using jth prime number\\n        long long next=1;\\n        dp[0]=1;\\n        for(int i=0;i<m;i++)\\n            nxt[i] = primes[i]; //Storing all prime number in an array Basically indexing them\\n        long long inf=1e18;\\n        for(int i=1;i<n;i++)\\n        {\\n            next=inf;\\n            for(int j=0;j<m;j++)\\n                next = min(nxt[j],next);//Find next possible ans\\n            dp[i]=next;//Assign it\\n            for(int j=0;j<m;j++)\\n            {\\n                if(next%nxt[j]==0) //If that next number multiple of particular prime number then assign its next multiple to the array tracking  their record\\n                {\\n                    index[j]++; //Just by incrementing index to get next multiple of the prime\\n                    nxt[j] = dp[index[j]]*primes[j];\\n                }\\n            }\\n        }\\n        return dp[n-1];//Return ans\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743934,
                "title": "c-solution-that-s-accepted",
                "content": "C++ solution that works with priority_queue but w/o set to record visited elements.\\n\\nThe tricky part is that instead of using a visited set to check number already visited, you just need to compare the number with the last element in the vector of ugly numbers.\\n\\nTime complexity: O(n logk), k is the number of element in primes\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int size = primes.size();\\n        \\n        // initialize res with first value 0 \\n        vector<int> res;\\n        res.push_back(1);\\n        \\n        if (primes.size() == 0) {\\n            return -1;\\n        }\\n        \\n        // first is value, second is index of prime, third is the current index for this prime,\\n        // need to select the lowest value each time\\n        auto comparator = [](tuple<long, int, int>& t1, tuple<long, int, int>& t2) {\\n            return get<0>(t1) > get<0>(t2);\\n        };\\n        priority_queue<tuple<long, int, int>, vector<tuple<long, int, int>>, decltype(comparator)> minQueue(comparator);\\n        \\n        // Add all values and starting index to 0\\n        for (int i = 0; i < primes.size(); i++) {\\n            minQueue.push(make_tuple(primes[i], i, 1));\\n        }\\n        \\n        while (res.size() != n) {\\n            // pop min value in the minQueue and pop value in the queue\\n            auto [curValue, primeIndex, curIndex] = minQueue.top();\\n            minQueue.pop();\\n            \\n            if (curValue > res.back()) {\\n                res.push_back(curValue);\\n            }\\n            minQueue.push(make_tuple((long) res[curIndex] * primes[primeIndex], primeIndex, curIndex + 1));\\n        } \\n        \\n        return res[n - 1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int size = primes.size();\\n        \\n        // initialize res with first value 0 \\n        vector<int> res;\\n        res.push_back(1);\\n        \\n        if (primes.size() == 0) {\\n            return -1;\\n        }\\n        \\n        // first is value, second is index of prime, third is the current index for this prime,\\n        // need to select the lowest value each time\\n        auto comparator = [](tuple<long, int, int>& t1, tuple<long, int, int>& t2) {\\n            return get<0>(t1) > get<0>(t2);\\n        };\\n        priority_queue<tuple<long, int, int>, vector<tuple<long, int, int>>, decltype(comparator)> minQueue(comparator);\\n        \\n        // Add all values and starting index to 0\\n        for (int i = 0; i < primes.size(); i++) {\\n            minQueue.push(make_tuple(primes[i], i, 1));\\n        }\\n        \\n        while (res.size() != n) {\\n            // pop min value in the minQueue and pop value in the queue\\n            auto [curValue, primeIndex, curIndex] = minQueue.top();\\n            minQueue.pop();\\n            \\n            if (curValue > res.back()) {\\n                res.push_back(curValue);\\n            }\\n            minQueue.push(make_tuple((long) res[curIndex] * primes[primeIndex], primeIndex, curIndex + 1));\\n        } \\n        \\n        return res[n - 1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732697,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    \\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[] pointers = new int[primes.length];\\n        Arrays.fill(pointers, 1);\\n        \\n        int[] dp = new int[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        int idx = 2;\\n        \\n        while(idx < dp.length){\\n        \\n            int min = Integer.MAX_VALUE;\\n            for(int i=0; i<primes.length; i++){\\n                int comp = primes[i] * dp[pointers[i]];\\n                if(min > comp){\\n                    min = comp;\\n                }\\n            }\\n            \\n            \\n            \\n            dp[idx] = min;\\n            \\n            for(int i=0; i<primes.length; i++){\\n                int comp = primes[i] * dp[pointers[i]];\\n                if(min == comp){\\n                    pointers[i]++;\\n                }\\n            }\\n            \\n            idx++;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[] pointers = new int[primes.length];\\n        Arrays.fill(pointers, 1);\\n        \\n        int[] dp = new int[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        int idx = 2;\\n        \\n        while(idx < dp.length){\\n        \\n            int min = Integer.MAX_VALUE;\\n            for(int i=0; i<primes.length; i++){\\n                int comp = primes[i] * dp[pointers[i]];\\n                if(min > comp){\\n                    min = comp;\\n                }\\n            }\\n            \\n            \\n            \\n            dp[idx] = min;\\n            \\n            for(int i=0; i<primes.length; i++){\\n                int comp = primes[i] * dp[pointers[i]];\\n                if(min == comp){\\n                    pointers[i]++;\\n                }\\n            }\\n            \\n            idx++;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727606,
                "title": "python-o-n-dp-solution-using-heap",
                "content": "The idea is similar to leetcode problem: 23. Merge k Sorted Lists. You can think of each prime number is the head of a list that are multiplies of that prime. When insert into the heap, we need to both record the index of which prime, and the index on the dp array. Because the next multiplier will be the next index on the DP array.\\n\\nAlso use a hashset to avoid duplicated number gets into the DP array.\\n\\nThere will be only less than k = len(primes) nodes in the heap so push and pop operation will be O(logk), each number will be duplicated k times maximum. So the time complexity is O(knlogk), since k <= 100, so it is O(n). Space complexity is also O(n).\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        dp, heap, visited = [1], [], set()\\n        for i, p in enumerate(primes):\\n            heapq.heappush(heap, (p, i, 0))\\n        \\n        while len(dp) < n:\\n            val, prime_idx, dp_idx = heapq.heappop(heap)\\n            if val not in visited:\\n                dp.append(val)\\n                visited.add(val)\\n            heapq.heappush(heap, (primes[prime_idx] * dp[dp_idx + 1], prime_idx, dp_idx + 1))\\n        \\n        return dp[-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        dp, heap, visited = [1], [], set()\\n        for i, p in enumerate(primes):\\n            heapq.heappush(heap, (p, i, 0))\\n        \\n        while len(dp) < n:\\n            val, prime_idx, dp_idx = heapq.heappop(heap)\\n            if val not in visited:\\n                dp.append(val)\\n                visited.add(val)\\n            heapq.heappush(heap, (primes[prime_idx] * dp[dp_idx + 1], prime_idx, dp_idx + 1))\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590211,
                "title": "java-dp-tabulation-solution-2-methods",
                "content": "**1. By creating a Pointer array (Almost same as Ugly number Problem)**\\n\\tTime Complexity - O(NK)\\n\\tSpace Complexity - O(N+K)\\n\\tRuntime - 279ms - Faster than 65.62%*\\n\\t.\\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n          int[] pointers = new int[primes.length];\\n          int[] dp = new int[n];\\n          dp[0] = 1;\\n          for(int i = 0; i < pointers.length; i++)\\n              pointers[i] = 0;\\n\\n          for(int i = 1; i < dp.length; i++) {\\n              int min = Integer.MAX_VALUE;\\n              for(int j = 0; j < pointers.length; j++)\\n                  min = Integer.min(min, primes[j] * dp[pointers[j]]);\\n\\n              dp[i] = min;\\n              for(int j = 0; j < pointers.length; j++) {\\n                  if(dp[i] == primes[j] * dp[pointers[j]])\\n                      pointers[j]++;\\n              }\\n          }\\n          return dp[n-1];\\n    }\\n}\\n```\\n.\\n**2. By using Priority Queue**\\n\\tTime Complexity - O(N* log(K))\\n\\tSpace Complexity - O(N + K)\\n\\tRuntime - 445ms - Faster than 36.13%\\n\\t.\\n```\\nclass Solution {\\n    public class Pair implements Comparable<Pair>{\\n        int primes;\\n        int pointers;\\n        int value;\\n        \\n        Pair(int primes, int pointers, int value){\\n        \\tthis.primes = primes;\\n        \\tthis.pointers = pointers;\\n        \\tthis.value = value;\\n        }\\n        \\n        public int compareTo(Pair o) {\\n        \\treturn this.value - o.value;\\n        }\\n    }\\n    \\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n          int[] dp = new int[n];\\n          dp[0] = 1;\\n\\n          PriorityQueue<Pair> pq = new PriorityQueue<>();\\n          for(int i = 0; i < primes.length; i++)\\n              pq.add(new Pair(primes[i], 0, primes[i] * dp[0]));\\n\\n          for(int i = 1; i < dp.length; i++) {\\n              Pair rem = pq.remove();\\n              dp[i] = rem.value;\\n              pq.add(new Pair(rem.primes, rem.pointers + 1, rem.primes * dp[rem.pointers]));\\n              while(pq.peek().value == rem.value) {\\n                  Pair nrem = pq.remove();\\n                  pq.add(new Pair(nrem.primes, nrem.pointers + 1, nrem.primes * dp[nrem.pointers]));\\n              }\\n          }\\n          return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n          int[] pointers = new int[primes.length];\\n          int[] dp = new int[n];\\n          dp[0] = 1;\\n          for(int i = 0; i < pointers.length; i++)\\n              pointers[i] = 0;\\n\\n          for(int i = 1; i < dp.length; i++) {\\n              int min = Integer.MAX_VALUE;\\n              for(int j = 0; j < pointers.length; j++)\\n                  min = Integer.min(min, primes[j] * dp[pointers[j]]);\\n\\n              dp[i] = min;\\n              for(int j = 0; j < pointers.length; j++) {\\n                  if(dp[i] == primes[j] * dp[pointers[j]])\\n                      pointers[j]++;\\n              }\\n          }\\n          return dp[n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public class Pair implements Comparable<Pair>{\\n        int primes;\\n        int pointers;\\n        int value;\\n        \\n        Pair(int primes, int pointers, int value){\\n        \\tthis.primes = primes;\\n        \\tthis.pointers = pointers;\\n        \\tthis.value = value;\\n        }\\n        \\n        public int compareTo(Pair o) {\\n        \\treturn this.value - o.value;\\n        }\\n    }\\n    \\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n          int[] dp = new int[n];\\n          dp[0] = 1;\\n\\n          PriorityQueue<Pair> pq = new PriorityQueue<>();\\n          for(int i = 0; i < primes.length; i++)\\n              pq.add(new Pair(primes[i], 0, primes[i] * dp[0]));\\n\\n          for(int i = 1; i < dp.length; i++) {\\n              Pair rem = pq.remove();\\n              dp[i] = rem.value;\\n              pq.add(new Pair(rem.primes, rem.pointers + 1, rem.primes * dp[rem.pointers]));\\n              while(pq.peek().value == rem.value) {\\n                  Pair nrem = pq.remove();\\n                  pq.add(new Pair(nrem.primes, nrem.pointers + 1, nrem.primes * dp[nrem.pointers]));\\n              }\\n          }\\n          return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564599,
                "title": "why-am-i-getting-tle-in-o-nk-solution",
                "content": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        ans=[1]\\n        l=[0]*len(primes)\\n        for i in range(n):\\n            mini=10**11\\n            for j in range(len(primes)):\\n                mini=min(primes[j]*ans[l[j]],mini)\\n            ans.append(mini)\\n            for j in range(len(primes)):\\n                if mini==primes[j]*ans[l[j]]:\\n                    l[j]+=1\\n        # print(ans)\\n        return ans[n-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        ans=[1]\\n        l=[0]*len(primes)\\n        for i in range(n):\\n            mini=10**11\\n            for j in range(len(primes)):\\n                mini=min(primes[j]*ans[l[j]],mini)\\n            ans.append(mini)\\n            for j in range(len(primes)):\\n                if mini==primes[j]*ans[l[j]]:\\n                    l[j]+=1\\n        # print(ans)\\n        return ans[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497385,
                "title": "c-heap-with-triplet",
                "content": "```\\n#define ll long long\\nclass Solution {\\n    struct triplet{\\n        ll primeNumber, index, element;\\n        triplet(ll pn, ll idx, ll e){\\n            primeNumber = pn;\\n            index = idx;\\n            element = e;\\n        }\\n    };\\n    \\n    struct compare{\\n        bool operator()(triplet &t1, triplet &t2){\\n            return t1.element > t2.element;      \\n        }\\n    };\\n    \\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>v(1,1);\\n        priority_queue<triplet, vector<triplet>, compare>pq;\\n        \\n        for(auto k:primes){\\n            pq.push({k, 0, k});\\n        }\\n\\n        while(v.size() < n){\\n            triplet top = pq.top();\\n            pq.pop();\\n            if(top.element > v.back()){\\n                v.push_back(top.element);\\n            }\\n            pq.push({top.primeNumber, top.index+1, (top.primeNumber * v[(top.index + 1)])});\\n        }\\n        \\n        return v.back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\n    struct triplet{\\n        ll primeNumber, index, element;\\n        triplet(ll pn, ll idx, ll e){\\n            primeNumber = pn;\\n            index = idx;\\n            element = e;\\n        }\\n    };\\n    \\n    struct compare{\\n        bool operator()(triplet &t1, triplet &t2){\\n            return t1.element > t2.element;      \\n        }\\n    };\\n    \\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int>v(1,1);\\n        priority_queue<triplet, vector<triplet>, compare>pq;\\n        \\n        for(auto k:primes){\\n            pq.push({k, 0, k});\\n        }\\n\\n        while(v.size() < n){\\n            triplet top = pq.top();\\n            pq.pop();\\n            if(top.element > v.back()){\\n                v.push_back(top.element);\\n            }\\n            pq.push({top.primeNumber, top.index+1, (top.primeNumber * v[(top.index + 1)])});\\n        }\\n        \\n        return v.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233306,
                "title": "java-priorityqueue-solution-with-explanation-time-o-nlogk",
                "content": "```\\n// PriorityQueue Solution\\n// The next super ugly number can be generated from the previous ugly number * certain prime.\\n// To get currently min ugly number, we can use a PriorityQueue as min heap.\\n// So we need to store tuples (ugly number, index, prime) in PriorityQueue.\\n// The 1st element indicates the current ugly number;\\n// The 2nd element indicates the index in the uglyNums;\\n// The 3rd element indicates the prime to generate current ugly number.\\n// Add the peek() element to get the min ugly num and add to uglyNums array.\\n// And then, use the min ugly number * its prime in the min heap to generate next ugly number.\\n// Note: there might be some duplicated ugly number generated by different primes.\\n// Poll all duplicated ugly number and times by their own primes then add back to the min heap.\\n// Time complexity: O(NlogK), where K is the length of primes array.\\n// Space complexity: O(N + K)\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        if (n <= 0 || primes == null || primes.length == 0) throw new IllegalArgumentException(\"Invalid input\");\\n        if (n == 1) return 1;\\n        PriorityQueue<Ugly> minHeap = new PriorityQueue<>((u1, u2) -> Integer.compare(u1.ugly, u2.ugly));\\n        int[] uglyNums = new int[n];\\n        uglyNums[0] = 1;\\n        for (int i = 0; i < primes.length; i++) {\\n            minHeap.add(new Ugly(primes[i], i + 1, primes[i]));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            uglyNums[i] = minHeap.peek().ugly;\\n            while (!minHeap.isEmpty() && minHeap.peek().ugly == uglyNums[i]) {\\n                Ugly ugly = minHeap.poll();\\n                int nextUgly = uglyNums[ugly.index] * ugly.prime;\\n                if (nextUgly > 0) {  // In case integer overflow\\n                    minHeap.add(new Ugly(nextUgly, ugly.index + 1, ugly.prime));\\n                }\\n            }\\n        }\\n        return uglyNums[n-1];\\n    }\\n    \\n    class Ugly {\\n        int ugly, index, prime;\\n        Ugly(int ugly, int index, int prime) {\\n            this.ugly = ugly;\\n            this.index = index;\\n            this.prime = prime;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// PriorityQueue Solution\\n// The next super ugly number can be generated from the previous ugly number * certain prime.\\n// To get currently min ugly number, we can use a PriorityQueue as min heap.\\n// So we need to store tuples (ugly number, index, prime) in PriorityQueue.\\n// The 1st element indicates the current ugly number;\\n// The 2nd element indicates the index in the uglyNums;\\n// The 3rd element indicates the prime to generate current ugly number.\\n// Add the peek() element to get the min ugly num and add to uglyNums array.\\n// And then, use the min ugly number * its prime in the min heap to generate next ugly number.\\n// Note: there might be some duplicated ugly number generated by different primes.\\n// Poll all duplicated ugly number and times by their own primes then add back to the min heap.\\n// Time complexity: O(NlogK), where K is the length of primes array.\\n// Space complexity: O(N + K)\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        if (n <= 0 || primes == null || primes.length == 0) throw new IllegalArgumentException(\"Invalid input\");\\n        if (n == 1) return 1;\\n        PriorityQueue<Ugly> minHeap = new PriorityQueue<>((u1, u2) -> Integer.compare(u1.ugly, u2.ugly));\\n        int[] uglyNums = new int[n];\\n        uglyNums[0] = 1;\\n        for (int i = 0; i < primes.length; i++) {\\n            minHeap.add(new Ugly(primes[i], i + 1, primes[i]));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            uglyNums[i] = minHeap.peek().ugly;\\n            while (!minHeap.isEmpty() && minHeap.peek().ugly == uglyNums[i]) {\\n                Ugly ugly = minHeap.poll();\\n                int nextUgly = uglyNums[ugly.index] * ugly.prime;\\n                if (nextUgly > 0) {  // In case integer overflow\\n                    minHeap.add(new Ugly(nextUgly, ugly.index + 1, ugly.prime));\\n                }\\n            }\\n        }\\n        return uglyNums[n-1];\\n    }\\n    \\n    class Ugly {\\n        int ugly, index, prime;\\n        Ugly(int ugly, int index, int prime) {\\n            this.ugly = ugly;\\n            this.index = index;\\n            this.prime = prime;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229234,
                "title": "java-clean-concise-optimal-code-dynamic-programming-approach-90-faster-solution",
                "content": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        \\n        int[] count = new int[primes.length];\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            int currUglyNumber = Integer.MAX_VALUE;\\n            \\n            for (int j = 0; j < primes.length; j++) {\\n                currUglyNumber = Math.min (currUglyNumber, dp[count[j]] * primes[j]);\\n            }\\n            \\n            for (int j = 0; j < count.length; j++) {\\n                if (currUglyNumber == dp[count[j]] * primes[j]) {\\n                    ++count[j];\\n                }\\n            }\\n            \\n            dp[i] = currUglyNumber;\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        \\n        int[] count = new int[primes.length];\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            int currUglyNumber = Integer.MAX_VALUE;\\n            \\n            for (int j = 0; j < primes.length; j++) {\\n                currUglyNumber = Math.min (currUglyNumber, dp[count[j]] * primes[j]);\\n            }\\n            \\n            for (int j = 0; j < count.length; j++) {\\n                if (currUglyNumber == dp[count[j]] * primes[j]) {\\n                    ++count[j];\\n                }\\n            }\\n            \\n            dp[i] = currUglyNumber;\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142730,
                "title": "python-heap-check-duplicate-using-a-seen-set",
                "content": "We can either check duplicate using\\n1- (done here) a seen set before pushing to heap\\n2- checking if the top of heap is same as popped value, if so ignore it\\n\\n```\\ndef nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        heap = [1]\\n        seen = set()\\n        cnt = 1\\n        while True:\\n            cur = heapq.heappop(heap)\\n            if cnt == n:\\n                return cur\\n            \\n            for prime in primes:\\n                new_super_ugly = cur * prime\\n                if new_super_ugly not in seen:\\n                    heapq.heappush(heap, new_super_ugly)\\n                    seen.add(new_super_ugly)\\n\\n            cnt += 1\\n```",
                "solutionTags": [],
                "code": "```\\ndef nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        heap = [1]\\n        seen = set()\\n        cnt = 1\\n        while True:\\n            cur = heapq.heappop(heap)\\n            if cnt == n:\\n                return cur\\n            \\n            for prime in primes:\\n                new_super_ugly = cur * prime\\n                if new_super_ugly not in seen:\\n                    heapq.heappush(heap, new_super_ugly)\\n                    seen.add(new_super_ugly)\\n\\n            cnt += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1142648,
                "title": "c-best-tc-o-nlogk-solution-priority-queue",
                "content": "class Solution {\\npublic:\\n    vector<int> ans;\\n\\n    struct comparator { \\n        bool operator()(pair<int, pair<int, int>> &p1, pair<int, pair<int, int>> & p2)  { \\n            return p1.first > p2.first;\\n        } \\n    }; \\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, comparator> pq;\\n        \\n        for(auto i: primes) {\\n            pq.push(make_pair(i, make_pair(i, 0)));\\n        }\\n        \\n        int prev(1);\\n        pair<int, pair<int, int>> curr;\\n        ans.push_back(1);\\n        while(ans.size() != n) {\\n            curr = pq.top();\\n            pq.pop();\\n            if(curr.first != prev) {\\n                prev = curr.first;\\n                ans.push_back(curr.first);\\n            }\\n            pq.push(make_pair(curr.second.first * ans[curr.second.second + 1] ,make_pair(curr.second.first, curr.second.second+1)));\\n        }\\n        return prev;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> ans;\\n\\n    struct comparator { \\n        bool operator()(pair<int, pair<int, int>> &p1, pair<int, pair<int, int>> & p2)  { \\n            return p1.first > p2.first;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 980317,
                "title": "c-simple-and-intuitive-with-explanation",
                "content": "One aproach can be to form the sequence of `n` ugli numbers and report the last one. While trying to do so, one usually gets stuck with thinking how to form the sequence so that no number is left out, that is, how to make sure the sequence contains all the `n` numbers in the right order. \\n\\nOne way to get around this is to look at the sequence from different perspective. Instead of inserting the numbers in the right order, what if you popped out the numbers in the right order? Hence while popping off the next number, you can make sure that the number you are removing is the lowest number possible among the given choices.\\n\\nLook at the code with this idea in mind!\\n\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        unordered_set<long long> alreadyCame;\\n        priority_queue<long long, vector<long long>, greater<long long>> pq;\\n        alreadyCame.insert(1);\\n        pq.push(1);\\n        long long current;\\n        \\n        while(n--){\\n            current = pq.top();\\n            pq.pop();\\n            \\n            if(!n) return current; // for decreasing time, not necessary for the logic\\n            \\n            for(int prime: primes){\\n                long long temp = prime*current;\\n                \\n                if(temp >= INT_MAX) break; // for decreasing time, not necessary for the logic\\n                \\n                if(!alreadyCame.count(temp)){\\n                    alreadyCame.insert(temp);\\n                    pq.push(temp);\\n                }\\n            }\\n        }\\n        \\n        return (int)current;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        unordered_set<long long> alreadyCame;\\n        priority_queue<long long, vector<long long>, greater<long long>> pq;\\n        alreadyCame.insert(1);\\n        pq.push(1);\\n        long long current;\\n        \\n        while(n--){\\n            current = pq.top();\\n            pq.pop();\\n            \\n            if(!n) return current; // for decreasing time, not necessary for the logic\\n            \\n            for(int prime: primes){\\n                long long temp = prime*current;\\n                \\n                if(temp >= INT_MAX) break; // for decreasing time, not necessary for the logic\\n                \\n                if(!alreadyCame.count(temp)){\\n                    alreadyCame.insert(temp);\\n                    pq.push(temp);\\n                }\\n            }\\n        }\\n        \\n        return (int)current;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895821,
                "title": "easy-o-n-js-solution",
                "content": "```\\nvar nthSuperUglyNumber = function(n, primes) {\\n    let nums = [1], indices = new Array(primes.length);\\n    for (let i = 0; i < indices.length; i++) indices[i] = 0;\\n    while (nums.length < n) {\\n        let next = Number.MAX_VALUE, minIndices = [];\\n        for (let i = 0; i < primes.length; i++) {\\n            let num = nums[indices[i]]*primes[i];\\n            if (next > num) {\\n                next = num;\\n                minIndices = [i];\\n            } else if (next == num) minIndices.push(i);\\n        }\\n        nums.push(next);\\n        minIndices.forEach(j => indices[j]++);\\n    }\\n    return nums[n-1];\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nthSuperUglyNumber = function(n, primes) {\\n    let nums = [1], indices = new Array(primes.length);\\n    for (let i = 0; i < indices.length; i++) indices[i] = 0;\\n    while (nums.length < n) {\\n        let next = Number.MAX_VALUE, minIndices = [];\\n        for (let i = 0; i < primes.length; i++) {\\n            let num = nums[indices[i]]*primes[i];\\n            if (next > num) {\\n                next = num;\\n                minIndices = [i];\\n            } else if (next == num) minIndices.push(i);\\n        }\\n        nums.push(next);\\n        minIndices.forEach(j => indices[j]++);\\n    }\\n    return nums[n-1];\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 894123,
                "title": "java-heap-solution-with-comments-time-complexity-o-logk-n",
                "content": "**The Idea is any  prime number array we have to use factor of those prime number i.e from [2,3,5] then 2X1, 3X1,  2X2, 5X1, 2X3...\\nWe keep adding all these prime numbers into heap and keep removing and storing that primes numbers factors into array and keep updating for the prime number next factor.\\nWe need to keep in ind when 2X3==6 and 3X2 = 6 then we will be already able to store 6 as the ugly number in the array but then we will needed both of 2 and 3 prime number\\'s being updated for their index[idx] , hence we need a loop for that while .**\\n\\nTime Complexity :- n = total of inputs of the ugly number k will be the same logk for adding log( k) and removing the same value max till log(k) from heap, so O(N*logk)\\nSpace Complexity :- is N for ugly numbers and k for primes\\' array so O(N + k)\\n\\n```\\nclass Solution {\\n    \\n   class ugly implements Comparable<ugly>{\\n       \\n       int val; //this is for the value\\n       int idx;  //idx which will be used for storing next number for primes[i]\\n       int set; //this is used for the primes[i] number which will be multiplied with the values\\n       \\n       public ugly(int val, int idx, int set){\\n           this.val = val;\\n           this.idx = idx;\\n           this.set = set;\\n       }\\n       \\n       public int compareTo(ugly p){\\n          \\n           return this.val-p.val;\\n       }\\n   }\\n        \\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        \\n        PriorityQueue<ugly> pq = new PriorityQueue<>();\\n        int[] arrugly = new int[n];\\n        \\n        for(int i = 0 ; i <primes.length; i++){\\n            pq.add(new ugly(primes[i],1,primes[i]));\\n        }\\n        \\n        arrugly[0] = 1;\\n        \\n        for(int i = 1; i<n; i++){\\n//here let we have gone till 1,2, this time i = 3 we get min values i.e. 3 out of heap and store arrugly[2] = 3\\n            \\n            arrugly[i] = pq.peek().val;\\n //taking the while loop because at a time i.e 2 factor = 6 and 3 factor = 6 so we will update respecitively of 2 and 3 factors\\n            \\n            while(pq.peek().val==arrugly[i]){\\n            ugly rem = pq.remove();\\n            pq.add(new ugly(arrugly[rem.idx]*rem.set, rem.idx+1, rem.set));    \\n//now arrugly[1]=2 and 2* rem.set(==3) = 6 and idx+1=2 for next iteration like next will be arrugly[2] = 3 so 3*rem.set(==3) = 9 and so on..            \\n            \\n            }\\n            \\n        }\\n        \\n        return arrugly[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n   class ugly implements Comparable<ugly>{\\n       \\n       int val; //this is for the value\\n       int idx;  //idx which will be used for storing next number for primes[i]\\n       int set; //this is used for the primes[i] number which will be multiplied with the values\\n       \\n       public ugly(int val, int idx, int set){\\n           this.val = val;\\n           this.idx = idx;\\n           this.set = set;\\n       }\\n       \\n       public int compareTo(ugly p){\\n          \\n           return this.val-p.val;\\n       }\\n   }\\n        \\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        \\n        PriorityQueue<ugly> pq = new PriorityQueue<>();\\n        int[] arrugly = new int[n];\\n        \\n        for(int i = 0 ; i <primes.length; i++){\\n            pq.add(new ugly(primes[i],1,primes[i]));\\n        }\\n        \\n        arrugly[0] = 1;\\n        \\n        for(int i = 1; i<n; i++){\\n//here let we have gone till 1,2, this time i = 3 we get min values i.e. 3 out of heap and store arrugly[2] = 3\\n            \\n            arrugly[i] = pq.peek().val;\\n //taking the while loop because at a time i.e 2 factor = 6 and 3 factor = 6 so we will update respecitively of 2 and 3 factors\\n            \\n            while(pq.peek().val==arrugly[i]){\\n            ugly rem = pq.remove();\\n            pq.add(new ugly(arrugly[rem.idx]*rem.set, rem.idx+1, rem.set));    \\n//now arrugly[1]=2 and 2* rem.set(==3) = 6 and idx+1=2 for next iteration like next will be arrugly[2] = 3 so 3*rem.set(==3) = 9 and so on..            \\n            \\n            }\\n            \\n        }\\n        \\n        return arrugly[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882804,
                "title": "heapq-solution-in-python",
                "content": "\\'\\'\\'\\n\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:         \\n        nums = [1] + primes\\n        s = set(nums)\\n         \\n        for i in range(n):\\n            num = heapq.heappop(nums)             \\n            for prime in primes:\\n                if num*prime not in s:\\n                    heapq.heappush(nums, num*prime)\\n                    s.add(num*prime)\\n        \\n        return num",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:         \\n        nums = [1] + primes\\n        s = set(nums)\\n         \\n        for i in range(n):\\n            num = heapq.heappop(nums)             \\n            for prime in primes:\\n                if num*prime not in s:\\n                    heapq.heappush(nums, num*prime)\\n                    s.add(num*prime)\\n        \\n        return num",
                "codeTag": "Python3"
            },
            {
                "id": 788267,
                "title": "python3-k-pointers",
                "content": "An interesting fact about ugly number or super ugly number is that they are self-generating. It is possible to write a function to generate next ugly number (e.g. this [post](https://leetcode.com/problems/ugly-number-ii/discuss/720034/Python3-7-line-dp)). Unfortunately, the scale of this problem is so big that a direct top-down approach causes TLE. \\n\\n\\n```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        ans = [1]\\n        ptr = [0]*len(primes) #all pointing to 0th index\\n        for _ in range(1, n): \\n            ans.append(min(ans[ptr[i]]*p for i, p in enumerate(primes)))\\n            for i, p in enumerate(primes):\\n                if ans[ptr[i]] * p == ans[-1]: ptr[i] += 1\\n        return ans[-1]\\n```\\n\\nfaster via a heap (280ms, 95.49%)\\n```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        ans = [1]\\n        hp = [(p, 0) for p in primes]\\n        for _ in range(1, n): \\n            ans.append(hp[0][0])\\n            while ans[-1] == hp[0][0]: \\n                val, i = heappop(hp)\\n                val = val//(ans[i]) * ans[i+1]\\n                heappush(hp, (val, i+1))\\n        return ans[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        ans = [1]\\n        ptr = [0]*len(primes) #all pointing to 0th index\\n        for _ in range(1, n): \\n            ans.append(min(ans[ptr[i]]*p for i, p in enumerate(primes)))\\n            for i, p in enumerate(primes):\\n                if ans[ptr[i]] * p == ans[-1]: ptr[i] += 1\\n        return ans[-1]\\n```\n```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        ans = [1]\\n        hp = [(p, 0) for p in primes]\\n        for _ in range(1, n): \\n            ans.append(hp[0][0])\\n            while ans[-1] == hp[0][0]: \\n                val, i = heappop(hp)\\n                val = val//(ans[i]) * ans[i+1]\\n                heappush(hp, (val, i+1))\\n        return ans[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778419,
                "title": "short-simple-using-c-sets",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        set<unsigned long long int>s;\\n        unsigned long long int x;\\n        s.insert(1);\\n        while(n--)\\n        {\\n            x=*s.begin();\\n            s.erase(s.begin());\\n            for(auto it:primes)\\n            {\\n                if(x*it<=INT_MAX)\\n                s.insert(x*it);\\n                else\\n                break;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        set<unsigned long long int>s;\\n        unsigned long long int x;\\n        s.insert(1);\\n        while(n--)\\n        {\\n            x=*s.begin();\\n            s.erase(s.begin());\\n            for(auto it:primes)\\n            {\\n                if(x*it<=INT_MAX)\\n                s.insert(x*it);\\n                else\\n                break;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766530,
                "title": "simple-5line-java-solution-using-heap",
                "content": "`````````````````\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] p) {\\n        PriorityQueue<Long> pq=new PriorityQueue<>();\\n        pq.add(1l);\\n        for(int i=1;i<n;i++){\\n            long l=pq.poll();\\n            while(!pq.isEmpty() && pq.peek()==l){\\n                pq.poll();\\n            }\\n           for(int j=0;j<p.length;j++){\\n               pq.add(p[j]*l);\\n           }\\n        }\\n        \\n        return pq.poll().intValue();\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "``````\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 749607,
                "title": "simple-python-only-use-heap",
                "content": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        \\n        minheap = [1]\\n        while n:\\n            node = heappop(minheap)\\n            #handle duplicates\\n            while minheap and minheap[0] == node:\\n                heappop(minheap)\\n            n -= 1\\n            for prime in primes:\\n                heappush(minheap, node * prime)\\n        \\n        return node\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        \\n        minheap = [1]\\n        while n:\\n            node = heappop(minheap)\\n            #handle duplicates\\n            while minheap and minheap[0] == node:\\n                heappop(minheap)\\n            n -= 1\\n            for prime in primes:\\n                heappush(minheap, node * prime)\\n        \\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714885,
                "title": "very-short-and-simple-c-priority-queue-sol",
                "content": "please upvote, if you like the question\\n```\\ntypedef long long ll;\\nll mod = 1000000007;\\n#define f first\\n#define s second\\n#define ss string\\n#define mp make_pair\\n#define pb push_back\\n#define p pair<int, int>\\n#define pp pair<int, p>\\n#define v vector<int>\\n#define vl vector<ll>\\n#define vb vector<bool>\\n#define vs vector<string>\\n#define vp vector<p>\\n#define vpp vector<pair<int, p>>\\n#define vv vector<v>\\n#define vvl vector<vl>\\n#define vvp vector<vp>\\n#define rep(i, n) for(int i = 0; i < (n); ++i)\\n#define repa(i, a, n) for(int i = a; i <= (n); ++i)\\n#define repd(i, n) for(int i = n; i >= 0; --i)\\n#define all(x) (x).begin(), (x).end()\\n\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& a) {\\n        if(n == 0){\\n            return -1;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(a.size() == 1){\\n            return pow(a[0], n-1);\\n        }\\n        priority_queue<ll, vl, greater<ll>> q;\\n        for(int i : a){\\n            q.push(i);\\n        }\\n        ll ans, count = 1;\\n        while(count < n){\\n            ans = q.top();\\n            q.pop();\\n            if(ans != q.top()){\\n                count++;\\n                for(int i : a){\\n                    q.push(i*ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& a) {\\n        if(n == 0){\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 565337,
                "title": "c-dynamic-programming-o-n-k",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> dp(n, INT_MAX);\\n        int m = primes.size();\\n        dp[0] = 1;\\n        vector<int> last(m, 0);\\n        for(int i = 1; i < n; i++){\\n            for(int k = 0; k < m; k++){\\n                dp[i] = min(dp[i], dp[last[k]]*primes[k]);\\n            }\\n            for(int k = 0; k < m; k++){\\n                if(dp[i] == dp[last[k]]*primes[k]) last[k]++;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> dp(n, INT_MAX);\\n        int m = primes.size();\\n        dp[0] = 1;\\n        vector<int> last(m, 0);\\n        for(int i = 1; i < n; i++){\\n            for(int k = 0; k < m; k++){\\n                dp[i] = min(dp[i], dp[last[k]]*primes[k]);\\n            }\\n            for(int k = 0; k < m; k++){\\n                if(dp[i] == dp[last[k]]*primes[k]) last[k]++;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439654,
                "title": "python-97-100-with-explanation",
                "content": "The overall idea is to build the super ugly number sequence in order until we have n values.\\nTo find the next value in the sequence, we need to find the min product of a number in the\\ncurrent sequence and a prime in the list. In order to avoid redundant computations, for each prime\\nwe use an index to tell us the next value in the current sequence for which we should obtain a product.\\n\\n```\\nfrom heapq import heapify, heappop, heappush\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        super_ugly_numbers = []\\n        heap = [1]\\n        heapify(heap)\\n        indexes = {1: [[0, p] for p in primes]}\\n        while len(super_ugly_numbers) < n:\\n            super_ugly_numbers.append(heappop(heap))\\n            for tup in indexes[super_ugly_numbers[-1]]:\\n                new_ugly = super_ugly_numbers[tup[0]] * tup[1]    \\n                if new_ugly in indexes:\\n                    indexes[new_ugly].append([tup[0] + 1, tup[1]])\\n                else:\\n                    indexes[new_ugly] = [[tup[0] + 1, tup[1]]]\\n                    heappush(heap, new_ugly)\\n            del indexes[super_ugly_numbers[-1]]\\n        return super_ugly_numbers[-1]\\n```\\n\\n\\n    Example\\n    Initialization:\\n          super_ugly_numbers = []\\n          heap = [1]\\n          indexes = {\\n              1: [[0,2], [0,7], [0,13], [0,19]]\\n          }\\n    Iteration 1 :\\n          super_ugly_numbers = [1]\\n          heap = [2, 7, 13, 19]\\n          indexes = {\\n              2: [[1,2]],\\n              7: [[1,7]],\\n              13: [[1,13],\\n              19: [1,19]]\\n          }\\n    Iteration 2:\\n          super_ugly_numbers = [1,2]\\n          heap = [4, 7, 13, 19]\\n          indexes = {\\n              4: [[2,2]],\\n              7: [[1,7]],\\n              13: [[1,13],\\n              19: [1,19]]\\n          }\\n    Iteration 3:\\n          super_ugly_numbers = [1,2,4]\\n          heap = [8, 7, 13, 19]\\n          indexes = {\\n              8: [[3,2]],\\n              7: [[1,7]],\\n              13: [[1,13],\\n              19: [1,19]]\\n          }\\n    Iteration 4:\\n          super_ugly_numbers = [1,2,4,7]\\n          heap = [8, 13, 14, 19]\\n          indexes = {\\n              8: [[3,2]],\\n              14: [[2,7]],\\n              13: [[1,13],\\n              19: [1,19]]\\n          }...",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heapify, heappop, heappush\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        super_ugly_numbers = []\\n        heap = [1]\\n        heapify(heap)\\n        indexes = {1: [[0, p] for p in primes]}\\n        while len(super_ugly_numbers) < n:\\n            super_ugly_numbers.append(heappop(heap))\\n            for tup in indexes[super_ugly_numbers[-1]]:\\n                new_ugly = super_ugly_numbers[tup[0]] * tup[1]    \\n                if new_ugly in indexes:\\n                    indexes[new_ugly].append([tup[0] + 1, tup[1]])\\n                else:\\n                    indexes[new_ugly] = [[tup[0] + 1, tup[1]]]\\n                    heappush(heap, new_ugly)\\n            del indexes[super_ugly_numbers[-1]]\\n        return super_ugly_numbers[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371325,
                "title": "pure-raw-python-no-libraries",
                "content": "```\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        pcnt = len(primes)\\n        uglies = [0]*n\\n        uglies[0] = 1\\n        divs = [0] * pcnt\\n        for i in range(1, n):\\n            uglies[i] = primes[0] * uglies[divs[0]]\\n            for k in range(1, pcnt):\\n                new = primes[k] * uglies[divs[k]]\\n                if uglies[i] > new:\\n                    uglies[i] = new\\n            for j in range(pcnt):\\n                divs[j] += uglies[i] == uglies[divs[j]] * primes[j]\\n        return uglies[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        pcnt = len(primes)\\n        uglies = [0]*n\\n        uglies[0] = 1\\n        divs = [0] * pcnt\\n        for i in range(1, n):\\n            uglies[i] = primes[0] * uglies[divs[0]]\\n            for k in range(1, pcnt):\\n                new = primes[k] * uglies[divs[k]]\\n                if uglies[i] > new:\\n                    uglies[i] = new\\n            for j in range(pcnt):\\n                divs[j] += uglies[i] == uglies[divs[j]] * primes[j]\\n        return uglies[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332578,
                "title": "cpp-o-n-logk-solution",
                "content": "Here\\'s the [explanation of the basic idea](https://www.geeksforgeeks.org/ugly-numbers/). \\nWe have K arrays. The ith array is generated by primes[i] x (ans[0], ans[1], ans[2], .etc). And we can treat this problem as to find the nth value of k sorted arrays. So I use a min heap(priority_queue) to store the first value of the k arrays. And if we find the lowest value(top of the heap) on ith array, we push its next element into the heap. Be careful of the duplicates.\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        priority_queue<Num, vector<Num>, myCompare> pq;\\n        vector<int> ans = {1};\\n        for(int i : primes)\\n            pq.push(Num(i, 0, i));\\n        for(int i = 1; i < n; ++i) {\\n            int tmp = pq.top().next;\\n            ans.push_back(tmp);\\n\\t\\t\\t//duplicate\\n            while(pq.top().next == tmp) {\\n                Num n = pq.top();\\n                pq.pop();\\n                pq.push(Num(n.prime, n.index + 1, n.prime * ans[n.index + 1]));\\n            }\\n        }\\n        return ans.back();\\n            \\n    }\\nprivate:\\n    struct Num {\\n        int prime;\\n        int index;\\n        int next;\\n        \\n        Num(int p, int i, int n): prime(p), index(i), next(n) {\\n            \\n        }\\n    };\\n    struct myCompare {\\n        bool operator()(Num a, Num b) {\\n            return a.next > b.next;\\n        }\\n    };\\n};\\n```\\nComplexity:\\n* Time: O(n * logk)\\n* Space: O(n + k)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        priority_queue<Num, vector<Num>, myCompare> pq;\\n        vector<int> ans = {1};\\n        for(int i : primes)\\n            pq.push(Num(i, 0, i));\\n        for(int i = 1; i < n; ++i) {\\n            int tmp = pq.top().next;\\n            ans.push_back(tmp);\\n\\t\\t\\t//duplicate\\n            while(pq.top().next == tmp) {\\n                Num n = pq.top();\\n                pq.pop();\\n                pq.push(Num(n.prime, n.index + 1, n.prime * ans[n.index + 1]));\\n            }\\n        }\\n        return ans.back();\\n            \\n    }\\nprivate:\\n    struct Num {\\n        int prime;\\n        int index;\\n        int next;\\n        \\n        Num(int p, int i, int n): prime(p), index(i), next(n) {\\n            \\n        }\\n    };\\n    struct myCompare {\\n        bool operator()(Num a, Num b) {\\n            return a.next > b.next;\\n        }\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190607,
                "title": "some-straightforward-java-solution",
                "content": "```\npublic int nthSuperUglyNumber(int n, int[] primes) {\n        if(n <= 0){\n            return 0;\n        }\n        int[] ugly = new int[n];\n        int[] index = new int[primes.length];\n        ugly[0] = 1;\n        int next = 1;\n        while(next < n){\n            ugly[next] = min(ugly, index, primes);\n            for(int i = 0; i < primes.length; i ++){\n                while(ugly[index[i]] * primes[i] <= ugly[next]){\n                    index[i] ++;\n                }\n            }\n            next ++;\n        }\n        return ugly[n - 1];\n    }\n    \n    public int min(int[] ugly, int[] index, int[] primes){\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < index.length; i ++){\n            min = Math.min(min, ugly[index[i]] * primes[i]);\n        }\n        return min;\n    }\n```",
                "solutionTags": [],
                "code": "```\npublic int nthSuperUglyNumber(int n, int[] primes) {\n        if(n <= 0){\n            return 0;\n        }\n        int[] ugly = new int[n];\n        int[] index = new int[primes.length];\n        ugly[0] = 1;\n        int next = 1;\n        while(next < n){\n            ugly[next] = min(ugly, index, primes);\n            for(int i = 0; i < primes.length; i ++){\n                while(ugly[index[i]] * primes[i] <= ugly[next]){\n                    index[i] ++;\n                }\n            }\n            next ++;\n        }\n        return ugly[n - 1];\n    }\n    \n    public int min(int[] ugly, int[] index, int[] primes){\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < index.length; i ++){\n            min = Math.min(min, ugly[index[i]] * primes[i]);\n        }\n        return min;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76293,
                "title": "fast-python-implementation-with-heap-explained",
                "content": "Implementing heap is easy but it may got slowed down by a naive de-duplication algorithm, for example, we can simply keep popping the top elements in the heap until it ran out of duplicates. Here is how I accelerated things up a little bit.\\nNotice that every number in the ugly queue is a product of the given primes, and duplicates are introduced when two prime numbers got flipped in the multiplication, so we can get rid of them by enforcing the ordering of numbers in the multiplication. To do this, I coupled each number in the ugly queue with the last prime number it's generated from, and I skip adding a new number to the heap if a smaller prime number was about to be multiplied with the old number coupled with a bigger prime.\\nThe heap stores the next smallest candidate for each given prime number and the index of the preceding ugly number the candidate is generated from. The prime number itself can be retrieved by a simple division.\\n\\n```\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ugly = [[0,0]] * n #ugly[i][0] = preceding ugly number * ugly[i][1]\\n        ugly[0] = [1,1]\\n        heap = zip(primes,[0]*len(primes)) #heap[i][0] = latent prime number * ugly[heap[i][1]][0]\\n        heapq.heapify(heap)\\n        \\n        for i in xrange(1,n):\\n            heapMin, fromIndex = heapq.heappop(heap)\\n            p = heapMin / ugly[fromIndex][0] #get the ending prime number from the heap\\n            ugly[i] = [heapMin,p]            #and update the ugly queue\\n            fromIndex += 1\\n            \\n            while ugly[fromIndex][1] > p: \\n                fromIndex += 1\\n            #skip the ugly numbers ending with bigger primes\\n            #replacing \">\" with \"<\" also works, but kinda counter-intuitive\\n            heapq.heappush(heap,(ugly[fromIndex][0]*p,fromIndex)) #update the heap\\n            \\n        return ugly[-1][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ugly = [[0,0]] * n #ugly[i][0] = preceding ugly number * ugly[i][1]\\n        ugly[0] = [1,1]\\n        heap = zip(primes,[0]*len(primes)) #heap[i][0] = latent prime number * ugly[heap[i][1]][0]\\n        heapq.heapify(heap)\\n        \\n        for i in xrange(1,n):\\n            heapMin, fromIndex = heapq.heappop(heap)\\n            p = heapMin / ugly[fromIndex][0] #get the ending prime number from the heap\\n            ugly[i] = [heapMin,p]            #and update the ugly queue\\n            fromIndex += 1\\n            \\n            while ugly[fromIndex][1] > p: \\n                fromIndex += 1\\n            #skip the ugly numbers ending with bigger primes\\n            #replacing \">\" with \"<\" also works, but kinda counter-intuitive\\n            heapq.heappush(heap,(ugly[fromIndex][0]*p,fromIndex)) #update the heap\\n            \\n        return ugly[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76334,
                "title": "my-python-heap-solution-556ms",
                "content": "    import heapq\\n    \\n    class Solution(object):\\n        def nthSuperUglyNumber(self, n, primes):\\n            if not n or n < 1 or not primes:\\n                return 0\\n            res = [1]\\n            heap = [(prime, 0, prime) for prime in primes]\\n            heapq.heapify(heap)\\n            for i in xrange(1, n):\\n                val, idx, prime = heapq.heappop(heap)\\n                res.append(val)\\n                heapq.heappush(heap, (res[idx + 1] * prime, idx + 1, prime))\\n                while heap[0][0] <= val:\\n                    _, idx, prime = heapq.heappop(heap)\\n                    heapq.heappush(heap, (res[idx + 1] * prime, idx + 1, prime))\\n            return res[-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    import heapq\\n    \\n    class Solution(object):\\n        def nthSuperUglyNumber(self, n, primes):\\n            if not n or n < 1 or not primes:\\n                return 0\\n            res = [1]\\n            heap = [(prime, 0, prime) for prime in primes]\\n            heapq.heapify(heap)\\n            for i in xrange(1, n):\\n                val, idx, prime = heapq.heappop(heap)\\n                res.append(val)\\n                heapq.heappush(heap, (res[idx + 1] * prime, idx + 1, prime))\\n                while heap[0][0] <= val:\\n                    _, idx, prime = heapq.heappop(heap)\\n                    heapq.heappush(heap, (res[idx + 1] * prime, idx + 1, prime))\\n            return res[-1]",
                "codeTag": "Java"
            },
            {
                "id": 76345,
                "title": "java-31ms-o-nlgk-solution-with-heap",
                "content": "Similar to Ugly Number II, use min-heap to manage numbers.\\n\\n    public int nthSuperUglyNumber(int n, int[] primes){\\n        int[] index = new int[1000];\\n        int[] res = new int[n];\\n        int[] heap = new int[primes.length];\\n        for(int i = 0;i<primes.length; i++)heap[i] = primes[i];\\n        res[0] = 1;\\n        for(int i = 1; i<n;)\\n        {\\n            if(res[i-1] != heap[0]){        \\t\\n            \\tres[i] = heap[0];\\n            \\tSystem.out.print(res[i]+\" \");\\n            \\ti++;\\n            }\\n            updateHeap(heap,primes,index,res);\\n        }\\n        return res[n-1];\\n    }\\n    public void heapify(int[] heap, int[] primes, int i){\\n        int index = i;\\n        int left = 2*i+1; int right = left+1;\\n        if(heap.length>left && heap[i] > heap[left]) index = left;\\n        if(heap.length>right && heap[index] > heap[right]) index = right;\\n        if(i!=index){\\n            int temp = heap[i];\\n            heap[i] = heap[index];\\n            heap[index] = temp;\\n            int tempPri = primes[i];\\n            primes[i] = primes[index];\\n            primes[index] = tempPri;\\n            heapify(heap,primes,index);\\n        }\\n    }\\n    public void updateHeap(int[] heap, int[] primes, int[] index, int[] res)\\n    {\\n        index[primes[0]]++;\\n        heap[0] = res[index[primes[0]]] * primes[0];\\n        heapify(heap,primes,0);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Similar to Ugly Number II, use min-heap to manage numbers.\\n\\n    public int nthSuperUglyNumber(int n, int[] primes){\\n        int[] index = new int[1000];\\n        int[] res = new int[n];\\n        int[] heap = new int[primes.length];\\n        for(int i = 0;i<primes.length; i++)heap[i] = primes[i];\\n        res[0] = 1;\\n        for(int i = 1; i<n;)\\n        {\\n            if(res[i-1] != heap[0]){        \\t\\n            \\tres[i] = heap[0];\\n            \\tSystem.out.print(res[i]+\" \");\\n            \\ti++;\\n            }\\n            updateHeap(heap,primes,index,res);\\n        }\\n        return res[n-1];\\n    }\\n    public void heapify(int[] heap, int[] primes, int i){\\n        int index = i;\\n        int left = 2*i+1; int right = left+1;\\n        if(heap.length>left && heap[i] > heap[left]) index = left;\\n        if(heap.length>right && heap[index] > heap[right]) index = right;\\n        if(i!=index){\\n            int temp = heap[i];\\n            heap[i] = heap[index];\\n            heap[index] = temp;\\n            int tempPri = primes[i];\\n            primes[i] = primes[index];\\n            primes[index] = tempPri;\\n            heapify(heap,primes,index);\\n        }\\n    }\\n    public void updateHeap(int[] heap, int[] primes, int[] index, int[] res)\\n    {\\n        index[primes[0]]++;\\n        heap[0] = res[index[primes[0]]] * primes[0];\\n        heapify(heap,primes,0);\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 76326,
                "title": "112ms-c-solution-with-explanation",
                "content": "    class Solution {\\n    public:\\n        int nthSuperUglyNumber(int n, vector<int>& primes) {\\n            vector<int> superUglyNumbers;\\n            superUglyNumbers.push_back(1);  // first super ugly number\\n            int numPrimes = primes.size();\\n            vector<int> idxs(numPrimes, 0);\\n            // add super ugly number up to nth \\n            while(superUglyNumbers.size() < n)\\n            {\\n                int nextSuperUglyNumber = superUglyNumbers[idxs[0]]*primes[0];   // next super ugly number\\n                for(int i = 0; i < numPrimes; i++)\\n                {\\n                    nextSuperUglyNumber = min(nextSuperUglyNumber, superUglyNumbers[idxs[i]]*primes[i]);\\n                }\\n                for(int i = 0; i < numPrimes; i++)\\n                {\\n                    if(nextSuperUglyNumber == superUglyNumbers[idxs[i]]*primes[i])\\n                    {\\n                        idxs[i]++;\\n                    }\\n                }\\n                superUglyNumbers.push_back(nextSuperUglyNumber);\\n            }\\n            \\n            return superUglyNumbers[n-1];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int nthSuperUglyNumber(int n, vector<int>& primes) {\\n            vector<int> superUglyNumbers;\\n            superUglyNumbers.push_back(1);  // first super ugly number\\n            int numPrimes = primes.size();\\n            vector<int> idxs(numPrimes, 0);\\n            // add super ugly number up to nth \\n            while(superUglyNumbers.size() < n)\\n            {\\n                int nextSuperUglyNumber = superUglyNumbers[idxs[0]]*primes[0];   // next super ugly number\\n                for(int i = 0; i < numPrimes; i++)\\n                {\\n                    nextSuperUglyNumber = min(nextSuperUglyNumber, superUglyNumbers[idxs[i]]*primes[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 76367,
                "title": "c-300ms-solution",
                "content": "First we have to prevent duplicate visiting.\\nFor example when primes = {2,3}\\n\\n    4-12-36\\n    |\\n    2- 6-18-54\\n    |\\n    1- 3- 9-27\\n\\nStarting from 1 (the first number), if we have *3, then we should not *2 further. Similarly, if primes = {2,3,5}, then we should not *2 if we have *3, and should not *2 or *3 if we have *5. \\n\\nNow we can realize this idea by using std::priority_queue. We use pair&lt;int,int&gt; to record current number and the prime index we have multiplied.\\n\\n\\tint nthSuperUglyNumber(const int n, const vector<int>& primes) {\\n\\t\\ttypedef pair<int,int> IP;\\n\\t\\tstruct Comp {\\n\\t\\t\\tbool operator()(const IP &l, const IP &r) {\\n\\t\\t\\t\\treturn l.first > r.first;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tpriority_queue<IP, vector<IP>, Comp> pq;\\n\\t\\tpq.emplace(1, 0);\\n\\t\\tfor (int i = 1;; ++i) {\\n\\t\\t\\tconst IP t = pq.top();\\n\\t\\t\\tif (i == n) {\\n\\t\\t\\t\\treturn t.first;\\n\\t\\t\\t}\\n\\t\\t\\tpq.pop();\\n\\t\\t\\tfor (int j = t.second; j < primes.size(); ++j) {\\n\\t\\t\\t\\tconst long long lltmp = static_cast<long long>(t.first) * primes[j];\\n\\t\\t\\t\\tconst int itmp = static_cast<int>(lltmp);\\n\\t\\t\\t\\tif (itmp != lltmp) {\\n\\t\\t\\t\\t\\t// overflow, WTF\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tassert(itmp > 0);\\n\\t\\t\\t\\tpq.emplace(itmp, j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tassert(0);\\n\\t\\treturn 0;\\n\\t}",
                "solutionTags": [
                    "C++"
                ],
                "code": "First we have to prevent duplicate visiting.\\nFor example when primes = {2,3}\\n\\n    4-12-36\\n    |\\n    2- 6-18-54\\n    |\\n    1- 3- 9-27\\n\\nStarting from 1 (the first number), if we have *3, then we should not *2 further. Similarly, if primes = {2,3,5}, then we should not *2 if we have *3, and should not *2 or *3 if we have *5. \\n\\nNow we can realize this idea by using std::priority_queue. We use pair&lt;int,int&gt; to record current number and the prime index we have multiplied.\\n\\n\\tint nthSuperUglyNumber(const int n, const vector<int>& primes) {\\n\\t\\ttypedef pair<int,int> IP;\\n\\t\\tstruct Comp {\\n\\t\\t\\tbool operator()(const IP &l, const IP &r) {\\n\\t\\t\\t\\treturn l.first > r.first;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tpriority_queue<IP, vector<IP>, Comp> pq;\\n\\t\\tpq.emplace(1, 0);\\n\\t\\tfor (int i = 1;; ++i) {\\n\\t\\t\\tconst IP t = pq.top();\\n\\t\\t\\tif (i == n) {\\n\\t\\t\\t\\treturn t.first;\\n\\t\\t\\t}\\n\\t\\t\\tpq.pop();\\n\\t\\t\\tfor (int j = t.second; j < primes.size(); ++j) {\\n\\t\\t\\t\\tconst long long lltmp = static_cast<long long>(t.first) * primes[j];\\n\\t\\t\\t\\tconst int itmp = static_cast<int>(lltmp);\\n\\t\\t\\t\\tif (itmp != lltmp) {\\n\\t\\t\\t\\t\\t// overflow, WTF\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tassert(itmp > 0);\\n\\t\\t\\t\\tpq.emplace(itmp, j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tassert(0);\\n\\t\\treturn 0;\\n\\t}",
                "codeTag": "Python3"
            },
            {
                "id": 76347,
                "title": "i-just-don-t-get-it-why-c-is-slower-than-java",
                "content": "I'm familiar with C/C++, so most of my solution are written in C/C++.\\n\\nBut why C is so much slower than Java now? Have you changed the judge compiler or something backend?\\n\\nI have three solutions in Java/C/C++ using the same algorithm, and the running time list below:\\n\\n    Java 94 ms, C 204 ms, C++ 552 ms\\n\\nC code:\\n\\n    int nthSuperUglyNumber(int n, int* primes, int primesSize) {\\n        if (n <= 0 || primesSize <= 0) return 1;\\n    \\n        int *index = (int *)calloc(primesSize, sizeof(int));\\n        int *nums = (int *)calloc(n, sizeof(int));\\n    \\n        nums[0] = 1;\\n        int storageIndex = 1;\\n    \\n        while (storageIndex < n) {\\n            int min = (1 << 31) - 1;\\n            for (int i = 0; i < primesSize; i++) {\\n                if (nums[index[i]] * primes[i] < min) {\\n                    min = nums[index[i]] * primes[i];\\n                }\\n            }\\n            nums[storageIndex++] = min;\\n            for (int i = 0; i < primesSize; i++) {\\n                if (nums[index[i]] * primes[i] == min) {\\n                    index[i]++;\\n                }\\n            }\\n        }\\n\\n        int ans = nums[n - 1];\\n        free(index);\\n        free(nums);\\n    \\n        return ans;\\n    }\\n\\nJava Code:\\n\\n    public class Solution {\\n        public int nthSuperUglyNumber(int n, int[] primes) {\\n            int k = primes.length;\\n            if (k == 0 || n <= 0) return 1;\\n            \\n            int[] index = new int[k];\\n            int[] nums = new int[n];\\n    \\n            nums[0] = 1;\\n            \\n            int i = 1;\\n            while (i < n) {\\n                int min = (1 << 31) - 1;\\n                for (int j = 0; j < k; j++) {\\n                    if (nums[index[j]] * primes[j] < min) {\\n                        min = nums[index[j]] * primes[j];\\n                    }\\n                }\\n                nums[i++] = min;\\n                for (int j = 0; j < k; j++) {\\n                    if (nums[index[j]] * primes[j] == min) {\\n                        index[j]++;\\n                    }\\n                }\\n            }\\n            \\n            return nums[n - 1];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int nthSuperUglyNumber(int n, int[] primes) {\\n            int k = primes.length;\\n            if (k == 0 || n <= 0) return 1;\\n            \\n            int[] index = new int[k];\\n            int[] nums = new int[n];\\n    \\n            nums[0] = 1;\\n            \\n            int i = 1;\\n            while (i < n) {\\n                int min = (1 << 31) - 1;\\n                for (int j = 0; j < k; j++) {\\n                    if (nums[index[j]] * primes[j] < min) {\\n                        min = nums[index[j]] * primes[j];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 76302,
                "title": "is-the-time-limit-too-strict-for-ruby",
                "content": "First I tried a solution based on Ugly Number II, but got TLE.\\n\\n    def nth_super_ugly_number(n, primes)\\n        nums = Array.new(n, 1)\\n      qs, is = Array.new(primes.size, 1), Array.new(primes.size, 0)\\n    \\n      1.upto(n - 1) do |i|\\n        primes.each_with_index { |prime, idx| qs[idx] = nums[is[idx]] * prime }\\n        nums[i] = qs.min\\n        is.each_with_index { |_, idx| is[idx] += 1 if qs[idx] == nums[i] }\\n      end\\n    \\n      nums[n - 1]\\n    end\\n\\n\\nThen I tryied to solve it using a priority queue, but still got LTE. (**Note Ruby has no built-in priority queue, you have to implement it yourself**)\\n\\n    class PriorityQueue\\n      def initialize(cmp)\\n        @queue, @cmp = [], cmp\\n      end\\n    \\n      def <<(value)\\n        @queue << value; _swim_(@queue.size - 1); self\\n      end\\n    \\n      def shift\\n        @queue[0], @queue[-1] = @queue[-1], @queue[0]\\n        @queue.pop.tap { _sink_(0) }\\n      end\\n    \\n      def peek\\n        @queue[0]\\n      end\\n    \\n      def empty?\\n        @queue.empty?\\n      end\\n    \\n      private def _swim_(k)\\n        while k > 0 && @cmp.call(@queue[k], @queue[(k - 1) / 2])\\n          @queue[k], @queue[(k - 1) / 2] = @queue[(k - 1) / 2], @queue[k]\\n          k = (k - 1) / 2\\n        end\\n      end\\n    \\n      private def _sink_(k)\\n        while k * 2 + 1 < @queue.size\\n          kk  = k * 2 + 1\\n          kk += 1 if @queue[kk + 1] && @cmp.call(@queue[kk + 1], @queue[kk])\\n          break if @cmp.call(@queue[k], @queue[kk])\\n    \\n          @queue[k], @queue[kk] = @queue[kk], @queue[k]\\n          k = kk\\n        end\\n      end\\n    end\\n    \\n    \\n    # @param {Integer} n\\n    # @param {Integer[]} primes\\n    # @return {Integer}\\n    def nth_super_ugly_number(n, primes)\\n       nums = Array.new(n, 1)\\n      minpq = PriorityQueue.new(Proc.new{ |(_, _, n1), (_, _, n2)| n1 < n2 })\\n    \\n      primes.each_with_index do |prime, index|\\n        minpq << [index, prime, prime]\\n      end\\n    \\n      1.upto(n - 1) do |i|\\n        nums[i] = minpq.peek[2]\\n    \\n        loop do\\n          index, prime, _ = minpq.shift\\n          minpq << [index + 1, prime, nums[index] * prime]\\n          break if minpq.empty? || minpq.peek[2] != nums[i]\\n        end\\n      end\\n    \\n      nums[n - 1]\\n    end\\n\\n\\nI did some tricks to speed up, but failed. Any suggestion?",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "First I tried a solution based on Ugly Number II, but got TLE.\\n\\n    def nth_super_ugly_number(n, primes)\\n        nums = Array.new(n, 1)\\n      qs, is = Array.new(primes.size, 1), Array.new(primes.size, 0)\\n    \\n      1.upto(n - 1) do |i|\\n        primes.each_with_index { |prime, idx| qs[idx] = nums[is[idx]] * prime }\\n        nums[i] = qs.min\\n        is.each_with_index { |_, idx| is[idx] += 1 if qs[idx] == nums[i] }\\n      end\\n    \\n      nums[n - 1]\\n    end\\n\\n\\nThen I tryied to solve it using a priority queue, but still got LTE. (**Note Ruby has no built-in priority queue, you have to implement it yourself**)\\n\\n    class PriorityQueue\\n      def initialize(cmp)\\n        @queue, @cmp = [], cmp\\n      end\\n    \\n      def <<(value)\\n        @queue << value; _swim_(@queue.size - 1); self\\n      end\\n    \\n      def shift\\n        @queue[0], @queue[-1] = @queue[-1], @queue[0]\\n        @queue.pop.tap { _sink_(0) }\\n      end\\n    \\n      def peek\\n        @queue[0]\\n      end\\n    \\n      def empty?\\n        @queue.empty?\\n      end\\n    \\n      private def _swim_(k)\\n        while k > 0 && @cmp.call(@queue[k], @queue[(k - 1) / 2])\\n          @queue[k], @queue[(k - 1) / 2] = @queue[(k - 1) / 2], @queue[k]\\n          k = (k - 1) / 2\\n        end\\n      end\\n    \\n      private def _sink_(k)\\n        while k * 2 + 1 < @queue.size\\n          kk  = k * 2 + 1\\n          kk += 1 if @queue[kk + 1] && @cmp.call(@queue[kk + 1], @queue[kk])\\n          break if @cmp.call(@queue[k], @queue[kk])\\n    \\n          @queue[k], @queue[kk] = @queue[kk], @queue[k]\\n          k = kk\\n        end\\n      end\\n    end\\n    \\n    \\n    # @param {Integer} n\\n    # @param {Integer[]} primes\\n    # @return {Integer}\\n    def nth_super_ugly_number(n, primes)\\n       nums = Array.new(n, 1)\\n      minpq = PriorityQueue.new(Proc.new{ |(_, _, n1), (_, _, n2)| n1 < n2 })\\n    \\n      primes.each_with_index do |prime, index|\\n        minpq << [index, prime, prime]\\n      end\\n    \\n      1.upto(n - 1) do |i|\\n        nums[i] = minpq.peek[2]\\n    \\n        loop do\\n          index, prime, _ = minpq.shift\\n          minpq << [index + 1, prime, nums[index] * prime]\\n          break if minpq.empty? || minpq.peek[2] != nums[i]\\n        end\\n      end\\n    \\n      nums[n - 1]\\n    end\\n\\n\\nI did some tricks to speed up, but failed. Any suggestion?",
                "codeTag": "Java"
            },
            {
                "id": 3894645,
                "title": "c-memoization-best-solution",
                "content": "# Intuition\\nSolution Using Memoization Using same concept as in Ugly 2\\n\\n# Approach\\nMemoization\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<long long>& dp, int n, int i, vector<int>& primes, vector<long long>& indices) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        long long nextUgly = INT_MAX;\\n        for (int j = 0; j < primes.size(); ++j) {\\n            nextUgly = min(nextUgly, dp[indices[j]] * primes[j]);\\n        }\\n\\n        dp[i] = nextUgly;\\n\\n        for (int j = 0; j < primes.size(); ++j) {\\n            if (dp[indices[j]] * primes[j] == nextUgly) {\\n                indices[j]++;\\n            }\\n        }\\n\\n        return solve(dp, n, i + 1, primes, indices);\\n    }\\n\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<long long> dp(n, -1);\\n        dp[0] = 1;\\n        vector<long long> indices(primes.size(), 0);\\n\\n        return solve(dp, n, 1, primes, indices);\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<long long>& dp, int n, int i, vector<int>& primes, vector<long long>& indices) {\\n        if (i == n) {\\n            return dp[n - 1];\\n        }\\n\\n        long long nextUgly = INT_MAX;\\n        for (int j = 0; j < primes.size(); ++j) {\\n            nextUgly = min(nextUgly, dp[indices[j]] * primes[j]);\\n        }\\n\\n        dp[i] = nextUgly;\\n\\n        for (int j = 0; j < primes.size(); ++j) {\\n            if (dp[indices[j]] * primes[j] == nextUgly) {\\n                indices[j]++;\\n            }\\n        }\\n\\n        return solve(dp, n, i + 1, primes, indices);\\n    }\\n\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<long long> dp(n, -1);\\n        dp[0] = 1;\\n        vector<long long> indices(primes.size(), 0);\\n\\n        return solve(dp, n, 1, primes, indices);\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871241,
                "title": "",
                "content": "**<<< 264. Ugly Number II**\\n\\nhttps://leetcode.com/problems/ugly-number-ii/solutions/3709599/easy-to-understand/\\n\\n# Code\\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        long[] dp=new long[n];\\n        dp[0]=1;\\n        int[] indexArr=new int[primes.length];\\n        for(int i=1; i<n; i++){\\n            long minValue=Long.MAX_VALUE;\\n            for(int j=0; j<primes.length; j++){\\n                minValue=Math.min(minValue,dp[indexArr[j]]*primes[j]);\\n            }\\n            dp[i]=minValue;\\n            for(int j=0; j<primes.length; j++){\\n                if(dp[i]==dp[indexArr[j]]*primes[j]){\\n                    indexArr[j]++;\\n                }\\n            }\\n        }\\n        return (int)dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        long[] dp=new long[n];\\n        dp[0]=1;\\n        int[] indexArr=new int[primes.length];\\n        for(int i=1; i<n; i++){\\n            long minValue=Long.MAX_VALUE;\\n            for(int j=0; j<primes.length; j++){\\n                minValue=Math.min(minValue,dp[indexArr[j]]*primes[j]);\\n            }\\n            dp[i]=minValue;\\n            for(int j=0; j<primes.length; j++){\\n                if(dp[i]==dp[indexArr[j]]*primes[j]){\\n                    indexArr[j]++;\\n                }\\n            }\\n        }\\n        return (int)dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552629,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n       \\n\\n    int s = primes.size();\\n    vector<int> idx(s,0);\\n    vector<int> dp(n,1);\\n\\n    for(int i=1;i<n;i++){\\n        int m = INT_MAX;\\n\\n        for(int j=0;j<s;j++){\\n            long long k =  ((long long)primes[j]*dp[idx[j]]);\\nif(k >= INT_MAX){\\n    continue;\\n}\\nint  r = (int)k;\\n            m = min(m ,r);\\n        }\\n\\n        for(int j=0;j<s;j++){\\n            long long k = ((long long)primes[j]*dp[idx[j]]);\\n            if(k >= INT_MAX){\\n    continue;\\n}\\n            k = (int)k;\\n            if(m == k){\\n                idx[j]++;\\n            }\\n        }\\n        dp[i] = m;\\n    }\\nreturn dp[n-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n       \\n\\n    int s = primes.size();\\n    vector<int> idx(s,0);\\n    vector<int> dp(n,1);\\n\\n    for(int i=1;i<n;i++){\\n        int m = INT_MAX;\\n\\n        for(int j=0;j<s;j++){\\n            long long k =  ((long long)primes[j]*dp[idx[j]]);\\nif(k >= INT_MAX){\\n    continue;\\n}\\nint  r = (int)k;\\n            m = min(m ,r);\\n        }\\n\\n        for(int j=0;j<s;j++){\\n            long long k = ((long long)primes[j]*dp[idx[j]]);\\n            if(k >= INT_MAX){\\n    continue;\\n}\\n            k = (int)k;\\n            if(m == k){\\n                idx[j]++;\\n            }\\n        }\\n        dp[i] = m;\\n    }\\nreturn dp[n-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319042,
                "title": "100-working-solution-without-tle-in-java-dp",
                "content": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int m= primes.length;\\n        PriorityQueue<int[]> q= new PriorityQueue<>((a,b) -> a[2]-b[2]);\\n        for(int i=0; i<m; i++){\\n            q.add(new int[]{primes[i],1,primes[i]});\\n        }\\n        \\n        int[] dp= new int[n+1];\\n        dp[0]=0;\\n        dp[1]=1;\\n        for(int i=2; i<=n;){\\n            int[] cur= q.poll();\\n            if(dp[i-1]!=cur[2]){\\n                dp[i]= cur[2];\\n                i++;\\n            }\\n            \\n            q.add(new int[]{cur[0],cur[1]+1, cur[0]*dp[cur[1]+1]});\\n        }\\n        \\n        return dp[n];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int m= primes.length;\\n        PriorityQueue<int[]> q= new PriorityQueue<>((a,b) -> a[2]-b[2]);\\n        for(int i=0; i<m; i++){\\n            q.add(new int[]{primes[i],1,primes[i]}",
                "codeTag": "Java"
            },
            {
                "id": 3258641,
                "title": "java-easy-to-understand-dp-solution",
                "content": "\\nJust like the ugly number 2 question .\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n       long dp[] = new long[n+1];\\n        int pointers[] = new int[primes.length];\\n        dp[0] = 1;\\n        for(int i =1;i<dp.length;i++){\\n            dp[i] = Integer.MAX_VALUE;\\n            for(int j =0;j<primes.length;j++){\\n                dp[i] = Math.min(dp[i],dp[pointers[j]]*primes[j]);\\n            }\\n            for(int j =0;j<primes.length;j++){\\n                if(dp[i] == dp[pointers[j]]*primes[j]){\\n                    pointers[j]++;\\n                }\\n            }\\n        }\\n        return (int)dp[n-1];\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\u2028link-- \\nhttps://github.com/AnkitaGoyalD2004?tab=repositories",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n       long dp[] = new long[n+1];\\n        int pointers[] = new int[primes.length];\\n        dp[0] = 1;\\n        for(int i =1;i<dp.length;i++){\\n            dp[i] = Integer.MAX_VALUE;\\n            for(int j =0;j<primes.length;j++){\\n                dp[i] = Math.min(dp[i],dp[pointers[j]]*primes[j]);\\n            }\\n            for(int j =0;j<primes.length;j++){\\n                if(dp[i] == dp[pointers[j]]*primes[j]){\\n                    pointers[j]++;\\n                }\\n            }\\n        }\\n        return (int)dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220721,
                "title": "solution-using-dp-c-two-approaches",
                "content": "# Approach 1 (Brute Force)\\nGives TLE for n=100000\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int N=primes.size();\\n        vector<long long> dp(n+1);\\n        dp[1]=1;\\n        for(int i=2;i<=n;i++){\\n            long long min_ans=INT_MAX;\\n            for(int j=1;j<i;j++){\\n                for(int k=0;k<N;k++){\\n                    if(primes[k]*dp[j]>dp[i-1]){\\n                        min_ans=min(min_ans,primes[k]*dp[j]);\\n                    }\\n                }\\n            }\\n            dp[i]=min_ans;\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n# Approach 2 (optimized)\\nusing Min Heap\\nACCEPTED\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int N=primes.size();\\n        priority_queue<long long,vector<long long>,greater<long long>> pq;\\n        vector<long long> dp(n+1);\\n        dp[1]=1;\\n        for(int i=2;i<=n;i++){\\n            int j=i-1;\\n            for(int k=0;k<N;k++){\\n                pq.push(dp[j]*primes[k]);\\n            }\\n            while(pq.top()<=dp[j]){\\n                pq.pop();\\n            }\\n            dp[i]=pq.top();\\n            pq.pop();\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int N=primes.size();\\n        vector<long long> dp(n+1);\\n        dp[1]=1;\\n        for(int i=2;i<=n;i++){\\n            long long min_ans=INT_MAX;\\n            for(int j=1;j<i;j++){\\n                for(int k=0;k<N;k++){\\n                    if(primes[k]*dp[j]>dp[i-1]){\\n                        min_ans=min(min_ans,primes[k]*dp[j]);\\n                    }\\n                }\\n            }\\n            dp[i]=min_ans;\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int N=primes.size();\\n        priority_queue<long long,vector<long long>,greater<long long>> pq;\\n        vector<long long> dp(n+1);\\n        dp[1]=1;\\n        for(int i=2;i<=n;i++){\\n            int j=i-1;\\n            for(int k=0;k<N;k++){\\n                pq.push(dp[j]*primes[k]);\\n            }\\n            while(pq.top()<=dp[j]){\\n                pq.pop();\\n            }\\n            dp[i]=pq.top();\\n            pq.pop();\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077728,
                "title": "python-my-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        l=[1]\\n        a=[0 for _ in range(len(primes))]\\n        for i in range(n-1):\\n            t=[primes[i]*l[a[i]] for i in range(len(primes))]\\n            m=min(t)\\n            for j in range(len(t)):\\n                if t[j]==m:\\n                    a[j]+=1\\n            l.append(m) \\n        return l[-1]            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        l=[1]\\n        a=[0 for _ in range(len(primes))]\\n        for i in range(n-1):\\n            t=[primes[i]*l[a[i]] for i in range(len(primes))]\\n            m=min(t)\\n            for j in range(len(t)):\\n                if t[j]==m:\\n                    a[j]+=1\\n            l.append(m) \\n        return l[-1]            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869878,
                "title": "c-priority-queue-min-heap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes)\\n    {\\n        typedef long long ll;\\n        vector<ll> ugly(n,-1);\\n        ll i=0;\\n        cout<<primes.size();\\n        priority_queue<ll,vector<ll>,greater<ll>> pq;\\n        pq.push(1);\\n        while(!pq.empty()&&ugly[n-1]==-1)\\n        {\\n            ll temp=pq.top();\\n            ugly[i++]=temp;\\n            for(auto &x:primes)\\n            {\\n                pq.push(temp*x);\\n            }\\n            while(!pq.empty()&&temp==pq.top())\\n            {\\n                pq.pop();\\n            }\\n        }\\n        return ugly[n-1];\\n        \\n        \\n    }\\n};\\n//if you lke the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes)\\n    {\\n        typedef long long ll;\\n        vector<ll> ugly(n,-1);\\n        ll i=0;\\n        cout<<primes.size();\\n        priority_queue<ll,vector<ll>,greater<ll>> pq;\\n        pq.push(1);\\n        while(!pq.empty()&&ugly[n-1]==-1)\\n        {\\n            ll temp=pq.top();\\n            ugly[i++]=temp;\\n            for(auto &x:primes)\\n            {\\n                pq.push(temp*x);\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 2767482,
                "title": "easy-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if(n == 1)  return 1;\\n        \\n        int k = primes.size();\\n        vector<int> idx(k, 0);\\n        \\n        int ugly[n];\\n        // memset(ugly, 0, sizeof(ugly));\\n        ugly[0] = 1;\\n        \\n        for (int i=1; i<n; i++){\\n            \\n            long minVal = INT_MAX;\\n            for (int j=0; j<k; j++){\\n                minVal = min(minVal, (long)primes[j] * ugly[idx[j]]);\\n            }\\n            \\n            ugly[i] = (int)minVal;\\n            for (int j=0; j<k; j++){\\n                if(minVal == (long)primes[j] * ugly[idx[j]]){\\n                    idx[j]++;\\n                }\\n            }\\n            // cout<<ugly[i]<<\",\";\\n        }\\n        \\n        return ugly[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if(n == 1)  return 1;\\n        \\n        int k = primes.size();\\n        vector<int> idx(k, 0);\\n        \\n        int ugly[n];\\n        // memset(ugly, 0, sizeof(ugly));\\n        ugly[0] = 1;\\n        \\n        for (int i=1; i<n; i++){\\n            \\n            long minVal = INT_MAX;\\n            for (int j=0; j<k; j++){\\n                minVal = min(minVal, (long)primes[j] * ugly[idx[j]]);\\n            }\\n            \\n            ugly[i] = (int)minVal;\\n            for (int j=0; j<k; j++){\\n                if(minVal == (long)primes[j] * ugly[idx[j]]){\\n                    idx[j]++;\\n                }\\n            }\\n            // cout<<ugly[i]<<\",\";\\n        }\\n        \\n        return ugly[n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2674993,
                "title": "o-nlogk-o-n-approach-easily-understandable-code",
                "content": "Please Correct me if I\\'m wrong, Doesn\\'t the below code runs with O(N) complexity? because primes.length() will be<=100 and n<=100000 , which makes queue operations <=100log100===Constant ?!!?\\tSo O(Nlogk)==O(N). Want feedback on this ..pls revert @anyone\\n\\n\\nAlso **UPVOTE** if this code helps \\uD83E\\uDD17\\n *I can explain pictorially, pls mention in comments if u want! *\\n\\t\\n\\t\\n\\t#define ll long long int\\n\\n\\tclass Compare\\n\\t{\\n\\tpublic:\\n\\tbool operator() (pair<ll, ll>&a, pair<ll, ll>&b)\\n\\t{\\n\\t\\treturn a.first * a.second > b.first * b.second;\\n\\t}\\n\\t};\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\tint nthSuperUglyNumber(int n, vector<int>& primes) {\\n\\n\\t\\tpriority_queue<pair<ll, ll>, vector<pair<ll, ll>>, Compare> pq;\\n\\n\\t\\tint len = 1;\\n\\t\\tunordered_map<int, int>next;\\n\\t\\tll prev = 1;\\n\\n\\t\\tll ans = 1;\\n\\n\\t\\tfor (int i = 0; i < primes.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tpq.push({primes[i], 1});\\n\\t\\t}\\n\\n\\t\\twhile (len < n)\\n\\t\\t{\\n\\t\\t\\tll num = pq.top().first;\\n\\t\\t\\tll mul = pq.top().second;\\n\\t\\t\\tpq.pop();\\n\\t\\t\\tans = mul * num;\\n            \\n            while(pq.top().first*pq.top().second==ans)\\n            {\\n                pq.push({pq.top().first,next[pq.top().second]});\\n                pq.pop();\\n            }\\n            \\n            len++;\\n\\t\\t\\tnext[prev] = ans;\\n            prev=ans;\\n\\t\\t\\tpq.push({num, next[mul]});\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\n\\t}\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\tint nthSuperUglyNumber(int n, vector<int>& primes) {\\n\\n\\t\\tpriority_queue<pair<ll, ll>, vector<pair<ll, ll>>, Compare> pq;\\n\\n\\t\\tint len = 1;\\n\\t\\tunordered_map<int, int>next;\\n\\t\\tll prev = 1;\\n\\n\\t\\tll ans = 1;\\n\\n\\t\\tfor (int i = 0; i < primes.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tpq.push({primes[i], 1}",
                "codeTag": "Java"
            },
            {
                "id": 2617234,
                "title": "python-one-heap-two-optimizations",
                "content": "Heap optimized solution is an implementation of a solution provided [here](https://leetcode.com/problems/super-ugly-number/discuss/169815/Python-DP-solution-beats-93.7-extremely-detailed-explanation).\\n\\n**Solution**:\\nUgly number is a number that composed of a multiple of given prime numbers. Thus, we start by initializing a heap with a value of 1. Then, to find an ugly number, we simply pop the smallest number from the heap. Next, we use the last ugly number and multiply it with each prime numbers and add those numbers into the heap. Repeat until we found n-th ugly number. \\n\\n1. Avoid Duplication\\nSince we take the last ugly number and multiply it with all prime numbers, there will be duplicated ugly numbers. ie given primes=[2, 7], duplicate ugly numbers are 1*2*7 and 1*7*2. Thus, we can avoid such duplication by saving the index of the prime number that was used to generate each ugly number. Then, we can calculate next ugly numbers by multiplying the current ugly number with prime numbers starting from such index.\\n\\n2. Heap Optimized\\nWe can optimize above solution further by avoiding populating heap with ugly numbers that we might not need. \\n```\\n    For example: given primes = [2, 7, 13, 19] and n = 3\\n    ugly        heap\\n    [1]         [2, 7, 13, 19]\\n    [1, 2]      [4, 7, 13, 14, 19, 26, 38]\\n    [1, 2, 4]   [7, 8, 13, 14, 19, 26, 28, 38, 52, 76]\\n```\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We end up calculating future ugly numbers when a more recent one hasn\\'t been picked yet. Ex: ugly[2] * 13 is calculated when ugly[0] * 13 isn\\'t even picked yet.  \\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To avoid above problem, we will keep track of a prime number and a previous ugly number used to generate each ugly number. When we pick an ugly number from the heap, we only have to calculate a single next ugly number by taking the prime number multiply by the current ugly number. \\n\\n```\\n    ugly        primes -> ugly                  heap\\n    [1]         {2:0, 7:0, 13:0, 19:0}          [2, 7, 13, 19]\\n    [1, 2]      {2:1, 7:0, 13:0, 19:0}          [4, 7, 13, 19]\\n    [1, 2, 4]   {2:2, 7:0, 13:0, 19:0}          [7, 8, 13, 19]\\n```\\n**Complexity**:\\nTime: \\n1. O(nlog(k\\\\**n)) \\n2. O(nlogk)\\n\\nSpace:  \\n1. O(k\\\\**n)    \\n2. O(k)\\n\\n```\\nimport heapq\\n\\n# Avoid Duplication Solution\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: list[int]) -> int:\\n\\n        # Find number of prime numbers\\n        k = len(primes)\\n\\n        # Intialize the heap\\n        heap = [(1, 0)]\\n\\n        # Intialize the result\\n        res = 0\\n\\n        # Calculate n ugly numbers\\n        for _ in range(n):\\n\\n            # Pop an ugly number and an index of the prime number used to generate such ugly number from the heap \\n            res, j = heapq.heappop(heap)\\n\\n            # Calculate next ugly numbers starting from the above index\\n            for i in range(j, k):\\n                heapq.heappush(heap, (res * primes[i], i))\\n\\n        return res\\n```\\n```\\n# Heap Optimized Solution\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: list[int]) -> int:\\n\\n        # Intialize the result\\n        res = [1]\\n\\n        # Intialzie the heap storing (ugly number, prime, index of previous ugly number)\\n        heap = [(prime * res[0], prime, 0) for prime in primes]\\n        heapq.heapify(heap)\\n\\n        # While we haven\\'t found n ugly number yet\\n        while len(res) < n:\\n\\n            # Pop an ugly number from the heap\\n            ugly, prime, i = heapq.heappop(heap)\\n\\n            # Append such ugly number into the result if it isn\\'t a duplicate\\n            if ugly != res[-1]:\\n                res.append(ugly)\\n\\n            # Calcualte the next ugly number and append it onto the heap\\n            heapq.heappush(heap, (prime * res[i + 1], prime, i + 1))\\n\\n        return res[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    For example: given primes = [2, 7, 13, 19] and n = 3\\n    ugly        heap\\n    [1]         [2, 7, 13, 19]\\n    [1, 2]      [4, 7, 13, 14, 19, 26, 38]\\n    [1, 2, 4]   [7, 8, 13, 14, 19, 26, 28, 38, 52, 76]\\n```\n```\\n    ugly        primes -> ugly                  heap\\n    [1]         {2:0, 7:0, 13:0, 19:0}          [2, 7, 13, 19]\\n    [1, 2]      {2:1, 7:0, 13:0, 19:0}          [4, 7, 13, 19]\\n    [1, 2, 4]   {2:2, 7:0, 13:0, 19:0}          [7, 8, 13, 19]\\n```\n```\\nimport heapq\\n\\n# Avoid Duplication Solution\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: list[int]) -> int:\\n\\n        # Find number of prime numbers\\n        k = len(primes)\\n\\n        # Intialize the heap\\n        heap = [(1, 0)]\\n\\n        # Intialize the result\\n        res = 0\\n\\n        # Calculate n ugly numbers\\n        for _ in range(n):\\n\\n            # Pop an ugly number and an index of the prime number used to generate such ugly number from the heap \\n            res, j = heapq.heappop(heap)\\n\\n            # Calculate next ugly numbers starting from the above index\\n            for i in range(j, k):\\n                heapq.heappush(heap, (res * primes[i], i))\\n\\n        return res\\n```\n```\\n# Heap Optimized Solution\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: list[int]) -> int:\\n\\n        # Intialize the result\\n        res = [1]\\n\\n        # Intialzie the heap storing (ugly number, prime, index of previous ugly number)\\n        heap = [(prime * res[0], prime, 0) for prime in primes]\\n        heapq.heapify(heap)\\n\\n        # While we haven\\'t found n ugly number yet\\n        while len(res) < n:\\n\\n            # Pop an ugly number from the heap\\n            ugly, prime, i = heapq.heappop(heap)\\n\\n            # Append such ugly number into the result if it isn\\'t a duplicate\\n            if ugly != res[-1]:\\n                res.append(ugly)\\n\\n            # Calcualte the next ugly number and append it onto the heap\\n            heapq.heappush(heap, (prime * res[i + 1], prime, i + 1))\\n\\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510440,
                "title": "c-solution-similar-to-ugly-number-2-super-ugly-number",
                "content": "```\\nint nthSuperUglyNumber(int n, vector<int>& primes) \\n    {\\n        if(n==1)\\n            return n;\\n        vector<int> dp(n+1,0);\\n        dp[1]=1;\\n        vector<int> lst(primes.size() , 1);\\n        \\n        for(int i=2 ; i<=n ; i++)\\n        {\\n            long long m = INT_MAX;\\n            for(int j=0 ; j<primes.size() ; j++)\\n            {\\n                long long ans = (long long)dp[lst[j]] * (long long)primes[j];\\n                m= min( m , ans);\\n            }\\n            dp[i]=m;\\n            \\n            for(int j=0 ; j<primes.size() ; j++)\\n                if( m == (long long)dp[lst[j]] * (long long)primes[j])\\n                    lst[j]++;\\n            \\n        }\\n        return dp[n];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint nthSuperUglyNumber(int n, vector<int>& primes) \\n    {\\n        if(n==1)\\n            return n;\\n        vector<int> dp(n+1,0);\\n        dp[1]=1;\\n        vector<int> lst(primes.size() , 1);\\n        \\n        for(int i=2 ; i<=n ; i++)\\n        {\\n            long long m = INT_MAX;\\n            for(int j=0 ; j<primes.size() ; j++)\\n            {\\n                long long ans = (long long)dp[lst[j]] * (long long)primes[j];\\n                m= min( m , ans);\\n            }\\n            dp[i]=m;\\n            \\n            for(int j=0 ; j<primes.size() ; j++)\\n                if( m == (long long)dp[lst[j]] * (long long)primes[j])\\n                    lst[j]++;\\n            \\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2496940,
                "title": "python-concise-code-heap",
                "content": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        \\n        heap = [1]\\n        \\n        while n:\\n            node = heappop(heap)\\n            while heap and node == heap[0]:\\n                heappop(heap)\\n            for i in primes:\\n                heappush(heap, i * node)\\n            n = n - 1\\n        return node\\n                    \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        \\n        heap = [1]\\n        \\n        while n:\\n            node = heappop(heap)\\n            while heap and node == heap[0]:\\n                heappop(heap)\\n            for i in primes:\\n                heappush(heap, i * node)\\n            n = n - 1\\n        return node\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 2382675,
                "title": "c-easily-understandable-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& arr) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]]=1;\\n        }\\n        vector<long long int>dp(n+1,0);\\n        dp[1]=1;\\n        long long int temp=0;\\n        int v;\\n        for(int i=2;i<=n;i++)\\n        {\\n            temp=INT_MAX;\\n            for(int j=0;j<arr.size();j++)\\n            {\\n                long long int count=mp[arr[j]];\\n                if(temp>(dp[count]*arr[j]))\\n                {\\n                    temp=dp[count]*arr[j];\\n                    v=arr[j];\\n                }\\n                else if(temp==(dp[count]*arr[j]))\\n                {\\n                    mp[arr[j]]++;\\n                }\\n            }\\n            mp[v]++;\\n            dp[i]=temp;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& arr) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]]=1;\\n        }\\n        vector<long long int>dp(n+1,0);\\n        dp[1]=1;\\n        long long int temp=0;\\n        int v;\\n        for(int i=2;i<=n;i++)\\n        {\\n            temp=INT_MAX;\\n            for(int j=0;j<arr.size();j++)\\n            {\\n                long long int count=mp[arr[j]];\\n                if(temp>(dp[count]*arr[j]))\\n                {\\n                    temp=dp[count]*arr[j];\\n                    v=arr[j];\\n                }\\n                else if(temp==(dp[count]*arr[j]))\\n                {\\n                    mp[arr[j]]++;\\n                }\\n            }\\n            mp[v]++;\\n            dp[i]=temp;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317107,
                "title": "python-solution-based-on-o-nk-complexity-notes-70-less-space",
                "content": "```\\n\"\"\"\\napproach\\ninitialize pointers = [0, 0, 0...0k]\\npointer[i] will point to the index of the number array for the ith prime\\nnumber array will store the ugly number\\n\\nprimes = [2, 3, 5], ptrs = [0, 0, 0], numbers = [1]\\nget the minimum of primes[i] * numbers[ptrs[i]] for i in range(len(primes))\\nmin(2x1, 3x1, 5x1) = 2\\n\\nnumbers = [1, 2], ptrs = [1, 0, 0]\\nmin(2x2, 3x1, 5x1) = 3\\n\\nnumbers = [1, 2, 3], ptrs = [1, 1, 0]\\nmin(2x2, 3x2, 5x1) = 4\\n\\nnumbers = [1, 2, 3, 4], ptrs = [2, 1, 0]\\nmin(2x3, 3x2, 5x1) = 5\\n\\nnumbers = [1, 2, 3, 4, 5], ptrs = [2, 1, 1]\\nmin(2x3, 3x2, 5x2) = 6\\n\\nnumbers = [1, 2, 3, 4, 5, 6], ptrs=[3, 2, 1] (NOTE: two pointers are incremented)\\nmin(2x4, 3x3, 5x2) = 8\\n\\nnumbers = [1, 2, 3, 4, 5, 6, 8], ptrs=[4, 2, 1]\\nThis process is continued till the len(numbers) == n and then\\nlast value of numbers is returned\\n\"\"\"\\n```\\n\\n```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        pointers = [0 for _ in range(len(primes))]\\n        numbers = [1]\\n        while len(numbers) < n:\\n            # get the possible values for next ugly number\\n            values = [primes[i]*numbers[pointers[i]] for i in range(len(primes))]\\n            \\n            # pick the next ugly number\\n            new_num = min(values)\\n            \\n            # add the ugly number to numbers array\\n            numbers.append(new_num)\\n            \\n            # update the pointers array\\n            for i, pointer in enumerate(pointers):\\n                if primes[i] * numbers[pointer] == new_num:\\n                    pointers[i]+=1\\n        return numbers[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\napproach\\ninitialize pointers = [0, 0, 0...0k]\\npointer[i] will point to the index of the number array for the ith prime\\nnumber array will store the ugly number\\n\\nprimes = [2, 3, 5], ptrs = [0, 0, 0], numbers = [1]\\nget the minimum of primes[i] * numbers[ptrs[i]] for i in range(len(primes))\\nmin(2x1, 3x1, 5x1) = 2\\n\\nnumbers = [1, 2], ptrs = [1, 0, 0]\\nmin(2x2, 3x1, 5x1) = 3\\n\\nnumbers = [1, 2, 3], ptrs = [1, 1, 0]\\nmin(2x2, 3x2, 5x1) = 4\\n\\nnumbers = [1, 2, 3, 4], ptrs = [2, 1, 0]\\nmin(2x3, 3x2, 5x1) = 5\\n\\nnumbers = [1, 2, 3, 4, 5], ptrs = [2, 1, 1]\\nmin(2x3, 3x2, 5x2) = 6\\n\\nnumbers = [1, 2, 3, 4, 5, 6], ptrs=[3, 2, 1] (NOTE: two pointers are incremented)\\nmin(2x4, 3x3, 5x2) = 8\\n\\nnumbers = [1, 2, 3, 4, 5, 6, 8], ptrs=[4, 2, 1]\\nThis process is continued till the len(numbers) == n and then\\nlast value of numbers is returned\\n\"\"\"\\n```\n```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        pointers = [0 for _ in range(len(primes))]\\n        numbers = [1]\\n        while len(numbers) < n:\\n            # get the possible values for next ugly number\\n            values = [primes[i]*numbers[pointers[i]] for i in range(len(primes))]\\n            \\n            # pick the next ugly number\\n            new_num = min(values)\\n            \\n            # add the ugly number to numbers array\\n            numbers.append(new_num)\\n            \\n            # update the pointers array\\n            for i, pointer in enumerate(pointers):\\n                if primes[i] * numbers[pointer] == new_num:\\n                    pointers[i]+=1\\n        return numbers[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311726,
                "title": "c-dp-indexing",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<long long> ind(primes.size(),0);\\n        vector<long long> res;\\n        unordered_map<long long,int> m;\\n        res.push_back(1);\\n        while(res.size()<n)\\n        {\\n            long long t=INT_MAX;\\n            int p=0;\\n            for(int i=0;i<primes.size();i++)\\n            {\\n                if(t>primes[i]*res[ind[i]])\\n                {\\n                    t=primes[i]*res[ind[i]];\\n                    p=i;\\n                }\\n            }\\n            ind[p]++;\\n            if(m.find(t)==m.end())\\n            {\\n                res.push_back(t);\\n                m[t]=1;\\n            }\\n        }\\n        return res[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<long long> ind(primes.size(),0);\\n        vector<long long> res;\\n        unordered_map<long long,int> m;\\n        res.push_back(1);\\n        while(res.size()<n)\\n        {\\n            long long t=INT_MAX;\\n            int p=0;\\n            for(int i=0;i<primes.size();i++)\\n            {\\n                if(t>primes[i]*res[ind[i]])\\n                {\\n                    t=primes[i]*res[ind[i]];\\n                    p=i;\\n                }\\n            }\\n            ind[p]++;\\n            if(m.find(t)==m.end())\\n            {\\n                res.push_back(t);\\n                m[t]=1;\\n            }\\n        }\\n        return res[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277589,
                "title": "easiest-c-code",
                "content": "class Solution {\\npublic:\\n\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int p=primes.size();\\n        int ind[p];\\n        for(int i=0;i<p;i++)\\n            ind[i]=0;\\n        long long int dp[n];\\n        dp[0]=1;\\n        long long int mini;\\n        for(int i=1;i<n;i++)\\n        {\\n            mini=INT_MAX;\\n            for(int i=0;i<p;i++)\\n            {\\n                //cout<<dp[ind[i]]*primes[i]<<\\' \\';\\n                mini=min(mini,dp[ind[i]]*primes[i]);\\n            }\\n            dp[i]=mini;\\n            //cout<<endl;\\n            for(int i=0;i<p;i++)\\n            {\\n                if(mini==dp[ind[i]]*primes[i])\\n                    ind[i]++;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int p=primes.size();\\n        int ind[p];\\n        for(int i=0;i<p;i++)\\n            ind[i]=0;\\n        long long int dp[n];\\n        dp[0]=1;\\n        long long int mini;\\n        for(int i=1;i<n;i++)\\n        {\\n            mini=INT_MAX;\\n            for(int i=0;i<p;i++)\\n            {\\n                //cout<<dp[ind[i]]*primes[i]<<\\' \\';\\n                mini=min(mini,dp[ind[i]]*primes[i]);\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 2236793,
                "title": "java-solution-93-fast-and-memory-usage-beats-83-of-java-submissions",
                "content": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        return this.sol(n,primes);\\n    }\\n    public int sol(int n ,int[] primes) {\\n        long[] primes1 = new long[primes.length];\\n        for(int i = 0 ;i< primes.length;i++) {\\n            primes1[i] = primes[i];\\n        }\\n        int[] index = new int[primes.length];\\n        long[] n1= new long[n];\\n        n1[0] = 1L;\\n        for(int i = 1; i< n;i++) {\\n            long min = Long.MAX_VALUE;\\n            for(int j=0;j < primes1.length;j++) {\\n                min= Math.min(min,primes1[j]);\\n\\n            }\\n            n1[i] = min;\\n            for(int j =0 ; j< primes1.length;j++) {\\n                if(min == primes1[j]) {\\n                    primes1[j] = primes[j] * (n1[++index[j]]);\\n                }\\n            }\\n        }\\n        return (int)n1[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        return this.sol(n,primes);\\n    }\\n    public int sol(int n ,int[] primes) {\\n        long[] primes1 = new long[primes.length];\\n        for(int i = 0 ;i< primes.length;i++) {\\n            primes1[i] = primes[i];\\n        }\\n        int[] index = new int[primes.length];\\n        long[] n1= new long[n];\\n        n1[0] = 1L;\\n        for(int i = 1; i< n;i++) {\\n            long min = Long.MAX_VALUE;\\n            for(int j=0;j < primes1.length;j++) {\\n                min= Math.min(min,primes1[j]);\\n\\n            }\\n            n1[i] = min;\\n            for(int j =0 ; j< primes1.length;j++) {\\n                if(min == primes1[j]) {\\n                    primes1[j] = primes[j] * (n1[++index[j]]);\\n                }\\n            }\\n        }\\n        return (int)n1[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205544,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> dp(primes.size(), 0);\\n        vector<int> ugly;\\n        ugly.push_back(1); \\n        \\n        for(int i = 1; i < n; i++) {\\n            long long int ans = INT_MAX;\\n            int index = 0;\\n            \\n            for(int j = 0; j < primes.size(); j++) {\\n                long long int t = (long long int)primes[j] * (long long int)ugly[dp[j]];\\n                if(ans > t ) {\\n                    ans = t;\\n                }\\n            }\\n            \\n            for(int j = 0; j < primes.size(); j++) {\\n                if(ans == (long long int)primes[j] * (long long int)ugly[dp[j]] ) {\\n                    dp[j]++;\\n                }\\n            }\\n            ugly.push_back(ans);\\n        }\\n        \\n        \\n        return ugly[n - 1];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> dp(primes.size(), 0);\\n        vector<int> ugly;\\n        ugly.push_back(1); \\n        \\n        for(int i = 1; i < n; i++) {\\n            long long int ans = INT_MAX;\\n            int index = 0;\\n            \\n            for(int j = 0; j < primes.size(); j++) {\\n                long long int t = (long long int)primes[j] * (long long int)ugly[dp[j]];\\n                if(ans > t ) {\\n                    ans = t;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2175023,
                "title": "c-this-solution-is-based-on-the-most-voted-answer-of-ugly-number-ii",
                "content": "**NOTE**: Please Go through the given problem below, it is same as this question, just that the primes array contains only three element(2,3&5)\\n\\nThe problem link of [Ugly Number II](https://leetcode.com/problems/ugly-number-ii/)\\nDetailed [Solution](https://leetcode.com/problems/ugly-number-ii/discuss/69368/Elegant-C%2B%2B-Solution-O(N)-space-time-with-detailed-explanation.) for the above problem.\\n\\nSolution for this problem:\\n```\\nint nthSuperUglyNumber(int n, vector<int>& primes){\\n        vector<int>t(1,1);\\n        vector<int>index(primes.size(),0);\\n        while(t.size()<n){\\n            int ans=INT_MAX;\\n            for(int i=0;i<primes.size();i++){\\n                int temp=primes[i]*t[index[i]];\\n                ans=min(ans,temp);  \\n            }\\n            \\n            t.push_back(ans);\\n            \\n            for(int i=0;i<primes.size();i++) if(primes[i]*t[index[i]]==ans) index[i]++;\\n        }\\n        return t.back();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint nthSuperUglyNumber(int n, vector<int>& primes){\\n        vector<int>t(1,1);\\n        vector<int>index(primes.size(),0);\\n        while(t.size()<n){\\n            int ans=INT_MAX;\\n            for(int i=0;i<primes.size();i++){\\n                int temp=primes[i]*t[index[i]];\\n                ans=min(ans,temp);  \\n            }\\n            \\n            t.push_back(ans);\\n            \\n            for(int i=0;i<primes.size();i++) if(primes[i]*t[index[i]]==ans) index[i]++;\\n        }\\n        return t.back();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2165297,
                "title": "java-with-comments-easy-solution",
                "content": "class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        if(n==1)return 1;\\n        int[]t=new int[n];\\n       int[]countOfPrime=new int[primes.length]; //This array hold number of times primes[i]has been used already\\n        t[0]=1; //1 is the first ans\\n        for(int i=1;i<n;i++)\\n        {\\n            int curr=Integer.MAX_VALUE;\\n            for(int j=0;j<primes.length;j++)\\n            {\\n                curr=Math.min(curr,t[countOfPrime[j]]*primes[j]);//for every previous value of t we are going to multiply the value with each primes value the min becomes the ans\\n               \\n            }\\n             t[i]=curr;\\n            for(int j=0;j<primes.length;j++ )\\n            {\\n                if(curr==(t[countOfPrime[j]]*primes[j]))\\n                    countOfPrime[j]++; //once we have used primes[i]value then we need to increase it for ex if we have used 2 once then we increase its count so that next time we use 2*2\\n            }\\n        }\\n        return t[n-1];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        if(n==1)return 1;\\n        int[]t=new int[n];\\n       int[]countOfPrime=new int[primes.length]; //This array hold number of times primes[i]has been used already\\n        t[0]=1; //1 is the first ans\\n        for(int i=1;i<n;i++)\\n        {\\n            int curr=Integer.MAX_VALUE;\\n            for(int j=0;j<primes.length;j++)\\n            {\\n                curr=Math.min(curr,t[countOfPrime[j]]*primes[j]);//for every previous value of t we are going to multiply the value with each primes value the min becomes the ans\\n               \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2156189,
                "title": "java-solution-48ms-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int pointers[]=new int[primes.length];\\n        int dp[]=new int[n];\\n        int i=0;\\n        dp[i]=1;\\n        i++;\\n        while(i<n)\\n        {\\n            int res=Integer.MAX_VALUE;\\n            for(int j=0;j<primes.length;j++)\\n            {\\n                res=Math.min(primes[j]*dp[pointers[j]],res);\\n            }\\n            dp[i]=res;\\n            for(int j=0;j<primes.length;j++)\\n            {\\n                if(primes[j]*dp[pointers[j]]==dp[i])\\n                    pointers[j]++;\\n            }\\n            i++;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int pointers[]=new int[primes.length];\\n        int dp[]=new int[n];\\n        int i=0;\\n        dp[i]=1;\\n        i++;\\n        while(i<n)\\n        {\\n            int res=Integer.MAX_VALUE;\\n            for(int j=0;j<primes.length;j++)\\n            {\\n                res=Math.min(primes[j]*dp[pointers[j]],res);\\n            }\\n            dp[i]=res;\\n            for(int j=0;j<primes.length;j++)\\n            {\\n                if(primes[j]*dp[pointers[j]]==dp[i])\\n                    pointers[j]++;\\n            }\\n            i++;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143501,
                "title": "kotlin-dp-solution-with-dry-run-explanation",
                "content": "Idea:\\n\\n1. We use DP to store all calculated number\\n2. We store the index of number, that each prime number should be calculate with\\n3. In each calculation, we only keep the minimum number\\n4. When the minimum number could be calculated with the prime number, we shift the index to next reference\\n\\nDry run explanation\\n```\\ne.g.\\nn = 5\\nprimes = [2, 3, 5]\\n\\ndp  = [0,0,0,0,0]\\npos = [0,0,0]\\n// according to the question, set dp[0] to 1\\ndp  = [1,0,0,0,0]\\npos = [0,0,0]\\n\\n// 1st loop, cal dp[1]\\n// for each primes number, we calculate the next number with the previous \"dp\" number that marked in the \"pos\" array\\nnums = [0,0,0]\\nnums[0] = dp[pos[0]] * primes[0] -> dp[0] * primes[0] -> 1 * 2 -> 2\\nnums[1] = dp[pos[1]] * primes[1] -> dp[0] * primes[1] -> 1 * 3 -> 3\\nnums[2] = dp[pos[2]] * primes[2] -> dp[0] * primes[2] -> 1 * 5 -> 5\\n\\nmin = nums.min() -> 2\\n\\nsince nums[0] == min, pos[0]++ -> pos[0] = 1\\n\\n// after 1st loop cal\\ndp  = [1,2,0,0,0]\\npos = [1,0,0]\\n\\n// 2nd loop, cal dp[2]\\nnums = [0,0,0]\\nnums[0] = dp[pos[0]] * primes[0] -> dp[1] * primes[0] -> 2 * 2 -> 4\\nnums[1] = dp[pos[1]] * primes[1] -> dp[0] * primes[1] -> 1 * 3 -> 3\\nnums[2] = dp[pos[2]] * primes[2] -> dp[0] * primes[2] -> 1 * 5 -> 5\\n\\nmin = nums.min() -> 3\\n\\nsince nums[1] == min, pos[1]++ -> pos[1] = 1\\n\\n// after 2nd loop cal\\ndp  = [1,2,3,0,0]\\npos = [1,1,0]\\n\\n// 3rd loop, cal dp[2]\\nnums = [0,0,0]\\nnums[0] = dp[pos[0]] * primes[0] -> dp[1] * primes[0] -> 2 * 2 -> 4\\nnums[1] = dp[pos[1]] * primes[1] -> dp[1] * primes[1] -> 2 * 3 -> 6\\nnums[2] = dp[pos[2]] * primes[2] -> dp[0] * primes[2] -> 1 * 5 -> 5\\n\\nmin = nums.min() -> 4\\n\\nsince nums[0] == min, pos[0]++ -> pos[0] = 2\\n\\n// after 3rd loop cal\\ndp  = [1,2,3,4,0]\\npos = [2,1,0]\\n\\n// 4th loop, cal dp[2]\\nnums = [0,0,0]\\nnums[0] = dp[pos[0]] * primes[0] -> dp[1] * primes[0] -> 3 * 2 -> 6\\nnums[1] = dp[pos[1]] * primes[1] -> dp[1] * primes[1] -> 2 * 3 -> 6\\nnums[2] = dp[pos[2]] * primes[2] -> dp[0] * primes[2] -> 1 * 5 -> 5\\n\\nmin = nums.min() -> 5\\n\\nsince nums[0] == min, pos[2]++ -> pos[2] = 1\\n\\n// after 4th loop cal\\ndp  = [1,2,3,4,5]\\npos = [2,1,1]\\n\\nanswer = 5\\n\\n```\\n\\nSolution:\\n```\\nclass Solution {\\n    fun nthSuperUglyNumber(n: Int, primes: IntArray): Int {\\n\\t    // arrange\\n        val dp = IntArray(n)\\n        val pos = IntArray(primes.size)\\n        dp[0] = 1\\n\\t\\t\\n\\t\\t// DP calculation\\n        for (i in 1 until n) {\\n            dp[i] = calNextNumber(dp, pos, primes)\\n        }\\n        \\n\\t\\t// returns\\n        return return dp.last()\\n    }\\n    \\n    private fun calNextNumber(dp: IntArray, pos: IntArray, primes: IntArray): Int {\\n        // Calculate next min number with all primes\\n        val nums = IntArray(primes.size)\\n        var min = Int.MAX_VALUE\\n        // calculate next number with corresponding position in dp\\n        primes.forEachIndexed { i , prime ->\\n            nums[i] = dp[pos[i]] * prime\\n            min = minOf(nums[i], min)\\n        }\\n        \\n        // when the num is min, it mean next time the prime number should calculate with next dp value\\n        nums.forEachIndexed { i, num ->\\n            if (min == num) {\\n                pos[i]++\\n            }\\n        }\\n        return min\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\ne.g.\\nn = 5\\nprimes = [2, 3, 5]\\n\\ndp  = [0,0,0,0,0]\\npos = [0,0,0]\\n// according to the question, set dp[0] to 1\\ndp  = [1,0,0,0,0]\\npos = [0,0,0]\\n\\n// 1st loop, cal dp[1]\\n// for each primes number, we calculate the next number with the previous \"dp\" number that marked in the \"pos\" array\\nnums = [0,0,0]\\nnums[0] = dp[pos[0]] * primes[0] -> dp[0] * primes[0] -> 1 * 2 -> 2\\nnums[1] = dp[pos[1]] * primes[1] -> dp[0] * primes[1] -> 1 * 3 -> 3\\nnums[2] = dp[pos[2]] * primes[2] -> dp[0] * primes[2] -> 1 * 5 -> 5\\n\\nmin = nums.min() -> 2\\n\\nsince nums[0] == min, pos[0]++ -> pos[0] = 1\\n\\n// after 1st loop cal\\ndp  = [1,2,0,0,0]\\npos = [1,0,0]\\n\\n// 2nd loop, cal dp[2]\\nnums = [0,0,0]\\nnums[0] = dp[pos[0]] * primes[0] -> dp[1] * primes[0] -> 2 * 2 -> 4\\nnums[1] = dp[pos[1]] * primes[1] -> dp[0] * primes[1] -> 1 * 3 -> 3\\nnums[2] = dp[pos[2]] * primes[2] -> dp[0] * primes[2] -> 1 * 5 -> 5\\n\\nmin = nums.min() -> 3\\n\\nsince nums[1] == min, pos[1]++ -> pos[1] = 1\\n\\n// after 2nd loop cal\\ndp  = [1,2,3,0,0]\\npos = [1,1,0]\\n\\n// 3rd loop, cal dp[2]\\nnums = [0,0,0]\\nnums[0] = dp[pos[0]] * primes[0] -> dp[1] * primes[0] -> 2 * 2 -> 4\\nnums[1] = dp[pos[1]] * primes[1] -> dp[1] * primes[1] -> 2 * 3 -> 6\\nnums[2] = dp[pos[2]] * primes[2] -> dp[0] * primes[2] -> 1 * 5 -> 5\\n\\nmin = nums.min() -> 4\\n\\nsince nums[0] == min, pos[0]++ -> pos[0] = 2\\n\\n// after 3rd loop cal\\ndp  = [1,2,3,4,0]\\npos = [2,1,0]\\n\\n// 4th loop, cal dp[2]\\nnums = [0,0,0]\\nnums[0] = dp[pos[0]] * primes[0] -> dp[1] * primes[0] -> 3 * 2 -> 6\\nnums[1] = dp[pos[1]] * primes[1] -> dp[1] * primes[1] -> 2 * 3 -> 6\\nnums[2] = dp[pos[2]] * primes[2] -> dp[0] * primes[2] -> 1 * 5 -> 5\\n\\nmin = nums.min() -> 5\\n\\nsince nums[0] == min, pos[2]++ -> pos[2] = 1\\n\\n// after 4th loop cal\\ndp  = [1,2,3,4,5]\\npos = [2,1,1]\\n\\nanswer = 5\\n\\n```\n```\\nclass Solution {\\n    fun nthSuperUglyNumber(n: Int, primes: IntArray): Int {\\n\\t    // arrange\\n        val dp = IntArray(n)\\n        val pos = IntArray(primes.size)\\n        dp[0] = 1\\n\\t\\t\\n\\t\\t// DP calculation\\n        for (i in 1 until n) {\\n            dp[i] = calNextNumber(dp, pos, primes)\\n        }\\n        \\n\\t\\t// returns\\n        return return dp.last()\\n    }\\n    \\n    private fun calNextNumber(dp: IntArray, pos: IntArray, primes: IntArray): Int {\\n        // Calculate next min number with all primes\\n        val nums = IntArray(primes.size)\\n        var min = Int.MAX_VALUE\\n        // calculate next number with corresponding position in dp\\n        primes.forEachIndexed { i , prime ->\\n            nums[i] = dp[pos[i]] * prime\\n            min = minOf(nums[i], min)\\n        }\\n        \\n        // when the num is min, it mean next time the prime number should calculate with next dp value\\n        nums.forEachIndexed { i, num ->\\n            if (min == num) {\\n                pos[i]++\\n            }\\n        }\\n        return min\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120606,
                "title": "javascript-dp-170ms-75-java-min-heap-pq-758ms-treeset-1754ms-three-solutions",
                "content": "prerequisite: https://leetcode.com/problems/ugly-number-ii/\\nmy solution: https://leetcode.com/problems/ugly-number-ii/discuss/937584/javascript-PriorityQueue-and-DP\\n\\nslightly changing the code from ugly number II, replace 2,3,5 with all primes number instead\\n\\n![image](https://assets.leetcode.com/users/images/360ca512-801d-4b64-b949-1f7290582f2e_1654574064.241775.png)\\n```\\nconst nthSuperUglyNumber = (n, primes) => {\\n    let res = [1], max = Math.max(...primes), cnt = Array(max + 1).fill(0);\\n    while (res.length < n) {\\n        let min = Number.MAX_SAFE_INTEGER;\\n        for (const x of primes) {\\n            let next = res[cnt[x]] * x;\\n            min = Math.min(min, next);\\n        }\\n        for (const x of primes) {\\n            let next = res[cnt[x]] * x;\\n            if (min == next) cnt[x]++;\\n        }\\n        res.push(min);\\n    }\\n    return res[n - 1];\\n};\\n```\\n**Solution 2**: use min heap/pq, got RE, seems memory out inside pq, but anyway, this way is correct also\\n![image](https://assets.leetcode.com/users/images/112d3947-c6e6-4f29-bd0a-38f32f9e0cf3_1654573977.7618291.png)\\n\\n```\\nconst nthSuperUglyNumber = (n, primes) => {\\n    let pq = new MinPriorityQueue();\\n    pq.enqueue(1);\\n    for (let t = 1; t < n; t++) {\\n        let cur = pq.dequeue().element;\\n        while (!pq.isEmpty() && pq.front().element == cur) {\\n            cur = pq.dequeue().element;\\n        }\\n        for (const x of primes) pq.enqueue(cur * x);\\n    }\\n    return pq.front().element;\\n};\\n```\\n**Java passed, exactly same code**\\n![image](https://assets.leetcode.com/users/images/a4904f03-a110-43b5-b87a-c04c1e78d782_1654575968.289958.png)\\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        PriorityQueue<Long> pq = new PriorityQueue<>();\\n        pq.add(1L);\\n        for (int t = 1; t < n; t++) {\\n            long cur = pq.poll();\\n            while (!pq.isEmpty() && pq.peek() == cur) cur = pq.poll();\\n            for (int x: primes) pq.add(cur * x);\\n        }\\n        long res = pq.peek();\\n        return (int) res;\\n    }\\n}\\n```\\n**Solution 3**: use TreeSet instead of min heap\\n![image](https://assets.leetcode.com/users/images/95139a00-50e3-4d00-bbb6-261d1bb3619a_1654576569.7640405.png)\\n\\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        TreeSet<Long> ts = new TreeSet();\\n        ts.add(1L);\\n        for (int t = 1; t < n; t++) {\\n            long cur = ts.pollFirst();\\n            while (ts.size() > 0 && ts.first() == cur) cur = ts.pollFirst();\\n            for (int x: primes) ts.add(cur * x);\\n        }\\n        long res = ts.first();\\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst nthSuperUglyNumber = (n, primes) => {\\n    let res = [1], max = Math.max(...primes), cnt = Array(max + 1).fill(0);\\n    while (res.length < n) {\\n        let min = Number.MAX_SAFE_INTEGER;\\n        for (const x of primes) {\\n            let next = res[cnt[x]] * x;\\n            min = Math.min(min, next);\\n        }\\n        for (const x of primes) {\\n            let next = res[cnt[x]] * x;\\n            if (min == next) cnt[x]++;\\n        }\\n        res.push(min);\\n    }\\n    return res[n - 1];\\n};\\n```\n```\\nconst nthSuperUglyNumber = (n, primes) => {\\n    let pq = new MinPriorityQueue();\\n    pq.enqueue(1);\\n    for (let t = 1; t < n; t++) {\\n        let cur = pq.dequeue().element;\\n        while (!pq.isEmpty() && pq.front().element == cur) {\\n            cur = pq.dequeue().element;\\n        }\\n        for (const x of primes) pq.enqueue(cur * x);\\n    }\\n    return pq.front().element;\\n};\\n```\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        PriorityQueue<Long> pq = new PriorityQueue<>();\\n        pq.add(1L);\\n        for (int t = 1; t < n; t++) {\\n            long cur = pq.poll();\\n            while (!pq.isEmpty() && pq.peek() == cur) cur = pq.poll();\\n            for (int x: primes) pq.add(cur * x);\\n        }\\n        long res = pq.peek();\\n        return (int) res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        TreeSet<Long> ts = new TreeSet();\\n        ts.add(1L);\\n        for (int t = 1; t < n; t++) {\\n            long cur = ts.pollFirst();\\n            while (ts.size() > 0 && ts.first() == cur) cur = ts.pollFirst();\\n            for (int x: primes) ts.add(cur * x);\\n        }\\n        long res = ts.first();\\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967216,
                "title": "python",
                "content": "\\n    def nthSuperUglyNumber(self, n, primes):\\n        dp, heap, visited = [1], [], set()\\n        \\n        for i, prime in enumerate(primes):\\n            heapq.heappush(heap, (prime, i, 0))\\n            \\n        while len(dp) < n:\\n            val, prime_idx, _idx = heapq.heappop(heap)\\n            \\n            if val not in visited:\\n                dp.append(val)\\n                visited.add(val)\\n                \\n            heapq.heappush(heap, (primes[prime_idx]*dp[_idx + 1], prime_idx, _idx + 1))\\n        \\n        return dp[-1]",
                "solutionTags": [],
                "code": "\\n    def nthSuperUglyNumber(self, n, primes):\\n        dp, heap, visited = [1], [], set()\\n        \\n        for i, prime in enumerate(primes):\\n            heapq.heappush(heap, (prime, i, 0))\\n            \\n        while len(dp) < n:\\n            val, prime_idx, _idx = heapq.heappop(heap)\\n            \\n            if val not in visited:\\n                dp.append(val)\\n                visited.add(val)\\n                \\n            heapq.heappush(heap, (primes[prime_idx]*dp[_idx + 1], prime_idx, _idx + 1))\\n        \\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1897515,
                "title": "python-use-heap-and-dp-clean-solution",
                "content": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        numbers = [1]\\n\\t\\t# initial heap, (the next val to be evaluated, the idx of the prime number, the last time used number position\\n        h = [(p, idx, 0) for idx, p in enumerate(primes)]\\n        heapq.heapify(h)\\n        while len(numbers) < n:\\n\\t\\t    # check the smallest number\\n            v, idx_p, num_pos = heapq.heappop(h)\\n\\t\\t\\t# if can put in the result\\n            if len(numbers) == 0 or v > numbers[-1]:\\n                numbers.append(v)\\n\\t\\t\\t# put the next candidate by putting the primes * the next can use number in the dp list\\n            heapq.heappush(h, (primes[idx_p] * numbers[num_pos+1], idx_p, num_pos+1))\\n        return numbers[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        numbers = [1]\\n\\t\\t# initial heap, (the next val to be evaluated, the idx of the prime number, the last time used number position\\n        h = [(p, idx, 0) for idx, p in enumerate(primes)]\\n        heapq.heapify(h)\\n        while len(numbers) < n:\\n\\t\\t    # check the smallest number\\n            v, idx_p, num_pos = heapq.heappop(h)\\n\\t\\t\\t# if can put in the result\\n            if len(numbers) == 0 or v > numbers[-1]:\\n                numbers.append(v)\\n\\t\\t\\t# put the next candidate by putting the primes * the next can use number in the dp list\\n            heapq.heappush(h, (primes[idx_p] * numbers[num_pos+1], idx_p, num_pos+1))\\n        return numbers[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856461,
                "title": "js-solution-faster-than-96-55-less-than-94-83",
                "content": "Runtime: 448 ms, faster than 96.55% of JavaScript online submissions for Super Ugly Number.\\nMemory Usage: 51.4 MB, less than 94.83% of JavaScript online submissions for Super Ugly Number.\\n```\\nvar nthSuperUglyNumber = function(n, primes) {\\n    const table = Array(primes.length).fill(0);\\n    const res = Array(n);\\n    res[0] = 1;\\n    for(let j=1;j<n;j++){\\n        let curr = Infinity;\\n        for (let i=0;i< table.length; i++) {\\n            curr = Math.min(curr, res[table[i]]*primes[i]);\\n        }\\n        for (let i=0;i< table.length; i++) {\\n            if (curr === res[table[i]]*primes[i]) table[i]++;\\n        }\\n        res[j] = curr;\\n    }\\n    return res[n-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nthSuperUglyNumber = function(n, primes) {\\n    const table = Array(primes.length).fill(0);\\n    const res = Array(n);\\n    res[0] = 1;\\n    for(let j=1;j<n;j++){\\n        let curr = Infinity;\\n        for (let i=0;i< table.length; i++) {\\n            curr = Math.min(curr, res[table[i]]*primes[i]);\\n        }\\n        for (let i=0;i< table.length; i++) {\\n            if (curr === res[table[i]]*primes[i]) table[i]++;\\n        }\\n        res[j] = curr;\\n    }\\n    return res[n-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1698538,
                "title": "java-solution-with-priorityqueue",
                "content": "```\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((i1, i2)->i1[1] - i2[1]);\\n        for(int p : primes)\\n        {\\n            pq.offer(new int[]{0, p, p});\\n        }\\n        \\n        int[] res = new int[n];\\n        res[0] = 1;\\n        int ind = 1;\\n        while(ind < n)\\n        {\\n            int[] item = pq.poll();\\n            if(item[1] != res[ind-1])\\n            {\\n                res[ind++] = item[1];\\n            }\\n            \\n            item[1] = res[item[0]++] * item[2];\\n            pq.offer(item);\\n        }\\n        \\n        return res[n-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((i1, i2)->i1[1] - i2[1]);\\n        for(int p : primes)\\n        {\\n            pq.offer(new int[]{0, p, p});\\n        }\\n        \\n        int[] res = new int[n];\\n        res[0] = 1;\\n        int ind = 1;\\n        while(ind < n)\\n        {\\n            int[] item = pq.poll();\\n            if(item[1] != res[ind-1])\\n            {\\n                res[ind++] = item[1];\\n            }\\n            \\n            item[1] = res[item[0]++] * item[2];\\n            pq.offer(item);\\n        }\\n        \\n        return res[n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596274,
                "title": "easy-solution-dynamic-programming-using-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int nthSuperUglyNumber(int n, int[] primes) {\\n\\t\\t\\tint cur[] = new int[primes.length];\\n\\t\\t\\tint dp[] = new int[n+1];\\n\\t\\t\\tdp[0]=1;\\n\\t\\t\\tint index=1;\\n\\t\\t\\twhile(index<n){\\n\\t\\t\\t\\tint min=Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int i=0;i<primes.length;i++){\\n\\t\\t\\t\\t\\tmin=Math.min(min, dp[cur[i]]*primes[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[index++]=min;\\n\\t\\t\\t\\tfor(int i=0;i<primes.length;i++){\\n\\t\\t\\t\\t\\tif(min == dp[cur[i]]*primes[i])\\n\\t\\t\\t\\t\\t\\tcur[i]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n-1];\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\t\\tpublic int nthSuperUglyNumber(int n, int[] primes) {\\n\\t\\t\\tint cur[] = new int[primes.length];\\n\\t\\t\\tint dp[] = new int[n+1];\\n\\t\\t\\tdp[0]=1;\\n\\t\\t\\tint index=1;\\n\\t\\t\\twhile(index<n){\\n\\t\\t\\t\\tint min=Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int i=0;i<primes.length;i++){\\n\\t\\t\\t\\t\\tmin=Math.min(min, dp[cur[i]]*primes[i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1516098,
                "title": "c-priority-queue-approach-o-nlogk",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Pair{\\n        long long val;\\n        long long ptr;\\n        long long product;\\n        Pair(){}\\n        Pair(long long _val,long long _ptr,long long _product){\\n            val=_val;\\n            ptr=_ptr;\\n            product=_product;\\n        }\\n    };\\n    struct compare{\\n        bool operator()(const Pair&a,const Pair &b){\\n            return a.product>b.product;\\n        }\\n    };\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        priority_queue<Pair,vector<Pair>,compare>pq;\\n        vector<long long> dp(n+1);\\n        dp[1]=1;\\n        for(int i=0;i<primes.size();i++){\\n            pq.push(Pair(primes[i],1,primes[i]));\\n        }\\n        \\n        int i=2;\\n        while(i<=n){\\n            Pair src=pq.top();pq.pop();\\n            if(src.product!=dp[i-1]){\\n                dp[i++]=src.product;\\n            }\\n            pq.push(Pair(src.val,src.ptr+1,dp[src.ptr+1]*src.val));\\n            \\n        }\\n       \\n        \\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Pair{\\n        long long val;\\n        long long ptr;\\n        long long product;\\n        Pair(){}\\n        Pair(long long _val,long long _ptr,long long _product){\\n            val=_val;\\n            ptr=_ptr;\\n            product=_product;\\n        }\\n    };\\n    struct compare{\\n        bool operator()(const Pair&a,const Pair &b){\\n            return a.product>b.product;\\n        }\\n    };\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        priority_queue<Pair,vector<Pair>,compare>pq;\\n        vector<long long> dp(n+1);\\n        dp[1]=1;\\n        for(int i=0;i<primes.size();i++){\\n            pq.push(Pair(primes[i],1,primes[i]));\\n        }\\n        \\n        int i=2;\\n        while(i<=n){\\n            Pair src=pq.top();pq.pop();\\n            if(src.product!=dp[i-1]){\\n                dp[i++]=src.product;\\n            }\\n            pq.push(Pair(src.val,src.ptr+1,dp[src.ptr+1]*src.val));\\n            \\n        }\\n       \\n        \\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478748,
                "title": "python-o-nlog-k-solution-based-on-dp",
                "content": "```\\nfrom heapq import heappush, heappop\\n\\n\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = [1]*(n+1)\\n        k = len(primes)\\n        indices = [0] * k\\n        heap = []\\n        for i, p in enumerate(primes):\\n            heappush(heap, (p, i))\\n        index = 0\\n        while index < n:\\n            (min_elem, index_min_elem) = heappop(heap)\\n            if min_elem != lst[index]:\\n                index += 1\\n                lst[index] = min_elem\\n            indices[index_min_elem] += 1\\n            heappush(heap, (primes[index_min_elem]*lst[indices[index_min_elem]],index_min_elem))\\n        return lst[n-1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\n\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = [1]*(n+1)\\n        k = len(primes)\\n        indices = [0] * k\\n        heap = []\\n        for i, p in enumerate(primes):\\n            heappush(heap, (p, i))\\n        index = 0\\n        while index < n:\\n            (min_elem, index_min_elem) = heappop(heap)\\n            if min_elem != lst[index]:\\n                index += 1\\n                lst[index] = min_elem\\n            indices[index_min_elem] += 1\\n            heappush(heap, (primes[index_min_elem]*lst[indices[index_min_elem]],index_min_elem))\\n        return lst[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464972,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        \\n        int[] p = new int[primes.length]; \\n        for(int i = 0; i < primes.length; i++) p[i] = 1;\\n        int[] dp = new int[n + 1];\\n        int [] temp = new int[primes.length];\\n        int curPtr = 2;\\n        dp[1] = 1;\\n        while(curPtr <= n) {\\n            for(int i = 0; i < p.length; i++) {\\n                int pimi = dp[p[i]]*primes[i];\\n                temp[i] = pimi;\\n            }\\n            int minVal = Integer.MAX_VALUE;\\n            \\n            for(int i = 0; i < temp.length; i++) {\\n                minVal = Math.min(minVal, temp[i]);\\n            }\\n            dp[curPtr++] = minVal;\\n            for(int i=0; i<temp.length; i++) {\\n                if(temp[i]==minVal) p[i]++;\\n            }\\n            \\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        \\n        int[] p = new int[primes.length]; \\n        for(int i = 0; i < primes.length; i++) p[i] = 1;\\n        int[] dp = new int[n + 1];\\n        int [] temp = new int[primes.length];\\n        int curPtr = 2;\\n        dp[1] = 1;\\n        while(curPtr <= n) {\\n            for(int i = 0; i < p.length; i++) {\\n                int pimi = dp[p[i]]*primes[i];\\n                temp[i] = pimi;\\n            }\\n            int minVal = Integer.MAX_VALUE;\\n            \\n            for(int i = 0; i < temp.length; i++) {\\n                minVal = Math.min(minVal, temp[i]);\\n            }\\n            dp[curPtr++] = minVal;\\n            for(int i=0; i<temp.length; i++) {\\n                if(temp[i]==minVal) p[i]++;\\n            }\\n            \\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385241,
                "title": "c-nthsuperuglynumber-easy-code-58ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int m = primes.size();\\n        vector<int>dp(n,0);\\n        dp[0] = 1;\\n        vector<int>multiples(m,0);\\n        \\n        //fill the sequence\\n        for(int i=1;i<n;i++){\\n            //find the min \\n            int curr_min = INT_MAX;\\n            for(int j=0;j<m;j++){\\n                curr_min = min (curr_min, dp[multiples[j]]*primes[j]);\\n            }\\n            for(int j=0;j<m;j++){\\n                if(curr_min == dp[multiples[j]]*primes[j])\\n                    multiples[j]++;\\n            }\\n            dp[i] = curr_min;\\n            //cout<<dp[i]<<\" \";\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int m = primes.size();\\n        vector<int>dp(n,0);\\n        dp[0] = 1;\\n        vector<int>multiples(m,0);\\n        \\n        //fill the sequence\\n        for(int i=1;i<n;i++){\\n            //find the min \\n            int curr_min = INT_MAX;\\n            for(int j=0;j<m;j++){\\n                curr_min = min (curr_min, dp[multiples[j]]*primes[j]);\\n            }\\n            for(int j=0;j<m;j++){\\n                if(curr_min == dp[multiples[j]]*primes[j])\\n                    multiples[j]++;\\n            }\\n            dp[i] = curr_min;\\n            //cout<<dp[i]<<\" \";\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1354117,
                "title": "java-3000-6-100-ms",
                "content": "\\tclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        if(n==1) return 1;\\n        PriorityQueue<Long>pq=new PriorityQueue<>();\\n        HashMap<Long,Boolean>map=new HashMap<>();\\n        pq.add((long)1);long temp=0;\\n        map.put((long)1,true);\\n        for(int j=0;j<n;j++){\\n            temp=pq.poll();\\n            for(int i=0;i<primes.length;i++){\\n                if(map.containsKey(primes[i]*temp)==false){\\n                    map.put((long)primes[i]*temp,true);\\n                    pq.add((long)primes[i]*temp);\\n                }\\n            }\\n        }\\n        return (int)temp;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        if(n==1) return 1;\\n        PriorityQueue<Long>pq=new PriorityQueue<>();\\n        HashMap<Long,Boolean>map=new HashMap<>();\\n        pq.add((long)1);long temp=0;\\n        map.put((long)1,true);\\n        for(int j=0;j<n;j++){\\n            temp=pq.poll();\\n            for(int i=0;i<primes.length;i++){\\n                if(map.containsKey(primes[i]*temp)==false){\\n                    map.put((long)primes[i]*temp,true);\\n                    pq.add((long)primes[i]*temp);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1348010,
                "title": "c-set-stl-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        set<long> possible,fix;\\n        possible.insert(1);\\n        while(fix.size()!=n){\\n            long nextUgly = *possible.begin();\\n            fix.insert(nextUgly);\\n            possible.erase(nextUgly);\\n            for(int i=0; i<primes.size();i++){\\n                possible.insert(primes[i]*nextUgly);\\n            }\\n        }\\n        return *fix.rbegin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        set<long> possible,fix;\\n        possible.insert(1);\\n        while(fix.size()!=n){\\n            long nextUgly = *possible.begin();\\n            fix.insert(nextUgly);\\n            possible.erase(nextUgly);\\n            for(int i=0; i<primes.size();i++){\\n                possible.insert(primes[i]*nextUgly);\\n            }\\n        }\\n        return *fix.rbegin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345728,
                "title": "java-dp",
                "content": "Pattern:\\n\\n1. Next ugly number is always greater than previous, skipping the same numbers.\\n2. List of primes are sorted, so multiplying all the ugly numbers formed so far with all\\n    the prime numbers in list, We can keep track of the minSoFar, keeping track \\n\\tof minSoFar should be greater than previous ugly number dp[i-1].\\n\\t\\n\\tdp[0] = 0, dp[1] = 1\\n\\tfor dp[2] = ?\\n\\twe have options min((dp[1],dp[2]...) * [2,3,5....]) = next ugly number.\\n\\nApproach 1: Time limit exceeded - O(n^2k)\\n```\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int dp[] = new int[n + 1];\\n        dp[1] = 1;\\n        //As the list of primes are sorted.\\n        //so we will form dp, using previous ugly number to make new ugly num.\\n        for (int i = 2; i <= n; i++) {\\n            //so,out next ugly number should always be\\n            //greater than prev ugly number.\\n            int greaterThan = dp[i - 1], nextGreater = Integer.MAX_VALUE;\\n            //go through all the ugly number so far formed and\\n            //make combination with sorted prime factor.\\n            for (int j = i-1; j >= 1;j--){\\n                for (int p=0;p<primes.length;p++){\\n                    if (dp[j] * primes[p] > nextGreater)\\n                        break;\\n                    if (dp[j] * primes[p] > greaterThan)\\n                        nextGreater = Math.min(nextGreater,dp[j] * primes[p]);\\n                }\\n            }\\n            dp[i] = nextGreater;\\n        }\\n\\n        return dp[n];\\n    }\\n```\\nAbove approach gave me TLE, So, going thru approach we can see that there exist pattern,\\nwhen we are getting next ugly number, we don\\'t need to multiply all the formed ugly number \\ninstead we can maintain the array index[],  which keeps track which ugly number should be multiplied\\nwith prime number i in array. \\nCurrent index will always store the ugly number, such that (dp[index[p]] * prime[p] > dp[i-1]).\\nApproach 2: optimised O(nk)\\n```\\n    //improved\\n    public int nthSuperUglyNumberDp(int n, int[] primes) {\\n        int dp[] = new int[n + 1];\\n        int index[] = new int[primes.length];\\n        Arrays.fill(index, 1);\\n        dp[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = Integer.MAX_VALUE;\\n            for (int p = 0; p < primes.length; p++) {\\n                dp[i] = Math.min(dp[i], primes[p] * dp[index[p]]);\\n            }\\n            //increase all the indexes which forms current ugly number.\\n            for (int p = 0; p < primes.length; p++)\\n                if (primes[p] * dp[index[p]] == dp[i])\\n                    index[p]++;\\n        }\\n        return dp[n];\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int dp[] = new int[n + 1];\\n        dp[1] = 1;\\n        //As the list of primes are sorted.\\n        //so we will form dp, using previous ugly number to make new ugly num.\\n        for (int i = 2; i <= n; i++) {\\n            //so,out next ugly number should always be\\n            //greater than prev ugly number.\\n            int greaterThan = dp[i - 1], nextGreater = Integer.MAX_VALUE;\\n            //go through all the ugly number so far formed and\\n            //make combination with sorted prime factor.\\n            for (int j = i-1; j >= 1;j--){\\n                for (int p=0;p<primes.length;p++){\\n                    if (dp[j] * primes[p] > nextGreater)\\n                        break;\\n                    if (dp[j] * primes[p] > greaterThan)\\n                        nextGreater = Math.min(nextGreater,dp[j] * primes[p]);\\n                }\\n            }\\n            dp[i] = nextGreater;\\n        }\\n\\n        return dp[n];\\n    }\\n```\n```\\n    //improved\\n    public int nthSuperUglyNumberDp(int n, int[] primes) {\\n        int dp[] = new int[n + 1];\\n        int index[] = new int[primes.length];\\n        Arrays.fill(index, 1);\\n        dp[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = Integer.MAX_VALUE;\\n            for (int p = 0; p < primes.length; p++) {\\n                dp[i] = Math.min(dp[i], primes[p] * dp[index[p]]);\\n            }\\n            //increase all the indexes which forms current ugly number.\\n            for (int p = 0; p < primes.length; p++)\\n                if (primes[p] * dp[index[p]] == dp[i])\\n                    index[p]++;\\n        }\\n        return dp[n];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310680,
                "title": "o-nk-solution-with-further-optimisation-to-o-nlogk-by-min-heap",
                "content": "O(NK) Solution :\\n\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int dp[n + 1]; dp[1] = 1;\\n        \\n        vector<int> pointers(primes.size(), 1);\\n        \\n        for (int i = 2; i<=n; i++) {\\n            int mn = INT_MAX;\\n            for (int j = 0; j<primes.size(); j++) {\\n                mn = min(mn, primes[j] * dp[pointers[j]]);\\n            }\\n            \\n            dp[i] = mn;\\n            \\n            for (int j = 0; j<primes.size(); j++) {\\n               if ( mn == primes[j] * dp[pointers[j]]) pointers[j]++;\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n````\\nO(NlogK) Solution : Use min heap for finding minimum \\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int dp[n + 1]; dp[1] = 1;\\n        \\n\\t\\t// pq contains vector of size three where first element is product (prime * dp[pointer] ), \\n\\t\\t// second is prime itself and third is the index of pointer.\\n\\t\\t\\n        priority_queue< vector<int>, vector<vector<int>>, greater<> > pq;\\n        for (int i = 0; i<primes.size(); i++)  pq.push({primes[i], primes[i], 1});\\n\\n        for (int i = 2; i<=n; i++) {\\n            int mn = pq.top()[0];\\n\\n            dp[i] = mn;\\n\\t\\t\\t\\n\\t\\t\\t// increase pointers corresponding to all minimums, so loop is required\\n            while(!pq.empty() && pq.top()[0] == mn) {\\n                vector<int> temp = pq.top(); pq.pop();\\n                temp[2]++; temp[0] = temp[1] * dp[temp[2]];\\n                pq.push(temp);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int dp[n + 1]; dp[1] = 1;\\n        \\n        vector<int> pointers(primes.size(), 1);\\n        \\n        for (int i = 2; i<=n; i++) {\\n            int mn = INT_MAX;\\n            for (int j = 0; j<primes.size(); j++) {\\n                mn = min(mn, primes[j] * dp[pointers[j]]);\\n            }\\n            \\n            dp[i] = mn;\\n            \\n            for (int j = 0; j<primes.size(); j++) {\\n               if ( mn == primes[j] * dp[pointers[j]]) pointers[j]++;\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293550,
                "title": "java-solution",
                "content": "```\\n  public int nthSuperUglyNumber(int n, int[] prime) {\\n        int count = 0, i = 0, j = 0, k = 0;\\n        int factor[] = new int[n];\\n        Arrays.fill(factor, 0);\\n        factor[0] = 1;\\n        count = 1;\\n        \\n        while(count < n && i < prime.length) \\n        {\\n        \\t// System.out.println(\"count : \" + count + \" --- n = \" + n);\\n            if((factor[k] * 2) < prime[i]) \\n            {\\n                int item = factor[k] * 2;\\n                factor[++j] = item;\\n                ++k;\\n            }\\n            else if((factor[k] * 2) == prime[i]) \\n            {\\n                int item = factor[k] * 2;\\n                factor[++j] = item;\\n                ++k;\\n                ++i;\\n            }\\n            else \\n            {\\n                factor[++j] = prime[i];\\n                i++;\\n            }\\n            count++;            \\n        }\\n        \\n        if(i >= prime.length && count < n) {\\n        \\twhile(count < n) {\\n\\t        \\t//System.out.println(\"count : \" + count + \" **** n = \" + n);\\n\\t        \\t int item = factor[k] * 2;\\n\\t             factor[++j] = item;\\n\\t             ++k;\\n\\t             count++;\\n\\t             \\n\\t             //System.out.println(\"item : \" + item);\\n        \\t}\\n        }\\n        \\n                \\n        // System.out.println();\\n        // for(int index = 0; index < factor.length; index++) {\\n        //     System.out.print(\"\\\\t\" + factor[index]);\\n        // }\\n        // System.out.println();\\n        return factor[count - 1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int nthSuperUglyNumber(int n, int[] prime) {\\n        int count = 0, i = 0, j = 0, k = 0;\\n        int factor[] = new int[n];\\n        Arrays.fill(factor, 0);\\n        factor[0] = 1;\\n        count = 1;\\n        \\n        while(count < n && i < prime.length) \\n        {\\n        \\t// System.out.println(\"count : \" + count + \" --- n = \" + n);\\n            if((factor[k] * 2) < prime[i]) \\n            {\\n                int item = factor[k] * 2;\\n                factor[++j] = item;\\n                ++k;\\n            }\\n            else if((factor[k] * 2) == prime[i]) \\n            {\\n                int item = factor[k] * 2;\\n                factor[++j] = item;\\n                ++k;\\n                ++i;\\n            }\\n            else \\n            {\\n                factor[++j] = prime[i];\\n                i++;\\n            }\\n            count++;            \\n        }\\n        \\n        if(i >= prime.length && count < n) {\\n        \\twhile(count < n) {\\n\\t        \\t//System.out.println(\"count : \" + count + \" **** n = \" + n);\\n\\t        \\t int item = factor[k] * 2;\\n\\t             factor[++j] = item;\\n\\t             ++k;\\n\\t             count++;\\n\\t             \\n\\t             //System.out.println(\"item : \" + item);\\n        \\t}\\n        }\\n        \\n                \\n        // System.out.println();\\n        // for(int index = 0; index < factor.length; index++) {\\n        //     System.out.print(\"\\\\t\" + factor[index]);\\n        // }\\n        // System.out.println();\\n        return factor[count - 1];\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1253100,
                "title": "c-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> dp(n,0);\\n        dp[0] = 1;\\n        unordered_map<int,int> pointer;\\n        \\n        for(int i=0;i<primes.size();++i)\\n            pointer[primes[i]] = 0;\\n        \\n        for(int i=1;i<n;++i)\\n        {\\n            int mn = INT_MAX;\\n            for(int j=0;j<primes.size();++j)\\n            {\\n                mn = min(mn,primes[j] * dp[pointer[primes[j]]]);\\n            }\\n            dp[i] = mn;\\n            for(int j=0;j<primes.size();++j)\\n            {\\n                if(dp[i] % primes[j] == 0)\\n                    pointer[primes[j]]++;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> dp(n,0);\\n        dp[0] = 1;\\n        unordered_map<int,int> pointer;\\n        \\n        for(int i=0;i<primes.size();++i)\\n            pointer[primes[i]] = 0;\\n        \\n        for(int i=1;i<n;++i)\\n        {\\n            int mn = INT_MAX;\\n            for(int j=0;j<primes.size();++j)\\n            {\\n                mn = min(mn,primes[j] * dp[pointer[primes[j]]]);\\n            }\\n            dp[i] = mn;\\n            for(int j=0;j<primes.size();++j)\\n            {\\n                if(dp[i] % primes[j] == 0)\\n                    pointer[primes[j]]++;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073539,
                "title": "dfs-with-binary-search-30-n-time-o-k-space-no-heap",
                "content": "simple dfs counting, as there\\'s 1 - 1 relation between a tree node and number factorization\\n\\n```\\nclass Solution {\\n    int msf = 0;\\n    int cnt = 0;\\n    private int n;\\n    private int[] primes;\\n    int st = 0;\\n    int m;\\n\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        this.n = n;\\n        this.primes = primes;\\n        if (primes[0] == 1) st = 1;\\n        int a = 1, b = Integer.MAX_VALUE;\\n        while (a < b) {\\n            m = a + ((b - a) >> 1);\\n            cnt = msf = 1;\\n            dfs(1, st);\\n            if (cnt < n)\\n                a = m + 1;\\n            else\\n                b = m;\\n        }\\n        m = a;\\n        cnt = msf = 1;\\n        dfs(1, st);\\n        return msf;\\n    }\\n\\n    private void dfs(int v, int from) {\\n        if (cnt > n) return;\\n        msf = Math.max(msf, v);\\n        for (int i = from; i < primes.length; i++) {\\n            long vv = (long) v * (long) primes[i];\\n            if (vv <= m) {\\n                cnt++;\\n                dfs((int) vv, i);\\n            } else break;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int msf = 0;\\n    int cnt = 0;\\n    private int n;\\n    private int[] primes;\\n    int st = 0;\\n    int m;\\n\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        this.n = n;\\n        this.primes = primes;\\n        if (primes[0] == 1) st = 1;\\n        int a = 1, b = Integer.MAX_VALUE;\\n        while (a < b) {\\n            m = a + ((b - a) >> 1);\\n            cnt = msf = 1;\\n            dfs(1, st);\\n            if (cnt < n)\\n                a = m + 1;\\n            else\\n                b = m;\\n        }\\n        m = a;\\n        cnt = msf = 1;\\n        dfs(1, st);\\n        return msf;\\n    }\\n\\n    private void dfs(int v, int from) {\\n        if (cnt > n) return;\\n        msf = Math.max(msf, v);\\n        for (int i = from; i < primes.length; i++) {\\n            long vv = (long) v * (long) primes[i];\\n            if (vv <= m) {\\n                cnt++;\\n                dfs((int) vv, i);\\n            } else break;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017751,
                "title": "java-91-o-n-k",
                "content": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {        \\n        int[] res = new int[n];\\n        int[] indices = new int[primes.length];\\n        \\n        res[0] = 1;        \\n        \\n        for(int i = 1; i < n; i++) {\\n            int num = Integer.MAX_VALUE;\\n            \\n            for(int j = 0; j < primes.length; j++) {\\n                int index = indices[j];\\n                if(primes[j] * res[index] < num) {\\n                    num = primes[j] * res[index];\\n                }\\n            }\\n            \\n            res[i] = num;\\n            \\n            for(int j = 0; j < primes.length; j++) {\\n                int index = indices[j];\\n                if(primes[j] * res[index] == num) {\\n                    indices[j]++; \\n                }\\n            }\\n                       \\n        }\\n        \\n        return res[n-1];    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {        \\n        int[] res = new int[n];\\n        int[] indices = new int[primes.length];\\n        \\n        res[0] = 1;        \\n        \\n        for(int i = 1; i < n; i++) {\\n            int num = Integer.MAX_VALUE;\\n            \\n            for(int j = 0; j < primes.length; j++) {\\n                int index = indices[j];\\n                if(primes[j] * res[index] < num) {\\n                    num = primes[j] * res[index];\\n                }\\n            }\\n            \\n            res[i] = num;\\n            \\n            for(int j = 0; j < primes.length; j++) {\\n                int index = indices[j];\\n                if(primes[j] * res[index] == num) {\\n                    indices[j]++; \\n                }\\n            }\\n                       \\n        }\\n        \\n        return res[n-1];    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991806,
                "title": "python-solution-using-heap",
                "content": "```\\nimport heapq\\n\\ndef get_uglies(primes):\\n    h = [1]\\n    prev = None\\n    while True:\\n        item = heapq.heappop(h)\\n        if item != prev:\\n            for p in primes:\\n                heapq.heappush(h, p * item)\\n            prev = item\\n            yield item\\n\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        for _, u in zip(range(n), get_uglies(primes)): \\n            pass\\n        return u\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\ndef get_uglies(primes):\\n    h = [1]\\n    prev = None\\n    while True:\\n        item = heapq.heappop(h)\\n        if item != prev:\\n            for p in primes:\\n                heapq.heappush(h, p * item)\\n            prev = item\\n            yield item\\n\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        for _, u in zip(range(n), get_uglies(primes)): \\n            pass\\n        return u\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917209,
                "title": "c-heap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef unsigned long long ull;\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        priority_queue<ull> q;\\n        vector<ull> res;\\n        q.push(-1);\\n        set<ull> s;\\n        while(res.size() <= n) {\\n            ull t = q.top(); q.pop();\\n            if(s.find(t) != s.end()) continue;\\n            res.push_back((-1)*t);\\n            for(int i:primes) {\\n                q.push(t*i);\\n            }\\n            s.insert(t);\\n        }\\n        return res[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef unsigned long long ull;\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        priority_queue<ull> q;\\n        vector<ull> res;\\n        q.push(-1);\\n        set<ull> s;\\n        while(res.size() <= n) {\\n            ull t = q.top(); q.pop();\\n            if(s.find(t) != s.end()) continue;\\n            res.push_back((-1)*t);\\n            for(int i:primes) {\\n                q.push(t*i);\\n            }\\n            s.insert(t);\\n        }\\n        return res[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728954,
                "title": "cpp-pure-min-heap-solution-with-comments-also-handles-duplicates",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t  typedef long long int  ll;\\n\\t\\t\\tint nthSuperUglyNumber(int n, vector<int>& primes) {\\n\\t\\t\\t   if(n == 0){\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(n == 1){\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t priority_queue<ll,vector<ll>,greater<ll>> pq;\\n\\n\\t\\t\\t\\tll  res;\\n\\n\\t\\t //Pushing the initial primes same as if they are multiplied by  1\\n\\t\\t\\t   for(int i : primes){\\n\\t\\t\\t\\t\\tpq.push(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t  pq.push(INT_MAX-1); //Taking care of the pq.top() if heap elements becomes zero (for ex n = 2, primes= [2])\\n\\t\\t\\t  //As 1 is default the first nummber we go for other n-1 numbers\\n\\t\\t\\t while(n>1){\\n\\t\\t\\t\\t\\tres = pq.top();\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t\\tif(res != pq.top()){    //Handling duplicates\\n\\t\\t\\t\\t\\t\\tn--;\\n\\t\\t\\t\\t\\t\\tfor(int i : primes){\\n\\t\\t\\t\\t\\t\\t\\tpq.push(i*res);  //Adding multiples of the res\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t  return res;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t  typedef long long int  ll;\\n\\t\\t\\tint nthSuperUglyNumber(int n, vector<int>& primes) {\\n\\t\\t\\t   if(n == 0){\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 722792,
                "title": "priorityqueue-and-treeset-solution-short-and-easy-to-understand",
                "content": "```\\nSolution 2: Using TreeSet N*K+ N*KLog(K*N)\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        if(n==1)\\n            return 1;\\n        TreeSet<Long> q = new TreeSet<>((a,b)-> a.compareTo(b));  // So we don\\'t need to handle the duplicate while poll from Queue\\n        q.add(1l);\\n        for(int i=1; i<n; i++){\\n            long temp = q.pollFirst();\\n            \\n            for(int j : primes){\\n                q.add(temp*j);\\n            }\\n        }\\n        return q.pollFirst().intValue();\\n    \\n    }\\n}\\n\\nSolution 3: Using PriorityQueue N*K+ N*KLog(K*N)\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        if(n==1)\\n            return 1;\\n        Queue<Long> q = new PriorityQueue<>((a,b)-> a.compareTo(b)); // Default as min head in java\\n        q.offer(1l);\\n        for(int i=1; i<n; i++){\\n            long temp = q.poll();\\n\\t\\t\\t\\n            while(q.size()>0 && q.peek()==temp) //remove duplicate\\n                temp= q.poll();\\n            \\n            for(int j : primes){\\n                q.offer(temp*j);\\n            }\\n        }\\n        return q.poll().intValue();\\n    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nSolution 2: Using TreeSet N*K+ N*KLog(K*N)\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        if(n==1)\\n            return 1;\\n        TreeSet<Long> q = new TreeSet<>((a,b)-> a.compareTo(b));  // So we don\\'t need to handle the duplicate while poll from Queue\\n        q.add(1l);\\n        for(int i=1; i<n; i++){\\n            long temp = q.pollFirst();\\n            \\n            for(int j : primes){\\n                q.add(temp*j);\\n            }\\n        }\\n        return q.pollFirst().intValue();\\n    \\n    }\\n}\\n\\nSolution 3: Using PriorityQueue N*K+ N*KLog(K*N)\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        if(n==1)\\n            return 1;\\n        Queue<Long> q = new PriorityQueue<>((a,b)-> a.compareTo(b)); // Default as min head in java\\n        q.offer(1l);\\n        for(int i=1; i<n; i++){\\n            long temp = q.poll();\\n\\t\\t\\t\\n            while(q.size()>0 && q.peek()==temp) //remove duplicate\\n                temp= q.poll();\\n            \\n            for(int j : primes){\\n                q.offer(temp*j);\\n            }\\n        }\\n        return q.poll().intValue();\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719958,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n         vector<int> dp(n, 0);\\n        \\n        dp[0] = 1;\\n        \\n        int m = primes.size();\\n        vector<int> pos(m, 0);\\n        vector<int> prod(m, 0);\\n        \\n        \\n        for(int i = 1; i < n; ++i) {\\n            int cur= INT_MAX;\\n            \\n            for(int i = 0; i < m; ++i) {\\n                prod[i] = dp[pos[i]] * primes[i];\\n                cur = min(cur, prod[i]);\\n            }\\n            \\n            for(int i = 0; i < m; ++i) {\\n                if(cur == prod[i]) {\\n                    pos[i]++;\\n                }\\n                \\n            }\\n            \\n            dp[i] = cur;\\n            \\n        }\\n        \\n        return(dp[n - 1]);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n         vector<int> dp(n, 0);\\n        \\n        dp[0] = 1;\\n        \\n        int m = primes.size();\\n        vector<int> pos(m, 0);\\n        vector<int> prod(m, 0);\\n        \\n        \\n        for(int i = 1; i < n; ++i) {\\n            int cur= INT_MAX;\\n            \\n            for(int i = 0; i < m; ++i) {\\n                prod[i] = dp[pos[i]] * primes[i];\\n                cur = min(cur, prod[i]);\\n            }\\n            \\n            for(int i = 0; i < m; ++i) {\\n                if(cur == prod[i]) {\\n                    pos[i]++;\\n                }\\n                \\n            }\\n            \\n            dp[i] = cur;\\n            \\n        }\\n        \\n        return(dp[n - 1]);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717613,
                "title": "python3-min-heap-and-set-generate-all-possible-values",
                "content": "a) Try generating all next possible values using primes and put them in a minHeap.\\nb) Use Set to store if a number is already visited\\n```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        import heapq\\n        heap = [1]\\n        seen = set()\\n        cnt = 0\\n        while True:\\n            val = heapq.heappop(heap)\\n            if val in seen:\\n                continue\\n            seen.add(val)\\n            cnt += 1\\n            if cnt == n:\\n                return val\\n            for prime in primes:\\n                if val * prime not in seen:\\n                    heapq.heappush(heap, val*prime)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        import heapq\\n        heap = [1]\\n        seen = set()\\n        cnt = 0\\n        while True:\\n            val = heapq.heappop(heap)\\n            if val in seen:\\n                continue\\n            seen.add(val)\\n            cnt += 1\\n            if cnt == n:\\n                return val\\n            for prime in primes:\\n                if val * prime not in seen:\\n                    heapq.heappush(heap, val*prime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712837,
                "title": "java-priorityqueue-complete-explanation-with-examples-easy-to-understand",
                "content": "we use **Min Heap PriorityQueue**.\\nThe idea is to push the 1st ugly number which is 1 into PriorityQueue and in every iteration take the top of PriorityQueue, check for duplicates and then push all the mulitples of that top number into PriorityQueue.\\n\\nFor example. primes[] = {5,7,13}\\nIn first iteration 1 is top so 1 is popped and 1 * 5, 1 * 7, 1 * 13 is pushed.\\nIn second iteration top is 7, so it is popped and 7 * 5, 7 * 7, 7 * 13 are pushed and so on.\\n\\nBelow is the implementation for the same algorithm:\\n\\n```\\npublic int nthSuperUglyNumber(int n, int[] primes) {\\n        PriorityQueue<Long> q=new PriorityQueue<>();\\n        int count=1; long num=1;\\n        for(int i:primes){q.add((long) i);}\\n        while(count<n){\\n            num=q.poll();\\n            if(q.isEmpty()||num!=q.peek()){\\n                count++;\\n                for(int i:primes){\\n                    q.add(num*i);\\n                }\\n            }\\n        }\\n        return (int)num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int nthSuperUglyNumber(int n, int[] primes) {\\n        PriorityQueue<Long> q=new PriorityQueue<>();\\n        int count=1; long num=1;\\n        for(int i:primes){q.add((long) i);}\\n        while(count<n){\\n            num=q.poll();\\n            if(q.isEmpty()||num!=q.peek()){\\n                count++;\\n                for(int i:primes){\\n                    q.add(num*i);\\n                }\\n            }\\n        }\\n        return (int)num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697569,
                "title": "python-fast-dp-with-heap-98-5",
                "content": "The idea is simple: maintain a heap of candidate. At the i-th iteration we find out the i-th super ugly number by popping the top of the heap. New candidates are generated by multiply heap top by each number in prime list.\\n\\nHowever, to make the code run faster, a few optimizations are made here:\\n1. We try to avoid adding duplicates. Take for example, primes[i] * primes[j], this can be generated by both primes[i] and primes[j]. A natural thought here is when maintain a \"base index\" of a candidate. Base index of a number <code>p</code>is <code>k</code> if it is generated by a subset of <code>primes[0], ..., primes[k]</code> only. We will only add <code>k + 1</code> multiples of p, namely <code>(p * primes[0], ..., p * primes[k])</code>. Because we know the larger multiples, for example, <code>p * primes[-1]</code> will be added later when we come to pick up a number larger than p (for example <code>p * primes[-1] / primes[k]</code>. \\n\\nNote that if this technique sounds unfamiliar to you, you can totally do it an easier way by maintaining a set. We will only add a candidate to the heap if that number wasn\\'t seen in set. Time complexity remains unchanged.\\n\\n2. We know all candidates are less than 2^(31), so we can break the adding loop early if we found <code>p * primes[j] > 2 ^31</code>\\n\\nTime Complexity: We will have at most (N - 1)* K elements in our heap. So, time complexity would be: O(N * log[(N - 1) * K]) = O(NlogN)\\n```\\ndef nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n\\tp = 1\\n\\theap = []\\n\\tfor i in range(min(n, len(primes))):\\n\\t\\theappush(heap, (primes[i], i))\\n\\ti, MAX = 0, 1 << 31\\n\\tfor i in range(n - 1):\\n\\t\\tp, base = heappop(heap)\\n\\t\\tfor j in range(base + 1):\\n\\t\\t\\tif p * primes[j] > MAX:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\theappush(heap, (p * primes[j], j))\\n\\treturn p\\n```",
                "solutionTags": [],
                "code": "```\\ndef nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n\\tp = 1\\n\\theap = []\\n\\tfor i in range(min(n, len(primes))):\\n\\t\\theappush(heap, (primes[i], i))\\n\\ti, MAX = 0, 1 << 31\\n\\tfor i in range(n - 1):\\n\\t\\tp, base = heappop(heap)\\n\\t\\tfor j in range(base + 1):\\n\\t\\t\\tif p * primes[j] > MAX:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\theappush(heap, (p * primes[j], j))\\n\\treturn p\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 631893,
                "title": "c-simple-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> dp;\\n        dp.push_back(1);\\n        for(int i=1;i<n;++i){\\n            vector<int> temp;\\n            for(int j=0;j<primes.size();++j){\\n                int val = dp[i-1]/primes[j];\\n                auto up = upper_bound(dp.begin(), dp.end(), val);\\n                temp.push_back(dp[up-dp.begin()]*primes[j]);\\n            }\\n            dp.push_back(*min_element(temp.begin(), temp.end()));\\n        }\\n        return dp[n-1];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<int> dp;\\n        dp.push_back(1);\\n        for(int i=1;i<n;++i){\\n            vector<int> temp;\\n            for(int j=0;j<primes.size();++j){\\n                int val = dp[i-1]/primes[j];\\n                auto up = upper_bound(dp.begin(), dp.end(), val);\\n                temp.push_back(dp[up-dp.begin()]*primes[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 582741,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\n    struct compare {\\n        bool operator() (pair<int, int>p1, pair<int, int>p2) {\\n            return p1.first > p2.first;\\n        }\\n    };\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        \\n        int p = primes.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, compare>pq;\\n        vector<int>index(p, 1);\\n        \\n        for (int i = 0; i < p; i++)\\n            pq.push(make_pair(primes[i], i));\\n        \\n        vector<int>ugly(n+1, 0);\\n        ugly[1] = 1;\\n        int k = 2;\\n        \\n        while (k <= n) {\\n            ugly[k] = pq.top().first;            \\n            while (!pq.empty() && ugly[k] == pq.top().first) {\\n                pair<int, int>p = pq.top();\\n                pq.pop();\\n                index[p.second]++;\\n                p.first = ugly[index[p.second]]*primes[p.second];\\n                pq.push(p);\\n            }\\n\\n            k++;\\n        }\\n            \\n        return ugly[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct compare {\\n        bool operator() (pair<int, int>p1, pair<int, int>p2) {\\n            return p1.first > p2.first;\\n        }\\n    };\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        \\n        int p = primes.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, compare>pq;\\n        vector<int>index(p, 1);\\n        \\n        for (int i = 0; i < p; i++)\\n            pq.push(make_pair(primes[i], i));\\n        \\n        vector<int>ugly(n+1, 0);\\n        ugly[1] = 1;\\n        int k = 2;\\n        \\n        while (k <= n) {\\n            ugly[k] = pq.top().first;            \\n            while (!pq.empty() && ugly[k] == pq.top().first) {\\n                pair<int, int>p = pq.top();\\n                pq.pop();\\n                index[p.second]++;\\n                p.first = ugly[index[p.second]]*primes[p.second];\\n                pq.push(p);\\n            }\\n\\n            k++;\\n        }\\n            \\n        return ugly[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578886,
                "title": "c-heap-dp-solution-76ms",
                "content": "heap solution:\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        priority_queue<int, vector<int>, greater<int>> heap;\\n        unordered_set<int> sets;\\n        int m = primes.size();\\n        heap.push(1);\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int num = heap.top();\\n            heap.pop();\\n            for(int j=0;j<m;j++)\\n            {\\n                long tmp = (long)num * (long)primes[j];\\n                if(tmp<=INT_MAX&&sets.count(tmp)==0)\\n                {\\n                    sets.insert(tmp);\\n                    heap.push(tmp);\\n                }\\n            }\\n        }\\n        return heap.top();\\n    }\\n};\\n```\\n\\ndp solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int m = primes.size();\\n        vector<int> nums(n, 1);\\n        vector<int> points(m, 0);\\n        for(int i=1;i<n;i++)\\n        {\\n            int num = INT_MAX;\\n            for(int j=0;j<m;j++)\\n                num = min(num, nums[points[j]]*primes[j]);\\n            nums[i] = num;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(nums[points[j]]*primes[j]==num)\\n                    points[j]++;\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        priority_queue<int, vector<int>, greater<int>> heap;\\n        unordered_set<int> sets;\\n        int m = primes.size();\\n        heap.push(1);\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int num = heap.top();\\n            heap.pop();\\n            for(int j=0;j<m;j++)\\n            {\\n                long tmp = (long)num * (long)primes[j];\\n                if(tmp<=INT_MAX&&sets.count(tmp)==0)\\n                {\\n                    sets.insert(tmp);\\n                    heap.push(tmp);\\n                }\\n            }\\n        }\\n        return heap.top();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int m = primes.size();\\n        vector<int> nums(n, 1);\\n        vector<int> points(m, 0);\\n        for(int i=1;i<n;i++)\\n        {\\n            int num = INT_MAX;\\n            for(int j=0;j<m;j++)\\n                num = min(num, nums[points[j]]*primes[j]);\\n            nums[i] = num;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(nums[points[j]]*primes[j]==num)\\n                    points[j]++;\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534106,
                "title": "c-heap-solution",
                "content": "```\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if(n == 1) return 1;\\n        vector<int> res = {1};\\n        auto cmp = [&](auto& a, auto& b) {\\n            return primes[a[0]]*res[a[1]] > primes[b[0]]*res[b[1]];\\n        };\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);\\n        \\n        for(int i = 0; i < primes.size(); i++) pq.push({i, 0});\\n        \\n        n--;\\n        while(!pq.empty()) {\\n            auto t = pq.top();\\n            pq.pop();\\n            int cur = primes[t[0]]*res[t[1]];\\n            if(cur > res.back()) {\\n                if(--n == 0) return cur;\\n                res.push_back(cur);\\n            }\\n            pq.push({t[0], t[1]+1});\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if(n == 1) return 1;\\n        vector<int> res = {1};\\n        auto cmp = [&](auto& a, auto& b) {\\n            return primes[a[0]]*res[a[1]] > primes[b[0]]*res[b[1]];\\n        };\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);\\n        \\n        for(int i = 0; i < primes.size(); i++) pq.push({i, 0});\\n        \\n        n--;\\n        while(!pq.empty()) {\\n            auto t = pq.top();\\n            pq.pop();\\n            int cur = primes[t[0]]*res[t[1]];\\n            if(cur > res.back()) {\\n                if(--n == 0) return cur;\\n                res.push_back(cur);\\n            }\\n            pq.push({t[0], t[1]+1});\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 514008,
                "title": "python-using-dict",
                "content": "```\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        dp = [1]\\n        i = 1\\n        d = dict((val, 0) for val in primes)\\n        while i < n:\\n            min_val = min(v*dp[d[v]] for v in d)\\n            for v in d:\\n                if min_val == v*dp[d[v]]:\\n                    d[v] += 1\\n            i += 1\\n            dp.append(min_val)\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\\n        dp = [1]\\n        i = 1\\n        d = dict((val, 0) for val in primes)\\n        while i < n:\\n            min_val = min(v*dp[d[v]] for v in d)\\n            for v in d:\\n                if min_val == v*dp[d[v]]:\\n                    d[v] += 1\\n            i += 1\\n            dp.append(min_val)\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 368981,
                "title": "java-solution",
                "content": "```\\npublic int nthSuperUglyNumber(int n, int[] primes) {\\n\\tint[] idx = new int[primes.length];\\n\\tint[] ugly = new int[n];\\n\\tint[] val = new int[primes.length];\\n\\tArrays.fill(val, 1);\\n\\tint next = 1;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tugly[i] = next;\\n\\t\\tnext = Integer.MAX_VALUE;\\n\\t\\tfor (int j = 0; j < primes.length; j++) {\\n\\t\\t\\tif (val[j] == ugly[i]) val[j] = primes[j] * ugly[idx[j]++];\\n\\t\\t\\tnext = Math.min(next, val[j]);\\n\\t\\t}\\n\\t}\\n\\n\\treturn ugly[n - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int nthSuperUglyNumber(int n, int[] primes) {\\n\\tint[] idx = new int[primes.length];\\n\\tint[] ugly = new int[n];\\n\\tint[] val = new int[primes.length];\\n\\tArrays.fill(val, 1);\\n\\tint next = 1;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tugly[i] = next;\\n\\t\\tnext = Integer.MAX_VALUE;\\n\\t\\tfor (int j = 0; j < primes.length; j++) {\\n\\t\\t\\tif (val[j] == ugly[i]) val[j] = primes[j] * ugly[idx[j]++];\\n\\t\\t\\tnext = Math.min(next, val[j]);\\n\\t\\t}\\n\\t}\\n\\n\\treturn ugly[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 251697,
                "title": "10-lines-min-heap-set-java-solution",
                "content": "```\\npublic int nthSuperUglyNumber(int n, int[] primes) {\\n    PriorityQueue<Long> minHeap = new PriorityQueue<>();\\n    Set<Long> visited = new HashSet<>();\\n    visited.add(1L);\\n    minHeap.offer(1L);\\n    while (n-- > 1) {\\n      long val = minHeap.poll();\\n      for (int prime : primes) {\\n        if (visited.add(val * prime)) {\\n          minHeap.offer(val * prime);\\n        }\\n      }\\n    }\\n    return minHeap.peek().intValue();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int nthSuperUglyNumber(int n, int[] primes) {\\n    PriorityQueue<Long> minHeap = new PriorityQueue<>();\\n    Set<Long> visited = new HashSet<>();\\n    visited.add(1L);\\n    minHeap.offer(1L);\\n    while (n-- > 1) {\\n      long val = minHeap.poll();\\n      for (int prime : primes) {\\n        if (visited.add(val * prime)) {\\n          minHeap.offer(val * prime);\\n        }\\n      }\\n    }\\n    return minHeap.peek().intValue();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204633,
                "title": "dp-method-to-solve-it",
                "content": "I use k(the Numbers of primes) pointers to every prime,every time getting a nth number,the according primes pointer keep +1.\\nFor example,primes = [2,7,13,19],At first,the dp[0] = 1,pointer = [0,0,0,0];1st:(2 * 1,7 * 1,13 * 1,19 * 1),choose the smallest number 2 as the next dp and the pointers step forward,So,dp[1] = 2,pointer = [1,0,0,0].2ed:(2 * 2,7 * 1,13 * 1,19 * 1),choose 4 as the next dp,so dp[2] = 4,pointer = [2,0,0,0].However we should notice 7 * 2\\'s prime is not only 2 but also 7,so in this situation,the 2\\'s pointer and 7\\'s pointer all step forward.\\n\\nThe code:\\n```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[] pointer = new int[primes.length];\\n        int k = primes.length;\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n        int i = 1;\\n        while(i < n){\\n            dp[i] = primes[0] * dp[pointer[0]];\\n            List<Integer> index = new LinkedList<>();\\n            index.add(0);\\n            for(int j = 1;j < k;j++){\\n                if(primes[j] * dp[pointer[j]] < dp[i]){\\n                    index.clear();\\n                    index.add(j);\\n                    dp[i] = primes[j] * dp[pointer[j]];\\n                }else if(primes[j] * dp[pointer[j]] == dp[i])index.add(j);\\n            }\\n            for(int j = 0;j < index.size();j++){\\n                pointer[index.get(j)] = pointer[index.get(j)] + 1;\\n            }\\n            i++;\\n        }\\n        return dp[n - 1];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[] pointer = new int[primes.length];\\n        int k = primes.length;\\n        int[] dp = new int[n];\\n        dp[0] = 1;\\n        int i = 1;\\n        while(i < n){\\n            dp[i] = primes[0] * dp[pointer[0]];\\n            List<Integer> index = new LinkedList<>();\\n            index.add(0);\\n            for(int j = 1;j < k;j++){\\n                if(primes[j] * dp[pointer[j]] < dp[i]){\\n                    index.clear();\\n                    index.add(j);\\n                    dp[i] = primes[j] * dp[pointer[j]];\\n                }else if(primes[j] * dp[pointer[j]] == dp[i])index.add(j);\\n            }\\n            for(int j = 0;j < index.size();j++){\\n                pointer[index.get(j)] = pointer[index.get(j)] + 1;\\n            }\\n            i++;\\n        }\\n        return dp[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170133,
                "title": "simple-c-code-using-set",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int cur=1;\\n        set<int> buf(primes.begin(),primes.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            auto itr=buf.begin();\\n            cur=*itr;\\n            buf.erase(itr);\\n            for(int p:primes)\\n            {\\n                if((long long)p*cur > INT_MAX)\\n                    continue;\\n                buf.insert(p*cur);\\n            }\\n        }\\n        return cur;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int cur=1;\\n        set<int> buf(primes.begin(),primes.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            auto itr=buf.begin();\\n            cur=*itr;\\n            buf.erase(itr);\\n            for(int p:primes)\\n            {\\n                if((long long)p*cur > INT_MAX)\\n                    continue;\\n                buf.insert(p*cur);\\n            }\\n        }\\n        return cur;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76297,
                "title": "python-dp-with-k-pointers-some-comments",
                "content": "```\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        k = len(primes)\\n        dp, index = [1] + [0] * n, [0] * k\\n        for i in range(1, n):\\n            uglies = [dp[index[j]] * primes[j] for j in range(0, k)] # Build next possible ugly numbers.\\n            dp[i] = min(uglies)     # Find the next one.\\n            index = [index[j] + 1 if uglies[j] == dp[i] else index[j] for j in range(0, k)] # Advance the index(es)\\n        return dp[n-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nthSuperUglyNumber(self, n, primes):\\n        \"\"\"\\n        :type n: int\\n        :type primes: List[int]\\n        :rtype: int\\n        \"\"\"\\n        k = len(primes)\\n        dp, index = [1] + [0] * n, [0] * k\\n        for i in range(1, n):\\n            uglies = [dp[index[j]] * primes[j] for j in range(0, k)] # Build next possible ugly numbers.\\n            dp[i] = min(uglies)     # Find the next one.\\n            index = [index[j] + 1 if uglies[j] == dp[i] else index[j] for j in range(0, k)] # Advance the index(es)\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76315,
                "title": "c-priority-queue-solution-o-n-log-k-by-chaoyanghe",
                "content": "This is my c++ priority_queue solution, pass all the test cases. \\nglad to chat with you about the code, my WeChat ID: TTHarry\\n\\n```\\nstruct Ugly{\\n    int mVal;\\n    int mIdx;\\n    int mP;\\n    Ugly(int val, int idx, int p){\\n        mVal = val;\\n        mIdx = idx;\\n        mP = p;\\n    }\\n};\\n\\nclass MyCompare{\\npublic:\\n    bool operator()(Ugly& u1, Ugly& u2){\\n        return u1.mVal > u2.mVal;//min-heap\\n    }\\n};\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if(n<=0) return -1;\\n        if(n==1) return 1;\\n        vector<int> ugly(n, INT_MAX);\\n        ugly[0] = 1;\\n        priority_queue< Ugly, vector<Ugly>, MyCompare > pq;\\n        for(int k = 0; k < primes.size(); k++) pq.push(Ugly(primes[k], 0, primes[k]));\\n        for(int i = 1; i < n; i++){\\n            Ugly u = pq.top();\\n            ugly[i] = u.mVal;\\n            while(pq.top().mVal == ugly[i]){\\n                Ugly next = pq.top();\\n                pq.pop();\\n                next.mIdx++;\\n                next.mVal = next.mP * ugly[next.mIdx];\\n                pq.push(next);\\n                if(pq.size() == 1) break;\\n            }\\n        }\\n        return ugly[n-1];\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nstruct Ugly{\\n    int mVal;\\n    int mIdx;\\n    int mP;\\n    Ugly(int val, int idx, int p){\\n        mVal = val;\\n        mIdx = idx;\\n        mP = p;\\n    }\\n};\\n\\nclass MyCompare{\\npublic:\\n    bool operator()(Ugly& u1, Ugly& u2){\\n        return u1.mVal > u2.mVal;//min-heap\\n    }\\n};\\nclass Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if(n<=0) return -1;\\n        if(n==1) return 1;\\n        vector<int> ugly(n, INT_MAX);\\n        ugly[0] = 1;\\n        priority_queue< Ugly, vector<Ugly>, MyCompare > pq;\\n        for(int k = 0; k < primes.size(); k++) pq.push(Ugly(primes[k], 0, primes[k]));\\n        for(int i = 1; i < n; i++){\\n            Ugly u = pq.top();\\n            ugly[i] = u.mVal;\\n            while(pq.top().mVal == ugly[i]){\\n                Ugly next = pq.top();\\n                pq.pop();\\n                next.mIdx++;\\n                next.mVal = next.mP * ugly[next.mIdx];\\n                pq.push(next);\\n                if(pq.size() == 1) break;\\n            }\\n        }\\n        return ugly[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76320,
                "title": "c-simple-solution-beats-95-55-with-comments-in-code",
                "content": "```\\nint nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int idx[primes.size()]; memset(idx, 0, sizeof(idx));        // current index for primes[i] in dp\\n        int next[primes.size()]; memset(next, 0, sizeof(next));     // next available primes[i] * dp[idx[i]]\\n        int dp[n]; memset(dp, 0, sizeof(dp)); dp[0] = 1;            // dp for answer\\n        \\n        for (int i = 0; i < primes.size(); i++) {\\n            next[i] = primes[i];                                    // initialize the values\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            dp[i] = INT_MAX;\\n            \\n            for (int j = 0; j < primes.size(); j++) {\\n                dp[i] = min(dp[i], next[j]);                        // find min in next for dp[i] \\n            }\\n            \\n            for (int j = 0; j < primes.size(); j++) {\\n                if (dp[i] == next[j]) {\\n                    next[j] = primes[j] * dp[++idx[j]];             // update idx and next\\n                }\\n            }\\n        }\\n        \\n        return dp[n - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint nthSuperUglyNumber(int n, vector<int>& primes) {\\n        int idx[primes.size()]; memset(idx, 0, sizeof(idx));        // current index for primes[i] in dp\\n        int next[primes.size()]; memset(next, 0, sizeof(next));     // next available primes[i] * dp[idx[i]]\\n        int dp[n]; memset(dp, 0, sizeof(dp)); dp[0] = 1;            // dp for answer\\n        \\n        for (int i = 0; i < primes.size(); i++) {\\n            next[i] = primes[i];                                    // initialize the values\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            dp[i] = INT_MAX;\\n            \\n            for (int j = 0; j < primes.size(); j++) {\\n                dp[i] = min(dp[i], next[j]);                        // find min in next for dp[i] \\n            }\\n            \\n            for (int j = 0; j < primes.size(); j++) {\\n                if (dp[i] == next[j]) {\\n                    next[j] = primes[j] * dp[++idx[j]];             // update idx and next\\n                }\\n            }\\n        }\\n        \\n        return dp[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76325,
                "title": "fastest-nth-ugly-number-ugly-number-ii-and-super-ugly-number-similar-solutions-java-dynamic-programming",
                "content": "Nth Ugly Number Solution: -\\n\\n```\\npublic class Solution {\\n    public int nthUglyNumber(int n) {\\n        if(n <= 0) {\\n            return 0;\\n        }\\n        int[] ugly = new int[n];\\n        ugly[0] = 1;\\n        int index2 = 0, index3 = 0, index5 = 0;\\n        int factor2 = 2, factor3 = 3, factor5 = 5;\\n        int curMin = 1;\\n        for(int i = 1; i < n; ++i) {\\n            curMin = Math.min(factor2, Math.min(factor3, factor5));\\n            ugly[i] = curMin;\\n            if(factor2 == curMin){\\n                factor2 = 2*ugly[++index2];\\n            }\\n            if(factor3 == curMin){\\n                factor3 = 3*ugly[++index3];\\n            }\\n            if(factor5 == curMin){\\n                factor5 = 5*ugly[++index5];\\n            }\\n        }\\n        return ugly[n-1];\\n    }\\n}\\n```\\n\\nSuper Ugly Number Solution. Since we do not know what the prime factors will be, we will have to create 2 arrays for that.\\n\\n```\\npublic class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n\\tif(n <= 0 || primes == null || primes.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint[] ugly = new int[n];\\n\\tugly[0] = 1;\\n\\tint length = primes.length;\\n\\tint[] indexes = new int[length];\\n\\tint[] factors = new int[length];\\n\\tfor(int i = 0; i < length; ++i) {\\n\\t\\tfactors[i] = primes[i];\\n\\t}\\n\\tint curMin = 1;\\n\\tfor(int i = 1; i < n; i++){\\n\\t\\tcurMin = factors[0];\\n\\t\\tfor(int j = 1; j < length; ++j) {\\n\\t\\t\\tcurMin = Math.min(curMin, factors[j]);\\n\\t\\t}\\n\\t\\tugly[i] = curMin;\\n\\t\\tfor(int j = 0; j < length; ++j) {\\n\\t\\t\\tif(curMin == factors[j]) {\\n\\t\\t\\t\\tfactors[j] = primes[j] * ugly[++indexes[j]];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ugly[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int nthUglyNumber(int n) {\\n        if(n <= 0) {\\n            return 0;\\n        }\\n        int[] ugly = new int[n];\\n        ugly[0] = 1;\\n        int index2 = 0, index3 = 0, index5 = 0;\\n        int factor2 = 2, factor3 = 3, factor5 = 5;\\n        int curMin = 1;\\n        for(int i = 1; i < n; ++i) {\\n            curMin = Math.min(factor2, Math.min(factor3, factor5));\\n            ugly[i] = curMin;\\n            if(factor2 == curMin){\\n                factor2 = 2*ugly[++index2];\\n            }\\n            if(factor3 == curMin){\\n                factor3 = 3*ugly[++index3];\\n            }\\n            if(factor5 == curMin){\\n                factor5 = 5*ugly[++index5];\\n            }\\n        }\\n        return ugly[n-1];\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n\\tif(n <= 0 || primes == null || primes.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint[] ugly = new int[n];\\n\\tugly[0] = 1;\\n\\tint length = primes.length;\\n\\tint[] indexes = new int[length];\\n\\tint[] factors = new int[length];\\n\\tfor(int i = 0; i < length; ++i) {\\n\\t\\tfactors[i] = primes[i];\\n\\t}\\n\\tint curMin = 1;\\n\\tfor(int i = 1; i < n; i++){\\n\\t\\tcurMin = factors[0];\\n\\t\\tfor(int j = 1; j < length; ++j) {\\n\\t\\t\\tcurMin = Math.min(curMin, factors[j]);\\n\\t\\t}\\n\\t\\tugly[i] = curMin;\\n\\t\\tfor(int j = 0; j < length; ++j) {\\n\\t\\t\\tif(curMin == factors[j]) {\\n\\t\\t\\t\\tfactors[j] = primes[j] * ugly[++indexes[j]];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ugly[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76336,
                "title": "my-simple-c-solution-20ms-o-nk",
                "content": "    \\n    int data[1000000+5]={1};\\n    int nthSuperUglyNumber(int n, int* primes, int primesSize) {\\n        int ptr[105]={0}, value[105];\\n        int min_value, last = 1, cnt = 1;\\n        memcpy(value,primes,sizeof(int)*primesSize);\\n        while(cnt < n)\\n        {\\n            min_value = INT_MAX;\\n            for(int i = 0; i < primesSize; i++)\\n            {\\n                if(value[i] <= last)\\n                    value[i] = primes[i] * data[++ptr[i]];\\n                if(min_value > value[i])\\n                    min_value = value[i];\\n            }\\n            data[cnt++] = last = min_value;\\n        }\\n        return data[n-1];\\n    }",
                "solutionTags": [],
                "code": "    \\n    int data[1000000+5]={1};\\n    int nthSuperUglyNumber(int n, int* primes, int primesSize) {\\n        int ptr[105]={0}, value[105];\\n        int min_value, last = 1, cnt = 1;\\n        memcpy(value,primes,sizeof(int)*primesSize);\\n        while(cnt < n)\\n        {\\n            min_value = INT_MAX;\\n            for(int i = 0; i < primesSize; i++)\\n            {\\n                if(value[i] <= last)\\n                    value[i] = primes[i] * data[++ptr[i]];\\n                if(min_value > value[i])\\n                    min_value = value[i];\\n            }\\n            data[cnt++] = last = min_value;\\n        }\\n        return data[n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 76344,
                "title": "c-104ms-solution-o-n-primes-size-space-o-n-primes-size-time",
                "content": "    class Solution {\\n    public:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if (n==1) return 1;\\n        vector<int> res(1,1);\\n        int sz=primes.size();\\n        vector<int> index(sz,0);\\n        int minNum;\\n        for (int k=2;k<=n;k++){\\n            minNum=res[index[0]]*primes[0];\\n            for (int j=1;j<sz;j++){\\n                int temp = res[index[j]]*primes[j];\\n                minNum = minNum>temp?temp:minNum;\\n            }\\n            res.push_back(minNum);  // minNum is the next result.\\n            for (int i=0;i<sz;i++){\\n                if (res[index[i]]*primes[i]==minNum) index[i]++;  // move all minNum index to the right\\n            }\\n        }\\n        return minNum;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        if (n==1) return 1;\\n        vector<int> res(1,1);\\n        int sz=primes.size();\\n        vector<int> index(sz,0);\\n        int minNum;\\n        for (int k=2;k<=n;k++){\\n            minNum=res[index[0]]*primes[0];\\n            for (int j=1;j<sz;j++){\\n                int temp = res[index[j]]*primes[j];\\n                minNum = minNum>temp?temp:minNum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 76346,
                "title": "why-o-nlogk-algorithm-takes-longer-running-time-than-o-nk-algorithm",
                "content": "This solution avoid repeated multiplication,  but the running time is 384ms, larger then the O(NK) algorithm\\n\\n       class Solution {\\n        public:\\n            int nthSuperUglyNumber(int n, vector<int>& primes) {\\n                if (n <= 1) return 1;\\n                vector<int> index(primes.size());\\n                vector<int> uglyNumbers(n);\\n                uglyNumbers[0] = 1;\\n                using val_pair = pair<int, size_t>;\\n                priority_queue<val_pair, vector<val_pair>, greater<val_pair>> pq;\\n                for (int j = 0; j < primes.size(); ++j) {\\n                    if (uglyNumbers[index[j]])\\n                        pq.push(make_pair(primes[j]*uglyNumbers[index[j]], j));\\n                }\\n                for (int i = 1; i < n; ++i) {\\n                    if (!pq.empty()) {\\n                        auto top = pq.top();\\n                        pq.pop();\\n                        uglyNumbers[i] = top.first;\\n                        int j = top.second;\\n                        index[j]++;\\n                        pq.push(make_pair(primes[j]*uglyNumbers[index[j]], j));\\n                        while (!pq.empty() && pq.top().first == top.first) {\\n                            auto next = pq.top();\\n                            pq.pop();\\n                            j = next.second;\\n                            index[j]++;\\n                            pq.push(make_pair(primes[j]*uglyNumbers[index[j]], j));\\n                        }                \\n                    }\\n        \\n                }\\n                return uglyNumbers.back();\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int nthSuperUglyNumber(int n, vector<int>& primes) {\\n                if (n <= 1) return 1;\\n                vector<int> index(primes.size());\\n                vector<int> uglyNumbers(n);\\n                uglyNumbers[0] = 1;\\n                using val_pair = pair<int, size_t>;\\n                priority_queue<val_pair, vector<val_pair>, greater<val_pair>> pq;\\n                for (int j = 0; j < primes.size(); ++j) {\\n                    if (uglyNumbers[index[j]])\\n                        pq.push(make_pair(primes[j]*uglyNumbers[index[j]], j));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 76349,
                "title": "accepted-easy-java-solution-beats-98",
                "content": "public class Solution {\\n\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int len=primes.length;\\n        int[] ugly=new int[n],index=new int[len],factor=new int[len],mul=new int[len];\\n        for(int i=0;i<len;i++){\\n            index[i]=0;\\n            factor[i]=primes[i];\\n            mul[i]=primes[i];\\n        }\\n        ugly[0]=1;\\n        for(int i=1;i<n;i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=0;j<len;j++){\\n                if(min>factor[j]) min=factor[j];\\n            }\\n            ugly[i]=min;\\n            for(int j=0;j<len;j++){\\n                if(factor[j]==min) factor[j]=mul[j]*ugly[++index[j]];\\n            }\\n        }\\n        return ugly[n-1];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int len=primes.length;\\n        int[] ugly=new int[n],index=new int[len],factor=new int[len],mul=new int[len];\\n        for(int i=0;i<len;i++){\\n            index[i]=0;\\n            factor[i]=primes[i];\\n            mul[i]=primes[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 76363,
                "title": "share-my-20-line-java-code",
                "content": "    public class Solution {\\n        public int nthSuperUglyNumber(int n, int[] primes) {\\n            if (n<=0 || primes==null || primes.length==0) { return 0; }\\n            int[] heads = new int[primes.length];\\n            for (int i=0; i<primes.length; ++i) { heads[i] = primes[i]; }\\n            int[] indices = new int[primes.length];\\n            Arrays.fill(indices, 1);  // which index in the result sequence generates the next super ugly number in primes[i]'s column?\\n            List<Integer> ans = new ArrayList<>();\\n            ans.add(1);\\n            while (ans.size() < n) {\\n                int min = heads[0];\\n                for (int i=1; i<heads.length; ++i) {\\n                    if (heads[i] < min) { min = heads[i]; }\\n                }\\n                ans.add(min);\\n                for (int i=0; i<primes.length; ++i) {\\n                    if (min == heads[i]) {\\n                        heads[i] = ans.get(indices[i]++) * primes[i];\\n                    }    \\n                }\\n            }\\n            return ans.get(ans.size()-1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int nthSuperUglyNumber(int n, int[] primes) {\\n            if (n<=0 || primes==null || primes.length==0) { return 0; }",
                "codeTag": "Java"
            },
            {
                "id": 76364,
                "title": "same-solution-as-ugly-number-ii",
                "content": "If you understand the solution for https://leetcode.com/problems/ugly-number-ii/, this solution is exactly the same.\\n\\nFor the ugly number II problem, this is an accepted solution\\n\\npublic class Solution {\\n    \\n    public int nthUglyNumber(int n) {\\n        \\n    int[] ugly= new int[n];\\n    \\n    ugly[0] = 1;\\n    int factor2=2, factor3=3,factor5=5;\\n    int ind2=0,ind3=0,ind5=0;\\n    \\n    for(int i=1;i<n;i++)\\n    {\\n        int min = Math.min(factor2,Math.min(factor3,factor5));\\n        \\n        ugly[i]=min;\\n        \\n        if(min==factor2)\\n        {\\n            factor2=2*ugly[++ind2];\\n        }\\n        if(min==factor3)\\n        {\\n            factor3=3*ugly[++ind3];\\n        }\\n        if(min==factor5)\\n        {\\n            factor5=5*ugly[++ind5];\\n        }\\n    }\\n    \\n    return ugly[n-1];\\n        \\n    }\\n}\\n\\nThe solution to this problem is same, except that instead of 3 numbers you have k numbers to consider. To achieve this, you declare the initial variables as an array. Here is an accepted solution for this problem. \\nNotice, the logic is same for both.\\n\\n\\npublic class Solution {\\n\\n    public int nthSuperUglyNumber(int n, int[] primes) {\\n        int[] ugly = new int[n];\\n\\n        int len=primes.length;\\n\\n        ugly[0] = 1;\\n\\n       // This tracks the array\\n        int[] index = new int[len];\\n\\n        int[] factor = new int[len];\\n        System.arraycopy(primes,0,factor,0,factor.length);\\n        // Initialilze the factors\\n\\n        for(int i=1;i<n;i++){\\n           \\n           int min=Integer.MAX_VALUE;\\n           for(int j=0;j<len;j++)\\n           {\\n               min=Math.min(min,factor[j]);\\n           }\\n              \\n            ugly[i] = min;\\n            \\n            for(int j=0;j<len;j++)\\n            {\\n                if(min==factor[j])\\n                {\\n                    factor[j]=primes[j]*ugly[++index[j]];\\n                }\\n            }\\n            \\n        }\\n        return ugly[n-1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    \\n    public int nthUglyNumber(int n) {\\n        \\n    int[] ugly= new int[n];\\n    \\n    ugly[0] = 1;\\n    int factor2=2, factor3=3,factor5=5;\\n    int ind2=0,ind3=0,ind5=0;\\n    \\n    for(int i=1;i<n;i++)\\n    {\\n        int min = Math.min(factor2,Math.min(factor3,factor5));\\n        \\n        ugly[i]=min;\\n        \\n        if(min==factor2)\\n        {\\n            factor2=2*ugly[++ind2];\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567506,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1565746,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1688304,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1566082,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1899890,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1972906,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1574185,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2072444,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1921483,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759597,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1567506,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1565746,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1688304,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1566082,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1899890,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1972906,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1574185,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2072444,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1921483,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759597,
                "content": [
                    {
                        "username": "bexceptionull",
                        "content": "Do you feel it is Super Ugly Problem Description?"
                    },
                    {
                        "username": "cavalier1991",
                        "content": "I am using Java and failed because of this case.\\n\\n500000\\n[7,19,29,37,41,47,53,59,61,79,83,89,101,103,109,127,131,137,139,157,167,179,181,199,211,229,233,239,241,251]\\n\\nOJ is expecting 127671181, however, the right answer should be greater than Integer.MAX_VALUE."
                    },
                    {
                        "username": "Flankerr",
                        "content": "This question should be marked as hard, it feels medium only if you have solved , ugly II"
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "The most efficient solutions so far were based on the idea of taking a sequence of numbers starting with the given primes and then take the minimum one, update the values by multiplying the minimum ones by the next respective ugly number (already found) and start looking for the minimum again.\\n\\nThe question is, what data structure to use for that layer of current candidates for ugly numbers? You need something that supports fast search for the minimum number, so the first thing that comes to mind is a min-heap. The problem is even tagged heap, for that matter!\\n\\nHowever, when using `PriorityQueue` in Java, which is a real efficient min-heap, I found out that my solution runs for 76 ms, beating 95%, but dumb solution using a regular array to store those candidates runs 36 ms, beating 99%! Why is that?\\n\\nI understand that inserting into a min-heap takes `O(log k)` time, but looking for the minimum is `O(1)`! On the other hand, dumb array solution uses linear search which is `O(k)`, even though removal/insertion is not needed at all.\\n\\nGiven that the problem description says that there can be up to 10000 primes, which is a lot for linear search, these results are very surprising. Is this just because the tests don't actually contain that kind of huge inputs, or am I missing something fundamental here?\\n\\nMy idea is that it has something to do with duplicates. If there is a lot of them, that means that we are removing/inserting elements from the heap many times per each outer loop iteration. If the number of duplicates approaches `k`, then we have `O(k log k)` complexity, which is worse than `O(k)` for a dumb array.\\n\\nIf that's the case, I wonder if it's possible to mitigate that by somehow merging elements together so that the heap always contain one minimum value for us to retrieve. That would be very tricky, though, if possible at all, because we need to be able to somehow do that before we even know that those elements are minimum ones. Which means we have to always merge equal elements, possibly by using some sort of a helper hash table or something."
                    },
                    {
                        "username": "zalars",
                        "content": "\"1 has no prime factors, therefore all of its prime factors are in the array primes\"\\nhere is no logic"
                    },
                    {
                        "username": "geekyshark",
                        "content": "\"1 has no prime factors, so all of its Prime factors are in array primes\" lol, I gave up on this question at this moment"
                    },
                    {
                        "username": "rootkonda",
                        "content": "Our goal is to keep generating the numbers between 1 to n i.e. nth super ugly number. The series starts from 1 as given and all the prime factors of the consecutive numbers should part of given primes[] array.\\n\\nWe have to maintain 2 arrays. \\n\\n1) To store the ugly numbers.\\n2) To store the indices[i] of next ugly number to be used for multiplying with the corresponding prime number in primes[i]\\n\\nFirst of all, we get the next smallest ugly number by multiplying primes[i] and ugly[] array. Why ?? Because an ugly number\\'s prime factors should be in the given primes[] so obviously the smallest primes[] will be the next ugly number after 1 in the ugly number sequence. Hence we go with this approach of multiplying two smaller numbers to get next ugly number.\\n\\nWhen primes[] =** { 2,7,13,19 } **the indices[] will also be of same size and initialized with 0\\'s.  In order to get next ugly number in the sequence it should be the smallest number possible,which we can get it by multiplying smallest number from primes[] and smallest ugly number in the ugly number sub-sequence. Indices[i] stores the index of the next ugly number that should multiplied with primes[i].\\n\\nWhen we start with primes[0] = 2, indices[0] = 0 ---> this is the index of ugly[] array. i.e ugly[indices[0]] = ugly[0]. As we multiply and take the minimum product, ugly[0] * primes[0] = 21 as ugly[0] is defaulted to 1 so the next ugly number is 2. \\n\\nugly[] = {1,2}\\nindices[] = { 1,0,0,0 } ---> indices[0] has index 1 from ugly number so it refers to value 2. \\n\\nNext ugly number is 4 :\\n**ugly[indices[0]] = ugly[1] * primes[0] = 2 * 2 = 4**. Note that its waste of multiplying with 1 because we already multiplied and got 2 earlier..Next smallest number to multiply is 2 hence we stored the index of that in indices array in previous iteration. Once we got 4 as next ugly number, indices[] array becomes ** { 2, 0, 0 , 0 }** . It becomes 2 because when we want to multiply primes[0] with next smallest ugly number which we havent multiplied is 4 and its index is 2 in ugly array so indices[0] becomes 2. Hence everytime we use a particular number in the ugly number sequence we increment the index in indices array by 1 so that next time when we multiply we are pointing to correct ugly number.\\n\\nNext ugly number is 7:\\n**ugly[indices[0]] = ugly[2] * primes[0] = 4 * 2 = 8\\nugly[indices[1]] = ugly[0] * primes[1] = 1 * 7 = 7....7** is the minimum so that is our next ugly number. If you notice here, after ugly number 4, we go straight to ugly number 1 because for the prime number 7, we havent multiplied with 1 like we did for 2 in the beginning. So from here the prime number 7\\'s subsequence has been started from 1. As we used 1 from ugly number sub sequence for prime number 7, increment to next ugly number index to use for prime number 7. So the indices[] will look like {2,1,0,0 }.\\n\\nThe above process goes on until we find the nth super ugly number. I hope this makes it clear !\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Ugly number 2 first if you are struggling on this one"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "class Solution {\\npublic:\\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\\n        vector<vector<long long>> arr(primes.size());\\n        int maxi = INT_MAX;\\n        for(int i=0;i<primes.size();i++){\\n            vector<long long> temp;\\n            temp.push_back(1);\\n            while(temp[temp.size()-1]<maxi){\\n                temp.push_back((long long) temp[temp.size()-1]*primes[i]);\\n            }\\n            temp.pop_back();\\n            arr[i]=temp;\\n        }\\n        // for(int i=0;i<arr.size();i++){\\n        //     cout<<arr[i].size()<<endl;\\n        // }\\n        set<long long> st;\\n        st.insert(1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            set<long long> temp = st;\\n            for(auto it:st){\\n                for(int j=1;j<arr[i].size();j++){\\n                    long long val1 = it;\\n                    long long val2 = arr[i][j];\\n                    if(val1*val2<=maxi){\\n                        temp.insert(val1*val2);\\n                        if(temp.size()>n){\\n                            temp.erase(*temp.rbegin());\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            st = temp;\\n        }\\n        return *st.rbegin();\\n    }\\n};\\n\\n/*\\nWhy this solution is giving TLE in last test case \\n*/"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    },
    {
        "title": "Monotone Increasing Digits",
        "question_content": "<p>An integer has <strong>monotone increasing digits</strong> if and only if each pair of adjacent digits <code>x</code> and <code>y</code> satisfy <code>x &lt;= y</code>.</p>\n\n<p>Given an integer <code>n</code>, return <em>the largest number that is less than or equal to </em><code>n</code><em> with <strong>monotone increasing digits</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 9\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1234\n<strong>Output:</strong> 1234\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 332\n<strong>Output:</strong> 299\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 109811,
                "title": "simple-and-very-short-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        string n_str = to_string(N);\\n        \\n        int marker = n_str.size();\\n        for(int i = n_str.size()-1; i > 0; i --) {\\n            if(n_str[i] < n_str[i-1]) {\\n                marker = i;\\n                n_str[i-1] = n_str[i-1]-1;\\n            }\\n        }\\n        \\n        for(int i = marker; i < n_str.size(); i ++) n_str[i] = '9';\\n        \\n        return stoi(n_str);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        string n_str = to_string(N);\\n        \\n        int marker = n_str.size();\\n        for(int i = n_str.size()-1; i > 0; i --) {\\n            if(n_str[i] < n_str[i-1]) {\\n                marker = i;\\n                n_str[i-1] = n_str[i-1]-1;\\n            }\\n        }\\n        \\n        for(int i = marker; i < n_str.size(); i ++) n_str[i] = '9';\\n        \\n        return stoi(n_str);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150752,
                "title": "clean-code",
                "content": "The result should be:\\n```\\npreceding monotone increasing digits (ending digit should decrease by 1) \\n```\\nfollowed by \\n```\\nall remaining digits set to \\'9\\'\\n```\\n.\\n\\n`e.g. N = 12321, the result is 12299`.\\n```\\nmonotoneIncreasingEnd is finalized as : 2\\ncurrent arrN : 12211\\narrN is finalized as : 12299\\n```\\n****\\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int N) {\\n        char[] arrN = String.valueOf(N).toCharArray();\\n        \\n        int monotoneIncreasingEnd = arrN.length - 1;\\n        for (int i = arrN.length - 1; i > 0; i--) {\\n            if (arrN[i] < arrN[i - 1]) {\\n                monotoneIncreasingEnd = i - 1;\\n                arrN[i - 1]--;\\n            }\\n        }\\n        // System.out.println(\"monotoneIncreasingEnd is finalized as : \" + monotoneIncreasingEnd);\\n        // System.out.println(\"current arrN : \" + new String(arrN));\\n        for (int i = monotoneIncreasingEnd + 1; i < arrN.length; i++) {\\n            arrN[i] = \\'9\\';\\n        }\\n        // System.out.println(\"arrN is finalized as : \" + new String(arrN));\\n        return Integer.parseInt(new String(arrN));\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npreceding monotone increasing digits (ending digit should decrease by 1) \\n```\n```\\nall remaining digits set to \\'9\\'\\n```\n```\\nmonotoneIncreasingEnd is finalized as : 2\\ncurrent arrN : 12211\\narrN is finalized as : 12299\\n```\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int N) {\\n        char[] arrN = String.valueOf(N).toCharArray();\\n        \\n        int monotoneIncreasingEnd = arrN.length - 1;\\n        for (int i = arrN.length - 1; i > 0; i--) {\\n            if (arrN[i] < arrN[i - 1]) {\\n                monotoneIncreasingEnd = i - 1;\\n                arrN[i - 1]--;\\n            }\\n        }\\n        // System.out.println(\"monotoneIncreasingEnd is finalized as : \" + monotoneIncreasingEnd);\\n        // System.out.println(\"current arrN : \" + new String(arrN));\\n        for (int i = monotoneIncreasingEnd + 1; i < arrN.length; i++) {\\n            arrN[i] = \\'9\\';\\n        }\\n        // System.out.println(\"arrN is finalized as : \" + new String(arrN));\\n        return Integer.parseInt(new String(arrN));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109794,
                "title": "simple-python-solution-w-explanation",
                "content": "The idea is to go from the LSB to MSB and find the last digit, where an inversion happens.\\nThere are 2 cases to consider:\\n\\ncase 1:\\nIn 14267 , we see that inversion happens at 4. In this case, then answer is obtained by reducing 4 to 3, and changing all the following digits to 9. \\n=> 13999\\n\\ncase 2:\\n1444267, here eventhough the last inversion happens at the last 4 in 1444, if we reduce it to 3, then that itself breaks the rule. So once we find the last digit where inversion happens,  if that digit is repeated, then we have to find the last position of that digit. After that it is same as case1, where we reduce it by 1 and set the remaining digits to 9.\\n=> 1399999\\n\\nThe steps are:\\n1) Convert n into num array in reverse order\\n2) Find the leftmost position that is inverted and if the inverted character repeats itself, find the leftmost repeated digit. \\n3) Fill the digits after inversion as 9\\n4) Reduce the digit that caused the inversion by -1\\n5) Reverse back the num array and convert to int\\n```\\ndef monotoneIncreasingDigits(self, N):\\n        if N < 10: return N\\n        n, inv_index = N, -1\\n        num = [int(d) for d in str(n)[::-1]] \\n\\n        for i in range(1, len(num)): \\n            if num[i] > num[i - 1] or (inv_index != -1 and num[inv_index] == num[i]):\\n                inv_index = i\\n\\n        if inv_index == -1: return N\\n\\n        for i in range(inv_index): num[i] = 9\\n        num[inv_index] -= 1\\n        \\n        return int(''.join([ str(i) for i in num[::-1]])) \\n```",
                "solutionTags": [],
                "code": "```\\ndef monotoneIncreasingDigits(self, N):\\n        if N < 10: return N\\n        n, inv_index = N, -1\\n        num = [int(d) for d in str(n)[::-1]] \\n\\n        for i in range(1, len(num)): \\n            if num[i] > num[i - 1] or (inv_index != -1 and num[inv_index] == num[i]):\\n                inv_index = i\\n\\n        if inv_index == -1: return N\\n\\n        for i in range(inv_index): num[i] = 9\\n        num[inv_index] -= 1\\n        \\n        return int(''.join([ str(i) for i in num[::-1]])) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 128514,
                "title": "simple-java-solution-with-clear-explanation-very-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int N) {\\n        //1. Convert the given integer to character array\\n        char[] ch = String.valueOf(N).toCharArray();\\n        \\n        //2. Create a integer mark variable and initialize it to the length of the character array \\n        int mark = ch.length;\\n        \\n        //3. Iterate from the end of the array to the beginning of the array.\\n        //Everytime you find current digit less then previous digit, reduce the previous digit by 1 and set that digit as the mark\\n        for(int i = ch.length-1;i>0;i--){\\n            if(ch[i]<ch[i-1]){\\n                mark = i-1;\\n                ch[i-1]--;\\n            }\\n        }\\n        \\n        //4. Set all digits after mark to 9 as we want the highest number.\\n        //In step 3 we made sure that all digits before mark are in increasing order\\n        for(int i = mark+1;i<ch.length;i++){\\n            ch[i] = \\'9\\';\\n        }\\n        return Integer.parseInt(new String(ch));\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int N) {\\n        //1. Convert the given integer to character array\\n        char[] ch = String.valueOf(N).toCharArray();\\n        \\n        //2. Create a integer mark variable and initialize it to the length of the character array \\n        int mark = ch.length;\\n        \\n        //3. Iterate from the end of the array to the beginning of the array.\\n        //Everytime you find current digit less then previous digit, reduce the previous digit by 1 and set that digit as the mark\\n        for(int i = ch.length-1;i>0;i--){\\n            if(ch[i]<ch[i-1]){\\n                mark = i-1;\\n                ch[i-1]--;\\n            }\\n        }\\n        \\n        //4. Set all digits after mark to 9 as we want the highest number.\\n        //In step 3 we made sure that all digits before mark are in increasing order\\n        for(int i = mark+1;i<ch.length;i++){\\n            ch[i] = \\'9\\';\\n        }\\n        return Integer.parseInt(new String(ch));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764279,
                "title": "python-straightforward-greedy-solution-explained",
                "content": "Let\\'s look at a few examples:\\n```\\nInput           Output\\n55627    ->     55599\\n55427    ->     49999\\n99996    ->     89999 \\n100         ->    99\\n```\\nFrom the above examples we can see that if a number is **not** monotone increasing digits, we will need to convert as many digits as posible to `9` and decrease the digit before the `9`s by 1. But how to decide which digit to decrease by 1?\\n\\nIf we try to tranverse the digits from left to right, there are many different cases we need to consider. But if we **tranverse the digits from right to left**, it is very straightforward! Whenever a digit is smaller than a digit to its left, decrease its left digit by 1 and convert all the digits from here until the end to 9. \\n\\nTo make the digits easy to access, tranverse, and modify, I converted the number into a list of integers.\\n\\n```\\nclass Solution(object):\\n    def monotoneIncreasingDigits(self, n):\\n        # First, handle the single-digit cases.\\n        if n < 10:\\n            return n\\n\\n\\t\\t# Convert the number into a list of integers\\n        l = []\\n        for _,c in enumerate(str(n)):\\n            l.append(int(c))\\n        n = len(l)\\n\\n\\t\\t# Tranverse from right to left \\n        for i in range(n-1,0,-1):\\n            if l[i] < l[i-1]:\\n                l[i-1] -= 1\\n                for i in range(i,n):\\n                    l[i] = 9\\n        \\n\\t\\t# Convert the list back to a number\\n        return int(\"\".join([str(x) for x in l]))\\n```\\n\\nPlease VOTE UP if you find this explanation helpful!",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nInput           Output\\n55627    ->     55599\\n55427    ->     49999\\n99996    ->     89999 \\n100         ->    99\\n```\n```\\nclass Solution(object):\\n    def monotoneIncreasingDigits(self, n):\\n        # First, handle the single-digit cases.\\n        if n < 10:\\n            return n\\n\\n\\t\\t# Convert the number into a list of integers\\n        l = []\\n        for _,c in enumerate(str(n)):\\n            l.append(int(c))\\n        n = len(l)\\n\\n\\t\\t# Tranverse from right to left \\n        for i in range(n-1,0,-1):\\n            if l[i] < l[i-1]:\\n                l[i-1] -= 1\\n                for i in range(i,n):\\n                    l[i] = 9\\n        \\n\\t\\t# Convert the list back to a number\\n        return int(\"\".join([str(x) for x in l]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651391,
                "title": "cpp-simple-solution-explanation-with-example-beats-100-time-and-space",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Monotone Increasing Digits.\\nMemory Usage: 5.9 MB, less than 100.00% of C++ online submissions for Monotone Increasing Digits.\\nLogic : any number \\'xxxxx..\\' a number monotonically increasing largest but smaller  than original number will be one less than the point before which every number is monotonically increasing  and after that point all places are filled whith 9 to get maximum\\n\\neg: 5 4 3 7 7 6\\n    7 6 if this was our number than 6 9 will be ans which is 7-1 and rest 9\\n    7 7 6 ------------------------- 6 9 9\\n    3 7 7 6 -----------------------3 7(till here monotonically increasing so one less than this is 3 6 and rest 9 9 ) 3 6 9 9 \\n     4 3 7 7 6 --- 3 9 9 9 9\\n     5 4 3 7 7 6 -- 4 9 9 9 9 9  \\n   ``` \\n    class Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        if(N < 10){\\n            return N;\\n        }\\n        string s = to_string(N);\\n        int index = s.length();\\n        int i;\\n        for(i = index -1 ; i > 0; i--){\\n            if(s[i-1] > s[i]){\\n                s[i-1]--;\\n                index = i; \\n            }\\n        }\\n        for(i = index; i < s.length(); i++){\\n            s[i] = \\'9\\';\\n        }\\n        N = stoi(s);\\n        return N;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        if(N < 10){\\n            return N;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 693207,
                "title": "c-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        \\n        queue<long>q;\\n        for (int i = 1; i <= 9; i++)\\n            q.push(i);\\n        \\n        int res = INT_MIN;\\n        while (!q.empty()) {\\n            int t = q.front();\\n            q.pop();\\n            \\n            if (t > N) break;\\n            res = max(res, t);\\n            \\n            int r = t % 10;\\n            for (int i = r; i <= 9; i++)\\n                q.push((long)t*10 + i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        \\n        queue<long>q;\\n        for (int i = 1; i <= 9; i++)\\n            q.push(i);\\n        \\n        int res = INT_MIN;\\n        while (!q.empty()) {\\n            int t = q.front();\\n            q.pop();\\n            \\n            if (t > N) break;\\n            res = max(res, t);\\n            \\n            int r = t % 10;\\n            for (int i = r; i <= 9; i++)\\n                q.push((long)t*10 + i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109788,
                "title": "simple-and-very-short-java-solution",
                "content": "//translated from the simple  and very short c++ solution\\n\\n```\\n    public int monotoneIncreasingDigits(int N) {\\n\\n        if(N<=9)\\n            return N;\\n        char[] x = String.valueOf(N).toCharArray();\\n\\n        int mark = x.length;\\n        for(int i = x.length-1;i>0;i--){\\n            if(x[i]<x[i-1]){\\n                mark = i-1;\\n                x[i-1]--;\\n            }\\n        }\\n        for(int i = mark+1;i<x.length;i++){\\n            x[i] = '9';\\n        }\\n        return Integer.parseInt(new String(x));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int monotoneIncreasingDigits(int N) {\\n\\n        if(N<=9)\\n            return N;\\n        char[] x = String.valueOf(N).toCharArray();\\n\\n        int mark = x.length;\\n        for(int i = x.length-1;i>0;i--){\\n            if(x[i]<x[i-1]){\\n                mark = i-1;\\n                x[i-1]--;\\n            }\\n        }\\n        for(int i = mark+1;i<x.length;i++){\\n            x[i] = '9';\\n        }\\n        return Integer.parseInt(new String(x));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 144404,
                "title": "simple-java-from-back-to-front-no-extra-space-and-no-conversion-to-char",
                "content": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int N) {\\n        int res = 0;\\n        int pre = Integer.MAX_VALUE;\\n        int offset = 1;\\n        while(N != 0) {\\n            int digit = N % 10;\\n            if(digit > pre) {\\n                res = digit * offset - 1;\\n                pre = digit - 1;\\n            }else {\\n                res = res + digit * offset;\\n                pre = digit;\\n            }\\n            offset *= 10;\\n            N = N / 10;\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int N) {\\n        int res = 0;\\n        int pre = Integer.MAX_VALUE;\\n        int offset = 1;\\n        while(N != 0) {\\n            int digit = N % 10;\\n            if(digit > pre) {\\n                res = digit * offset - 1;\\n                pre = digit - 1;\\n            }else {\\n                res = res + digit * offset;\\n                pre = digit;\\n            }\\n            offset *= 10;\\n            N = N / 10;\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181945,
                "title": "fast-and-simple-40ms-python-solution-using-recursion",
                "content": "We scan through S from left to right:\\n* If it\\'s monotonically increasing we just adding corresponding part to result\\n* If not then we simply decrease result by 1, which would result in some 9s in the tail\\n* However, decrease by 1 might lead to our result being not monotonically increasing, so we run recursion base on our current result number\\n\\nExample - say the input was 1221\\n1. i=0, res=1000\\n2. i=1, res=1200\\n3. i=2, res=1220\\n4. i=3, res=1219 because it\\'s not increasing anymore\\n5. then we recursively call with input being 1219\\n6. i=0, res=1000\\n7. i=1, res=1200\\n8. i=2, res=1199 because it\\'s not increasing anymore\\n9. then we recursively call with input being 1199\\n10. voila! we got it\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        s = str(N)\\n        l = len(s)\\n        res = 0\\n        for i in range(len(s)):\\n            if i == 0 or s[i] >= s[i-1]:\\n                res += int(s[i]) * pow(10, l-1)\\n            else:\\n                return self.monotoneIncreasingDigits(res-1)\\n            l -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        s = str(N)\\n        l = len(s)\\n        res = 0\\n        for i in range(len(s)):\\n            if i == 0 or s[i] >= s[i-1]:\\n                res += int(s[i]) * pow(10, l-1)\\n            else:\\n                return self.monotoneIncreasingDigits(res-1)\\n            l -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109792,
                "title": "easy-java",
                "content": "```\\n    public int monotoneIncreasingDigits(int N) {\\n        char[] digit = (N + \"\").toCharArray();\\n        int flag = digit.length;\\n        for (int i = digit.length - 1; i > 0; i--) {\\n            if (digit[i] < digit[i - 1]) {\\n                digit[i - 1]--;\\n                flag = i;\\n            }\\n        }\\n        Arrays.fill(digit, flag, digit.length, '9');\\n        return Integer.parseInt(new String(digit));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int monotoneIncreasingDigits(int N) {\\n        char[] digit = (N + \"\").toCharArray();\\n        int flag = digit.length;\\n        for (int i = digit.length - 1; i > 0; i--) {\\n            if (digit[i] < digit[i - 1]) {\\n                digit[i - 1]--;\\n                flag = i;\\n            }\\n        }\\n        Arrays.fill(digit, flag, digit.length, '9');\\n        return Integer.parseInt(new String(digit));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056255,
                "title": "java-c-0ms-awesome-approach-100-faster",
                "content": "# Attention \\u2757\\nAvoid the following approach, it is too expensive because of ```n--``` statements\\u2757. \\n```\\npublic int monotoneIncreasingDigits(int n) {\\n        while (!isSatisfies(n)) {\\n            n--;\\n        }\\n        return n;\\n    }\\n\\n    public boolean isSatisfies(int n) {\\n        int k = 10;\\n        while (n > 0) {\\n            if (k < n % 10) {\\n                return false;\\n            } else {\\n                k = n % 10;\\n                n /= 10;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\n# My Approach\\n\\nLet\\'s we will improve above code.\\n```isSatisfies(int n)``` method returns just ```true``` , ```false``` if ```n``` has ```monotone``` ```increasing digits```, hasn\\'t  respectively. \\nI changed it to ```getThePositionNotSatisfied(int n)``` and it returns the position of the digit not satisfied the condition or -1 if satisfies all condition. \\n\\nAnd, instead of ```n--```, I write the following statements to increase loop steps and to improve speed : \\n```\\ndigitInTheNextPosition = ((int) (n / Math.pow(10, position - 1))) % 10;\\n            n -= Math.pow(10, position - 1) * (digitInTheNextPosition + 1);\\n            n -= n % Math.pow(10, position);\\n            n += Math.pow(10, position) - 1;\\n```\\n\\nFor example, if ```n=3423```.\\nThen ```getThePositionNotSatisfied(3423) = 2```, it means that from right the digit in \\n```2-index```, i.e ```4``` not satisfies the condition.\\nThen \\n    ```position = 2```\\n    ```digitNextInThePosition = 3423/ Math.pow(10,2 - 1) % 10 = 2;```\\n    ```n = 3423 - Math.pow(10,2 - 1)(2+1) = 3393;```\\n\\nProbably, there are other numbers between ```3393``` and ```3399``` that we looking for. So we need to check these numbers. And new value of ```n``` to check should be ```3399```.\\nFor this, we need to swap all digits after the ```position``` with 9. In my code, I achive it as following :\\n\\n```n = 3393 - 3393 % Math.pow(10, 2) = 3300;```\\n```n = 3300 + (Math.pow(10, 2) - 1) = 3300 + 99 = 3399;```\\n\\nand, so on. \\n\\nIn the first approach to down from ```3423``` to ```3399``` you have to walk **23 steps**, in the second approach just **1 step** :)\\n\\n\\n*Please upvote, if you find it useful*\\uD83D\\uDE0A\\n\\n\\n# Java\\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int position;\\n        int digitInTheNextPosition;\\n        while ((position = getThePositionNotSatisfied(n)) != -1) {\\n            digitInTheNextPosition = ((int) (n / Math.pow(10, position - 1))) % 10;\\n            n -= Math.pow(10, position - 1) * (digitInTheNextPosition + 1);\\n            n -= n % Math.pow(10, position);\\n            n += Math.pow(10, position) - 1;\\n        }\\n        return n;\\n    }\\n\\n    public int getThePositionNotSatisfied(int n) {\\n        int k = 10;\\n        int position = 0;\\n        while (n > 0) {\\n            if (k < n % 10) {\\n                return position;\\n            } else {\\n                k = n % 10;\\n                n /= 10;\\n                position++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n---\\n\\n# C++\\n```\\n#include<math.h>\\nclass Solution {\\npublic: \\n    int getThePositionNotSatisfied(int n) {\\n        int k = 10;\\n        int position = 0;\\n        while (n > 0) {\\n            if (k < n % 10) {\\n                return position;\\n            } else {\\n                k = n % 10;\\n                n /= 10;\\n                position++;\\n            }\\n        }\\n        return -1;\\n    }\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        int position;\\n        int digitInTheNextPosition;\\n        while ((position = getThePositionNotSatisfied(n)) != -1) {\\n            digitInTheNextPosition = ((int) (n / pow(10, position - 1))) % 10;\\n            n -= pow(10, position - 1) * (digitInTheNextPosition + 1);\\n            n -= (n %(int) pow(10, position));\\n            n += pow(10, position) - 1;\\n        }\\n        return n;\\n    }\\n};\\n```\\n# Result\\n![image.png](https://assets.leetcode.com/users/images/84a5dd1a-e926-41e6-bbba-b7d1bf60e692_1673826006.070908.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```n--```\n```\\npublic int monotoneIncreasingDigits(int n) {\\n        while (!isSatisfies(n)) {\\n            n--;\\n        }\\n        return n;\\n    }\\n\\n    public boolean isSatisfies(int n) {\\n        int k = 10;\\n        while (n > 0) {\\n            if (k < n % 10) {\\n                return false;\\n            } else {\\n                k = n % 10;\\n                n /= 10;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```isSatisfies(int n)```\n```true```\n```false```\n```n```\n```monotone```\n```increasing digits```\n```getThePositionNotSatisfied(int n)```\n```n--```\n```\\ndigitInTheNextPosition = ((int) (n / Math.pow(10, position - 1))) % 10;\\n            n -= Math.pow(10, position - 1) * (digitInTheNextPosition + 1);\\n            n -= n % Math.pow(10, position);\\n            n += Math.pow(10, position) - 1;\\n```\n```n=3423```\n```getThePositionNotSatisfied(3423) = 2```\n```2-index```\n```4```\n```position = 2```\n```digitNextInThePosition = 3423/ Math.pow(10,2 - 1) % 10 = 2;```\n```n = 3423 - Math.pow(10,2 - 1)(2+1) = 3393;```\n```3393```\n```3399```\n```n```\n```3399```\n```position```\n```n = 3393 - 3393 % Math.pow(10, 2) = 3300;```\n```n = 3300 + (Math.pow(10, 2) - 1) = 3300 + 99 = 3399;```\n```3423```\n```3399```\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int position;\\n        int digitInTheNextPosition;\\n        while ((position = getThePositionNotSatisfied(n)) != -1) {\\n            digitInTheNextPosition = ((int) (n / Math.pow(10, position - 1))) % 10;\\n            n -= Math.pow(10, position - 1) * (digitInTheNextPosition + 1);\\n            n -= n % Math.pow(10, position);\\n            n += Math.pow(10, position) - 1;\\n        }\\n        return n;\\n    }\\n\\n    public int getThePositionNotSatisfied(int n) {\\n        int k = 10;\\n        int position = 0;\\n        while (n > 0) {\\n            if (k < n % 10) {\\n                return position;\\n            } else {\\n                k = n % 10;\\n                n /= 10;\\n                position++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\n#include<math.h>\\nclass Solution {\\npublic: \\n    int getThePositionNotSatisfied(int n) {\\n        int k = 10;\\n        int position = 0;\\n        while (n > 0) {\\n            if (k < n % 10) {\\n                return position;\\n            } else {\\n                k = n % 10;\\n                n /= 10;\\n                position++;\\n            }\\n        }\\n        return -1;\\n    }\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        int position;\\n        int digitInTheNextPosition;\\n        while ((position = getThePositionNotSatisfied(n)) != -1) {\\n            digitInTheNextPosition = ((int) (n / pow(10, position - 1))) % 10;\\n            n -= pow(10, position - 1) * (digitInTheNextPosition + 1);\\n            n -= (n %(int) pow(10, position));\\n            n += pow(10, position) - 1;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1779683,
                "title": "c-simplest-greedy-solution-faster-than-100",
                "content": "We need to return the largest number that is less than or equal to the given ```n```, that has monotome increasing digits.\\n\\n**APPROACH :**\\n\\n* If the number ```n``` is monotone increasing then, we can return the number itself.\\n* Otherwise, we start traversing from the last digit.\\n*  Wherever we find a digit that\\'s less than it\\'s previous digit (ie; ```s[i] < s[i-1]```), we mark that index & decrement the previous index digit by ```1``` (Since we want a number smaller than the given one)\\n*  To return the largest number possible : We make all the digits from the marked index = ```9```.\\n\\n**Time Complexity :** O(n)\\n\\n**Space Complexity :** O(n) - We need to create a string in order to traverse digit by digit.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        int size = s.size(), lim = s.size();\\n        for(int i=size-1; i>0; i--){\\n            if(s[i-1] > s[i]) lim = i, s[i-1] -= 1;\\n        }\\n        for(int i=lim; i<size; i++) s[i] = \\'9\\';\\n        return stoi(s);\\n    }\\n};\\n```\\n\\n**Do upvote if you\\'ve found my post helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```n```\n```n```\n```s[i] < s[i-1]```\n```1```\n```9```\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        int size = s.size(), lim = s.size();\\n        for(int i=size-1; i>0; i--){\\n            if(s[i-1] > s[i]) lim = i, s[i-1] -= 1;\\n        }\\n        for(int i=lim; i<size; i++) s[i] = \\'9\\';\\n        return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602170,
                "title": "python3-7-lines-w-explanation",
                "content": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n\\n        n = str(n)                                        # For example: n = 246621 --> \"246621\"\\n        N = len(n)\\n\\n        for i in range(N-1):                              # find the first break in monotonicity\\n            if n[i] > n[i+1]: break                       #       Ex: \"2466 21\"\\n                                                          #                ^\\n        else: return int(n)                               # if no break, then n is a mono non-decr seq\\n        \\n        while i>0 and n[i]==n[i-1]: i-=1                  # back up to the last digit in the mono incr seq \\n                                                          #       Ex: \"246 621\"\\n                                                          #               ^\\n        return int(str(int(n[:i+1])-1)+\\'9\\'*(N-i-1))       # borrow a 1 from the mono incr portion and pad with 9s\\n                                                          #       Ex: (\"246\"-\"1\")+ \\'9\\'*4 = \"245999\"--> 245999",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n\\n        n = str(n)                                        # For example: n = 246621 --> \"246621\"\\n        N = len(n)\\n\\n        for i in range(N-1):                              # find the first break in monotonicity\\n            if n[i] > n[i+1]: break                       #       Ex: \"2466 21\"\\n                                                          #                ^\\n        else: return int(n)                               # if no break, then n is a mono non-decr seq\\n        \\n        while i>0 and n[i]==n[i-1]: i-=1                  # back up to the last digit in the mono incr seq \\n                                                          #       Ex: \"246 621\"\\n                                                          #               ^\\n        return int(str(int(n[:i+1])-1)+\\'9\\'*(N-i-1))       # borrow a 1 from the mono incr portion and pad with 9s\\n                                                          #       Ex: (\"246\"-\"1\")+ \\'9\\'*4 = \"245999\"--> 245999",
                "codeTag": "Java"
            },
            {
                "id": 392400,
                "title": "very-intuitional-java-solution-using-stack",
                "content": "```\\n  public int monotoneIncreasingDigits(int N) {\\n        char[] num = String.valueOf(N).toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        boolean find = false;\\n        for (int i = 0; i < num.length; i++) {\\n            char ch = num[i];\\n            while (!stack.isEmpty() && stack.peek() > ch) {\\n                ch = (char)(stack.pop() - 1);\\n                find = true;\\n            }\\n            stack.push(ch);\\n            if (find) {\\n                break;\\n            }\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        while (!stack.isEmpty()) {\\n            sb.append(stack.pop());\\n        }\\n        sb.reverse();\\n        while (sb.length() < num.length) {\\n            sb.append(\\'9\\');\\n        }\\n        return Integer.parseInt(sb.toString());\\n    }",
                "solutionTags": [],
                "code": "```\\n  public int monotoneIncreasingDigits(int N) {\\n        char[] num = String.valueOf(N).toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        boolean find = false;\\n        for (int i = 0; i < num.length; i++) {\\n            char ch = num[i];\\n            while (!stack.isEmpty() && stack.peek() > ch) {\\n                ch = (char)(stack.pop() - 1);\\n                find = true;\\n            }\\n            stack.push(ch);\\n            if (find) {\\n                break;\\n            }\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        while (!stack.isEmpty()) {\\n            sb.append(stack.pop());\\n        }\\n        sb.reverse();\\n        while (sb.length() < num.length) {\\n            sb.append(\\'9\\');\\n        }\\n        return Integer.parseInt(sb.toString());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3233464,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        int size = s.size(), lim = s.size();\\n        for(int i=size-1; i>0; i--){\\n            if(s[i-1] > s[i]) lim = i, s[i-1] -= 1;\\n        }\\n        for(int i=lim; i<size; i++) s[i] = \\'9\\';\\n        return stoi(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        int size = s.size(), lim = s.size();\\n        for(int i=size-1; i>0; i--){\\n            if(s[i-1] > s[i]) lim = i, s[i-1] -= 1;\\n        }\\n        for(int i=lim; i<size; i++) s[i] = \\'9\\';\\n        return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982708,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char[] arr = String.valueOf(n).toCharArray();\\n        int start = arr.length;\\n        for (int i = arr.length - 2; i >= 0; i --) {\\n            if (arr[i] > arr[i + 1]) {\\n                start = i + 1;\\n                arr[i] --;\\n            }\\n        }\\n        \\n        for (int i = start; i < arr.length; i ++) {\\n            arr[i] = \\'9\\';\\n        }\\n        \\n        return Integer.parseInt(String.valueOf(arr));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char[] arr = String.valueOf(n).toCharArray();\\n        int start = arr.length;\\n        for (int i = arr.length - 2; i >= 0; i --) {\\n            if (arr[i] > arr[i + 1]) {\\n                start = i + 1;\\n                arr[i] --;\\n            }\\n        }\\n        \\n        for (int i = start; i < arr.length; i ++) {\\n            arr[i] = \\'9\\';\\n        }\\n        \\n        return Integer.parseInt(String.valueOf(arr));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499694,
                "title": "o-n-python-solution-very-simple-logic",
                "content": "Example: n = 4329762\\nfor loop: i = 6 -> if condition: 2 < 6 is true: n_str = 4329762 - 63 = 4329699\\nfor loop: i = 5 -> if condition: 9 < 6 is false\\nfor loop i = 4 -> if condition: 6 < 9 is true: n_str = 4329699 - 9700 = 4319999\\nand so on...\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        n_str = str(n)\\n        len_n = len(n_str)\\n        for i in range(len_n-1, 0, -1):\\n            if int(n_str[i]) < int(n_str[i - 1]):\\n                n_str = str(int(n_str) - (int(n_str[i:]) + 1))\\n        return int(n_str)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        n_str = str(n)\\n        len_n = len(n_str)\\n        for i in range(len_n-1, 0, -1):\\n            if int(n_str[i]) < int(n_str[i - 1]):\\n                n_str = str(int(n_str) - (int(n_str[i:]) + 1))\\n        return int(n_str)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689652,
                "title": "simple-o-log-n-java-solution-with-one-pass",
                "content": "We scan from right to left, i.e., least significant to most significan, take 7634 fro example: \\n1. if the digits are strictly increasing from left to right, we do nothing, so 34 -> 34.\\n2. if a one digit is smaller than any digit on the right, the result would be the digit minus 1, and fill remaining digits with 9. 634 -> 599, 7599 -> 6999.\\n3. \\n\\n    public int monotoneIncreasingDigits(int N) {\\n        int res = 0;\\n        int digit = 0;\\n        int max = 9;\\n        \\n        while(N > 0)\\n        {\\n            int cur = N % 10;\\n            N /= 10;\\n            if(cur <= max)\\n            {\\n                res += cur * Math.pow(10, digit);\\n                max = cur;\\n            }\\n            else\\n            {\\n                res = (int)(cur * Math.pow(10, digit) - 1);\\n                max = cur - 1;\\n            }\\n            digit++;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "We scan from right to left, i.e., least significant to most significan, take 7634 fro example: \\n1. if the digits are strictly increasing from left to right, we do nothing, so 34 -> 34.\\n2. if a one digit is smaller than any digit on the right, the result would be the digit minus 1, and fill remaining digits with 9. 634 -> 599, 7599 -> 6999.\\n3. \\n\\n    public int monotoneIncreasingDigits(int N) {\\n        int res = 0;\\n        int digit = 0;\\n        int max = 9;\\n        \\n        while(N > 0)\\n        {\\n            int cur = N % 10;\\n            N /= 10;\\n            if(cur <= max)\\n            {\\n                res += cur * Math.pow(10, digit);\\n                max = cur;\\n            }\\n            else\\n            {\\n                res = (int)(cur * Math.pow(10, digit) - 1);\\n                max = cur - 1;\\n            }\\n            digit++;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3326181,
                "title": "very-easy-to-understand-converting-to-string-and-solving-in-c",
                "content": "# Approach\\n1.First convert the number into a string using to_string( ).\\n2.Then check each digit in a for loop if the prev digit is smaller than or equal to the next digit or not. If yes,then continue.\\n3.If no then just make the rest leftout digits(to the right of index where condition is violated) to \\'9\\' and decrement the current digit by 1.\\n4.We will continue this process using a while loop till we get the desired condition where every prev digits are less or equal to the next digits.\\n\\neg. 332\\n->we see that condition is violated at index 1 where s[i]>s[i+1] (3>2)\\n->here we convert all the rest digits to 9(here 2 is converted to 9)\\nand then we decrement the ith digit by 1(here 3 becomes 2).\\n->then we concatenate the prefix and suffix. Here prefix was \\'3\\' and suffix is \\'29\\',resultant is \\'329\\'.But there is again violation in 0th index where \\'3\\'>\\'2\\'.So again loop goes on to convert it finally.\\n\\nTIME complexity will not be much as nums can go upto 10^9 so it can be a 9 letter string to the max,and we can apply while loop nested with for loop for many times.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s=to_string(n);              //num converted to string\\n        int len=s.size(),ind,flag=0;\\n        while(1)\\n        {\\n            flag=0;                          //initially flag is set to zero to indicate no problem is there in string\\n            for(int i=0;i<len-1;i++)\\n            {\\n               if(s[i]<=s[i+1])\\n                continue;\\n               else\\n               {\\n                  ind=i;                        //ind refers to the index at which the problem occurs\\n                  string ans=\"\";\\n                  for(int j=1;j<=len-1-ind;j++)\\n                    ans+=\\'9\\';\\n                  s=s.substr(0,ind)+(--s[ind])+ans;        //final string is formed and s is replaced with new string\\n                  flag=1;                          //flag is set to one to indicate the string was problematic and the while loop will continue further\\n               }   \\n            }\\n            if(flag==0)                 //if string is perfect(no error) then exit the while loop\\n             break;\\n        }\\n        int final=stoi(s);\\n        return final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s=to_string(n);              //num converted to string\\n        int len=s.size(),ind,flag=0;\\n        while(1)\\n        {\\n            flag=0;                          //initially flag is set to zero to indicate no problem is there in string\\n            for(int i=0;i<len-1;i++)\\n            {\\n               if(s[i]<=s[i+1])\\n                continue;\\n               else\\n               {\\n                  ind=i;                        //ind refers to the index at which the problem occurs\\n                  string ans=\"\";\\n                  for(int j=1;j<=len-1-ind;j++)\\n                    ans+=\\'9\\';\\n                  s=s.substr(0,ind)+(--s[ind])+ans;        //final string is formed and s is replaced with new string\\n                  flag=1;                          //flag is set to one to indicate the string was problematic and the while loop will continue further\\n               }   \\n            }\\n            if(flag==0)                 //if string is perfect(no error) then exit the while loop\\n             break;\\n        }\\n        int final=stoi(s);\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009726,
                "title": "easy-o-n-javascript-with-explanation",
                "content": "```\\n\\nconst monotoneIncreasingDigits = N => {\\n  \\n  // create any array of integers from number N\\n  const n = Array.from(\\'\\'+N, Number);\\n  \\n  let i = 0;\\n  \\n  // find the cliff\\n  while(i < n.length-1 && n[i] <= n[i+1])\\n    i++;\\n\\n // decremnet the cliff and any values before the cliff which satisfy this condition n[i] > n[i+1]\\n  while( i >= 0 && n[i] > n[i+1]){\\n    n[i]--;\\n    i--;\\n  }\\n  \\n  // assign any value after the first cliff to 9\\n  for(let j = i+2; j < n.length; j++)\\n    n[j] = 9;\\n  \\n  // convert the integer array to a string then to a number and return\\n  return +n.join(\\'\\')\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst monotoneIncreasingDigits = N => {\\n  \\n  // create any array of integers from number N\\n  const n = Array.from(\\'\\'+N, Number);\\n  \\n  let i = 0;\\n  \\n  // find the cliff\\n  while(i < n.length-1 && n[i] <= n[i+1])\\n    i++;\\n\\n // decremnet the cliff and any values before the cliff which satisfy this condition n[i] > n[i+1]\\n  while( i >= 0 && n[i] > n[i+1]){\\n    n[i]--;\\n    i--;\\n  }\\n  \\n  // assign any value after the first cliff to 9\\n  for(let j = i+2; j < n.length; j++)\\n    n[j] = 9;\\n  \\n  // convert the integer array to a string then to a number and return\\n  return +n.join(\\'\\')\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 957995,
                "title": "straightforward-greedy-python-solution",
                "content": "```\\n    def monotoneIncreasingDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        s = str(N)\\n        if len(s) < 2:\\n            return N\\n        ans = \"\"\\n        pre = 0\\n        for i in range(len(s)):\\n            if int(s[i]) >= pre:\\n                ans += s[i]\\n                pre = int(s[i])\\n            else:\\n                j = len(ans)-1\\n                while j-1 >= 0 and ans[j] == ans[j-1]:\\n                    j -= 1\\n                ans = ans[:j+1] + (len(s)-j-1)*\\'0\\'\\n                return int(ans)-1\\n        return int(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\n    def monotoneIncreasingDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        s = str(N)\\n        if len(s) < 2:\\n            return N\\n        ans = \"\"\\n        pre = 0\\n        for i in range(len(s)):\\n            if int(s[i]) >= pre:\\n                ans += s[i]\\n                pre = int(s[i])\\n            else:\\n                j = len(ans)-1\\n                while j-1 >= 0 and ans[j] == ans[j-1]:\\n                    j -= 1\\n                ans = ans[:j+1] + (len(s)-j-1)*\\'0\\'\\n                return int(ans)-1\\n        return int(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 870704,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\n    vector<int> convert_to_arr(int n){\\n        vector<int> v;\\n        while(n){\\n            int t = n%10;\\n            n = n/10;\\n            v.push_back(t);\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n    \\n    int convert_int(vector<int> nums){\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n            ans = ans*10 + nums[i];\\n        return ans;\\n    }\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        vector<int> nums = convert_to_arr(N);\\n        stack<int> st;\\n        int n = nums.size();\\n        int count = 0;\\n        for(int i=n-1;i>=0;i--){\\n          int count = 0;\\n            if(st.size()>0 and nums[i]>nums[st.top()]){\\n              while(st.size()>0){\\n                   nums[st.top()] = 9;\\n                   st.pop();\\n               }\\n             count = -1;\\n            }\\n            nums[i] += count;\\n            st.push(i);\\n        }\\n      \\n       return convert_int(nums); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> convert_to_arr(int n){\\n        vector<int> v;\\n        while(n){\\n            int t = n%10;\\n            n = n/10;\\n            v.push_back(t);\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n    \\n    int convert_int(vector<int> nums){\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n            ans = ans*10 + nums[i];\\n        return ans;\\n    }\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        vector<int> nums = convert_to_arr(N);\\n        stack<int> st;\\n        int n = nums.size();\\n        int count = 0;\\n        for(int i=n-1;i>=0;i--){\\n          int count = 0;\\n            if(st.size()>0 and nums[i]>nums[st.top()]){\\n              while(st.size()>0){\\n                   nums[st.top()] = 9;\\n                   st.pop();\\n               }\\n             count = -1;\\n            }\\n            nums[i] += count;\\n            st.push(i);\\n        }\\n      \\n       return convert_int(nums); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109785,
                "title": "simple-python-solution",
                "content": "class Solution(object):\\n    def monotoneIncreasingDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if N == 10:\\n            return 9\\n        if N < 20:\\n            return N\\n        num = [s for s in str(N)]\\n        i = len(num) - 1\\n        index = len(num) \\n        while i > 0:\\n            if int(num[i]) < int(num[i-1]):\\n                num[i-1] = str(int(num[i-1]) -1)\\n                index = i\\n            i -= 1\\n        for n in range(index,len(num)):\\n            num[n] = '9'\\n        return int(''.join(s for s in num))",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def monotoneIncreasingDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if N == 10:\\n            return 9\\n        if N < 20:\\n            return N\\n        num = [s for s in str(N)]\\n        i = len(num) - 1\\n        index = len(num) \\n        while i > 0:\\n            if int(num[i]) < int(num[i-1]):\\n                num[i-1] = str(int(num[i-1]) -1)\\n                index = i\\n            i -= 1\\n        for n in range(index,len(num)):\\n            num[n] = '9'\\n        return int(''.join(s for s in num))",
                "codeTag": "Java"
            },
            {
                "id": 2439636,
                "title": "java-simple-solution-without-dp",
                "content": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int len = size(n);\\n        int[] dig = new int[len];\\n        len--;\\n        while(n>0){\\n            dig[len] = n%10;\\n            n /= 10;\\n            len--;\\n        }\\n        n = dig.length;\\n        int t = 10;\\n\\n        while(t>0){\\n            boolean change = false;\\n            for(int i=0;i<n-1;i++){\\n                if(dig[i]>dig[i+1]){\\n                    dig[i]--;\\n                    for(int j=i+1;j<n;j++){\\n                        dig[j]=9;\\n                    }\\n                    change = true;\\n                    break;\\n                }\\n            }\\n            if(!change){\\n                break;\\n            }\\n            t--;\\n        }\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            ans += dig[i]*(int)Math.pow(10,n-i-1);\\n        }\\n        return ans;\\n    }\\n    public int size(int num){\\n        if(0<=num && num<10){\\n            return 1;\\n        }\\n        if(10<=num && num<100){\\n            return 2;\\n        }\\n        if(100<=num && num<1000){\\n            return 3;\\n        }\\n        if(1000<=num && num<10000){\\n            return 4;\\n        }\\n        if(10000<=num && num<100000){\\n            return 5;\\n        }\\n        if(100000<=num && num<1000000){\\n            return 6;\\n        }\\n        if(1000000<=num && num<10000000){\\n            return 7;\\n        }\\n        if(10000000<=num && num<100000000){\\n            return 8;\\n        }\\n        if(100000000<=num && num<1000000000){\\n            return 9;\\n        }\\n        return 10;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int len = size(n);\\n        int[] dig = new int[len];\\n        len--;\\n        while(n>0){\\n            dig[len] = n%10;\\n            n /= 10;\\n            len--;\\n        }\\n        n = dig.length;\\n        int t = 10;\\n\\n        while(t>0){\\n            boolean change = false;\\n            for(int i=0;i<n-1;i++){\\n                if(dig[i]>dig[i+1]){\\n                    dig[i]--;\\n                    for(int j=i+1;j<n;j++){\\n                        dig[j]=9;\\n                    }\\n                    change = true;\\n                    break;\\n                }\\n            }\\n            if(!change){\\n                break;\\n            }\\n            t--;\\n        }\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            ans += dig[i]*(int)Math.pow(10,n-i-1);\\n        }\\n        return ans;\\n    }\\n    public int size(int num){\\n        if(0<=num && num<10){\\n            return 1;\\n        }\\n        if(10<=num && num<100){\\n            return 2;\\n        }\\n        if(100<=num && num<1000){\\n            return 3;\\n        }\\n        if(1000<=num && num<10000){\\n            return 4;\\n        }\\n        if(10000<=num && num<100000){\\n            return 5;\\n        }\\n        if(100000<=num && num<1000000){\\n            return 6;\\n        }\\n        if(1000000<=num && num<10000000){\\n            return 7;\\n        }\\n        if(10000000<=num && num<100000000){\\n            return 8;\\n        }\\n        if(100000000<=num && num<1000000000){\\n            return 9;\\n        }\\n        return 10;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165565,
                "title": "easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\\\\\n        string s=to_string(n);\\n        int x=s.size();\\n        for (int i=s.size()-1;i>0;i--) {\\n            if (s[i]<s[i-1]) {\\n                x=i;\\n                s[i-1]=s[i-1]-1;\\n            }\\n        }\\n        for (int i=x;i<s.size();i++) s[i]=\\'9\\';\\n        stringstream geek(s);\\n        geek>>x;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\\\\\n        string s=to_string(n);\\n        int x=s.size();\\n        for (int i=s.size()-1;i>0;i--) {\\n            if (s[i]<s[i-1]) {\\n                x=i;\\n                s[i-1]=s[i-1]-1;\\n            }\\n        }\\n        for (int i=x;i<s.size();i++) s[i]=\\'9\\';\\n        stringstream geek(s);\\n        geek>>x;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757475,
                "title": "c-100-faster",
                "content": ",,,\\n\\n    int monotoneIncreasingDigits(int n) {\\n     \\n        vector<int> v;\\n        \\n        while(n)\\n        {\\n            v.push_back(n%10);\\n            n=n/10;\\n        }\\n        \\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(i<v.size()-1 && v[i]<v[i+1])\\n            {\\n                v[i]=9;\\n                v[i+1]--;\\n                int k=i;\\n                while(k>0 && v[k]>v[k-1])\\n                {\\n                    v[k-1]=v[k];\\n                    k--;\\n                }\\n                \\n            }\\n           \\n        }\\n        \\n        reverse(v.begin(),v.end());\\n        \\n        long ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans = ans*10;\\n            ans += v[i];\\n        }\\n        \\n        return ans;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": ",,,\\n\\n    int monotoneIncreasingDigits(int n) {\\n     \\n        vector<int> v;\\n        \\n        while(n)\\n        {\\n            v.push_back(n%10);\\n            n=n/10;\\n        }\\n        \\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(i<v.size()-1 && v[i]<v[i+1])\\n            {\\n                v[i]=9;\\n                v[i+1]--;\\n                int k=i;\\n                while(k>0 && v[k]>v[k-1])\\n                {\\n                    v[k-1]=v[k];\\n                    k--;\\n                }\\n                \\n            }\\n           \\n        }\\n        \\n        reverse(v.begin(),v.end());\\n        \\n        long ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans = ans*10;\\n            ans += v[i];\\n        }\\n        \\n        return ans;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1672111,
                "title": "8-line-js-code",
                "content": "```\\nvar monotoneIncreasingDigits = function(n) {\\n    let arr = String(n).split(\\'\\');\\n    for (let i=arr.length-2; i>=0; i--) {\\n        if (arr[i]>arr[i+1]) {\\n            arr[i]--;\\n            for(let j=i+1; j<arr.length; j++) arr[j]=\\'9\\';\\n        }\\n    }\\n    return Number(arr.join(\\'\\'));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar monotoneIncreasingDigits = function(n) {\\n    let arr = String(n).split(\\'\\');\\n    for (let i=arr.length-2; i>=0; i--) {\\n        if (arr[i]>arr[i+1]) {\\n            arr[i]--;\\n            for(let j=i+1; j<arr.length; j++) arr[j]=\\'9\\';\\n        }\\n    }\\n    return Number(arr.join(\\'\\'));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1659975,
                "title": "simple-c-without-changing-into-string-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        int ans = 0;\\n        stack<int> st;\\n        \\n        while(n)\\n        {\\n            int last = n % 10; n /= 10;\\n            \\n            if(st.empty() or st.top() >= last)\\n            {\\n                st.push(last);\\n            }\\n            else\\n            {\\n                while(n and n % 10 == last)\\n                {\\n                    st.push(last);\\n                    last = n % 10;\\n                    n /= 10;\\n                }\\n                st.top()--;\\n                \\n                n =  (n*10)  + last;\\n                n =  (n*10) + st.top(); st.pop();\\n                \\n                while(!st.empty())\\n                {\\n                    n = n * 10 +  9;\\n                    st.pop();\\n                }\\n                \\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            n = n * 10 +  st.top();\\n            st.pop();\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        int ans = 0;\\n        stack<int> st;\\n        \\n        while(n)\\n        {\\n            int last = n % 10; n /= 10;\\n            \\n            if(st.empty() or st.top() >= last)\\n            {\\n                st.push(last);\\n            }\\n            else\\n            {\\n                while(n and n % 10 == last)\\n                {\\n                    st.push(last);\\n                    last = n % 10;\\n                    n /= 10;\\n                }\\n                st.top()--;\\n                \\n                n =  (n*10)  + last;\\n                n =  (n*10) + st.top(); st.pop();\\n                \\n                while(!st.empty())\\n                {\\n                    n = n * 10 +  9;\\n                    st.pop();\\n                }\\n                \\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            n = n * 10 +  st.top();\\n            st.pop();\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279195,
                "title": "digit-dp-c",
                "content": "Using Digit Dynamic Programming \\n```\\nclass Solution {\\npublic:\\n    int str_to_int(string temp){\\n        int ans = 0, prod = 1;\\n        while(temp.size()){\\n            ans += prod*(temp.back()-\\'0\\');\\n            temp.pop_back();\\n            if(prod == 1e9) break;\\n            prod *= 10;\\n        }\\n        return ans;\\n    }\\n    \\n    string int_to_str(int temp){\\n        deque<char> d;\\n        while(temp){\\n            d.push_front(char((temp%10)+\\'0\\'));\\n            temp/=10;\\n        }\\n        string ans; \\n        for(char c : d){\\n            ans += c;\\n        }\\n        return ans;\\n    }\\n    \\n    string s;\\n    int dp[10][2][10];\\n    string go(int curr, int n, bool tight, int last){\\n        if(curr == n){\\n            return \"\";\\n        }\\n        if(dp[curr][tight][last] != -1) return int_to_str(dp[curr][tight][last]);\\n        string ans = \"\";\\n        int ub = 9;\\n        if(tight == 1) ub = s[curr] - \\'0\\';\\n        for(int i = 0; i <= ub; i++){\\n            if( i >= last ){\\n                string c1 = char(i+\\'0\\') + go(curr+1,n,tight&(i==ub),i);\\n                string c2 = go(curr+1,n,tight,last);\\n                int choice1 = str_to_int(c1);\\n                int choice2 = str_to_int(c2);\\n                int cnt = str_to_int(ans);\\n                cnt = max({cnt,choice1,choice2});\\n                ans = int_to_str(cnt);\\n            }\\n        }\\n        dp[curr][tight][last] = str_to_int(ans);\\n        return ans;\\n    }\\n    \\n    int monotoneIncreasingDigits(int n) {\\n        while(n){\\n            s = char((n%10)+\\'0\\') + s;\\n            n/=10;\\n        }\\n        memset(dp, -1, sizeof dp);\\n        string ans = go(0,s.size(),1,0);\\n        return str_to_int(ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int str_to_int(string temp){\\n        int ans = 0, prod = 1;\\n        while(temp.size()){\\n            ans += prod*(temp.back()-\\'0\\');\\n            temp.pop_back();\\n            if(prod == 1e9) break;\\n            prod *= 10;\\n        }\\n        return ans;\\n    }\\n    \\n    string int_to_str(int temp){\\n        deque<char> d;\\n        while(temp){\\n            d.push_front(char((temp%10)+\\'0\\'));\\n            temp/=10;\\n        }\\n        string ans; \\n        for(char c : d){\\n            ans += c;\\n        }\\n        return ans;\\n    }\\n    \\n    string s;\\n    int dp[10][2][10];\\n    string go(int curr, int n, bool tight, int last){\\n        if(curr == n){\\n            return \"\";\\n        }\\n        if(dp[curr][tight][last] != -1) return int_to_str(dp[curr][tight][last]);\\n        string ans = \"\";\\n        int ub = 9;\\n        if(tight == 1) ub = s[curr] - \\'0\\';\\n        for(int i = 0; i <= ub; i++){\\n            if( i >= last ){\\n                string c1 = char(i+\\'0\\') + go(curr+1,n,tight&(i==ub),i);\\n                string c2 = go(curr+1,n,tight,last);\\n                int choice1 = str_to_int(c1);\\n                int choice2 = str_to_int(c2);\\n                int cnt = str_to_int(ans);\\n                cnt = max({cnt,choice1,choice2});\\n                ans = int_to_str(cnt);\\n            }\\n        }\\n        dp[curr][tight][last] = str_to_int(ans);\\n        return ans;\\n    }\\n    \\n    int monotoneIncreasingDigits(int n) {\\n        while(n){\\n            s = char((n%10)+\\'0\\') + s;\\n            n/=10;\\n        }\\n        memset(dp, -1, sizeof dp);\\n        string ans = go(0,s.size(),1,0);\\n        return str_to_int(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239043,
                "title": "92-intuitive-easy-to-understand-greedy-java",
                "content": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char [] arr=String.valueOf(n).toCharArray();\\n        for(int i=arr.length-2;i>=0;i--){\\n            if(arr[i]<=arr[i+1])\\n                continue;\\n            else{\\n                arr[i]--;\\n                for(int j=i+1;j<arr.length;j++)\\n                    arr[j]=\\'9\\';\\n            }\\n        }\\n        return Integer.valueOf(new String(arr));\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char [] arr=String.valueOf(n).toCharArray();\\n        for(int i=arr.length-2;i>=0;i--){\\n            if(arr[i]<=arr[i+1])\\n                continue;\\n            else{\\n                arr[i]--;\\n                for(int j=i+1;j<arr.length;j++)\\n                    arr[j]=\\'9\\';\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 998451,
                "title": "simple-python-and-easy-to-understand",
                "content": "\\n    def monotoneIncreasingDigits(self, N: int) -> int:\\n\\t\\n        N = str(N)\\n        mono = True # indicator of monotone digit sequence\\n        mid = 0\\n        for i in range(len(N)-1):\\n\\t\\t    #find the last position where N[i+1] > N[i], if the digit sequence is not monotone,\\n\\t\\t\\t#we can decrease the number at this position by one and set all the following numbers as 9\\n            if int(N[i+1]) - int(N[i]) >= 1: \\n                mid = i+1\\n            if int(N[i]) > int(N[i+1]):\\n                mono = False\\n                break\\n                \\n        if mono: #if monotone, return original number\\n            return int(N)\\n\\n        if mid == 0:\\n            return int(str(int(N[0])-1) + (len(N)-1)*\\'9\\')\\n\\n        return int(str(int(N[:mid])) + str(int(N[mid])-1) + (len(N)-mid-1)*\\'9\\')",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def monotoneIncreasingDigits(self, N: int) -> int:\\n\\t\\n        N = str(N)\\n        mono = True # indicator of monotone digit sequence\\n        mid = 0\\n        for i in range(len(N)-1):\\n\\t\\t    #find the last position where N[i+1] > N[i], if the digit sequence is not monotone,\\n\\t\\t\\t#we can decrease the number at this position by one and set all the following numbers as 9\\n            if int(N[i+1]) - int(N[i]) >= 1: \\n                mid = i+1\\n            if int(N[i]) > int(N[i+1]):\\n                mono = False\\n                break\\n                \\n        if mono: #if monotone, return original number\\n            return int(N)\\n\\n        if mid == 0:\\n            return int(str(int(N[0])-1) + (len(N)-1)*\\'9\\')\\n\\n        return int(str(int(N[:mid])) + str(int(N[mid])-1) + (len(N)-mid-1)*\\'9\\')",
                "codeTag": "Python3"
            },
            {
                "id": 976269,
                "title": "python-3",
                "content": "Find the index of the first digit which is smaller than previous digit.\\nFor example, in **135248**, the number 2 is the first digit because it is smaller than 5. The maximum monotone digits is 134999.\\nJust decrease the previous digit (5) by 1 (if it is bigger than 1, otherwise just ignore it), so we have 134 as the first three digits of the new number, and change all the following digits (248) to 9 (999).\\n\\n\\n\\n```\\ndef monotoneIncreasingDigits(self, N: int) -> int:\\n        s=list(str(N))\\n        n=len(s)\\n        ans=\"\"\\n        cur=0\\n        for x in range(n):\\n            if x==0 or s[x]==s[x-1]:\\n                cur+=1\\n            elif s[x]>s[x-1]:\\n                ans+=cur*str(s[x-1])\\n                cur=1\\n            else:\\n                if int(s[x-1])>1:\\n                    ans+=str(int(s[x-1])-1)\\n                ans+=\"9\"*(cur+n-x-1)\\n                return ans\\n        ans+=str(s[x])*cur\\n        return  ans\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndef monotoneIncreasingDigits(self, N: int) -> int:\\n        s=list(str(N))\\n        n=len(s)\\n        ans=\"\"\\n        cur=0\\n        for x in range(n):\\n            if x==0 or s[x]==s[x-1]:\\n                cur+=1\\n            elif s[x]>s[x-1]:\\n                ans+=cur*str(s[x-1])\\n                cur=1\\n            else:\\n                if int(s[x-1])>1:\\n                    ans+=str(int(s[x-1])-1)\\n                ans+=\"9\"*(cur+n-x-1)\\n                return ans\\n        ans+=str(s[x])*cur\\n        return  ans\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 633016,
                "title": "java-clean-solution-beat-100-o-d-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int power = 1;\\n        int toAdd = 0;\\n        int prev = 9;\\n        \\n        while (n != 0) {\\n            int current = n % 10;\\n            n /= 10;\\n            \\n            if (current > prev) {\\n                toAdd = power - 1;\\n                current -= 1;\\n                prev = current;\\n            }\\n            \\n            toAdd += current * power;\\n            prev = Math.min(prev, current);\\n            power *= 10;\\n        }\\n        \\n        return toAdd;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int power = 1;\\n        int toAdd = 0;\\n        int prev = 9;\\n        \\n        while (n != 0) {\\n            int current = n % 10;\\n            n /= 10;\\n            \\n            if (current > prev) {\\n                toAdd = power - 1;\\n                current -= 1;\\n                prev = current;\\n            }\\n            \\n            toAdd += current * power;\\n            prev = Math.min(prev, current);\\n            power *= 10;\\n        }\\n        \\n        return toAdd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352718,
                "title": "creative-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int check_index = 0;\\n    string process(int n)\\n    {\\n        string str = to_string(n);\\n        if (str.size()==1) // one digit\\n            return str;\\n        if (check_index == 1) return str; // check if string is not monotone\\n        for(int i =check_index-1;i>0;i--)\\n        {\\n            if ((str[i]-\\'0\\'<str[i-1]-\\'0\\')) // if not monotone decrease current digit by one;\\n            {\\n                str[i-1] =(str[i-1]-\\'0\\'-1)+\\'0\\';\\n                check_index = i;\\n                for(int t = i;t<str.size();t++) str[t] = 9 + \\'0\\'; //all next values set to 9\\n            }\\n            else if(i==1) return str;\\n        }\\n        return process(stoi(str));\\n    }\\n    \\n    int monotoneIncreasingDigits(int N) {\\n        check_index = to_string(N).size();\\n        return stoi(process(N));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int check_index = 0;\\n    string process(int n)\\n    {\\n        string str = to_string(n);\\n        if (str.size()==1) // one digit\\n            return str;\\n        if (check_index == 1) return str; // check if string is not monotone\\n        for(int i =check_index-1;i>0;i--)\\n        {\\n            if ((str[i]-\\'0\\'<str[i-1]-\\'0\\')) // if not monotone decrease current digit by one;\\n            {\\n                str[i-1] =(str[i-1]-\\'0\\'-1)+\\'0\\';\\n                check_index = i;\\n                for(int t = i;t<str.size();t++) str[t] = 9 + \\'0\\'; //all next values set to 9\\n            }\\n            else if(i==1) return str;\\n        }\\n        return process(stoi(str));\\n    }\\n    \\n    int monotoneIncreasingDigits(int N) {\\n        check_index = to_string(N).size();\\n        return stoi(process(N));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289025,
                "title": "java-1ms-solution-with-detailed-explanation",
                "content": "This problem can be solved in greedy strategy:\\n1. At first, we use a list to represent the given number ```N``` where list.get(0) is the highest number.\\n2. Then, we traverse from 0 to list.size() - 1 to find the **first** i that list[i] > list[i + 1]\\n3. If we don\\'t find such i, then return the given number. Otherwise, we **backwardly** traverse from i to 0 to find the **first** j that list[j] > list[j - 1] or until j equals 0. \\n4. list[j] minus one, and for all k > j, set list[k] to 9. \\n\\n```\\npublic int monotoneIncreasingDigits(int N) {\\n    // Represent N with a list\\n\\tList<Integer> num = new ArrayList<Integer>();\\n    while( N != 0 ) {\\n        num.add(0, N % 10);\\n        N /= 10;\\n    }\\n\\t\\n    for(int i = 0; i < num.size() - 1; i++) {\\n        if( num.get(i) > num.get(i + 1) ) { // find the first i that num[i] > num[i + 1]\\n            for(int j = i; j >= 0; j--) {\\n                if( j == 0 || num.get(j) > num.get(j - 1) ) { // find the first j that num[j] > num[j - 1]\\n                    num.set(j, num.get(j) - 1);\\n                    for(int k = j + 1; k < num.size(); k++) // set all num[k] where k > j to 9\\n                        num.set(k, 9);\\n                    break;\\n                }\\n            }\\n            break;\\n        }\\n    }\\n    int result = 0;\\n    for(int i = 0; i < num.size(); i++)\\n        result = result * 10 + num.get(i);\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```N```\n```\\npublic int monotoneIncreasingDigits(int N) {\\n    // Represent N with a list\\n\\tList<Integer> num = new ArrayList<Integer>();\\n    while( N != 0 ) {\\n        num.add(0, N % 10);\\n        N /= 10;\\n    }\\n\\t\\n    for(int i = 0; i < num.size() - 1; i++) {\\n        if( num.get(i) > num.get(i + 1) ) { // find the first i that num[i] > num[i + 1]\\n            for(int j = i; j >= 0; j--) {\\n                if( j == 0 || num.get(j) > num.get(j - 1) ) { // find the first j that num[j] > num[j - 1]\\n                    num.set(j, num.get(j) - 1);\\n                    for(int k = j + 1; k < num.size(); k++) // set all num[k] where k > j to 9\\n                        num.set(k, 9);\\n                    break;\\n                }\\n            }\\n            break;\\n        }\\n    }\\n    int result = 0;\\n    for(int i = 0; i < num.size(); i++)\\n        result = result * 10 + num.get(i);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276266,
                "title": "swift-8ms-beat-100-with-space",
                "content": "```\\nfunc monotoneIncreasingDigits(_ N: Int) -> Int {\\n        if N < 10{\\n            return N\\n        }\\n        var N = String(N).characters.map{Int(String($0))!}\\n        var lastChanged = -1\\n        for i in stride(from: N.count - 1, to:0, by: -1){\\n            if N[i-1] > N[i]{\\n                N[i] = 9\\n                N[i-1] = N[i-1] - 1\\n                lastChanged = i\\n            }\\n        }\\n        \\n        if lastChanged != -1{\\n            var rightIndex = lastChanged + 1\\n            while(rightIndex < N.count){\\n                N[rightIndex] = 9\\n                rightIndex += 1\\n            }\\n        }\\n        \\n        if N[0] <= 0{\\n            N.remove(at: 0)\\n        }\\n        return Int(N.map{String($0)}.joined())!\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc monotoneIncreasingDigits(_ N: Int) -> Int {\\n        if N < 10{\\n            return N\\n        }\\n        var N = String(N).characters.map{Int(String($0))!}\\n        var lastChanged = -1\\n        for i in stride(from: N.count - 1, to:0, by: -1){\\n            if N[i-1] > N[i]{\\n                N[i] = 9\\n                N[i-1] = N[i-1] - 1\\n                lastChanged = i\\n            }\\n        }\\n        \\n        if lastChanged != -1{\\n            var rightIndex = lastChanged + 1\\n            while(rightIndex < N.count){\\n                N[rightIndex] = 9\\n                rightIndex += 1\\n            }\\n        }\\n        \\n        if N[0] <= 0{\\n            N.remove(at: 0)\\n        }\\n        return Int(N.map{String($0)}.joined())!\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 112785,
                "title": "my-simple-java-solution",
                "content": "Starting from the right most bit. It should be greater than or equal to the one to its left. If it is true, skip. For example, 1234. It will return 1234. \\nelse,  arr[i - 1] - 1 and use j to track the position of i. Lastly, set all bits to 9 from j to the end. For example, 322 becomes 299.\\n\\n```\\npublic int monotoneIncreasingDigits(int N) {\\n        char[] arr = String.valueOf(N).toCharArray();\\n        int len = arr.length, j = len;\\n        for (int i = len - 1; i > 0; i--) {\\n            if (arr[i] >= arr[i - 1]) continue;\\n            arr[i - 1]--;\\n            j = i;\\n        }\\n        for (int i = j; i < len; i++) {\\n            arr[i] = '9';\\n        }\\n        return Integer.valueOf(new String(arr));\\n    }",
                "solutionTags": [],
                "code": "Starting from the right most bit. It should be greater than or equal to the one to its left. If it is true, skip. For example, 1234. It will return 1234. \\nelse,  arr[i - 1] - 1 and use j to track the position of i. Lastly, set all bits to 9 from j to the end. For example, 322 becomes 299.\\n\\n```\\npublic int monotoneIncreasingDigits(int N) {\\n        char[] arr = String.valueOf(N).toCharArray();\\n        int len = arr.length, j = len;\\n        for (int i = len - 1; i > 0; i--) {\\n            if (arr[i] >= arr[i - 1]) continue;\\n            arr[i - 1]--;\\n            j = i;\\n        }\\n        for (int i = j; i < len; i++) {\\n            arr[i] = '9';\\n        }\\n        return Integer.valueOf(new String(arr));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4051367,
                "title": "simple-priority-queue-approach-to-optimised-sol-2-ways",
                "content": "Simply genrate all numbers according to constrain take maximum till we reach the same length as given number \\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int monotoneIncreasingDigits(int n) \\n    {\\n        long long num=n;\\n        if(num==0) return 0;\\n        if(num<=10)return 9;\\n        priority_queue<long long>pq;\\n        for(int i=1; i<=9; i++)\\n        {\\n            pq.push(i);\\n        }\\n        \\n        long long ans=0;\\n        int s= to_string(num).size();\\n        int c=0;\\n        while(!pq.empty())\\n        {\\n            long long it= pq.top();\\n            pq.pop();\\n            c++;\\n            ans=max(ans, it);\\n            if(to_string(it).size()==s)\\n            {\\n                break;\\n            }\\n            int last= it%10;\\n            for(int i=last; i<=9; i++)\\n            {\\n                if(((1ll*it*10) +i) <=num) pq.push(it*10+i);\\n            }\\n        }\\n        \\n        return (int)ans;\\n        \\n        \\n    }\\n};\\n\\n```\\n\\n\\n\\nOptimised version\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int monotoneIncreasingDigits(int n) \\n    {\\n        long long num=n;\\n        if(num==0) return 0;\\n        if(num<=10)return 9;\\n        priority_queue<long long>pq;\\n        for(int i=1; i<=9; i++)\\n        {\\n            pq.push(i);\\n        }\\n        \\n        long long ans=0;\\n        int s= to_string(num).size();\\n        int c=0;\\n        while(!pq.empty())\\n        {\\n            long long it= pq.top();\\n            pq.pop();\\n            c++;\\n            ans=max(ans, it);\\n            if(to_string(it).size()==s)\\n            {\\n                break;\\n            }\\n            int last= it%10;\\n            for(int i=last; i<=9; i++)\\n            {\\n                if(((1ll*it*10) +i) <=num) pq.push(it*10+i);\\n            }\\n        }\\n        \\n        return (int)ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int monotoneIncreasingDigits(int n) \\n    {\\n        long long num=n;\\n        if(num==0) return 0;\\n        if(num<=10)return 9;\\n        priority_queue<long long>pq;\\n        for(int i=1; i<=9; i++)\\n        {\\n            pq.push(i);\\n        }\\n        \\n        long long ans=0;\\n        int s= to_string(num).size();\\n        int c=0;\\n        while(!pq.empty())\\n        {\\n            long long it= pq.top();\\n            pq.pop();\\n            c++;\\n            ans=max(ans, it);\\n            if(to_string(it).size()==s)\\n            {\\n                break;\\n            }\\n            int last= it%10;\\n            for(int i=last; i<=9; i++)\\n            {\\n                if(((1ll*it*10) +i) <=num) pq.push(it*10+i);\\n            }\\n        }\\n        \\n        return (int)ans;\\n        \\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int monotoneIncreasingDigits(int n) \\n    {\\n        long long num=n;\\n        if(num==0) return 0;\\n        if(num<=10)return 9;\\n        priority_queue<long long>pq;\\n        for(int i=1; i<=9; i++)\\n        {\\n            pq.push(i);\\n        }\\n        \\n        long long ans=0;\\n        int s= to_string(num).size();\\n        int c=0;\\n        while(!pq.empty())\\n        {\\n            long long it= pq.top();\\n            pq.pop();\\n            c++;\\n            ans=max(ans, it);\\n            if(to_string(it).size()==s)\\n            {\\n                break;\\n            }\\n            int last= it%10;\\n            for(int i=last; i<=9; i++)\\n            {\\n                if(((1ll*it*10) +i) <=num) pq.push(it*10+i);\\n            }\\n        }\\n        \\n        return (int)ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445662,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        while(1){\\n            bool flag = false;\\n            for(int i = 1; i < s.length(); i++){\\n                if(s[i] >= s[i-1]) continue;\\n                else{\\n                    s[i-1]--;\\n                    while(i != s.length()){\\n                        s[i] = \\'9\\';\\n                        i++;\\n                    }\\n                    flag = true;\\n                }\\n            }\\n            if(!flag) break;\\n        }\\n        return stoi(s);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        strn = list(str(n))\\n        flag = len(strn)\\n\\n        for i in range(flag-1,0,-1):\\n            if strn[i] < strn[i-1]:\\n                flag = i\\n                strn[i-1] = str(int(strn[i-1]) -1)\\n                \\n        for i in range(flag, len(strn)):\\n            strn[i] = \\'9\\'\\n\\n        return int(\"\".join(strn))\\n```\\n\\n```Java []\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int[] digits = new int[10];\\n        int num = n;\\n        int index = 0;\\n\\n        while(n > 0){\\n            digits[index++] = n % 10;\\n            n /= 10;\\n        }\\n        int start = 0, len = index;\\n        int end = len - 1;\\n        while(start < end){\\n            int d = digits[start];\\n            digits[start++] = digits[end];\\n            digits[end--] = d;\\n        }\\n        int i = 1;\\n        for(;i < len;i++){\\n            if(digits[i - 1] > digits[i]) break;\\n        }\\n        if(i == len) return num;\\n        i--;\\n        while(i > 0 && digits[i - 1] == digits[i]){\\n            i--;\\n        }\\n        digits[i++]--;\\n        while(i < len) digits[i++] = 9;\\n        int ans = 0;\\n        for( i = 0;i < len;i++) ans = ans * 10 + digits[i];\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        while(1){\\n            bool flag = false;\\n            for(int i = 1; i < s.length(); i++){\\n                if(s[i] >= s[i-1]) continue;\\n                else{\\n                    s[i-1]--;\\n                    while(i != s.length()){\\n                        s[i] = \\'9\\';\\n                        i++;\\n                    }\\n                    flag = true;\\n                }\\n            }\\n            if(!flag) break;\\n        }\\n        return stoi(s);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        strn = list(str(n))\\n        flag = len(strn)\\n\\n        for i in range(flag-1,0,-1):\\n            if strn[i] < strn[i-1]:\\n                flag = i\\n                strn[i-1] = str(int(strn[i-1]) -1)\\n                \\n        for i in range(flag, len(strn)):\\n            strn[i] = \\'9\\'\\n\\n        return int(\"\".join(strn))\\n```\n```Java []\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int[] digits = new int[10];\\n        int num = n;\\n        int index = 0;\\n\\n        while(n > 0){\\n            digits[index++] = n % 10;\\n            n /= 10;\\n        }\\n        int start = 0, len = index;\\n        int end = len - 1;\\n        while(start < end){\\n            int d = digits[start];\\n            digits[start++] = digits[end];\\n            digits[end--] = d;\\n        }\\n        int i = 1;\\n        for(;i < len;i++){\\n            if(digits[i - 1] > digits[i]) break;\\n        }\\n        if(i == len) return num;\\n        i--;\\n        while(i > 0 && digits[i - 1] == digits[i]){\\n            i--;\\n        }\\n        digits[i++]--;\\n        while(i < len) digits[i++] = 9;\\n        int ans = 0;\\n        for( i = 0;i < len;i++) ans = ans * 10 + digits[i];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307999,
                "title": "simple-c-sloution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose we have a non-negative integer N, we have to find the largest number that is less than or equal to N with monotone increasing digits. We know that an integer has monotone increasing digits if and only if each pair of adjacent digits\\u2019 x and y satisfy x <= y.) So if the input is like 332, then the result will be 299.\\n\\nTo solve this, we will follow these steps \\u2212\\n\\ns := N as string, i := 1, n := size of s\\nwhile i < n and s[i] >= s[i \\u2013 1]\\nincrease i by 1\\nif i < n\\nwhile i > 0 and s[i \\u2013 1] > s[i], then\\ndecrease i by 1\\ndecrease s[i] by 1\\nfor j in range i + 1 to n\\ns[j] := \\u20189\\u2019\\nreturn s as number\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n     string s = to_string(N);\\n      int i = 1;\\n      int n = s.size();\\n      while(i < n && s[i] >= s[i - 1]) i++;\\n      if( i < n)\\n      while(i > 0 && s[i - 1] > s[i]){\\n         i--;\\n         s[i]--;\\n      }\\n      for(int j = i + 1; j < n; j++)s[j] = \\'9\\';\\n      return stoi(s);\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n     string s = to_string(N);\\n      int i = 1;\\n      int n = s.size();\\n      while(i < n && s[i] >= s[i - 1]) i++;\\n      if( i < n)\\n      while(i > 0 && s[i - 1] > s[i]){\\n         i--;\\n         s[i]--;\\n      }\\n      for(int j = i + 1; j < n; j++)s[j] = \\'9\\';\\n      return stoi(s);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081415,
                "title": "python-solution-using-backtracking-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n\\t\\t# max size of string\\n        self.maxlen = len(str(n))\\n\\t\\t# maximum ans store here\\n        self.maxans = 0\\n        self.find(str(n))\\n        return self.maxans\\n    \\n    def find(self,num,idx=0,curnum=\\'\\',pb=None):\\n\\t\\t# idx is size counter of current number (curnum) pb represents previous bit/number at idx position\\n\\t\\t\\'\\'\\'\\n\\t\\t\\tThis Approach uses leading zeros in number that means\\n\\t\\t\\tif we are looking for ans for value 10 it will be 09 instead of 9\\n\\t\\t\\tbut int(\\'09\\') = 9 so we receive our output. hence length of final\\n\\t\\t\\toutput will always be equal to length of string i.e. self.maxlen\\n\\t\\t\\t\\n\\t\\t\\twe\\'ll start creating number from backside for example if we are looking for\\n\\t\\t\\tn = 1234 first bit in first iteration will be 1 then we\\'ll place second bit in the range\\n\\t\\t\\tof 1-9 and third bit in the range of 2-9.\\n\\t\\t\\t\\n\\t\\t\\tAs soon as we receive one ans that will be the largest one we stop the recursion and returns\\n\\t\\t\\tthe answer\\n\\t\\t\\'\\'\\'\\n        if idx == self.maxlen:\\n            self.maxans = max(self.maxans,int(curnum))\\n\\t\\t# if we have received our ans we will stop backtracking immediatly\\n        if idx >= self.maxlen or self.maxans:\\n            return\\n\\t\\t# if first time call\\n        if not pb:\\n            for i in range(int(num[idx]),-1,-1):\\n                self.find(num,idx+1,curnum+str(i),num[idx])\\n\\t\\t# otherwise\\n        else:\\n            for i in range(9,int(pb)-1,-1):\\n                if int(curnum+str(i))<=int(num[:idx+1]):\\n                    self.find(num,idx+1,curnum+str(i),num[idx])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Backtracking",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n\\t\\t# max size of string\\n        self.maxlen = len(str(n))\\n\\t\\t# maximum ans store here\\n        self.maxans = 0\\n        self.find(str(n))\\n        return self.maxans\\n    \\n    def find(self,num,idx=0,curnum=\\'\\',pb=None):\\n\\t\\t# idx is size counter of current number (curnum) pb represents previous bit/number at idx position\\n\\t\\t\\'\\'\\'\\n\\t\\t\\tThis Approach uses leading zeros in number that means\\n\\t\\t\\tif we are looking for ans for value 10 it will be 09 instead of 9\\n\\t\\t\\tbut int(\\'09\\') = 9 so we receive our output. hence length of final\\n\\t\\t\\toutput will always be equal to length of string i.e. self.maxlen\\n\\t\\t\\t\\n\\t\\t\\twe\\'ll start creating number from backside for example if we are looking for\\n\\t\\t\\tn = 1234 first bit in first iteration will be 1 then we\\'ll place second bit in the range\\n\\t\\t\\tof 1-9 and third bit in the range of 2-9.\\n\\t\\t\\t\\n\\t\\t\\tAs soon as we receive one ans that will be the largest one we stop the recursion and returns\\n\\t\\t\\tthe answer\\n\\t\\t\\'\\'\\'\\n        if idx == self.maxlen:\\n            self.maxans = max(self.maxans,int(curnum))\\n\\t\\t# if we have received our ans we will stop backtracking immediatly\\n        if idx >= self.maxlen or self.maxans:\\n            return\\n\\t\\t# if first time call\\n        if not pb:\\n            for i in range(int(num[idx]),-1,-1):\\n                self.find(num,idx+1,curnum+str(i),num[idx])\\n\\t\\t# otherwise\\n        else:\\n            for i in range(9,int(pb)-1,-1):\\n                if int(curnum+str(i))<=int(num[:idx+1]):\\n                    self.find(num,idx+1,curnum+str(i),num[idx])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038319,
                "title": "javascript-fast-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind first decrease number and set it 9\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* return n if n is less then 10\\n* for i: String(n)\\n* find first y that is less then before\\n* find max number x before y\\n\\ncombine result:\\n* same with n when index < x\\n* x-1 when index == x\\n* 9 when index >=y\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar monotoneIncreasingDigits = function(n) {\\n    const str = String(n);\\n    const len = str.length;\\n\\n    let increaseIndex = 0;\\n    let nineIndex = 0;\\n\\n    for(let i = 1;i<len;i++){\\n        const diff = str[i] - str[i-1];\\n        if(diff === 0){\\n            continue;\\n        }\\n        if(diff > 0){\\n            increaseIndex = i;\\n        }\\n        if(diff <0){\\n            nineIndex = i;\\n            break;\\n        }\\n    }\\n    if(increaseIndex === nineIndex){\\n        return n;\\n    }\\n    if(nineIndex ==0){\\n        return n;\\n    }\\n    let result = \\'\\';\\n    for(let i =0;i<len;i++){\\n        if(i<increaseIndex){\\n            result += str[i];\\n            continue;\\n        }\\n        if(i>=nineIndex || i >increaseIndex){\\n            result += \\'9\\'\\n            continue;\\n        }\\n        if(i == increaseIndex){\\n            result += str[i]-1;   \\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar monotoneIncreasingDigits = function(n) {\\n    const str = String(n);\\n    const len = str.length;\\n\\n    let increaseIndex = 0;\\n    let nineIndex = 0;\\n\\n    for(let i = 1;i<len;i++){\\n        const diff = str[i] - str[i-1];\\n        if(diff === 0){\\n            continue;\\n        }\\n        if(diff > 0){\\n            increaseIndex = i;\\n        }\\n        if(diff <0){\\n            nineIndex = i;\\n            break;\\n        }\\n    }\\n    if(increaseIndex === nineIndex){\\n        return n;\\n    }\\n    if(nineIndex ==0){\\n        return n;\\n    }\\n    let result = \\'\\';\\n    for(let i =0;i<len;i++){\\n        if(i<increaseIndex){\\n            result += str[i];\\n            continue;\\n        }\\n        if(i>=nineIndex || i >increaseIndex){\\n            result += \\'9\\'\\n            continue;\\n        }\\n        if(i == increaseIndex){\\n            result += str[i]-1;   \\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744868,
                "title": "recursion-greedy-clean-and-concise-code",
                "content": "# Approach\\nTry every possible valid combination\\n\\n# Complexity\\n- Time complexity: O(2^N)\\n- Space complexity: O(N) for ans string\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool solve(int i,string &ans,bool lim,string &str){\\n        if(i == str.size()) return ans <= str;\\n        char st = lim ? str[i] : \\'9\\';\\n        for(char ch = st;ch >= ans.back();ch--){\\n            ans += ch;\\n            if(solve(i+1,ans,lim ? ch == str[i] : false,str)) return true;\\n            ans.pop_back();\\n        }\\n\\n        return false;\\n    }\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string str = to_string(n);\\n        for(char ch = str[0];ch>=\\'0\\';ch--){\\n            string ans;\\n            ans+=ch;\\n            if(solve(1,ans,ch == str[0],str)) return stoi(ans);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool solve(int i,string &ans,bool lim,string &str){\\n        if(i == str.size()) return ans <= str;\\n        char st = lim ? str[i] : \\'9\\';\\n        for(char ch = st;ch >= ans.back();ch--){\\n            ans += ch;\\n            if(solve(i+1,ans,lim ? ch == str[i] : false,str)) return true;\\n            ans.pop_back();\\n        }\\n\\n        return false;\\n    }\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string str = to_string(n);\\n        for(char ch = str[0];ch>=\\'0\\';ch--){\\n            string ans;\\n            ans+=ch;\\n            if(solve(1,ans,ch == str[0],str)) return stoi(ans);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541964,
                "title": "easy-c-solution-with-explaination",
                "content": "### Main Concept\\n\\nFirst let us consider the number as a string of digits. E.g: 123 is \"123\" with size 3.\\n\\n* Violation occurs if for any digit the previous digit is greater i.e \\n\\n\\t``` s[i-1] > s[i] for i in 1...n-1``` where n is number of digits.\\n\\t\\t\\t\\t\\n* For any violation, we can decrease the previous digit and set the following digits to 9 to remove the violation.\\n\\n\\tEg:  In  `14211` the violating digits are `4` and `2`.  If we decrease `4` and set the digits following `4` to `9` we get `13999` which is the optimal solution.\\n\\n* Doing the previous step will also remove all other violations as well if they exist.\\n* If there are digits immediately before the previous digit of the violating pair, that are equal to the previous digit, we need to decrease the first occurance of the previous digit and set the following digits to 9.\\n\\n\\tEg: In `188882` the violating pair is `8` and `2` at index `4` and `5` respectively. \\n\\tNow since the digits between indices `1` and `3` are equal to previous digit `8` at index `4` we will decrease the first occurance of `8` at index `1` and set the following digits to `9`. \\n\\tThis will give us the solution `179999` which is the optimal solution.\\n\\t\\n<hr>\\n<br>\\n\\n### Code\\n\\n```\\nclass Solution {\\n    \\n    string num;\\n    \\n    int findViolationPosition() {\\n        for(int i=1; i < num.size(); i++) {\\n            // check if previous number greater than next i.e violation\\n            if(num[i-1] > num[i])\\n                return i;\\n        }\\n        return -1;   \\n    }\\n    \\n    int findSmallestIndexToChange(int violation_position) {\\n        int smallest_index = violation_position - 1;\\n        for(; smallest_index >=0; smallest_index--) {\\n            if(num[smallest_index] != num[violation_position-1]) {\\n                break;\\n            }\\n        }\\n        return smallest_index+1;\\n    }\\n    \\n    string removeViolations(int smallest_index) {\\n        string sol = num;\\n        sol[smallest_index]--;\\n        for(int i=smallest_index+1; i<sol.size(); i++) {\\n            sol[i] = \\'9\\';\\n        }\\n        return sol;\\n    }\\n    \\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        \\n        // store the number in string format \\n        num = to_string(n);\\n        \\n        // find the position where violation occurs\\n        int violation_position = findViolationPosition();\\n        \\n        // if no violation then the current number is the answer\\n        if(violation_position == -1) \\n            return n;\\n        \\n        // find the smallest index that must be changed to remove violation.\\n        int smallest_index = findSmallestIndexToChange(violation_position);\\n        \\n        \\n        // decrease the number at the smallest_index and make every number after it as 9\\n        string ans = removeViolations(smallest_index);\\n        \\n        return stoi(ans);\\n    }\\n};\\n```\\n\\n\\n### Variable values for sample input.\\n\\n```\\nn = 182\\nnum = \"182\"\\nviolation_position = 2\\nsmallest_index = 1\\nans = \"179\"\\n```\\n\\n\\n```\\nn = 188882\\nnum = \"188882\"\\nviolation_position = 5\\nsmallest_index = 1\\nans = \"179999\"\\n```\\n\\n<hr>\\n<br>\\n\\n\\n### Complexities\\n\\nTime Complexity = O(1)\\nSpace Complexity = O(1) \\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "``` s[i-1] > s[i] for i in 1...n-1```\n```\\nclass Solution {\\n    \\n    string num;\\n    \\n    int findViolationPosition() {\\n        for(int i=1; i < num.size(); i++) {\\n            // check if previous number greater than next i.e violation\\n            if(num[i-1] > num[i])\\n                return i;\\n        }\\n        return -1;   \\n    }\\n    \\n    int findSmallestIndexToChange(int violation_position) {\\n        int smallest_index = violation_position - 1;\\n        for(; smallest_index >=0; smallest_index--) {\\n            if(num[smallest_index] != num[violation_position-1]) {\\n                break;\\n            }\\n        }\\n        return smallest_index+1;\\n    }\\n    \\n    string removeViolations(int smallest_index) {\\n        string sol = num;\\n        sol[smallest_index]--;\\n        for(int i=smallest_index+1; i<sol.size(); i++) {\\n            sol[i] = \\'9\\';\\n        }\\n        return sol;\\n    }\\n    \\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        \\n        // store the number in string format \\n        num = to_string(n);\\n        \\n        // find the position where violation occurs\\n        int violation_position = findViolationPosition();\\n        \\n        // if no violation then the current number is the answer\\n        if(violation_position == -1) \\n            return n;\\n        \\n        // find the smallest index that must be changed to remove violation.\\n        int smallest_index = findSmallestIndexToChange(violation_position);\\n        \\n        \\n        // decrease the number at the smallest_index and make every number after it as 9\\n        string ans = removeViolations(smallest_index);\\n        \\n        return stoi(ans);\\n    }\\n};\\n```\n```\\nn = 182\\nnum = \"182\"\\nviolation_position = 2\\nsmallest_index = 1\\nans = \"179\"\\n```\n```\\nn = 188882\\nnum = \"188882\"\\nviolation_position = 5\\nsmallest_index = 1\\nans = \"179999\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411476,
                "title": "follow-up-can-t-cast-into-string-array",
                "content": "The simpler solution is to cast the number into a string/array, run the algorithm and cast back.\\n\\nA follow up question is to perform the algorithm without casting.\\n\\nWe still need to iterate and find \"indexes\" in the number where the monotonic property breaks. Whenever we find such location we decrease the current number by -1 and maximize all numbers to the right to 9.\\n\\nTo iterate over the numbers we\\'ll have to divide by `10^k` and take the `%10` of the result to look at the right most number.\\n\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        if n < 10: return n\\n        \\n        output = 0\\n        k = 0\\n        \\n        while n >= 10**k:\\n            if k == 0:\\n                output += n % 10\\n                k += 1\\n                continue\\n                \\n            cur = (n // 10**k) % 10\\n            _next = output // 10**(k-1) % 10\\n            \\n            if cur > _next:\\n                # decrement current by one\\n                output += (cur - 1) * 10**k\\n                \\n\\t\\t\\t\\t# Change all to the right to 9\\n                for j in range(k-1, -1, -1):\\n                    num_in_location = output // 10**j % 10\\n                    output += (9 - num_in_location) * 10**j # complement to 9\\n                \\n            else:\\n                output += cur * 10**k\\n                \\n            k += 1\\n        \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        if n < 10: return n\\n        \\n        output = 0\\n        k = 0\\n        \\n        while n >= 10**k:\\n            if k == 0:\\n                output += n % 10\\n                k += 1\\n                continue\\n                \\n            cur = (n // 10**k) % 10\\n            _next = output // 10**(k-1) % 10\\n            \\n            if cur > _next:\\n                # decrement current by one\\n                output += (cur - 1) * 10**k\\n                \\n\\t\\t\\t\\t# Change all to the right to 9\\n                for j in range(k-1, -1, -1):\\n                    num_in_location = output // 10**j % 10\\n                    output += (9 - num_in_location) * 10**j # complement to 9\\n                \\n            else:\\n                output += cur * 10**k\\n                \\n            k += 1\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404305,
                "title": "python-solution-with-explanation",
                "content": "```\\n135549 --> 134999\\n1. The monotone increasing stop at index = 3 with digit \\'5\\'\\n2. The left most digit of \\'5\\' is at index = 2 \\n3. The left part of the answer is str(int(s[:2+1])-1)\\n4. The remaining part is filled up with \\'9\\' \\n```\\n\\nThe following is the python implementation\\n\\n```\\ndef monotoneIncreasingDigits(self, n: int) -> int:\\n\\tif n<10:\\n\\t\\treturn n\\n\\tn, i = str(n), 0\\n\\twhile(i<len(n)-1 and n[i]<=n[i+1]):\\n\\t\\ti+=1  # find the index breaking monotone changes\\n\\tif i==len(n)-1:\\n\\t\\treturn int(n)  # It means all of digits are monotone increased\\n\\twhile(i>0 and n[i]==n[i-1]):\\n\\t\\ti-=1\\n\\ta = str(int(n[:i+1])-1)+\\'9\\'*(len(n)-i-1)\\n\\treturn int(a)\\n```",
                "solutionTags": [],
                "code": "```\\n135549 --> 134999\\n1. The monotone increasing stop at index = 3 with digit \\'5\\'\\n2. The left most digit of \\'5\\' is at index = 2 \\n3. The left part of the answer is str(int(s[:2+1])-1)\\n4. The remaining part is filled up with \\'9\\' \\n```\n```\\ndef monotoneIncreasingDigits(self, n: int) -> int:\\n\\tif n<10:\\n\\t\\treturn n\\n\\tn, i = str(n), 0\\n\\twhile(i<len(n)-1 and n[i]<=n[i+1]):\\n\\t\\ti+=1  # find the index breaking monotone changes\\n\\tif i==len(n)-1:\\n\\t\\treturn int(n)  # It means all of digits are monotone increased\\n\\twhile(i>0 and n[i]==n[i-1]):\\n\\t\\ti-=1\\n\\ta = str(int(n[:i+1])-1)+\\'9\\'*(len(n)-i-1)\\n\\treturn int(a)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1997579,
                "title": "c-0ms-100-faster-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        int check=0,index=0;\\n        if(n<10)\\n            return n;\\n        string s=to_string(n);\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s[i]>s[i+1])\\n            {index=i;\\n             check=1;\\n             break;\\n        }}\\n            if(check==0)\\n                return n;\\n            s[index]--;\\n        if(index>=1)\\n        {for(int i=index;i>0;i--)\\n{\\n    if(s[i-1]>s[i])\\n    {s[i-1]=s[i];\\n     index=i-1;\\n}}}\\n            for(int i=index+1;i<s.length();i++)\\n                s[i]=\\'9\\';\\n            return stoi(s);\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        int check=0,index=0;\\n        if(n<10)\\n            return n;\\n        string s=to_string(n);\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s[i]>s[i+1])\\n            {index=i;\\n             check=1;\\n             break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1952518,
                "title": "concise-bruteforce-java",
                "content": "We can really just bruteforce it and it\\'d be fast enough given there aren\\'t that many eligible numbers to try anyways.\\n\\n```Java\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        return (int)solve(1, 0, n);\\n    }\\n\\n    private int solve(int st, long cur, int max){\\n        if (cur > max)\\n            return 0;\\n        long ans = cur;\\n        for (int i = st; i <= 9; i++){\\n            ans = Math.max(solve(i, 10 * cur + i, max), ans);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        return (int)solve(1, 0, n);\\n    }\\n\\n    private int solve(int st, long cur, int max){\\n        if (cur > max)\\n            return 0;\\n        long ans = cur;\\n        for (int i = st; i <= 9; i++){\\n            ans = Math.max(solve(i, 10 * cur + i, max), ans);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863297,
                "title": "java-99-faster-code",
                "content": "\\'\\'\\'\\n\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        String str = String.valueOf(n);\\n        int length = str.length();\\n        int[] nums = new int[length];\\n        int idx = length;\\n        int ans = 0;\\n        for (int i = 0; i < length; i++) {\\n            nums[i] = Integer.parseInt(str.substring(i, i + 1));\\n            if (i > 0 && nums[i-1] > nums[i]) {\\n                idx = Math.min(idx, i - 1);\\n                while (idx > 0 && nums[idx - 1] == nums[idx]) {\\n                    idx--;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < length; i++) {\\n            if (i < idx) {\\n                ans = 10 * ans + nums[i];\\n            } else if (i == idx) {\\n                ans = 10 * ans + (nums[i] - 1);\\n            } else {\\n                ans = 10 * ans + 9;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        String str = String.valueOf(n);\\n        int length = str.length();\\n        int[] nums = new int[length];\\n        int idx = length;\\n        int ans = 0;\\n        for (int i = 0; i < length; i++) {\\n            nums[i] = Integer.parseInt(str.substring(i, i + 1));\\n            if (i > 0 && nums[i-1] > nums[i]) {\\n                idx = Math.min(idx, i - 1);\\n                while (idx > 0 && nums[idx - 1] == nums[idx]) {\\n                    idx--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1781617,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        if(n==0)\\n            return n;\\n        \\n        vector<int> mad;\\n        while(n>0)\\n        {\\n            mad.push_back(n%10);\\n            n=n/10;\\n        }\\n        reverse(mad.begin(),mad.end());\\n        for(int i=(mad.size()-2);i>=0;i--)\\n        {\\n            if(mad[i]>mad[i+1])\\n            {\\n                mad[i]--;\\n                for(int j=i+1;j<mad.size();j++)\\n                {\\n                    mad[j]=9;\\n                }\\n            }\\n        }\\n        \\n        long long ans=0;\\n        for(int i=0;i<mad.size();i++)\\n        {\\n            ans=ans*10 + mad[i];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        if(n==0)\\n            return n;\\n        \\n        vector<int> mad;\\n        while(n>0)\\n        {\\n            mad.push_back(n%10);\\n            n=n/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1781148,
                "title": "0ms-beats-100-c-recursive-solution",
                "content": "```\\nint monotoneIncreasingDigits(int n) {\\n        if(n>=0&&n<=9){\\n            return n;\\n        }\\n        string s=to_string(n);\\n        int i=1;\\n        for(i;i<s.size();i++){\\n            if(s[i]<s[i-1]){\\n                break;\\n            }\\n        }\\n        if(i==s.size()){\\n            return n;\\n        }\\n        string temp;\\n        for(int j=i;j<s.size();j++){\\n            temp+=s[j];\\n        }\\n        int x=stoi(temp);\\n        return monotoneIncreasingDigits(n-x-1);\\n    }",
                "solutionTags": [],
                "code": "```\\nint monotoneIncreasingDigits(int n) {\\n        if(n>=0&&n<=9){\\n            return n;\\n        }\\n        string s=to_string(n);\\n        int i=1;\\n        for(i;i<s.size();i++){\\n            if(s[i]<s[i-1]){\\n                break;\\n            }\\n        }\\n        if(i==s.size()){\\n            return n;\\n        }\\n        string temp;\\n        for(int j=i;j<s.size();j++){\\n            temp+=s[j];\\n        }\\n        int x=stoi(temp);\\n        return monotoneIncreasingDigits(n-x-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1695054,
                "title": "java-100-fast-solution",
                "content": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        for(int i = 10;n/i>0;i*=10){\\n            int digit = (n/i)%10;\\n            int endnum = n%i;\\n            int firstendnum = endnum*10/i;\\n            if(digit>firstendnum){\\n                n-=endnum+1;\\n            }\\n        }\\n        return(n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        for(int i = 10;n/i>0;i*=10){\\n            int digit = (n/i)%10;\\n            int endnum = n%i;\\n            int firstendnum = endnum*10/i;\\n            if(digit>firstendnum){\\n                n-=endnum+1;\\n            }\\n        }\\n        return(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586604,
                "title": "python-solution-beats-96-78-of-python-submissions",
                "content": "**Runtime: 24 ms, faster than 96.78% of Python3 online submissions for Monotone Increasing Digits.\\nMemory Usage: 14.2 MB, less than 77.49% of Python3 online submissions for Monotone Increasing Digits.**\\n\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        num=str(n)\\n        leng=len(num)\\n        prev=0\\n        ans=\"\"\\n        for i in range(1,leng+1):\\n            if i==leng:\\n                while prev<leng:\\n                    ans+=str(num[prev])\\n                    prev+=1\\n                return int(ans)\\n            elif num[prev]==num[i]:continue\\n            elif num[prev]<num[i]:\\n                while prev<i:\\n                    ans+=num[prev]\\n                    prev+=1\\n            else:\\n                ans+=str(int(num[prev])-1)\\n                ans+=\\'9\\'*(leng-len(ans))\\n                return int(ans)\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        num=str(n)\\n        leng=len(num)\\n        prev=0\\n        ans=\"\"\\n        for i in range(1,leng+1):\\n            if i==leng:\\n                while prev<leng:\\n                    ans+=str(num[prev])\\n                    prev+=1\\n                return int(ans)\\n            elif num[prev]==num[i]:continue\\n            elif num[prev]<num[i]:\\n                while prev<i:\\n                    ans+=num[prev]\\n                    prev+=1\\n            else:\\n                ans+=str(int(num[prev])-1)\\n                ans+=\\'9\\'*(leng-len(ans))\\n                return int(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580493,
                "title": "weeb-does-python-beats-96-76",
                "content": "![image](https://assets.leetcode.com/users/images/839379a4-3886-4dd8-ac7c-e06b1dc532fa_1637032257.1598141.png)\\n\\n1. The logic is simple, if we find that there is a digit that is greater than the next digit to the right. Then we minus 1 to the current digit and leave the remainding [\"9\"] until the len(result) == len(n), Otherwise, we copy the digit and change nothing to our result. Doing this, we can maintain a monotonic increasing result.\\n\\n2. However, consecutive digits of the same values can be a problem. Rather than coding it so that the current element is decremented by 1, we should actually be decrementing the first consecutive element by 1 instead.\\n\\n3. So, how do you do that? The answer is using a counter. This allows us to subtract the index of the current consectutive element with the counter to get the first occurence of the consecutive element.\\n\\n4. Once we get the first consective element, follow step 1.\\n\\t\\n\\t\\n\\t\\tclass Solution:\\n\\t\\t\\tdef monotoneIncreasingDigits(self, n: int) -> int:\\n\\t\\t\\t\\t# if n is sorted in the first place, the answer is n\\n\\t\\t\\t\\tif int(\"\".join(sorted(str(n)))) == n:\\n\\t\\t\\t\\t\\treturn n\\n\\n\\t\\t\\t\\tresult = [\"9\"] * len(str(n))\\n\\t\\t\\t\\tnums = [int(i) for i in str(n)]\\n\\t\\t\\t\\tcount = -1 # -1 because we are dealing with index\\n\\n\\t\\t\\t\\tfor i in range(len(nums)-1):\\n\\t\\t\\t\\t\\tif nums[i] > nums[i+1]: # step 1\\n\\t\\t\\t\\t\\t\\tresult[i] = str(nums[i] - 1)\\n\\t\\t\\t\\t\\t\\treturn int(\"\".join(result))\\n\\n\\t\\t\\t\\t\\telif nums[i] == nums[i+1]: # check for consecutive elements, step 2 to 3\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\t\\tif i+2 < len(nums) and nums[i+1] > nums[i+2]: \\n\\t\\t\\t\\t\\t\\t\\tresult[i-count] = str(nums[i-count] - 1) # step 4\\n\\t\\t\\t\\t\\t\\t\\t# backtrack to first consecutive element and minus 1, then add the remainding [\"9\"] until len(result) == len(nums)\\n\\t\\t\\t\\t\\t\\t\\treturn int(\"\".join(result[:i-count+1] + [\"9\"] * (len(nums) - i + count - 1)))\\n\\n\\t\\t\\t\\t\\t\\t# if there are consecutive elements of different values, eg. 668841\\n\\t\\t\\t\\t\\t\\t# check whether the i+1th consecutive element is <= to the i+2th element\\n\\t\\t\\t\\t\\t\\telif i+2 < len(nums) and nums[i+1] <= nums[i+2]: \\n\\t\\t\\t\\t\\t\\t\\t# if both statements are true, that means we can maintain monotone increasing digits so we can safely copy the digit and change nothing to our result.\\n\\t\\t\\t\\t\\t\\t\\tresult[i] = str(nums[i])\\n\\n\\t\\t\\t\\t\\telse: # step 1, we copy the digit and change nothing to our result.\\n\\t\\t\\t\\t\\t\\tresult[i] = str(nums[i])\\n\\t\\t\\t\\t\\t\\tcount = -1\\n\\t\\t\\t\\t\\t\\t# reset counter since there could be multiple cosecutive elements\\n\\t\\nAlright, hope this explanation is clear\\nAnyways, its time for some anime recommendations\\nTake a break, watch some anime\\nCheck out **\\u5F92\\u7136\\u30C1\\u30EB\\u30C9\\u30EC\\u30F3 (Tsuredure Children)**\\n\\n# Episodes: 12\\n# Genres: Comedy, Romance\\n# Theme: School\\n# Demographic: Shounen\\n\\nA collection of multiple short stories jumbled up into 12 episodes. Enjoy the anime.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/839379a4-3886-4dd8-ac7c-e06b1dc532fa_1637032257.1598141.png)\\n\\n1. The logic is simple, if we find that there is a digit that is greater than the next digit to the right. Then we minus 1 to the current digit and leave the remainding [\"9\"] until the len(result) == len(n), Otherwise, we copy the digit and change nothing to our result. Doing this, we can maintain a monotonic increasing result.\\n\\n2. However, consecutive digits of the same values can be a problem. Rather than coding it so that the current element is decremented by 1, we should actually be decrementing the first consecutive element by 1 instead.\\n\\n3. So, how do you do that? The answer is using a counter. This allows us to subtract the index of the current consectutive element with the counter to get the first occurence of the consecutive element.\\n\\n4. Once we get the first consective element, follow step 1.\\n\\t\\n\\t\\n\\t\\tclass Solution:\\n\\t\\t\\tdef monotoneIncreasingDigits(self, n: int) -> int:\\n\\t\\t\\t\\t# if n is sorted in the first place, the answer is n\\n\\t\\t\\t\\tif int(\"\".join(sorted(str(n)))) == n:\\n\\t\\t\\t\\t\\treturn n\\n\\n\\t\\t\\t\\tresult = [\"9\"] * len(str(n))\\n\\t\\t\\t\\tnums = [int(i) for i in str(n)]\\n\\t\\t\\t\\tcount = -1 # -1 because we are dealing with index\\n\\n\\t\\t\\t\\tfor i in range(len(nums)-1):\\n\\t\\t\\t\\t\\tif nums[i] > nums[i+1]: # step 1\\n\\t\\t\\t\\t\\t\\tresult[i] = str(nums[i] - 1)\\n\\t\\t\\t\\t\\t\\treturn int(\"\".join(result))\\n\\n\\t\\t\\t\\t\\telif nums[i] == nums[i+1]: # check for consecutive elements, step 2 to 3\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\t\\tif i+2 < len(nums) and nums[i+1] > nums[i+2]: \\n\\t\\t\\t\\t\\t\\t\\tresult[i-count] = str(nums[i-count] - 1) # step 4\\n\\t\\t\\t\\t\\t\\t\\t# backtrack to first consecutive element and minus 1, then add the remainding [\"9\"] until len(result) == len(nums)\\n\\t\\t\\t\\t\\t\\t\\treturn int(\"\".join(result[:i-count+1] + [\"9\"] * (len(nums) - i + count - 1)))\\n\\n\\t\\t\\t\\t\\t\\t# if there are consecutive elements of different values, eg. 668841\\n\\t\\t\\t\\t\\t\\t# check whether the i+1th consecutive element is <= to the i+2th element\\n\\t\\t\\t\\t\\t\\telif i+2 < len(nums) and nums[i+1] <= nums[i+2]: \\n\\t\\t\\t\\t\\t\\t\\t# if both statements are true, that means we can maintain monotone increasing digits so we can safely copy the digit and change nothing to our result.\\n\\t\\t\\t\\t\\t\\t\\tresult[i] = str(nums[i])\\n\\n\\t\\t\\t\\t\\telse: # step 1, we copy the digit and change nothing to our result.\\n\\t\\t\\t\\t\\t\\tresult[i] = str(nums[i])\\n\\t\\t\\t\\t\\t\\tcount = -1\\n\\t\\t\\t\\t\\t\\t# reset counter since there could be multiple cosecutive elements\\n\\t\\nAlright, hope this explanation is clear\\nAnyways, its time for some anime recommendations\\nTake a break, watch some anime\\nCheck out **\\u5F92\\u7136\\u30C1\\u30EB\\u30C9\\u30EC\\u30F3 (Tsuredure Children)**\\n\\n# Episodes: 12\\n# Genres: Comedy, Romance\\n# Theme: School\\n# Demographic: Shounen\\n\\nA collection of multiple short stories jumbled up into 12 episodes. Enjoy the anime.",
                "codeTag": "Java"
            },
            {
                "id": 1405825,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        auto s = to_string(n);\\n        for(int i = s.size() -2 ; i>=0;i--){\\n            if(s[i] > s[i+1]){\\n                // s[i] >= \\'1\\'\\n              s[i] = s[i]-1;\\n              for(int k = i+1; k< s.size(); k++){\\n                     s[k] = \\'9\\'; \\n              }  \\n            }\\n        }\\n        \\n        if(s[0] == \\'0\\'){\\n            s.erase(s.begin());\\n        }\\n        return stoi(s);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        auto s = to_string(n);\\n        for(int i = s.size() -2 ; i>=0;i--){\\n            if(s[i] > s[i+1]){\\n                // s[i] >= \\'1\\'\\n              s[i] = s[i]-1;\\n              for(int k = i+1; k< s.size(); k++){\\n                     s[k] = \\'9\\'; \\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1398816,
                "title": "javascript-greedy-84ms",
                "content": "```\\nconst monotoneIncreasingDigits = (N) => {\\n    let a = (N + \\'\\').split(\"\");\\n    let n = a.length;\\n    let j = n;\\n    for (let i = n - 1; i > 0; i--) {\\n        if (a[i - 1] <= a[i]) continue;\\n        a[i - 1]--;\\n        j = i;\\n    }\\n    for (let i = j; i < n; i++) a[i] = 9;\\n    return a.join(\"\") - \\'0\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst monotoneIncreasingDigits = (N) => {\\n    let a = (N + \\'\\').split(\"\");\\n    let n = a.length;\\n    let j = n;\\n    for (let i = n - 1; i > 0; i--) {\\n        if (a[i - 1] <= a[i]) continue;\\n        a[i - 1]--;\\n        j = i;\\n    }\\n    for (let i = j; i < n; i++) a[i] = 9;\\n    return a.join(\"\") - \\'0\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395346,
                "title": "c-simple-easy-understanding-0-ms-beats-100",
                "content": "The basic steps used to solve this question are the following:\\n\\n1.) Converting n to its string representation.\\n2.) Checking for monotonicity.\\n3.) Convert the digits to 0 which make our number non-monotonic.\\n4.) Calling the function again to work with the modified number.\\n\\nI have taken an example given in the commented code to provide a better understanding of the code as it runs. Recursion is the key step used to solve the question.\\n\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n\\t\\t\\t//Let n=1872\\n\\t\\t\\tstring p=\"\";\\n            int copy=n,rem=0;\\n\\t\\t\\t//extracting the digits and storing in string\\n            while(copy>0)\\n            {\\n                rem=copy%10;\\n                p.push_back(\\'0\\'+rem);\\n                copy/=10;\\n            }\\n\\t\\t\\t//p=\"2781\" is obtained after while loop\\n\\t\\t\\t\\n\\t\\t\\t//reverse is required to get the same order of digits\\n            reverse(p.begin(),p.end());\\n\\t\\t\\t//p=\"1872\" after reversing\\n\\t\\t\\t\\n            int flag=0;\\n            int i;//denotes the position upto which our number is monotonic\\n\\t\\t\\t//checking whether monotonic or not\\n            for(i=0;i<p.size()-1;i++)\\n            {\\n                if(p[i]<=p[i+1])\\n                    continue;\\n                else\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)//if monotonic return n\\n            {\\n                return n;\\n            }\\n            i++;\\n            for(;i<p.size();i++)\\n            {\\n                p[i]=\\'0\\';//converting the digits from ith index to 0 as the next smaller number has the most chances to be monotonic\\n            }\\n            //p=\"1800\"\\n\\t\\t\\n            int val=0;\\n            for(auto it:p)\\n                val=val*10+(it-\\'0\\');//converting the string back to its numeric value\\n\\t\\t\\t//val=1800 after for loop\\n\\t\\t\\tval--; // val=1799 \\n\\t\\t\\n\\t\\t\\t//recursion done to evaluate 1799\\n\\t\\t\\treturn monotoneIncreasingDigits(val);\\n\\t\\t}\\n}\\n```\\n\\n**If you found the solution helpful, do consider Upvoting :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n\\t\\t\\t//Let n=1872\\n\\t\\t\\tstring p=\"\";\\n            int copy=n,rem=0;\\n\\t\\t\\t//extracting the digits and storing in string\\n            while(copy>0)\\n            {\\n                rem=copy%10;\\n                p.push_back(\\'0\\'+rem);\\n                copy/=10;\\n            }\\n\\t\\t\\t//p=\"2781\" is obtained after while loop\\n\\t\\t\\t\\n\\t\\t\\t//reverse is required to get the same order of digits\\n            reverse(p.begin(),p.end());\\n\\t\\t\\t//p=\"1872\" after reversing\\n\\t\\t\\t\\n            int flag=0;\\n            int i;//denotes the position upto which our number is monotonic\\n\\t\\t\\t//checking whether monotonic or not\\n            for(i=0;i<p.size()-1;i++)\\n            {\\n                if(p[i]<=p[i+1])\\n                    continue;\\n                else\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)//if monotonic return n\\n            {\\n                return n;\\n            }\\n            i++;\\n            for(;i<p.size();i++)\\n            {\\n                p[i]=\\'0\\';//converting the digits from ith index to 0 as the next smaller number has the most chances to be monotonic\\n            }\\n            //p=\"1800\"\\n\\t\\t\\n            int val=0;\\n            for(auto it:p)\\n                val=val*10+(it-\\'0\\');//converting the string back to its numeric value\\n\\t\\t\\t//val=1800 after for loop\\n\\t\\t\\tval--; // val=1799 \\n\\t\\t\\n\\t\\t\\t//recursion done to evaluate 1799\\n\\t\\t\\treturn monotoneIncreasingDigits(val);\\n\\t\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317879,
                "title": "ugly-but-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        # yx,,, y<=x monotone increasing\\n        manipulate = list(int(i) for i in str(n))\\n        i=0\\n        while i < len(manipulate)-1:\\n            if manipulate[i] <= manipulate[i+1]:\\n                i += 1\\n            elif manipulate[i] > manipulate[i+1]:\\n                while i-1>=0 and manipulate[i-1] == manipulate[i]:\\n                    i-=1\\n                manipulate[i] -= 1\\n                while i < len(manipulate)-1:\\n                    i += 1\\n                    manipulate[i] = 9\\n        return int(\\'\\'.join([str(i) for i in manipulate]))\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        # yx,,, y<=x monotone increasing\\n        manipulate = list(int(i) for i in str(n))\\n        i=0\\n        while i < len(manipulate)-1:\\n            if manipulate[i] <= manipulate[i+1]:\\n                i += 1\\n            elif manipulate[i] > manipulate[i+1]:\\n                while i-1>=0 and manipulate[i-1] == manipulate[i]:\\n                    i-=1\\n                manipulate[i] -= 1\\n                while i < len(manipulate)-1:\\n                    i += 1\\n                    manipulate[i] = 9\\n        return int(\\'\\'.join([str(i) for i in manipulate]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219552,
                "title": "simple-and-crisp-c-solution",
                "content": "First find the index of the element which is not monotonically increasing.\\nSubtract 1 fom that number and change all the numbers after that to 9.\\nWe also need to check that the index we found must not be repeating.\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s=to_string(n);\\n        bool f=true;\\n        int ind;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i]<s[i-1])\\n            {\\n                ind=i-1;\\n                while(ind>0 && s[ind-1]==s[i-1])\\n                {\\n                    ind--;\\n                }\\n                f=false;\\n                break;\\n            }\\n        }\\n        if(f)\\n        {\\n            return n;\\n        }\\n        s[ind]--;\\n        for(int i=ind+1;i<s.size();i++)\\n        {\\n            s[i]=\\'9\\';\\n        }\\n        return stoi(s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s=to_string(n);\\n        bool f=true;\\n        int ind;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i]<s[i-1])\\n            {\\n                ind=i-1;\\n                while(ind>0 && s[ind-1]==s[i-1])\\n                {\\n                    ind--;\\n                }\\n                f=false;\\n                break;\\n            }\\n        }\\n        if(f)\\n        {\\n            return n;\\n        }\\n        s[ind]--;\\n        for(int i=ind+1;i<s.size();i++)\\n        {\\n            s[i]=\\'9\\';\\n        }\\n        return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101777,
                "title": "python3-digit-by-digit-with-stacks",
                "content": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, N: int) -> int:\\n        # Go through examples by hand to find the pattern going digit by digit;\\n        # starting from ones digit, take the existing value. Move over to the\\n        # tens digit: if the value there is strictly larger, then update ones\\n        # digit to 9, and decrement tens digit by one. Repeat this process\\n        # through all digits to find largest monotonically increasing value <= N\\n\\n        # Implement with stacks: pop off digit from nums stack, process and\\n        # place onto minc stack. If new digit is larger than top of minc stack,\\n        # update all minc stack values to 9. Flip minc stack at end since\\n        # reversed.\\n\\n        # O(logN ^ 2) time and space\\n\\n        nums = [int(i) for i in str(N)]\\n        minc = []\\n\\n        while nums:\\n            dgt = nums.pop()\\n            if minc and dgt > minc[-1]:\\n                for i in range(len(minc)):\\n                    minc[i] = 9\\n                dgt -= 1\\n            minc.append(dgt)\\n        return int(\"\".join((str(i) for i in reversed(minc))))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, N: int) -> int:\\n        # Go through examples by hand to find the pattern going digit by digit;\\n        # starting from ones digit, take the existing value. Move over to the\\n        # tens digit: if the value there is strictly larger, then update ones\\n        # digit to 9, and decrement tens digit by one. Repeat this process\\n        # through all digits to find largest monotonically increasing value <= N\\n\\n        # Implement with stacks: pop off digit from nums stack, process and\\n        # place onto minc stack. If new digit is larger than top of minc stack,\\n        # update all minc stack values to 9. Flip minc stack at end since\\n        # reversed.\\n\\n        # O(logN ^ 2) time and space\\n\\n        nums = [int(i) for i in str(N)]\\n        minc = []\\n\\n        while nums:\\n            dgt = nums.pop()\\n            if minc and dgt > minc[-1]:\\n                for i in range(len(minc)):\\n                    minc[i] = 9\\n                dgt -= 1\\n            minc.append(dgt)\\n        return int(\"\".join((str(i) for i in reversed(minc))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020939,
                "title": "c-0ms-faster-than-100-100-calculation-based-no-string-is-used",
                "content": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        int ans;\\n        for(int x=N;x>=0;)\\n        {\\n            bool f=false;\\n            int n=x;\\n            long long b=10;\\n            while(n>0)\\n            {\\n                int x=(n%100)/10;\\n                int y=n%10;\\n                if(x<=y)\\n                {\\n                    f=true;\\n                }\\n                else\\n                {\\n                    f=false;\\n                    break;\\n                }\\n                n=n/10;\\n                b=b*10;\\n            }\\n            if(f==true)\\n            {\\n                ans=x;\\n                break;\\n            }\\n            x=x-(x%b);\\n            x--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        int ans;\\n        for(int x=N;x>=0;)\\n        {\\n            bool f=false;\\n            int n=x;\\n            long long b=10;\\n            while(n>0)\\n            {\\n                int x=(n%100)/10;\\n                int y=n%10;\\n                if(x<=y)\\n                {\\n                    f=true;\\n                }\\n                else\\n                {\\n                    f=false;\\n                    break;\\n                }\\n                n=n/10;\\n                b=b*10;\\n            }\\n            if(f==true)\\n            {\\n                ans=x;\\n                break;\\n            }\\n            x=x-(x%b);\\n            x--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921119,
                "title": "python3-o-n-via-stack",
                "content": "Algo\\nThe key is to find the first place where a digit is smaller than its neighbor before. Upon finding such place, decrement its previous neighbor and possibly recursively decrease its neighbor until non-decreasing order is retained. Padding 9 after such change results in the correct answer. \\n\\nImplementation \\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, N: int) -> int:\\n        nums = [int(x) for x in str(N)] # digits \\n        stack = []\\n        for i, x in enumerate(nums): \\n            while stack and stack[-1] > x: x = stack.pop() - 1\\n            stack.append(x) \\n            if len(stack) <= i: break \\n        return int(\"\".join(map(str, stack)).ljust(len(nums), \"9\")) # right padding with \"9\"\\n```\\n\\nAnalysis\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, N: int) -> int:\\n        nums = [int(x) for x in str(N)] # digits \\n        stack = []\\n        for i, x in enumerate(nums): \\n            while stack and stack[-1] > x: x = stack.pop() - 1\\n            stack.append(x) \\n            if len(stack) <= i: break \\n        return int(\"\".join(map(str, stack)).ljust(len(nums), \"9\")) # right padding with \"9\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892253,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, N: int) -> int:\\n        N_vec = [int(d) for d in str(N)]\\n        nlen = len(N_vec)\\n        idx = nlen\\n        for i in range(1, nlen)[::-1]:\\n            if N_vec[i]<N_vec[i-1]:\\n                N_vec[i-1] -= 1\\n                idx = i\\n        for i in range(idx, nlen):\\n            N_vec[i] = 9\\n        \\n        return int(\"\".join(str(d) for d in N_vec))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, N: int) -> int:\\n        N_vec = [int(d) for d in str(N)]\\n        nlen = len(N_vec)\\n        idx = nlen\\n        for i in range(1, nlen)[::-1]:\\n            if N_vec[i]<N_vec[i-1]:\\n                N_vec[i-1] -= 1\\n                idx = i\\n        for i in range(idx, nlen):\\n            N_vec[i] = 9\\n        \\n        return int(\"\".join(str(d) for d in N_vec))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759120,
                "title": "c-0ms-code",
                "content": "**Status**: Accepted (0ms Code)\\n**Idea:** \\n* Find the index which distrubs the vector being monotonic.\\n* Find the find occurence of that element and reduce it by 1. Change all the number to the right by 9.\\n\\n**Complexity Analysis:**\\n* Time: O(N) (Two pass)\\n* Space: O(1)\\n```\\nint monotoneIncreasingDigits(int N) {\\n        int index = -1;\\n        string s = to_string(N);\\n        bool sorted = true;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s[i - 1] > s[i]){\\n                sorted = false;\\n                index = i - 1;\\n                break;\\n            }\\n        }\\n        if(sorted) return N;\\n        index = s.find(s[index]);\\n        s[index] = ((s[index] - \\'0\\') - 1) + \\'0\\';\\n        for(int i = index + 1; i < s.length(); i++){\\n            s[i] = \\'9\\';\\n        }\\n        while(s.front() == \\'0\\') s = s.substr(1);\\n        return stoi(s);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint monotoneIncreasingDigits(int N) {\\n        int index = -1;\\n        string s = to_string(N);\\n        bool sorted = true;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s[i - 1] > s[i]){\\n                sorted = false;\\n                index = i - 1;\\n                break;\\n            }\\n        }\\n        if(sorted) return N;\\n        index = s.find(s[index]);\\n        s[index] = ((s[index] - \\'0\\') - 1) + \\'0\\';\\n        for(int i = index + 1; i < s.length(); i++){\\n            s[i] = \\'9\\';\\n        }\\n        while(s.front() == \\'0\\') s = s.substr(1);\\n        return stoi(s);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732115,
                "title": "java-using-array",
                "content": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int N) {\\n        int len = String.valueOf(N).length();\\n        int[] digits = new int[len];\\n        for(int i=len-1; i>=0; i--) {\\n            digits[i] = N % 10;\\n            N = N/10;\\n        }\\n        int k = len;\\n        for(int i=len-2; i>=0; i--) {\\n            if(digits[i] > digits[i+1]) {\\n                k = i+1;\\n                digits[i]--;\\n            }\\n        }\\n        while(k<len) {\\n            digits[k] = 9;\\n            k++;\\n        }\\n        int res = 0;\\n        for(int i=0; i<len; i++) {\\n            res = res*10 + digits[i];\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int N) {\\n        int len = String.valueOf(N).length();\\n        int[] digits = new int[len];\\n        for(int i=len-1; i>=0; i--) {\\n            digits[i] = N % 10;\\n            N = N/10;\\n        }\\n        int k = len;\\n        for(int i=len-2; i>=0; i--) {\\n            if(digits[i] > digits[i+1]) {\\n                k = i+1;\\n                digits[i]--;\\n            }\\n        }\\n        while(k<len) {\\n            digits[k] = 9;\\n            k++;\\n        }\\n        int res = 0;\\n        for(int i=0; i<len; i++) {\\n            res = res*10 + digits[i];\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724421,
                "title": "java-solution-with-string-manipulation",
                "content": "Process the number from right to left, if any digit is greater than next digit then reduce (one, -1) the value of that digit, and track the position, after processing entire number, now convert all right side digits to \\'9\\'.\\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        return greedy1(n);\\n    }\\n    \\n    public int greedy1(int n) {\\n        Integer it = new Integer(n);\\n        StringBuilder sb = new StringBuilder(it.toString());\\n        int len = sb.length();\\n        boolean first = true;\\n        int k = len;\\n        for(int j=len-1;j>0;j--)\\n        {\\n            int i = j-1;\\n            if(sb.charAt(i) > sb.charAt(j))\\n            {\\n                //Track position which cause to reduce cliff.\\n                k = j;\\n                int ch = sb.charAt(i);\\n                ch--;\\n                char ch1 = (char)ch;\\n                sb.setCharAt(i,ch1);\\n                \\n            }\\n        }\\n        for(;k<len;k++)\\n        {\\n            sb.setCharAt(k,\\'9\\');\\n        }\\n        it = new Integer(sb.toString());\\n        return it;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        return greedy1(n);\\n    }\\n    \\n    public int greedy1(int n) {\\n        Integer it = new Integer(n);\\n        StringBuilder sb = new StringBuilder(it.toString());\\n        int len = sb.length();\\n        boolean first = true;\\n        int k = len;\\n        for(int j=len-1;j>0;j--)\\n        {\\n            int i = j-1;\\n            if(sb.charAt(i) > sb.charAt(j))\\n            {\\n                //Track position which cause to reduce cliff.\\n                k = j;\\n                int ch = sb.charAt(i);\\n                ch--;\\n                char ch1 = (char)ch;\\n                sb.setCharAt(i,ch1);\\n                \\n            }\\n        }\\n        for(;k<len;k++)\\n        {\\n            sb.setCharAt(k,\\'9\\');\\n        }\\n        it = new Integer(sb.toString());\\n        return it;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698413,
                "title": "c-easy-to-understand-faster-than-100",
                "content": "12966->12866->12899\\n12644->12544->12599\\nStep 1:Find the first position where digit[i-1]>digit[i](The first posn where monotonic increasing seq fails)\\nStep 2:Decrease that digit by 1. Move a digit backward ie. i changed to i-1\\nStep 3: If digit[i-1]<=digit[i]. Change all digits from posn i+1 till end to 9\\nElse repeat from step 1.\\n\\nclass Solution {\\npublic:\\n\\n    int monotoneIncreasingDigits(int N) {\\n     string num=to_string(N);\\n     int pos=1;\\n     while(pos<num.length()&&num[pos]>=num[pos-1]) pos++;\\n     if(pos==num.length()) return N;\\n     //Here pos= position where num[pos-1]>num[pos]\\n     while(pos-1>=0&&num[pos-1]>num[pos])\\n     {\\n         num[pos-1]--;\\n         pos--;\\n     }\\n     //Change all digits from pos+1 to 9\\n     for(int i=pos+1;i<num.length();i++) num[i]=\\'9\\';\\n     return stoi(num);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int monotoneIncreasingDigits(int N) {\\n     string num=to_string(N);\\n     int pos=1;\\n     while(pos<num.length()&&num[pos]>=num[pos-1]) pos++;\\n     if(pos==num.length()) return N;\\n     //Here pos= position where num[pos-1]>num[pos]\\n     while(pos-1>=0&&num[pos-1]>num[pos])\\n     {\\n         num[pos-1]--;\\n         pos--;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 678281,
                "title": "c-backtracking-solution-not-optimal-but-work-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void dfs(int N, int base, int prev, int num, int cnt) {\\n        if (cnt == 0) {\\n            if (num <= N && ans < num) ans = num;\\n            return;\\n        }\\n        for (int i = 0; i <= prev; i++) \\n            if (num <= (INT_MAX - base * i) && num + i*base <= N ) \\n                dfs(N, base * 10, i, num + i*base, cnt-1);\\n    }\\n    int monotoneIncreasingDigits(int N) {\\n        ans = 0;\\n        dfs(N, 1, 9, 0, to_string(N).size());\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans;\\n    void dfs(int N, int base, int prev, int num, int cnt) {\\n        if (cnt == 0) {\\n            if (num <= N && ans < num) ans = num;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 678280,
                "title": "short-simple-and-intuitive-c-solution-faster-than-100",
                "content": "The idea is to make the digits from right 0 and subtract 1 from it at each step. After every such step we check if it satisfies the condition, we return that number, if not we repeat making the next digit from right 0 and subtracting 1.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool chk(int n){\\n        string s = to_string(n);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]<s[i-1]) return 0;\\n        }\\n        return 1;\\n    }\\n    \\n    int monotoneIncreasingDigits(int N) {\\n        int c=10;\\n        while(!chk(N)){\\n            N/=c;\\n            N*=c;\\n            N--;\\n            c*=10;\\n        }\\n        return N;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool chk(int n){\\n        string s = to_string(n);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]<s[i-1]) return 0;\\n        }\\n        return 1;\\n    }\\n    \\n    int monotoneIncreasingDigits(int N) {\\n        int c=10;\\n        while(!chk(N)){\\n            N/=c;\\n            N*=c;\\n            N--;\\n            c*=10;\\n        }\\n        return N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631968,
                "title": "c-o-n-greedy-solution-using-stack",
                "content": "```\\npublic class Solution {\\n    public int MonotoneIncreasingDigits(int N) {\\n        Stack<int> stack = new Stack<int>();\\n        while (N > 0) {\\n            int digit = N % 10;\\n            N /= 10;\\n            if (stack.Count == 0 || stack.Peek() >= digit) {\\n                stack.Push(digit);\\n            }\\n            else {\\n                int count = stack.Count;\\n                stack.Clear();   \\n                if (count > 0) {\\n                    while (count > 0) {\\n                        stack.Push(9);\\n                        count--;                    \\n                    }\\n                    stack.Push(digit-1);\\n                }\\n            }\\n        }\\n        var arr = stack.ToArray();\\n        Array.Reverse(arr);\\n        int p = 1;\\n        int result = 0;\\n        foreach (int i in arr) {\\n            result += i*p;\\n            p *= 10;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MonotoneIncreasingDigits(int N) {\\n        Stack<int> stack = new Stack<int>();\\n        while (N > 0) {\\n            int digit = N % 10;\\n            N /= 10;\\n            if (stack.Count == 0 || stack.Peek() >= digit) {\\n                stack.Push(digit);\\n            }\\n            else {\\n                int count = stack.Count;\\n                stack.Clear();   \\n                if (count > 0) {\\n                    while (count > 0) {\\n                        stack.Push(9);\\n                        count--;                    \\n                    }\\n                    stack.Push(digit-1);\\n                }\\n            }\\n        }\\n        var arr = stack.ToArray();\\n        Array.Reverse(arr);\\n        int p = 1;\\n        int result = 0;\\n        foreach (int i in arr) {\\n            result += i*p;\\n            p *= 10;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629781,
                "title": "java-explained-greedy-solution",
                "content": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int N) {\\n        if (N < 10) {\\n            return N;\\n        }\\n        String str = String.valueOf(N);\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        \\n        for (; counter < str.length() - 1; counter++) {\\n            //put all continuous non-decreasing digits in its original order\\n            if (str.charAt(counter) <= str.charAt(counter + 1)) {\\n                sb.append(str.charAt(counter));\\n            } else{\\n                break;\\n            }\\n        }\\n        \\n        if (counter == str.length() - 1) {\\n            //if all digits is in non-decreasing order\\n            sb.append(str.charAt(counter));\\n        } else {\\n            //there is decreasing......\\n            //999998 -> 899999, replace all equal digits before decreasing\\n            while (sb.length() >= 1 && str.charAt(counter) == sb.charAt(sb.length() - 1)) {\\n                sb.deleteCharAt(sb.length() - 1);\\n                --counter;\\n            } \\n            \\n            //as long as we find a decreasing such as 532, we can replace 5 with 4 and set all digits after it to be 9\\n            //no need to worry about 1 -> 0, we can handle it later easily since it will be the start of stringbuilder\\n            sb.append(str.charAt(counter) - \\'1\\');\\n            ++counter;                \\n        \\n            while (counter < str.length()) {\\n                sb.append(\\'9\\');\\n                ++counter;\\n            }\\n        }\\n        \\n        //for corner case like \"10\" -> \"09\" -> \"9\",\"100\" -> \"099\" -> \"99\",....\\n        if (sb.charAt(0) == \\'0\\') {\\n            sb.deleteCharAt(0);\\n        }\\n        \\n        String res = sb.toString();\\n        return Integer.valueOf(res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int N) {\\n        if (N < 10) {\\n            return N;\\n        }\\n        String str = String.valueOf(N);\\n        StringBuilder sb = new StringBuilder();\\n        int counter = 0;\\n        \\n        for (; counter < str.length() - 1; counter++) {\\n            //put all continuous non-decreasing digits in its original order\\n            if (str.charAt(counter) <= str.charAt(counter + 1)) {\\n                sb.append(str.charAt(counter));\\n            } else{\\n                break;\\n            }\\n        }\\n        \\n        if (counter == str.length() - 1) {\\n            //if all digits is in non-decreasing order\\n            sb.append(str.charAt(counter));\\n        } else {\\n            //there is decreasing......\\n            //999998 -> 899999, replace all equal digits before decreasing\\n            while (sb.length() >= 1 && str.charAt(counter) == sb.charAt(sb.length() - 1)) {\\n                sb.deleteCharAt(sb.length() - 1);\\n                --counter;\\n            } \\n            \\n            //as long as we find a decreasing such as 532, we can replace 5 with 4 and set all digits after it to be 9\\n            //no need to worry about 1 -> 0, we can handle it later easily since it will be the start of stringbuilder\\n            sb.append(str.charAt(counter) - \\'1\\');\\n            ++counter;                \\n        \\n            while (counter < str.length()) {\\n                sb.append(\\'9\\');\\n                ++counter;\\n            }\\n        }\\n        \\n        //for corner case like \"10\" -> \"09\" -> \"9\",\"100\" -> \"099\" -> \"99\",....\\n        if (sb.charAt(0) == \\'0\\') {\\n            sb.deleteCharAt(0);\\n        }\\n        \\n        String res = sb.toString();\\n        return Integer.valueOf(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514855,
                "title": "java-solution-that-beats-91-99-of-java-online-submissions-in-o-n-2-in-worst-case",
                "content": "class Solution {\\n    int n_num=0;\\n    public int monotoneIncreasingDigits(int N) {\\n        int num=N; int rem=0; boolean flag=true; \\n\\t\\t***//case 1***\\n        while(num!=1){\\n            rem=num%10;\\n            if(rem!=0){flag=false; break;}\\n            num=num/10;\\n        }\\n        if(num==1&&flag==true){return N-1;}\\n\\t\\t***//case 2***\\n        int old_rem=-1;\\n        num=N; flag=true;\\n        while(num!=0){\\n            rem=num%10;\\n            if(old_rem!=-1&&rem>old_rem){\\n                flag=false; break;\\n            }\\n            old_rem=rem;\\n            num=num/10;\\n        }\\n        if(flag==true){return N;}\\n\\t\\t***//case 3***\\n        int count=0; num=N;rem=0;\\n        while(num!=0){\\n            rem=num%10;\\n            count+=1;\\n            num=num/10;\\n        }\\n        int arr[]=new int[count];\\n        Arrays.fill(arr,0);\\n        num=N; rem=0;\\n        int id=arr.length-1;\\n        while(num!=0){\\n            rem=num%10;\\n            arr[id]=rem;\\n            id--;\\n            num=num/10;\\n        }\\n        id=arr.length-1;\\n        while(true){\\n            int j=arr[id];  flag=false;\\n            for( j=arr[id];j>=0;j--){\\n                arr[id]=j;\\n                if(sorted(arr,N)==true){\\n                    flag=true; break;\\n                }\\n            }\\n            if(flag==false&&j<=0){\\n                arr[id]=9;\\n            }\\n            if(flag==true){\\n                break;\\n            }\\n            id=id-1;\\n        }\\n        if(flag==true){return n_num;}\\n        return 0;\\n   }\\n    public boolean sorted(int []arr ,int N){\\n        n_num=0;\\n        for(int i=0;i<=arr.length-2;i++){\\n            if(arr[i]>arr[i+1]){\\n                return false;\\n            }\\n        }\\n        for(int val:arr){\\n            n_num=n_num*10+val;\\n        }\\n        if(n_num>N){return false;}\\n        return true;\\n    }\\n}\\n\\n***///DESCRIPTION\\n// case 1- for numbers like 100, 1000, 10000, etc\\n//case 2 for already increasing numbers eg 1234\\n// case 3 for numbers like 4321, 332, etc***\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    int n_num=0;\\n    public int monotoneIncreasingDigits(int N) {\\n        int num=N; int rem=0; boolean flag=true; \\n\\t\\t***//case 1***\\n        while(num!=1){\\n            rem=num%10;\\n            if(rem!=0){flag=false; break;}",
                "codeTag": "Java"
            },
            {
                "id": 479687,
                "title": "c-100-time-100-space-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        string str=to_string(N);\\n        int i;\\n        for(i=0; i<str.size()-1; i++)\\n            if(str[i]>str[i+1])\\n                break;\\n        if(i==str.size()-1)\\n            return N;\\n        while(i>0 && str[i-1]>str[i]-1)\\n            i--;\\n        int num=0, j=0;\\n        while(j<str.size()){\\n            if(j==i)\\n                num=(num*10)+((str[j]-\\'0\\')-1);\\n            else if(j>i)\\n                num=(num*10)+9;\\n            else\\n                num=(num*10)+(str[j]-\\'0\\');\\n            j++;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        string str=to_string(N);\\n        int i;\\n        for(i=0; i<str.size()-1; i++)\\n            if(str[i]>str[i+1])\\n                break;\\n        if(i==str.size()-1)\\n            return N;\\n        while(i>0 && str[i-1]>str[i]-1)\\n            i--;\\n        int num=0, j=0;\\n        while(j<str.size()){\\n            if(j==i)\\n                num=(num*10)+((str[j]-\\'0\\')-1);\\n            else if(j>i)\\n                num=(num*10)+9;\\n            else\\n                num=(num*10)+(str[j]-\\'0\\');\\n            j++;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447558,
                "title": "c-faster-than-100-o-n-recursive-solution",
                "content": "The main observation is that assuming an Integer ```N``` has digits ```a_0a_1...a_n```, the desired monotonous increasing digits (MID) can be found from getting the solution for ```a_1...a_n``` and comparing its most significant digit with ```a_0```.\\n\\n```\\n#include <vector>\\n#include <cmath>\\n\\n\\nvoid int_to_digits(int N, std::vector<int> & digits)\\n{\\n  while(N>=10)\\n  {\\n    digits.push_back(N%10);\\n    N/=10;\\n  }\\n  digits.push_back(N);\\n\\n}\\n\\nint largest_smaller_MID(const std::vector<int> & N)\\n{\\n  //assuming that the most significan digit of N is at the end of the vector\\n  int s=N.size();\\n\\n  if(s==1)\\n  {\\n    return N[0];\\n  }\\n\\n  if(N[s-1]>N[s-2])\\n  {\\n    return (N[s-1]*pow(10,s-1))-1;\\n  }\\n  else\\n  {\\n    std::vector<int> q(N.begin(),N.end()-1);\\n    int u=largest_smaller_MID(q);\\n    if(u<N[s-1]*pow(10,s-2))\\n    {\\n      return N[s-1]*(pow(10,s-1))-1;\\n    }\\n    else\\n    {\\n      return u+pow(10,s-1)*N[s-1];\\n    }\\n\\n  }\\n  return -1;\\n}\\n\\nclass Solution\\n{\\n  public:\\n    int monotoneIncreasingDigits(int N) \\n    {\\n      std::vector<int> digits;\\n      int_to_digits(N,digits);\\n      int res=largest_smaller_MID(digits);\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```N```\n```a_0a_1...a_n```\n```a_1...a_n```\n```a_0```\n```\\n#include <vector>\\n#include <cmath>\\n\\n\\nvoid int_to_digits(int N, std::vector<int> & digits)\\n{\\n  while(N>=10)\\n  {\\n    digits.push_back(N%10);\\n    N/=10;\\n  }\\n  digits.push_back(N);\\n\\n}\\n\\nint largest_smaller_MID(const std::vector<int> & N)\\n{\\n  //assuming that the most significan digit of N is at the end of the vector\\n  int s=N.size();\\n\\n  if(s==1)\\n  {\\n    return N[0];\\n  }\\n\\n  if(N[s-1]>N[s-2])\\n  {\\n    return (N[s-1]*pow(10,s-1))-1;\\n  }\\n  else\\n  {\\n    std::vector<int> q(N.begin(),N.end()-1);\\n    int u=largest_smaller_MID(q);\\n    if(u<N[s-1]*pow(10,s-2))\\n    {\\n      return N[s-1]*(pow(10,s-1))-1;\\n    }\\n    else\\n    {\\n      return u+pow(10,s-1)*N[s-1];\\n    }\\n\\n  }\\n  return -1;\\n}\\n\\nclass Solution\\n{\\n  public:\\n    int monotoneIncreasingDigits(int N) \\n    {\\n      std::vector<int> digits;\\n      int_to_digits(N,digits);\\n      int res=largest_smaller_MID(digits);\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 379013,
                "title": "go-100",
                "content": "use twolevel iterative algorithm\\uFF1A\\n1: use []int to record the digits of N, the high digits in the right\\n2: traverse the array and set 0th to ith elements to \\'9\\' if i<i+1 and digits[i] < digits[i+1], maybe one elements are set to \\'9\\' several times,this is a point need to be optimized\\n\\n```\\nfunc monotoneIncreasingDigits(N int) int {\\n\\tvar digits []int\\n\\tfor N > 0 {\\n\\t\\tdigits = append(digits, N%10)\\n\\t\\tN = N / 10\\n\\t}\\n\\ti := 0\\n\\tfor i < len(digits)-1 {\\n\\t\\tif digits[i] < digits[i+1] {\\n\\t\\t\\tfor j := 0; j <= i; j++ {\\n\\t\\t\\t\\tdigits[j] = 9\\n\\t\\t\\t}\\n\\t\\t\\tdigits[i+1]--\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\n\\tret := 0\\n\\tfor i := len(digits) - 1; i >= 0; i-- {\\n\\t\\tret = ret*10 + digits[i]\\n\\t}\\n\\treturn ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc monotoneIncreasingDigits(N int) int {\\n\\tvar digits []int\\n\\tfor N > 0 {\\n\\t\\tdigits = append(digits, N%10)\\n\\t\\tN = N / 10\\n\\t}\\n\\ti := 0\\n\\tfor i < len(digits)-1 {\\n\\t\\tif digits[i] < digits[i+1] {\\n\\t\\t\\tfor j := 0; j <= i; j++ {\\n\\t\\t\\t\\tdigits[j] = 9\\n\\t\\t\\t}\\n\\t\\t\\tdigits[i+1]--\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\n\\tret := 0\\n\\tfor i := len(digits) - 1; i >= 0; i-- {\\n\\t\\tret = ret*10 + digits[i]\\n\\t}\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362053,
                "title": "solution-in-python-3-beats-95",
                "content": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n    \\tN = [int(i) for i in str(n)]\\n    \\tL = len(N)\\n    \\tfor I in range(L-1):\\n    \\t\\tif N[I] > N[I+1]: break\\n    \\tif N[I] <= N[I+1]: return n\\n    \\tN[I+1:], N[I] = [9]*(L-I-1), N[I] - 1\\n    \\tfor i in range(I,0,-1):\\n    \\t\\tif N[i] >= N[i-1]: break\\n    \\t\\tN[i], N[i-1] = 9, N[i-1] - 1\\n    \\treturn sum([N[i]*10**(L-i-1) for i in range(L)])\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n    \\tN = [int(i) for i in str(n)]\\n    \\tL = len(N)\\n    \\tfor I in range(L-1):\\n    \\t\\tif N[I] > N[I+1]: break\\n    \\tif N[I] <= N[I+1]: return n\\n    \\tN[I+1:], N[I] = [9]*(L-I-1), N[I] - 1\\n    \\tfor i in range(I,0,-1):\\n    \\t\\tif N[i] >= N[i-1]: break\\n    \\t\\tN[i], N[i-1] = 9, N[i-1] - 1\\n    \\treturn sum([N[i]*10**(L-i-1) for i in range(L)])\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 272293,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    public int MonotoneIncreasingDigits(int N) {\\n      var list = new List<int>();\\n\\n      while (N > 0)\\n      {\\n        list.Add(N % 10);\\n        N /= 10;\\n      }\\n\\n      for (int i = 0; i < list.Count - 1; i++)\\n      {\\n        if (list[i + 1] > list[i])\\n        {\\n          for (int j = i; j >= 0 && list[j] != 9; j--)\\n            list[j] = 9;\\n\\n          list[i + 1]--;\\n        }\\n\\n      }\\n\\n      var num = 0;\\n      for (int i = list.Count - 1; i >= 0; i--)\\n        num = num * 10 + list[i];\\n\\n      return num;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MonotoneIncreasingDigits(int N) {\\n      var list = new List<int>();\\n\\n      while (N > 0)\\n      {\\n        list.Add(N % 10);\\n        N /= 10;\\n      }\\n\\n      for (int i = 0; i < list.Count - 1; i++)\\n      {\\n        if (list[i + 1] > list[i])\\n        {\\n          for (int j = i; j >= 0 && list[j] != 9; j--)\\n            list[j] = 9;\\n\\n          list[i + 1]--;\\n        }\\n\\n      }\\n\\n      var num = 0;\\n      for (int i = list.Count - 1; i >= 0; i--)\\n        num = num * 10 + list[i];\\n\\n      return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248443,
                "title": "a-simple-c-solution-accepted-runtime-4ms",
                "content": "```\\nint howMuchDigits(int N){\\n    int ret=0;\\n    while(N>0){\\n        N/=10;\\n        ret++;\\n    }\\n    return ret;\\n}\\nint monotoneIncreasingDigits(int N) {\\n    int count=howMuchDigits(N);\\n    int* array=(int*)calloc(10,sizeof(int));\\n    for(int i=0;i<count;i++){\\n        int temp=pow(10,count-i-1);\\n        array[i]=N/temp;\\n        N%=temp;\\n    }\\n    int start=0;\\n    for(int i=0;i<count-1;i++){\\n        if(array[i]==array[i+1]){\\n            continue;\\n        }\\n        if(array[i]<array[i+1]){\\n            start=i+1;\\n        }\\n        if(array[i]>array[i+1]){\\n            array[start]--;\\n            for(int j=start+1;j<count;j++){\\n                array[j]=9;\\n            }\\n            break;\\n        }\\n    }\\n    int ret=0;\\n    for(int i=0;i<count;i++){\\n        ret=ret*10+array[i];\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint howMuchDigits(int N){\\n    int ret=0;\\n    while(N>0){\\n        N/=10;\\n        ret++;\\n    }\\n    return ret;\\n}\\nint monotoneIncreasingDigits(int N) {\\n    int count=howMuchDigits(N);\\n    int* array=(int*)calloc(10,sizeof(int));\\n    for(int i=0;i<count;i++){\\n        int temp=pow(10,count-i-1);\\n        array[i]=N/temp;\\n        N%=temp;\\n    }\\n    int start=0;\\n    for(int i=0;i<count-1;i++){\\n        if(array[i]==array[i+1]){\\n            continue;\\n        }\\n        if(array[i]<array[i+1]){\\n            start=i+1;\\n        }\\n        if(array[i]>array[i+1]){\\n            array[start]--;\\n            for(int j=start+1;j<count;j++){\\n                array[j]=9;\\n            }\\n            break;\\n        }\\n    }\\n    int ret=0;\\n    for(int i=0;i<count;i++){\\n        ret=ret*10+array[i];\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209382,
                "title": "c-solution-4ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        int a[10]={0};\\n        int ans=0;\\n        int num = 0;// cout the num of figures\\n        for(int i = 0;i<10;i++)\\n        {\\n            a[i] = N%10;\\n            N/=10;\\n            num++;\\n            if(N==0)\\n            {break;}\\n        }\\n        for(int j=0;j<num-1;j++)\\n        {\\n\\t\\t\\tfor(int i = weishu;i>0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(a[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif((a[i]>a[i-1]))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ta[i]--;\\n\\t\\t\\t\\t\\t\\tfor(int k = 0;k<i;k++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\ta[k] = 9;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        }\\n\\t\\tfor (int i = 0; i < weishu; i++)\\n\\t\\t{\\n\\t\\t\\tans += a[i]*pow(10,i);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int N) {\\n        int a[10]={0};\\n        int ans=0;\\n        int num = 0;// cout the num of figures\\n        for(int i = 0;i<10;i++)\\n        {\\n            a[i] = N%10;\\n            N/=10;\\n            num++;\\n            if(N==0)\\n            {break;}\\n        }\\n        for(int j=0;j<num-1;j++)\\n        {\\n\\t\\t\\tfor(int i = weishu;i>0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(a[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif((a[i]>a[i-1]))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ta[i]--;\\n\\t\\t\\t\\t\\t\\tfor(int k = 0;k<i;k++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\ta[k] = 9;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        }\\n\\t\\tfor (int i = 0; i < weishu; i++)\\n\\t\\t{\\n\\t\\t\\tans += a[i]*pow(10,i);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 186710,
                "title": "concise-python-solution-beats-98",
                "content": "```\\n def monotoneIncreasingDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        digits = [int(x) for x in str(N)]\\n        count = 0 #store the number of same digit\\n        \\n        for i in range(len(digits)-1):\\n            if digits[i] > digits[i+1]:\\n                digits[i-count] -= 1\\n                for j in range(i-count+1,len(digits)):\\n                    digits[j] = 9\\n                break\\n            elif digits[i] == digits[i+1]:\\n                count += 1\\n            else:\\n                count = 0\\n        \\n        return int(\\'\\'.join([str(x) for x in digits]))\\n```",
                "solutionTags": [],
                "code": "```\\n def monotoneIncreasingDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        digits = [int(x) for x in str(N)]\\n        count = 0 #store the number of same digit\\n        \\n        for i in range(len(digits)-1):\\n            if digits[i] > digits[i+1]:\\n                digits[i-count] -= 1\\n                for j in range(i-count+1,len(digits)):\\n                    digits[j] = 9\\n                break\\n            elif digits[i] == digits[i+1]:\\n                count += 1\\n            else:\\n                count = 0\\n        \\n        return int(\\'\\'.join([str(x) for x in digits]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161628,
                "title": "c-greedy-solution",
                "content": "\\n  string st=to_string(N);\\n     \\n\\t   int i;\\n      \\n\\t   int n=st.size();\\n        \\n\\t    int ind=n-1;\\n\\t\\t\\t\\t\\n        for(i=n-2;i>=0;i--)\\n        {\\n\\t\\tif(st[i]>st[i+1])\\n\\t\\t{\\n\\t\\t\\tst[i]--;\\n\\t\\t\\tind=i;\\n\\t\\t}\\n        }\\n\\t\\t\\t\\t\\n        string res;\\n\\t\\t\\t\\t\\n        for(i=0;i<=ind;i++)\\n\\t\\tres=res+st[i];\\n\\t\\t\\t\\t\\t\\t\\t\\n        for(i=ind+1;i<n;i++)\\n\\t\\tres=res+\"9\";\\n\\t\\t\\n        return stoi(res);",
                "solutionTags": [],
                "code": "\\n  string st=to_string(N);\\n     \\n\\t   int i;\\n      \\n\\t   int n=st.size();\\n        \\n\\t    int ind=n-1;\\n\\t\\t\\t\\t\\n        for(i=n-2;i>=0;i--)\\n        {\\n\\t\\tif(st[i]>st[i+1])\\n\\t\\t{\\n\\t\\t\\tst[i]--;\\n\\t\\t\\tind=i;\\n\\t\\t}\\n        }\\n\\t\\t\\t\\t\\n        string res;\\n\\t\\t\\t\\t\\n        for(i=0;i<=ind;i++)\\n\\t\\tres=res+st[i];\\n\\t\\t\\t\\t\\t\\t\\t\\n        for(i=ind+1;i<n;i++)\\n\\t\\tres=res+\"9\";\\n\\t\\t\\n        return stoi(res);",
                "codeTag": "Unknown"
            },
            {
                "id": 130015,
                "title": "string-based-c-solution-4ms",
                "content": "```\\nint monotoneIncreasingDigits(int N) {\\n    char num[10];\\n    sprintf(num,\"%d\",N);\\n    int nines_digit = strlen(num);\\n    for (int i = strlen(num)-1; i>0; i--){\\n        if(num[i] < num[i-1]){\\n            num[i] = \\'9\\';\\n            num[i-1] = num[i-1] - 1;\\n            for(int j = i+1; j <nines_digit;j++){\\n                num[j] = \\'9\\';\\n            }\\n            nines_digit = i;\\n        }\\n    }\\n    return atoi(num);\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint monotoneIncreasingDigits(int N) {\\n    char num[10];\\n    sprintf(num,\"%d\",N);\\n    int nines_digit = strlen(num);\\n    for (int i = strlen(num)-1; i>0; i--){\\n        if(num[i] < num[i-1]){\\n            num[i] = \\'9\\';\\n            num[i-1] = num[i-1] - 1;\\n            for(int j = i+1; j <nines_digit;j++){\\n                num[j] = \\'9\\';\\n            }\\n            nines_digit = i;\\n        }\\n    }\\n    return atoi(num);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109786,
                "title": "c-solution",
                "content": "public class Solution {\\n    public int MonotoneIncreasingDigits(int N) {\\n       char[] n = N.ToString().ToCharArray();        \\n        int mark =n.Length;\\n        for(int i=n.Length-1;i>=1;i--)\\n        {\\n            if(n[i]<n[i-1])\\n            {\\n                mark = i;\\n                n[i-1]--;\\n            }\\n        }\\n        Console.WriteLine(mark);\\n        for(int i=mark;i<n.Length;i++)\\n        {\\n            n[i]='9';\\n        }\\n        return Convert.ToInt32(new String(n));  \\n    }\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public int MonotoneIncreasingDigits(int N) {\\n       char[] n = N.ToString().ToCharArray();        \\n        int mark =n.Length;\\n        for(int i=n.Length-1;i>=1;i--)\\n        {\\n            if(n[i]<n[i-1])\\n            {\\n                mark = i;\\n                n[i-1]--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4086697,
                "title": "ruby-solution-with-reverse-indexing-explained-100-100",
                "content": "# Intuition\\nCheck if the number is monotone increasing.  If not, find the first digit that\\'s not increasing from the previous digit.  Decrement the digit and replace all the digits after it with 9.\\n\\n# Approach\\n1. Create an array of the digits as integers.\\n2. Check if the number is already monotone increasing.  If so, return it.\\n3. Iterate through the digits of the number backwards, checking if each digit is less than or equal to the following digit.  If so, decrement the digit and set it to be first_index.  (This represents the first index where the digit will change.)\\n4. Set all the digits after first_index to 9.\\n5. Join the digits together as a single number and return.\\n\\n(Note: numbers like 100 are edge cases, because the first digit becomes a 0.  This doesn\\'t cause a problem, because [0,9,9] => \"099\" => 99.)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef monotone_increasing_digits(n)\\n    digits = n.to_s.split(\\'\\').map { |digit| digit.to_i }\\n    return n if (1...digits.length).all? { |i| digits[i] >= digits[i-1] }\\n    first_idx = -1\\n    i = -2\\n\\n    while digits[i]\\n        if digits[i] > digits[i+1]\\n            digits[i] -= 1\\n            first_idx = i\\n        end\\n        i -= 1\\n    end\\n\\n    (first_idx+1..-1).each { |i| digits[i] = 9 }\\n    \\n    digits.map{ |digit| digit.to_s }.join(\\'\\').to_i\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef monotone_increasing_digits(n)\\n    digits = n.to_s.split(\\'\\').map { |digit| digit.to_i }\\n    return n if (1...digits.length).all? { |i| digits[i] >= digits[i-1] }\\n    first_idx = -1\\n    i = -2\\n\\n    while digits[i]\\n        if digits[i] > digits[i+1]\\n            digits[i] -= 1\\n            first_idx = i\\n        end\\n        i -= 1\\n    end\\n\\n    (first_idx+1..-1).each { |i| digits[i] = 9 }\\n    \\n    digits.map{ |digit| digit.to_s }.join(\\'\\').to_i\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4049847,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        digits = []\\n        final = []\\n\\n        while n:\\n            digits.append(n%10)\\n            n //= 10\\n        \\n        for i in range(len(digits)):\\n            if digits[i]<=0 or (i!=len(digits)-1 and digits[i]<digits[i+1]):\\n                if i!=len(digits)-1:\\n                    final = [9]*(len(final)+1)\\n                    digits[i+1] -= 1\\n            else:\\n                final.append(digits[i])\\n        \\n        final = final[::-1]\\n\\n        return int(\\'\\'.join([str(x) for x in final])) if final else 0     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        digits = []\\n        final = []\\n\\n        while n:\\n            digits.append(n%10)\\n            n //= 10\\n        \\n        for i in range(len(digits)):\\n            if digits[i]<=0 or (i!=len(digits)-1 and digits[i]<digits[i+1]):\\n                if i!=len(digits)-1:\\n                    final = [9]*(len(final)+1)\\n                    digits[i+1] -= 1\\n            else:\\n                final.append(digits[i])\\n        \\n        final = final[::-1]\\n\\n        return int(\\'\\'.join([str(x) for x in final])) if final else 0     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023968,
                "title": "c-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n       string a=to_string(n); \\n       int i=1;\\n       int z=a.size();\\n       while(i<z && a[i]>=a[i-1]) i++;\\n       if(i<z)\\n       while(i>0 && a[i-1]>a[i]){\\n           i--;\\n           a[i]--;\\n       }\\n       for(int j=i+1;j<z;j++)a[j]=\\'9\\';\\n       return stoi(a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n       string a=to_string(n); \\n       int i=1;\\n       int z=a.size();\\n       while(i<z && a[i]>=a[i-1]) i++;\\n       if(i<z)\\n       while(i>0 && a[i-1]>a[i]){\\n           i--;\\n           a[i]--;\\n       }\\n       for(int j=i+1;j<z;j++)a[j]=\\'9\\';\\n       return stoi(a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022246,
                "title": "c-0ms-100-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code converts an integer `n` into a string and finds the largest monotone decreasing number less than or equal to `n`. It does this by scanning the digits from left to right, finding the first decreasing digit, decreasing it by 1, setting all subsequent digits to \\'9\\', and converting the result back to an integer. This ensures that the output number is the largest possible monotone decreasing number.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert the integer input n into a string st to make it easier to work with individual digits.\\n\\n1. Initialize an index i to 0, which will be used to traverse the digits of st.\\n\\n1. Start a loop that continues as long as i is less than the size of the string st minus 1 (i.e., there are more digits to process) and the current digit st[i] is less than or equal to the next digit st[i+1]. This loop is used to find the first digit (from left to right) where the digits start decreasing.\\n\\n1. After finding the first decreasing digit, check if there are any previous identical digits (digits that are the same as the decreasing digit) by moving the index i backward while st[i] is equal to st[i-1]. This step ensures that we don\\'t reduce identical digits more than once.\\n\\n1. Decrease the digit at index i by 1, which ensures that the number remains monotone decreasing up to this point.\\n\\n1. Increment the index i by 1 to move to the next digit.\\n\\n1. Iterate through the remaining digits in the string st from index i onwards and change each of them to \\'9\\' to ensure that the number is as large as possible while remaining monotone decreasing.\\n\\n1. Finally, convert the modified string st back to an integer using stoi(st) and return it as the result.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(log10(n))\\n     This is because the code essentially processes each digit of the input number once, and the number of digits in \"n\" is proportional to log10(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(log10(n))\\n    This is because the space required for the st string is proportional to the number of digits in the input number, which is log10(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string st= to_string(n);\\n        int i=0;\\n        while(i<st.size()-1 && st[i]<=st[i+1]) i++;\\n        if(i==st.size()-1) return n;\\n        while(i>0 && st[i]==st[i-1]) i--;\\n        st[i]--;\\n        i++;\\n        while(i<st.size()){\\n            st[i]=\\'9\\';\\n            i++;\\n        }\\n        return stoi(st);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string st= to_string(n);\\n        int i=0;\\n        while(i<st.size()-1 && st[i]<=st[i+1]) i++;\\n        if(i==st.size()-1) return n;\\n        while(i>0 && st[i]==st[i-1]) i--;\\n        st[i]--;\\n        i++;\\n        while(i<st.size()){\\n            st[i]=\\'9\\';\\n            i++;\\n        }\\n        return stoi(st);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014544,
                "title": "easy-java-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char arr[] = String.valueOf(n).toCharArray();\\n\\n        int x = arr.length;\\n        int st = x;\\n        \\n        for(int i=x-2; i>=0; i--){\\n            if(arr[i]>arr[i+1]){\\n                st = i+1;\\n                arr[i]--;\\n            }\\n        }\\n\\n        for(int i=st; i<x; i++){\\n            arr[i] = \\'9\\';\\n        }\\n\\n        return Integer.valueOf(String.valueOf(arr));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char arr[] = String.valueOf(n).toCharArray();\\n\\n        int x = arr.length;\\n        int st = x;\\n        \\n        for(int i=x-2; i>=0; i--){\\n            if(arr[i]>arr[i+1]){\\n                st = i+1;\\n                arr[i]--;\\n            }\\n        }\\n\\n        for(int i=st; i<x; i++){\\n            arr[i] = \\'9\\';\\n        }\\n\\n        return Integer.valueOf(String.valueOf(arr));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011664,
                "title": "java-simple-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires the largest monotonically increasing integer less than or equal to N, so take a two-digit number as an example.\\n\\nFor example: 98, In the case of strNum[i-1] > strNum[i] (non-monotonically increasing), we first want strNum[i-1]--, and then strNum[i] to be 9, so that the integer is 89, which is the largest monotonically increasing integer less than 98.\\n\\nIf you think about this point clearly, the problem will be easy to solve.\\n\\n**Now, do we go from front to back or from back to front?**\\n\\nIf we walk from front to back, we encounter strNum[i-1] > strNum[i], let strNum[i-1] decrease by one, but if strNum[i-1] decreases by one, it may be less than strNum[i-2] again.\\n\\nThis is a bit abstract, for example, the number: 332, if you go from front to back, then it becomes 329, and then 2 is less than the first 3, the real result should be 299.\\n\\nThen from the back to the forward traversal, you can reuse the results of the last comparison, from the back to the forward traversal 332 value changes to: 332 -> 329 -> 299.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter the traversal order is determined, then the local optimal can be deduced from the global, can not find a counterexample, try greedy.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char[] s = String.valueOf(n).toCharArray();\\n\\n        int res = 0;\\n        int flag = s.length;\\n        for (int i = s.length - 1; i > 0; i--) {\\n            if (s[i] < s[i-1]) {\\n                s[i] = \\'9\\';\\n                s[i-1] = (char)(s[i-1] - 1);\\n                flag = i;\\n            }\\n        }\\n\\n        for (int i = flag; i < s.length; i++) {\\n            s[i] = \\'9\\';\\n        }\\n        for (int i = 0; i < s.length; i++) {\\n            res = (res * 10 + (s[i] - \\'0\\'));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char[] s = String.valueOf(n).toCharArray();\\n\\n        int res = 0;\\n        int flag = s.length;\\n        for (int i = s.length - 1; i > 0; i--) {\\n            if (s[i] < s[i-1]) {\\n                s[i] = \\'9\\';\\n                s[i-1] = (char)(s[i-1] - 1);\\n                flag = i;\\n            }\\n        }\\n\\n        for (int i = flag; i < s.length; i++) {\\n            s[i] = \\'9\\';\\n        }\\n        for (int i = 0; i < s.length; i++) {\\n            res = (res * 10 + (s[i] - \\'0\\'));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996285,
                "title": "easy-digit-dp-intutive-aproach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitdp(self,idx,s,prevdigit,val,tight,iszero):\\n        if idx>=len(s):\\n            return val\\n        limit=int(s[idx])\\n        if not tight:\\n            limit=9\\n        take=0\\n\\n        for currentdigit in range(limit+1):\\n            nexttight=tight and currentdigit==limit\\n            nextzero=iszero and currentdigit==0\\n            if nextzero or currentdigit>=prevdigit:\\n                take=max(take,self.digitdp(idx+1,s,currentdigit,val*10+currentdigit,nexttight,nextzero))\\n        return take\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        return self.digitdp(0,str(n),0,0,True,True)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitdp(self,idx,s,prevdigit,val,tight,iszero):\\n        if idx>=len(s):\\n            return val\\n        limit=int(s[idx])\\n        if not tight:\\n            limit=9\\n        take=0\\n\\n        for currentdigit in range(limit+1):\\n            nexttight=tight and currentdigit==limit\\n            nextzero=iszero and currentdigit==0\\n            if nextzero or currentdigit>=prevdigit:\\n                take=max(take,self.digitdp(idx+1,s,currentdigit,val*10+currentdigit,nexttight,nextzero))\\n        return take\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        return self.digitdp(0,str(n),0,0,True,True)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977718,
                "title": "cleanest-and-easiest-dp-digit-dp-approach-with-explaination",
                "content": "# Intuition\\nWhy Digit dp?\\nReason 1:\\nLooking at the contraints which are of order (10^9) (hint for digit dp).\\nReason 2:\\nThe answer is in range [0,n] i.e (here of course brute forcely we can check for every number in the range 0,1,2,3,...,n that if it\\'s digit are in increasing order and in this way we can find largest)\\n\\nSo its clear digit dp arroach can be applied here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn digit dp we try to create a number based on condition..\\nLets say a number 9435\\ninitially we have nothing and the the number at thousandsths place can be 1,2,3,4,5,6,7,8,9 ryt it can be anything\\nNow let\\'s say the digit at thousandths place is 4 then it is compulsary the next digit must be greater then or equals to 4 .so the  choices for next digit are 4,5,6,7,8,9 ryt?? (absolutely)\\n\\nNow see this case when we have n = 4525\\nand first digit we choose is 4 now next digit must be greater than or equals to 4 ryt so our contender for next digit are 4,5,6,7,8,9 ...do you think all these are valid contenders => NO!! because if we choose something gretaer than 5 than the number created will be greater than 4525 (got confused dont worry) lets see an example\\nif we have n = 4525\\nand we choose 4 as 1st digit and 6 as 2nd digit then number will be of form 4 6 _ _ now whatever we choose as third digit the created number will always be greater than 4525 ...\\n\\nSO we will use  two variable ***lb*** and ***ub*** which will be used to make the decision on what valid digit we can choose..\\n\\n**$$lb$$** => decides the next digit should be greater than equals to lb\\n**$$ub$$** => decides the next digit should be less than equals to ub\\n\\nhere tight variable will be used to decide ub\\n\\nSee here why=>\\nagain lets see for n = 4525\\nif 1st digit is 1 _ _ _ then whatever we choose as long as it is greater than equals to 1 all the ansers will be valid but if 1st digit is 4 than next digit must be less than equal to 5 ===>  4 _ _ _\\nnow if we choose digit as the digit of num then tight variiable is true like in 2nd case when we choose 4 => 4 _ _ _   here for next iteration tight is true that is next digit must be less than euals to 5\\n\\nbut for first case when 1st digit we choose was 1 then => 1 _ _ _\\nso now we can choose 2nd digit anything here tight variable is false that is no restriction on upper bound\\n  \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int lb,int i,int tight,string temp,string nums)\\n    {\\n        if(i==nums.size()){\\n            return stoi(temp);\\n            //returning the created number\\n        }\\n\\n\\n       int ub = tight ? nums[i]-\\'0\\' : 9;\\n        // Checking if tight is true then ub will be equal to current nums[i] else ub cna be anything ie <=9\\n       \\n        int ans = INT_MIN;\\n       for(int k=lb;k<=ub;k++){\\n           ans = max(ans,solve(k,i+1,tight & (k==ub),temp + to_string(k),nums));\\n       }\\n// the digit should be between ub and lb (so that both ascending order of digits and also the number created less than <=n>)\\n//tight & (k==ub) this checks if tight is false then for other recursive calls we can choose ub as anything <=9 but if tight is true then tight again will be trur if dig we choose ==nums[i]\\n\\n\\n       return ans;\\n    }\\n    int monotoneIncreasingDigits(int n) {\\n        \\n        return solve(0,0,1,\"\",to_string(n));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int lb,int i,int tight,string temp,string nums)\\n    {\\n        if(i==nums.size()){\\n            return stoi(temp);\\n            //returning the created number\\n        }\\n\\n\\n       int ub = tight ? nums[i]-\\'0\\' : 9;\\n        // Checking if tight is true then ub will be equal to current nums[i] else ub cna be anything ie <=9\\n       \\n        int ans = INT_MIN;\\n       for(int k=lb;k<=ub;k++){\\n           ans = max(ans,solve(k,i+1,tight & (k==ub),temp + to_string(k),nums));\\n       }\\n// the digit should be between ub and lb (so that both ascending order of digits and also the number created less than <=n>)\\n//tight & (k==ub) this checks if tight is false then for other recursive calls we can choose ub as anything <=9 but if tight is true then tight again will be trur if dig we choose ==nums[i]\\n\\n\\n       return ans;\\n    }\\n    int monotoneIncreasingDigits(int n) {\\n        \\n        return solve(0,0,1,\"\",to_string(n));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963642,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char[] arr = String.valueOf(n).toCharArray();\\n        int start = arr.length;\\n        for (int i = arr.length - 2; i >= 0; i --) {\\n            if (arr[i] > arr[i + 1]) {\\n                start = i + 1;\\n                arr[i] --;\\n            }\\n        }\\n        \\n        for (int i = start; i < arr.length; i ++) {\\n            arr[i] = \\'9\\';\\n        }\\n        \\n        return Integer.parseInt(String.valueOf(arr));\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        int size = s.size(), lim = s.size();\\n        for(int i=size-1; i>0; i--){\\n            if(s[i-1] > s[i]) lim = i, s[i-1] -= 1;\\n        }\\n        for(int i=lim; i<size; i++) s[i] = \\'9\\';\\n        return stoi(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char[] arr = String.valueOf(n).toCharArray();\\n        int start = arr.length;\\n        for (int i = arr.length - 2; i >= 0; i --) {\\n            if (arr[i] > arr[i + 1]) {\\n                start = i + 1;\\n                arr[i] --;\\n            }\\n        }\\n        \\n        for (int i = start; i < arr.length; i ++) {\\n            arr[i] = \\'9\\';\\n        }\\n        \\n        return Integer.parseInt(String.valueOf(arr));\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        int size = s.size(), lim = s.size();\\n        for(int i=size-1; i>0; i--){\\n            if(s[i-1] > s[i]) lim = i, s[i-1] -= 1;\\n        }\\n        for(int i=lim; i<size; i++) s[i] = \\'9\\';\\n        return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887699,
                "title": "easy-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        if(n<10)return n;\\n        vector<int>nums;\\n        while(n>=1)\\n        {\\n            nums.push_back(n %10);\\n            n=n/10;\\n        }\\n        reverse(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n            {\\n                nums[i]--;\\n                for(int k=i;k>0;k--)\\n                {\\n                    if(nums[k]<nums[k-1])\\n                    {\\n                        nums[k]=9;\\n                        nums[k-1]--;\\n                    }\\n                }\\n                \\n                for(int j=i+1;j<nums.size();j++)\\n                {\\n                    nums[j]=9;\\n                }\\n                break;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=ans*10+nums[i];\\n        }\\n        return ans;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        if(n<10)return n;\\n        vector<int>nums;\\n        while(n>=1)\\n        {\\n            nums.push_back(n %10);\\n            n=n/10;\\n        }\\n        reverse(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n            {\\n                nums[i]--;\\n                for(int k=i;k>0;k--)\\n                {\\n                    if(nums[k]<nums[k-1])\\n                    {\\n                        nums[k]=9;\\n                        nums[k-1]--;\\n                    }\\n                }\\n                \\n                for(int j=i+1;j<nums.size();j++)\\n                {\\n                    nums[j]=9;\\n                }\\n                break;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=ans*10+nums[i];\\n        }\\n        return ans;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869201,
                "title": "easy-and-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        String str = Integer.toString(n);\\n        boolean isMonotonic = true;\\n        int firstMonoIdx = -1;        \\n        for(int i = 1; i < str.length(); i++)\\n        {            \\n            if(str.charAt(i) < str.charAt(i - 1))\\n            {\\n                isMonotonic = false;\\n                break;\\n            }\\n            if(str.charAt(i) > str.charAt(i - 1))\\n            firstMonoIdx = i;\\n        }\\n        if(isMonotonic)\\n        return n;\\n\\n        char [] ch = new char[str.length()];\\n        for(int i = 0; i < firstMonoIdx; i++)\\n        ch[i] = str.charAt(i);\\n        \\n        int j = firstMonoIdx == -1 ? 0 : firstMonoIdx;\\n        char c = str.charAt(j);\\n        ch[j] = --c;\\n        for(int i = j + 1; i < str.length(); i++)\\n        ch[i] = \\'9\\';\\n        return Integer.parseInt(new String(ch));\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        String str = Integer.toString(n);\\n        boolean isMonotonic = true;\\n        int firstMonoIdx = -1;        \\n        for(int i = 1; i < str.length(); i++)\\n        {            \\n            if(str.charAt(i) < str.charAt(i - 1))\\n            {\\n                isMonotonic = false;\\n                break;\\n            }\\n            if(str.charAt(i) > str.charAt(i - 1))\\n            firstMonoIdx = i;\\n        }\\n        if(isMonotonic)\\n        return n;\\n\\n        char [] ch = new char[str.length()];\\n        for(int i = 0; i < firstMonoIdx; i++)\\n        ch[i] = str.charAt(i);\\n        \\n        int j = firstMonoIdx == -1 ? 0 : firstMonoIdx;\\n        char c = str.charAt(j);\\n        ch[j] = --c;\\n        for(int i = j + 1; i < str.length(); i++)\\n        ch[i] = \\'9\\';\\n        return Integer.parseInt(new String(ch));\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865031,
                "title": "optimised-greedy-solution-with-detailed-explanations-in-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        #Optimised greedy solution o(n)\\n        \"\"\"\\n        I will refer to monotone increasing digits as mid for convenience sake;\\n        I call the function we\\'re suppose to build mid()\\n        I didn\\'t came up with this solution but I hope i will make it clear for you.\\n        Let\\'s start with a case analysis.\\n\\n        mid(10)=9\\n        mid(20)=19\\n        mid(21)=mid(20)=19\\n        mid(98)=mid(97)=mid(96)=...=mid(90)=89\\n        Now i will use @ as a cursor to guide you.\\n        The algorithm in it\\'s implementation is quite similar to a sliding window, by fixing the number from the right to the left we\\'re effectively solving subproblems.\\n        mid(9876)=mid(9875)=...=mid(9870)=mid(98@79)=...\\n        =mid(98@79)=mid(9@799)=...\\n        =mid(9@799)=mid(8999)\\n\\n        Here\\'s are the pattern i hope you picked up.\\n        Usually just substracting -1 to the number we have is good enough.\\n        If there is 2 digits in the number we have to fix,substracting -1 until we reach the number we want work.But it could take a while. \\n        It\\'s faster to substract to the second term starting from the right and then replace the first term by a 9.\\n        This logic can be generalised for 3 digits integer...effectively for k digits integer.\\n        if you have 3 numbers, fix the first 2 digits starting from the right with the same method. If the 3rd term pause a problem,-1, and you replace the other terms by 9.\\n        The code below is slightly optimised.\\n        9 comes pretty often, and everytime we update the k th digit we have to replace all the numbers before it by 9, so we replace some digits by 9 a bunch of time.\\n        Instead,we can just find the position of the last term we substracted by -1, and replace all the numbers before with 9. That\\'s why we use the variable flag.\\n\\n        \"\"\"\\n        listNum = list(str(n))\\n        flag = len(listNum)\\n\\n        for i in range(len(listNum) - 1, 0, -1):\\n            if listNum[i - 1] > listNum[i]:\\n                flag = i\\n                listNum[i - 1] = str(int(listNum[i - 1]) - 1)\\n\\n        for i in range(flag, len(listNum)):\\n            listNum[i] = \\'9\\'    \\n        \\n        return int(\"\".join(listNum))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        #Optimised greedy solution o(n)\\n        \"\"\"\\n        I will refer to monotone increasing digits as mid for convenience sake;\\n        I call the function we\\'re suppose to build mid()\\n        I didn\\'t came up with this solution but I hope i will make it clear for you.\\n        Let\\'s start with a case analysis.\\n\\n        mid(10)=9\\n        mid(20)=19\\n        mid(21)=mid(20)=19\\n        mid(98)=mid(97)=mid(96)=...=mid(90)=89\\n        Now i will use @ as a cursor to guide you.\\n        The algorithm in it\\'s implementation is quite similar to a sliding window, by fixing the number from the right to the left we\\'re effectively solving subproblems.\\n        mid(9876)=mid(9875)=...=mid(9870)=mid(98@79)=...\\n        =mid(98@79)=mid(9@799)=...\\n        =mid(9@799)=mid(8999)\\n\\n        Here\\'s are the pattern i hope you picked up.\\n        Usually just substracting -1 to the number we have is good enough.\\n        If there is 2 digits in the number we have to fix,substracting -1 until we reach the number we want work.But it could take a while. \\n        It\\'s faster to substract to the second term starting from the right and then replace the first term by a 9.\\n        This logic can be generalised for 3 digits integer...effectively for k digits integer.\\n        if you have 3 numbers, fix the first 2 digits starting from the right with the same method. If the 3rd term pause a problem,-1, and you replace the other terms by 9.\\n        The code below is slightly optimised.\\n        9 comes pretty often, and everytime we update the k th digit we have to replace all the numbers before it by 9, so we replace some digits by 9 a bunch of time.\\n        Instead,we can just find the position of the last term we substracted by -1, and replace all the numbers before with 9. That\\'s why we use the variable flag.\\n\\n        \"\"\"\\n        listNum = list(str(n))\\n        flag = len(listNum)\\n\\n        for i in range(len(listNum) - 1, 0, -1):\\n            if listNum[i - 1] > listNum[i]:\\n                flag = i\\n                listNum[i - 1] = str(int(listNum[i - 1]) - 1)\\n\\n        for i in range(flag, len(listNum)):\\n            listNum[i] = \\'9\\'    \\n        \\n        return int(\"\".join(listNum))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862704,
                "title": "c-solution-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MonotoneIncreasingDigits(int n) {\\n        List<int> digits = new List<int>();\\n\\n        while(n != 0){\\n            digits.Insert(0, n%10);\\n            n = n/10;\\n        }\\n        \\n        int i = 0, res = 0;\\n\\n        while(i < digits.Count){\\n            int j = i;\\n\\n            while(j < digits.Count && digits[j] == digits[i]){\\n                j++;\\n            }\\n\\n            if(j >= digits.Count){\\n                break;\\n            }\\n\\n            if(digits[j] < digits[i]){\\n                digits[i++]--;\\n\\n                while(i < digits.Count){\\n                    digits[i++] = 9;\\n                }\\n\\n                break;\\n            }\\n\\n            i = j;\\n        }\\n\\n        for(int j=0; j<digits.Count; j++){\\n            res = res*10 + digits[j];\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MonotoneIncreasingDigits(int n) {\\n        List<int> digits = new List<int>();\\n\\n        while(n != 0){\\n            digits.Insert(0, n%10);\\n            n = n/10;\\n        }\\n        \\n        int i = 0, res = 0;\\n\\n        while(i < digits.Count){\\n            int j = i;\\n\\n            while(j < digits.Count && digits[j] == digits[i]){\\n                j++;\\n            }\\n\\n            if(j >= digits.Count){\\n                break;\\n            }\\n\\n            if(digits[j] < digits[i]){\\n                digits[i++]--;\\n\\n                while(i < digits.Count){\\n                    digits[i++] = 9;\\n                }\\n\\n                break;\\n            }\\n\\n            i = j;\\n        }\\n\\n        for(int j=0; j<digits.Count; j++){\\n            res = res*10 + digits[j];\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834890,
                "title": "simple-fast-solution-with-comments",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar monotoneIncreasingDigits = function (n) {\\n    // converting number to array of integers\\n    var narr = [...n.toString()].map((l) => parseInt(l));\\n    var stack = [narr[0]];\\n    // iterating over array and pushing digits in stack \\n    for (let i = 1; i < narr.length; i++) {\\n        if (narr[i] >= narr[i-1]) stack.push(narr[i]);\\n        // in case x > y:\\n        else {\\n            // [i-1] is the last index with biggest digit before number started decreasing\\n            // lets borrow \\'1\\' from this digit and change remaining digits to \\'9\\'\\n            stack[i-1] -= 1;\\n            for (let c = i; c < narr.length; c++) {stack.push(9)}\\n            /*  iterating over stack from [i-1] to 0 (backwards); if right digit is lesser than left,\\n                replace it with \\'9\\' and borrow \\'1\\' from left digit, like we did above */  \\n            for (let c = i-1; c > 0; c--) {\\n                if (stack[c] < stack[c-1]) {\\n                    stack[c-1] -= 1;\\n                    stack[c] = 9;\\n                }\\n            }\\n            break;\\n        }\\n    }\\n    // parseInt automatically removes leading zero if presented\\n    return parseInt(stack.join(\\'\\'));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar monotoneIncreasingDigits = function (n) {\\n    // converting number to array of integers\\n    var narr = [...n.toString()].map((l) => parseInt(l));\\n    var stack = [narr[0]];\\n    // iterating over array and pushing digits in stack \\n    for (let i = 1; i < narr.length; i++) {\\n        if (narr[i] >= narr[i-1]) stack.push(narr[i]);\\n        // in case x > y:\\n        else {\\n            // [i-1] is the last index with biggest digit before number started decreasing\\n            // lets borrow \\'1\\' from this digit and change remaining digits to \\'9\\'\\n            stack[i-1] -= 1;\\n            for (let c = i; c < narr.length; c++) {stack.push(9)}\\n            /*  iterating over stack from [i-1] to 0 (backwards); if right digit is lesser than left,\\n                replace it with \\'9\\' and borrow \\'1\\' from left digit, like we did above */  \\n            for (let c = i-1; c > 0; c--) {\\n                if (stack[c] < stack[c-1]) {\\n                    stack[c-1] -= 1;\\n                    stack[c] = 9;\\n                }\\n            }\\n            break;\\n        }\\n    }\\n    // parseInt automatically removes leading zero if presented\\n    return parseInt(stack.join(\\'\\'));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815031,
                "title": "php-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function monotoneIncreasingDigits($n) {\\n\\n        $s = (string)$n; // convertimos numero en string \\n        $size = strlen($s); // contamos cantidad de elementos\\n        $lim = strlen($s); // contamos cantidad de elementos\\n\\n        for($i = $size-1; $i>0; $i--){\\n            if($s[$i-1] > $s[$i]) {\\n                $lim = $i;\\n                $s[$i-1] = $s[$i-1] - 1;\\n            }\\n             \\n        }\\n\\n        for($i = $lim; $i< $size; $i++) {\\n            $s[$i] = \\'9\\';\\n        } \\n\\n        return intval($s);\\n    }\\n        \\n}\\n\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function monotoneIncreasingDigits($n) {\\n\\n        $s = (string)$n; // convertimos numero en string \\n        $size = strlen($s); // contamos cantidad de elementos\\n        $lim = strlen($s); // contamos cantidad de elementos\\n\\n        for($i = $size-1; $i>0; $i--){\\n            if($s[$i-1] > $s[$i]) {\\n                $lim = $i;\\n                $s[$i-1] = $s[$i-1] - 1;\\n            }\\n             \\n        }\\n\\n        for($i = $lim; $i< $size; $i++) {\\n            $s[$i] = \\'9\\';\\n        } \\n\\n        return intval($s);\\n    }\\n        \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810519,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        while(1){\\n            bool flag = false;\\n            for(int i = 1; i < s.length(); i++){\\n                if(s[i] >= s[i-1]) continue;\\n                else{\\n                    s[i-1]--;\\n                    while(i != s.length()){\\n                        s[i] = \\'9\\';\\n                        i++;\\n                    }\\n                    flag = true;\\n                }\\n            }\\n            if(!flag) break;\\n        }\\n        return stoi(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        while(1){\\n            bool flag = false;\\n            for(int i = 1; i < s.length(); i++){\\n                if(s[i] >= s[i-1]) continue;\\n                else{\\n                    s[i-1]--;\\n                    while(i != s.length()){\\n                        s[i] = \\'9\\';\\n                        i++;\\n                    }\\n                    flag = true;\\n                }\\n            }\\n            if(!flag) break;\\n        }\\n        return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807470,
                "title": "dfs-backtracking-not-the-cleverest-solution-but-reliable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nMy idea is that we want to build the largest monotone number less than $n$. A kind of brute-force way to do that is\\n* take as many digits as we can from $n$\\n* if we can\\'t take the next digit from $n$ (because it\\'s lower than the prior digit), then we take the next lowest digit\\n* from there on we take the highest digit we can\\n\\n**NOTE:** there are more clever solutions that are smarter. They realized that the third bullet point is `<prefix><smallerDigit><rest>`. Since `smallerDigit < originalDigit` by definition (we subtract 1 at least), then ANY `<rest>` will produce a smaller number than $n$. We want the largest monotone number so they just fill `<rest>` with 9\\'s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nI used DFS + backtracking. The current state is `mono`, a list of monotonically nondecreasing digits that form the result.\\n\\nAt each index we try all digits that will produce a number `mono` that is less than or equal to `n`.\\n\\nIf we have taken all the digits of `n` so far, `mono[i]` must be less than or equal to `digits[i]`.\\n\\nIf we already decreased a prior digit, then we can take digits up to 9.\\n\\nTo quickly know if the prefix is the same or not, I have a `samePrefix: bool` variable that tracks this.\\n\\nWe use the prior digit as `dmin` so that we never try numbers less than `dmin`.\\n\\nFinally, if there\\'s no monotone number with the same number of digits (the top-level `dfs(0, True)` returns False), then we return the largest digits-1 number: all 9s.\\n\\n# Complexity\\n- Time complexity: $\\\\log(n)$\\n\\nWe work digit-by-digit. The DFS looks more complicated, as if we\\'ll potentially explore lots of numbers. So naively I would guess something more than $\\\\log(n)$.\\n\\nBut in practice, see the NOTE above. We\\'ll either take $n$ itself, or in $\\\\log(n)$ time find the index we decrement and fill the rest with 9s.\\n\\n- Space complexity:\\n\\n$\\\\log(n)$. Just a bunch of digits, and there are a logarithmic number of digits.\\n\\n# Code\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        # various cases:\\n        #    n is already monotone: return it\\n        #    there is an n-digit monotone number below: return it\\n        #    \\n\\n        # recursive solution, greedy dfs + backtracking\\n        # take as many digits as we can from n. if we can\\'t, then decrease a digit then return the max possible digits from there\\n        # example: 10\\n        #    take 1 -> 0 isn\\'t decreasing, no lower digit. return nothing\\n        #    taking 1 failed, can\\'t decrease to zero\\n        #    so we need an digits(n)-1 result - all 9s\\n\\n        # DFS + backtracking\\n\\n        digits = []\\n        r = n\\n        while r:\\n            digits.append(r % 10)\\n            r //= 10\\n        digits.reverse()\\n\\n        if all(digits[i] <= digits[i+1] for i in range(len(digits)-1)):\\n            return n\\n\\n        mono = []\\n\\n        def dfs(i: int, samePrefix: bool) -> bool:\\n            if i == len(digits):\\n                return True # found a solution\\n\\n            if samePrefix:\\n                dmax = digits[i]\\n            else:\\n                dmax = 9\\n\\n            if i == 0:\\n                dmin = 1\\n            else:\\n                dmin = mono[-1]\\n\\n            for d in range(dmax, dmin-1, -1):\\n                mono.append(d)\\n                if dfs(i+1, samePrefix and d == digits[i]):\\n                    return True\\n                else:\\n                    mono.pop()\\n\\n            return False\\n\\n        ndigit = dfs(0, True)\\n        if ndigit:\\n            r = 0\\n            for d in mono:\\n                r = r*10 + d\\n            return r\\n        else:\\n            return int(\\'9\\'*(len(digits)-1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        # various cases:\\n        #    n is already monotone: return it\\n        #    there is an n-digit monotone number below: return it\\n        #    \\n\\n        # recursive solution, greedy dfs + backtracking\\n        # take as many digits as we can from n. if we can\\'t, then decrease a digit then return the max possible digits from there\\n        # example: 10\\n        #    take 1 -> 0 isn\\'t decreasing, no lower digit. return nothing\\n        #    taking 1 failed, can\\'t decrease to zero\\n        #    so we need an digits(n)-1 result - all 9s\\n\\n        # DFS + backtracking\\n\\n        digits = []\\n        r = n\\n        while r:\\n            digits.append(r % 10)\\n            r //= 10\\n        digits.reverse()\\n\\n        if all(digits[i] <= digits[i+1] for i in range(len(digits)-1)):\\n            return n\\n\\n        mono = []\\n\\n        def dfs(i: int, samePrefix: bool) -> bool:\\n            if i == len(digits):\\n                return True # found a solution\\n\\n            if samePrefix:\\n                dmax = digits[i]\\n            else:\\n                dmax = 9\\n\\n            if i == 0:\\n                dmin = 1\\n            else:\\n                dmin = mono[-1]\\n\\n            for d in range(dmax, dmin-1, -1):\\n                mono.append(d)\\n                if dfs(i+1, samePrefix and d == digits[i]):\\n                    return True\\n                else:\\n                    mono.pop()\\n\\n            return False\\n\\n        ndigit = dfs(0, True)\\n        if ndigit:\\n            r = 0\\n            for d in mono:\\n                r = r*10 + d\\n            return r\\n        else:\\n            return int(\\'9\\'*(len(digits)-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806364,
                "title": "monotone-increasing-digits-by-python",
                "content": "# Intuition\\nTraverse the list from back of the list.\\nif [i-1] > [i]: [i-1]--, [i]=9\\n\\nCreate a variable to mark the chagne in the list.\\nChange all elements behind the variable to 9.\\n\\n# Code\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        n = list(str(n))\\n        # set a variable to mark the change in the list\\n        change = -1\\n        for i in range(len(n)-1, 0, -1):\\n            if int(n[i]) < int(n[i-1]):\\n                # change i and previous index in the list\\n                n[i-1] = str(int(n[i-1])-1)\\n                n[i] = \\'9\\'\\n                change = i\\n        # if no change in the list, return it directly\\n        if change == -1:\\n            return int(\\'\\'.join(n))\\n        # change all elements to 9 after the change index\\n        for j in range(change, len(n)):\\n            n[j] = \\'9\\'\\n\\n        return int(\\'\\'.join(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        n = list(str(n))\\n        # set a variable to mark the change in the list\\n        change = -1\\n        for i in range(len(n)-1, 0, -1):\\n            if int(n[i]) < int(n[i-1]):\\n                # change i and previous index in the list\\n                n[i-1] = str(int(n[i-1])-1)\\n                n[i] = \\'9\\'\\n                change = i\\n        # if no change in the list, return it directly\\n        if change == -1:\\n            return int(\\'\\'.join(n))\\n        # change all elements to 9 after the change index\\n        for j in range(change, len(n)):\\n            n[j] = \\'9\\'\\n\\n        return int(\\'\\'.join(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804862,
                "title": "java-easiest-solution-beginner-friendly-greedy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n                 int ans = 0;\\n                 String g;\\n    public int monotoneIncreasingDigits(int n) {\\n        \\n         if(n/10 == 0) return n;\\n         g = Integer.toString(n); \\n         int nm=Integer.parseInt(g.charAt(0)+\"\");\\n         for(int i=nm;i>=0;i--){\\n         if(rec(n , 1 , i , i)) return ans;\\n         }\\n         return ans;\\n    }\\n      public boolean rec(int n , int index , int num , int prev){\\n                 if(index >= g.length()){\\n                     if(num <= n) {ans = Math.max(ans , num);\\n                     return true;}\\n                     return false;\\n                 }\\n                for(int i=9 ;i>=prev ;i--){\\n                    if(rec(n , index+1 , num*10+i , i)) return true;\\n                }   \\n                return false;\\n      }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n                 int ans = 0;\\n                 String g;\\n    public int monotoneIncreasingDigits(int n) {\\n        \\n         if(n/10 == 0) return n;\\n         g = Integer.toString(n); \\n         int nm=Integer.parseInt(g.charAt(0)+\"\");\\n         for(int i=nm;i>=0;i--){\\n         if(rec(n , 1 , i , i)) return ans;\\n         }\\n         return ans;\\n    }\\n      public boolean rec(int n , int index , int num , int prev){\\n                 if(index >= g.length()){\\n                     if(num <= n) {ans = Math.max(ans , num);\\n                     return true;}\\n                     return false;\\n                 }\\n                for(int i=9 ;i>=prev ;i--){\\n                    if(rec(n , index+1 , num*10+i , i)) return true;\\n                }   \\n                return false;\\n      }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804019,
                "title": "simple-logic-application-backtracking",
                "content": "# Complexity\\n- Time complexity:\\nO(N) -> N is the number of digits in the given number.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    int[] arrDigits;\\n    int globalJ;\\n     \\n    public int MonotoneIncreasingDigits(int n)\\n    {\\n        int resNum = 0, i = 0, j = 1;\\n        globalJ = -1;\\n        List<int> ltDigits = new List<int>();\\n        while (n != 0)\\n        {\\n            ltDigits.Add(n % 10);\\n            n /= 10;\\n        }\\n\\n        ltDigits.Reverse();\\n        arrDigits = ltDigits.ToArray();\\n\\n        while (j < arrDigits.Length)\\n        {\\n            if (arrDigits[j] < arrDigits[i])\\n            {\\n                Backtrack(i);\\n                break;\\n            }\\n\\n            ++j;\\n            ++i;\\n        }\\n\\n        MakeAllDigits9();\\n        foreach (int d in arrDigits)\\n            resNum = resNum * 10 + d;\\n\\n        return resNum;\\n    }\\n\\n    private void Backtrack(int i)\\n    {\\n        arrDigits[i] -= 1;\\n        globalJ = i + 1;\\n        if (i == 0)\\n            return;\\n\\n        if (arrDigits[i] < arrDigits[i - 1])\\n        {\\n            Backtrack(i - 1);\\n            return;\\n        }\\n    }\\n\\n    private void MakeAllDigits9()\\n    {\\n        if (globalJ == -1)\\n            return;\\n\\n        while (globalJ < arrDigits.Length)\\n            arrDigits[globalJ++] = 9;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution\\n{\\n    int[] arrDigits;\\n    int globalJ;\\n     \\n    public int MonotoneIncreasingDigits(int n)\\n    {\\n        int resNum = 0, i = 0, j = 1;\\n        globalJ = -1;\\n        List<int> ltDigits = new List<int>();\\n        while (n != 0)\\n        {\\n            ltDigits.Add(n % 10);\\n            n /= 10;\\n        }\\n\\n        ltDigits.Reverse();\\n        arrDigits = ltDigits.ToArray();\\n\\n        while (j < arrDigits.Length)\\n        {\\n            if (arrDigits[j] < arrDigits[i])\\n            {\\n                Backtrack(i);\\n                break;\\n            }\\n\\n            ++j;\\n            ++i;\\n        }\\n\\n        MakeAllDigits9();\\n        foreach (int d in arrDigits)\\n            resNum = resNum * 10 + d;\\n\\n        return resNum;\\n    }\\n\\n    private void Backtrack(int i)\\n    {\\n        arrDigits[i] -= 1;\\n        globalJ = i + 1;\\n        if (i == 0)\\n            return;\\n\\n        if (arrDigits[i] < arrDigits[i - 1])\\n        {\\n            Backtrack(i - 1);\\n            return;\\n        }\\n    }\\n\\n    private void MakeAllDigits9()\\n    {\\n        if (globalJ == -1)\\n            return;\\n\\n        while (globalJ < arrDigits.Length)\\n            arrDigits[globalJ++] = 9;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788470,
                "title": "go-o-n-parsing-number-from-the-end-solution",
                "content": "# Approach\\nParsing a number from the end into digits and compare digits\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nfunc monotoneIncreasingDigits(n int) int {\\n\\tres := 0\\n\\treduceNextDigit := false\\n\\tresDigitsCount := 1\\n\\tfor n > 0 {\\n\\t\\tcurDigit := n % 10\\n\\t\\tif reduceNextDigit {\\n\\t\\t\\tcurDigit -= 1\\n\\t\\t\\treduceNextDigit = false\\n\\t\\t}\\n\\t\\tnextDigit := (n / 10) % 10\\n\\n\\t\\tif (curDigit >= nextDigit) || nextDigit == 0 {\\n\\t\\t\\tres = resDigitsCount*curDigit + res\\n\\t\\t} else {\\n\\t\\t\\tres = (resDigitsCount * 10) - 1\\n\\t\\t\\treduceNextDigit = true\\n\\t\\t}\\n\\n\\t\\tn /= 10\\n\\t\\tresDigitsCount *= 10\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc monotoneIncreasingDigits(n int) int {\\n\\tres := 0\\n\\treduceNextDigit := false\\n\\tresDigitsCount := 1\\n\\tfor n > 0 {\\n\\t\\tcurDigit := n % 10\\n\\t\\tif reduceNextDigit {\\n\\t\\t\\tcurDigit -= 1\\n\\t\\t\\treduceNextDigit = false\\n\\t\\t}\\n\\t\\tnextDigit := (n / 10) % 10\\n\\n\\t\\tif (curDigit >= nextDigit) || nextDigit == 0 {\\n\\t\\t\\tres = resDigitsCount*curDigit + res\\n\\t\\t} else {\\n\\t\\t\\tres = (resDigitsCount * 10) - 1\\n\\t\\t\\treduceNextDigit = true\\n\\t\\t}\\n\\n\\t\\tn /= 10\\n\\t\\tresDigitsCount *= 10\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3779646,
                "title": "c-solution-with-just-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThere are basically 2 things.\\n1) While loop (num) - is used to find where exactly we have a case of non monotone. ie whee y>x\\n2) So in case the flag isn\\'t true and its not monotone. The last monotone(upto the checked number) would be corrected by multiplying it by multiples of 10 and -1 in it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int monotoneIncreasingDigits(int n)\\n        {\\n            int num,output = n;\\n            int count,temp;\\n            bool flag = false;\\n            if (n == 0)\\n            {\\n                return 0;\\n            }\\n            while (!flag)\\n            {\\n                output = num;\\n                count = 0;\\n                temp = num % 10;\\n                while (num)\\n                {\\n                    num = num / 10;\\n                    if (num % 10 > temp)\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                    temp = num % 10;\\n                    count++;\\n                    flag = true;\\n                }\\n                if (!flag)\\n                {\\n                    num = (num) * (pow(10, count + 1)) - 1;\\n                }\\n            }\\n            return output;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int monotoneIncreasingDigits(int n)\\n        {\\n            int num,output = n;\\n            int count,temp;\\n            bool flag = false;\\n            if (n == 0)\\n            {\\n                return 0;\\n            }\\n            while (!flag)\\n            {\\n                output = num;\\n                count = 0;\\n                temp = num % 10;\\n                while (num)\\n                {\\n                    num = num / 10;\\n                    if (num % 10 > temp)\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                    temp = num % 10;\\n                    count++;\\n                    flag = true;\\n                }\\n                if (!flag)\\n                {\\n                    num = (num) * (pow(10, count + 1)) - 1;\\n                }\\n            }\\n            return output;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769245,
                "title": "cpp-backtracking-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void backtrack(string str,int index,string temp,string&answer){\\n\\n          if( stoi(temp) > stoi(str)){\\n              return; \\n          }\\n\\n         if(index==str.size()){\\n             answer= temp; \\n             return; \\n         }\\n\\n\\n         for(int i{9};i>= str[index-1]-\\'0\\';i--){\\n\\n             char idk= temp[index]; \\n             temp[index]= \\'0\\'+i;\\n             backtrack(str,index+1,temp,answer); \\n             temp[index]=idk; \\n             if(answer.size()!=0){ return; }\\n         }\\n      \\n        return; \\n\\n    }\\n\\n    int monotoneIncreasingDigits(int n) {\\n\\n        string str= to_string(n); \\n        int first= stoi( str.substr(0,1));\\n        string answer=\"\";\\n\\n        for(int i{first};i>=0;i--){\\n \\n          string temp= str; \\n          temp[0]= \\'0\\'+i;  \\n        \\n           \\n         backtrack(str,1,temp,answer);\\n         if(answer.size()!=0){ break; }\\n\\n        }\\n        \\n        return stoi(answer); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void backtrack(string str,int index,string temp,string&answer){\\n\\n          if( stoi(temp) > stoi(str)){\\n              return; \\n          }\\n\\n         if(index==str.size()){\\n             answer= temp; \\n             return; \\n         }\\n\\n\\n         for(int i{9};i>= str[index-1]-\\'0\\';i--){\\n\\n             char idk= temp[index]; \\n             temp[index]= \\'0\\'+i;\\n             backtrack(str,index+1,temp,answer); \\n             temp[index]=idk; \\n             if(answer.size()!=0){ return; }\\n         }\\n      \\n        return; \\n\\n    }\\n\\n    int monotoneIncreasingDigits(int n) {\\n\\n        string str= to_string(n); \\n        int first= stoi( str.substr(0,1));\\n        string answer=\"\";\\n\\n        for(int i{first};i>=0;i--){\\n \\n          string temp= str; \\n          temp[0]= \\'0\\'+i;  \\n        \\n           \\n         backtrack(str,1,temp,answer);\\n         if(answer.size()!=0){ break; }\\n\\n        }\\n        \\n        return stoi(answer); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763236,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def monotoneIncreasingDigits(n: Int): Int = {\\n      def solve(st: Int, cur: Long, max: Int): Long = \\n        if (cur > max) 0\\n        else (st to 9).foldLeft(cur){(acc, i) => math.max(solve(i, 10 * cur + i, max), acc)}\\n\\n      solve(1, 0, n).toInt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def monotoneIncreasingDigits(n: Int): Int = {\\n      def solve(st: Int, cur: Long, max: Int): Long = \\n        if (cur > max) 0\\n        else (st to 9).foldLeft(cur){(acc, i) => math.max(solve(i, 10 * cur + i, max), acc)}\\n\\n      solve(1, 0, n).toInt\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3714537,
                "title": "masum-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s=to_string(n);\\n        int i=1;\\n        int N=s.size();\\n        while(i<N && s[i]>=s[i-1])\\n        {\\n            i++;\\n        }\\n        if(i<N)\\n        {\\n            while(i>0 && s[i]<s[i-1])\\n            {\\n                i--;\\n                s[i]--;\\n            }\\n\\n           for(int j=i+1;j<N;j++)\\n           {\\n               s[j]=\\'9\\';\\n           }\\n        }\\n        return stoi(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s=to_string(n);\\n        int i=1;\\n        int N=s.size();\\n        while(i<N && s[i]>=s[i-1])\\n        {\\n            i++;\\n        }\\n        if(i<N)\\n        {\\n            while(i>0 && s[i]<s[i-1])\\n            {\\n                i--;\\n                s[i]--;\\n            }\\n\\n           for(int j=i+1;j<N;j++)\\n           {\\n               s[j]=\\'9\\';\\n           }\\n        }\\n        return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709014,
                "title": "easy-greedy-solution-c",
                "content": "# Intuition\\nUse simple greedy\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind the last index where first digit greater than second digit\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        if(n<=9){\\n            return n;\\n        }\\n        string s=to_string(n);\\n        int i=0;\\n        for(i=0;i<s.length()-1;i++){\\n            if(s[i]>s[i+1]){\\n               break;\\n            }\\n        }\\n        if(i==s.length()-1){\\n            return n;\\n        }\\n        else{\\n           int j=i;\\n           while(j>=0 && s[j]==s[i]){\\n               j--;\\n           }\\n           s[j+1]--;\\n           j++;\\n            for(int k=j+1;k<s.length();k++){\\n                s[k]=\\'9\\';\\n            }\\n        }\\n        return stoi(s);\\n    }\\n};\\n**************************PLEASE UPVOTE IF FOUND USEFUL********\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        if(n<=9){\\n            return n;\\n        }\\n        string s=to_string(n);\\n        int i=0;\\n        for(i=0;i<s.length()-1;i++){\\n            if(s[i]>s[i+1]){\\n               break;\\n            }\\n        }\\n        if(i==s.length()-1){\\n            return n;\\n        }\\n        else{\\n           int j=i;\\n           while(j>=0 && s[j]==s[i]){\\n               j--;\\n           }\\n           s[j+1]--;\\n           j++;\\n            for(int k=j+1;k<s.length();k++){\\n                s[k]=\\'9\\';\\n            }\\n        }\\n        return stoi(s);\\n    }\\n};\\n**************************PLEASE UPVOTE IF FOUND USEFUL********\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699216,
                "title": "simple-observational-approach-greedy-c",
                "content": "# Intuition\\nObservation based question. Nothing more, since n is from 1 to 1e9, we need to be strictly in o(n) no exceeding more than that.\\n\\n# Approach\\nThe problem arises when only the current digit is smaller than previous one. Start a loop from backwards check for this condition if such one arises, keep track of its idx and decrement the previous digit. When fully traversed start from idx to last element mark all digits as 9. This would be final ans.\\n\\n# Complexity\\n- Time complexity:\\n  O(no of digits)\\n\\n- Space complexity:\\n   o(no of digits)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) \\n    {\\n       string t=to_string(n);\\n       \\n       int idx=-1;\\n       for(int i=t.size()-1;i>0;i--)\\n       {\\n           if(t[i-1]>t[i])\\n            idx=i,t[i-1]--;\\n       }\\n       for(int i=idx;i<t.size();i++)\\n        t[i]=\\'9\\';\\n\\n        return stoi(t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) \\n    {\\n       string t=to_string(n);\\n       \\n       int idx=-1;\\n       for(int i=t.size()-1;i>0;i--)\\n       {\\n           if(t[i-1]>t[i])\\n            idx=i,t[i-1]--;\\n       }\\n       for(int i=idx;i<t.size();i++)\\n        t[i]=\\'9\\';\\n\\n        return stoi(t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696615,
                "title": "beats-100-runtime-0ms-easy-logic-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string nums= to_string(n); \\n    jump:\\n        for(int i=0; i<nums.length()-1;i++){\\n            if(nums[i]<=nums[i+1]) continue;\\n            else{\\n                nums[i]=nums[i]-1;\\n                for(int j=i; j<nums.length()-1;j++){\\n                    nums[j+1]=\\'9\\';\\n                }\\n                goto jump;\\n            }\\n        }\\n\\n        return stoi(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string nums= to_string(n); \\n    jump:\\n        for(int i=0; i<nums.length()-1;i++){\\n            if(nums[i]<=nums[i+1]) continue;\\n            else{\\n                nums[i]=nums[i]-1;\\n                for(int j=i; j<nums.length()-1;j++){\\n                    nums[j+1]=\\'9\\';\\n                }\\n                goto jump;\\n            }\\n        }\\n\\n        return stoi(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689238,
                "title": "c-easy-solution-stack-optimal-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //using Stack \\n    //TC=O(NlogN)+O(N)\\n    //SC=O(N)+O(N)\\n    int monotoneIncreasingDigits(int n) {\\n        //edge case\\n        if(n==0){\\n            return 0;\\n        }\\n        vector<int> s;\\n        while(n>0){\\n            s.push_back(n%10);\\n            n/=10;\\n        }\\n\\n        reverse(s.begin(),s.end());\\n        stack<int> st;\\n        for(int i=0;i<s.size()-1;i++){\\n            if((s[i])>(s[i+1])){\\n                if(!st.empty() && (s[st.top()])!=(s[i])){\\n                    int temp=s[i];\\n                    temp--;\\n                    s[i]=(temp);\\n                    for(int j=i+1;j<s.size();j++){\\n                        s[j]=9;\\n                    }\\n                    break;\\n                }\\n                while(st.size()>=1 && (s[i])==(s[st.top()])){\\n                    st.pop();\\n                }\\n                 \\n                if(st.empty()){\\n                    int temp=s[0];\\n                    temp--;\\n                    s[0]=(temp);\\n                    for(int j=1;j<s.size();j++){\\n                        s[j]=9;\\n                    }\\n                    break;\\n                }\\n                else{\\n                    int temp=(s[st.top()+1]);\\n                    temp--;\\n                    s[st.top()+1]=(temp);\\n                    cout<<s[st.top()+1]<<endl;\\n                    for(int j=st.top()+2;j<s.size();j++){\\n                        s[j]=9;\\n                    }\\n                    break;\\n                }\\n                \\n            }\\n            st.push(i);\\n        }        \\n        int no=0;\\n        for(int j=0;j<s.size();j++){\\n            no=no*10+(s[j]);\\n        }\\n        return no;\\n    }\\n};\\n```\\n# Author: Jayesh Badgujar\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //using Stack \\n    //TC=O(NlogN)+O(N)\\n    //SC=O(N)+O(N)\\n    int monotoneIncreasingDigits(int n) {\\n        //edge case\\n        if(n==0){\\n            return 0;\\n        }\\n        vector<int> s;\\n        while(n>0){\\n            s.push_back(n%10);\\n            n/=10;\\n        }\\n\\n        reverse(s.begin(),s.end());\\n        stack<int> st;\\n        for(int i=0;i<s.size()-1;i++){\\n            if((s[i])>(s[i+1])){\\n                if(!st.empty() && (s[st.top()])!=(s[i])){\\n                    int temp=s[i];\\n                    temp--;\\n                    s[i]=(temp);\\n                    for(int j=i+1;j<s.size();j++){\\n                        s[j]=9;\\n                    }\\n                    break;\\n                }\\n                while(st.size()>=1 && (s[i])==(s[st.top()])){\\n                    st.pop();\\n                }\\n                 \\n                if(st.empty()){\\n                    int temp=s[0];\\n                    temp--;\\n                    s[0]=(temp);\\n                    for(int j=1;j<s.size();j++){\\n                        s[j]=9;\\n                    }\\n                    break;\\n                }\\n                else{\\n                    int temp=(s[st.top()+1]);\\n                    temp--;\\n                    s[st.top()+1]=(temp);\\n                    cout<<s[st.top()+1]<<endl;\\n                    for(int j=st.top()+2;j<s.size();j++){\\n                        s[j]=9;\\n                    }\\n                    break;\\n                }\\n                \\n            }\\n            st.push(i);\\n        }        \\n        int no=0;\\n        for(int j=0;j<s.size();j++){\\n            no=no*10+(s[j]);\\n        }\\n        return no;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3676647,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n    string s = to_string(n);\\n    int index = s.length();\\n\\n    for (int i = s.length() - 1; i > 0; i--) {\\n        if (s[i] < s[i - 1]) {\\n            index = i - 1;\\n            s[index]--;\\n        }\\n    }\\n\\n    for (int i = index + 1; i < s.length(); i++) {\\n        s[i] = \\'9\\';\\n    }\\n\\n    return stoi(s);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n    string s = to_string(n);\\n    int index = s.length();\\n\\n    for (int i = s.length() - 1; i > 0; i--) {\\n        if (s[i] < s[i - 1]) {\\n            index = i - 1;\\n            s[index]--;\\n        }\\n    }\\n\\n    for (int i = index + 1; i < s.length(); i++) {\\n        s[i] = \\'9\\';\\n    }\\n\\n    return stoi(s);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671106,
                "title": "u-turn",
                "content": "**time: `O(1)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/0b2811c0-f27e-4d21-b991-9cc3c1eac748_1687468281.6927447.png)\\n\\n```\\nint monotoneIncreasingDigits(int n)\\n{\\n\\tauto s = to_string(n);\\n\\tfor(int i{}; i+1<size(s); ++i)\\n\\t\\tif(s[i]>s[i+1])\\n\\t\\t{\\n\\t\\t\\tfor( ; i and s[i]==s[i-1]; --i);\\n\\t\\t\\t--s[i];\\n\\t\\t\\tfill(begin(s)+i+1, end(s), \\'9\\');\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\treturn stoi(s);\\n}\\n```\\nI call this time of algorithm: U-turn (or There and Back Again). You traverse the array to find something, then you go back to find something else. After that you do something with obtained info and return.\\n**Another example of U-turn algo:**\\n[31. Next Permutation](https://leetcode.com/problems/next-permutation/discuss/3415522/findswapreverse?currentPage=1&orderBy=most_relevant&query=android)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint monotoneIncreasingDigits(int n)\\n{\\n\\tauto s = to_string(n);\\n\\tfor(int i{}; i+1<size(s); ++i)\\n\\t\\tif(s[i]>s[i+1])\\n\\t\\t{\\n\\t\\t\\tfor( ; i and s[i]==s[i-1]; --i);\\n\\t\\t\\t--s[i];\\n\\t\\t\\tfill(begin(s)+i+1, end(s), \\'9\\');\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\treturn stoi(s);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665777,
                "title": "easy-understanding-python-100-time-solution",
                "content": "# Complexity\\n- Time complexity:\\n        O(d^2) where d = number of digits of n \\n- Space complexity:\\n        O(d) where d= number of digits of n\\n\\n# Code\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        def makeNine(ind):\\n            for i in range(ind,len(s)):\\n                s[i]=\\'9\\'\\n        s=list(str(n))\\n        //traversing the list of the digits in reverse\\n        for i in range(len(s)-2,-1,-1):\\n            if s[i]>s[i+1]:\\n                s[i]=str(int(s[i])-1)\\n                //all the digits after i is made equal to 9\\n                makeNine(i+1)\\n        return int(\"\".join(s))\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        def makeNine(ind):\\n            for i in range(ind,len(s)):\\n                s[i]=\\'9\\'\\n        s=list(str(n))\\n        //traversing the list of the digits in reverse\\n        for i in range(len(s)-2,-1,-1):\\n            if s[i]>s[i+1]:\\n                s[i]=str(int(s[i])-1)\\n                //all the digits after i is made equal to 9\\n                makeNine(i+1)\\n        return int(\"\".join(s))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651111,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        int p = s.size(), lim = s.size();\\n        for(int i=p-1;i>0;i--){\\n            if(s[i-1]>s[i])\\n            {\\n                lim = i;\\n                s[i-1]-=1;\\n            }\\n        }\\n        for(int i=lim; i<p; i++) s[i] = \\'9\\';\\n        return stoi(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        int p = s.size(), lim = s.size();\\n        for(int i=p-1;i>0;i--){\\n            if(s[i-1]>s[i])\\n            {\\n                lim = i;\\n                s[i-1]-=1;\\n            }\\n        }\\n        for(int i=lim; i<p; i++) s[i] = \\'9\\';\\n        return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650671,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MonotoneIncreasingDigits(int n)\\n    {\\n        var idx = 11;\\n        var list = new List<int>();\\n        while (n > 0)\\n        {\\n            list.Insert(0, n % 10);\\n            n /= 10;\\n        }\\n\\n        for (int i = 1; i < list.Count && idx == 11; i++)\\n        {\\n            if (list[i] < list[i - 1])\\n            {\\n                for (int j = i - 1; j >= 0 && list[j] > list[j + 1]; j--)\\n                {\\n                    list[j] -= 1;\\n                    idx = j + 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < list.Count; i++)\\n        {\\n            if (i >= idx)\\n                n = n * 10 + 9;\\n            else\\n                n = n * 10 + list[i];\\n        }\\n\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MonotoneIncreasingDigits(int n)\\n    {\\n        var idx = 11;\\n        var list = new List<int>();\\n        while (n > 0)\\n        {\\n            list.Insert(0, n % 10);\\n            n /= 10;\\n        }\\n\\n        for (int i = 1; i < list.Count && idx == 11; i++)\\n        {\\n            if (list[i] < list[i - 1])\\n            {\\n                for (int j = i - 1; j >= 0 && list[j] > list[j + 1]; j--)\\n                {\\n                    list[j] -= 1;\\n                    idx = j + 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < list.Count; i++)\\n        {\\n            if (i >= idx)\\n                n = n * 10 + 9;\\n            else\\n                n = n * 10 + list[i];\\n        }\\n\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614564,
                "title": "java-greedy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        if (n < 10) return n;\\n        List<Integer> list = new ArrayList<>();\\n        while (n > 0) {\\n            list.add(n % 10);\\n            n /= 10;\\n        }\\n        Collections.reverse(list);\\n        int idx = list.size() - 1;\\n        while (!isMonotoneIncreasing(list)) {\\n            for (int i = 0; i < list.size() - 1; i++) {\\n                if (list.get(i) > list.get(i + 1)) {\\n                    idx = i;\\n                    break;\\n                }\\n            }\\n            list.set(idx, list.get(idx) - 1);\\n            for (int i = idx + 1; i < list.size(); i++) {\\n                if (list.get(i) != 9) list.set(i, 9);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < list.size(); i++) sb.append(list.get(i));\\n        return Integer.parseInt(sb.toString());\\n    }\\n\\n    private boolean isMonotoneIncreasing(List<Integer> list) {\\n        for (int i = 0; i < list.size() - 1; i++) if (list.get(i) > list.get(i + 1)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        if (n < 10) return n;\\n        List<Integer> list = new ArrayList<>();\\n        while (n > 0) {\\n            list.add(n % 10);\\n            n /= 10;\\n        }\\n        Collections.reverse(list);\\n        int idx = list.size() - 1;\\n        while (!isMonotoneIncreasing(list)) {\\n            for (int i = 0; i < list.size() - 1; i++) {\\n                if (list.get(i) > list.get(i + 1)) {\\n                    idx = i;\\n                    break;\\n                }\\n            }\\n            list.set(idx, list.get(idx) - 1);\\n            for (int i = idx + 1; i < list.size(); i++) {\\n                if (list.get(i) != 9) list.set(i, 9);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < list.size(); i++) sb.append(list.get(i));\\n        return Integer.parseInt(sb.toString());\\n    }\\n\\n    private boolean isMonotoneIncreasing(List<Integer> list) {\\n        for (int i = 0; i < list.size() - 1; i++) if (list.get(i) > list.get(i + 1)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610731,
                "title": "a-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MonotoneIncreasingDigits(int n) {\\n        var list = new List<int>();\\n        int pos = -1, original = n;\\n        while(n >= 10)\\n        {\\n            list.Insert(0, n % 10);\\n            n /= 10;\\n        }\\n        list.Insert(0, n);\\n        for (int i = 0; i < list.Count - 1; i++)\\n        {\\n            if (list[i] > list[i + 1])\\n            {\\n                pos = i; break;\\n            }\\n        }\\n        if (pos == -1) return original;\\n        int res = 0;\\n         bool found = false;\\n                for (int i = 0; i < list.Count; i++)\\n                {\\n                    if (found)\\n                     res = res * 10 + 9;\\n                    else\\n                    {\\n                        if (list[i] == list[pos]) { list[i]--; found = true; }\\n                        res = res * 10 + list[i];\\n                    }                        \\n                }\\n                return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MonotoneIncreasingDigits(int n) {\\n        var list = new List<int>();\\n        int pos = -1, original = n;\\n        while(n >= 10)\\n        {\\n            list.Insert(0, n % 10);\\n            n /= 10;\\n        }\\n        list.Insert(0, n);\\n        for (int i = 0; i < list.Count - 1; i++)\\n        {\\n            if (list[i] > list[i + 1])\\n            {\\n                pos = i; break;\\n            }\\n        }\\n        if (pos == -1) return original;\\n        int res = 0;\\n         bool found = false;\\n                for (int i = 0; i < list.Count; i++)\\n                {\\n                    if (found)\\n                     res = res * 10 + 9;\\n                    else\\n                    {\\n                        if (list[i] == list[pos]) { list[i]--; found = true; }\\n                        res = res * 10 + list[i];\\n                    }                        \\n                }\\n                return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608511,
                "title": "c-easy-approach-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert the integer to string, then it\\'s easy to find the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution \\n{\\npublic:\\n    int monotoneIncreasingDigits(int n) \\n    {\\n       \\n        string str = std::to_string(n);\\n        if (isMonotone(str))\\n        {\\n            return n;\\n        }\\n        int length = str.length();\\n        int idx = -1;\\n\\n        for (int i = length - 1; i > 0; --i) \\n        {\\n            if (str[i] < str[i - 1]) \\n            {\\n                idx = i - 1;\\n                --str[idx];\\n            }\\n        }\\n\\n        for (int i = idx + 1; i < length; ++i) \\n        {\\n            str[i] = \\'9\\';\\n        }\\n\\n        return stoi(str);\\n    }\\n\\nprivate:\\n    bool isMonotone(string& num)\\n    {\\n        int n = num.length();\\n        for (int i=0; i<n-1; ++i)\\n        {\\n            if (num[i + 1] < num[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution \\n{\\npublic:\\n    int monotoneIncreasingDigits(int n) \\n    {\\n       \\n        string str = std::to_string(n);\\n        if (isMonotone(str))\\n        {\\n            return n;\\n        }\\n        int length = str.length();\\n        int idx = -1;\\n\\n        for (int i = length - 1; i > 0; --i) \\n        {\\n            if (str[i] < str[i - 1]) \\n            {\\n                idx = i - 1;\\n                --str[idx];\\n            }\\n        }\\n\\n        for (int i = idx + 1; i < length; ++i) \\n        {\\n            str[i] = \\'9\\';\\n        }\\n\\n        return stoi(str);\\n    }\\n\\nprivate:\\n    bool isMonotone(string& num)\\n    {\\n        int n = num.length();\\n        for (int i=0; i<n-1; ++i)\\n        {\\n            if (num[i + 1] < num[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3586335,
                "title": "go-algo-overkill",
                "content": "```\\nfunc monotoneIncreasingDigits(n int) int {\\n    digits := getDigits(n)\\n    \\n    for start := breakIndex(digits); start != -1; start = breakIndex(digits) {\\n        decrement(start, digits)\\n    }\\n\\n    return getNum(digits)\\n}\\n\\nfunc decrement(start int, digits []int) {\\n    for i := start; i < len(digits); i++ {\\n        digits[i] = 9\\n    }\\n}\\n\\nfunc breakIndex(digits []int) int {\\n    start := -1\\n\\n    for i := 0; i < len(digits) - 1; i++ {\\n        if digits[i] > digits[i + 1] {\\n            digits[i]--\\n            start = i + 1\\n            break\\n        }\\n    }\\n\\n    return start\\n}\\n\\nfunc getDigits(n int) []int {\\n    digits := []int{}\\n\\n    for ; n != 0; n /= 10 {\\n        digits = append(digits, n % 10)\\n    }\\n\\n    for i, j := 0, len(digits) - 1; i < j; i, j = i + 1, j - 1 {\\n        digits[i], digits[j] = digits[j], digits[i]\\n    }\\n\\n    return digits\\n}\\n\\nfunc getNum(digits []int) int {\\n    num := 0\\n\\n    for i := 0; i < len(digits); i++ {\\n        num *= 10\\n        num += digits[i]\\n    }\\n\\n    return num\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc monotoneIncreasingDigits(n int) int {\\n    digits := getDigits(n)\\n    \\n    for start := breakIndex(digits); start != -1; start = breakIndex(digits) {\\n        decrement(start, digits)\\n    }\\n\\n    return getNum(digits)\\n}\\n\\nfunc decrement(start int, digits []int) {\\n    for i := start; i < len(digits); i++ {\\n        digits[i] = 9\\n    }\\n}\\n\\nfunc breakIndex(digits []int) int {\\n    start := -1\\n\\n    for i := 0; i < len(digits) - 1; i++ {\\n        if digits[i] > digits[i + 1] {\\n            digits[i]--\\n            start = i + 1\\n            break\\n        }\\n    }\\n\\n    return start\\n}\\n\\nfunc getDigits(n int) []int {\\n    digits := []int{}\\n\\n    for ; n != 0; n /= 10 {\\n        digits = append(digits, n % 10)\\n    }\\n\\n    for i, j := 0, len(digits) - 1; i < j; i, j = i + 1, j - 1 {\\n        digits[i], digits[j] = digits[j], digits[i]\\n    }\\n\\n    return digits\\n}\\n\\nfunc getNum(digits []int) int {\\n    num := 0\\n\\n    for i := 0; i < len(digits); i++ {\\n        num *= 10\\n        num += digits[i]\\n    }\\n\\n    return num\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3560942,
                "title": "python-greedy-easy",
                "content": "A few example to build an idea:\\nI should have done it (and I could succeed) but i didn\\'t and failed.\\n```\\n9 -> 9(V)\\n3 -> 3(V)\\n10 -> 10(X) -> 09(V) - remember this\\n\\n25 -> 25(V)\\n24 -> 24(V)\\n23 -> 23(V)\\n22 -> 22(V)\\n21 -> 21(X) -> 20(X) -> 19(V) - remember this\\n\\n32 -> 32(X) -> 31(X) -> 30(X) -> 29(V) - remember this\\n\\n101 -> 101(X) -> 100(X) -> 099(V) - remember this\\n\\n332 -> 332(X) -> ... -> 300(X) -> 299(V) - remember this\\n```\\nBy observing these examples, where `X` - means invalid and `V` - valid we can see the following pattern:\\nWhen `d[i - 1] > d[i]` we `d[i - 1] -= 1` and `d[i...N] = 9`\\n\\nGoing right-to-left and we have our greedy algo.\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        nums = list(str(n))\\n        N = len(nums)\\n        for i in reversed(range(N - 1)):\\n            if nums[i] > nums[i + 1]:\\n                nums[i] = chr(ord(nums[i]) - 1)\\n                for j in range(i + 1, N):\\n                    nums[j] = \\'9\\'\\n        \\n        return int(\\'\\'.join(nums))\\n```\\n\\nAnother interesting idea is instead of filling rest with `9` we can leave `d[i - 1]` as is and fill the rest with `0`.\\nLater when building the final number we can just do `num - 1` to get the same `...999`.\\nE.g. `3332 -> 3330 -> 3300 -> 3000 - 1 -> 2999`\\n\\nWant left-to-right approach?\\nTry the example:\\n```\\n3332 -> 3329 -> 3299 -> 2999\\n```\\n\\nCheers!\\n*Need to enforce myself to write brute force and examples.*",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n9 -> 9(V)\\n3 -> 3(V)\\n10 -> 10(X) -> 09(V) - remember this\\n\\n25 -> 25(V)\\n24 -> 24(V)\\n23 -> 23(V)\\n22 -> 22(V)\\n21 -> 21(X) -> 20(X) -> 19(V) - remember this\\n\\n32 -> 32(X) -> 31(X) -> 30(X) -> 29(V) - remember this\\n\\n101 -> 101(X) -> 100(X) -> 099(V) - remember this\\n\\n332 -> 332(X) -> ... -> 300(X) -> 299(V) - remember this\\n```\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        nums = list(str(n))\\n        N = len(nums)\\n        for i in reversed(range(N - 1)):\\n            if nums[i] > nums[i + 1]:\\n                nums[i] = chr(ord(nums[i]) - 1)\\n                for j in range(i + 1, N):\\n                    nums[j] = \\'9\\'\\n        \\n        return int(\\'\\'.join(nums))\\n```\n```\\n3332 -> 3329 -> 3299 -> 2999\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553634,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        \\n        string num = to_string(n);\\n        int l = num.size();\\n        \\n        while(true){\\n            bool flag = false;\\n            for(int i=0; i<l-1;i++){\\n                if(num[i] <= num[i+1])\\n                continue;\\n                else{\\n                    for(int j=i+1; j<l; j++)\\n                    num[j]=\\'9\\';\\n\\n                    num[i] = char(num[i]-1);\\n                    flag = true;\\n                }\\n            }\\n            if(!flag)\\n            break;\\n        }\\n\\n        return stoi(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        \\n        string num = to_string(n);\\n        int l = num.size();\\n        \\n        while(true){\\n            bool flag = false;\\n            for(int i=0; i<l-1;i++){\\n                if(num[i] <= num[i+1])\\n                continue;\\n                else{\\n                    for(int j=i+1; j<l; j++)\\n                    num[j]=\\'9\\';\\n\\n                    num[i] = char(num[i]-1);\\n                    flag = true;\\n                }\\n            }\\n            if(!flag)\\n            break;\\n        }\\n\\n        return stoi(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544452,
                "title": "my-easy-intuitive-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere N is the length of the string after conversion\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n  // but the concept is first start from right and move leftwards and wherever\\n  // we find s[j-1]>s[j] just decrement s[j-1] by one ... do this till leftmost \\n  // possible index and from this index, make all numbers 9 (to the right from the leftmost index)\\n  // ex :- 125432 then start from 2 and make this 125432->125422->125322->124322 now index 2(i.e.,4) \\n  // is the leftmost possible index here so make values of index from(2+1 to n-1)->124999 final ans\\n  int monotoneIncreasingDigits(int n) {\\n      string s = to_string(n);\\n      int i=s.size()-1;\\n      for(int j=i;j>=1;j--) {\\n          if(s[j-1]>s[j]){\\n              s[j-1] -= 1;\\n              i = j-1;\\n          }\\n      }\\n\\n      for(int j=i+1;j<s.size();j++) s[j] = \\'9\\';\\n\\n      return stoi(s);\\n  }\\n\\n\\n//  // method 1 \\n//     int monotoneIncreasingDigits(int n) {\\n//         string s = to_string(n);\\n//         string ans=\"\";\\n\\n//         for(int i=0;i<s.size();i++){\\n//             ans.push_back(s[i]);\\n//             int j = ans.size()-1;\\n\\n//             while(j && ans[j-1]>ans[j]) {\\n//                 if(s[j-1]==ans[j-1])ans[j-1] -= 1; // ye if condition is imp\\n//                 // see this ex n=100... ans should be 99 but without if ans =89\\n//                 ans[j] = \\'9\\';\\n//                 j--;\\n//             }\\n//         }\\n//         return stoi(ans);\\n//     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  // but the concept is first start from right and move leftwards and wherever\\n  // we find s[j-1]>s[j] just decrement s[j-1] by one ... do this till leftmost \\n  // possible index and from this index, make all numbers 9 (to the right from the leftmost index)\\n  // ex :- 125432 then start from 2 and make this 125432->125422->125322->124322 now index 2(i.e.,4) \\n  // is the leftmost possible index here so make values of index from(2+1 to n-1)->124999 final ans\\n  int monotoneIncreasingDigits(int n) {\\n      string s = to_string(n);\\n      int i=s.size()-1;\\n      for(int j=i;j>=1;j--) {\\n          if(s[j-1]>s[j]){\\n              s[j-1] -= 1;\\n              i = j-1;\\n          }\\n      }\\n\\n      for(int j=i+1;j<s.size();j++) s[j] = \\'9\\';\\n\\n      return stoi(s);\\n  }\\n\\n\\n//  // method 1 \\n//     int monotoneIncreasingDigits(int n) {\\n//         string s = to_string(n);\\n//         string ans=\"\";\\n\\n//         for(int i=0;i<s.size();i++){\\n//             ans.push_back(s[i]);\\n//             int j = ans.size()-1;\\n\\n//             while(j && ans[j-1]>ans[j]) {\\n//                 if(s[j-1]==ans[j-1])ans[j-1] -= 1; // ye if condition is imp\\n//                 // see this ex n=100... ans should be 99 but without if ans =89\\n//                 ans[j] = \\'9\\';\\n//                 j--;\\n//             }\\n//         }\\n//         return stoi(ans);\\n//     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521203,
                "title": "java-o-n-simple-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Convert Number into integer array\\n2. Start from i=n-2 index to compare it with i+1 index\\n3. if i+1 index is larger than i, then keep iterating\\n4. if i+1 index is smaller than i, then it is not monotonic increasing\\n5. to make it increasing , make the cuurent index i.e i decrease by 1 and rest of the numbers after i index must be set to 9 as we are looking for largest number <=n.\\n6. keep finding last point where arr[i]>arr[i+1] in temp idx variable by storing i+1 as idx.\\n7. now, we have idx from where we have to set value to 9 for all remaining indexes.\\n8. Convert result integer array into result integer.\\n\\n# Complexity\\n- Time complexity:\\nBIG O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        \\n\\n\\n    public int monotoneIncreasingDigits(int n) {\\n\\n       \\n        char[] last=String.valueOf(n).toCharArray();\\n        int[] arr=new int[last.length];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=Character.getNumericValue(last[i]);\\n        }\\n        int idx=-1;\\n        for(int j=arr.length-2;j>=0;j--){\\n            if(arr[j]>arr[j+1]){\\n                arr[j]=arr[j]-1;\\n                idx=j+1;\\n            }\\n        }\\n        if(idx==-1)\\n         return n;\\n        for(int i=idx;i<arr.length;i++)\\n         arr[i]=9;\\n\\n         String res=\"\";\\n         for(int i=0;i<arr.length;i++){\\n             res=res+arr[i];\\n         }\\n         int result=Integer.parseInt(res);\\n         return result;\\n\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        \\n\\n\\n    public int monotoneIncreasingDigits(int n) {\\n\\n       \\n        char[] last=String.valueOf(n).toCharArray();\\n        int[] arr=new int[last.length];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=Character.getNumericValue(last[i]);\\n        }\\n        int idx=-1;\\n        for(int j=arr.length-2;j>=0;j--){\\n            if(arr[j]>arr[j+1]){\\n                arr[j]=arr[j]-1;\\n                idx=j+1;\\n            }\\n        }\\n        if(idx==-1)\\n         return n;\\n        for(int i=idx;i<arr.length;i++)\\n         arr[i]=9;\\n\\n         String res=\"\";\\n         for(int i=0;i<arr.length;i++){\\n             res=res+arr[i];\\n         }\\n         int result=Integer.parseInt(res);\\n         return result;\\n\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481214,
                "title": "monotone-increasing-digits",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int num) {\\n    string s = to_string(num);\\n    int n = s.size();\\n    int k = n;\\n\\n    for (int i = n - 1; i > 0; --i){\\n      if (s[i] < s[i - 1]) {\\n        --s[i - 1];\\n        k = i;\\n      }\\n    }\\n    for (int i = k; i < n; ++i)\\n      s[i] = \\'9\\';\\n\\n    return stoi(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int num) {\\n    string s = to_string(num);\\n    int n = s.size();\\n    int k = n;\\n\\n    for (int i = n - 1; i > 0; --i){\\n      if (s[i] < s[i - 1]) {\\n        --s[i - 1];\\n        k = i;\\n      }\\n    }\\n    for (int i = k; i < n; ++i)\\n      s[i] = \\'9\\';\\n\\n    return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414606,
                "title": "python3-memoize",
                "content": "# Code\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        if n < 10:\\n            return n\\n        b = 0\\n        @lru_cache(None)\\n        def r(rem, con):\\n            nonlocal b\\n            if len(rem) < 2:\\n                if con[-1] <= rem:\\n                    b = max(b, int(con + rem))\\n            else:\\n                if con[-1] <= rem[0]:\\n                    r(rem[1:], con + rem[0])\\n                if int(rem[0])-1 >= int(con[-1]):\\n                    b = max(b, int(con + str(int(rem[0])-1) + \"9\" * (len(rem)-1)    ))\\n        r(str(n), \"0\")\\n        return b\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        if n < 10:\\n            return n\\n        b = 0\\n        @lru_cache(None)\\n        def r(rem, con):\\n            nonlocal b\\n            if len(rem) < 2:\\n                if con[-1] <= rem:\\n                    b = max(b, int(con + rem))\\n            else:\\n                if con[-1] <= rem[0]:\\n                    r(rem[1:], con + rem[0])\\n                if int(rem[0])-1 >= int(con[-1]):\\n                    b = max(b, int(con + str(int(rem[0])-1) + \"9\" * (len(rem)-1)    ))\\n        r(str(n), \"0\")\\n        return b\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406702,
                "title": "simple-approach-o-log-n-time-o-1-space",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst intuition was to have two loops and check every digit-pair, but that\\'s way too slow (exponential time complexity), so the next idea was to look at what happens when we have to change a digit?\\nGoing from behind we can see, that on each change we set the current digit and everything behind it to 9 (because once we flip something to 9, nothing else can stay behind it, as they would be smaller), plus the greater digit to its current value minus one (since we are looking for smaller numbers than the original, i.e. flipping 30 to 29 by flipping the zero to 9 and 3 -= 1).\\nWe are always checking 2 digits at once - Left and Right, and we are walking the digits from the back.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(log 1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MonotoneIncreasingDigits(int n)\\n            {\\n                int r; //right dight\\n                int l; //left digit\\n                        //an index, a pointer of where we are, \\n                        //keeping track of how much the value of \\n                        //the current digit is. I.e: The 4 in 345 is wirth 40//\\n                int point = 1; \\n                while (n / point > 0)\\n                {\\n                    //get the current digit\\n                    r = (n % (point * 10)) /  (point * 1);\\n                    //get the next digit\\n                    l = (n % (point * 100)) / (point * 10);\\n\\n                    //we compare their values\\n                    //current digit less than next digit\\n                    if (l > r)\\n                    {\\n                        //setting up to set everything to 9 starting from current\\n                        int count = point;\\n                        //Set everything to 9\\n                        while (count > 0)\\n                        {\\n                            //removing current value\\n                            n -=n % (count * 10);\\n                            //adding 9\\n                            n += 9 * count;\\n                            //going back a digit\\n                            count /= 10;\\n                        }\\n                        //next -= 1\\n                        n -= point * 10;\\n                    }\\n                    //increase pointer\\n                    point *= 10;\\n                }\\n                return n;\\n            }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MonotoneIncreasingDigits(int n)\\n            {\\n                int r; //right dight\\n                int l; //left digit\\n                        //an index, a pointer of where we are, \\n                        //keeping track of how much the value of \\n                        //the current digit is. I.e: The 4 in 345 is wirth 40//\\n                int point = 1; \\n                while (n / point > 0)\\n                {\\n                    //get the current digit\\n                    r = (n % (point * 10)) /  (point * 1);\\n                    //get the next digit\\n                    l = (n % (point * 100)) / (point * 10);\\n\\n                    //we compare their values\\n                    //current digit less than next digit\\n                    if (l > r)\\n                    {\\n                        //setting up to set everything to 9 starting from current\\n                        int count = point;\\n                        //Set everything to 9\\n                        while (count > 0)\\n                        {\\n                            //removing current value\\n                            n -=n % (count * 10);\\n                            //adding 9\\n                            n += 9 * count;\\n                            //going back a digit\\n                            count /= 10;\\n                        }\\n                        //next -= 1\\n                        n -= point * 10;\\n                    }\\n                    //increase pointer\\n                    point *= 10;\\n                }\\n                return n;\\n            }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321004,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        \\n        vector <int> a;\\n\\n        if ( n==0 ) {\\n            return n;\\n        }\\n        \\n        while ( n!=0 ) {\\n            \\n            a.push_back(n%10);\\n            n = n/10;\\n        }\\n\\n        bool flag = 1;\\n        for ( int i=0; i<a.size()-1; i++ ) {\\n\\n            if ( a[i] < a[i+1] ) {\\n                flag = 0;\\n                break;\\n            }\\n        }\\n\\n        int ans = 0;\\n\\n        if ( flag ) {\\n\\n            for ( int i=0; i<a.size(); i++ ) {\\n                ans += a[i]*pow(10,i);\\n            }\\n\\n            return ans;\\n        }\\n\\n        for ( int i=0; i<a.size()-1; i++ ) {\\n\\n            if ( a[i] < a[i+1] ) {\\n\\n                a[i+1] --; \\n\\n                for ( int j=0; j<=i; j++ ) {\\n                    a[j] = 9;\\n                }\\n            }\\n        }\\n\\n        for ( int i=0; i<a.size(); i++ ) {\\n            ans += a[i]*pow(10,i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        \\n        vector <int> a;\\n\\n        if ( n==0 ) {\\n            return n;\\n        }\\n        \\n        while ( n!=0 ) {\\n            \\n            a.push_back(n%10);\\n            n = n/10;\\n        }\\n\\n        bool flag = 1;\\n        for ( int i=0; i<a.size()-1; i++ ) {\\n\\n            if ( a[i] < a[i+1] ) {\\n                flag = 0;\\n                break;\\n            }\\n        }\\n\\n        int ans = 0;\\n\\n        if ( flag ) {\\n\\n            for ( int i=0; i<a.size(); i++ ) {\\n                ans += a[i]*pow(10,i);\\n            }\\n\\n            return ans;\\n        }\\n\\n        for ( int i=0; i<a.size()-1; i++ ) {\\n\\n            if ( a[i] < a[i+1] ) {\\n\\n                a[i+1] --; \\n\\n                for ( int j=0; j<=i; j++ ) {\\n                    a[j] = 9;\\n                }\\n            }\\n        }\\n\\n        for ( int i=0; i<a.size(); i++ ) {\\n            ans += a[i]*pow(10,i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299447,
                "title": "cpp-code-with-detail-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s think of a number as a sequence.\\n\\nAnd let\\'s say some sections of the sequence decrease.\\nAssume We just keep the first digit of the decreasing interval and replace it with a monotonic increasing sequence, which means a sequence that has the same value as the first digit.\\n`ex) 1,2,3,4,3,2,1 -> 1,2,3,4,4,4,4. 1234321 < 1234444`\\n\\nA substituted sequence can never be less than or equal to a conventional sequence.\\n\\nTherefore, the first condition to have a value less than or equal to the existing sequence is to reduce the first number of the decreasing interval.\\nLet\\'s reduce the size of 1 because it has to be the largest of the small numbers.\\nAnd it also has to have the largest number of small numbers, so it changes all subsequent values to 9.\\n`ex) 1,2,3,4,3,2,1 -> 1,2,3,3,3,2,1 -> 1,2,3,3,9,9,9 (answer!)`\\n\\nHowever, in this case, a new decreasing interval may appear because of the decreasing number.\\nSo that\\'s the case with the same number repeatedly.\\n`ex) 1,2,2,4,4,3,2,1 -> 1,2,2,4,3,9,9,9`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        int l = s.size(), i=0;\\n        \\n        int down_point = l;\\n        for (int i=0; i<s.size()-1; i++) {\\n            if (s[i] > s[i+1]) {\\n                down_point = i;\\n                break;\\n            }\\n        }\\n\\n        if (down_point == l) return n;\\n\\n        s[down_point]--;\\n        for (int i=down_point-1; i>=0; i--) {\\n            if (s[i] > s[i+1]) {\\n                s[i]--;\\n                s[i+1] = \\'9\\';\\n            }\\n        }\\n        for (int i=down_point+1; i<l; i++) {\\n            s[i] = \\'9\\';\\n        }\\n\\n        return stoi(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string s = to_string(n);\\n        int l = s.size(), i=0;\\n        \\n        int down_point = l;\\n        for (int i=0; i<s.size()-1; i++) {\\n            if (s[i] > s[i+1]) {\\n                down_point = i;\\n                break;\\n            }\\n        }\\n\\n        if (down_point == l) return n;\\n\\n        s[down_point]--;\\n        for (int i=down_point-1; i>=0; i--) {\\n            if (s[i] > s[i+1]) {\\n                s[i]--;\\n                s[i+1] = \\'9\\';\\n            }\\n        }\\n        for (int i=down_point+1; i<l; i++) {\\n            s[i] = \\'9\\';\\n        }\\n\\n        return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289423,
                "title": "my-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        num = str(n)\\n        num = list(num)\\n        num.reverse()\\n\\n        for i in range(1,len(num)):\\n            if num[i] > num[i-1] :\\n                num[i]=str(int(num[i])-1)\\n                for j in range(0,i):\\n                    num[j]=\\'9\\'\\n    \\n        num.reverse()\\n        return int(\\'\\'.join(num))\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        num = str(n)\\n        num = list(num)\\n        num.reverse()\\n\\n        for i in range(1,len(num)):\\n            if num[i] > num[i-1] :\\n                num[i]=str(int(num[i])-1)\\n                for j in range(0,i):\\n                    num[j]=\\'9\\'\\n    \\n        num.reverse()\\n        return int(\\'\\'.join(num))\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257688,
                "title": "c-iterate-from-back",
                "content": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string ans = to_string(n);\\n        int i = ans.size();        \\n        for (int y = (int) ans.size() - 2; y >= 0; --y)\\n            if (ans[y] > ans[y + 1]){\\n                i = y + 1;\\n                --ans[y];\\n            }    \\n        for (; i < ans.size(); ++i) ans[i] = \\'9\\';\\n        return stoi(ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        string ans = to_string(n);\\n        int i = ans.size();        \\n        for (int y = (int) ans.size() - 2; y >= 0; --y)\\n            if (ans[y] > ans[y + 1]){\\n                i = y + 1;\\n                --ans[y];\\n            }    \\n        for (; i < ans.size(); ++i) ans[i] = \\'9\\';\\n        return stoi(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247072,
                "title": "recursion",
                "content": "```\\n long long ans=0;\\n    void so(int n,long long s,int j){\\n        if(s>n)\\n            return;\\n        ans=max(ans,s);\\n        for(int i=j;i<=9;i++){\\n            so(n,s*10+i,i);\\n            }\\n        }\\n            \\n    int monotoneIncreasingDigits(int n) {\\n        so(n,0,1);\\n        return ans;\\n    }****\\n",
                "solutionTags": [],
                "code": "```\\n long long ans=0;\\n    void so(int n,long long s,int j){\\n        if(s>n)\\n            return;\\n        ans=max(ans,s);\\n        for(int i=j;i<=9;i++){\\n            so(n,s*10+i,i);\\n            }\\n        }\\n            \\n    int monotoneIncreasingDigits(int n) {\\n        so(n,0,1);\\n        return ans;\\n    }****\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3238060,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn monotone_increasing_digits(n: i32) -> i32 {\\n        let mut n = n.to_string().chars().collect::<Vec<_>>();\\n        let len = n.len();\\n        let mut start = len;\\n        for i in (1..len).rev() {\\n            if n[i] < n[i - 1] {\\n                n[i - 1] = (n[i - 1] as u8 - 1) as char;\\n                start = i;\\n            }\\n        }\\n        n[start..len].iter_mut().for_each(|x| *x = \\'9\\');\\n        n.into_iter().collect::<String>().parse::<i32>().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn monotone_increasing_digits(n: i32) -> i32 {\\n        let mut n = n.to_string().chars().collect::<Vec<_>>();\\n        let len = n.len();\\n        let mut start = len;\\n        for i in (1..len).rev() {\\n            if n[i] < n[i - 1] {\\n                n[i - 1] = (n[i - 1] as u8 - 1) as char;\\n                start = i;\\n            }\\n        }\\n        n[start..len].iter_mut().for_each(|x| *x = \\'9\\');\\n        n.into_iter().collect::<String>().parse::<i32>().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3216626,
                "title": "python-3-without-string-or-list-o-log-n",
                "content": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        digits = 0\\n        decrease = -1\\n        tmp = n\\n        y = 10\\n        while tmp:\\n            x = tmp % 10\\n            if x > y or (x == y and decrease == digits - 1):\\n                decrease = digits\\n            digits += 1\\n            tmp //= 10\\n            y = x\\n        if decrease == -1:\\n            return n\\n        i = 1\\n        tmp = n\\n        for _ in range(decrease):\\n            n += i * (9 - (tmp % 10))\\n            i *= 10\\n            tmp //= 10\\n        return n - i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        digits = 0\\n        decrease = -1\\n        tmp = n\\n        y = 10\\n        while tmp:\\n            x = tmp % 10\\n            if x > y or (x == y and decrease == digits - 1):\\n                decrease = digits\\n            digits += 1\\n            tmp //= 10\\n            y = x\\n        if decrease == -1:\\n            return n\\n        i = 1\\n        tmp = n\\n        for _ in range(decrease):\\n            n += i * (9 - (tmp % 10))\\n            i *= 10\\n            tmp //= 10\\n        return n - i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174718,
                "title": "c",
                "content": "```\\nchar* intToStr(int n){\\n    char* ret = malloc(11 ) ;\\n    int val = n ;\\n    int idx = 0 ;\\n    while(val){\\n        ret[idx] = val%10 + \\'0\\' ;\\n        val /= 10 ;\\n        idx++ ;\\n    }\\n    ret[idx] = \\'\\\\0\\' ;\\n    for(int i = 0; i < idx/2; i++){\\n        char tmp = ret[i] ;\\n        ret[i] = ret[idx-1-i] ;\\n        ret[idx-1-i]  = tmp ;\\n    }\\n    return ret ;\\n    \\n}\\nint stoi(char* str){\\n    int n = strlen(str) ;\\n    int val = 0; \\n    for(int i = 0;  i < n ; i++){\\n        val = val*10 + str[i]-\\'0\\' ;\\n    }\\n    return val ;\\n}\\nint monotoneIncreasingDigits(int n){\\n    char* str = intToStr(n) ;\\n\\n    int N = strlen(str) ;\\n    int j = N ;\\n    for(int i = N-1; i > 0; i--){\\n        if(str[i] >= str[i-1])\\n            continue ;\\n        str[i-1]-- ;\\n        j = i ;\\n    }\\n    \\n    for(int k = j; k < N; k++){\\n        str[k] = \\'9\\' ;\\n    }\\n\\n    return stoi(str) ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar* intToStr(int n){\\n    char* ret = malloc(11 ) ;\\n    int val = n ;\\n    int idx = 0 ;\\n    while(val){\\n        ret[idx] = val%10 + \\'0\\' ;\\n        val /= 10 ;\\n        idx++ ;\\n    }\\n    ret[idx] = \\'\\\\0\\' ;\\n    for(int i = 0; i < idx/2; i++){\\n        char tmp = ret[i] ;\\n        ret[i] = ret[idx-1-i] ;\\n        ret[idx-1-i]  = tmp ;\\n    }\\n    return ret ;\\n    \\n}\\nint stoi(char* str){\\n    int n = strlen(str) ;\\n    int val = 0; \\n    for(int i = 0;  i < n ; i++){\\n        val = val*10 + str[i]-\\'0\\' ;\\n    }\\n    return val ;\\n}\\nint monotoneIncreasingDigits(int n){\\n    char* str = intToStr(n) ;\\n\\n    int N = strlen(str) ;\\n    int j = N ;\\n    for(int i = N-1; i > 0; i--){\\n        if(str[i] >= str[i-1])\\n            continue ;\\n        str[i-1]-- ;\\n        j = i ;\\n    }\\n    \\n    for(int k = j; k < N; k++){\\n        str[k] = \\'9\\' ;\\n    }\\n\\n    return stoi(str) ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3115288,
                "title": "c-easy-no-stack",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> getVector(int n){\\n        vector<int> nums;\\n        while(n){\\n            int digit=n%10;\\n            nums.push_back(digit);\\n            n/=10;\\n        }\\n        reverse(nums.begin(),nums.end());\\n        return nums;\\n    }\\n    int convertToInt(vector<int>& nums){\\n        int ans = 0;\\n        for(int ind=0;ind<nums.size();ind++){\\n            ans=ans*10+nums[ind];\\n        }\\n            \\n        return ans;\\n    }\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        //get n in terns of array to traverse\\n        vector<int> nums=getVector(n);\\n        int changeIdx=-1;\\n        for(int ind=nums.size()-1;ind>0;ind--){\\n            if(nums[ind-1]>nums[ind]){\\n                changeIdx=ind;\\n                nums[ind-1]--;\\n            }\\n        }\\n        for(int ind=changeIdx;ind<nums.size();ind++){\\n            nums[ind]=9;\\n        }\\n        //converting again to int\\n        int ans=convertToInt(nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> getVector(int n){\\n        vector<int> nums;\\n        while(n){\\n            int digit=n%10;\\n            nums.push_back(digit);\\n            n/=10;\\n        }\\n        reverse(nums.begin(),nums.end());\\n        return nums;\\n    }\\n    int convertToInt(vector<int>& nums){\\n        int ans = 0;\\n        for(int ind=0;ind<nums.size();ind++){\\n            ans=ans*10+nums[ind];\\n        }\\n            \\n        return ans;\\n    }\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        //get n in terns of array to traverse\\n        vector<int> nums=getVector(n);\\n        int changeIdx=-1;\\n        for(int ind=nums.size()-1;ind>0;ind--){\\n            if(nums[ind-1]>nums[ind]){\\n                changeIdx=ind;\\n                nums[ind-1]--;\\n            }\\n        }\\n        for(int ind=changeIdx;ind<nums.size();ind++){\\n            nums[ind]=9;\\n        }\\n        //converting again to int\\n        int ans=convertToInt(nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072683,
                "title": "simple-recursive-go-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ (the stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc monotoneIncreasingDigits(n int) int {\\n    str := strconv.Itoa(n)\\n    chars := []byte(str)\\n    for i := range chars {\\n        if canKeep(chars, i) {\\n            continue\\n        }\\n        chars[i] -= 1\\n        for j := i + 1; j < len(chars); j ++ {\\n            chars[j] = \\'9\\'\\n        }\\n        break\\n    }\\n    num, _ := strconv.Atoi(string(chars))\\n    return num\\n}\\n\\nfunc canKeep(chars []byte, i int) bool {\\n    if i == len(chars) - 1 {\\n        return true\\n    }\\n    if canKeep(chars, i + 1) {\\n        return chars[i] <= chars[i + 1]\\n    } else {\\n        return chars[i] <= chars[i + 1] - 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc monotoneIncreasingDigits(n int) int {\\n    str := strconv.Itoa(n)\\n    chars := []byte(str)\\n    for i := range chars {\\n        if canKeep(chars, i) {\\n            continue\\n        }\\n        chars[i] -= 1\\n        for j := i + 1; j < len(chars); j ++ {\\n            chars[j] = \\'9\\'\\n        }\\n        break\\n    }\\n    num, _ := strconv.Atoi(string(chars))\\n    return num\\n}\\n\\nfunc canKeep(chars []byte, i int) bool {\\n    if i == len(chars) - 1 {\\n        return true\\n    }\\n    if canKeep(chars, i + 1) {\\n        return chars[i] <= chars[i + 1]\\n    } else {\\n        return chars[i] <= chars[i + 1] - 1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3060303,
                "title": "backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solv(int &ans, int x, int c, int num, long long sum)\\n    {\\n        if(c==0)\\n        {\\n            if(sum<=num)\\n                ans=max(ans,(int)sum);\\n            return;\\n        }\\n        for(int i=x;i<=9;i++)\\n        {\\n            solv(ans,i,c-1,num,sum*10+i);\\n        }\\n    }\\n    int monotoneIncreasingDigits(int n) {\\n        if(n==0)\\n            return 0;\\n        int x=0,c=0;\\n        int num=n;\\n        while(n>0)\\n        {\\n            x=n%10;\\n            n=n/10;\\n            c++;\\n        }\\n        int ans=0;\\n        while(x>=0)\\n        {\\n            solv(ans,x,c-1,num,x);\\n            if(ans>0)\\n                break;\\n            x--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    void solv(int &ans, int x, int c, int num, long long sum)\\n    {\\n        if(c==0)\\n        {\\n            if(sum<=num)\\n                ans=max(ans,(int)sum);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3056589,
                "title": "python-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought on how to solve this problem is to use a recursive approach to iterate through the characters of the expression, keeping track of the current scope and the variables that have been assigned values in that scope.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use a stack to keep track of the scopes and variables, and a dictionary to store the variable values. I will use a stack to keep track of the expressions inside the parenthesis.\\n\\n- Initialize an empty stack for scopes, an empty stack for expressions, and an empty dictionary for variable values.\\n- Iterate through the characters of the expression:\\na. If the current character is an opening parenthesis, recursively call the parse function with the expression inside the parenthesis and push the result onto the expressions stack.\\nb. If the current character is a variable, check the current scope and any outer scopes for its value. If a value is found, use it in the calculation. If not, use the default value.\\nc. If the current character is an operator, pop the necessary number of expressions from the expressions stack and perform the operation. Push the result back onto the expressions stack.\\nd. If the current character is a closing parenthesis, return the result from the expressions stack.\\nReturn the final result from the expressions stack.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        s = str(n)\\n        i = 1\\n        while i < len(s) and s[i-1] <= s[i]:\\n            i += 1\\n        if i < len(s):\\n            while i > 0 and s[i-1] > s[i]:\\n                s = s[:i-1] + str(int(s[i-1]) - 1) + \\'9\\' * (len(s)-i)\\n                i -= 1\\n        return int(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        s = str(n)\\n        i = 1\\n        while i < len(s) and s[i-1] <= s[i]:\\n            i += 1\\n        if i < len(s):\\n            while i > 0 and s[i-1] > s[i]:\\n                s = s[:i-1] + str(int(s[i-1]) - 1) + \\'9\\' * (len(s)-i)\\n                i -= 1\\n        return int(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047067,
                "title": "100-faster-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        if(!n) return 0;\\n        int temp = n;\\n        string s = to_string(temp);\\n        int ind = -1;\\n        for(int i = 0; i < (int)log10(n); i++){\\n            if(s[i] <= s[i+1]) continue;\\n            ind = i;\\n            break;\\n        }\\n\\n        if(ind + 1 == 0) return stoi(s);\\n        char check = s[ind];\\n        while(ind >= 0){\\n            if(check == s[ind]) s[ind]--;\\n            else break;\\n            ind--;\\n        }\\n\\n        for(int i = ind+2; i <= (int)log10(n); i++){\\n            s[i]=\\'9\\';\\n        }\\n\\n        return stoi(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        if(!n) return 0;\\n        int temp = n;\\n        string s = to_string(temp);\\n        int ind = -1;\\n        for(int i = 0; i < (int)log10(n); i++){\\n            if(s[i] <= s[i+1]) continue;\\n            ind = i;\\n            break;\\n        }\\n\\n        if(ind + 1 == 0) return stoi(s);\\n        char check = s[ind];\\n        while(ind >= 0){\\n            if(check == s[ind]) s[ind]--;\\n            else break;\\n            ind--;\\n        }\\n\\n        for(int i = ind+2; i <= (int)log10(n); i++){\\n            s[i]=\\'9\\';\\n        }\\n\\n        return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038712,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        StringBuilder s = new StringBuilder(String.valueOf(n));\\n        while(true) {\\n            boolean b = false;\\n            StringBuilder ans = new StringBuilder();\\n            for (int i = 0; i < s.length(); i++) {\\n                if (b) ans.append(\"9\");\\n                else if (i < s.length()-1 && s.charAt(i) > s.charAt(i+1)) {\\n                    b = true;\\n                    ans.append(s.charAt(i) - \\'0\\' - 1);\\n                }\\n                else ans.append(s.charAt(i));\\n            }\\n            s = new StringBuilder(ans);\\n            if(!b) break;\\n        }\\n        return Integer.parseInt(s.toString());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        StringBuilder s = new StringBuilder(String.valueOf(n));\\n        while(true) {\\n            boolean b = false;\\n            StringBuilder ans = new StringBuilder();\\n            for (int i = 0; i < s.length(); i++) {\\n                if (b) ans.append(\"9\");\\n                else if (i < s.length()-1 && s.charAt(i) > s.charAt(i+1)) {\\n                    b = true;\\n                    ans.append(s.charAt(i) - \\'0\\' - 1);\\n                }\\n                else ans.append(s.charAt(i));\\n            }\\n            s = new StringBuilder(ans);\\n            if(!b) break;\\n        }\\n        return Integer.parseInt(s.toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023495,
                "title": "golang-simple-solution-greedy",
                "content": "# Code\\n```\\nfunc monotoneIncreasingDigits(n int) int {\\n    ss := []byte(strconv.Itoa(n))\\n    if len(ss) <= 1 {\\n        return n\\n    }\\n\\n    for i := len(ss) - 1; i > 0; i-- {\\n        if ss[i - 1] > ss[i] {\\n            ss[i - 1] -= 1\\n            for j := i; j < len(ss); j++ {\\n                ss[j] = \\'9\\'\\n            }\\n        }\\n    }\\n\\n    res, _ := strconv.Atoi(string(ss))\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc monotoneIncreasingDigits(n int) int {\\n    ss := []byte(strconv.Itoa(n))\\n    if len(ss) <= 1 {\\n        return n\\n    }\\n\\n    for i := len(ss) - 1; i > 0; i-- {\\n        if ss[i - 1] > ss[i] {\\n            ss[i - 1] -= 1\\n            for j := i; j < len(ss); j++ {\\n                ss[j] = \\'9\\'\\n            }\\n        }\\n    }\\n\\n    res, _ := strconv.Atoi(string(ss))\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015985,
                "title": "c-math-o-1",
                "content": "# Intuition\\n\\nFor an integer $x = d_9 d_8 d_7 \\\\cdots d_0$, if $d_i > d_{i-1}$, we could use the following formula to produce the maximun increasing number:\\n\\n$$\\nd_i := d_i - 1 \\\\\\\\\\nd_{i-1}, d_{i-2}, \\\\cdots d_0 := 9\\n$$\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        vector<int> digits;\\n        while (n > 0)\\n        {\\n            digits.push_back(n % 10);\\n            n /= 10;\\n        }\\n\\n        int k = digits.size();\\n        if (k <= 1)\\n        {\\n            return n;\\n        }\\n\\n        for (int i = 0; i < k - 1; i++)\\n        {\\n            if (digits[i] < digits[i + 1])\\n            {\\n                for (int j = 0; j <= i; j++)\\n                {\\n                    digits[j] = 9;\\n                }\\n                digits[i + 1] --;\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = k - 1; i >= 0; i--)\\n        {\\n            ans = ans * 10 + digits[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int monotoneIncreasingDigits(int n) {\\n        vector<int> digits;\\n        while (n > 0)\\n        {\\n            digits.push_back(n % 10);\\n            n /= 10;\\n        }\\n\\n        int k = digits.size();\\n        if (k <= 1)\\n        {\\n            return n;\\n        }\\n\\n        for (int i = 0; i < k - 1; i++)\\n        {\\n            if (digits[i] < digits[i + 1])\\n            {\\n                for (int j = 0; j <= i; j++)\\n                {\\n                    digits[j] = 9;\\n                }\\n                digits[i + 1] --;\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = k - 1; i >= 0; i--)\\n        {\\n            ans = ans * 10 + digits[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992655,
                "title": "python-greedy-solution",
                "content": "# Intuition\\nAs long as we need to get biggest number with non-decreasing digits thus we can only decrease the number, as less as possible. Thus we shall start from the right (least significant digits) and making sure higher digits are less. In case we detect an inversion, we decrease the higher digit, and set all digits on the left to biggest possible - nines:\\n\\n```\\n....a(i+1)a(i)....\\n```\\n=>\\n```\\n....(a(i+1)-1)99...999\\n```\\n\\n\\n# Approach\\n1. Split into digits\\n2. Go right to left, considering pairs\\n3. In case of inversion => right change to 9, previous decrement, fill all previous with 9s\\n4. If did not become 0, continue with the next one with step 3\\n\\n\\n## Pseudo-code\\n\\n\\n```\\ndigits = split_into_digits(n)\\n\\nfor high, low in pairs(digits):\\n  if high == 0:\\n    break\\n  if low < high:\\n    decrement high\\n    set_all_lower_to_nine()\\n\\nreturn build_number(digits)\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        result, nines, power = 0, 9, 1       # Initialize result with 0, nines up to current digit with 9 and current power of ten to 1\\n        while n:                             # Iterating the number from low digits, checking pairs\\n            digit_low = n % 10               # Lowest digit is modulo of 10\\n            n //= 10                         # Shift the number\\n            digit_high = n % 10              # Higher digit is modulo of 10 now\\n            if digit_low < digit_high:       # If we have found an inversion\\n                result = nines               # Set all digits up to the current one to 9s\\n                n -= 1                       # Decrement the remaining part of the number (which starts with the current higher digit)\\n            else:\\n                result += digit_low * power  # Otherwise add lowe digit to the number\\n            power *= 10                      # Shifting the power\\n            nines = 10 * nines + 9           # Adding another 9 not nines\\n\\n        return result                        # Return the result\\n```\\n\\nIf you have any questions I am here to answer them, and please upvote if you like the approach!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n....a(i+1)a(i)....\\n```\n```\\n....(a(i+1)-1)99...999\\n```\n```\\ndigits = split_into_digits(n)\\n\\nfor high, low in pairs(digits):\\n  if high == 0:\\n    break\\n  if low < high:\\n    decrement high\\n    set_all_lower_to_nine()\\n\\nreturn build_number(digits)\\n```\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        result, nines, power = 0, 9, 1       # Initialize result with 0, nines up to current digit with 9 and current power of ten to 1\\n        while n:                             # Iterating the number from low digits, checking pairs\\n            digit_low = n % 10               # Lowest digit is modulo of 10\\n            n //= 10                         # Shift the number\\n            digit_high = n % 10              # Higher digit is modulo of 10 now\\n            if digit_low < digit_high:       # If we have found an inversion\\n                result = nines               # Set all digits up to the current one to 9s\\n                n -= 1                       # Decrement the remaining part of the number (which starts with the current higher digit)\\n            else:\\n                result += digit_low * power  # Otherwise add lowe digit to the number\\n            power *= 10                      # Shifting the power\\n            nines = 10 * nines + 9           # Adding another 9 not nines\\n\\n        return result                        # Return the result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966498,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int tmpNum = n, i = 1;\\n        while (tmpNum > 0) {\\n            i *= 10;\\n            int mod = tmpNum % 10;\\n            tmpNum /= 10;\\n            if (mod < tmpNum % 10) {\\n                break;\\n            }\\n        }\\n        if (tmpNum > 0) {\\n            return monotoneIncreasingDigits((tmpNum * i) - 1);\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        int tmpNum = n, i = 1;\\n        while (tmpNum > 0) {\\n            i *= 10;\\n            int mod = tmpNum % 10;\\n            tmpNum /= 10;\\n            if (mod < tmpNum % 10) {\\n                break;\\n            }\\n        }\\n        if (tmpNum > 0) {\\n            return monotoneIncreasingDigits((tmpNum * i) - 1);\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938746,
                "title": "easy-python-solution-beats-94-72",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursively go through all powers of 10 for the given number\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        if n < 10:\\n            return n\\n        else:\\n            check_num = str(n)\\n            found = False\\n            for d in range(1,len(check_num)):\\n                if check_num[d] < check_num[d-1]:\\n                    found = False\\n                    break\\n                found = True\\n            if found:\\n                return n\\n            else:\\n                divisor = 10 ** (len(check_num) - d)\\n                return self.monotoneIncreasingDigits(n - n%divisor - 1)\\n          \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def monotoneIncreasingDigits(self, n: int) -> int:\\n        if n < 10:\\n            return n\\n        else:\\n            check_num = str(n)\\n            found = False\\n            for d in range(1,len(check_num)):\\n                if check_num[d] < check_num[d-1]:\\n                    found = False\\n                    break\\n                found = True\\n            if found:\\n                return n\\n            else:\\n                divisor = 10 ** (len(check_num) - d)\\n                return self.monotoneIncreasingDigits(n - n%divisor - 1)\\n          \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929612,
                "title": "java-100",
                "content": "```\\npublic int monotoneIncreasingDigits(int n) {\\n\\t\\tchar[]charArray = String.valueOf(n).toCharArray();\\n\\t\\t//Find the cliff \\n\\t\\tint i=1;\\n\\t\\twhile(i<charArray.length && charArray[i]>=charArray[i-1]) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\t//Decrement while cliff exist\\n\\t\\twhile(i>0 && i<charArray.length && charArray[i-1] >charArray[i]) {\\n\\t\\t\\tcharArray[i-1]--;\\n\\t\\t\\ti--;\\n\\t\\t}\\n\\t\\t//make rest of the digits 9\\n\\t\\tfor(int j=i+1;j<charArray.length;j++) {\\n\\t\\t\\tcharArray[j]=\\'9\\';\\n\\t\\t}\\n\\t\\treturn Integer.parseInt(new String(charArray));\\n\\t}",
                "solutionTags": [],
                "code": "```\\npublic int monotoneIncreasingDigits(int n) {\\n\\t\\tchar[]charArray = String.valueOf(n).toCharArray();\\n\\t\\t//Find the cliff \\n\\t\\tint i=1;\\n\\t\\twhile(i<charArray.length && charArray[i]>=charArray[i-1]) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\t//Decrement while cliff exist\\n\\t\\twhile(i>0 && i<charArray.length && charArray[i-1] >charArray[i]) {\\n\\t\\t\\tcharArray[i-1]--;\\n\\t\\t\\ti--;\\n\\t\\t}\\n\\t\\t//make rest of the digits 9\\n\\t\\tfor(int j=i+1;j<charArray.length;j++) {\\n\\t\\t\\tcharArray[j]=\\'9\\';\\n\\t\\t}\\n\\t\\treturn Integer.parseInt(new String(charArray));\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2928144,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char[] x = String.valueOf(n).toCharArray();\\n\\n        int mark = x.length;\\n        for(int i = x.length-1;i>0;i--){\\n            if(x[i]<x[i-1]){\\n                mark = i-1;\\n                x[i-1]--;\\n            }\\n        }\\n        for(int i = mark+1;i<x.length;i++){\\n            x[i] = \\'9\\';\\n        }\\n        return Integer.parseInt(new String(x));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int monotoneIncreasingDigits(int n) {\\n        char[] x = String.valueOf(n).toCharArray();\\n\\n        int mark = x.length;\\n        for(int i = x.length-1;i>0;i--){\\n            if(x[i]<x[i-1]){\\n                mark = i-1;\\n                x[i-1]--;\\n            }\\n        }\\n        for(int i = mark+1;i<x.length;i++){\\n            x[i] = \\'9\\';\\n        }\\n        return Integer.parseInt(new String(x));\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2002335,
                "content": [
                    {
                        "username": "Rounak_25",
                        "content": "if n=244765432\\nthe expected ans is 244699999\\nbut the ans should be 244759999"
                    },
                    {
                        "username": "singh_3662",
                        "content": "244759999 is not in the order of monotone increasing digits.\\nBecause 7 > 5, so the expected ans is the correct one."
                    },
                    {
                        "username": "geekyshark",
                        "content": "anyone in their right mind can see 7>5 , hence given answer is correct "
                    }
                ]
            }
        ]
    }
]