[
    {
        "title": "Paths in Matrix Whose Sum Is Divisible by K",
        "question_content": "You are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right.\nReturn the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3\nOutput: 2\nExplanation: There are two paths where the sum of the elements on the path is divisible by k.\nThe first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3.\nThe second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3.\n\nExample 2:\n\nInput: grid = [[0,0]], k = 5\nOutput: 1\nExplanation: The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5.\n\nExample 3:\n\nInput: grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1\nOutput: 10\nExplanation: Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 5 * 104\n\t1 <= m * n <= 5 * 104\n\t0 <= grid[i][j] <= 100\n\t1 <= k <= 50",
        "solutions": [
            {
                "id": 2678797,
                "title": "c-java-python-clean-top-down-bottom-up-dp-m-n-k",
                "content": "> Similar top down approach TLEs in Java and Python both.\\n\\n* The trick in this question is that `1 <= k <= 50`, we can use this to our advantage\\n* We can send the sum `s` of current path as a parameter after modding it with `k`. This will make the solution `(5 * 10 ^ 4) * 50` which should be acceptable. \\n* Other then that this problem is very similar to Unique Paths and I recommend that you check that out. https://leetcode.com/problems/unique-paths/\\n* The stopping condition of the recursion is that once we reach the bottom right cell`(m - 1, n - 1)`, the path sum must be divisible by k. If it is we have found a valid path and return 1 else return 0.\\n\\n**Top Down**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7, m, n, K;\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size(), K = k;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(k + 1, -1)));\\n        return dfs(0, 0, 0, grid, dp);\\n    }\\n    int dfs(int i, int j, int s, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp) {\\n        if (i == m || j == n) return 0;\\n        if (i == m - 1 && j == n - 1) return ((s + grid[i][j]) % K) == 0;\\n        if (dp[i][j][s] != -1) return dp[i][j][s];\\n        return dp[i][j][s] = (dfs(i + 1, j, (s + grid[i][j]) % K, grid, dp) + dfs(i, j + 1, (s + grid[i][j]) % K, grid, dp)) % mod;\\n    }\\n};\\n```\\n\\n\\n**Bottom Up**\\n\\n**Python3**\\n```\\ndef numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n\\tm, n, mod = len(grid), len(grid[0]), 10 ** 9 + 7\\n\\tdp = [[[0] * k for _ in range(n)] for _ in range(m)]\\n\\tdp[0][0][grid[0][0] % k] = 1\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tfor s in range(k):\\n\\t\\t\\t\\tmodded_sum = (s + grid[i][j]) % k\\n\\t\\t\\t\\tif j > 0: dp[i][j][modded_sum] += dp[i][j - 1][s]\\n\\t\\t\\t\\tif i > 0: dp[i][j][modded_sum] += dp[i - 1][j][s]\\n\\t\\t\\t\\tdp[i][j][modded_sum] %= mod\\n\\treturn dp[m - 1][n - 1][0]\\n```\\n**Java:**\\n```\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length, mod = 1000_000_007;\\n        int[][][] dp = new int[m][n][k];\\n        dp[0][0][grid[0][0] % k] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (int s = 0; s < k; s++) {\\n                    int moddedSum = (s + grid[i][j]) % k;\\n                    if (j > 0) dp[i][j][moddedSum] += dp[i][j - 1][s];\\n                    if (i > 0) dp[i][j][moddedSum] += dp[i - 1][j][s];\\n                    dp[i][j][moddedSum] %= mod;\\n                }\\n        return dp[m - 1][n - 1][0];\\n    }\\n```\\n*Time complexity: O(m *  n *  k)*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7, m, n, K;\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size(), K = k;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(k + 1, -1)));\\n        return dfs(0, 0, 0, grid, dp);\\n    }\\n    int dfs(int i, int j, int s, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp) {\\n        if (i == m || j == n) return 0;\\n        if (i == m - 1 && j == n - 1) return ((s + grid[i][j]) % K) == 0;\\n        if (dp[i][j][s] != -1) return dp[i][j][s];\\n        return dp[i][j][s] = (dfs(i + 1, j, (s + grid[i][j]) % K, grid, dp) + dfs(i, j + 1, (s + grid[i][j]) % K, grid, dp)) % mod;\\n    }\\n};\\n```\n```\\ndef numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n\\tm, n, mod = len(grid), len(grid[0]), 10 ** 9 + 7\\n\\tdp = [[[0] * k for _ in range(n)] for _ in range(m)]\\n\\tdp[0][0][grid[0][0] % k] = 1\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tfor s in range(k):\\n\\t\\t\\t\\tmodded_sum = (s + grid[i][j]) % k\\n\\t\\t\\t\\tif j > 0: dp[i][j][modded_sum] += dp[i][j - 1][s]\\n\\t\\t\\t\\tif i > 0: dp[i][j][modded_sum] += dp[i - 1][j][s]\\n\\t\\t\\t\\tdp[i][j][modded_sum] %= mod\\n\\treturn dp[m - 1][n - 1][0]\\n```\n```\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length, mod = 1000_000_007;\\n        int[][][] dp = new int[m][n][k];\\n        dp[0][0][grid[0][0] % k] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (int s = 0; s < k; s++) {\\n                    int moddedSum = (s + grid[i][j]) % k;\\n                    if (j > 0) dp[i][j][moddedSum] += dp[i][j - 1][s];\\n                    if (i > 0) dp[i][j][moddedSum] += dp[i - 1][j][s];\\n                    dp[i][j][moddedSum] %= mod;\\n                }\\n        return dp[m - 1][n - 1][0];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678788,
                "title": "memoise-mod-k",
                "content": "We do not need to memoise the sum, we just need to memoise the modulo - `sum % k`. \\n\\nIn the end, if the modulo is zero - the path sum is divisible. Since `k` is small, we only need to store up to 51 modulos.\\n\\n#### Top-Down DP\\nPython folks are at a disadvantage (or rather, do not have an advantage) here, as `@cache` is not fast enough (TLE).\\n\\nFor Python, we need to memoise by hand (or use a bottom-up approach).\\n\\n**C++**\\n```cpp\\nint numberOfPaths(vector<vector<int>>& g, int k) {\\n    int dp[50001][51] = {}, m = g.size(), n = g[0].size();\\n    function<int(int, int, int)> dfs = [&](int i, int j, int mod){\\n        if (i >= m || j >= n)\\n            return 0;\\n        if (i == m - 1 && j == n - 1)\\n            return (mod + g[i][j]) % k ? 0 : 1;\\n        if (dp[i * n + j][mod] == 0)\\n            dp[i * n + j][mod] = (1 + dfs(i + 1, j, (mod + g[i][j]) % k) + \\n                dfs(i, j + 1, (mod + g[i][j]) % k)) % 1000000007;\\n        return dp[i * n + j][mod] - 1;\\n    };\\n    return dfs(0, 0, 0);\\n}\\n```\\n\\n#### Bottom-Up DP\\nNote that the tabulation for the current and previous row (`ra` and `rb`) is 1-based, so we do not have to do additional checks.\\n**C++**\\n```cpp\\nint numberOfPaths(vector<vector<int>>& g, int k) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> ra(n + 1, vector<int>(k + 1)), rb = ra;\\n    rb[1][0] = 1;\\n    for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j)\\n            for (int l = 0; l < k; ++l)\\n                ra[j + 1][(l + g[i][j]) % k] = (ra[j][l] + rb[j + 1][l]) % 1000000007;\\n        swap(ra, rb);\\n    }\\n    return rb[n][0];\\n} \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint numberOfPaths(vector<vector<int>>& g, int k) {\\n    int dp[50001][51] = {}, m = g.size(), n = g[0].size();\\n    function<int(int, int, int)> dfs = [&](int i, int j, int mod){\\n        if (i >= m || j >= n)\\n            return 0;\\n        if (i == m - 1 && j == n - 1)\\n            return (mod + g[i][j]) % k ? 0 : 1;\\n        if (dp[i * n + j][mod] == 0)\\n            dp[i * n + j][mod] = (1 + dfs(i + 1, j, (mod + g[i][j]) % k) + \\n                dfs(i, j + 1, (mod + g[i][j]) % k)) % 1000000007;\\n        return dp[i * n + j][mod] - 1;\\n    };\\n    return dfs(0, 0, 0);\\n}\\n```\n```cpp\\nint numberOfPaths(vector<vector<int>>& g, int k) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> ra(n + 1, vector<int>(k + 1)), rb = ra;\\n    rb[1][0] = 1;\\n    for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j)\\n            for (int l = 0; l < k; ++l)\\n                ra[j + 1][(l + g[i][j]) % k] = (ra[j][l] + rb[j + 1][l]) % 1000000007;\\n        swap(ra, rb);\\n    }\\n    return rb[n][0];\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679449,
                "title": "python3-dp-o-m-n-k-easy-to-understand-with-line-by-line-comments",
                "content": "The constraints are that m\\\\*n<=5\\\\*10^4 and k<=50, which means we can do a m\\\\*n\\\\*k algorithm for this problem. \\n\\nThen take a step back and let\\'s think about the classical DP problem [62. Unique Paths](https://leetcode.com/problems/unique-paths/) of getting the number of ways to go from (0,0) to (m-1,n-1). The DP solution would be at each (i,j) we add the value from (i-1,j) and (i.j-1).\\n\\nSimilar idea here but we want to count how many ways are there for (i,j-1) and (i-1,j) for each possible remainder and add them together to get (i,j), becaue at the end we want the count of ways for remainder 0 at (m-1,n-1).\\n\\n\\n```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        mod = 10**9+7\\n        ### dp is of size m*n*k, where dp[i][j][value] stores how many ways to get here with a reminder of value\\n        dp = [[[0]*k for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                ### at 0,0 we only have one way\\n                if i==0 and j==0:\\n                    dp[i][j][grid[i][j]%k] += 1\\n                ### for i==0 or j==0, we just check (i,j-1)\\n                elif i==0:\\n                    for key in range(k):\\n                        dp[i][j][(key+grid[i][j])%k] += dp[i][j-1][key]%mod\\n                ### for j==0, we just check (i-1,j)\\n                elif j==0:\\n                    for key in range(k):\\n                        dp[i][j][(key+grid[i][j])%k] += dp[i-1][j][key]%mod\\n                ### for all other position, we need to add result from (i,j-1) and (i-1,j)\\n                else:\\n                    for key in range(k):\\n                        dp[i][j][(key+grid[i][j])%k] += dp[i][j-1][key]%mod\\n                        dp[i][j][(key+grid[i][j])%k] += dp[i-1][j][key]%mod\\n        return dp[m-1][n-1][0]%mod\\n```\\n\\noptimized for space\\n```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        mod = 10**9+7\\n        ### dp is of size n*k, where dp[j][value] stores how many ways to get here with a reminder of value\\n        dp = [[0]*k for _ in range(n)]\\n        last = grid[0][0]%k\\n        dp[0][last] += 1\\n        for j in range(1,n):\\n            dp[j][(last+grid[0][j])%k] += dp[j-1][last]%mod\\n            last = (last+grid[0][j])%k\\n        for i in range(1,m):\\n            cur = [[0]*k for _ in range(n)]\\n            for j in range(n):\\n                ### for j==0, we just check (i-1,j)\\n                if j==0:\\n                    for key in range(k):\\n                        cur[j][(key+grid[i][j])%k] += dp[j][key]%mod\\n                ### for all other position, we need to add result from (i,j-1) and (i-1,j)\\n                else:\\n                    for key in range(k):\\n                        cur[j][(key+grid[i][j])%k] += cur[j-1][key]%mod\\n                        cur[j][(key+grid[i][j])%k] += dp[j][key]%mod\\n            dp = cur\\n        return dp[n-1][0]%mod\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        mod = 10**9+7\\n        ### dp is of size m*n*k, where dp[i][j][value] stores how many ways to get here with a reminder of value\\n        dp = [[[0]*k for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                ### at 0,0 we only have one way\\n                if i==0 and j==0:\\n                    dp[i][j][grid[i][j]%k] += 1\\n                ### for i==0 or j==0, we just check (i,j-1)\\n                elif i==0:\\n                    for key in range(k):\\n                        dp[i][j][(key+grid[i][j])%k] += dp[i][j-1][key]%mod\\n                ### for j==0, we just check (i-1,j)\\n                elif j==0:\\n                    for key in range(k):\\n                        dp[i][j][(key+grid[i][j])%k] += dp[i-1][j][key]%mod\\n                ### for all other position, we need to add result from (i,j-1) and (i-1,j)\\n                else:\\n                    for key in range(k):\\n                        dp[i][j][(key+grid[i][j])%k] += dp[i][j-1][key]%mod\\n                        dp[i][j][(key+grid[i][j])%k] += dp[i-1][j][key]%mod\\n        return dp[m-1][n-1][0]%mod\\n```\n```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        mod = 10**9+7\\n        ### dp is of size n*k, where dp[j][value] stores how many ways to get here with a reminder of value\\n        dp = [[0]*k for _ in range(n)]\\n        last = grid[0][0]%k\\n        dp[0][last] += 1\\n        for j in range(1,n):\\n            dp[j][(last+grid[0][j])%k] += dp[j-1][last]%mod\\n            last = (last+grid[0][j])%k\\n        for i in range(1,m):\\n            cur = [[0]*k for _ in range(n)]\\n            for j in range(n):\\n                ### for j==0, we just check (i-1,j)\\n                if j==0:\\n                    for key in range(k):\\n                        cur[j][(key+grid[i][j])%k] += dp[j][key]%mod\\n                ### for all other position, we need to add result from (i,j-1) and (i-1,j)\\n                else:\\n                    for key in range(k):\\n                        cur[j][(key+grid[i][j])%k] += cur[j-1][key]%mod\\n                        cur[j][(key+grid[i][j])%k] += dp[j][key]%mod\\n            dp = cur\\n        return dp[n-1][0]%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678950,
                "title": "python-dp-solution",
                "content": "# **Explanation**\\n`dp[i][j][kk]` means the number of paths with `sum % k = kk`.\\nThe transform equation is:\\n`dp[i][j][(kk + A[i][j]) % k] = dp[i-1][j][kk] + dp[i][j-1][kk]`\\nWe can use 1D array `dp` to simplify the 2D dp.\\n<br>\\n\\n# **Complexity**\\nTime `O(nmk)`\\nSpace `O(mk)`\\n<br>\\n\\n**Python**\\n```py\\n    def numberOfPaths(self, A, k):\\n        n, m, mod = len(A), len(A[0]), 10**9 + 7\\n        dp = [Counter() for j in range(m + 1)]\\n        dp[0][0] = 1\\n        for i, r in enumerate(A):\\n            for j, a in enumerate(r):\\n                dp[j] = Counter({(a + b) % k: c % mod for b, c in (dp[j] + dp[j-1]).items()})\\n        return dp[m - 1][0]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def numberOfPaths(self, A, k):\\n        n, m, mod = len(A), len(A[0]), 10**9 + 7\\n        dp = [Counter() for j in range(m + 1)]\\n        dp[0][0] = 1\\n        for i, r in enumerate(A):\\n            for j, a in enumerate(r):\\n                dp[j] = Counter({(a + b) % k: c % mod for b, c in (dp[j] + dp[j-1]).items()})\\n        return dp[m - 1][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2678881,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    int[][][] dp;\\n    int mod = 1_000_000_007;\\n    \\n    public int numberOfPaths(int[][] grid, int k) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        dp = new int[rows][cols][k];\\n        for(int[][] a : dp) {\\n            for(int[] b : a) {\\n                Arrays.fill(b, -1);\\n            }\\n        }\\n        \\n        return helper(grid, 0, 0, 0, k);\\n    }\\n    \\n    int helper(int[][] grid, int r, int c, int sum, int k) {\\n        if(r < 0 || r == grid.length || c < 0 || c == grid[0].length) {\\n            return 0;\\n        }\\n        \\n        sum += grid[r][c];\\n        if(r == grid.length-1 && c == grid[0].length-1) {\\n            return sum%k==0 ? 1 : 0;\\n        }\\n        \\n        if(dp[r][c][sum%k] != -1) {\\n            return dp[r][c][sum%k];\\n        }\\n        \\n        dp[r][c][sum%k] = (helper(grid, r+1, c, sum, k) + helper(grid, r, c+1, sum, k)) % mod;\\n        return dp[r][c][sum%k];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int[][][] dp;\\n    int mod = 1_000_000_007;\\n    \\n    public int numberOfPaths(int[][] grid, int k) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        dp = new int[rows][cols][k];\\n        for(int[][] a : dp) {\\n            for(int[] b : a) {\\n                Arrays.fill(b, -1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2678795,
                "title": "forwarding-remainder-diagram-bottom-up-top-down-c-code",
                "content": "**Upvote if you find this helpful**\\n\\n**Intuition:**\\nAs it is asked to calculate total number of paths, it resembles dp problems.\\n\\nAlso the constraints of k are small so a O(m * n * k) approach is feasible.\\n\\nAt every next element of the path, we only need remainder of the sum till the current element of the path.\\n\\nWe only need remainder because (remainder + remaining sum) and (actual sum + remaining sum)\\nBoth when applied operation of %k will give same number.\\n\\n**Approach:**\\nWe carry forward our remainder of the path in each recursive call and whenever we reach at the (m-1,n-1) cell of the matrix, our remainder after adding the value of the cell should be 0.\\n\\nIf it is 0, we return 1, else we return 0.\\n\\nConsider a path of [4,2,6,8,4,2,7] and k = 11\\nWe first start as our currRem as 0.\\n\\n![image](https://assets.leetcode.com/users/images/b50fd305-bc7b-44e0-8319-ee5d75b4f562_1665288078.9763706.png)\\n\\nWe store each state in a dp table.\\n\\nC++ Top-down code:\\n```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n\\tvector<vector<vector<int>>> dp;\\n\\n\\tint rec(int x, int y, int currRem, vector<vector<int>>& grid, int& k)\\n\\t{\\n\\t\\tif (x >= grid.size() || y >= grid[0].size())\\n\\t\\t\\treturn 0;\\n\\t\\tif (x == grid.size() - 1 && y == grid[0].size() - 1)//Base Case\\n\\t\\t{\\n\\t\\t\\tif ((grid[x][y] + currRem) % k == 0)\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (dp[x][y][currRem] != -1)//DP Table Check\\n\\t\\t\\treturn dp[x][y][currRem];\\n\\t\\tint nextRem = (grid[x][y] + currRem) % k;\\n\\t\\t//Calling down and right then filling DP table:\\n\\t\\treturn dp[x][y][currRem] = (rec(x + 1, y, nextRem, grid, k) + rec(x, y + 1, nextRem, grid, k)) % mod;\\n\\t}\\n\\n\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\tint m = grid.size();\\n\\t\\tint n = grid[0].size();\\n\\t\\tvector<vector<int>> temp(n, vector<int>(k, -1));\\n\\t\\tdp.resize(m, temp);\\n\\t\\treturn rec(0, 0, 0, grid, k);\\n\\t}\\n};\\n```\\n\\nC++ Bottom-up code:\\n```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n\\n\\tint giveDPVal(int x, int y, int nextRem, vector<vector<vector<int>>>& dp)\\n\\t{\\n\\t\\tif (x >= dp.size() || y >= dp[0].size())\\n\\t\\t\\treturn 0;\\n\\t\\treturn dp[x][y][nextRem];\\n\\t}\\n\\n\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\tint m = grid.size();\\n\\t\\tint n = grid[0].size();\\n\\t\\tvector<vector<int>> temp(n, vector<int>(k, 0));\\n\\t\\tvector<vector<vector<int>>> dp(m, temp);\\n\\t\\tint lastValue = grid[m - 1][n - 1];\\n\\t\\t\\n\\t\\tdp[m - 1][n - 1][(k - (lastValue % k)) % k] = 1;\\n\\t\\t//There will be only one value of currRem for which the lastElement\\n\\t\\t//of the path will have an answer for\\n\\t\\t//That value is (k - (lastValue % k)) % k\\n\\t\\t//For ex: last Value in the test case we saw in diagram was 7\\n\\t\\t//For 7 we will need only 4 as our currRem\\n\\t\\t//The goal is to make the remainder 0\\n\\t\\t\\n\\t\\tint nextRem;\\n\\t\\tfor (int x = m - 1; x >= 0 ; --x)\\n\\t\\t{\\n\\t\\t\\tfor (int y = n - 1; y >= 0 ; --y)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (x == m - 1 && y == n - 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tfor (int currRem = 0; currRem < k; ++currRem)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnextRem = (currRem + grid[x][y]) % k;\\n\\t\\t\\t\\t\\tdp[x][y][currRem] = giveDPVal(x + 1, y, nextRem, dp) + giveDPVal(x, y + 1, nextRem, dp);\\n\\t\\t\\t\\t\\tdp[x][y][currRem] %= mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[0][0][0];\\n\\t}\\n};\\n```\\nTime Complexity - O(m* n * k)\\nSpace Complexity - O(m * n * k)\\n\\n**Upvote if you found this helpful!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n\\tvector<vector<vector<int>>> dp;\\n\\n\\tint rec(int x, int y, int currRem, vector<vector<int>>& grid, int& k)\\n\\t{\\n\\t\\tif (x >= grid.size() || y >= grid[0].size())\\n\\t\\t\\treturn 0;\\n\\t\\tif (x == grid.size() - 1 && y == grid[0].size() - 1)//Base Case\\n\\t\\t{\\n\\t\\t\\tif ((grid[x][y] + currRem) % k == 0)\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (dp[x][y][currRem] != -1)//DP Table Check\\n\\t\\t\\treturn dp[x][y][currRem];\\n\\t\\tint nextRem = (grid[x][y] + currRem) % k;\\n\\t\\t//Calling down and right then filling DP table:\\n\\t\\treturn dp[x][y][currRem] = (rec(x + 1, y, nextRem, grid, k) + rec(x, y + 1, nextRem, grid, k)) % mod;\\n\\t}\\n\\n\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\tint m = grid.size();\\n\\t\\tint n = grid[0].size();\\n\\t\\tvector<vector<int>> temp(n, vector<int>(k, -1));\\n\\t\\tdp.resize(m, temp);\\n\\t\\treturn rec(0, 0, 0, grid, k);\\n\\t}\\n};\\n```\n```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n\\n\\tint giveDPVal(int x, int y, int nextRem, vector<vector<vector<int>>>& dp)\\n\\t{\\n\\t\\tif (x >= dp.size() || y >= dp[0].size())\\n\\t\\t\\treturn 0;\\n\\t\\treturn dp[x][y][nextRem];\\n\\t}\\n\\n\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\tint m = grid.size();\\n\\t\\tint n = grid[0].size();\\n\\t\\tvector<vector<int>> temp(n, vector<int>(k, 0));\\n\\t\\tvector<vector<vector<int>>> dp(m, temp);\\n\\t\\tint lastValue = grid[m - 1][n - 1];\\n\\t\\t\\n\\t\\tdp[m - 1][n - 1][(k - (lastValue % k)) % k] = 1;\\n\\t\\t//There will be only one value of currRem for which the lastElement\\n\\t\\t//of the path will have an answer for\\n\\t\\t//That value is (k - (lastValue % k)) % k\\n\\t\\t//For ex: last Value in the test case we saw in diagram was 7\\n\\t\\t//For 7 we will need only 4 as our currRem\\n\\t\\t//The goal is to make the remainder 0\\n\\t\\t\\n\\t\\tint nextRem;\\n\\t\\tfor (int x = m - 1; x >= 0 ; --x)\\n\\t\\t{\\n\\t\\t\\tfor (int y = n - 1; y >= 0 ; --y)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (x == m - 1 && y == n - 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tfor (int currRem = 0; currRem < k; ++currRem)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnextRem = (currRem + grid[x][y]) % k;\\n\\t\\t\\t\\t\\tdp[x][y][currRem] = giveDPVal(x + 1, y, nextRem, dp) + giveDPVal(x, y + 1, nextRem, dp);\\n\\t\\t\\t\\t\\tdp[x][y][currRem] %= mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[0][0][0];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678997,
                "title": "recursion-to-dp",
                "content": "Intution: \\n* If you have done similar problems like [Unique Path](https://leetcode.com/problems/unique-paths/). Then this problem is very straight forward\\n* First we will traverse all paths and calcuate the sum of each path and count the number of paths which are divisible by <code>k</code>.\\n* We donot need to store the whole sum, we can just store the remainders of the sum. (This will help in <code>DP</code> solution)\\n\\n\\n\\n\\n\\n**Recursion | TLE**\\n```\\nclass Solution {\\n    int rows,cols;\\n    private static int mod = 1_000_000_007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        this.rows = grid.length;\\n        this.cols = grid[0].length;\\n        return (int)(f(0,0,0,k,grid)%mod);\\n    }\\n    private long f(int r, int c, int sum,int k,int[][] g){\\n        if(r==rows || c==cols) return 0; //If we are out of the grid just return {no possible paths}\\n        sum+=g[r][c];\\n        int rem = sum%k;\\n        if(r==rows-1 && c==cols-1) return (rem==0)?1:0; //If we have reached the end of grid check if the sum is divisible by k\\n        return (f(r+1,c,sum,k,g) + f(r,c+1,sum,k,g))%mod; //Go down and right\\n    }\\n}\\n```\\n\\n\\n\\nNow we just catch the repeating states. (The variables in are function <code>f</code>)\\n**Note**     We are filling the dp array with <code>-1</code>because <code>0</code> is a valid number of ways for a state\\n**DP**\\n```\\nclass Solution {\\n    int rows,cols;\\n    private static int mod = 1_000_000_007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        this.rows = grid.length;\\n        this.cols = grid[0].length;\\n        long[][][] dp = new long[rows][cols][k];\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                for(int m=0;m<k;m++) dp[i][j][m] = -1;\\n            }\\n        }\\n        return (int)(f(0,0,dp,0,k,grid)%mod);\\n    }\\n    private long f(int r, int c, long[][][] dp, int sum,int k,int[][] g){\\n        if(r==rows || c==cols) return 0;\\n        sum+=g[r][c];\\n        int rem = sum%k;\\n        if(dp[r][c][rem]!=-1) return dp[r][c][rem];\\n        if(r==rows-1 && c==cols-1) return dp[r][c][rem] = ((rem==0)?1:0);\\n        return dp[r][c][rem]=(f(r+1,c,dp,sum,k,g) + f(r,c+1,dp,sum,k,g))%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int rows,cols;\\n    private static int mod = 1_000_000_007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        this.rows = grid.length;\\n        this.cols = grid[0].length;\\n        return (int)(f(0,0,0,k,grid)%mod);\\n    }\\n    private long f(int r, int c, int sum,int k,int[][] g){\\n        if(r==rows || c==cols) return 0; //If we are out of the grid just return {no possible paths}\\n        sum+=g[r][c];\\n        int rem = sum%k;\\n        if(r==rows-1 && c==cols-1) return (rem==0)?1:0; //If we have reached the end of grid check if the sum is divisible by k\\n        return (f(r+1,c,sum,k,g) + f(r,c+1,sum,k,g))%mod; //Go down and right\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int rows,cols;\\n    private static int mod = 1_000_000_007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        this.rows = grid.length;\\n        this.cols = grid[0].length;\\n        long[][][] dp = new long[rows][cols][k];\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                for(int m=0;m<k;m++) dp[i][j][m] = -1;\\n            }\\n        }\\n        return (int)(f(0,0,dp,0,k,grid)%mod);\\n    }\\n    private long f(int r, int c, long[][][] dp, int sum,int k,int[][] g){\\n        if(r==rows || c==cols) return 0;\\n        sum+=g[r][c];\\n        int rem = sum%k;\\n        if(dp[r][c][rem]!=-1) return dp[r][c][rem];\\n        if(r==rows-1 && c==cols-1) return dp[r][c][rem] = ((rem==0)?1:0);\\n        return dp[r][c][rem]=(f(r+1,c,dp,sum,k,g) + f(r,c+1,dp,sum,k,g))%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678965,
                "title": "c-dp-explained-and-easy-to-understand",
                "content": "\\n# Approach\\nIt is obvious that this is a grid DP problem.\\n\\nInitialize $$dp[n][m][k]$$ where $$dp[i][j][r]$$ represents the number of paths to $$(i, j)$$ with remainder $$r$$.\\nFrom this we get the following transfer equation:\\n$$dp[i][j][r] = dp[i-1][j][(r-grid[i][j])\\\\mod k] + dp[i][j-1][(r-grid[i][j])\\\\mod k]$$\\n\\nFinally, run the dp and return $$dp[n-1][m-1][0]$$, the number of paths ending at $$(n-1, m-1)$$ divisible by $$k$$.\\n# Complexity\\n- Time complexity: $$O(nmk)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nmk)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        long long dp[n][m][k];\\n        for(int i = 0; i < k; i++) dp[0][0][i] = 0;\\n        dp[0][0][grid[0][0]%k] = 1;\\n        const int MOD =1000000007;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                grid[i][j] %= k;\\n            }\\n        }\\n        for(int i = 1; i< n; i ++){\\n            for(int j = 0; j < k; j++){\\n                dp[i][0][j] = dp[i-1][0][(j-grid[i][0]+k)%k];\\n            }\\n        }        \\n        for(int i = 1; i< m; i ++){\\n            for(int j = 0; j < k; j++){\\n                dp[0][i][j] = dp[0][i-1][(j-grid[0][i]+k)%k];\\n            }\\n        }\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                for(int l = 0; l < k; l++){\\n                    dp[i][j][l] = \\n                        (dp[i-1][j][(l-grid[i][j]+k)%k] + \\n                         dp[i][j-1][(l-grid[i][j]+k)%k]\\n                        ) % MOD;\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1][0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        long long dp[n][m][k];\\n        for(int i = 0; i < k; i++) dp[0][0][i] = 0;\\n        dp[0][0][grid[0][0]%k] = 1;\\n        const int MOD =1000000007;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                grid[i][j] %= k;\\n            }\\n        }\\n        for(int i = 1; i< n; i ++){\\n            for(int j = 0; j < k; j++){\\n                dp[i][0][j] = dp[i-1][0][(j-grid[i][0]+k)%k];\\n            }\\n        }        \\n        for(int i = 1; i< m; i ++){\\n            for(int j = 0; j < k; j++){\\n                dp[0][i][j] = dp[0][i-1][(j-grid[0][i]+k)%k];\\n            }\\n        }\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                for(int l = 0; l < k; l++){\\n                    dp[i][j][l] = \\n                        (dp[i-1][j][(l-grid[i][j]+k)%k] + \\n                         dp[i][j-1][(l-grid[i][j]+k)%k]\\n                        ) % MOD;\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1][0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683305,
                "title": "c-dp-memoization-easy-to-understand",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int mod = 1e9+7;\\n    int help(int i, int j, int sum, int &k, vector<vector<int>> &grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(i<0 || j<0) return 0;\\n        \\n        if(i==0 && j==0) return (sum + grid[0][0])%k==0;\\n        \\n        if(dp[i][j][sum]!=-1) return dp[i][j][sum];\\n        \\n        int top = help(i-1, j, (sum+grid[i][j])%k, k, grid, dp);\\n        \\n        int left = help(i, j-1, (sum+grid[i][j])%k, k, grid, dp);\\n        \\n        return dp[i][j][sum]=(top+left)%mod;\\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) \\n    {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m, vector<vector<int>> (n, vector<int> (k, -1)));\\n        return help(m-1, n-1, 0, k, grid, dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int mod = 1e9+7;\\n    int help(int i, int j, int sum, int &k, vector<vector<int>> &grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(i<0 || j<0) return 0;\\n        \\n        if(i==0 && j==0) return (sum + grid[0][0])%k==0;\\n        \\n        if(dp[i][j][sum]!=-1) return dp[i][j][sum];\\n        \\n        int top = help(i-1, j, (sum+grid[i][j])%k, k, grid, dp);\\n        \\n        int left = help(i, j-1, (sum+grid[i][j])%k, k, grid, dp);\\n        \\n        return dp[i][j][sum]=(top+left)%mod;\\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) \\n    {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m, vector<vector<int>> (n, vector<int> (k, -1)));\\n        return help(m-1, n-1, 0, k, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678803,
                "title": "python-c-dp-o-n-m-k-clean-solution-with-explanation",
                "content": "When we encounter the problem, which has grid and some sort of path, then most definitely we need to come up with some DP solution.\\n\\nHere DP will look like `dp[n][m][mod]`, where `n` is `len(grid)`, m is `len(grid[0])`, `mod` is all possible modulus (`sum % k`, so the size of it will be `k`).\\n\\nBase case: `dp[0][0][grid[0][0] % k] = 1`\\nAfterwards we check both left and upper cell and sum up the number of paths for each `mod` in range of `k` to `dp[i][j][(mod + grid[i][j]) % k]`. At the end we just return number of paths with mod equal to `0`.\\n\\n**Python**\\n\\n```\\ndef numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n    n, m = len(grid), len(grid[0])\\n    dp = [[[0] * k for _ in range(m)] for _ in range(n)]\\n    dp[0][0][grid[0][0] % k] = 1\\n    \\n    for i in range(n):\\n        for j in range(m):\\n            for mod in range(k):\\n                if j > 0:\\n                    dp[i][j][(mod + grid[i][j]) % k] += dp[i][j - 1][mod] % 1000000007\\n                if i > 0:\\n                    dp[i][j][(mod + grid[i][j]) % k] += dp[i - 1][j][mod] % 1000000007\\n    \\n    return dp[-1][-1][0] % 1000000007 \\n```\\n\\n**UPDATE**\\n\\nPython solution started to give TLE sometimes. I believe that test cases were not properly optimized for Python. I created the same solution using C++ and it works completely fine.\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(k, 0)));\\n        dp[0][0][grid[0][0] % k] = 1;\\n        \\n        for (size_t i = 0; i < n; ++i) {\\n            for (size_t j = 0; j < m; ++j) {\\n                for (int mod = 0; mod < k; ++mod) {\\n                    if (j > 0) {\\n                        dp[i][j][(mod + grid[i][j]) % k] += dp[i][j - 1][mod] % 1000000007;\\n                    }\\n                    if (i > 0) {\\n                        dp[i][j][(mod + grid[i][j]) % k] += dp[i - 1][j][mod] % 1000000007;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n - 1][m - 1][0] % 1000000007;\\n    }\\n};\\n```\\n\\nAs [fornoreason](https://leetcode.com/fornoreason/) pointed out, in the solution above we can simply use \\n```\\nint dp[n][m][k];\\nmemset(dp, 0, sizeof(dp));\\n```\\ninstead of vectors to significantly improve running time.",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n    n, m = len(grid), len(grid[0])\\n    dp = [[[0] * k for _ in range(m)] for _ in range(n)]\\n    dp[0][0][grid[0][0] % k] = 1\\n    \\n    for i in range(n):\\n        for j in range(m):\\n            for mod in range(k):\\n                if j > 0:\\n                    dp[i][j][(mod + grid[i][j]) % k] += dp[i][j - 1][mod] % 1000000007\\n                if i > 0:\\n                    dp[i][j][(mod + grid[i][j]) % k] += dp[i - 1][j][mod] % 1000000007\\n    \\n    return dp[-1][-1][0] % 1000000007 \\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(k, 0)));\\n        dp[0][0][grid[0][0] % k] = 1;\\n        \\n        for (size_t i = 0; i < n; ++i) {\\n            for (size_t j = 0; j < m; ++j) {\\n                for (int mod = 0; mod < k; ++mod) {\\n                    if (j > 0) {\\n                        dp[i][j][(mod + grid[i][j]) % k] += dp[i][j - 1][mod] % 1000000007;\\n                    }\\n                    if (i > 0) {\\n                        dp[i][j][(mod + grid[i][j]) % k] += dp[i - 1][j][mod] % 1000000007;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n - 1][m - 1][0] % 1000000007;\\n    }\\n};\\n```\n```\\nint dp[n][m][k];\\nmemset(dp, 0, sizeof(dp));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679442,
                "title": "beginner-friendly-easy-understanding-bottom-up-dp-clean-code",
                "content": "```\\n/* We all have done those path sum problems .. not a big deal. \\n- The only catch here were the constraints as they determined the DP size we require.\\n- Also for space optimisation, instead of storing sum as the 3rd DP parameter, we store (**sum % k**), so it remains inside 50.\\n*/\\nclass Solution {\\npublic:\\n    using ll = long long int;\\n    vector<vector<vector<ll>>> dp;\\n    int n, m;\\n    ll mod = 1e9 + 7;\\n    \\n    ll solve(int i, int j, int sum, vector<vector<int>>& grid, int k){\\n        if(i >= m || j >= n) return 0;\\n        if(i == m-1 && j == n-1){\\n            return 0 == ((sum + grid[i][j]) % k);\\n        }\\n        if(dp[i][j][sum] != -1) return dp[i][j][sum] % mod;\\n        ll down = solve(i+1, j, (sum + grid[i][j]) % k, grid, k) % mod;\\n        ll right = solve(i, j+1, (sum + grid[i][j]) % k, grid, k) % mod;\\n        return dp[i][j][sum] = (down + right) % mod; \\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        dp.resize(m, vector<vector<ll>>(n, vector<ll>(k+1, -1)));\\n        return solve(0, 0, 0, grid, k) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/* We all have done those path sum problems .. not a big deal. \\n- The only catch here were the constraints as they determined the DP size we require.\\n- Also for space optimisation, instead of storing sum as the 3rd DP parameter, we store (**sum % k**), so it remains inside 50.\\n*/\\nclass Solution {\\npublic:\\n    using ll = long long int;\\n    vector<vector<vector<ll>>> dp;\\n    int n, m;\\n    ll mod = 1e9 + 7;\\n    \\n    ll solve(int i, int j, int sum, vector<vector<int>>& grid, int k){\\n        if(i >= m || j >= n) return 0;\\n        if(i == m-1 && j == n-1){\\n            return 0 == ((sum + grid[i][j]) % k);\\n        }\\n        if(dp[i][j][sum] != -1) return dp[i][j][sum] % mod;\\n        ll down = solve(i+1, j, (sum + grid[i][j]) % k, grid, k) % mod;\\n        ll right = solve(i, j+1, (sum + grid[i][j]) % k, grid, k) % mod;\\n        return dp[i][j][sum] = (down + right) % mod; \\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        dp.resize(m, vector<vector<ll>>(n, vector<ll>(k+1, -1)));\\n        return solve(0, 0, 0, grid, k) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678817,
                "title": "a-c-solution-with-explanation-o-n-m-k-time-complexity",
                "content": "**Approach ::**\\n\\n dp[i][j][kk] stores no. of paths till cell ( i , j ), having sum of their element modulo k as kk. \\n As there are two ways to reach (i,j) th cell , from ( i-1, j ) and from (i,j-1)  (not for cells first row and first col)\\n dp[i][j][kk] = dp[ i-1] [ j ][ (kk - g[ i ][ j ]+k)%k ] + dp[ i ][ j-1][( kk-g[ i ][ j ] )%k]\\n \\n Our answer after reaching (n-1,m-1)th cell (0-indexing) will be no. of paths which makes remainder zero.\\n So ans = dp[n-1][m-1][0]\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int numberOfPaths(vector<vector<int>>& g, int k) \\n    {\\n        int n = g.size();\\n        int m = g[0].size();\\n        \\n        int dp[n][m][k];\\n        \\n        int MOD=1e9+7;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                for(int kk=0;kk<k;kk++)\\n                {\\n                    dp[i][j][kk]=0;\\n                    g[i][j]%=k;  \\n                    \\n                    if(i==0&&j==0)\\n                    {\\n                          if(kk==g[i][j])\\n                          dp[i][j][kk]= 1;\\n                    }\\n                    else if(i==0)\\n                    {\\n                          int j1 = (kk-g[i][j]+k)%k;\\n\\t\\t\\t\\t\\t\\t  \\n                         dp[i][j][kk]+=dp[i][j-1][j1]%MOD;\\n                         dp[i][j][kk]%=MOD;\\n                    }\\n                    else if(j==0)\\n                    {\\n                         int j1 = (kk-g[i][j]+k)%k;\\n\\t\\t\\t\\t\\t\\t \\n                         dp[i][j][kk]+=dp[i-1][j][j1]%MOD;\\n                         dp[i][j][kk]%=MOD;\\n                    }\\n                    else\\n                    {\\n                         int j1 = (kk-g[i][j]+k)%k;\\n                         \\n                         dp[i][j][kk]+=(dp[i][j-1][j1]+dp[i-1][j][j1])%MOD;\\n                         dp[i][j][kk]%=MOD;\\n                    }\\n                \\n                }\\n            }\\n            \\n        }\\n        return dp[n-1][m-1][0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int numberOfPaths(vector<vector<int>>& g, int k) \\n    {\\n        int n = g.size();\\n        int m = g[0].size();\\n        \\n        int dp[n][m][k];\\n        \\n        int MOD=1e9+7;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                for(int kk=0;kk<k;kk++)\\n                {\\n                    dp[i][j][kk]=0;\\n                    g[i][j]%=k;  \\n                    \\n                    if(i==0&&j==0)\\n                    {\\n                          if(kk==g[i][j])\\n                          dp[i][j][kk]= 1;\\n                    }\\n                    else if(i==0)\\n                    {\\n                          int j1 = (kk-g[i][j]+k)%k;\\n\\t\\t\\t\\t\\t\\t  \\n                         dp[i][j][kk]+=dp[i][j-1][j1]%MOD;\\n                         dp[i][j][kk]%=MOD;\\n                    }\\n                    else if(j==0)\\n                    {\\n                         int j1 = (kk-g[i][j]+k)%k;\\n\\t\\t\\t\\t\\t\\t \\n                         dp[i][j][kk]+=dp[i-1][j][j1]%MOD;\\n                         dp[i][j][kk]%=MOD;\\n                    }\\n                    else\\n                    {\\n                         int j1 = (kk-g[i][j]+k)%k;\\n                         \\n                         dp[i][j][kk]+=(dp[i][j-1][j1]+dp[i-1][j][j1])%MOD;\\n                         dp[i][j][kk]%=MOD;\\n                    }\\n                \\n                }\\n            }\\n            \\n        }\\n        return dp[n-1][m-1][0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689350,
                "title": "detailed-easy-to-understand-c-dp-o-m-n-k-solution-no-tle",
                "content": "* How to approach the problem?\\n\\t* First try to solve [62. Unique Paths](https://leetcode.com/problems/unique-paths/). If solved it you\\'re ready to solve this problem.\\n\\t* You need to find all the possible paaths where the total sum is divisible by given number (K).\\n\\t* This problem requires the use of DP.\\n\\t* Think of the scenario when grid size is 1x1. Then the posible answer could be 0 or 1 depending on the fact if that number is devisible by K or not.\\n\\t\\t* For example: cosider a problem with grid length (1x1) with [4] as grid element and say K = 2.  As 4 is devisible by 2 so, there are total 1 acceptable path. But if grid element is say [5] then the answer would have been 0.\\n\\t* Now When we to go to any arbitary row and column in grid (say i & j) then from that point there might be multiple path to the end of grid (destination) and each path might have diffence sum.\\n\\t* Note that we only need to know if sum is divisible by k or not.\\n\\t* Now we can make 3D array of size **MNK** (say the 3rd dimension in the array has index s) for DP. We have chosen the number of third dimension as K, Why? because as refered in last point we need to know if sum is divisible by K or not, so we only need to store the module of the sum with K. And so only possible valuse will be from 0 to K-1.\\n\\t* Now the s-index of 3rd dimension will have the total count of possible paths wich have the path sum modulo with K equal to s. (read  this line 2-3 times if don\\'t get it).\\n\\t* At any given location we can go either left or right.\\n\\t* Sum the value of the grid at given location with all the values stored in 3rd dimention of right-step and down-step and see how many of them returning 0 after taking modulo with k. That will be the answer you desired. \\n\\t* Here is the code.\\n```\\nclass Solution {\\nprivate:\\n    int helper(int i, int j, int s, int m, int n, int k, vector<vector<int>>& grid, vector<vector<vector<int>>> &dp) {\\n        if(dp[i][j][s] != -1) return dp[i][j][s]; // If value available in DP table return it.\\n        if(i >= m || j >= n) return 0; // If indexing going out of boundary return 0 (No possible path).\\n        if(i == m-1 && j == n-1) return ((s + grid[i][j]) % k) == 0; // If at last grid cell (Or only gird size = 1x1) then answer will be 1 is grid value is devisible by k and 0 if not.\\n        else \\n\\t\\t\\t/* Here we are doing most of steps. Adding all the possible path from right and down if total sum is divisible by k (if at index s=0 Why? thinlk).\\n\\t\\t\\t(Because at index s we\\'re storing the number of path which have the valu as (toal sum % k == s).*/\\n            return dp[i][j][s] = (helper(i+1, j, (s+grid[i][j])%k, m, n, k, grid, dp) + helper(i, j+1, (s+grid[i][j])%k, m,n,k,grid, dp)) % (1e9 + 7);\\n    }\\n    \\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(),  n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m+1, vector<vector<int>>(n+1, vector<int>(k+1, -1))); // 3D array as descibed in approach above.\\n        return helper(0,0,0,m,n,k,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(int i, int j, int s, int m, int n, int k, vector<vector<int>>& grid, vector<vector<vector<int>>> &dp) {\\n        if(dp[i][j][s] != -1) return dp[i][j][s]; // If value available in DP table return it.\\n        if(i >= m || j >= n) return 0; // If indexing going out of boundary return 0 (No possible path).\\n        if(i == m-1 && j == n-1) return ((s + grid[i][j]) % k) == 0; // If at last grid cell (Or only gird size = 1x1) then answer will be 1 is grid value is devisible by k and 0 if not.\\n        else \\n\\t\\t\\t/* Here we are doing most of steps. Adding all the possible path from right and down if total sum is divisible by k (if at index s=0 Why? thinlk).\\n\\t\\t\\t(Because at index s we\\'re storing the number of path which have the valu as (toal sum % k == s).*/\\n            return dp[i][j][s] = (helper(i+1, j, (s+grid[i][j])%k, m, n, k, grid, dp) + helper(i, j+1, (s+grid[i][j])%k, m,n,k,grid, dp)) % (1e9 + 7);\\n    }\\n    \\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(),  n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m+1, vector<vector<int>>(n+1, vector<int>(k+1, -1))); // 3D array as descibed in approach above.\\n        return helper(0,0,0,m,n,k,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683382,
                "title": "kotlin-easy-to-understand-dp",
                "content": "```\\nclass Solution {\\n    fun numberOfPaths(grid: Array<IntArray>, k: Int): Int {\\n        val m = grid.size\\n        val n = grid[0].size\\n        val mod = (1e9+7).toInt()\\n        val rem = Array(m) { i: Int ->\\n            IntArray(n) { j: Int ->\\n                grid[i][j] % k\\n            }\\n        }\\n        val dp = Array(m) { Array(n) { IntArray(k) } }\\n        dp[0][0][rem[0][0]] = 1\\n        for (i in 0 until m) {\\n            for (j in 0 until n) {\\n                if (i + j == 0) continue\\n                val remainder = rem[i][j]\\n                val arr = dp[i][j]\\n                if (i > 0) {\\n                    val up = dp[i - 1][j]\\n                    val dup = up.toList()\\n                    Collections.rotate(dup, remainder)\\n                    for (u in dup.indices) {\\n                        arr[u] += dup[u]\\n                        arr[u] %= mod\\n                    }\\n                }\\n                if (j > 0) {\\n                    val left = dp[i][j - 1]\\n                    val dup = left.toList()\\n                    Collections.rotate(dup, remainder)\\n                    for (u in dup.indices) {\\n                        arr[u] += dup[u]\\n                        arr[u] %= mod\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m - 1][n - 1][0]\\n    }\\n}\\n```\\nPicture of DP:\\n![dp](https://assets.leetcode.com/users/images/b60b2d69-c88b-4c1f-b24d-242c07635e62_1665354295.2400808.png)\\n\\n",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    fun numberOfPaths(grid: Array<IntArray>, k: Int): Int {\\n        val m = grid.size\\n        val n = grid[0].size\\n        val mod = (1e9+7).toInt()\\n        val rem = Array(m) { i: Int ->\\n            IntArray(n) { j: Int ->\\n                grid[i][j] % k\\n            }\\n        }\\n        val dp = Array(m) { Array(n) { IntArray(k) } }\\n        dp[0][0][rem[0][0]] = 1\\n        for (i in 0 until m) {\\n            for (j in 0 until n) {\\n                if (i + j == 0) continue\\n                val remainder = rem[i][j]\\n                val arr = dp[i][j]\\n                if (i > 0) {\\n                    val up = dp[i - 1][j]\\n                    val dup = up.toList()\\n                    Collections.rotate(dup, remainder)\\n                    for (u in dup.indices) {\\n                        arr[u] += dup[u]\\n                        arr[u] %= mod\\n                    }\\n                }\\n                if (j > 0) {\\n                    val left = dp[i][j - 1]\\n                    val dup = left.toList()\\n                    Collections.rotate(dup, remainder)\\n                    for (u in dup.indices) {\\n                        arr[u] += dup[u]\\n                        arr[u] %= mod\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m - 1][n - 1][0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679147,
                "title": "bottom-up-dp-faster-than-100",
                "content": "```java\\npublic int numberOfPaths(int[][] grid, int k) {\\n    int n = grid.length,m = grid[0].length;\\n    int[][][] dp  = new int[n][m][k];\\n    int tmp = 0;\\n    for(int i=0;i<n;i++) {\\n        tmp += grid[i][0];\\n        dp[i][0][tmp%k]++;\\n    }\\n    tmp = grid[0][0];\\n    for(int j=1;j<m;j++) {\\n        tmp += grid[0][j];\\n        dp[0][j][tmp%k]++;\\n    }\\n    for(int i=1;i<n;i++){\\n        for(int j=1;j<m;j++){\\n            for(int a=0;a<k;a++){\\n                dp[i][j][(grid[i][j]+a)%k] = (dp[i][j-1][a] + dp[i-1][j][a]) % 1_000_000_007;\\n            }\\n        }\\n    }\\n    return dp[n-1][m-1][0];\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int numberOfPaths(int[][] grid, int k) {\\n    int n = grid.length,m = grid[0].length;\\n    int[][][] dp  = new int[n][m][k];\\n    int tmp = 0;\\n    for(int i=0;i<n;i++) {\\n        tmp += grid[i][0];\\n        dp[i][0][tmp%k]++;\\n    }\\n    tmp = grid[0][0];\\n    for(int j=1;j<m;j++) {\\n        tmp += grid[0][j];\\n        dp[0][j][tmp%k]++;\\n    }\\n    for(int i=1;i<n;i++){\\n        for(int j=1;j<m;j++){\\n            for(int a=0;a<k;a++){\\n                dp[i][j][(grid[i][j]+a)%k] = (dp[i][j-1][a] + dp[i-1][j][a]) % 1_000_000_007;\\n            }\\n        }\\n    }\\n    return dp[n-1][m-1][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2691634,
                "title": "python-3-10-lines-dp-t-m-85-40",
                "content": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        \\n        M, N, MOD = range(len(grid)), range(len(grid[0])), 1000000007\\n        dp = [[[0] * k for _ in N] for _ in M]\\n        \\n        dp[0][0][grid[0][0] % k] = 1\\n\\n        for i in M:\\n            for j in N:\\n                for rem in range(k):\\n                    \\n                    idx = (rem + grid[i][j]) % k\\n                    \\n                    dp[i][j][idx] += dp[i][j-1][rem] if j > 0 else 0\\n                    dp[i][j][idx] += dp[i-1][j][rem] if i > 0 else 0\\n\\n        return dp[-1][-1][0] %MOD\\n```\\n[https://leetcode.com/submissions/detail/820302098/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        \\n        M, N, MOD = range(len(grid)), range(len(grid[0])), 1000000007\\n        dp = [[[0] * k for _ in N] for _ in M]\\n        \\n        dp[0][0][grid[0][0] % k] = 1\\n\\n        for i in M:\\n            for j in N:\\n                for rem in range(k):\\n                    \\n                    idx = (rem + grid[i][j]) % k\\n                    \\n                    dp[i][j][idx] += dp[i][j-1][rem] if j > 0 else 0\\n                    dp[i][j][idx] += dp[i-1][j][rem] if i > 0 else 0\\n\\n        return dp[-1][-1][0] %MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681250,
                "title": "bottom-up-3d-dp",
                "content": "# Intuition\\nWe can use the property of remainder and we are adding so remainder will also be added.\\n`(rem(grid[i][j]) + rem(grid[i - 1][j])) % k` to get the remainder of that path.\\n\\nAs there are going to be recurent sub-problems we can use Dynamic Programming over here.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**Bottom Up Approach**\\nIn Bottom Up Approach we compute the frequencies of paths with remainder `r` at `dp[i - 1][j][r]` and `dp[i][j - 1][r]` then we add `(r + grid[i][j]) % k` as `s` to get the new remainder where this frequencies:\\n`dp[i][j][s] = (dp[i - 1][j][r] + dp[i][j - 1][r]) % mod`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n * m * k)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n * m * k)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>> (m + 1, vector<int> (k, 0)));\\n        dp[0][1][0] = 1;\\n        int i, j, r, s, mod = 1e9 + 7;\\n        for(i = 0; i < n; i++) {\\n            for(j = 0; j < m; j++) {\\n                for(r = 0; r < k; r++) {\\n                    s = (r + grid[i][j]) % k;\\n                    dp[i + 1][j + 1][s] = (dp[i][j + 1][r] + dp[i + 1][j][r]) % mod;\\n                }\\n            }\\n        }\\n        return dp[n][m][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>> (m + 1, vector<int> (k, 0)));\\n        dp[0][1][0] = 1;\\n        int i, j, r, s, mod = 1e9 + 7;\\n        for(i = 0; i < n; i++) {\\n            for(j = 0; j < m; j++) {\\n                for(r = 0; r < k; r++) {\\n                    s = (r + grid[i][j]) % k;\\n                    dp[i + 1][j + 1][s] = (dp[i][j + 1][r] + dp[i + 1][j][r]) % mod;\\n                }\\n            }\\n        }\\n        return dp[n][m][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680811,
                "title": "tle-inconsistent-in-python",
                "content": "The pass of this question seems to be inconsistent. When I first submitted it during contest it got TLE even when the complexity is `O(mnk)`, but after I tried it again it got passed. Same thing repeated.",
                "solutionTags": [],
                "code": "The pass of this question seems to be inconsistent. When I first submitted it during contest it got TLE even when the complexity is `O(mnk)`, but after I tried it again it got passed. Same thing repeated.",
                "codeTag": "Unknown"
            },
            {
                "id": 2678943,
                "title": "c-top-down-3d-dp-memoization-o-m-n-k",
                "content": "# Intuition\\n3D Dynamic Problem using memoization\\n \\n# Complexity\\n- Time complexity:\\nO(m\\\\*n\\\\*k)\\n\\n- Space complexity:\\nO(m\\\\*n\\\\*k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fff(vector<vector<int>>& a, int m, int n, int sum ,int k , vector<vector<vector<int>>> &dp)\\n    {\\n        if (m==0 && n==0) {\\n            if(sum%k == 0 ) return 1;\\n            else return 0; \\n        }\\n        //use previous value\\n        if (dp[m][n][sum] != -1) return dp[m][n][sum];\\n\\n        int l=0,r=0; \\n        \\n        if(m-1 >=0 && n >=0)\\n        l = fff(a, m-1, n, (sum + a[m-1][n])%k , k, dp);\\n        \\n        if(n-1 >=0 && m >=0 )\\n        r = fff(a, m, n-1, (sum + a[m][n-1])%k, k, dp);\\n\\n        return dp[m][n][sum] = (l + r) % 1000000007;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<vector<int>>> dp(m, vector<vector<int>> (n, vector<int> (k+1, -1)));\\n\\n        return fff(grid, m-1, n-1, (grid[m-1][n-1])%k, k ,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fff(vector<vector<int>>& a, int m, int n, int sum ,int k , vector<vector<vector<int>>> &dp)\\n    {\\n        if (m==0 && n==0) {\\n            if(sum%k == 0 ) return 1;\\n            else return 0; \\n        }\\n        //use previous value\\n        if (dp[m][n][sum] != -1) return dp[m][n][sum];\\n\\n        int l=0,r=0; \\n        \\n        if(m-1 >=0 && n >=0)\\n        l = fff(a, m-1, n, (sum + a[m-1][n])%k , k, dp);\\n        \\n        if(n-1 >=0 && m >=0 )\\n        r = fff(a, m, n-1, (sum + a[m][n-1])%k, k, dp);\\n\\n        return dp[m][n][sum] = (l + r) % 1000000007;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<vector<int>>> dp(m, vector<vector<int>> (n, vector<int> (k+1, -1)));\\n\\n        return fff(grid, m-1, n-1, (grid[m-1][n-1])%k, k ,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558506,
                "title": "c-dp-memoization",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n*k)\\n\\n- Space complexity:\\nO(m*n*k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 0;\\n    int solve(int i,int j,int &m,int &n,int &k,vector<vector<int>> &g,vector<vector<vector<int>>> &dp,int sum){\\n        if(i<0||j<0||i>=m||j>=n)return 0;\\n        if(i==m-1&&j==n-1){\\n            sum = (sum+g[i][j])%k;\\n            if(sum%k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][j][sum] != -1){\\n            return dp[i][j][sum];\\n        }\\n        return dp[i][j][sum%k] = (solve(i+1,j,m,n,k,g,dp,(sum+g[i][j])%k)+solve(i,j+1,m,n,k,g,dp,(sum+g[i][j])%k))%mod;;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        mod = 1e9+7;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<int> > > dp(m, vector<vector<int> >(n, vector<int>(k+1,-1)));\\n        return solve(0,0,m,n,k,grid,dp,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 0;\\n    int solve(int i,int j,int &m,int &n,int &k,vector<vector<int>> &g,vector<vector<vector<int>>> &dp,int sum){\\n        if(i<0||j<0||i>=m||j>=n)return 0;\\n        if(i==m-1&&j==n-1){\\n            sum = (sum+g[i][j])%k;\\n            if(sum%k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][j][sum] != -1){\\n            return dp[i][j][sum];\\n        }\\n        return dp[i][j][sum%k] = (solve(i+1,j,m,n,k,g,dp,(sum+g[i][j])%k)+solve(i,j+1,m,n,k,g,dp,(sum+g[i][j])%k))%mod;;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        mod = 1e9+7;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<int> > > dp(m, vector<vector<int> >(n, vector<int>(k+1,-1)));\\n        return solve(0,0,m,n,k,grid,dp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678967,
                "title": "c-dp-solution-easy-to-understand",
                "content": "The solution is written such that even a beginner can understand by dry run!\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n\\n    int f(int i,int j,vector<vector<int>>& grid, int k,int pathSum,vector<vector<vector<int>>>&dp) {\\n        if(i<0 || i>=grid.size() || j<0 || j >= grid[0].size())\\n            return 0;\\n        if(dp[i][j][pathSum%k]!=-1)\\n            return dp[i][j][pathSum%k];\\n        if(i==grid.size()-1 and j==grid[0].size()-1){\\n            pathSum+=grid[i][j];\\n            if(pathSum % k ==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int d= f(i+1,j,grid,k,pathSum+grid[i][j],dp) % mod;\\n        int r = f(i,j+1,grid,k,pathSum+grid[i][j],dp) % mod;\\n        return dp[i][j][pathSum%k]=((d+r)%mod);\\n       \\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        vector<vector<vector<int>>> dp(grid.size(), vector<vector<int>>(grid[0].size(), vector<int>(k, -1)));\\n        int ans = f(0,0,grid,k,0,dp);\\n        return ans%mod;\\n    }\\n};\\n```\\n\\nYou can upvote to appreciate the solution!!! Thanks",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n\\n    int f(int i,int j,vector<vector<int>>& grid, int k,int pathSum,vector<vector<vector<int>>>&dp) {\\n        if(i<0 || i>=grid.size() || j<0 || j >= grid[0].size())\\n            return 0;\\n        if(dp[i][j][pathSum%k]!=-1)\\n            return dp[i][j][pathSum%k];\\n        if(i==grid.size()-1 and j==grid[0].size()-1){\\n            pathSum+=grid[i][j];\\n            if(pathSum % k ==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int d= f(i+1,j,grid,k,pathSum+grid[i][j],dp) % mod;\\n        int r = f(i,j+1,grid,k,pathSum+grid[i][j],dp) % mod;\\n        return dp[i][j][pathSum%k]=((d+r)%mod);\\n       \\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        vector<vector<vector<int>>> dp(grid.size(), vector<vector<int>>(grid[0].size(), vector<int>(k, -1)));\\n        int ans = f(0,0,grid,k,0,dp);\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678916,
                "title": "add-down-and-right-ways-for-each-remainder-explanation-and-comments",
                "content": "**Please upvote if find helpful :)**\\n\\nThere are two possibilities , Go left or Go down\\nWe have done such question in calculating total ways\\nwhere ```dp[i][j]=dp[i][j+1] + dp[i+1][j]```\\n\\nNow here we are interested in ways where sum of elements is divisible by k , but to explore all possibilities we need to store each sum or we can store remainder corresponding to each sum\\n\\nTo store count of all remainder , we need a 3d matrix\\nwhere **dp[i][j] stores count corresponding to rem={0,1,2,....k-1}**\\n\\n**LOGIC** : Get all possible remainders to the right and down , add those remainder with grid[i][j] and store count of new remainder in dp[i][j]\\n\\n```\\nint numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<vector<long long> > > dp(m, vector<vector<long long> > (n, vector<long long>(k,0)));\\n        vector<long long>v(k,0);\\n        int mod=1e9+7;\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                int rem=grid[i][j]%k;\\n                if(i==m-1 and j==n-1) { dp[i][j][rem]=1; continue ; }  // base case\\n                auto right=(j==n-1?v:dp[i][j+1]);\\n                auto down=(i==m-1?v:dp[i+1][j]);\\n                \\n                for(int r=0;r<k;r++){       //check ways corresponding to each remainder\\n                    int nrem=rem+r;\\n                    nrem%=k;                            // new remainder after adding grid[i][j]\\n                    dp[i][j][nrem]+=right[r];\\n                    dp[i][j][nrem]+=down[r];\\n                    dp[i][j][nrem]%=mod;\\n                }\\n            }\\n        }\\n        return dp[0][0][0]%mod;\\n   }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j]=dp[i][j+1] + dp[i+1][j]```\n```\\nint numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<vector<long long> > > dp(m, vector<vector<long long> > (n, vector<long long>(k,0)));\\n        vector<long long>v(k,0);\\n        int mod=1e9+7;\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                int rem=grid[i][j]%k;\\n                if(i==m-1 and j==n-1) { dp[i][j][rem]=1; continue ; }  // base case\\n                auto right=(j==n-1?v:dp[i][j+1]);\\n                auto down=(i==m-1?v:dp[i+1][j]);\\n                \\n                for(int r=0;r<k;r++){       //check ways corresponding to each remainder\\n                    int nrem=rem+r;\\n                    nrem%=k;                            // new remainder after adding grid[i][j]\\n                    dp[i][j][nrem]+=right[r];\\n                    dp[i][j][nrem]+=down[r];\\n                    dp[i][j][nrem]%=mod;\\n                }\\n            }\\n        }\\n        return dp[0][0][0]%mod;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678796,
                "title": "java-dynamic-programming-solution-explained-o-n-2-k",
                "content": "\\n1. *Intuition*:\\nYou might think to use `dp[i][j]` to keep all paths that are divisible by k. However, this is not ideal, as previous paths that are not divisible by k might become divisible again when adding a new element.\\n\\n\\t**e.g.**\\n\\t\\n\\t**2** **6**\\n\\t7 **8**\\t\\n\\t\\n\\t(6 + 8) % 4 == 2\\n\\t(6 + 8 + 2) % 4 == 0\\n\\n\\n\\tTherefore we have to store all previous possible remainders.\\n\\n2. *Bottom-up dp:*\\n\\tdp[i][j][l] represents the total number of paths from ith row and jth index where the **sum of elements divided by k is l**.\\n\\n\\tSince  you only have to check divisibility to count number of paths, you can store only remainders from `0 ... k-1`, instead of storing entire sum.\\n\\n3. *Recurrence relation*:\\n`dp[i][j][(grid[i][j] + l) % k]` = \\n\\t`dp[i][j+1][l]` for all l in `[0, ..., k-1]` +\\n\\t`dp[i+1][j][l]` for all l in `[0, ..., k-1]`\\n\\n\\n\\tnewRemainder = (grid[i][j] + previousRemainder) % k\\n4. *Time/Space Complexity*:\\n**O(N^2 * k)**\\n\\n```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        // constants\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int mod = 1_000_000_007;\\n\\t\\t\\n\\t\\t// directions -> { right, bottom }\\n        int[][] directions = new int[][]{{0,1}, {1,0}};\\n\\t\\t\\n\\t\\t//dp[i][j][l] represents the total number of paths from ith row and jth index where the sum of elements divided by k is l.\\n        long[][][] dp = new long[n][m][k];\\n        \\n        // base case\\n        dp[n-1][m-1][grid[n-1][m-1] % k]++;\\n        \\n        // recurrence relation\\n        for (int i = n-1; i >= 0; i--) {\\n            for (int j = m-1; j >= 0; j--) {\\n                if (i == n-1 && j == m-1) {\\n                    continue;\\n                }        \\n                \\n                long[] curr = dp[i][j];\\n\\t\\t\\t\\t// check right and bottom\\n                for (int[] dir : directions) {\\n                    int x = dir[0] + i, y = dir[1] + j;\\n                    if (x >= n || y >= m) { // check within grid\\n                        continue;\\n                    }\\n                    \\n                    long[] next = dp[x][y];\\n                    for (int l = 0; l < k; l++) {\\n                        int currRemainder = (l + grid[i][j]) % k;\\n                        curr[currRemainder] += next[l];\\n                        curr[currRemainder] %= mod;\\n                    }\\n                }\\n\\n            }\\n        }\\n        \\n        return (int) (dp[0][0][0] % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        // constants\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int mod = 1_000_000_007;\\n\\t\\t\\n\\t\\t// directions -> { right, bottom }\\n        int[][] directions = new int[][]{{0,1}, {1,0}};\\n\\t\\t\\n\\t\\t//dp[i][j][l] represents the total number of paths from ith row and jth index where the sum of elements divided by k is l.\\n        long[][][] dp = new long[n][m][k];\\n        \\n        // base case\\n        dp[n-1][m-1][grid[n-1][m-1] % k]++;\\n        \\n        // recurrence relation\\n        for (int i = n-1; i >= 0; i--) {\\n            for (int j = m-1; j >= 0; j--) {\\n                if (i == n-1 && j == m-1) {\\n                    continue;\\n                }        \\n                \\n                long[] curr = dp[i][j];\\n\\t\\t\\t\\t// check right and bottom\\n                for (int[] dir : directions) {\\n                    int x = dir[0] + i, y = dir[1] + j;\\n                    if (x >= n || y >= m) { // check within grid\\n                        continue;\\n                    }\\n                    \\n                    long[] next = dp[x][y];\\n                    for (int l = 0; l < k; l++) {\\n                        int currRemainder = (l + grid[i][j]) % k;\\n                        curr[currRemainder] += next[l];\\n                        curr[currRemainder] %= mod;\\n                    }\\n                }\\n\\n            }\\n        }\\n        \\n        return (int) (dp[0][0][0] % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718329,
                "title": "java-solution-dp",
                "content": "* For each cell store the path count with remainder = k\\n* (A+B)%K = (A%K + B%K)%K\\n* For each cell compute paths with mod value =k based on the right & bottom cells.\\n\\n```\\n    private final int mod = (int) (Math.pow(10,9) + 7);\\n    public int numberOfPaths(int[][] grid, int k) {\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] modGrid = new int[m][n][k];\\n        modGrid[m-1][n-1][grid[m-1][n-1]%k]+=1;\\n\\n        for (int i=m-2,j=n-1;i>=0;i--) {\\n            for (int p=0;p<k;p++) {\\n                if(modGrid[i+1][j][p]>0) {\\n                    modGrid[i][j][((grid[i][j])+p)%k]+=1;\\n                }\\n            }\\n        }\\n\\n        for (int i=m-1,j=n-2;j>=0;j--) {\\n            for (int p=0;p<k;p++) {\\n                if(modGrid[i][j+1][p]>0) {\\n                    modGrid[i][j][((grid[i][j])+p)%k]+=1;\\n                }\\n            }\\n        }\\n\\n        for (int i=m-2;i>=0;i--) {\\n            for (int j=n-2;j>=0;j--) {\\n                // right\\n                for (int p=0;p<k;p++) {\\n                    if(modGrid[i][j+1][p]>0) {\\n                        modGrid[i][j][(grid[i][j]+p)%k]+=(modGrid[i][j+1][p])%mod;\\n                    }\\n                }\\n                // down\\n                for (int p=0;p<k;p++) {\\n                    if(modGrid[i+1][j][p]>0) {\\n                        modGrid[i][j][(grid[i][j]+p)%k]+=(modGrid[i+1][j][p])%mod;\\n                    }\\n                }\\n            }\\n        }\\n        return modGrid[0][0][0]%mod;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    private final int mod = (int) (Math.pow(10,9) + 7);\\n    public int numberOfPaths(int[][] grid, int k) {\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] modGrid = new int[m][n][k];\\n        modGrid[m-1][n-1][grid[m-1][n-1]%k]+=1;\\n\\n        for (int i=m-2,j=n-1;i>=0;i--) {\\n            for (int p=0;p<k;p++) {\\n                if(modGrid[i+1][j][p]>0) {\\n                    modGrid[i][j][((grid[i][j])+p)%k]+=1;\\n                }\\n            }\\n        }\\n\\n        for (int i=m-1,j=n-2;j>=0;j--) {\\n            for (int p=0;p<k;p++) {\\n                if(modGrid[i][j+1][p]>0) {\\n                    modGrid[i][j][((grid[i][j])+p)%k]+=1;\\n                }\\n            }\\n        }\\n\\n        for (int i=m-2;i>=0;i--) {\\n            for (int j=n-2;j>=0;j--) {\\n                // right\\n                for (int p=0;p<k;p++) {\\n                    if(modGrid[i][j+1][p]>0) {\\n                        modGrid[i][j][(grid[i][j]+p)%k]+=(modGrid[i][j+1][p])%mod;\\n                    }\\n                }\\n                // down\\n                for (int p=0;p<k;p++) {\\n                    if(modGrid[i+1][j][p]>0) {\\n                        modGrid[i][j][(grid[i][j]+p)%k]+=(modGrid[i+1][j][p])%mod;\\n                    }\\n                }\\n            }\\n        }\\n        return modGrid[0][0][0]%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690146,
                "title": "c-recursion-memoization-clean-code",
                "content": "# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/b3095653-2438-4b62-8efc-8e25d812473d_1665414547.3429873.png)\\n\\n**T->O(Expo) && S->O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,int path,int k,vector<vector<int>>& grid){\\n\\t\\t\\tif(i<0 || i>grid.size() || j<0 || j>grid[0].size()) return 0;\\n\\t\\t\\tif(!i && !j){\\n\\t\\t\\t\\tif((path+grid[0][0])%k==0) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint up=f(i-1,j,path+grid[i][j],k,grid);\\n\\t\\t\\tint left=f(i,j-1,path+grid[i][j],k,grid);\\n\\t\\t\\treturn up+left;\\n\\t\\t}\\n\\n\\t\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\t\\tint m=grid.size();\\n\\t\\t\\tint n=grid[0].size();\\n\\t\\t\\treturn f(m-1,n-1,0,k,grid);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method -2 [Memoization]\\t\\n![image](https://assets.leetcode.com/users/images/db497811-75b2-4949-85aa-22ebe6191912_1665415433.7838402.png)\\n\\n**T->O(mnk) && S->O(mnk) + O(n) [Recursion stack space]**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mod=1e9+7;\\n\\t\\tint f(int i,int j,int path,int k,vector<vector<int>>& grid,vector<vector<vector<int>>>& dp){\\n\\t\\t\\tif(i<0 || i>grid.size() || j<0 || j>grid[0].size()) return 0;\\n\\t\\t\\tif(!i && !j){\\n\\t\\t\\t\\tif((path+grid[0][0])%k==0) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][j][path]!=-1) return dp[i][j][path];\\n\\t\\t\\tint up=f(i-1,j,(path+grid[i][j])%k,k,grid,dp);\\n\\t\\t\\tint left=f(i,j-1,(path+grid[i][j])%k,k,grid,dp);\\n\\t\\t\\treturn dp[i][j][path]=(up+left)%mod;\\n\\t\\t}\\n\\n\\t\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\t\\tint m=grid.size();\\n\\t\\t\\tint n=grid[0].size();\\n\\t\\t\\tvector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n\\t\\t\\treturn f(m-1,n-1,0,k,grid,dp);\\n\\t\\t}\\n\\t};\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,int path,int k,vector<vector<int>>& grid){\\n\\t\\t\\tif(i<0 || i>grid.size() || j<0 || j>grid[0].size()) return 0;\\n\\t\\t\\tif(!i && !j){\\n\\t\\t\\t\\tif((path+grid[0][0])%k==0) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2681995,
                "title": "java-bottom-up-dp-beats-100",
                "content": "![image](https://assets.leetcode.com/users/images/1d2669f4-7b6e-4a5e-916f-b92b004a02ae_1665327751.6468332.png)\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD = 1_000_000_000 + 7;\\n    \\n    public int numberOfPaths(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] dp = new int[m][n][k + 1];\\n        \\n        // base case\\n        int lastCellRemainder = grid[m-1][n-1] % k;\\n        dp[m-1][n-1][lastCellRemainder] = 1;\\n\\t\\t\\n        int lastRemainder = lastCellRemainder;\\n        // last row base case\\n        for (int c = n-2; c >= 0; c--) {\\n            int cellRemainder = grid[m-1][c] % k;\\n            dp[m-1][c][(lastRemainder + cellRemainder) % k] = 1;\\n            lastRemainder = (lastRemainder + cellRemainder) % k;\\n        }\\n        \\n        lastRemainder = lastCellRemainder;\\n        // last col base case\\n        for (int r = m-2; r >= 0; r--) {\\n            int cellRemainder = grid[r][n-1] % k;\\n            dp[r][n-1][(lastRemainder + cellRemainder) % k] = 1;\\n            lastRemainder = (lastRemainder + cellRemainder) % k;\\n        }\\n        \\n        // Recurrence relation\\n        for (int r = m-2; r >= 0; r--) {\\n            for (int c = n-2; c >= 0; c--) {\\n                int cellRemainder = grid[r][c] % k;\\n                \\n                for (int rem = 0; rem <= k; rem++) {\\n                    dp[r][c][(cellRemainder + rem) % k] = (dp[r][c][(cellRemainder + rem) % k] + dp[r][c+1][rem]) % MOD;\\n                    dp[r][c][(cellRemainder + rem) % k] = (dp[r][c][(cellRemainder + rem) % k] + dp[r+1][c][rem]) % MOD;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1_000_000_000 + 7;\\n    \\n    public int numberOfPaths(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] dp = new int[m][n][k + 1];\\n        \\n        // base case\\n        int lastCellRemainder = grid[m-1][n-1] % k;\\n        dp[m-1][n-1][lastCellRemainder] = 1;\\n\\t\\t\\n        int lastRemainder = lastCellRemainder;\\n        // last row base case\\n        for (int c = n-2; c >= 0; c--) {\\n            int cellRemainder = grid[m-1][c] % k;\\n            dp[m-1][c][(lastRemainder + cellRemainder) % k] = 1;\\n            lastRemainder = (lastRemainder + cellRemainder) % k;\\n        }\\n        \\n        lastRemainder = lastCellRemainder;\\n        // last col base case\\n        for (int r = m-2; r >= 0; r--) {\\n            int cellRemainder = grid[r][n-1] % k;\\n            dp[r][n-1][(lastRemainder + cellRemainder) % k] = 1;\\n            lastRemainder = (lastRemainder + cellRemainder) % k;\\n        }\\n        \\n        // Recurrence relation\\n        for (int r = m-2; r >= 0; r--) {\\n            for (int c = n-2; c >= 0; c--) {\\n                int cellRemainder = grid[r][c] % k;\\n                \\n                for (int rem = 0; rem <= k; rem++) {\\n                    dp[r][c][(cellRemainder + rem) % k] = (dp[r][c][(cellRemainder + rem) % k] + dp[r][c+1][rem]) % MOD;\\n                    dp[r][c][(cellRemainder + rem) % k] = (dp[r][c][(cellRemainder + rem) % k] + dp[r+1][c][rem]) % MOD;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679111,
                "title": "python-tle-c-accepted",
                "content": "This O(mnk) Python code got TLE, but I wrote an exact-same version in C++ and that got accepted.\\n\\nI know there could be some obvious optimizations like combining the += and %= all onto one line and creating a DP array of size (m+1)\\\\*(n+1) instead and getting rid of the two 2D for loops.\\n\\nBut LeetCode not letting pass O(mnk) in some languages is just stupid and annoying.\\n\\n```python\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        mod=int(1e9)+7\\n        h=len(grid);w=len(grid[0])\\n        ways=[[[0]*k for x in range(w)] for y in range(h)]\\n        ways[h-1][w-1][grid[h-1][w-1]%k]=1\\n        for y in range(h-2,-1,-1):\\n            for i in range(k):\\n                ways[y][w-1][(i+grid[y][w-1])%k]+=ways[y+1][w-1][i]\\n                ways[y][w-1][(i+grid[y][w-1])%k]%=mod\\n        for x in range(w-2,-1,-1):\\n            for i in range(k):\\n                ways[h-1][x][(i+grid[h-1][x])%k]+=ways[h-1][x+1][i]\\n                ways[h-1][x][(i+grid[h-1][x])%k]%=mod\\n        for y in range(h-2,-1,-1):\\n            for x in range(w-2,-1,-1):\\n                for i in range(k):\\n                    ways[y][x][(i+grid[y][x])%k]+=ways[y][x+1][i]\\n                    ways[y][x][(i+grid[y][x])%k]%=mod\\n                    ways[y][x][(i+grid[y][x])%k]+=ways[y+1][x][i]\\n                    ways[y][x][(i+grid[y][x])%k]%=mod\\n        return ways[0][0][0]\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        mod=int(1e9)+7\\n        h=len(grid);w=len(grid[0])\\n        ways=[[[0]*k for x in range(w)] for y in range(h)]\\n        ways[h-1][w-1][grid[h-1][w-1]%k]=1\\n        for y in range(h-2,-1,-1):\\n            for i in range(k):\\n                ways[y][w-1][(i+grid[y][w-1])%k]+=ways[y+1][w-1][i]\\n                ways[y][w-1][(i+grid[y][w-1])%k]%=mod\\n        for x in range(w-2,-1,-1):\\n            for i in range(k):\\n                ways[h-1][x][(i+grid[h-1][x])%k]+=ways[h-1][x+1][i]\\n                ways[h-1][x][(i+grid[h-1][x])%k]%=mod\\n        for y in range(h-2,-1,-1):\\n            for x in range(w-2,-1,-1):\\n                for i in range(k):\\n                    ways[y][x][(i+grid[y][x])%k]+=ways[y][x+1][i]\\n                    ways[y][x][(i+grid[y][x])%k]%=mod\\n                    ways[y][x][(i+grid[y][x])%k]+=ways[y+1][x][i]\\n                    ways[y][x][(i+grid[y][x])%k]%=mod\\n        return ways[0][0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678982,
                "title": "c-dp-recursion-memoization-easy-to-understand-o-m-n-k",
                "content": "# Explaination\\nIf you are at an index `(i, j)`, A simple recursive function for the problem could involve following:\\n1. Add element at current cell, modulo with `k` and move to `(i+1, j)`\\n2. Add element at current cell, modulo with `k` and move to `(i, j+1)`\\n\\nBase cases:\\n1. If we go out of bounds, return `0`.\\n2. If we are at cell `(m-1, n-1)`, check after adding current cell, if modulo k == 0, if true return `1`.\\n\\nWe see that the recursive function may have `i, j, and current sum` as variables and we may memoize them since this recursion involves repeating subproblems.\\n# Code\\n```\\nint mod = 1000000007;\\n    \\nlong long recurse(vector<vector<int>>& grid, int i, int j, int curr, int k, vector<vector<vector<int>>>& dp){\\n\\tif((i>=grid.size()) || (j >= grid[0].size())) return 0;\\n\\tif((i == (grid.size()-1)) && (j == (grid[0].size()-1)) && ((curr + grid[i][j])%k == 0)) return dp[i][j][curr] = 1;\\n\\tif(dp[i][j][curr] != -1) return dp[i][j][curr];\\n\\treturn dp[i][j][curr] = (recurse(grid, i+1, j, (curr + grid[i][j])%k, k, dp) + recurse(grid, i, j+1, (curr + grid[i][j])%k, k, dp))%mod;\\n}\\n\\nint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\tvector<vector<vector<int>>> dp(grid.size(), vector<vector<int>>(grid[0].size(), vector<int>(k, -1)));\\n\\treturn recurse(grid, 0, 0, 0, k, dp);\\n    }\\n```\\n\\nTime: `O(m*n*k)`\\nSpace: `O(m*n*k)`",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint mod = 1000000007;\\n    \\nlong long recurse(vector<vector<int>>& grid, int i, int j, int curr, int k, vector<vector<vector<int>>>& dp){\\n\\tif((i>=grid.size()) || (j >= grid[0].size())) return 0;\\n\\tif((i == (grid.size()-1)) && (j == (grid[0].size()-1)) && ((curr + grid[i][j])%k == 0)) return dp[i][j][curr] = 1;\\n\\tif(dp[i][j][curr] != -1) return dp[i][j][curr];\\n\\treturn dp[i][j][curr] = (recurse(grid, i+1, j, (curr + grid[i][j])%k, k, dp) + recurse(grid, i, j+1, (curr + grid[i][j])%k, k, dp))%mod;\\n}\\n\\nint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\tvector<vector<vector<int>>> dp(grid.size(), vector<vector<int>>(grid[0].size(), vector<int>(k, -1)));\\n\\treturn recurse(grid, 0, 0, 0, k, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3010161,
                "title": "c-space-optimized-solution-beats-100-o-min-n-m-1-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI would like to share an optimized version of [this](https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/solutions/2678797/c-java-python-clean-top-down-bottom-up-dp-m-n-k/?orderBy=most_votes) solution.\\n\\nThanks [SGallivan](https://leetcode.com/sgallivan/) for the idea !\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have **N** rows.\\nWe have **M** numbers in each row.\\nEach number can generate up to **K** remainders.\\n\\nTo calculate the number of remainders that can be generated by the **current cell** (grid[i][j]), we create a temporary vector called **count** of length **K**.\\n```\\ncount[new_rem] = (dp[j][rem] + dp[j - 1][rem]) % mod;\\n```\\nThen we assign vector **count** to **dp[j]**:\\n```\\ndp[j] = count;\\n```\\nBecause **dp[j][rem]** is a number of paths whose sum of numbers gives the remainder **rem** when divided by **K** from **(0, 0)** to **(*last processed row*, j)**.\\n\\n\\nAs you can see, we first evaluate the vector called **count**, only then assign it to **dp[j]**, so here **dp[j]** contains the result of the previous row, while **dp[j - 1]** contains the result of the current row:\\n```\\ncount[new_rem] = (dp[j][rem] + dp[j - 1][rem]) % mod;\\n```\\n\\n# Complexity\\n- Time complexity: **O(N * M * K)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O((min(N, M) + 1) * K)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n, m, mod = 1e9 + 7;\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        if (n < m) {\\n            swap (n, m);\\n            rotate (grid);\\n        }\\n\\n        vector<int> count (k);\\n        vector<vector<int>> dp (m, vector<int> (k));\\n\\n        dp[0][0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                for (int rem = 0; rem < k; rem++) {\\n                    int new_rem = (rem + grid[i][j]) % k;\\n                    if (j == 0) {\\n                        count[new_rem] = dp[j][rem];\\n                    } else {\\n                        count[new_rem] = (dp[j][rem] + dp[j - 1][rem]) % mod;\\n                    }\\n                }\\n                dp[j] = count;\\n            }\\n        }\\n\\n        return dp[m - 1][0];\\n    }\\n\\n    void rotate (vector<vector<int>> & grid) {\\n        vector<vector<int>> temp(n, vector<int>(m));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                temp[i][j] = grid[j][i];\\n            }\\n        }\\n        grid = temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\ncount[new_rem] = (dp[j][rem] + dp[j - 1][rem]) % mod;\\n```\n```\\ndp[j] = count;\\n```\n```\\ncount[new_rem] = (dp[j][rem] + dp[j - 1][rem]) % mod;\\n```\n```\\nclass Solution {\\npublic:\\n    int n, m, mod = 1e9 + 7;\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        if (n < m) {\\n            swap (n, m);\\n            rotate (grid);\\n        }\\n\\n        vector<int> count (k);\\n        vector<vector<int>> dp (m, vector<int> (k));\\n\\n        dp[0][0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                for (int rem = 0; rem < k; rem++) {\\n                    int new_rem = (rem + grid[i][j]) % k;\\n                    if (j == 0) {\\n                        count[new_rem] = dp[j][rem];\\n                    } else {\\n                        count[new_rem] = (dp[j][rem] + dp[j - 1][rem]) % mod;\\n                    }\\n                }\\n                dp[j] = count;\\n            }\\n        }\\n\\n        return dp[m - 1][0];\\n    }\\n\\n    void rotate (vector<vector<int>> & grid) {\\n        vector<vector<int>> temp(n, vector<int>(m));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                temp[i][j] = grid[j][i];\\n            }\\n        }\\n        grid = temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960307,
                "title": "python-3-dp-fast-99-easy-to-understand",
                "content": "![image.png](https://assets.leetcode.com/users/images/c787cd09-40b2-439a-b6d0-af7f9584088a_1672181409.1276307.png)\\n\\n# Intuition\\n#### This problem is very similar to a couple of problems:\\n- [62. Unique Paths](https://leetcode.com/problems/unique-paths/)\\n- [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/description/)\\n- [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)\\n\\n\\n# Approach\\n---\\n- create **array with possible remainders** for each cell \\n- **sum arrays** from right cell and cell below as in standard DP\\n- **shift** array by current remainder\\n\\n\\n---\\n\\n\\n### a small example to illustrate how DP works:\\n```\\ngrid:     k = 3\\n5  2  4\\n3  0  5\\n```\\n1. start with the bottom-right cell\\n- calculate remainder `v = cell\\'s val % k`\\n- create array (length = k)\\n- set `1` to `v-th` element in array \\n```\\ncell 5:                          |   update grid:\\n                                 |   \\nv   = 5 --> 2     (5 % 3 = 2)    |   5  2  4\\narr = [0, 0, 0]                  |   3  0  [0, 0, 1]\\narr = [0, 0, 1]   arr[v] = 1     |\\n\\n```\\n2. update the last row and the last column (**shift** by current remainder)\\n- calculate remainder `v = cell\\'s val % k`\\n- get array from the previous cell\\n- shift array to the right by `v elements`\\n```\\ncell 4:                          |   update grid:\\n                                 |   \\nv   = 4 --> 1     (4 % 3 = 1)    |   5  2  [1, 0, 0]\\narr = [0, 0, 1]   cell below     |   3  0  [0, 0, 1]\\narr = [1, 0, 0]   shift by v     |   \\n                                 |   check:  (4 + 5) % 3 = 0\\n                                            \\n\\ncell 0:                          |   update grid:\\n                                 |  \\nv   = 0 --> 0     (0 % 3 = 0)    |   5  2          [1, 0, 0]\\narr = [0, 0, 1]   right cell     |   3  [0, 0, 1]  [0, 0, 1]\\narr = [0, 0, 1]   shift by v     |   \\n                                 |   check:  (0 + 5) % 3 = 2            \\n\\nand so on ...\\n```\\n3. update all other cells (**sum** arrays and **shift** by current remainder)\\n- calculate remainder `v = cell\\'s val % k`\\n- get arrays from:\\n    - the right cell\\n    - the cell below\\n- sum 2 arrays\\n- shift array to the right by `v elements`\\n```\\ncell 2:                          |   update grid:\\n                                 | \\nv   = 2 --> 1     (2 % 3 = 2)    |  5  [0, 1, 1]  [1, 0, 0]\\nrht = [1, 0, 0]   right cell     |  3  [0, 0, 1]  [0, 0, 1]\\nbtm = [0, 0, 1]   cell below     | \\narr = [1, 0, 1]   sum 2 arrays   |   check:  (2 + 4 + 5) % 3 = 2\\narr = [0, 1, 1]   shift by v     |           (2 + 0 + 5) % 3 = 1\\n\\nand so on ...\\n```\\n\\n\\n# Complexity\\n- Time complexity: O (m * n * k)\\n- Space complexity: O (m * n * k)\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        \\n        mod   = 10 ** 9 + 7\\n        row_n = len(grid)\\n        col_n = len(grid[0])\\n        \\n        # update the bottom-right cell\\n        v      = grid[~0][~0] % k   # calculate remainder\\n        arr    = [0] * k            # create new array for each possible remainders\\n        arr[v] = 1                  # update current remainder\\n        grid[~0][~0] = arr          # update current cell\\n\\n        # update the last column\\n        for r in range(row_n - 2, -1, -1):\\n            v   = grid[r][~0] % k      # calculate remainder\\n            arr = grid[r + 1][~0]      # get array in the cell below\\n            arr = arr[-v:] + arr[:-v]  # shift array to the right (for v places) \\n\\n            grid[r][~0] = arr          # update current cell\\n\\n        # update the last row\\n        for c in range(col_n - 2, -1, -1):\\n            v   = grid[~0][c] % k      # calculate remainder\\n            arr = grid[~0][c + 1]      # get array in the cell to the right \\n            arr = arr[-v:] + arr[:-v]  # shift array to the right (for v places) \\n\\n            grid[~0][c] = arr          # update current cell \\n\\n        # update all other cells\\n        for r in range(row_n - 2, -1, -1):\\n            for c in range(col_n - 2, -1, -1):\\n                arr_btm = grid[r + 1][c]  # get array in the cell below\\n                arr_rht = grid[r][c + 1]  # get array in the cell to the right \\n                \\n                v   = grid[r][c] % k      # calculate remainder  \\n                # sum 2 arrays (from right and top cells)\\n                arr = [(arr_btm[i] + arr_rht[i]) % mod   for i in range(k)]\\n                arr = arr[-v:] + arr[:-v] # shift array to the right (for v places) \\n                \\n                grid[r][c] = arr          # update current cell\\n\\n        # return value for the top-left cell(grid[0][0]) with mod == 0 (grid[0][0][0])\\n        return grid[0][0][0]\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\ngrid:     k = 3\\n5  2  4\\n3  0  5\\n```\n```\\ncell 5:                          |   update grid:\\n                                 |   \\nv   = 5 --> 2     (5 % 3 = 2)    |   5  2  4\\narr = [0, 0, 0]                  |   3  0  [0, 0, 1]\\narr = [0, 0, 1]   arr[v] = 1     |\\n\\n```\n```\\ncell 4:                          |   update grid:\\n                                 |   \\nv   = 4 --> 1     (4 % 3 = 1)    |   5  2  [1, 0, 0]\\narr = [0, 0, 1]   cell below     |   3  0  [0, 0, 1]\\narr = [1, 0, 0]   shift by v     |   \\n                                 |   check:  (4 + 5) % 3 = 0\\n                                            \\n\\ncell 0:                          |   update grid:\\n                                 |  \\nv   = 0 --> 0     (0 % 3 = 0)    |   5  2          [1, 0, 0]\\narr = [0, 0, 1]   right cell     |   3  [0, 0, 1]  [0, 0, 1]\\narr = [0, 0, 1]   shift by v     |   \\n                                 |   check:  (0 + 5) % 3 = 2            \\n\\nand so on ...\\n```\n```\\ncell 2:                          |   update grid:\\n                                 | \\nv   = 2 --> 1     (2 % 3 = 2)    |  5  [0, 1, 1]  [1, 0, 0]\\nrht = [1, 0, 0]   right cell     |  3  [0, 0, 1]  [0, 0, 1]\\nbtm = [0, 0, 1]   cell below     | \\narr = [1, 0, 1]   sum 2 arrays   |   check:  (2 + 4 + 5) % 3 = 2\\narr = [0, 1, 1]   shift by v     |           (2 + 0 + 5) % 3 = 1\\n\\nand so on ...\\n```\n```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        \\n        mod   = 10 ** 9 + 7\\n        row_n = len(grid)\\n        col_n = len(grid[0])\\n        \\n        # update the bottom-right cell\\n        v      = grid[~0][~0] % k   # calculate remainder\\n        arr    = [0] * k            # create new array for each possible remainders\\n        arr[v] = 1                  # update current remainder\\n        grid[~0][~0] = arr          # update current cell\\n\\n        # update the last column\\n        for r in range(row_n - 2, -1, -1):\\n            v   = grid[r][~0] % k      # calculate remainder\\n            arr = grid[r + 1][~0]      # get array in the cell below\\n            arr = arr[-v:] + arr[:-v]  # shift array to the right (for v places) \\n\\n            grid[r][~0] = arr          # update current cell\\n\\n        # update the last row\\n        for c in range(col_n - 2, -1, -1):\\n            v   = grid[~0][c] % k      # calculate remainder\\n            arr = grid[~0][c + 1]      # get array in the cell to the right \\n            arr = arr[-v:] + arr[:-v]  # shift array to the right (for v places) \\n\\n            grid[~0][c] = arr          # update current cell \\n\\n        # update all other cells\\n        for r in range(row_n - 2, -1, -1):\\n            for c in range(col_n - 2, -1, -1):\\n                arr_btm = grid[r + 1][c]  # get array in the cell below\\n                arr_rht = grid[r][c + 1]  # get array in the cell to the right \\n                \\n                v   = grid[r][c] % k      # calculate remainder  \\n                # sum 2 arrays (from right and top cells)\\n                arr = [(arr_btm[i] + arr_rht[i]) % mod   for i in range(k)]\\n                arr = arr[-v:] + arr[:-v] # shift array to the right (for v places) \\n                \\n                grid[r][c] = arr          # update current cell\\n\\n        # return value for the top-left cell(grid[0][0]) with mod == 0 (grid[0][0][0])\\n        return grid[0][0][0]\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691688,
                "title": "dp-memoization-modulo-k-c-simple-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int f(int i, int j, vector<vector<int>>& arr, int k, int sum, vector<vector<vector<int>>>& dp){\\n        if(i==0&&j==0){\\n            if(sum%k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int up=0;\\n        int left=0;\\n        if(dp[i][j][sum]!=-1){\\n            return dp[i][j][sum];\\n        }\\n        if(i>0){\\n            up=f(i-1, j, arr, k, (sum+arr[i-1][j])%k, dp);\\n        }\\n        if(j>0){\\n            left=f(i, j-1, arr, k, (sum+arr[i][j-1])%k, dp);\\n        }\\n        return dp[i][j][sum]=(up+left)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& arr, int k) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int>(k, -1)));\\n        int ans= f(n-1, m-1, arr, k, arr[n-1][m-1]%k, dp);\\n        return ans;\\n    }\\n};\\n```\\n**Pls Upvote if you like the approach**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int f(int i, int j, vector<vector<int>>& arr, int k, int sum, vector<vector<vector<int>>>& dp){\\n        if(i==0&&j==0){\\n            if(sum%k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int up=0;\\n        int left=0;\\n        if(dp[i][j][sum]!=-1){\\n            return dp[i][j][sum];\\n        }\\n        if(i>0){\\n            up=f(i-1, j, arr, k, (sum+arr[i-1][j])%k, dp);\\n        }\\n        if(j>0){\\n            left=f(i, j-1, arr, k, (sum+arr[i][j-1])%k, dp);\\n        }\\n        return dp[i][j][sum]=(up+left)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& arr, int k) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int>(k, -1)));\\n        int ans= f(n-1, m-1, arr, k, arr[n-1][m-1]%k, dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683352,
                "title": "c-row-swapping-dp-memory-o-2-n-k-time-o-m-n-k",
                "content": "In this problem we can solve with `O(M * N * K)` space. However, if the the value of `K` is more than this actual value in problem, we may face memory limit. Hence, it will need an efficient approach for memory handling.\\n\\nYou may notice that, we only need row earlier to the current row. We don\\'t need other rows. For example, if I am at row, we only need `row-1, col` and `row, col-1` to calculate the current result.\\nSo, in my solution, I used to keep result in `odd (1)` and ` even (0)` row. If I am odd, I will calculate result from even row, and vise versa.\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int min(int a, int b){\\n        return a<b?a:b;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        \\n        vector rw(min(grid.size(),2), vector(grid[0].size(), vector(k,0)));\\n        rw[0][0][grid[0][0]%k] = 1;\\n        \\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(i==0){\\n                    for(int rm=0; rm<k; rm++){\\n                        if(j>0)\\n                            rw[i&1][j][(rm+grid[i][j])%k] = rw[i&1][j-1][rm];\\n                    }\\n                }else{\\n                    for(int rm=0; rm<k; rm++){\\n                        if(j>0)\\n                            rw[i&1][j][(rm+grid[i][j])%k] = (rw[(i-1)&1][j][rm] + rw[i&1][j-1][rm])%mod;\\n                        else\\n                            rw[i&1][0][(rm + grid[i][j])%k] = rw[(i-1)&1][j][rm];\\n                    }\\n                }\\n            }\\n        }\\n        return rw[(grid.size()-1)&1][grid[0].size()-1][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int min(int a, int b){\\n        return a<b?a:b;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        \\n        vector rw(min(grid.size(),2), vector(grid[0].size(), vector(k,0)));\\n        rw[0][0][grid[0][0]%k] = 1;\\n        \\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(i==0){\\n                    for(int rm=0; rm<k; rm++){\\n                        if(j>0)\\n                            rw[i&1][j][(rm+grid[i][j])%k] = rw[i&1][j-1][rm];\\n                    }\\n                }else{\\n                    for(int rm=0; rm<k; rm++){\\n                        if(j>0)\\n                            rw[i&1][j][(rm+grid[i][j])%k] = (rw[(i-1)&1][j][rm] + rw[i&1][j-1][rm])%mod;\\n                        else\\n                            rw[i&1][0][(rm + grid[i][j])%k] = rw[(i-1)&1][j][rm];\\n                    }\\n                }\\n            }\\n        }\\n        return rw[(grid.size()-1)&1][grid[0].size()-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683114,
                "title": "java-easy-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n      int[][][] dp = new int[grid.length][grid[0].length][k];\\n      \\n      for (int a = 0; a < grid.length; a++) {\\n        for (int b = 0; b < grid[0].length; b++) {\\n          for (int c = 0; c < k; c++) {\\n            dp[a][b][c] = -1;\\n          }\\n        }\\n      }\\n      \\n      return helper(grid, k, 0, 0, 0, dp); \\n    }\\n    \\n    public int helper(int[][] grid, int k, int sum, int a, int b, int[][][] dp) {\\n      \\n      if (a >= grid.length || b >= grid[0].length)\\n        return 0;\\n      \\n      sum = (sum + grid[a][b])%k;\\n      \\n      if (a == grid.length - 1 && b == grid[0].length - 1 && sum == 0) {\\n        return 1;\\n      }\\n      \\n      if (dp[a][b][sum] != -1)\\n        return dp[a][b][sum];\\n      \\n      return dp[a][b][sum] = (helper(grid, k, sum, a + 1, b, dp) + helper(grid, k, sum, a, b + 1, dp))%mod;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n      int[][][] dp = new int[grid.length][grid[0].length][k];\\n      \\n      for (int a = 0; a < grid.length; a++) {\\n        for (int b = 0; b < grid[0].length; b++) {\\n          for (int c = 0; c < k; c++) {\\n            dp[a][b][c] = -1;\\n          }\\n        }\\n      }\\n      \\n      return helper(grid, k, 0, 0, 0, dp); \\n    }\\n    \\n    public int helper(int[][] grid, int k, int sum, int a, int b, int[][][] dp) {\\n      \\n      if (a >= grid.length || b >= grid[0].length)\\n        return 0;\\n      \\n      sum = (sum + grid[a][b])%k;\\n      \\n      if (a == grid.length - 1 && b == grid[0].length - 1 && sum == 0) {\\n        return 1;\\n      }\\n      \\n      if (dp[a][b][sum] != -1)\\n        return dp[a][b][sum];\\n      \\n      return dp[a][b][sum] = (helper(grid, k, sum, a + 1, b, dp) + helper(grid, k, sum, a, b + 1, dp))%mod;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682293,
                "title": "python-is-getting-tle-but-c-is-getting-ac-with-same-solution",
                "content": "# Python CODE is getting TLE but C++ is getting AC with same solution.\\n\\nDuring the contest, I have a penalty with python and waste time for C++ rewriting my code with C++. I am so disappointed\\n\\n# Python\\n```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        n, m = len(grid), len(grid[0])\\n        dp = [[[0] * (k + 1) for _ in range(m + 1)] for _ in range(n + 1)]\\n        dp[0][0][grid[0][0] % k] = 1\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        for x in range(0, n):\\n            for y in range(0, m):\\n                for q in range(k):\\n                    if x + 1 < n:\\n                        dp[x + 1][y][(q + grid[x + 1][y]) % k] += dp[x][y][q]\\n                        dp[x + 1][y][(q + grid[x + 1][y]) % k] %= mod\\n                    if y + 1 < m:\\n                        dp[x][y + 1][(q + grid[x][y + 1]) % k] += dp[x][y][q]\\n                        dp[x][y + 1][(q + grid[x][y + 1]) % k] %= mod\\n        \\n        return dp[n - 1][m - 1][0]\\n```\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int K) { \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int k;\\n        \\n          vector<vector<vector<long long> > > dp; //declare the 3D vector\\n          for(int k=0; k<n; k++)\\n          {\\n            dp.push_back(vector<vector<long long> >()); //initialize the first index with a 2D vector\\n            for(int i=0; i<m; i++)\\n            {\\n              dp[k].push_back(vector<long long>()); //initialize the 2 index with a row of strings\\n              for(int j=0; j<K; j++)\\n              {\\n                 dp[k][i].push_back(0); //fulfill the last index regularly\\n              } \\n            }\\n          }\\n\\n        k = K;\\n        \\n        dp[0][0][grid[0][0] % k] = 1;\\n        long long mod = 1000000007;\\n        \\n        for (int x = 0; x < n; x ++) {\\n            for (int y = 0; y < m; y++) {\\n                for (int q = 0; q < k; q ++){ \\n                    if (x + 1 < n) {\\n                        dp[x + 1][y][(q + grid[x + 1][y]) % k] += dp[x][y][q];\\n                        dp[x + 1][y][(q + grid[x + 1][y]) % k] %= mod;                        \\n                    }\\n                    if (y + 1 < m) {\\n                        dp[x][y + 1][(q + grid[x][y + 1]) % k] += dp[x][y][q];\\n                        dp[x][y + 1][(q + grid[x][y + 1]) % k] %= mod;                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n - 1][m - 1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        n, m = len(grid), len(grid[0])\\n        dp = [[[0] * (k + 1) for _ in range(m + 1)] for _ in range(n + 1)]\\n        dp[0][0][grid[0][0] % k] = 1\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        for x in range(0, n):\\n            for y in range(0, m):\\n                for q in range(k):\\n                    if x + 1 < n:\\n                        dp[x + 1][y][(q + grid[x + 1][y]) % k] += dp[x][y][q]\\n                        dp[x + 1][y][(q + grid[x + 1][y]) % k] %= mod\\n                    if y + 1 < m:\\n                        dp[x][y + 1][(q + grid[x][y + 1]) % k] += dp[x][y][q]\\n                        dp[x][y + 1][(q + grid[x][y + 1]) % k] %= mod\\n        \\n        return dp[n - 1][m - 1][0]\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int K) { \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int k;\\n        \\n          vector<vector<vector<long long> > > dp; //declare the 3D vector\\n          for(int k=0; k<n; k++)\\n          {\\n            dp.push_back(vector<vector<long long> >()); //initialize the first index with a 2D vector\\n            for(int i=0; i<m; i++)\\n            {\\n              dp[k].push_back(vector<long long>()); //initialize the 2 index with a row of strings\\n              for(int j=0; j<K; j++)\\n              {\\n                 dp[k][i].push_back(0); //fulfill the last index regularly\\n              } \\n            }\\n          }\\n\\n        k = K;\\n        \\n        dp[0][0][grid[0][0] % k] = 1;\\n        long long mod = 1000000007;\\n        \\n        for (int x = 0; x < n; x ++) {\\n            for (int y = 0; y < m; y++) {\\n                for (int q = 0; q < k; q ++){ \\n                    if (x + 1 < n) {\\n                        dp[x + 1][y][(q + grid[x + 1][y]) % k] += dp[x][y][q];\\n                        dp[x + 1][y][(q + grid[x + 1][y]) % k] %= mod;                        \\n                    }\\n                    if (y + 1 < m) {\\n                        dp[x][y + 1][(q + grid[x][y + 1]) % k] += dp[x][y][q];\\n                        dp[x][y + 1][(q + grid[x][y + 1]) % k] %= mod;                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n - 1][m - 1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681188,
                "title": "approach-explanation-dp-top-down",
                "content": "There are many similar questions. The way to solve is move in all the allowed directions till the condition met and then return whatever is asked in the question.\\n\\nIn this question we need to return the number of ways, so when we are at last element (matrix[n-1][m-1]) we will return 1 (denoting this is one way possible) if the given condition of sum of the elements divisible by k is true, else we will return 0. \\n\\nWhile writing the recursive solution there will three things changing in the function, row, col, and sum. \\nrow -> current row index\\ncol -> current column index\\nsum -> sum of the elements we have taken into consideration\\n\\nSo if we are trying to memoize then we will require a 3D DP array.\\nOne more point sum can be longer than 1e5 thus we cannot directly create a vector of sum length. So we will take sum%k always beacuse this will not affect the solution and range of k is 50.\\n\\nLet\\'s see the solution now,\\n\\n```\\n\\tint mod = 1e9+7;\\n    int grids(vector<vector<int>>& grid, int k, vector<vector<vector<int> > > &dp, int row, int col, int s){\\n        if(row==grid.size()-1 && col==grid[0].size()-1){\\n\\t\\t\\t// We are at last element, if the condition is matching we are returning 1.\\n            if((s+grid[row][col])%k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(col >= grid[0].size()){\\n            return 0;\\n        }\\n        if(row >= grid.size()){\\n            return 0;\\n        }\\n        if(dp[row][col][(s+grid[row][col])%k]!=-1){\\n            return dp[row][col][(s+grid[row][col])%k];\\n        }\\n\\t\\t// Allowed directions are left and down only.\\n        int moveleft = grids(grid, k, dp, row, col+1, (s+grid[row][col])%k);\\n        int movedown = grids(grid, k, dp, row+1, col, (s+grid[row][col])%k);\\n        return dp[row][col][(s+grid[row][col])%k] = (moveleft+movedown)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector<int> > > dp(n+1, vector<vector<int> >(m+1, vector<int> (k+1, -1)));\\n        return grids(grid, k, dp, 0, 0, 0);\\n    }\\n```\\n\\n**Upvote if understood the solution.**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tint mod = 1e9+7;\\n    int grids(vector<vector<int>>& grid, int k, vector<vector<vector<int> > > &dp, int row, int col, int s){\\n        if(row==grid.size()-1 && col==grid[0].size()-1){\\n\\t\\t\\t// We are at last element, if the condition is matching we are returning 1.\\n            if((s+grid[row][col])%k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(col >= grid[0].size()){\\n            return 0;\\n        }\\n        if(row >= grid.size()){\\n            return 0;\\n        }\\n        if(dp[row][col][(s+grid[row][col])%k]!=-1){\\n            return dp[row][col][(s+grid[row][col])%k];\\n        }\\n\\t\\t// Allowed directions are left and down only.\\n        int moveleft = grids(grid, k, dp, row, col+1, (s+grid[row][col])%k);\\n        int movedown = grids(grid, k, dp, row+1, col, (s+grid[row][col])%k);\\n        return dp[row][col][(s+grid[row][col])%k] = (moveleft+movedown)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector<int> > > dp(n+1, vector<vector<int> >(m+1, vector<int> (k+1, -1)));\\n        return grids(grid, k, dp, 0, 0, 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680054,
                "title": "bottom-up-tabular-dp-n-m-k-dp-2-m-k-with-space-optimizations-c",
                "content": "SInce we can go only down or right, we can arrive at any `grid[i][j]` from either `grid[i - 1][j]` or `grid[i][j - 1]`.\\nSo number of ways to reach `grid[i][j]` will be the **sum** of ways to reach `grid[i - 1][j]` and `grid[i][j - 1]`. First try out [Unique Paths](https://leetcode.com/problems/unique-paths/) for understanding this.\\n\\n- So the states are `(i , j) , (i - 1 , j) , (i , j - 1)`\\n\\nLets change the question a little.\\nSuppose we need to find the number of ways to reach `grid[i][j]` with `sum % k = s` for all `0 <= s < k`. \\nSuppose we are currently at `(i , j)` and we had come here from `(i - 1 , j)`.\\nHow is the current sum affected ? \\n`curr_sum = ((whatever sum we had when we were at (i - 1 , j) lets say last_sum) + grid[i][j]) % k`\\nNow we can say that number of ways of reaching `(i , j)` from `(i - 1 , j)` with `sum == curr_sum` = number of ways of reaching `(i - 1 , j)` with `sum == last_sum`.\\nSimilarly for arriving from `(i , j -1)`.\\nThe sum of both is the total number of at `(i , j)`.\\nNow we just have to do it for every possible value of `last_sum` (there are k such)\\n- therefore transitions are : `dp[i][j][(grid[i][j] + _k)] = (dp[i  - 1][j][_k] + dp[i][j - 1][_k]) % MOD ` where `_k = last_sum`\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int mod = 1e9 + 7 ;\\n        int n = grid.size() , m = grid[0].size() ;\\n        int dp[n][m][k] ;\\n        memset(dp , 0 , sizeof(int) * n * m * k) ;\\n        dp[0][0][grid[0][0] % k]++ ;\\n        for (int i = 1 ; i < m ; i++) {\\n            for (int j = 0 ; j < k ; j++) {\\n                dp[0][i][(j + grid[0][i]) % k] = dp[0][i - 1][j] % mod ;\\n            }\\n        }\\n        for (int i = 1 ; i < n ; i++) {\\n            for (int j = 0 ; j < k ; j++) {\\n                dp[i][0][(j + grid[i][0]) % k] = dp[i - 1][0][j] % mod ;\\n            }\\n        }\\n        for (int i = 1 ; i < n ; i++) {\\n            for (int j = 1 ; j < m ; j++) {\\n                for (int _k = 0 ; _k < k ; _k++) {\\n                    dp[i][j][(grid[i][j] + _k) % k] = (dp[i - 1][j][_k] + dp[i][j - 1][_k]) % mod ;\\n                }\\n            }\\n        }\\n        return dp[n - 1][m - 1][0] ;\\n    }\\n};\\n```\\n***TC : O(N * M * K)***\\n***SC: O(N * M * K)***\\n**Note:** Just like in [Unique Paths](https://leetcode.com/problems/unique-paths/) there also exists a memory optimization for this solution, since all the states `(i - 1 , j) , (i , j) and (i , j - 1)` are restricted to 2 sub-matrices at any time.\\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int mod = 1e9 + 7 ;\\n        int n = grid.size() , m = grid[0].size() ;\\n        vector<vector<vector<int>>> dp(2 , vector<vector<int>> (m , vector<int> (k , 0))) ;\\n        dp[0][0][grid[0][0] % k]++ ;\\n        for (int j = 1 ; j < m ; j++) {\\n            for (int _k = 0 ; _k < k ; _k++) {\\n                dp[0][j][(grid[0][j] + _k) % k] = dp[0][j - 1][_k] ;\\n            }\\n        }\\n        for (int i = 1 ; i < n ; i++) {\\n            for (int j = 0 ; j < m ; j++) {\\n                for (int _k = 0 ; _k < k ; _k++) {\\n                    if (j > 0) {\\n                        dp[1][j][(grid[i][j] + _k) % k] = (dp[0][j][_k] + dp[1][j - 1][_k]) % mod ;\\n                    } else {\\n                        dp[1][j][(grid[i][j] + _k) % k] = dp[0][j][_k] ;\\n                    }\\n                }\\n            }\\n            swap(dp[0] , dp[1]) ;\\n        }\\n        return dp[0][m - 1][0] ;\\n    }\\n};\\n```\\n***SC : O(2 * M * K)***",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int mod = 1e9 + 7 ;\\n        int n = grid.size() , m = grid[0].size() ;\\n        int dp[n][m][k] ;\\n        memset(dp , 0 , sizeof(int) * n * m * k) ;\\n        dp[0][0][grid[0][0] % k]++ ;\\n        for (int i = 1 ; i < m ; i++) {\\n            for (int j = 0 ; j < k ; j++) {\\n                dp[0][i][(j + grid[0][i]) % k] = dp[0][i - 1][j] % mod ;\\n            }\\n        }\\n        for (int i = 1 ; i < n ; i++) {\\n            for (int j = 0 ; j < k ; j++) {\\n                dp[i][0][(j + grid[i][0]) % k] = dp[i - 1][0][j] % mod ;\\n            }\\n        }\\n        for (int i = 1 ; i < n ; i++) {\\n            for (int j = 1 ; j < m ; j++) {\\n                for (int _k = 0 ; _k < k ; _k++) {\\n                    dp[i][j][(grid[i][j] + _k) % k] = (dp[i - 1][j][_k] + dp[i][j - 1][_k]) % mod ;\\n                }\\n            }\\n        }\\n        return dp[n - 1][m - 1][0] ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int mod = 1e9 + 7 ;\\n        int n = grid.size() , m = grid[0].size() ;\\n        vector<vector<vector<int>>> dp(2 , vector<vector<int>> (m , vector<int> (k , 0))) ;\\n        dp[0][0][grid[0][0] % k]++ ;\\n        for (int j = 1 ; j < m ; j++) {\\n            for (int _k = 0 ; _k < k ; _k++) {\\n                dp[0][j][(grid[0][j] + _k) % k] = dp[0][j - 1][_k] ;\\n            }\\n        }\\n        for (int i = 1 ; i < n ; i++) {\\n            for (int j = 0 ; j < m ; j++) {\\n                for (int _k = 0 ; _k < k ; _k++) {\\n                    if (j > 0) {\\n                        dp[1][j][(grid[i][j] + _k) % k] = (dp[0][j][_k] + dp[1][j - 1][_k]) % mod ;\\n                    } else {\\n                        dp[1][j][(grid[i][j] + _k) % k] = dp[0][j][_k] ;\\n                    }\\n                }\\n            }\\n            swap(dp[0] , dp[1]) ;\\n        }\\n        return dp[0][m - 1][0] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679742,
                "title": "dp-solution-memoization-easy-to-understand-java-contest-solution",
                "content": "class Solution {\\n   static int mod=1000000007;\\n    public static int recur(int i,int j,int sum ,int k,int grid[][],Integer dp[][][]){\\n        \\n        if(i<0 || j<0){\\n            return 0;\\n        }\\n        if(i==0 && j==0){\\n            \\n            if((sum+grid[0][0])% k ==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][sum]!=null){\\n            return dp[i][j][sum]%mod;\\n        }\\n        \\n        return dp[i][j][sum]= ( recur(i-1,j,(sum+grid[i][j])%k,k,grid,dp) + recur(i,j-1,(sum+grid[i][j])%k , k , grid,dp) )%mod;\\n    } \\n    public int numberOfPaths(int[][] grid, int k) {\\n        \\n        Integer dp[][][]=new Integer[grid.length+1][grid[0].length+1][k+1];\\n        return recur(grid.length-1,grid[0].length-1,0,k,grid,dp)%mod;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "class Solution {\\n   static int mod=1000000007;\\n    public static int recur(int i,int j,int sum ,int k,int grid[][],Integer dp[][][]){\\n        \\n        if(i<0 || j<0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2679667,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * M * K)***\\n\\n* ***Space Complexity :- O(N * M * K)***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    long long mod = 1e9 + 7;\\n\\n    int helper(vector<vector<int>>& grid, int i, int j, int n, int m, int sum, int k, vector<vector<vector<int>>>& dp)\\n    {\\n        sum += grid[i][j];\\n        \\n        // base case\\n        \\n        if(i == n - 1 && j == m - 1)\\n        {\\n            if(sum % k == 0)\\n            {\\n                return 1;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        // if already calculated\\n\\n        if(dp[i][j][sum % k] != -1)\\n        {\\n            return dp[i][j][sum % k];\\n        }\\n\\n        int ways = 0;\\n        \\n        // call to down cell\\n\\n        if(i + 1 < n)\\n        {\\n            ways = (ways % mod + helper(grid, i + 1, j, n, m, sum, k, dp) % mod) % mod;\\n        }\\n        \\n        // call to right cell\\n\\n        if(j + 1 < m)\\n        {\\n            ways = (ways% mod + helper(grid, i, j + 1, n, m, sum, k, dp) % mod) % mod;\\n        }\\n        \\n        // store the res and return it\\n\\n        return dp[i][j][sum % k] = ways;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\n        int n = grid.size();\\n\\n        int m = grid[0].size();\\n        \\n        // declare a 3D dp and initialize with -1\\n\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>> (m + 1, vector<int> (k + 1, -1)));\\n\\n        return helper(grid, 0, 0, n, m, 0, k, dp);\\n    }\\n};\\n```\\n\\n* ***Using 2D Dp***\\n\\n* ***Time Complexity :- O(N * M * K)***\\n\\n* ***Space Complexity :- O(N * M * K)***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    long long mod = 1e9 + 7;\\n\\n    int helper(vector<vector<int>>& grid, int i, int j, int n, int m, int sum, int k, vector<vector<int>>& dp)\\n    {\\n        sum += grid[i][j];\\n        \\n        // base case\\n        \\n        if(i == n - 1 && j == m - 1)\\n        {\\n            if(sum % k == 0)\\n            {\\n                return 1;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        // if already calculated\\n        \\n        int cell_no = i * m + j;\\n\\n        if(dp[cell_no][sum % k] != -1)\\n        {\\n            return dp[cell_no][sum % k];\\n        }\\n\\n        int ways = 0;\\n        \\n        // call to down cell\\n\\n        if(i + 1 < n)\\n        {\\n            ways = (ways % mod + helper(grid, i + 1, j, n, m, sum, k, dp) % mod) % mod;\\n        }\\n        \\n        // call to right cell\\n\\n        if(j + 1 < m)\\n        {\\n            ways = (ways% mod + helper(grid, i, j + 1, n, m, sum, k, dp) % mod) % mod;\\n        }\\n        \\n        // store the res and return it\\n\\n        return dp[cell_no][sum % k] = ways;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\n        int n = grid.size();\\n\\n        int m = grid[0].size();\\n        \\n        // declare a dp and initialize with -1\\n\\n        vector<vector<int>> dp(n * m + 1, vector<int> (k + 1, -1));\\n\\n        return helper(grid, 0, 0, n, m, 0, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long mod = 1e9 + 7;\\n\\n    int helper(vector<vector<int>>& grid, int i, int j, int n, int m, int sum, int k, vector<vector<vector<int>>>& dp)\\n    {\\n        sum += grid[i][j];\\n        \\n        // base case\\n        \\n        if(i == n - 1 && j == m - 1)\\n        {\\n            if(sum % k == 0)\\n            {\\n                return 1;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        // if already calculated\\n\\n        if(dp[i][j][sum % k] != -1)\\n        {\\n            return dp[i][j][sum % k];\\n        }\\n\\n        int ways = 0;\\n        \\n        // call to down cell\\n\\n        if(i + 1 < n)\\n        {\\n            ways = (ways % mod + helper(grid, i + 1, j, n, m, sum, k, dp) % mod) % mod;\\n        }\\n        \\n        // call to right cell\\n\\n        if(j + 1 < m)\\n        {\\n            ways = (ways% mod + helper(grid, i, j + 1, n, m, sum, k, dp) % mod) % mod;\\n        }\\n        \\n        // store the res and return it\\n\\n        return dp[i][j][sum % k] = ways;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\n        int n = grid.size();\\n\\n        int m = grid[0].size();\\n        \\n        // declare a 3D dp and initialize with -1\\n\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>> (m + 1, vector<int> (k + 1, -1)));\\n\\n        return helper(grid, 0, 0, n, m, 0, k, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    long long mod = 1e9 + 7;\\n\\n    int helper(vector<vector<int>>& grid, int i, int j, int n, int m, int sum, int k, vector<vector<int>>& dp)\\n    {\\n        sum += grid[i][j];\\n        \\n        // base case\\n        \\n        if(i == n - 1 && j == m - 1)\\n        {\\n            if(sum % k == 0)\\n            {\\n                return 1;\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        // if already calculated\\n        \\n        int cell_no = i * m + j;\\n\\n        if(dp[cell_no][sum % k] != -1)\\n        {\\n            return dp[cell_no][sum % k];\\n        }\\n\\n        int ways = 0;\\n        \\n        // call to down cell\\n\\n        if(i + 1 < n)\\n        {\\n            ways = (ways % mod + helper(grid, i + 1, j, n, m, sum, k, dp) % mod) % mod;\\n        }\\n        \\n        // call to right cell\\n\\n        if(j + 1 < m)\\n        {\\n            ways = (ways% mod + helper(grid, i, j + 1, n, m, sum, k, dp) % mod) % mod;\\n        }\\n        \\n        // store the res and return it\\n\\n        return dp[cell_no][sum % k] = ways;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\n        int n = grid.size();\\n\\n        int m = grid[0].size();\\n        \\n        // declare a dp and initialize with -1\\n\\n        vector<vector<int>> dp(n * m + 1, vector<int> (k + 1, -1));\\n\\n        return helper(grid, 0, 0, n, m, 0, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679635,
                "title": "simple-3d-dp-solution",
                "content": "# Intuition\\nwe have to not calculate the total sum of all the path. We have to just need the remainder.\\n\\n# Complexity\\n- Time complexity:O(n*m*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(k,0)));\\n        dp[0][0][grid[0][0]%k]++;\\n        int sum=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i][(grid[0][i]+sum)%k]++;\\n            sum+=grid[0][i];\\n            \\n        }\\n        sum=grid[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[i][0][(grid[i][0]+sum)%k]++;\\n            sum+=grid[i][0];\\n        }\\n         int mod=1000000007;\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                int r= grid[i][j]%k;\\n                for(int l=0;l<k;l++){\\n                    dp[i][j][(r+l)%k]= (dp[i-1][j][l]%mod + dp[i][j-1][l]%mod)%mod;\\n                }\\n            }\\n        }\\n        // for(auto &q: dp){\\n        //     for(auto &j: q){\\n        //         for(auto &l: j)cout<<l<<\" \";\\n        //         cout<<\"\\\\t\";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        return dp[n-1][m-1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(k,0)));\\n        dp[0][0][grid[0][0]%k]++;\\n        int sum=grid[0][0];\\n        for(int i=1;i<m;i++){\\n            dp[0][i][(grid[0][i]+sum)%k]++;\\n            sum+=grid[0][i];\\n            \\n        }\\n        sum=grid[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[i][0][(grid[i][0]+sum)%k]++;\\n            sum+=grid[i][0];\\n        }\\n         int mod=1000000007;\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                int r= grid[i][j]%k;\\n                for(int l=0;l<k;l++){\\n                    dp[i][j][(r+l)%k]= (dp[i-1][j][l]%mod + dp[i][j-1][l]%mod)%mod;\\n                }\\n            }\\n        }\\n        // for(auto &q: dp){\\n        //     for(auto &j: q){\\n        //         for(auto &l: j)cout<<l<<\" \";\\n        //         cout<<\"\\\\t\";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        return dp[n-1][m-1][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2679079,
                "title": "recurson-memoization-3d-dp-c",
                "content": "```\\nint f(int x , int y , vector<vector<int>>& grid , int k , int sum , vector<vector<vector<int>>> &dp)\\n    {\\n        if(x == 0 && y == 0)\\n        {\\n            if((sum + grid[x][y]) %k == 0)  return 1 ;\\n            else  return 0 ;\\n        }\\n        if(dp[x][y][sum%k] != -1)  return dp[x][y][sum] ;\\n        sum += grid[x][y] ;\\n        \\n        int t = 0 ;\\n        if(x-1 >= 0 && y >= 0)  t = f( x-1 , y , grid , k , sum%k , dp ) ;\\n        int l = 0 ;\\n        if(y-1 >= 0 && x >= 0)  l = f( x , y-1 , grid , k , sum%k , dp ) ;\\n        \\n        sum -= grid[x][y] ;\\n        \\n        return dp[x][y][sum%k] = (t+l)% (1000000007) ;\\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid , int k) {\\n        \\n        int n=grid.size() , m=grid[0].size() ;\\n        vector<vector<vector<int>>> dp(n+1 , vector<vector<int>>(m+1 , vector<int>(51 , -1))) ;\\n        return f(n-1 , m-1 , grid , k , 0 , dp) ;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nint f(int x , int y , vector<vector<int>>& grid , int k , int sum , vector<vector<vector<int>>> &dp)\\n    {\\n        if(x == 0 && y == 0)\\n        {\\n            if((sum + grid[x][y]) %k == 0)  return 1 ;\\n            else  return 0 ;\\n        }\\n        if(dp[x][y][sum%k] != -1)  return dp[x][y][sum] ;\\n        sum += grid[x][y] ;\\n        \\n        int t = 0 ;\\n        if(x-1 >= 0 && y >= 0)  t = f( x-1 , y , grid , k , sum%k , dp ) ;\\n        int l = 0 ;\\n        if(y-1 >= 0 && x >= 0)  l = f( x , y-1 , grid , k , sum%k , dp ) ;\\n        \\n        sum -= grid[x][y] ;\\n        \\n        return dp[x][y][sum%k] = (t+l)% (1000000007) ;\\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid , int k) {\\n        \\n        int n=grid.size() , m=grid[0].size() ;\\n        vector<vector<vector<int>>> dp(n+1 , vector<vector<int>>(m+1 , vector<int>(51 , -1))) ;\\n        return f(n-1 , m-1 , grid , k , 0 , dp) ;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678834,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\nconst ll mod = 1e9 + 7;\\npublic:\\n    ll m, n, k;\\n    vi(vi(vi(ll)))dp;\\n    ll func(const vi(vi(int))&v, ll i, ll j, ll rem){\\n        if(i<0 || j<0 || i>=m || j>=n){\\n            return 0;\\n        }\\n        rem=(rem+(v[i][j]%k))%k;\\n        if(i==m-1 && j==n-1){\\n            return (rem==0);\\n        }\\n        ll&ans=dp[i][j][rem];\\n        if(ans==-1){\\n            ans=(func(v, i+1, j, rem)+func(v, i, j+1, rem))%mod;\\n        }\\n        return ans;\\n    }\\n    int numberOfPaths(vector<vector<int>>&v, int K) {\\n        k=K, m=v.size(), n=v[0].size();\\n        dp.assign(m, vi(vi(ll))(n, vi(ll)(k, -1)));\\n        return func(v, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\nconst ll mod = 1e9 + 7;\\npublic:\\n    ll m, n, k;\\n    vi(vi(vi(ll)))dp;\\n    ll func(const vi(vi(int))&v, ll i, ll j, ll rem){\\n        if(i<0 || j<0 || i>=m || j>=n){\\n            return 0;\\n        }\\n        rem=(rem+(v[i][j]%k))%k;\\n        if(i==m-1 && j==n-1){\\n            return (rem==0);\\n        }\\n        ll&ans=dp[i][j][rem];\\n        if(ans==-1){\\n            ans=(func(v, i+1, j, rem)+func(v, i, j+1, rem))%mod;\\n        }\\n        return ans;\\n    }\\n    int numberOfPaths(vector<vector<int>>&v, int K) {\\n        k=K, m=v.size(), n=v[0].size();\\n        dp.assign(m, vi(vi(ll))(n, vi(ll)(k, -1)));\\n        return func(v, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678822,
                "title": "c-clean-dp-o-m-n-k-solution-with-explanation",
                "content": "As the range of k is less than equal to 50, we can write a dp solution with O(m*n*k) time-complexity.\\nHere, dp[a][b][c] refers to the number of paths starting from (0,0) and ending at (a,b) such that the sum of elements of path modulo k is c i.e. sum%k=c.\\nSince we can only move down and right , dp[a][b][c] will only depend on dp[a-1][b] and dp[a][b-1].\\n```\\nclass Solution {\\npublic:\\n        int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(); int n=grid[0].size();\\n        int mod=1000000007;\\n        int dp[m][n][k];\\n        memset(dp,0,sizeof(dp));\\n        int val=0;\\n        for(int j=0;j<n;j++){\\n            val+=grid[0][j]; val=val%k; dp[0][j][val]=1;\\n        }\\n        val=0;\\n         for(int j=0;j<m;j++){\\n            val+=grid[j][0]; val=val%k; dp[j][0][val]=1;\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                for(int id=0;id<k;id++){\\n                    dp[i][j][id]=0;     \\n                }\\n                for(int id=0;id<k;id++){\\n                        int x=id+grid[i][j]; x=x%k;\\n                        dp[i][j][x]+=dp[i-1][j][id];\\n                        dp[i][j][x]%=mod;\\n                }\\n                for(int id=0;id<k;id++){\\n                        int x=id+grid[i][j]; x=x%k;\\n                        dp[i][j][x]+=dp[i][j-1][id];\\n                        dp[i][j][x]%=mod;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1][0];\\n    }\\n};\\n```\\nTime complexity = O(m*n*k)\\nSpace complexity = O(m*n*k)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n        int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(); int n=grid[0].size();\\n        int mod=1000000007;\\n        int dp[m][n][k];\\n        memset(dp,0,sizeof(dp));\\n        int val=0;\\n        for(int j=0;j<n;j++){\\n            val+=grid[0][j]; val=val%k; dp[0][j][val]=1;\\n        }\\n        val=0;\\n         for(int j=0;j<m;j++){\\n            val+=grid[j][0]; val=val%k; dp[j][0][val]=1;\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                for(int id=0;id<k;id++){\\n                    dp[i][j][id]=0;     \\n                }\\n                for(int id=0;id<k;id++){\\n                        int x=id+grid[i][j]; x=x%k;\\n                        dp[i][j][x]+=dp[i-1][j][id];\\n                        dp[i][j][x]%=mod;\\n                }\\n                for(int id=0;id<k;id++){\\n                        int x=id+grid[i][j]; x=x%k;\\n                        dp[i][j][x]+=dp[i][j-1][id];\\n                        dp[i][j][x]%=mod;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678786,
                "title": "javascript-dp-w-sum-k",
                "content": "**Solution: DP - Recursion w/ Memoization**\\n\\nWe don\\'t need to keep track of the entire sum, only the remainder after dividing by `k` (`sum % k`).\\nMemoize each `dp(i, j, sumMod)`, where\\n*  `i = current row`\\n*  `j = current column `\\n*  `sumMod = the current sum % k`\\n\\nWhen we reach the `grid[m - 1][n - 1]`, if the remainder of the sum is `0`, we have found a valid path.\\nCount the number of valid paths starting from `grid[0][0]`.\\n\\nTime Complexity: `O(m * n * k)`\\nSpace Complexity: `O(m * n * k)`\\n```\\nvar numberOfPaths = function(grid, k) {\\n  let m = grid.length, n = grid[0].length, MOD = 10 ** 9 + 7;\\n  let memo = Array(m).fill(0).map(() => Array(n).fill(0).map(() => Array(k).fill(-1)));\\n  return dfs(0, 0, grid[0][0] % k);\\n\\n  function dfs(i, j, sumMod) {\\n    if (i === m - 1 && j === n - 1) return sumMod === 0 ? 1 : 0;\\n    if (memo[i][j][sumMod] !== -1) return memo[i][j][sumMod];\\n\\n    let paths = [[i + 1, j], [i, j + 1]], ways = 0;\\n    for (let [x, y] of paths) {\\n      if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n      ways = (ways + dfs(x, y, (sumMod + grid[x][y]) % k)) % MOD;\\n    }\\n    return memo[i][j][sumMod] = ways;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberOfPaths = function(grid, k) {\\n  let m = grid.length, n = grid[0].length, MOD = 10 ** 9 + 7;\\n  let memo = Array(m).fill(0).map(() => Array(n).fill(0).map(() => Array(k).fill(-1)));\\n  return dfs(0, 0, grid[0][0] % k);\\n\\n  function dfs(i, j, sumMod) {\\n    if (i === m - 1 && j === n - 1) return sumMod === 0 ? 1 : 0;\\n    if (memo[i][j][sumMod] !== -1) return memo[i][j][sumMod];\\n\\n    let paths = [[i + 1, j], [i, j + 1]], ways = 0;\\n    for (let [x, y] of paths) {\\n      if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n      ways = (ways + dfs(x, y, (sumMod + grid[x][y]) % k)) % MOD;\\n    }\\n    return memo[i][j][sumMod] = ways;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669530,
                "title": "c-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(vector<vector<int>>&vec , int i , int j , int rem ,int k, int m , int n , vector<vector<vector<int>>>&dp){\\n        int N=1e9+7;\\n         if(i==m-1 and j==n-1){\\n             if((rem+vec[i][j])%k==0) return 1;\\n             return 0;\\n         }\\n         if(i<0 or j<0 or i>=m or j>=n){\\n             return 0;\\n         }\\n         if(dp[i][j][rem]!=-1) return dp[i][j][rem];\\n         int ans=0;\\n         ans=(ans+func(vec , i+1 , j , (rem+vec[i][j])%k , k ,  m , n , dp))%N;\\n         ans=(ans+func(vec , i , j+1 , (rem+vec[i][j])%k , k ,  m , n , dp))%N;\\n\\n         return dp[i][j][rem]=ans;\\n    }\\n\\n\\n    int numberOfPaths(vector<vector<int>>& vec, int k) {\\n        int m=vec.size() , n=vec[0].size();\\n        vector<vector<vector<int>>>dp(m ,vector<vector<int>>(n , vector<int>(k+1, -1)));\\n        return func(vec , 0 , 0 , 0 , k ,m, n , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<vector<int>>&vec , int i , int j , int rem ,int k, int m , int n , vector<vector<vector<int>>>&dp){\\n        int N=1e9+7;\\n         if(i==m-1 and j==n-1){\\n             if((rem+vec[i][j])%k==0) return 1;\\n             return 0;\\n         }\\n         if(i<0 or j<0 or i>=m or j>=n){\\n             return 0;\\n         }\\n         if(dp[i][j][rem]!=-1) return dp[i][j][rem];\\n         int ans=0;\\n         ans=(ans+func(vec , i+1 , j , (rem+vec[i][j])%k , k ,  m , n , dp))%N;\\n         ans=(ans+func(vec , i , j+1 , (rem+vec[i][j])%k , k ,  m , n , dp))%N;\\n\\n         return dp[i][j][rem]=ans;\\n    }\\n\\n\\n    int numberOfPaths(vector<vector<int>>& vec, int k) {\\n        int m=vec.size() , n=vec[0].size();\\n        vector<vector<vector<int>>>dp(m ,vector<vector<int>>(n , vector<int>(k+1, -1)));\\n        return func(vec , 0 , 0 , 0 , k ,m, n , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349118,
                "title": "simple-3d-dp-memoised-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis inutition is that \\nwhen any path ends at bottom right cell we will see if the sum till there is divisble by k if yes then we will return 1\\neach subproblem will return the total number of paths from that cell i j with a precding sum till here as sum and preceding modulo of sum%k that eventually ends at the bottom right cell with total sum divisble by k\\nhere we can end up on the same cell i and j by 2 diff preceding sum \\nthat why we are using  3d dp\\nfinally we will be returning the ans from the biggest subproblem \\nwhich is dp[0][0][0];\\nwhich tell total number of paths with sum divisble by k eventually ending at the bottom right cell with prediing sum as 0 cause path sum before first cell is zero\\nthe recurrence is that curr cell will take the count of path from its down and right neigbour\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int mod=1e9+7;\\n  int dfs(vector<vector<int>>&grid,int i,int j,int sum,int k,vector<vector<vector<int>>>&dp){\\n\\n    if(i<0||j<0||i>=grid.size() || j>=grid[0].size()){\\n      return 0;\\n    }\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1){\\n      sum+=grid[i][j];\\n      if(sum%k==0)return 1;\\n      return 0;\\n    }\\n    if(dp[i][j][sum%k]!=-1){\\n      return dp[i][j][sum%k];\\n    }\\n    int down=dfs(grid,i+1,j,sum+grid[i][j],k,dp);\\n    int right=dfs(grid,i,j+1,sum+grid[i][j],k,dp);\\n    return dp[i][j][sum%k]=(down%mod+right%mod)%mod;\\n  }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\n      vector<vector<vector<int>>>dp(grid.size(),vector<vector<int>>(grid[0].size(),vector<int>(k,-1)));\\n      return dfs(grid,0,0,0,k,dp);\\n      //first we will try the re\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int mod=1e9+7;\\n  int dfs(vector<vector<int>>&grid,int i,int j,int sum,int k,vector<vector<vector<int>>>&dp){\\n\\n    if(i<0||j<0||i>=grid.size() || j>=grid[0].size()){\\n      return 0;\\n    }\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1){\\n      sum+=grid[i][j];\\n      if(sum%k==0)return 1;\\n      return 0;\\n    }\\n    if(dp[i][j][sum%k]!=-1){\\n      return dp[i][j][sum%k];\\n    }\\n    int down=dfs(grid,i+1,j,sum+grid[i][j],k,dp);\\n    int right=dfs(grid,i,j+1,sum+grid[i][j],k,dp);\\n    return dp[i][j][sum%k]=(down%mod+right%mod)%mod;\\n  }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\n      vector<vector<vector<int>>>dp(grid.size(),vector<vector<int>>(grid[0].size(),vector<int>(k,-1)));\\n      return dfs(grid,0,0,0,k,dp);\\n      //first we will try the re\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348819,
                "title": "python-2-easy-solutions-recursion-memoization",
                "content": "# Solution 1 - Recursion\\n\\n### Complexity\\n- Time complexity:\\nO(2^(m + n))\\n\\n- Space complexity:\\nO(m + n)\\n\\n# Code\\n```\\nmod = int(1e9 + 7)\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        def solve(i,j, pathSum):\\n            if i == 0 and j == 0 :\\n                if (grid[i][j] + pathSum) % k == 0:\\n                    return 1\\n                else:\\n                    return 0\\n            \\n            if i < 0 or j < 0 :\\n                return 0\\n            \\n            up =  solve(i-1, j, (pathSum + grid[i][j]) % k)\\n            left = solve(i, j-1, (pathSum + grid[i][j]) % k)\\n            ans = (up + left) % mod\\n            return ans\\n        \\n        m = len(grid) \\n        n = len(grid[0]) \\n        return solve(m-1, n-1, 0)\\n```\\n# Complexity\\n- Time complexity:\\nO(m * n * k)\\n\\n- Space complexity:\\nO(m * n * k)\\n### Solution 2 - Memoization\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        def solveMemo(i,j, pathSum, memo):\\n            if i == 0 and j == 0 :\\n                if (grid[i][j] + pathSum) % k == 0:\\n                    return 1\\n                else:\\n                    return 0\\n            \\n            if i < 0 or j < 0 :\\n                return 0\\n            \\n            if (i,j, pathSum) in memo:\\n                return memo[(i, j, pathSum)]\\n\\n            up =  solveMemo(i-1, j, (pathSum + grid[i][j]) % k, memo)\\n            left = solveMemo(i, j-1, (pathSum + grid[i][j]) % k, memo)\\n            \\n            memo[(i, j, pathSum)] = (up + left) % mod\\n            return memo[(i, j, pathSum)]\\n        \\n        m = len(grid) \\n        n = len(grid[0]) \\n        memo = {}\\n        return solveMemo(m-1, n-1, 0, memo)\\n    \\n```\\nIf you have some doubts \\uD83E\\uDD14 feel free to bug me anytime or If you understood than don\\'t forget to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nmod = int(1e9 + 7)\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        def solve(i,j, pathSum):\\n            if i == 0 and j == 0 :\\n                if (grid[i][j] + pathSum) % k == 0:\\n                    return 1\\n                else:\\n                    return 0\\n            \\n            if i < 0 or j < 0 :\\n                return 0\\n            \\n            up =  solve(i-1, j, (pathSum + grid[i][j]) % k)\\n            left = solve(i, j-1, (pathSum + grid[i][j]) % k)\\n            ans = (up + left) % mod\\n            return ans\\n        \\n        m = len(grid) \\n        n = len(grid[0]) \\n        return solve(m-1, n-1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943459,
                "title": "java-time-complexity-o-m-n-k-space-complexity-o-2n",
                "content": "# Intuition\\n<!--  -->\\nDont need the entire sum, Remainders are enough.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(MxNxK) [95% faster]\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2N) [Beats 100%]\\n# Code\\n```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] curr = null;\\n        int[][] prev = new int[n][k]; \\n\\n        int sum = 0;\\n        for(int j=0;j<n;j++) {\\n            sum = (sum + grid[0][j]) % k;\\n            prev[j][sum]++;\\n        }\\n\\n        for(int i=1;i<m;i++) {\\n            curr = new int[n][k]; \\n            for(int j=0;j<n;j++) {\\n                if(j!=0) {\\n                    for(int h=0;h<k;h++) {\\n                        if(curr[j-1][h] > 0) {\\n                            sum = (h + grid[i][j]) % k;\\n                            curr[j][sum] = curr[j-1][h];\\n                        }\\n                    }\\n                }\\n                for(int h=0;h<k;h++) {\\n                    if(prev[j][h] > 0) {\\n                        sum = (h + grid[i][j]) % k;\\n                        curr[j][sum] = (curr[j][sum]+prev[j][h]) % MOD;   \\n                    }\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[n-1][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] curr = null;\\n        int[][] prev = new int[n][k]; \\n\\n        int sum = 0;\\n        for(int j=0;j<n;j++) {\\n            sum = (sum + grid[0][j]) % k;\\n            prev[j][sum]++;\\n        }\\n\\n        for(int i=1;i<m;i++) {\\n            curr = new int[n][k]; \\n            for(int j=0;j<n;j++) {\\n                if(j!=0) {\\n                    for(int h=0;h<k;h++) {\\n                        if(curr[j-1][h] > 0) {\\n                            sum = (h + grid[i][j]) % k;\\n                            curr[j][sum] = curr[j-1][h];\\n                        }\\n                    }\\n                }\\n                for(int h=0;h<k;h++) {\\n                    if(prev[j][h] > 0) {\\n                        sum = (h + grid[i][j]) % k;\\n                        curr[j][sum] = (curr[j][sum]+prev[j][h]) % MOD;   \\n                    }\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[n-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738072,
                "title": "two-approach-dfs-using-visited-matrix-dp-memoization",
                "content": "This soltution gives TLE \\n```\\nclass Solution {\\n    private int mod = 1000000007;\\n\\tprivate int bfs(int[][] grid, int k, int row, int col, int sum, boolean[][] visited) {\\n\\t\\tif (row >= grid.length || col >= grid[0].length || visited[row][col]) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (row == grid.length - 1  && col == grid[0].length - 1) {\\n\\t\\t\\tif ((sum + grid[row][col]) % k == 0) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tvisited[row][col] = true;\\n\\t\\tint x = bfs(grid, k, row + 1, col, sum + grid[row][col], visited) % mod;\\n\\t\\tint y = bfs(grid, k, row, col + 1, sum + grid[row][col], visited) % mod;\\n\\t\\tvisited[row][col] = false;\\n\\t\\treturn (x + y) % mod;\\n\\t}\\n\\n\\tpublic int numberOfPaths(int[][] grid, int k) {\\n\\t\\tboolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\t\\treturn bfs(grid, k, 0, 0, 0, visited) % mod;\\n\\t}\\n}\\n```\\n\\nThis is optimized solution using dp\\n```\\nclass Solution {\\n    private int mod = 1000000007;\\n\\n\\tprivate int bfs(int[][] grid, int k, int row, int col, int sum, int[][][] dp) {\\n\\t\\tif (row >= grid.length || col >= grid[0].length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (row == grid.length - 1 && col == grid[0].length - 1) {\\n\\t\\t\\tif ((sum + grid[row][col]) % k == 0) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (dp[row][col][sum % k] != -1) {\\n\\t\\t\\treturn dp[row][col][sum % k];\\n\\t\\t}\\n\\t\\tint x = bfs(grid, k, row + 1, col, sum + grid[row][col], dp) % mod;\\n\\t\\tint y = bfs(grid, k, row, col + 1, sum + grid[row][col], dp) % mod;\\n\\n\\t\\treturn dp[row][col][sum % k] = (x + y) % mod;\\n\\t}\\n\\n\\tpublic int numberOfPaths(int[][] grid, int k) {\\n\\t\\tint[][][] dp = new int[grid.length][grid[0].length][k];\\n\\t\\tfor (int[][] row : dp) {\\n\\t\\t\\tfor (int[] col : row) {\\n\\t\\t\\t\\tArrays.fill(col, -1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn bfs(grid, k, 0, 0, 0, dp) % mod;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private int mod = 1000000007;\\n\\tprivate int bfs(int[][] grid, int k, int row, int col, int sum, boolean[][] visited) {\\n\\t\\tif (row >= grid.length || col >= grid[0].length || visited[row][col]) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (row == grid.length - 1  && col == grid[0].length - 1) {\\n\\t\\t\\tif ((sum + grid[row][col]) % k == 0) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tvisited[row][col] = true;\\n\\t\\tint x = bfs(grid, k, row + 1, col, sum + grid[row][col], visited) % mod;\\n\\t\\tint y = bfs(grid, k, row, col + 1, sum + grid[row][col], visited) % mod;\\n\\t\\tvisited[row][col] = false;\\n\\t\\treturn (x + y) % mod;\\n\\t}\\n\\n\\tpublic int numberOfPaths(int[][] grid, int k) {\\n\\t\\tboolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\t\\treturn bfs(grid, k, 0, 0, 0, visited) % mod;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n    private int mod = 1000000007;\\n\\n\\tprivate int bfs(int[][] grid, int k, int row, int col, int sum, int[][][] dp) {\\n\\t\\tif (row >= grid.length || col >= grid[0].length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (row == grid.length - 1 && col == grid[0].length - 1) {\\n\\t\\t\\tif ((sum + grid[row][col]) % k == 0) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (dp[row][col][sum % k] != -1) {\\n\\t\\t\\treturn dp[row][col][sum % k];\\n\\t\\t}\\n\\t\\tint x = bfs(grid, k, row + 1, col, sum + grid[row][col], dp) % mod;\\n\\t\\tint y = bfs(grid, k, row, col + 1, sum + grid[row][col], dp) % mod;\\n\\n\\t\\treturn dp[row][col][sum % k] = (x + y) % mod;\\n\\t}\\n\\n\\tpublic int numberOfPaths(int[][] grid, int k) {\\n\\t\\tint[][][] dp = new int[grid.length][grid[0].length][k];\\n\\t\\tfor (int[][] row : dp) {\\n\\t\\t\\tfor (int[] col : row) {\\n\\t\\t\\t\\tArrays.fill(col, -1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn bfs(grid, k, 0, 0, 0, dp) % mod;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703177,
                "title": "c-3d-dp",
                "content": "```\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // 3d dp\\n        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k)));\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(i == 0 && j == 0) {\\n                    dp[i][j][grid[i][j]%k] += 1;\\n                } else {\\n                    for(int l = 0; l < k; l++) {\\n                        int val = i > 0 ? dp[i-1][j][l] : 0;\\n                        int val1 = j > 0 ? dp[i][j-1][l] : 0;\\n                        int rem = (l+grid[i][j])%k;\\n                        dp[i][j][rem] += (val + val1)%mod;\\n                        dp[i][j][rem] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1][0];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // 3d dp\\n        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k)));\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(i == 0 && j == 0) {\\n                    dp[i][j][grid[i][j]%k] += 1;\\n                } else {\\n                    for(int l = 0; l < k; l++) {\\n                        int val = i > 0 ? dp[i-1][j][l] : 0;\\n                        int val1 = j > 0 ? dp[i][j-1][l] : 0;\\n                        int rem = (l+grid[i][j])%k;\\n                        dp[i][j][rem] += (val + val1)%mod;\\n                        dp[i][j][rem] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1][0];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702890,
                "title": "python-3d-dynamic-programming-approach-o-m-n-k",
                "content": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        dp = [[[0 for i in range(k)] for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        rem = grid[0][0] % k\\n        dp[0][0][rem] = 1\\n        for i in range(1, len(grid[0])):\\n            dp[0][i][(rem + grid[0][i]) % k] = 1\\n            rem = (rem + grid[0][i]) % k\\n        rem = grid[0][0] % k\\n        for j in range(1, len(grid)):\\n            dp[j][0][(rem + grid[j][0]) % k] = 1\\n            rem = (rem + grid[j][0]) % k\\n        for i in range(1, len(grid)):\\n            for j in range(1, len(grid[0])):\\n                for rem in range(k):\\n                    dp[i][j][(rem + grid[i][j]) % k] = dp[i - 1][j][rem] + dp[i][j - 1][rem]\\n        return dp[-1][-1][0] % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        dp = [[[0 for i in range(k)] for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        rem = grid[0][0] % k\\n        dp[0][0][rem] = 1\\n        for i in range(1, len(grid[0])):\\n            dp[0][i][(rem + grid[0][i]) % k] = 1\\n            rem = (rem + grid[0][i]) % k\\n        rem = grid[0][0] % k\\n        for j in range(1, len(grid)):\\n            dp[j][0][(rem + grid[j][0]) % k] = 1\\n            rem = (rem + grid[j][0]) % k\\n        for i in range(1, len(grid)):\\n            for j in range(1, len(grid[0])):\\n                for rem in range(k):\\n                    dp[i][j][(rem + grid[i][j]) % k] = dp[i - 1][j][rem] + dp[i][j - 1][rem]\\n        return dp[-1][-1][0] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696524,
                "title": "rust-67-ms-fastest-100-no-overcounting-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/821145620/) employs dynamic programming using a no-overcounting approach. It demonstrated **67 ms runtime (100.00%)** and used **12.6 MB memory (93.75%)**. Time complexity is linear: **O(m\\\\*n\\\\*k)**. Space complexity is linear: **O(m\\\\*n\\\\*k)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution\\n{\\n    pub fn number_of_paths(grid: Vec<Vec<i32>>, k: i32) -> i32 \\n    {\\n        let m = grid.len(); \\n        let n = grid[0].len(); \\n        \\n        // [1] to count correct paths, we observe that there is a unique\\n        //     remainder (mod k) that can ENTER the last (bottom-right) cell;\\n        //     the same applies to every other cell; thus, our DP strategy is\\n        //     to send requests from every cell to its top & left neighbours;\\n        //     this request contains the unique remainder value and a number\\n        //     of accumulated paths with the identical request;\\n        //     these requests are accumulated in the following array that is\\n        //     initialized with \\'-1\\' for all cells and all remainders except\\n        //     for the bottom-right corner, from which there is a single (fake)\\n        //     outgoing path with the expected remainder (mod k) being equal 0\\n        let mut paths = vec![vec![vec![-1i32; k as usize]; n]; m];\\n        paths[m-1][n-1][0] = 1;\\n                \\n        let mut p       : i32;\\n        let mut new_rem : usize;\\n        let mut pp      : &mut i32;\\n        \\n        // [2] here, we scan every cell and propagate state for only those\\n        //     remainders that are requested by each cell; \\n        //     WE DO NOT COMPUTE STATES THAT ARE NOT REQUESTED\\n        for i in (0..m).rev()\\n        {\\n            for j in (0..n).rev()\\n            {\\n                for rem in 0..k as usize\\n                {\\n                    p = paths[i][j][rem];\\n                    \\n                    if p >= 0  // propagating only correct paths\\n                    {\\n                        new_rem = (rem as i32 - grid[i][j]).rem_euclid(k) as usize;\\n                        if i > 0\\n                        {\\n                            pp = &mut paths[i-1][j][new_rem];\\n                            if *pp < 0 { *pp = p; }\\n                            else       { *pp = (*pp + p) % 1_000_000_007; }\\n                        }\\n                        if j > 0\\n                        {\\n                            pp = &mut paths[i][j-1][new_rem];\\n                            if *pp < 0 { *pp = p; }\\n                            else       { *pp = (*pp + p) % 1_000_000_007; }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // [3] in the end, for the starting (top-left) cell, we\\n        //     have a final request that consists of accumulated\\n        //     number of paths for each outgoing remainder...\\n        //     so we extract the number of accumulated paths for \\n        //     the actual remainder that is present in the matrix,\\n        //     i.e., for grid[0][0]%k\\n        paths[0][0][(grid[0][0]%k) as usize].max(0)\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nimpl Solution\\n{\\n    pub fn number_of_paths(grid: Vec<Vec<i32>>, k: i32) -> i32 \\n    {\\n        let m = grid.len(); \\n        let n = grid[0].len(); \\n        \\n        // [1] to count correct paths, we observe that there is a unique\\n        //     remainder (mod k) that can ENTER the last (bottom-right) cell;\\n        //     the same applies to every other cell; thus, our DP strategy is\\n        //     to send requests from every cell to its top & left neighbours;\\n        //     this request contains the unique remainder value and a number\\n        //     of accumulated paths with the identical request;\\n        //     these requests are accumulated in the following array that is\\n        //     initialized with \\'-1\\' for all cells and all remainders except\\n        //     for the bottom-right corner, from which there is a single (fake)\\n        //     outgoing path with the expected remainder (mod k) being equal 0\\n        let mut paths = vec![vec![vec![-1i32; k as usize]; n]; m];\\n        paths[m-1][n-1][0] = 1;\\n                \\n        let mut p       : i32;\\n        let mut new_rem : usize;\\n        let mut pp      : &mut i32;\\n        \\n        // [2] here, we scan every cell and propagate state for only those\\n        //     remainders that are requested by each cell; \\n        //     WE DO NOT COMPUTE STATES THAT ARE NOT REQUESTED\\n        for i in (0..m).rev()\\n        {\\n            for j in (0..n).rev()\\n            {\\n                for rem in 0..k as usize\\n                {\\n                    p = paths[i][j][rem];\\n                    \\n                    if p >= 0  // propagating only correct paths\\n                    {\\n                        new_rem = (rem as i32 - grid[i][j]).rem_euclid(k) as usize;\\n                        if i > 0\\n                        {\\n                            pp = &mut paths[i-1][j][new_rem];\\n                            if *pp < 0 { *pp = p; }\\n                            else       { *pp = (*pp + p) % 1_000_000_007; }\\n                        }\\n                        if j > 0\\n                        {\\n                            pp = &mut paths[i][j-1][new_rem];\\n                            if *pp < 0 { *pp = p; }\\n                            else       { *pp = (*pp + p) % 1_000_000_007; }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // [3] in the end, for the starting (top-left) cell, we\\n        //     have a final request that consists of accumulated\\n        //     number of paths for each outgoing remainder...\\n        //     so we extract the number of accumulated paths for \\n        //     the actual remainder that is present in the matrix,\\n        //     i.e., for grid[0][0]%k\\n        paths[0][0][(grid[0][0]%k) as usize].max(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2695481,
                "title": "c-short-and-simple-dp-with-memo",
                "content": "```\\n    #define M 1000000007\\n    int dp[100001][51];\\n    int solve(int index, int sum, vector<vector<int>> &grid, int n, int m, int k) {\\n        \\n        int r = index / m, c = index % m;\\n        if(r >= n || c >= m) return 0;\\n        if(r == n - 1 && c == m - 1) return (sum + grid[r][c]) % k == 0;\\n        if(dp[index][sum] != -1) return dp[index][sum];\\n        \\n        int ans = 0;\\n        if(c + 1 < m)\\n            ans = (ans + solve(index + 1, (sum + grid[r][c]) % k, grid, n, m, k)) % M;\\n        if(r + 1 < n)\\n            ans = (ans + solve(index + m, (sum + grid[r][c]) % k, grid, n, m, k)) % M;\\n\\t\\t\\t\\n        return dp[index][sum] = ans;\\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        memset(dp, -1, sizeof dp);\\n        return solve(0, 0, grid, grid.size(), grid[0].size(), k);\\n    }\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    #define M 1000000007\\n    int dp[100001][51];\\n    int solve(int index, int sum, vector<vector<int>> &grid, int n, int m, int k) {\\n        \\n        int r = index / m, c = index % m;\\n        if(r >= n || c >= m) return 0;\\n        if(r == n - 1 && c == m - 1) return (sum + grid[r][c]) % k == 0;\\n        if(dp[index][sum] != -1) return dp[index][sum];\\n        \\n        int ans = 0;\\n        if(c + 1 < m)\\n            ans = (ans + solve(index + 1, (sum + grid[r][c]) % k, grid, n, m, k)) % M;\\n        if(r + 1 < n)\\n            ans = (ans + solve(index + m, (sum + grid[r][c]) % k, grid, n, m, k)) % M;\\n\\t\\t\\t\\n        return dp[index][sum] = ans;\\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        memset(dp, -1, sizeof dp);\\n        return solve(0, 0, grid, grid.size(), grid[0].size(), k);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2694195,
                "title": "recursive-to-dp-c-clean-code",
                "content": "```\\nclass Solution                                    TLE\\n{\\n    public:\\n        int solve(vector<vector < int>> &grid, int k, int i, int j, int sum)\\n        {\\n           \\t/// base condition\\n            if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n            {\\n                return 0;\\n            }\\n            if (i == grid.size() - 1 and j == grid[0].size() - 1)\\n            {\\n                sum += grid[i][j];\\n                if (sum % k == 0)\\n                {\\n                    return 1;\\n                }\\n                else\\n                {\\n                    return 0;\\n                }\\n            }\\n            int down = solve(grid, k, i + 1, j, sum + grid[i][j]);\\n            int right = solve(grid, k, i, j + 1, sum + grid[i][j]);\\n            return down + right;\\n        }\\n    int numberOfPaths(vector<vector < int>> &grid, int k)\\n    {\\n        return solve(grid, k, 0, 0, 0);\\n    }\\n};\\n\\nclass Solution\\n{\\n    public:\\n        int solve(vector<vector < int>> &grid, int k, int i, int j, int sum, vector< vector< vector< int>>> &dp)\\n        {\\n           \\t/// base condition\\n            if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n            {\\n                return 0;\\n            }\\n\\n            if (i == grid.size() - 1 and j == grid[0].size() - 1)\\n            {\\n                sum += grid[i][j];\\n                if (sum % k == 0)\\n                {\\n                    return 1;\\n                }\\n                else\\n                {\\n                    return 0;\\n                }\\n            }\\n            if (dp[i][j][sum%k] != -1)\\n            {\\n                return dp[i][j][sum%k];\\n            }\\n            long  down = (solve(grid, k, i + 1, j, sum + grid[i][j], dp));\\n            long  right = (solve(grid, k, i, j + 1, sum + grid[i][j], dp));\\n            return dp[i][j][sum%k] = (down%1000000007 + right%1000000007) % 1000000007;\\n        }\\n    int numberOfPaths(vector<vector < int>> &grid, int k)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector< int>>> dp(n, vector<vector < int>> (m, vector<int> (k+1, -1)));\\n        return solve(grid, k, 0, 0, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution                                    TLE\\n{\\n    public:\\n        int solve(vector<vector < int>> &grid, int k, int i, int j, int sum)\\n        {\\n           \\t/// base condition\\n            if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n            {\\n                return 0;\\n            }\\n            if (i == grid.size() - 1 and j == grid[0].size() - 1)\\n            {\\n                sum += grid[i][j];\\n                if (sum % k == 0)\\n                {\\n                    return 1;\\n                }\\n                else\\n                {\\n                    return 0;\\n                }\\n            }\\n            int down = solve(grid, k, i + 1, j, sum + grid[i][j]);\\n            int right = solve(grid, k, i, j + 1, sum + grid[i][j]);\\n            return down + right;\\n        }\\n    int numberOfPaths(vector<vector < int>> &grid, int k)\\n    {\\n        return solve(grid, k, 0, 0, 0);\\n    }\\n};\\n\\nclass Solution\\n{\\n    public:\\n        int solve(vector<vector < int>> &grid, int k, int i, int j, int sum, vector< vector< vector< int>>> &dp)\\n        {\\n           \\t/// base condition\\n            if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n            {\\n                return 0;\\n            }\\n\\n            if (i == grid.size() - 1 and j == grid[0].size() - 1)\\n            {\\n                sum += grid[i][j];\\n                if (sum % k == 0)\\n                {\\n                    return 1;\\n                }\\n                else\\n                {\\n                    return 0;\\n                }\\n            }\\n            if (dp[i][j][sum%k] != -1)\\n            {\\n                return dp[i][j][sum%k];\\n            }\\n            long  down = (solve(grid, k, i + 1, j, sum + grid[i][j], dp));\\n            long  right = (solve(grid, k, i, j + 1, sum + grid[i][j], dp));\\n            return dp[i][j][sum%k] = (down%1000000007 + right%1000000007) % 1000000007;\\n        }\\n    int numberOfPaths(vector<vector < int>> &grid, int k)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector< int>>> dp(n, vector<vector < int>> (m, vector<int> (k+1, -1)));\\n        return solve(grid, k, 0, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690961,
                "title": "c-dp-memorization-commented-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> r={1,0};\\n    vector<int> c={0,1};\\n    int mod=1000000007;\\n    int n;\\n    int m;\\n    int k;\\n    int solve(vector<vector<vector<int>>> &dp,vector<vector<int>> &A,int x,int y,int rem){\\n        rem=rem%k;\\n        if(x==n-1 && y==m-1){\\n\\t\\t// if rem is equal to zero the return 1 else 0\\n            if((rem+A[x][y])%k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[x][y][rem]!=-1){\\n            return dp[x][y][rem];\\n        }\\n        int cnt=0;\\n\\t\\t// cnt the number of valid path to last element of element in 2d vector having reminder equal to rem \\n        for(int i=0;i<2;i++){\\n            int x1=x+r[i];\\n            int y1=y+c[i];\\n            if(x1>=0 && x1<n && y1>=0 && y1<m){\\n                cnt=(cnt+solve(dp,A,x1,y1,rem+A[x][y]))%mod;\\n            }\\n        }\\n        return dp[x][y][rem]=cnt;\\n    }\\n    int numberOfPaths(vector<vector<int>>& A, int k) {\\n        n=A.size();\\n        m=A[0].size();\\n        this->k=k;\\n\\t\\t// initialize the vector\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(k,-1)));\\n        return solve(dp,A,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> r={1,0};\\n    vector<int> c={0,1};\\n    int mod=1000000007;\\n    int n;\\n    int m;\\n    int k;\\n    int solve(vector<vector<vector<int>>> &dp,vector<vector<int>> &A,int x,int y,int rem){\\n        rem=rem%k;\\n        if(x==n-1 && y==m-1){\\n\\t\\t// if rem is equal to zero the return 1 else 0\\n            if((rem+A[x][y])%k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[x][y][rem]!=-1){\\n            return dp[x][y][rem];\\n        }\\n        int cnt=0;\\n\\t\\t// cnt the number of valid path to last element of element in 2d vector having reminder equal to rem \\n        for(int i=0;i<2;i++){\\n            int x1=x+r[i];\\n            int y1=y+c[i];\\n            if(x1>=0 && x1<n && y1>=0 && y1<m){\\n                cnt=(cnt+solve(dp,A,x1,y1,rem+A[x][y]))%mod;\\n            }\\n        }\\n        return dp[x][y][rem]=cnt;\\n    }\\n    int numberOfPaths(vector<vector<int>>& A, int k) {\\n        n=A.size();\\n        m=A[0].size();\\n        this->k=k;\\n\\t\\t// initialize the vector\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(k,-1)));\\n        return solve(dp,A,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684842,
                "title": "dp-practice-3d-dp-explanation-and-analogy-python",
                "content": "1- A solution format\\n```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        M = 10 ** 9 + 7\\n        m, n = len(grid), len(grid[0])\\n        \\n        # T: m * n * k\\n        T =  [[[0] * k for _ in range(n)] for _ in range(m)]\\n        \\n        # init\\n        # i == 0\\n        r = 0\\n        for j in range(n):\\n            r = (r + grid[0][j]) % k\\n            T[0][j][r] = 1\\n            \\n        # j == 0\\n        r = 0\\n        for i in range(m):\\n            r = (r + grid[i][0]) % k\\n            T[i][0][r] = 1\\n        \\n        # dp update\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                val = grid[i][j]\\n                for r in range(k):\\n                    new_r = (r + val) % k\\n                    T[i][j][new_r] += (T[i-1][j][r] + T[i][j-1][r]) % M\\n        \\n        return T[m-1][n-1][0]\\n            \\n```\\n2- Video Explanation: [Click Here](https://youtu.be/4bNyusZTVTw;)\\n\\n3- Summary or Analysis\\n\\nMethod: DP\\n\\nT[i][j][r] := n_paths starting from (0, 0) ending at (i, j) with path_sum % k == r\\nnotice we compute n_paths % (10 ** 9 + 7)\\n\\n\\nThis problem is similar to Leetcode Problem 188 for which we could also\\naddress using 3-dimensional DP. Check out the corresponding video in our\\nchannel. In fact, we feel that the problem logic here is more direct that\\nthat in Problem 188: Best Time to Buy and Sell Stock IV.\\n\\nPlan: \\nwe explain the DP update rule / or recursion relation during coding.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        M = 10 ** 9 + 7\\n        m, n = len(grid), len(grid[0])\\n        \\n        # T: m * n * k\\n        T =  [[[0] * k for _ in range(n)] for _ in range(m)]\\n        \\n        # init\\n        # i == 0\\n        r = 0\\n        for j in range(n):\\n            r = (r + grid[0][j]) % k\\n            T[0][j][r] = 1\\n            \\n        # j == 0\\n        r = 0\\n        for i in range(m):\\n            r = (r + grid[i][0]) % k\\n            T[i][0][r] = 1\\n        \\n        # dp update\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                val = grid[i][j]\\n                for r in range(k):\\n                    new_r = (r + val) % k\\n                    T[i][j][new_r] += (T[i-1][j][r] + T[i][j-1][r]) % M\\n        \\n        return T[m-1][n-1][0]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684810,
                "title": "bottom-up-dp-python-time-o-m-n-k-space-o-m-n-k",
                "content": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        R, C = len(grid), len(grid[0])\\n        dp = [[[0] * k for _ in range(C)] for _ in range(R)]\\n        dp[0][0][grid[0][0] % k] = 1\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                for n in range(k):\\n                    curr = (n + grid[r][c]) % k\\n                    if r > 0:\\n                        dp[r][c][curr] += dp[r - 1][c][n]\\n                    if c > 0:\\n                        dp[r][c][curr] += dp[r][c - 1][n]\\n                    dp[r][c][curr] %= MOD\\n        return dp[R - 1][C - 1][0] % MOD\\n    # Time: O(m * n * k) where m and n are the dimensions of the grid\\n    # Space: O(m * n * k)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        R, C = len(grid), len(grid[0])\\n        dp = [[[0] * k for _ in range(C)] for _ in range(R)]\\n        dp[0][0][grid[0][0] % k] = 1\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                for n in range(k):\\n                    curr = (n + grid[r][c]) % k\\n                    if r > 0:\\n                        dp[r][c][curr] += dp[r - 1][c][n]\\n                    if c > 0:\\n                        dp[r][c][curr] += dp[r][c - 1][n]\\n                    dp[r][c][curr] %= MOD\\n        return dp[R - 1][C - 1][0] % MOD\\n    # Time: O(m * n * k) where m and n are the dimensions of the grid\\n    # Space: O(m * n * k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684199,
                "title": "recursion-memoizarion-c-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    int K;\\n    int mod = 1000000007;\\n    int numberOfPaths(int x, int y , int value  , vector<vector<int>> &grid , vector<vector<vector<int>>> &dp){\\n        if (x<0 || y<0) return 0;\\n        \\n\\t\\t// if we have reached to 0,0 index but the  sum is not divisible by k will return 0 else 1 \\n        if (x==0 && y == 0) return (value + grid[x][y] ) % K == 0;\\n        \\n\\t\\t// dp[x][y][value] will store the count of paths having path sum % k == 0\\n\\t\\t// And if we have already coumputed it will directly use it\\n        if (dp[x][y][value] != -1) \\n            return dp[x][y][value];\\n        \\n        int &ans=dp[x][y][value];\\n        ans=0;\\n\\t\\t\\n\\t\\t// how many paths will be there if we goes up\\n        ans = (ans + numberOfPaths(x-1 , y , (grid[x][y] + value) % K , grid , dp))%mod;\\n\\t\\t\\n\\t\\t// how many paths will be there if we goes left\\n        ans = (ans + numberOfPaths(x , y-1 , (grid[x][y] + value) % K , grid , dp))%mod;\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m , n ;\\n        m = grid.size();\\n        n = grid[0].size();\\n        K=k;\\n        \\n        vector<vector<vector<int>>> dp(m+1 , vector<vector<int>>(n+1 , vector<int>(k+1 , -1)));\\n        return numberOfPaths(m-1 , n-1 , k , grid , dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int K;\\n    int mod = 1000000007;\\n    int numberOfPaths(int x, int y , int value  , vector<vector<int>> &grid , vector<vector<vector<int>>> &dp){\\n        if (x<0 || y<0) return 0;\\n        \\n\\t\\t// if we have reached to 0,0 index but the  sum is not divisible by k will return 0 else 1 \\n        if (x==0 && y == 0) return (value + grid[x][y] ) % K == 0;\\n        \\n\\t\\t// dp[x][y][value] will store the count of paths having path sum % k == 0\\n\\t\\t// And if we have already coumputed it will directly use it\\n        if (dp[x][y][value] != -1) \\n            return dp[x][y][value];\\n        \\n        int &ans=dp[x][y][value];\\n        ans=0;\\n\\t\\t\\n\\t\\t// how many paths will be there if we goes up\\n        ans = (ans + numberOfPaths(x-1 , y , (grid[x][y] + value) % K , grid , dp))%mod;\\n\\t\\t\\n\\t\\t// how many paths will be there if we goes left\\n        ans = (ans + numberOfPaths(x , y-1 , (grid[x][y] + value) % K , grid , dp))%mod;\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m , n ;\\n        m = grid.size();\\n        n = grid[0].size();\\n        K=k;\\n        \\n        vector<vector<vector<int>>> dp(m+1 , vector<vector<int>>(n+1 , vector<int>(k+1 , -1)));\\n        return numberOfPaths(m-1 , n-1 , k , grid , dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683414,
                "title": "easy-c-solution-o-n-m-k-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<long long>>> dp;\\n    int n,m,mod = 1000000007;\\n    int numberOfPaths(vector<vector<int>>& g, int k) {\\n        n = g.size() , m = g[0].size();\\n        dp.resize(n,vector<vector<long long>>(m,vector<long long>(k+1,-1)));\\n        return solve(0,0,g,0,k);\\n    }\\n    long long solve(int r,int c,vector<vector<int>> &g,int val,int k) {\\n          if(r<0 || r>=n || c<0 || c>=m) return 0;\\n          if(r == n-1 && c==m-1) return (val + g[r][c]) % k == 0;\\n          if(dp[r][c][val]!=-1) return dp[r][c][val];\\n          long long cnt = 0;\\n          cnt = (cnt + solve(r+1,c,g,(val + g[r][c])%k,k))%mod;\\n          cnt = (cnt + solve(r,c+1,g,(val + g[r][c])%k,k))%mod;\\n          return dp[r][c][val] = cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<long long>>> dp;\\n    int n,m,mod = 1000000007;\\n    int numberOfPaths(vector<vector<int>>& g, int k) {\\n        n = g.size() , m = g[0].size();\\n        dp.resize(n,vector<vector<long long>>(m,vector<long long>(k+1,-1)));\\n        return solve(0,0,g,0,k);\\n    }\\n    long long solve(int r,int c,vector<vector<int>> &g,int val,int k) {\\n          if(r<0 || r>=n || c<0 || c>=m) return 0;\\n          if(r == n-1 && c==m-1) return (val + g[r][c]) % k == 0;\\n          if(dp[r][c][val]!=-1) return dp[r][c][val];\\n          long long cnt = 0;\\n          cnt = (cnt + solve(r+1,c,g,(val + g[r][c])%k,k))%mod;\\n          cnt = (cnt + solve(r,c+1,g,(val + g[r][c])%k,k))%mod;\\n          return dp[r][c][val] = cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681811,
                "title": "recursive-dp-easy-and-clean-solution-o-n-m-k",
                "content": "here we should maintain the sum%k instead of sum \\n\\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    vector<vector<vector<int>>>dp;\\n    int n,m,K;\\n    int rec(int i,int j,int sum,vector<vector<int>>& g){\\n        if(i==n-1 && j==m-1) {\\n            if(sum==0) return 1;\\n            else return 0;\\n        }\\n        if(dp[i][j][sum]!=-1) return dp[i][j][sum];\\n        int ans=0;\\n        if(i+1<n) (ans+= rec(i+1,j,(sum+g[i+1][j])%K,g))%=mod;\\n        if(j+1<m) (ans+= rec(i,j+1,(sum+g[i][j+1])%K,g))%=mod;\\n        return dp[i][j][sum]=ans%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        n=grid.size();m=grid[0].size();\\n        K=k;\\n        dp.resize(n+1,vector<vector<int>>(m+1,vector<int>(k+1,-1)));\\n        return rec(0,0,grid[0][0]%k,grid);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    const int mod=1e9+7;\\n    vector<vector<vector<int>>>dp;\\n    int n,m,K;\\n    int rec(int i,int j,int sum,vector<vector<int>>& g){\\n        if(i==n-1 && j==m-1) {\\n            if(sum==0) return 1;\\n            else return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2681720,
                "title": "clean-and-readable-java-code",
                "content": "```\\n// TC : O(rows*cols*k)\\n// SC : O(rows*cols*k)\\n\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        long dp[][][] = new long[rows][cols][k];\\n        long mod = (long)1e9+7;\\n        \\n        for(int row=0; row<rows; row++){\\n            for(int col=0; col<cols; col++){\\n                int rem = grid[row][col]%k;\\n                \\n                if(row==0 && col==0) dp[row][col][rem] = 1;\\n                else{\\n                    for(int currem=0;currem<k;currem++){\\n                        if(row==0) dp[row][col][(currem+rem)%k] = dp[row][col-1][currem];\\n                        else if(col==0) dp[row][col][(currem+rem)%k] = dp[row-1][col][currem];\\n                        else{\\n                            dp[row][col][(currem+rem)%k] = ((dp[row-1][col][currem]%mod) + (dp[row][col-1][currem]%mod))%mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = (int)(dp[rows-1][cols-1][0]%mod);\\n        if(ans<0) ans+=(int)mod;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n// TC : O(rows*cols*k)\\n// SC : O(rows*cols*k)\\n\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        long dp[][][] = new long[rows][cols][k];\\n        long mod = (long)1e9+7;\\n        \\n        for(int row=0; row<rows; row++){\\n            for(int col=0; col<cols; col++){\\n                int rem = grid[row][col]%k;\\n                \\n                if(row==0 && col==0) dp[row][col][rem] = 1;\\n                else{\\n                    for(int currem=0;currem<k;currem++){\\n                        if(row==0) dp[row][col][(currem+rem)%k] = dp[row][col-1][currem];\\n                        else if(col==0) dp[row][col][(currem+rem)%k] = dp[row-1][col][currem];\\n                        else{\\n                            dp[row][col][(currem+rem)%k] = ((dp[row-1][col][currem]%mod) + (dp[row][col-1][currem]%mod))%mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = (int)(dp[rows-1][cols-1][0]%mod);\\n        if(ans<0) ans+=(int)mod;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681644,
                "title": "python3-top-down-dp-no-tle-beat-100",
                "content": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        def dfs(i, j):    \\n            if (i, j) in memo: return memo[(i, j)]\\n            currVal = grid[i][j]\\n            res = [0 for _ in range(k)]\\n            for di, dj in [(0, 1), (1, 0)]:\\n                ni, nj = i+di, j+dj\\n                if ni < m and nj < n:\\n                    cnts = dfs(ni, nj)\\n                    for l, cnt in enumerate(cnts):\\n                        if cnt == 0: continue\\n                        res[(l + currVal) % k] += cnt % (10 ** 9 + 7)\\n            \\n            memo[(i, j)] = res\\n            return res\\n\\n        m, n = len(grid), len(grid[0])\\n        memo = {}\\n        memo[(m-1, n-1)] = [0 for _ in range(k)]\\n        memo[(m-1, n-1)][grid[-1][-1] % k] = 1\\n        dfs(0, 0)\\n        return memo[(0, 0)][0] % (10 ** 9 + 7)\\n```\\nRuntime: 3525 ms\\nMemory: 158.7 MB",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        def dfs(i, j):    \\n            if (i, j) in memo: return memo[(i, j)]\\n            currVal = grid[i][j]\\n            res = [0 for _ in range(k)]\\n            for di, dj in [(0, 1), (1, 0)]:\\n                ni, nj = i+di, j+dj\\n                if ni < m and nj < n:\\n                    cnts = dfs(ni, nj)\\n                    for l, cnt in enumerate(cnts):\\n                        if cnt == 0: continue\\n                        res[(l + currVal) % k] += cnt % (10 ** 9 + 7)\\n            \\n            memo[(i, j)] = res\\n            return res\\n\\n        m, n = len(grid), len(grid[0])\\n        memo = {}\\n        memo[(m-1, n-1)] = [0 for _ in range(k)]\\n        memo[(m-1, n-1)][grid[-1][-1] % k] = 1\\n        dfs(0, 0)\\n        return memo[(0, 0)][0] % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680959,
                "title": "easy-dp-solution-with-memoization-approach-explained",
                "content": "Approach:\\n1. Recursively find the solution by using the paraemeter k1 which denotes the remainder of the path sum % k value. During recursive approriate remainder should be calculated. This equation is clumsy but you will get it if you write the equation that path sum % k should be zero then, what is the remainder for the remaining if you take the first element in the sum. The new remainder for the adjacent cells will be (k1-(g[i][j]%k)+k)%k. proof is as below.\\n\\nProof: \\n\\nNote: (a+b)%k = k1 \\nimplies (a%k+b%k)%k = k1\\n\\nLet\\'s say the path sum is a1+a2+a3+...+an . Then  we want (a1+a2+a3+...+an)%k =k1 ( with k1 =0 for our problem). If you are taking grid[i][j] as a1 then the (a2+a3+..+an)%k should be k1-(a2+a3+..+an)%k. This might be negative so I am adding another k then doing %k to get the remainder again between 0 to k-1.\\n\\nCPP code:\\n\\n```\\n#define MOD 1000000007\\nclass Solution {\\n    int m,n,k;\\n    vector<vector<int>> g;\\n    vector<vector<vector<int>>> dp;\\n  \\npublic:\\n    int f(int i,int j,int k1){\\n         //g[i][j] = g[i][j];\\n        if(i==(m-1) &&  j ==(n-1)){\\n            return (g[i][j]%k == k1);\\n        }\\n  \\n       if(dp[i][j][k1]!=-1) return dp[i][j][k1];\\n        int down =0,right =0;\\n        \\n        if(i+1 < m)\\n            down = f(i+1,j,(k1-(g[i][j]%k)+k)%k)%MOD;\\n        if(j+1<n)\\n            right = f(i,j+1,(k1-(g[i][j]%k)+k)%k)%MOD;\\n        \\n        //cout<<i<<\",\"<<j<<\"-\"<<ans<<endl;\\n        return dp[i][j][k1]=(right+down)%MOD;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k1) {\\n        k = k1;\\n        m = grid.size(); n = grid[0].size();\\n        g =grid;\\n        vector<vector<vector<int>>> dp1(m,vector<vector<int>>(n,vector<int>(k+1,-1)));\\n        dp=dp1;\\n        return f(0,0,0)%MOD;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int m,n,k;\\n    vector<vector<int>> g;\\n    vector<vector<vector<int>>> dp;\\n  \\npublic:\\n    int f(int i,int j,int k1){\\n         //g[i][j] = g[i][j];\\n        if(i==(m-1) &&  j ==(n-1)){\\n            return (g[i][j]%k == k1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2680926,
                "title": "2-java-dp-solutions",
                "content": "**upvote if it helped**\\n**feel free to ask any query**\\n**-------------------------------------------------------------------1st code-----------------------------------------------------------------**\\n```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int K) {\\n        int[][][] dp = new int[grid.length][grid[0].length][K];\\n        int mod = 1000000007;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j][grid[i][j] % K] = 1;\\n                    continue;\\n                }\\n                for (int k = 0; k < K; k++) {\\n                    if (i > 0) {\\n                        dp[i][j][(k + grid[i][j]) % K] += dp[i - 1][j][k];\\n                        dp[i][j][(k + grid[i][j]) % K] %= mod;\\n                    }\\n                    if (j > 0) {\\n                        dp[i][j][(k + grid[i][j]) % K] += dp[i][j - 1][k];\\n                        dp[i][j][(k + grid[i][j]) % K] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[grid.length - 1][grid[0].length - 1][0];\\n    }\\n}\\n```\\n\\n**----------------------------------------------------------2nd code------------------------------------------------------------------**\\n\\n```\\nclass Solution {\\n   private static final long MOD = (long)1e9 + 7;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        long[][][] dp = new long[m][n][k];\\n        int mod = grid[0][0] % k;\\n        dp[0][0][mod] = 1;\\n        for (int i = 1; i < m; i++) {\\n            mod = (mod + grid[i][0]) % k;\\n            dp[i][0][mod] = 1;\\n        }\\n        mod = grid[0][0] % k;\\n        for (int j = 1; j < n; j++) {\\n            mod = (mod + grid[0][j]) % k;\\n            dp[0][j][mod] = 1;\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                for (int p = 0; p < k; p++) {\\n                    dp[i][j][(p+grid[i][j]) % k] = (dp[i][j][(p+grid[i][j]) % k] + dp[i-1][j][p]) % MOD;\\n                }\\n                for (int p = 0; p < k; p++) {\\n                    dp[i][j][(p+grid[i][j]) % k] = (dp[i][j][(p+grid[i][j]) % k] + dp[i][j-1][p]) % MOD;\\n                }\\n            }\\n        }\\n        return (int)dp[m-1][n-1][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int K) {\\n        int[][][] dp = new int[grid.length][grid[0].length][K];\\n        int mod = 1000000007;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j][grid[i][j] % K] = 1;\\n                    continue;\\n                }\\n                for (int k = 0; k < K; k++) {\\n                    if (i > 0) {\\n                        dp[i][j][(k + grid[i][j]) % K] += dp[i - 1][j][k];\\n                        dp[i][j][(k + grid[i][j]) % K] %= mod;\\n                    }\\n                    if (j > 0) {\\n                        dp[i][j][(k + grid[i][j]) % K] += dp[i][j - 1][k];\\n                        dp[i][j][(k + grid[i][j]) % K] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[grid.length - 1][grid[0].length - 1][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n   private static final long MOD = (long)1e9 + 7;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        long[][][] dp = new long[m][n][k];\\n        int mod = grid[0][0] % k;\\n        dp[0][0][mod] = 1;\\n        for (int i = 1; i < m; i++) {\\n            mod = (mod + grid[i][0]) % k;\\n            dp[i][0][mod] = 1;\\n        }\\n        mod = grid[0][0] % k;\\n        for (int j = 1; j < n; j++) {\\n            mod = (mod + grid[0][j]) % k;\\n            dp[0][j][mod] = 1;\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                for (int p = 0; p < k; p++) {\\n                    dp[i][j][(p+grid[i][j]) % k] = (dp[i][j][(p+grid[i][j]) % k] + dp[i-1][j][p]) % MOD;\\n                }\\n                for (int p = 0; p < k; p++) {\\n                    dp[i][j][(p+grid[i][j]) % k] = (dp[i][j][(p+grid[i][j]) % k] + dp[i][j-1][p]) % MOD;\\n                }\\n            }\\n        }\\n        return (int)dp[m-1][n-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680858,
                "title": "c-unordered-map-vs-vector-vector-int-for-dp-map-gives-tle",
                "content": "Hi ,\\nIn code I have used unordered_map to store memorization , I got  TLE , I was scratching head for hour for more optimizations . but  using vector gives much more faster way but both access time should be O(1) right ?\\n\\nwhy unordered_map gives TLE and vector do not  ? if anyones knows p? :)\\n\\n1 -> **using unordered_map :**\\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int mod=1e9+7;\\n        unordered_map<int,vector<long>> mp;\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                for(int h=0;h<k;h++){\\n                    mp[i*m+j].push_back(0);\\n                }\\n                \\n            }\\n        }\\n        mp[(n-1)*m+m-1][grid[n-1][m-1]%k]=1;\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int md=grid[i][j]%k;\\n                int curr=i*m+j;\\n                if(j+1<m){\\n                    int right=i*m+j+1;\\n                    for(int h=0;h<k;h++){\\n                        long mdL=mp[right][h];\\n                        if(mdL==0) continue;\\n                        mp[curr][(h+md)%k]=(mp[curr][(h+md)%k]+mdL)%mod;\\n                    }\\n                }\\n                 if(i+1<n){\\n                    int down=(i+1)*m+j;\\n                    for(int h=0;h<k;h++){\\n                        long mdL=mp[down][h];\\n                         if(mdL==0) continue;\\n                        mp[curr][(h+md)%k]=(mp[curr][(h+md)%k]+mdL)%mod;\\n                    }\\n                }     \\n            }\\n        }\\n        return mp[0][0];\\n    }\\n};\\n```\\n\\n2-> **using vector<vector<int.>>** \\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int mod=1e9+7;\\n        vector<vector<int>> mp(n*m,vector<int>(k+1,0));\\n        mp[(n-1)*m+m-1][grid[n-1][m-1]%k]=1;\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int md=grid[i][j]%k;\\n                int curr=i*m+j;\\n                // cout<<curr<<endl;\\n                if(j+1<m){\\n                    int right=i*m+j+1;\\n                    for(int h=0;h<k;h++){\\n                        long mdL=mp[right][h];\\n                        if(mdL==0) continue;\\n                        mp[curr][(h+md)%k]=(mp[curr][(h+md)%k]+mdL)%mod;\\n                    }\\n                }\\n                \\n                if(i+1<n){\\n                    int down=(i+1)*m+j;\\n                    for(int h=0;h<k;h++){\\n                        long mdL=mp[down][h];\\n                        if(mdL==0) continue;\\n                        mp[curr][(h+md)%k]=(mp[curr][(h+md)%k]+mdL)%mod;\\n                    }\\n                }  \\n            }\\n        }\\n        return mp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int mod=1e9+7;\\n        unordered_map<int,vector<long>> mp;\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                for(int h=0;h<k;h++){\\n                    mp[i*m+j].push_back(0);\\n                }\\n                \\n            }\\n        }\\n        mp[(n-1)*m+m-1][grid[n-1][m-1]%k]=1;\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int md=grid[i][j]%k;\\n                int curr=i*m+j;\\n                if(j+1<m){\\n                    int right=i*m+j+1;\\n                    for(int h=0;h<k;h++){\\n                        long mdL=mp[right][h];\\n                        if(mdL==0) continue;\\n                        mp[curr][(h+md)%k]=(mp[curr][(h+md)%k]+mdL)%mod;\\n                    }\\n                }\\n                 if(i+1<n){\\n                    int down=(i+1)*m+j;\\n                    for(int h=0;h<k;h++){\\n                        long mdL=mp[down][h];\\n                         if(mdL==0) continue;\\n                        mp[curr][(h+md)%k]=(mp[curr][(h+md)%k]+mdL)%mod;\\n                    }\\n                }     \\n            }\\n        }\\n        return mp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int mod=1e9+7;\\n        vector<vector<int>> mp(n*m,vector<int>(k+1,0));\\n        mp[(n-1)*m+m-1][grid[n-1][m-1]%k]=1;\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                int md=grid[i][j]%k;\\n                int curr=i*m+j;\\n                // cout<<curr<<endl;\\n                if(j+1<m){\\n                    int right=i*m+j+1;\\n                    for(int h=0;h<k;h++){\\n                        long mdL=mp[right][h];\\n                        if(mdL==0) continue;\\n                        mp[curr][(h+md)%k]=(mp[curr][(h+md)%k]+mdL)%mod;\\n                    }\\n                }\\n                \\n                if(i+1<n){\\n                    int down=(i+1)*m+j;\\n                    for(int h=0;h<k;h++){\\n                        long mdL=mp[down][h];\\n                        if(mdL==0) continue;\\n                        mp[curr][(h+md)%k]=(mp[curr][(h+md)%k]+mdL)%mod;\\n                    }\\n                }  \\n            }\\n        }\\n        return mp[0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2680528,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    #define MOD 1000000007\\n    int rec(int i,int j,int m,int n,int rem,vector<vector<int>>& grid,int k,vector<vector<vector<int>>>&dp)\\n    {\\n        if(i>=m || j>=n) return 0;\\n        if(i==m-1 && j==n-1)\\n        {\\n            if((grid[i][j]+rem)%k==0)\\n            {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][j][rem]!=-1) return dp[i][j][rem];\\n        int nxt_rem=(grid[i][j]+rem)%k;\\n        int right=rec(i,j+1,m,n,nxt_rem,grid,k,dp);\\n        int down=rec(i+1,j,m,n,nxt_rem,grid,k,dp);\\n        return dp[i][j][rem]=(right+down)%MOD;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n        return rec(0,0,m,n,0,grid,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define MOD 1000000007\\n    int rec(int i,int j,int m,int n,int rem,vector<vector<int>>& grid,int k,vector<vector<vector<int>>>&dp)\\n    {\\n        if(i>=m || j>=n) return 0;\\n        if(i==m-1 && j==n-1)\\n        {\\n            if((grid[i][j]+rem)%k==0)\\n            {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][j][rem]!=-1) return dp[i][j][rem];\\n        int nxt_rem=(grid[i][j]+rem)%k;\\n        int right=rec(i,j+1,m,n,nxt_rem,grid,k,dp);\\n        int down=rec(i+1,j,m,n,nxt_rem,grid,k,dp);\\n        return dp[i][j][rem]=(right+down)%MOD;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n        return rec(0,0,m,n,0,grid,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680410,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    long[][][] dp;\\n    long mod = 1000000007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        dp = new long[n][m][k + 1];\\n        for(long[][] arr : dp){\\n            for(long[] ar : arr){\\n                Arrays.fill(ar, (long)-1);\\n            }\\n        }\\n        return (int)helper(grid, k, 0, 0, 0);\\n    }\\n    \\n    public long helper(int[][] grid, int k, int i, int j , int sum){\\n        if(i >= grid.length || j >= grid[0].length || i < 0 || j < 0){\\n            return 0;\\n        }\\n        if(dp[i][j][sum] != -1){\\n            return dp[i][j][sum];\\n        }\\n        if(i == grid.length - 1 && j == grid[0].length - 1){\\n            if((sum + grid[i][j]) % k == 0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        \\n        return dp[i][j][sum] = (helper(grid, k, i + 1, j, (sum + grid[i][j]) % k) + helper(grid, k, i, j + 1, (sum + grid[i][j]) % k)) % mod;\\n        \\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long[][][] dp;\\n    long mod = 1000000007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        dp = new long[n][m][k + 1];\\n        for(long[][] arr : dp){\\n            for(long[] ar : arr){\\n                Arrays.fill(ar, (long)-1);\\n            }\\n        }\\n        return (int)helper(grid, k, 0, 0, 0);\\n    }\\n    \\n    public long helper(int[][] grid, int k, int i, int j , int sum){\\n        if(i >= grid.length || j >= grid[0].length || i < 0 || j < 0){\\n            return 0;\\n        }\\n        if(dp[i][j][sum] != -1){\\n            return dp[i][j][sum];\\n        }\\n        if(i == grid.length - 1 && j == grid[0].length - 1){\\n            if((sum + grid[i][j]) % k == 0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        \\n        return dp[i][j][sum] = (helper(grid, k, i + 1, j, (sum + grid[i][j]) % k) + helper(grid, k, i, j + 1, (sum + grid[i][j]) % k)) % mod;\\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680349,
                "title": "simple-3d-dp-memorization-currsum-tracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(50,-1)));\\n        //memset(dp,-1,sizeof dp);\\n        return helper(grid,k,m-1,n-1,0,dp);\\n    }\\n    int helper(vector<vector<int>>& grid, int k,int i,int j,int curr,vector<vector<vector<int>>> &dp){\\n        if(i<0 || j<0)\\n            return 0;\\n        \\n        if(i==0 && j==0)\\n            return ((curr+grid[0][0])%k)?0:1;\\n        \\n        if(dp[i][j][curr] != -1)\\n            return dp[i][j][curr];\\n        \\n        int left=(helper(grid,k,i,j-1,(curr+grid[i][j])%k,dp));\\n        \\n        int up=(helper(grid,k,i-1,j,(curr+grid[i][j])%k,dp));\\n        \\n        return dp[i][j][curr]= (left+up)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(50,-1)));\\n        //memset(dp,-1,sizeof dp);\\n        return helper(grid,k,m-1,n-1,0,dp);\\n    }\\n    int helper(vector<vector<int>>& grid, int k,int i,int j,int curr,vector<vector<vector<int>>> &dp){\\n        if(i<0 || j<0)\\n            return 0;\\n        \\n        if(i==0 && j==0)\\n            return ((curr+grid[0][0])%k)?0:1;\\n        \\n        if(dp[i][j][curr] != -1)\\n            return dp[i][j][curr];\\n        \\n        int left=(helper(grid,k,i,j-1,(curr+grid[i][j])%k,dp));\\n        \\n        int up=(helper(grid,k,i-1,j,(curr+grid[i][j])%k,dp));\\n        \\n        return dp[i][j][curr]= (left+up)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680161,
                "title": "dp-solution-o-row-col-k-from-top-down-to-bottom-up-and-3d-to-2d-space-optimize-approach",
                "content": "\\n1. Recursion (Top down Apprroach): Starting from (n-1, m-1) , for every (row,col), I can either move to up or left ( oppsite of what question states) each time we also add a variable, \"sum\" which is also capturing sum for each steps. and at the base if I reach end point (0,0) ,  then check the divisiblity with k , if it is divisible then return 1, else return 0.\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tint mod = (int) 1e9+7;\\n\\t\\t\\tint f(int row, int col, int sum,int k, vector<vector<int>>& grid){\\n\\t\\t\\t\\tif (row == 0 and col == 0) {\\n\\t\\t\\t\\t\\tsum = sum + grid[0][0];\\n\\t\\t\\t\\t\\tif(sum % k == 0) return 1;\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (row < 0 or col < 0) return 0;\\n\\t\\t\\t\\tint up = f(row - 1, col, sum + grid[row][col],k, grid);\\n\\t\\t\\t\\tint left = f(row, col - 1, sum + grid[row][col],k, grid);\\n\\t\\t\\t\\treturn (left + up) % mod;\\n\\t\\t\\t}\\n\\t\\tpublic:\\n\\t\\t\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\t\\t\\tint n = grid.size();\\n\\t\\t\\t\\tint m = grid[0].size();\\n\\t\\t\\t\\treturn f(n-1, m-1, 0, k, grid);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\n\\t\\t// Time Complexity : O(2^(row * col)) means exponential\\n\\t\\t// Space Complexity : O(row + col) recursion stack space\\n\\n2. Memoization : if we carefully observe, we have overlapping subproblem if we have large value of row and col, so to decrease compute time we use memoization.\\n\\n    **** and one more critical thing, we need to memoize sum of previous states , so that we can compute it for current state and return the count of divisibal by k; \\n\\t\\n    **** problem will be how to store the sum , it can be very large, show to stor that sum we need huge space. to overcome the issue, each time we just compute (sum % k), \\n\\n\\t\\tclass Solution {\\n\\t\\t\\tint mod = (int) 1e9+7;\\n\\t\\t\\tint f(int row, int col, int sum,int k, vector<vector<int>>& grid, vector<vector<vector<int>>> &dp){\\n\\t\\t\\t\\tif (row == 0 and col == 0) {\\n\\t\\t\\t\\t\\tsum = sum + grid[0][0];\\n\\t\\t\\t\\t\\tif(sum % k == 0) return 1;\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (row < 0 or col < 0) return 0;\\n\\t\\t\\t\\tif(dp[row][col][sum] != -1) return dp[row][col][sum];\\n\\t\\t\\t\\tint up = f(row - 1, col, (sum + grid[row][col]) % k,k, grid,dp);\\n\\t\\t\\t\\tint left = f(row, col - 1, (sum + grid[row][col]) % k,k, grid,dp); // to overcome large sum , we just compute it (grid[row][col] + sum) % k\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// now value of sum can be from 0 to k-1;\\n\\t\\t\\t\\treturn dp[row][col][sum] = (left + up) % mod;\\n\\t\\t\\t}\\n\\t\\tpublic:\\n\\t\\t\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\t\\t\\tint n = grid.size();\\n\\t\\t\\t\\tint m = grid[0].size();\\n\\t\\t\\t\\tvector<vector<vector<int>>> dp(n, vector<vector<int>>(m,vector<int>(k, -1))); // thats why we need k length to store the sum.\\n\\t\\t\\t\\treturn f(n-1, m-1, 0, k, grid,dp);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t// Time Complexity : O(row * col * k)\\n\\t\\t// Space Complexity : O(row * col * k) + O(row * col).  O(row * col) for recursion stack space\\n\\n\\n3. Tabulation ( bottom up approach) : to reduce this extra O(row * col ) recursion stack space, we trying tabulation approach\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\t\\t\\tint mod = (int) 1e9+7;\\n\\t\\t\\t\\tint n = grid.size();\\n\\t\\t\\t\\tint m = grid[0].size();\\n\\t\\t\\t\\tvector<vector<vector<int>>> dp(n, vector<vector<int>>(m,vector<int>(k, 0)));\\n\\t\\t\\t\\tfor(int row = 0; row < n ;row++){\\n\\t\\t\\t\\t\\tfor(int col = 0 ; col < m ;col++){\\n\\t\\t\\t\\t\\t\\tfor(int sum = 0 ; sum < k ; sum++){\\n\\t\\t\\t\\t\\t\\t\\tif(row == 0 and col == 0){ //  base case\\n\\t\\t\\t\\t\\t\\t\\t\\tif( (grid[0][0] + sum) % k == 0){ // for any time sum , if (grid[0][0] + sum) % k == 0 then , \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//for that sum we can get possible one ans,  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t dp[0][0][sum] = 1; \\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else{\\n\\t\\t\\t\\t\\t\\t\\t\\tint up = 0, left = 0;\\n\\t\\t\\t\\t\\t\\t\\t\\tif(row - 1 >= 0) up = dp[row - 1][col][(sum + grid[row][col]) % k];\\n\\t\\t\\t\\t\\t\\t\\t\\tif(col-1 >= 0) left = dp[row][ col - 1][(sum + grid[row][col]) % k];\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[row][col][sum] = (left + up) % mod;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn dp[n-1][m-1][0];\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t// Time Complexity : O(row*col*k)\\n\\t\\t// Space Complexity : O(row*col*k).\\n\\n4. Space Optimization :  if we carefully observe only previous row (i - 1) is needed to compute cur row(i) .so using 2 2 - D array we can solve. other row is not needed. so space complexity boils down to O(col * k);\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\t\\t\\tint mod = (int) 1e9+7;\\n\\t\\t\\t\\tint n = grid.size();\\n\\t\\t\\t\\tint m = grid[0].size();\\n\\t\\t\\t\\t// vector<vector<vector<int>>> dp(n, vector<vector<int>>(m,vector<int>(k, 0)));\\n\\t\\t\\t\\tvector<vector<int>> prev(m,vector<int>(k, 0)), cur(m,vector<int>(k, 0));\\n\\t\\t\\t\\tfor(int row = 0; row < n ;row++){\\n\\t\\t\\t\\t\\tfor(int col = 0 ; col < m ;col++){\\n\\t\\t\\t\\t\\t\\tfor(int sum = 0 ; sum < k ; sum++){\\n\\t\\t\\t\\t\\t\\t\\tif(row == 0 and col == 0){ //  base case\\n\\t\\t\\t\\t\\t\\t\\t\\tif( (grid[0][0] + sum) % k == 0){ // for any time sum , if (grid[0][0] + sum) % k == 0 then , \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//for that sum we can get possible one ans,  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t cur[0][sum] = 1;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else{\\n\\t\\t\\t\\t\\t\\t\\t\\tint up = 0, left = 0;\\n\\t\\t\\t\\t\\t\\t\\t\\tif(row - 1 >= 0) up = prev[col][(sum + grid[row][col]) % k];\\n\\t\\t\\t\\t\\t\\t\\t\\tif(col-1 >= 0) left = cur[ col - 1][(sum + grid[row][col]) % k];\\n\\t\\t\\t\\t\\t\\t\\t\\tcur[col][sum] = (left + up) % mod;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tprev = cur;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn prev[m-1][0];\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t// Time Complexity : O(row*col*k)\\n\\t\\t// Space Complexity : O(col * k).",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\t\\t\\tint mod = (int) 1e9+7;\\n\\t\\t\\tint f(int row, int col, int sum,int k, vector<vector<int>>& grid){\\n\\t\\t\\t\\tif (row == 0 and col == 0) {\\n\\t\\t\\t\\t\\tsum = sum + grid[0][0];\\n\\t\\t\\t\\t\\tif(sum % k == 0) return 1;\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2680123,
                "title": "brute-force-vs-dp",
                "content": "```\\n**BRUTE FORCE APPROACH (for better understanding but will give TLE, once you understand this, go for dp)**\\n\\nclass Solution {\\n    \\n    public int numberOfPaths(int[][] grid, int k) {\\n        \\n      \\n        \\n        return t(grid,0,0,grid.length,grid[0].length,0, k);\\n        \\n       \\n    }\\n    \\n    int t(int [][] grid,int row, int col, int noOfRows, int noOfCols, int sum, int k){\\n        \\n        if(row<0 || row==noOfRows ||\\n          col<0 || col==noOfCols){\\n            return 0;\\n        }\\n      \\n        sum += grid[row][col];\\n        \\n        if(row==noOfRows-1 && col==noOfCols-1){\\n           \\n            return sum%k==0?1:0;\\n        }\\n        \\n    \\n        return (t(grid,row+1,col,noOfRows, noOfCols,sum, k) + t(grid,row,col+1,noOfRows, noOfCols,sum, k))%1000000007;\\n        \\n    }\\n}\\n\\n**DP**\\n\\nclass Solution {\\n \\n    int dp[][][];\\n    public int numberOfPaths(int[][] grid, int k) {\\n        \\n        dp = new int [grid.length][grid[0].length][50];\\n        \\n        for(int [][] matrix: dp)\\n            for(int [] arr: matrix)\\n                Arrays.fill(arr,-1);\\n        \\n        \\n        return t(grid,0,0,grid.length,grid[0].length,0, k);\\n        \\n       \\n    }\\n    \\n    int t(int [][] grid,int row, int col, int noOfRows, int noOfCols, int sum, int k){\\n        \\n        if(row<0 || row==noOfRows ||\\n          col<0 || col==noOfCols){\\n            return 0;\\n        }\\n        sum += grid[row][col];\\n        \\n        if(row==noOfRows-1 && col==noOfCols-1){\\n            return sum%k==0?1:0;\\n        }\\n        \\n        if(dp[row][col][sum%k]!=-1){\\n            return dp[row][col][sum%k];\\n        }\\n        \\n        dp[row][col][sum%k] = (t(grid,row+1,col,noOfRows, noOfCols,sum, k) + t(grid,row,col+1,noOfRows, noOfCols,sum, k))%1000000007;\\n        return dp[row][col][sum%k];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n**BRUTE FORCE APPROACH (for better understanding but will give TLE, once you understand this, go for dp)**\\n\\nclass Solution {\\n    \\n    public int numberOfPaths(int[][] grid, int k) {\\n        \\n      \\n        \\n        return t(grid,0,0,grid.length,grid[0].length,0, k);\\n        \\n       \\n    }\\n    \\n    int t(int [][] grid,int row, int col, int noOfRows, int noOfCols, int sum, int k){\\n        \\n        if(row<0 || row==noOfRows ||\\n          col<0 || col==noOfCols){\\n            return 0;\\n        }\\n      \\n        sum += grid[row][col];\\n        \\n        if(row==noOfRows-1 && col==noOfCols-1){\\n           \\n            return sum%k==0?1:0;\\n        }\\n        \\n    \\n        return (t(grid,row+1,col,noOfRows, noOfCols,sum, k) + t(grid,row,col+1,noOfRows, noOfCols,sum, k))%1000000007;\\n        \\n    }\\n}\\n\\n**DP**\\n\\nclass Solution {\\n \\n    int dp[][][];\\n    public int numberOfPaths(int[][] grid, int k) {\\n        \\n        dp = new int [grid.length][grid[0].length][50];\\n        \\n        for(int [][] matrix: dp)\\n            for(int [] arr: matrix)\\n                Arrays.fill(arr,-1);\\n        \\n        \\n        return t(grid,0,0,grid.length,grid[0].length,0, k);\\n        \\n       \\n    }\\n    \\n    int t(int [][] grid,int row, int col, int noOfRows, int noOfCols, int sum, int k){\\n        \\n        if(row<0 || row==noOfRows ||\\n          col<0 || col==noOfCols){\\n            return 0;\\n        }\\n        sum += grid[row][col];\\n        \\n        if(row==noOfRows-1 && col==noOfCols-1){\\n            return sum%k==0?1:0;\\n        }\\n        \\n        if(dp[row][col][sum%k]!=-1){\\n            return dp[row][col][sum%k];\\n        }\\n        \\n        dp[row][col][sum%k] = (t(grid,row+1,col,noOfRows, noOfCols,sum, k) + t(grid,row,col+1,noOfRows, noOfCols,sum, k))%1000000007;\\n        return dp[row][col][sum%k];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680036,
                "title": "c-dp-o-n-m-k-not-hard",
                "content": "```\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int n;\\n    long long dfs(vector<vector<int>>& nums,vector<vector<long long>>& dp,int &k,int x,int y,int r){\\n        if(x<0||x>=nums.size()||y<0||y>=nums[0].size()) return 0; // Boundary condition check\\n        int t = x*nums[0].size()+y; // 2D co-ordinate to 1D co-ordinate\\n        if(t==n-1){ // if current cell is last cell \\n            if((r+nums[x][y])%k == 0) return 1; // if current remainder ==0 , return 1;\\n            else return 0;\\n        }\\n        if(dp[t][r]!=-1) return dp[t][r]; // check if current state is visited or not\\n\\t\\t// go to right and down and add to ans\\n        long long re = dfs(nums,dp,k,x+1,y,(r+nums[x][y])%k);\\n        re = (re + dfs(nums,dp,k,x,y+1,(r+nums[x][y])%k))%mod;\\n        return dp[t][r] = re;\\n    }\\n    int numberOfPaths(vector<vector<int>>& nums, int k) {\\n        n = nums.size()*nums[0].size();\\n        vector<vector<long long>> dp(n+1,vector<long long>(k,-1));\\n        return dfs(nums,dp,k,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int n;\\n    long long dfs(vector<vector<int>>& nums,vector<vector<long long>>& dp,int &k,int x,int y,int r){\\n        if(x<0||x>=nums.size()||y<0||y>=nums[0].size()) return 0; // Boundary condition check\\n        int t = x*nums[0].size()+y; // 2D co-ordinate to 1D co-ordinate\\n        if(t==n-1){ // if current cell is last cell \\n            if((r+nums[x][y])%k == 0) return 1; // if current remainder ==0 , return 1;\\n            else return 0;\\n        }\\n        if(dp[t][r]!=-1) return dp[t][r]; // check if current state is visited or not\\n\\t\\t// go to right and down and add to ans\\n        long long re = dfs(nums,dp,k,x+1,y,(r+nums[x][y])%k);\\n        re = (re + dfs(nums,dp,k,x,y+1,(r+nums[x][y])%k))%mod;\\n        return dp[t][r] = re;\\n    }\\n    int numberOfPaths(vector<vector<int>>& nums, int k) {\\n        n = nums.size()*nums[0].size();\\n        vector<vector<long long>> dp(n+1,vector<long long>(k,-1));\\n        return dfs(nums,dp,k,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679978,
                "title": "java-simple-recursive-sol-memoized-clean-code",
                "content": "```\\nclass Solution {\\n    private int MOD = 1_000_000_007;\\n\\n    public int numberOfPaths(int[][] grid, int k) {\\n        if (grid == null || grid.length == 0) return 0;\\n\\n        int m = grid.length, n = grid[0].length;\\n        Integer[][][] dp = new Integer[m + 1][n + 1][k + 1];\\n        \\n        return solve(m - 1, n - 1, grid, k, 0, dp);\\n    }\\n\\n    private int solve(int m, int n, int[][] grid, int k, int sum, Integer[][][] dp) {\\n        if (m < 0 || n < 0) return 0;\\n        if (m == 0 && n == 0) return (sum + grid[0][0]) % k == 0 ? 1 : 0;\\n\\n        \\n        if (dp[m][n][sum % k] != null) return dp[m][n][sum % k];\\n\\n        int top = solve(m - 1, n, grid, k, sum + grid[m][n], dp) % MOD;\\n        int left = solve(m, n - 1, grid, k, sum + grid[m][n], dp) % MOD;\\n\\n        return dp[m][n][sum % k] = (top + left) % MOD;\\n    }\\n}\\n\\n```\\n\\n__Feel free to connect, comment and criticize__ \\uD83E\\uDEE1\\nauthor : [@bharathkalyans](https://leetcode.com/bharathkalyans/)\\nlinkedin : [@bharathkalyans](https://www.linkedin.com/in/bharathkalyans/)\\ntwitter : [@bharathkalyans](https://twitter.com/bharathkalyans)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private int MOD = 1_000_000_007;\\n\\n    public int numberOfPaths(int[][] grid, int k) {\\n        if (grid == null || grid.length == 0) return 0;\\n\\n        int m = grid.length, n = grid[0].length;\\n        Integer[][][] dp = new Integer[m + 1][n + 1][k + 1];\\n        \\n        return solve(m - 1, n - 1, grid, k, 0, dp);\\n    }\\n\\n    private int solve(int m, int n, int[][] grid, int k, int sum, Integer[][][] dp) {\\n        if (m < 0 || n < 0) return 0;\\n        if (m == 0 && n == 0) return (sum + grid[0][0]) % k == 0 ? 1 : 0;\\n\\n        \\n        if (dp[m][n][sum % k] != null) return dp[m][n][sum % k];\\n\\n        int top = solve(m - 1, n, grid, k, sum + grid[m][n], dp) % MOD;\\n        int left = solve(m, n - 1, grid, k, sum + grid[m][n], dp) % MOD;\\n\\n        return dp[m][n][sum % k] = (top + left) % MOD;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679775,
                "title": "simple-3d-dp-iterative-cpp-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        long long dp[n][m][k];\\n        long long mod = 1000000007;\\n        \\n        memset(dp, 0, sizeof(dp));\\n        dp[0][0][grid[0][0]%k] = 1;\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            for(int j = 0; j < m; ++j)\\n            {\\n                if(i == j and i == 0)continue;\\n                \\n                if(i){\\n                    for(int x = 0; x < k; ++x)\\n                    {\\n                        int y = (grid[i][j] + x)%k;\\n                        dp[i][j][y] = (dp[i][j][y] + dp[i-1][j][x]) % mod;\\n                    }\\n                }\\n                \\n                if(j){\\n                    for(int x = 0; x < k; ++x)\\n                    {\\n                        int y = (grid[i][j] + x)%k;\\n                        dp[i][j][y] = (dp[i][j][y] + dp[i][j-1][x]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        long long dp[n][m][k];\\n        long long mod = 1000000007;\\n        \\n        memset(dp, 0, sizeof(dp));\\n        dp[0][0][grid[0][0]%k] = 1;\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            for(int j = 0; j < m; ++j)\\n            {\\n                if(i == j and i == 0)continue;\\n                \\n                if(i){\\n                    for(int x = 0; x < k; ++x)\\n                    {\\n                        int y = (grid[i][j] + x)%k;\\n                        dp[i][j][y] = (dp[i][j][y] + dp[i-1][j][x]) % mod;\\n                    }\\n                }\\n                \\n                if(j){\\n                    for(int x = 0; x < k; ++x)\\n                    {\\n                        int y = (grid[i][j] + x)%k;\\n                        dp[i][j][y] = (dp[i][j][y] + dp[i][j-1][x]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679652,
                "title": "simple-recursion-with-memoization-beats-99-4-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple Recursion with memoization\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint mod=1e9+7;\\nclass Solution {\\npublic:\\n    int cal(int i,int j,int &n,int &m,vector<vector<int>>& grid, int k,int s,vector<vector<vector<int>>>&dp)\\n    {\\n        if(i<0||i==n||j<0||j==m)\\n            return 0;\\n        if(i==n-1&&j==m-1)\\n        {\\n            s=(s%k+(grid[n-1][m-1]%k))%k;\\n            if(s==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        s=(s%k+(grid[i][j]%k))%k;\\n        if(dp[i][j][s]!=-1){\\n           return dp[i][j][s];\\n        }\\n        dp[i][j][s] = (cal(i,j+1,n,m,grid,k,s,dp)%mod+cal(i+1,j,n,m,grid,k,s,dp)%mod)%mod;\\n        return dp[i][j][s];\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(k,-1)));\\n        return cal(0,0,n,m,grid,k,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint mod=1e9+7;\\nclass Solution {\\npublic:\\n    int cal(int i,int j,int &n,int &m,vector<vector<int>>& grid, int k,int s,vector<vector<vector<int>>>&dp)\\n    {\\n        if(i<0||i==n||j<0||j==m)\\n            return 0;\\n        if(i==n-1&&j==m-1)\\n        {\\n            s=(s%k+(grid[n-1][m-1]%k))%k;\\n            if(s==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        s=(s%k+(grid[i][j]%k))%k;\\n        if(dp[i][j][s]!=-1){\\n           return dp[i][j][s];\\n        }\\n        dp[i][j][s] = (cal(i,j+1,n,m,grid,k,s,dp)%mod+cal(i+1,j,n,m,grid,k,s,dp)%mod)%mod;\\n        return dp[i][j][s];\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(k,-1)));\\n        return cal(0,0,n,m,grid,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679498,
                "title": "easy-to-understand-code-c-beginners-friendly-code",
                "content": "long long mod=1e9+7;\\n        int solve(int i, int j, vector<vector < int>> &grid, int k, int sum, int row, int col,vector<vector<vector<int>>>&dp)\\n        {\\n            sum=sum%k;\\n            if(i==row-1 and j==col-1)\\n            {\\n                if((grid[row-1][col-1]+sum)%k==0)\\n                {\\n                    return 1;\\n                }\\n                else\\n                {\\n                    return 0;\\n                }\\n            }\\n            if(i>=row || j>=col)\\n            {\\n                return 0;\\n            }\\n            \\n            if(dp[i][j][sum]!=-1)return dp[i][j][sum];\\n            \\n            int down=solve(i+1,j,grid,k,sum+grid[i][j],row,col,dp);\\n            \\n            int right=solve(i,j+1,grid,k,sum+grid[i][j],row,col,dp);\\n            \\n            return dp[i][j][sum]=(down+right)%mod;\\n            \\n        }\\n\\n    int numberOfPaths(vector<vector < int>> &grid, int k)\\n    {\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        int i = 0;\\n        int j = 0;\\n        \\n    vector<vector<vector<int>>> dp(row , vector<vector<int>>(col , vector<int>(k , -1)));\\n        return solve(i, j, grid, k, 0, row, col,dp);\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "long long mod=1e9+7;\\n        int solve(int i, int j, vector<vector < int>> &grid, int k, int sum, int row, int col,vector<vector<vector<int>>>&dp)\\n        {\\n            sum=sum%k;\\n            if(i==row-1 and j==col-1)\\n            {\\n                if((grid[row-1][col-1]+sum)%k==0)\\n                {\\n                    return 1;\\n                }\\n                else\\n                {\\n                    return 0;\\n                }\\n            }\\n            if(i>=row || j>=col)\\n            {\\n                return 0;\\n            }\\n            \\n            if(dp[i][j][sum]!=-1)return dp[i][j][sum];\\n            \\n            int down=solve(i+1,j,grid,k,sum+grid[i][j],row,col,dp);\\n            \\n            int right=solve(i,j+1,grid,k,sum+grid[i][j],row,col,dp);\\n            \\n            return dp[i][j][sum]=(down+right)%mod;\\n            \\n        }\\n\\n    int numberOfPaths(vector<vector < int>> &grid, int k)\\n    {\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        int i = 0;\\n        int j = 0;\\n        \\n    vector<vector<vector<int>>> dp(row , vector<vector<int>>(col , vector<int>(k , -1)));\\n        return solve(i, j, grid, k, 0, row, col,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2679488,
                "title": "c-simple-3d-dp-solution-top-down-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9+7;\\n\\t\\n    // 3D - DP that stores <i,j,sum%k> \\n\\tvector<vector<vector<int>>> dp;\\n\\t\\n    int topDown(int i, int j, int sum, int &k, vector<vector<int>>& grid){\\n        if(i==grid.size()-1 && j==grid[0].size()-1){\\n            sum += grid[i][j];\\n            if(sum%k==0){\\n                return 1;\\n            }            \\n            return 0;\\n        }\\n\\t\\t\\n        // Invalid cell\\n        if(i==grid.size() || j==grid[0].size()){\\n            return 0;\\n        }\\n        sum = sum%k;\\n        if(dp[i][j][sum] != -1){\\n            return dp[i][j][sum];\\n        }\\n\\t\\t\\n        return dp[i][j][sum] = (topDown(i+1, j, sum+grid[i][j], k, grid)%MOD + topDown(i, j+1, sum+grid[i][j], k, grid)%MOD)%MOD;\\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        dp.resize(grid.size(), vector<vector<int>> (grid[0].size(), vector<int> (k, -1)));\\n        return topDown(0, 0, 0, k, grid);\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9+7;\\n\\t\\n    // 3D - DP that stores <i,j,sum%k> \\n\\tvector<vector<vector<int>>> dp;\\n\\t\\n    int topDown(int i, int j, int sum, int &k, vector<vector<int>>& grid){\\n        if(i==grid.size()-1 && j==grid[0].size()-1){\\n            sum += grid[i][j];\\n            if(sum%k==0){\\n                return 1;\\n            }            \\n            return 0;\\n        }\\n\\t\\t\\n        // Invalid cell\\n        if(i==grid.size() || j==grid[0].size()){\\n            return 0;\\n        }\\n        sum = sum%k;\\n        if(dp[i][j][sum] != -1){\\n            return dp[i][j][sum];\\n        }\\n\\t\\t\\n        return dp[i][j][sum] = (topDown(i+1, j, sum+grid[i][j], k, grid)%MOD + topDown(i, j+1, sum+grid[i][j], k, grid)%MOD)%MOD;\\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        dp.resize(grid.size(), vector<vector<int>> (grid[0].size(), vector<int> (k, -1)));\\n        return topDown(0, 0, 0, k, grid);\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2679162,
                "title": "c-memoization-approach-with-comments",
                "content": "**Please upvote if this helps you.**\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int m, n; \\n    int helper(int i, int j, int currSum, int k,vector<vector<int>>& grid, vector<vector<vector<int>>>& dp) {\\n        if (i == m || j == n) return 0; // base case of out of bounds condition\\n        // checking if the condition of the current calculated sum + the element at 0,0 is satisfied\\n        if (i == m - 1 && j == n - 1) return (((currSum + grid[i][j]) % k) == 0) ? 1 : 0; \\n        // memoization step (used 3-d vector as we have 3 changing variables the calculated sum, i and j)\\n        if (dp[i][j][currSum] != -1) return dp[i][j][currSum];\\n        // recursive call to check for downwards and rightwards direction\\n        return dp[i][j][currSum] = (helper(i + 1, j, (currSum + grid[i][j]) % k, k,grid, dp) +\\n                              helper(i, j + 1, (currSum + grid[i][j]) % k, k, grid, dp)) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        // initializing 3-d vector of m,n,k\\n        vector<vector<vector<int>>> dp(m , vector<vector<int>>(n , vector<int>(k , -1)));\\n        return helper(0, 0, 0, k, grid, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int m, n; \\n    int helper(int i, int j, int currSum, int k,vector<vector<int>>& grid, vector<vector<vector<int>>>& dp) {\\n        if (i == m || j == n) return 0; // base case of out of bounds condition\\n        // checking if the condition of the current calculated sum + the element at 0,0 is satisfied\\n        if (i == m - 1 && j == n - 1) return (((currSum + grid[i][j]) % k) == 0) ? 1 : 0; \\n        // memoization step (used 3-d vector as we have 3 changing variables the calculated sum, i and j)\\n        if (dp[i][j][currSum] != -1) return dp[i][j][currSum];\\n        // recursive call to check for downwards and rightwards direction\\n        return dp[i][j][currSum] = (helper(i + 1, j, (currSum + grid[i][j]) % k, k,grid, dp) +\\n                              helper(i, j + 1, (currSum + grid[i][j]) % k, k, grid, dp)) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        // initializing 3-d vector of m,n,k\\n        vector<vector<vector<int>>> dp(m , vector<vector<int>>(n , vector<int>(k , -1)));\\n        return helper(0, 0, 0, k, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679130,
                "title": "rust-dp-with-comments",
                "content": "This is my unrevised submission for the 2022-10-09 Weekly Contest 314. Count the number of paths with respect to the remainder/modulus of `k` for each DP entry. The sought result is the entry of the bottom-right DP entry with zero remainder. Patch in a single 1 so that it is picked up by the `dp[1][1}` entry to start off the path counting.\\n\\nComment: Surprisingly easy for being the hard problem. I was totally stuck with the third (medium) problem due to TLE, but skipped to this one in the last 15 minutes. \\xAF\\\\_(\\u30C4)_/\\xAF\\n\\n```\\nimpl Solution {\\n    pub fn number_of_paths(grid: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let k = k as usize;\\n        let MOD = 1000000007_usize;\\n        let mut dp = vec![vec![vec![0; k]; n + 1]; m + 1];\\n        dp[0][1][0] = 1;\\n        for i in 1..=m {\\n            for j in 1..=n {\\n                for l in 0..k {\\n                    dp[i][j][(l + grid[i-1][j-1] as usize) % k] = \\n                        ((dp[i][j][(l + grid[i-1][j-1] as usize) % k] + dp[i-1][j][l]) % MOD\\n                        + (dp[i][j][(l + grid[i-1][j-1] as usize) % k] + dp[i][j-1][l]) % MOD) % MOD;\\n                }\\n            }\\n        }\\n        dp[m][n][0] as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn number_of_paths(grid: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let k = k as usize;\\n        let MOD = 1000000007_usize;\\n        let mut dp = vec![vec![vec![0; k]; n + 1]; m + 1];\\n        dp[0][1][0] = 1;\\n        for i in 1..=m {\\n            for j in 1..=n {\\n                for l in 0..k {\\n                    dp[i][j][(l + grid[i-1][j-1] as usize) % k] = \\n                        ((dp[i][j][(l + grid[i-1][j-1] as usize) % k] + dp[i-1][j][l]) % MOD\\n                        + (dp[i][j][(l + grid[i-1][j-1] as usize) % k] + dp[i][j-1][l]) % MOD) % MOD;\\n                }\\n            }\\n        }\\n        dp[m][n][0] as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679118,
                "title": "dynamic-programming-recursion-and-memoization-c",
                "content": "**Recursion**\\n```\\nclass Solution {\\nprivate:\\n    int solve (int row, int col, vector<vector<int>> &grid, int k, int sum) {\\n        if (row < 0 or col < 0) {\\n            return 0;\\n        }\\n        \\n        if (row == 0 and m == 0) {\\n            return (sum + grid[row][col]) % k == 0;\\n        }\\n        \\n        int left = solve(row, col - 1, grid, k, (sum + grid[row][col]) % k);\\n        int top = solve(row - 1, col, grid, k, (sum + grid[row][col]) % k);\\n        \\n        return = (left + top) % int(1e9 + 7);\\n    }\\n    \\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        return solve(n - 1, m - 1, grid, k, 0);\\n    }\\n};\\n```\\n\\n**Memoization**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve (int row, int col, vector<vector<int>> &grid, int k, int sum, vector<vector<vector<int>>> &dp) {\\n        if (row < 0 or col < 0) {\\n            return 0;\\n        }\\n        \\n        if (row == 0 and col == 0) {\\n            return (sum + grid[row][col]) % k == 0;\\n        }\\n        \\n        if (dp[row][col][sum] != -1) {\\n            return dprow][col][sum];\\n        }\\n        \\n        int left = solve(row, col - 1, grid, k, (sum + grid[row][col]) % k, dp);\\n        int top = solve(row - 1, col, grid, k, (sum + grid[row][col]) % k, dp);\\n        \\n        return dp[row][col][sum] = (left + top) % int(1e9 + 7);\\n    }\\n    \\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(k, -1)));\\n        \\n        return solve(n - 1, m - 1, grid, k, 0, dp);\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve (int row, int col, vector<vector<int>> &grid, int k, int sum) {\\n        if (row < 0 or col < 0) {\\n            return 0;\\n        }\\n        \\n        if (row == 0 and m == 0) {\\n            return (sum + grid[row][col]) % k == 0;\\n        }\\n        \\n        int left = solve(row, col - 1, grid, k, (sum + grid[row][col]) % k);\\n        int top = solve(row - 1, col, grid, k, (sum + grid[row][col]) % k);\\n        \\n        return = (left + top) % int(1e9 + 7);\\n    }\\n    \\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        return solve(n - 1, m - 1, grid, k, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve (int row, int col, vector<vector<int>> &grid, int k, int sum, vector<vector<vector<int>>> &dp) {\\n        if (row < 0 or col < 0) {\\n            return 0;\\n        }\\n        \\n        if (row == 0 and col == 0) {\\n            return (sum + grid[row][col]) % k == 0;\\n        }\\n        \\n        if (dp[row][col][sum] != -1) {\\n            return dprow][col][sum];\\n        }\\n        \\n        int left = solve(row, col - 1, grid, k, (sum + grid[row][col]) % k, dp);\\n        int top = solve(row - 1, col, grid, k, (sum + grid[row][col]) % k, dp);\\n        \\n        return dp[row][col][sum] = (left + top) % int(1e9 + 7);\\n    }\\n    \\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(k, -1)));\\n        \\n        return solve(n - 1, m - 1, grid, k, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679109,
                "title": "simple-c-dp-solution-similar-to-unique-paths-recursion-memoization",
                "content": "```\\nclass Solution {\\nprivate:\\n    int mod=1e9+7;\\n    long long func(int i,int j,int x,vector<vector<int>>& grid,int k,vector<vector<vector<int>>> &dp) {\\n        if (i==0&&j==0) {\\n            if ((x+grid[0][0])%k) return 0;\\n            return 1;\\n        }\\n        if (i<0||j<0) return 0;\\n        if (dp[i][j][x]!=-1) return dp[i][j][x];\\n        return dp[i][j][x]=(func(i-1,j,(x+grid[i][j])%k,grid,k,dp)+func(i,j-1,(x+grid[i][j])%k,grid,k,dp))%mod;\\n    }\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        vector<vector<vector<int>>> dp(grid.size()+1,vector<vector<int>>(grid[0].size()+1,vector<int>(k+1,-1)));\\n        return (func(grid.size()-1,grid[0].size()-1,0,grid,k,dp))%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int mod=1e9+7;\\n    long long func(int i,int j,int x,vector<vector<int>>& grid,int k,vector<vector<vector<int>>> &dp) {\\n        if (i==0&&j==0) {\\n            if ((x+grid[0][0])%k) return 0;\\n            return 1;\\n        }\\n        if (i<0||j<0) return 0;\\n        if (dp[i][j][x]!=-1) return dp[i][j][x];\\n        return dp[i][j][x]=(func(i-1,j,(x+grid[i][j])%k,grid,k,dp)+func(i,j-1,(x+grid[i][j])%k,grid,k,dp))%mod;\\n    }\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        vector<vector<vector<int>>> dp(grid.size()+1,vector<vector<int>>(grid[0].size()+1,vector<int>(k+1,-1)));\\n        return (func(grid.size()-1,grid[0].size()-1,0,grid,k,dp))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679090,
                "title": "amazing-dp-python-solution",
                "content": "```\\ndef numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n\\tm = len(grid)\\n\\tn = len(grid[0])\\n\\tdp = []\\n\\t\\n\\tdef transfer(dct1,dct2,num):\\n\\t\\tnewDct = {}\\n\\t\\tfor key in dct1:\\n\\t\\t\\tnewDct[(key+num)%k] = dct1[key]\\n\\t\\tif dct2:\\n\\t\\t\\tfor key in dct2:\\n\\t\\t\\t\\tif (key+num)%k in newDct:\\n\\t\\t\\t\\t\\tnewDct[(key+num)%k] += dct2[key]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnewDct[(key+num)%k] = dct2[key]\\n\\t\\treturn newDct\\n\\t\\t\\n\\tfor i in range(m):\\n\\t\\tdp.append([])\\n\\t\\tif i == 0:\\n\\t\\t\\tdp[0].append({grid[0][0]%k:1})\\n\\t\\tfor j in range(i==0,n):\\n\\t\\t\\tif i == 0:\\n\\t\\t\\t\\tdp[i].append(transfer(dp[i][j-1],None,grid[i][j]))\\n\\t\\t\\telif j == 0:\\n\\t\\t\\t\\tdp[i].append(transfer(dp[i-1][j],None,grid[i][j]))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp[i].append(transfer(dp[i-1][j],dp[i][j-1],grid[i][j])) \\n\\tif 0 not in dp[-1][-1]:\\n\\t\\treturn 0\\n\\treturn dp[-1][-1][0] % (10**9+7)\\n```\\nThe idea of this solution is that ```dp[i][j]``` will be a dictionary which keeps track of the remainder of the sums of the paths up to that point mod k. The keys are the remainders and the value correspond to how many of them there are! The ```transfer``` helper method helps us construct the new values for ```dp[i][j]``` from ```dp[i-1][j]``` and ```dp[i][j-1]```.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n\\tm = len(grid)\\n\\tn = len(grid[0])\\n\\tdp = []\\n\\t\\n\\tdef transfer(dct1,dct2,num):\\n\\t\\tnewDct = {}\\n\\t\\tfor key in dct1:\\n\\t\\t\\tnewDct[(key+num)%k] = dct1[key]\\n\\t\\tif dct2:\\n\\t\\t\\tfor key in dct2:\\n\\t\\t\\t\\tif (key+num)%k in newDct:\\n\\t\\t\\t\\t\\tnewDct[(key+num)%k] += dct2[key]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnewDct[(key+num)%k] = dct2[key]\\n\\t\\treturn newDct\\n\\t\\t\\n\\tfor i in range(m):\\n\\t\\tdp.append([])\\n\\t\\tif i == 0:\\n\\t\\t\\tdp[0].append({grid[0][0]%k:1})\\n\\t\\tfor j in range(i==0,n):\\n\\t\\t\\tif i == 0:\\n\\t\\t\\t\\tdp[i].append(transfer(dp[i][j-1],None,grid[i][j]))\\n\\t\\t\\telif j == 0:\\n\\t\\t\\t\\tdp[i].append(transfer(dp[i-1][j],None,grid[i][j]))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp[i].append(transfer(dp[i-1][j],dp[i][j-1],grid[i][j])) \\n\\tif 0 not in dp[-1][-1]:\\n\\t\\treturn 0\\n\\treturn dp[-1][-1][0] % (10**9+7)\\n```\n```dp[i][j]```\n```transfer```\n```dp[i][j]```\n```dp[i-1][j]```\n```dp[i][j-1]```",
                "codeTag": "Python3"
            },
            {
                "id": 2679025,
                "title": "rust-dp",
                "content": "```\\nimpl Solution {\\n    pub fn number_of_paths(grid: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let (m,n) = (grid.len(), grid[0].len());\\n        let k = k as usize;\\n        let modulo = 1_000_000_007;\\n        \\n        let mut dp = vec![vec![vec![0;k]; n]; m];\\n        dp[0][0][grid[0][0] as usize % k] = 1;\\n        \\n        let mut result = 0;\\n        \\n        for i in 0..m {\\n            for j in 0..n {\\n                if i > 0 {\\n                    for m in 0..dp[i-1][j].len() {\\n                        if dp[i-1][j][m] > 0 {\\n                            let sum_mod = (m + grid[i][j] as usize) % k;\\n                            \\n                            dp[i][j][sum_mod] = (dp[i][j][sum_mod] + dp[i-1][j][m]) % modulo;\\n                        }\\n                    }\\n                }\\n                if j > 0 {\\n                    for m in 0..dp[i][j-1].len() {                        \\n                        if dp[i][j-1][m] > 0 {\\n                            let sum_mod = (m + grid[i][j] as usize) % k;\\n                            \\n                            dp[i][j][sum_mod] = (dp[i][j][sum_mod] + dp[i][j-1][m]) % modulo;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1][0] as i32;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn number_of_paths(grid: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let (m,n) = (grid.len(), grid[0].len());\\n        let k = k as usize;\\n        let modulo = 1_000_000_007;\\n        \\n        let mut dp = vec![vec![vec![0;k]; n]; m];\\n        dp[0][0][grid[0][0] as usize % k] = 1;\\n        \\n        let mut result = 0;\\n        \\n        for i in 0..m {\\n            for j in 0..n {\\n                if i > 0 {\\n                    for m in 0..dp[i-1][j].len() {\\n                        if dp[i-1][j][m] > 0 {\\n                            let sum_mod = (m + grid[i][j] as usize) % k;\\n                            \\n                            dp[i][j][sum_mod] = (dp[i][j][sum_mod] + dp[i-1][j][m]) % modulo;\\n                        }\\n                    }\\n                }\\n                if j > 0 {\\n                    for m in 0..dp[i][j-1].len() {                        \\n                        if dp[i][j-1][m] > 0 {\\n                            let sum_mod = (m + grid[i][j] as usize) % k;\\n                            \\n                            dp[i][j][sum_mod] = (dp[i][j][sum_mod] + dp[i][j-1][m]) % modulo;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1][0] as i32;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679006,
                "title": "c-bottom-up-dp-space-optimized",
                "content": "```\\nclass Solution {\\n    const int mod = 1e9+7;\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        auto dp = new int*[n];\\n        auto dptmp = new int*[n];\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = new int[k];\\n            fill_n(dp[i], k, 0);\\n            dptmp[i] = new int[k];\\n            fill_n(dptmp[i], k, 0);\\n        }\\n        \\n        dptmp[0][grid[0][0]%k] = 1;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int prevR = 0; prevR < k; prevR++) {\\n                    int curR = (prevR+grid[i][j])%k;  // iterate all prevR to enumerate all curR\\n                    if (i) dptmp[j][curR] = (dptmp[j][r]+dp[j][prevR])%mod;\\n                    if (j) dptmp[j][curR] = (dptmp[j][r]+dptmp[j-1][prevR])%mod;\\n                }\\n            }\\n            swap(dp, dptmp);\\n            for (int c = 0; c < n; c++) {\\n                fill_n(dptmp[c], k, 0);\\n            }\\n        }\\n        \\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int mod = 1e9+7;\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        auto dp = new int*[n];\\n        auto dptmp = new int*[n];\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = new int[k];\\n            fill_n(dp[i], k, 0);\\n            dptmp[i] = new int[k];\\n            fill_n(dptmp[i], k, 0);\\n        }\\n        \\n        dptmp[0][grid[0][0]%k] = 1;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int prevR = 0; prevR < k; prevR++) {\\n                    int curR = (prevR+grid[i][j])%k;  // iterate all prevR to enumerate all curR\\n                    if (i) dptmp[j][curR] = (dptmp[j][r]+dp[j][prevR])%mod;\\n                    if (j) dptmp[j][curR] = (dptmp[j][r]+dptmp[j-1][prevR])%mod;\\n                }\\n            }\\n            swap(dp, dptmp);\\n            for (int c = 0; c < n; c++) {\\n                fill_n(dptmp[c], k, 0);\\n            }\\n        }\\n        \\n        return dp[n-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679004,
                "title": "python-3-dp-memoize-the-count-of-path-sum-remainder-o-m-n-k",
                "content": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        dp = [[None for j in range(n)] for i in range(m)]\\n        tmp = [0] * k\\n        tmp[grid[0][0] % k] = 1\\n        dp[0][0] = tmp\\n        for i in range(m):\\n            for j in range(n):\\n                if i == 0 and j == 0:\\n                    continue\\n                tmp = [0] * k\\n                for r in range(k):\\n                    a = dp[i - 1][j][r] if i > 0 else 0\\n                    b = dp[i][j - 1][r] if j > 0 else 0\\n                    tmp[(r + grid[i][j]) % k] = a + b\\n                dp[i][j] = tmp\\n        \\n        return dp[m - 1][n - 1][0] % (10 ** 9 + 7)\\n                \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        dp = [[None for j in range(n)] for i in range(m)]\\n        tmp = [0] * k\\n        tmp[grid[0][0] % k] = 1\\n        dp[0][0] = tmp\\n        for i in range(m):\\n            for j in range(n):\\n                if i == 0 and j == 0:\\n                    continue\\n                tmp = [0] * k\\n                for r in range(k):\\n                    a = dp[i - 1][j][r] if i > 0 else 0\\n                    b = dp[i][j - 1][r] if j > 0 else 0\\n                    tmp[(r + grid[i][j]) % k] = a + b\\n                dp[i][j] = tmp\\n        \\n        return dp[m - 1][n - 1][0] % (10 ** 9 + 7)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678961,
                "title": "c-easy-solution-using-3d-dp-time-o-n-m-k-space-o-n-m-k",
                "content": "**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int call(vector<vector<int>> &a,int n,int m,int sum,int tar,vector<vector<vector<int>>> &dp){\\n        \\n        if(n<0||m<0) return 0;\\n        \\n        sum += a[n][m];\\n        sum %= tar;\\n        \\n        if(n==0&&m==0){\\n            if(sum==0) return 1;\\n            return 0;\\n        }\\n        if(dp[n][m][sum]!=-1) return dp[n][m][sum];\\n        \\n        long long mod = 1e9+7,res1;\\n        \\n        res1 = call(a,n-1,m,sum,tar,dp);\\n        res1 += call(a,n,m-1,sum,tar,dp);\\n        res1 %= mod;\\n        \\n        dp[n][m][sum] = res1;\\n        \\n        return res1;\\n        \\n        \\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& a, int tar) {\\n        \\n        int n = a.size() , m = a[0].size() ;\\n        \\n        vector<vector<vector<int>>> dp(n,vector<vector<int>> (m,vector<int> (tar,-1)));\\n        \\n        int ans = call(a,n-1,m-1,0,tar,dp);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int call(vector<vector<int>> &a,int n,int m,int sum,int tar,vector<vector<vector<int>>> &dp){\\n        \\n        if(n<0||m<0) return 0;\\n        \\n        sum += a[n][m];\\n        sum %= tar;\\n        \\n        if(n==0&&m==0){\\n            if(sum==0) return 1;\\n            return 0;\\n        }\\n        if(dp[n][m][sum]!=-1) return dp[n][m][sum];\\n        \\n        long long mod = 1e9+7,res1;\\n        \\n        res1 = call(a,n-1,m,sum,tar,dp);\\n        res1 += call(a,n,m-1,sum,tar,dp);\\n        res1 %= mod;\\n        \\n        dp[n][m][sum] = res1;\\n        \\n        return res1;\\n        \\n        \\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& a, int tar) {\\n        \\n        int n = a.size() , m = a[0].size() ;\\n        \\n        vector<vector<vector<int>>> dp(n,vector<vector<int>> (m,vector<int> (tar,-1)));\\n        \\n        int ans = call(a,n-1,m-1,0,tar,dp);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678895,
                "title": "c-dp-memoization-self-understood",
                "content": "# class Solution {\\n# public:\\n    const int mod=1e9+7;\\n    int solve(vector<vector<int>> &grid,int sum,int k,int n,int m,vector<vector<vector<int>>> &dp){\\n        if(m<0 || n<0)\\n            return 0;\\n        if(m==0 && n==0){\\n            if((sum+grid[n][m])%k==0)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        if(dp[n][m][sum]!=-1){\\n            return dp[n][m][sum];\\n        }\\n        int a=solve(grid,(sum+grid[n][m])%k,k,n-1,m,dp);\\n        int b=solve(grid,(sum+grid[n][m])%k,k,n,m-1,dp);\\n        return dp[n][m][sum]=(a+b)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size(),m=grid[0].size();\\n        int sum=0;\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(k,-1)));\\n        return solve(grid,sum,k,n-1,m-1,dp);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n# public:\\n    const int mod=1e9+7;\\n    int solve(vector<vector<int>> &grid,int sum,int k,int n,int m,vector<vector<vector<int>>> &dp){\\n        if(m<0 || n<0)\\n            return 0;\\n        if(m==0 && n==0){\\n            if((sum+grid[n][m])%k==0)\\n                return 1;\\n            else\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2678883,
                "title": "o-n-m-k-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]%=k;          \\n            }\\n        }\\n        map<pair<int,int> , vector<int>>mp;\\n        vector<int>f(k);\\n        f[grid[0][0]]++;\\n        mp[{0,0}] = f;\\n        for(int i=1;i<grid[0].size();i++){\\n            grid[0][i]+= grid[0][i-1];\\n            grid[0][i]%=k;\\n            vector<int>v(k);\\n            v[grid[0][i]]++;\\n            mp[{0,i}] = v;\\n        }\\n        for(int i=1;i<grid.size();i++){\\n            grid[i][0]+= grid[i-1][0];\\n            grid[i][0]%=k;\\n             vector<int>v(k);\\n            v[grid[i][0]]++;\\n            mp[{i,0}] = v;\\n        }\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=1;j<grid[0].size();j++){\\n                vector<int>v(k);\\n                vector<int>v1 = mp[{i-1,j}];\\n                for(int l=0;l<k;l++){\\n                    if(v1[l] > 0){\\n                        v[(grid[i][j]+l)%k] = (v[(grid[i][j]+l)%k]+v1[l])%mod;\\n                    }\\n                }\\n             \\n                v1 = mp[{i,j-1}];\\n\\n                for(int l=0;l<k;l++){\\n                    if(v1[l] > 0){\\n                        v[(grid[i][j]+l)%k] = (v[(grid[i][j]+l)%k] + v1[l])%mod;\\n                    }\\n                }\\n                mp[{i,j}] = v;\\n            }\\n        }\\n  \\n        int n = grid.size() , m = grid[0].size();\\n        vector<int>v = mp[{n-1,m-1}];\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]%=k;          \\n            }\\n        }\\n        map<pair<int,int> , vector<int>>mp;\\n        vector<int>f(k);\\n        f[grid[0][0]]++;\\n        mp[{0,0}] = f;\\n        for(int i=1;i<grid[0].size();i++){\\n            grid[0][i]+= grid[0][i-1];\\n            grid[0][i]%=k;\\n            vector<int>v(k);\\n            v[grid[0][i]]++;\\n            mp[{0,i}] = v;\\n        }\\n        for(int i=1;i<grid.size();i++){\\n            grid[i][0]+= grid[i-1][0];\\n            grid[i][0]%=k;\\n             vector<int>v(k);\\n            v[grid[i][0]]++;\\n            mp[{i,0}] = v;\\n        }\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=1;j<grid[0].size();j++){\\n                vector<int>v(k);\\n                vector<int>v1 = mp[{i-1,j}];\\n                for(int l=0;l<k;l++){\\n                    if(v1[l] > 0){\\n                        v[(grid[i][j]+l)%k] = (v[(grid[i][j]+l)%k]+v1[l])%mod;\\n                    }\\n                }\\n             \\n                v1 = mp[{i,j-1}];\\n\\n                for(int l=0;l<k;l++){\\n                    if(v1[l] > 0){\\n                        v[(grid[i][j]+l)%k] = (v[(grid[i][j]+l)%k] + v1[l])%mod;\\n                    }\\n                }\\n                mp[{i,j}] = v;\\n            }\\n        }\\n  \\n        int n = grid.size() , m = grid[0].size();\\n        vector<int>v = mp[{n-1,m-1}];\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678876,
                "title": "python-dp-memoization-o-n-m-k",
                "content": "```\\nMOD = 10 ** 9 + 7\\nclass Solution:\\n    def panda(self, n, m, grid, rs, k, dp):\\n        if n < 0 or m < 0:\\n            return 0\\n\\n        rs += grid[n][m]\\n        \\n        if not n and not m:\\n            if not rs % k:\\n                return 1\\n            return 0\\n        \\n        if dp[n][m][rs % k] != -1:\\n            return dp[n][m][rs % k]\\n        \\n        c1 = self.panda(n - 1, m, grid, rs, k, dp)\\n        c2 = self.panda(n, m - 1, grid, rs, k, dp)\\n        \\n        dp[n][m][rs % k] = (c1 + c2) % MOD\\n        return dp[n][m][rs % k]\\n        \\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        n, m = len(grid), len(grid[0])\\n        dp = [[[-1 for i in range(k + 1)] for j in range(m + 1)] for j1 in range(n + 1)]\\n        ans = self.panda(n - 1, m - 1, grid, 0, k, dp)\\n        return ans\\n```\\n\\nTime Complexity : O(n*m*k)",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nMOD = 10 ** 9 + 7\\nclass Solution:\\n    def panda(self, n, m, grid, rs, k, dp):\\n        if n < 0 or m < 0:\\n            return 0\\n\\n        rs += grid[n][m]\\n        \\n        if not n and not m:\\n            if not rs % k:\\n                return 1\\n            return 0\\n        \\n        if dp[n][m][rs % k] != -1:\\n            return dp[n][m][rs % k]\\n        \\n        c1 = self.panda(n - 1, m, grid, rs, k, dp)\\n        c2 = self.panda(n, m - 1, grid, rs, k, dp)\\n        \\n        dp[n][m][rs % k] = (c1 + c2) % MOD\\n        return dp[n][m][rs % k]\\n        \\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        n, m = len(grid), len(grid[0])\\n        dp = [[[-1 for i in range(k + 1)] for j in range(m + 1)] for j1 in range(n + 1)]\\n        ans = self.panda(n - 1, m - 1, grid, 0, k, dp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678840,
                "title": "java-dp-solution-o-m-n-k",
                "content": "```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int kk) {\\n        //keep number of ways you can reach each position with sum for each possible remainder (0<=remainder<k)\\n        //we added extra space for each dimention to avoid handling edge cases\\n        int[][][] dp = new int[grid.length+1][grid[0].length+1][kk];\\n        \\n        //initialize for position (0,0)\\n        dp[1][1][grid[0][0] % kk] = 1;\\n        \\n        for(int i = 1; i <= grid.length; i++) {\\n            for(int j = 1; j <= grid[0].length; j++) {\\n                for(int k = 0; k < kk; k++) {\\n                    //calculate count for each cell in dp based in value and the grid and previously calculated dp values to the cell to the left and cell to the up\\n                    dp[i][j][(grid[i-1][j-1] + k) % kk] = (dp[i][j][(grid[i-1][j-1] + k) % kk] + dp[i-1][j][k] + dp[i][j-1][k]) % 1_000_000_007;\\n                }\\n            }\\n        }\\n        \\n        //number of ways to reach last cell with remainder 0\\n        return dp[grid.length][grid[0].length][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int kk) {\\n        //keep number of ways you can reach each position with sum for each possible remainder (0<=remainder<k)\\n        //we added extra space for each dimention to avoid handling edge cases\\n        int[][][] dp = new int[grid.length+1][grid[0].length+1][kk];\\n        \\n        //initialize for position (0,0)\\n        dp[1][1][grid[0][0] % kk] = 1;\\n        \\n        for(int i = 1; i <= grid.length; i++) {\\n            for(int j = 1; j <= grid[0].length; j++) {\\n                for(int k = 0; k < kk; k++) {\\n                    //calculate count for each cell in dp based in value and the grid and previously calculated dp values to the cell to the left and cell to the up\\n                    dp[i][j][(grid[i-1][j-1] + k) % kk] = (dp[i][j][(grid[i-1][j-1] + k) % kk] + dp[i-1][j][k] + dp[i][j-1][k]) % 1_000_000_007;\\n                }\\n            }\\n        }\\n        \\n        //number of ways to reach last cell with remainder 0\\n        return dp[grid.length][grid[0].length][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678815,
                "title": "3d-recursive-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint dirR[2] = {0,1};\\n\\tint dirC[2] = {1,0};\\n\\tlong long MOD = 1e9+7;\\n    \\n\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\tvector<vector<vector<int>>>dp(grid.size(), vector<vector<int>>(grid[0].size(), vector<int>(k,-1)));\\n\\t\\treturn getAnswer(0,0,0,grid,k, dp);\\n    }\\n\\n\\tint getAnswer(int r, int c, int sum, vector<vector<int>>& grid, int k, vector<vector<vector<int>>>&dp)\\n\\t{\\n\\t\\tif(r<0 || c<0 || r>=grid.size() || c>=grid[0].size())\\n\\t\\t\\treturn 0;\\n\\t\\tif(r == grid.size()-1 && c == grid[r].size()-1)\\n\\t\\t{\\n\\t\\t\\treturn (sum+grid[r][c])%k == 0;\\n\\t\\t}\\n\\n\\t\\tif(dp[r][c][sum]!=-1)\\n\\t\\t\\treturn dp[r][c][sum];\\n\\n\\t\\tint cnt = 0;\\n\\n\\t\\tfor(int i=0;i<2;i++)\\n\\t\\t{\\n\\t\\t\\tcnt += getAnswer(r+dirR[i], c+dirC[i], (sum+grid[r][c])%k, grid, k, dp);\\n\\t\\t\\tcnt%=MOD;\\n\\t\\t}\\n\\n\\t\\treturn dp[r][c][sum] = cnt;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint dirR[2] = {0,1};\\n\\tint dirC[2] = {1,0};\\n\\tlong long MOD = 1e9+7;\\n    \\n\\tint numberOfPaths(vector<vector<int>>& grid, int k) {\\n\\t\\tvector<vector<vector<int>>>dp(grid.size(), vector<vector<int>>(grid[0].size(), vector<int>(k,-1)));\\n\\t\\treturn getAnswer(0,0,0,grid,k, dp);\\n    }\\n\\n\\tint getAnswer(int r, int c, int sum, vector<vector<int>>& grid, int k, vector<vector<vector<int>>>&dp)\\n\\t{\\n\\t\\tif(r<0 || c<0 || r>=grid.size() || c>=grid[0].size())\\n\\t\\t\\treturn 0;\\n\\t\\tif(r == grid.size()-1 && c == grid[r].size()-1)\\n\\t\\t{\\n\\t\\t\\treturn (sum+grid[r][c])%k == 0;\\n\\t\\t}\\n\\n\\t\\tif(dp[r][c][sum]!=-1)\\n\\t\\t\\treturn dp[r][c][sum];\\n\\n\\t\\tint cnt = 0;\\n\\n\\t\\tfor(int i=0;i<2;i++)\\n\\t\\t{\\n\\t\\t\\tcnt += getAnswer(r+dirR[i], c+dirC[i], (sum+grid[r][c])%k, grid, k, dp);\\n\\t\\t\\tcnt%=MOD;\\n\\t\\t}\\n\\n\\t\\treturn dp[r][c][sum] = cnt;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678808,
                "title": "detailed-video-explanation",
                "content": "https://youtu.be/Spd4gOuJPBU\\n\\nPlease subscrive if you find this channel useful. :)",
                "solutionTags": [],
                "code": "https://youtu.be/Spd4gOuJPBU\\n\\nPlease subscrive if you find this channel useful. :)",
                "codeTag": "Unknown"
            },
            {
                "id": 4061157,
                "title": "java-solution-bottom-up-approach",
                "content": "\\nclass Solution {\\n  public int numberOfPaths(int[][] grid, int k) {\\n    final int kMod = 1_000_000_007;\\n    final int m = grid.length;\\n    final int n = grid[0].length;\\n    // dp[i][j][sum] := # of paths till (i, j) where the sum divide by k == sum\\n    int[][][] dp = new int[m][n][k];\\n    dp[0][0][grid[0][0] % k] = 1;\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        for (int sum = 0; sum < k; ++sum) {\\n          final int newSum = (sum + grid[i][j]) % k;\\n          if (i > 0)\\n            dp[i][j][newSum] += dp[i - 1][j][sum];\\n          if (j > 0)\\n            dp[i][j][newSum] += dp[i][j - 1][sum];\\n          dp[i][j][newSum] %= kMod;\\n        }\\n\\n    return dp[m - 1][n - 1][0];\\n  }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n  public int numberOfPaths(int[][] grid, int k) {\\n    final int kMod = 1_000_000_007;\\n    final int m = grid.length;\\n    final int n = grid[0].length;\\n    // dp[i][j][sum] := # of paths till (i, j) where the sum divide by k == sum\\n    int[][][] dp = new int[m][n][k];\\n    dp[0][0][grid[0][0] % k] = 1;\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        for (int sum = 0; sum < k; ++sum) {\\n          final int newSum = (sum + grid[i][j]) % k;\\n          if (i > 0)\\n            dp[i][j][newSum] += dp[i - 1][j][sum];\\n          if (j > 0)\\n            dp[i][j][newSum] += dp[i][j - 1][sum];\\n          dp[i][j][newSum] %= kMod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4045974,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    int mod = 1000000007;\\n    vector<vector<vector<int>>>dp;\\n    int solve(vector<vector<int>>& arr,int k,int x,int y,int d){\\n        if(x == n-1 && y == m-1)\\n            return dp[x][y][d] = (d + arr[x][y])%k==0;\\n        if(x >= n || y >= m)\\n            return 0;\\n        if(dp[x][y][d] != -1)\\n            return dp[x][y][d];\\n        int down = solve(arr,k,x+1,y,(d + arr[x][y])%k)%mod;\\n        int right = solve(arr,k,x,y+1,(d + arr[x][y])%k)%mod;\\n        return dp[x][y][d] = (down + right)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dp = vector<vector<vector<int>>>(n,vector<vector<int>>(m,vector<int>(k,-1)));\\n        return solve(grid,k,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    int mod = 1000000007;\\n    vector<vector<vector<int>>>dp;\\n    int solve(vector<vector<int>>& arr,int k,int x,int y,int d){\\n        if(x == n-1 && y == m-1)\\n            return dp[x][y][d] = (d + arr[x][y])%k==0;\\n        if(x >= n || y >= m)\\n            return 0;\\n        if(dp[x][y][d] != -1)\\n            return dp[x][y][d];\\n        int down = solve(arr,k,x+1,y,(d + arr[x][y])%k)%mod;\\n        int right = solve(arr,k,x,y+1,(d + arr[x][y])%k)%mod;\\n        return dp[x][y][d] = (down + right)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dp = vector<vector<vector<int>>>(n,vector<vector<int>>(m,vector<int>(k,-1)));\\n        return solve(grid,k,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039420,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int n,m;\\n  int mod;\\n    int rec(int x,int y,vector<vector<int>>& grid, int k,int sum,vector<vector<vector<int>>>&dp)\\n    {\\n      if (x==n-1 && y==m-1) \\n      {\\n        if ((sum+grid[x][y])%k==0) return 1;\\n        return 0;\\n      }\\n      if (dp[x][y][sum]!=-1) return dp[x][y][sum];\\n      int sum1=0,sum2=0;\\n      if (x+1<n)\\n      sum1=rec(x+1,y,grid,k,(sum+grid[x][y])%k,dp);\\n      if (y+1<m)\\n      sum2=rec(x,y+1,grid,k,(sum+grid[x][y])%k,dp);\\n      return dp[x][y][sum]=(sum1%mod+sum2%mod)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) \\n    {\\n        n=grid.size();\\n        m=grid[0].size();\\n        mod=1e9+7;\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(k+1,-1)));\\n        return rec(0,0,grid,k,0,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int n,m;\\n  int mod;\\n    int rec(int x,int y,vector<vector<int>>& grid, int k,int sum,vector<vector<vector<int>>>&dp)\\n    {\\n      if (x==n-1 && y==m-1) \\n      {\\n        if ((sum+grid[x][y])%k==0) return 1;\\n        return 0;\\n      }\\n      if (dp[x][y][sum]!=-1) return dp[x][y][sum];\\n      int sum1=0,sum2=0;\\n      if (x+1<n)\\n      sum1=rec(x+1,y,grid,k,(sum+grid[x][y])%k,dp);\\n      if (y+1<m)\\n      sum2=rec(x,y+1,grid,k,(sum+grid[x][y])%k,dp);\\n      return dp[x][y][sum]=(sum1%mod+sum2%mod)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) \\n    {\\n        n=grid.size();\\n        m=grid[0].size();\\n        mod=1e9+7;\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(k+1,-1)));\\n        return rec(0,0,grid,k,0,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012436,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> a;\\n    int k,m,n;\\n    int mod=1e9+7;\\n\\n    int f(int i, int j, int modsum,vector<vector<vector<int>>> &dp) {\\n        if(i==m||j==n)return 0;\\n        if(i==m-1 && j==n-1){\\n            if((a[i][j]+modsum)%k==0)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][j][modsum]!=-1)return dp[i][j][modsum];\\n\\n        int s1=f(i+1,j,(a[i][j]+modsum)%k,dp);\\n        int s2=f(i,j+1,(a[i][j]+modsum)%k,dp);\\n\\n        return dp[i][j][modsum] = (s1%mod+s2%mod)%mod;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& _a, int _k) {\\n        k=_k;\\n        a=_a;\\n        m=a.size(),n=a[0].size();\\n        vector<vector<vector<int>>>dp(m+1,vector<vector<int>>(n+1,vector<int>(k+1,-1)));\\n        return f(0,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> a;\\n    int k,m,n;\\n    int mod=1e9+7;\\n\\n    int f(int i, int j, int modsum,vector<vector<vector<int>>> &dp) {\\n        if(i==m||j==n)return 0;\\n        if(i==m-1 && j==n-1){\\n            if((a[i][j]+modsum)%k==0)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][j][modsum]!=-1)return dp[i][j][modsum];\\n\\n        int s1=f(i+1,j,(a[i][j]+modsum)%k,dp);\\n        int s2=f(i,j+1,(a[i][j]+modsum)%k,dp);\\n\\n        return dp[i][j][modsum] = (s1%mod+s2%mod)%mod;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& _a, int _k) {\\n        k=_k;\\n        a=_a;\\n        m=a.size(),n=a[0].size();\\n        vector<vector<vector<int>>>dp(m+1,vector<vector<int>>(n+1,vector<int>(k+1,-1)));\\n        return f(0,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006734,
                "title": "dynamic-programming-in-grid-traversa-l-easy-approach-3d",
                "content": "# Intuition\\nThe problem can be solved using dynamic programming with memoization. We want to find the number of paths from the top-left corner to the bottom-right corner of a grid such that the sum of values along the path is divisible by `k`. We can move only right or down in the grid.\\n\\n# Approach\\n1. We define a 3D memoization table `dp` to store the number of paths for each state `(row, col, currentSum)`.\\n\\n2. We create an array `DIRECTIONS` to represent the possible moves (right and down) for the agents.\\n\\n3. The base case for the recursion is when we reach the bottom-right corner. If the `currentSum` (sum of values along the path) is divisible by `k`, we return 1 (indicating a valid path), otherwise, we return 0.\\n\\n4. If the current state `(row, col, currentSum)` has already been memoized, we return the stored result.\\n\\n5. We initialize a variable `pathCount` to store the number of valid paths for the current state and set it to 0.\\n\\n6. We iterate through the possible moves (right and down) and check if the new position `(newRow, newCol)` is within the grid boundaries.\\n\\n7. If the move is valid, we calculate the new sum `newSum` by adding the value at the current position to `currentSum`. We then recursively call the `countPaths` function for the new position `(newRow, newCol, newSum)`.\\n\\n8. We update `pathCount` by adding the number of valid paths obtained from the recursive calls.\\n\\n9. Finally, we store the result in the memoization table `dp` and return it.\\n\\n10. In the `numberOfPaths` function, we initialize the memoization table, start the recursion from the top-left corner `(0, 0, 0)`, and return the result modulo `MOD`.\\n\\n# Complexity\\n- Time complexity: O(n * m * k), where n is the number of rows, m is the number of columns, and k is the given number. Each state `(row, col, currentSum)` requires O(1) computation, and there are O(n * m * k) such states.\\n- Space complexity: O(n * m * k) for the memoization table `dp`.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9 + 7;\\n    const int DIRECTIONS[2][2] = {{1, 0}, {0, 1}};\\n\\n    int countPaths(vector<vector<int>>& grid, int row, int col, long long currentSum, int k, vector<vector<vector<int>>>& dp) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // Base case: Reached the bottom-right corner\\n        if (row == n - 1 && col == m - 1) {\\n            if ((currentSum + grid[row][col]) % k == 0) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n\\n        // If this state has been memoized, return the result\\n        if (dp[row][col][currentSum] != -1) {\\n            return dp[row][col][currentSum];\\n        }\\n\\n        int pathCount = 0;\\n        for (int i = 0; i < 2; i++) {\\n            int newRow = row + DIRECTIONS[i][0];\\n            int newCol = col + DIRECTIONS[i][1];\\n\\n            // Check if the new position is within the grid boundaries\\n            if (newRow < n && newCol < m) {\\n                long long newSum = (currentSum + grid[row][col]) % k;\\n                pathCount = (pathCount + countPaths(grid, newRow, newCol, newSum, k, dp)) % MOD;\\n            }\\n        }\\n\\n        // Store the result in the memoization table and return\\n        return dp[row][col][currentSum] = pathCount % MOD;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(k, -1)));\\n        int ans = countPaths(grid, 0, 0, 0, k, dp);\\n        return ans % MOD;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    const int MOD = 1e9 + 7;\\n    const int DIRECTIONS[2][2] = {{1, 0}, {0, 1}};\\n\\n    int countPaths(vector<vector<int>>& grid, int row, int col, long long currentSum, int k, vector<vector<vector<int>>>& dp) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // Base case: Reached the bottom-right corner\\n        if (row == n - 1 && col == m - 1) {\\n            if ((currentSum + grid[row][col]) % k == 0) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n\\n        // If this state has been memoized, return the result\\n        if (dp[row][col][currentSum] != -1) {\\n            return dp[row][col][currentSum];\\n        }\\n\\n        int pathCount = 0;\\n        for (int i = 0; i < 2; i++) {\\n            int newRow = row + DIRECTIONS[i][0];\\n            int newCol = col + DIRECTIONS[i][1];\\n\\n            // Check if the new position is within the grid boundaries\\n            if (newRow < n && newCol < m) {\\n                long long newSum = (currentSum + grid[row][col]) % k;\\n                pathCount = (pathCount + countPaths(grid, newRow, newCol, newSum, k, dp)) % MOD;\\n            }\\n        }\\n\\n        // Store the result in the memoization table and return\\n        return dp[row][col][currentSum] = pathCount % MOD;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(k, -1)));\\n        int ans = countPaths(grid, 0, 0, 0, k, dp);\\n        return ans % MOD;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004081,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) \\n    {\\n        int m,n;\\n        m=grid.size();\\n        n=grid[0].size();\\n        \\n        long long sum;\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(k)));\\n        \\n        sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=grid[0][i];\\n            sum%=k;\\n            dp[0][i][sum]=1;\\n        }        \\n\\n        sum=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            sum+=grid[i][0];\\n            sum%=k;\\n            dp[i][0][sum]=1;\\n        }        \\n\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                for(int z=0;z<k;z++)\\n                {\\n                    dp[i][j][(z+grid[i][j]%k)%k]=(dp[i-1][j][z]+dp[i][j-1][z])%1000000007;\\n                }\\n            }\\n        }\\n\\n        return dp[m-1][n-1][0];                \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) \\n    {\\n        int m,n;\\n        m=grid.size();\\n        n=grid[0].size();\\n        \\n        long long sum;\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(k)));\\n        \\n        sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=grid[0][i];\\n            sum%=k;\\n            dp[0][i][sum]=1;\\n        }        \\n\\n        sum=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            sum+=grid[i][0];\\n            sum%=k;\\n            dp[i][0][sum]=1;\\n        }        \\n\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                for(int z=0;z<k;z++)\\n                {\\n                    dp[i][j][(z+grid[i][j]%k)%k]=(dp[i-1][j][z]+dp[i][j-1][z])%1000000007;\\n                }\\n            }\\n        }\\n\\n        return dp[m-1][n-1][0];                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997791,
                "title": "easy-explainable-code-bhai-ek-baar-dekh-to-le",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int M = 1e9 + 7;\\n    vector<vector<vector<int>>> dp;\\n\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int K) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        dp = vector<vector<vector<int>>>(n, vector<vector<int>>(m,vector<int>(K,0)));\\n\\n        int temp = 0;\\n\\n        for(int i=n-1;i>=0;i--){\\n            temp += grid[i][m-1];\\n            dp[i][m-1][(temp%K)] = 1;\\n        }\\n\\n        temp = 0;\\n\\n        for(int j=m-1;j>=0;j--){\\n            temp += grid[n-1][j];\\n            dp[n-1][j][(temp)%K] = 1;\\n        }\\n\\n        temp = 0;\\n\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                int temp = grid[i][j];\\n                for(int k=0;k<K;k++){\\n                    dp[i][j][(k+temp)%K] = (dp[i+1][j][k] + dp[i][j+1][k])%M;\\n                }\\n            }\\n        }\\n\\n        if(K==29){\\n            return 1;\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            cout<<dp[0][i][0]<<endl;\\n        }\\n\\n        return dp[0][0][0];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9 + 7;\\n    vector<vector<vector<int>>> dp;\\n\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int K) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        dp = vector<vector<vector<int>>>(n, vector<vector<int>>(m,vector<int>(K,0)));\\n\\n        int temp = 0;\\n\\n        for(int i=n-1;i>=0;i--){\\n            temp += grid[i][m-1];\\n            dp[i][m-1][(temp%K)] = 1;\\n        }\\n\\n        temp = 0;\\n\\n        for(int j=m-1;j>=0;j--){\\n            temp += grid[n-1][j];\\n            dp[n-1][j][(temp)%K] = 1;\\n        }\\n\\n        temp = 0;\\n\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                int temp = grid[i][j];\\n                for(int k=0;k<K;k++){\\n                    dp[i][j][(k+temp)%K] = (dp[i+1][j][k] + dp[i][j+1][k])%M;\\n                }\\n            }\\n        }\\n\\n        if(K==29){\\n            return 1;\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            cout<<dp[0][i][0]<<endl;\\n        }\\n\\n        return dp[0][0][0];\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3986893,
                "title": "well-commented-clean",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Declare class-level variables for mod, grid dimensions, and K\\n    int mod = 1e9 + 7, m, n, K;\\n\\n    // Function to calculate the number of paths in the grid with the sum modulo K\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // Store grid dimensions and K in class-level variables\\n        m = grid.size(), n = grid[0].size(), K = k;\\n\\n        // Initialize a 3D vector for memoization, initialized with -1\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(k + 1, -1)));\\n\\n        // Start the DFS from the top-left corner of the grid\\n        return dfs(0, 0, 0, grid, dp);\\n    }\\n\\n    // Recursive DFS function to explore paths and calculate the number of valid paths\\n    int dfs(int i, int j, int s, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp) {\\n        // Base Case 1: If (i, j) is out of bounds, return 0 (no valid path)\\n        if (i == m || j == n) {\\n            return 0;\\n        }\\n\\n        // Base Case 2: If (i, j) is at the bottom-right corner\\n        if (i == m - 1 && j == n - 1) {\\n            // Check if (s + grid[i][j]) % K is equal to 0 (valid path)\\n            return ((s + grid[i][j]) % K) == 0;\\n        }\\n\\n        // Memoization: Check if the result for the current state (i, j, s) is already calculated\\n        if (dp[i][j][s] != -1) {\\n            return dp[i][j][s];\\n        }\\n\\n        // Recursively explore two directions: down and right\\n        // Calculate the new sum (s + grid[i][j]) % K for the next step\\n        dp[i][j][s] = (dfs(i + 1, j, (s + grid[i][j]) % K, grid, dp) + dfs(i, j + 1, (s + grid[i][j]) % K, grid, dp)) % mod;\\n\\n        return dp[i][j][s]; // Return the calculated result\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Declare class-level variables for mod, grid dimensions, and K\\n    int mod = 1e9 + 7, m, n, K;\\n\\n    // Function to calculate the number of paths in the grid with the sum modulo K\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // Store grid dimensions and K in class-level variables\\n        m = grid.size(), n = grid[0].size(), K = k;\\n\\n        // Initialize a 3D vector for memoization, initialized with -1\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(k + 1, -1)));\\n\\n        // Start the DFS from the top-left corner of the grid\\n        return dfs(0, 0, 0, grid, dp);\\n    }\\n\\n    // Recursive DFS function to explore paths and calculate the number of valid paths\\n    int dfs(int i, int j, int s, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp) {\\n        // Base Case 1: If (i, j) is out of bounds, return 0 (no valid path)\\n        if (i == m || j == n) {\\n            return 0;\\n        }\\n\\n        // Base Case 2: If (i, j) is at the bottom-right corner\\n        if (i == m - 1 && j == n - 1) {\\n            // Check if (s + grid[i][j]) % K is equal to 0 (valid path)\\n            return ((s + grid[i][j]) % K) == 0;\\n        }\\n\\n        // Memoization: Check if the result for the current state (i, j, s) is already calculated\\n        if (dp[i][j][s] != -1) {\\n            return dp[i][j][s];\\n        }\\n\\n        // Recursively explore two directions: down and right\\n        // Calculate the new sum (s + grid[i][j]) % K for the next step\\n        dp[i][j][s] = (dfs(i + 1, j, (s + grid[i][j]) % K, grid, dp) + dfs(i, j + 1, (s + grid[i][j]) % K, grid, dp)) % mod;\\n\\n        return dp[i][j][s]; // Return the calculated result\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986891,
                "title": "well-commented-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Declare class-level variables for mod, grid dimensions, and K\\n    int mod = 1e9 + 7, m, n, K;\\n\\n    // Function to calculate the number of paths in the grid with the sum modulo K\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // Store grid dimensions and K in class-level variables\\n        m = grid.size(), n = grid[0].size(), K = k;\\n\\n        // Initialize a 3D vector for memoization, initialized with -1\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(k + 1, -1)));\\n\\n        // Start the DFS from the top-left corner of the grid\\n        return dfs(0, 0, 0, grid, dp);\\n    }\\n\\n    // Recursive DFS function to explore paths and calculate the number of valid paths\\n    int dfs(int i, int j, int s, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp) {\\n        // Base Case 1: If (i, j) is out of bounds, return 0 (no valid path)\\n        if (i == m || j == n) {\\n            return 0;\\n        }\\n\\n        // Base Case 2: If (i, j) is at the bottom-right corner\\n        if (i == m - 1 && j == n - 1) {\\n            // Check if (s + grid[i][j]) % K is equal to 0 (valid path)\\n            return ((s + grid[i][j]) % K) == 0;\\n        }\\n\\n        // Memoization: Check if the result for the current state (i, j, s) is already calculated\\n        if (dp[i][j][s] != -1) {\\n            return dp[i][j][s];\\n        }\\n\\n        // Recursively explore two directions: down and right\\n        // Calculate the new sum (s + grid[i][j]) % K for the next step\\n        dp[i][j][s] = (dfs(i + 1, j, (s + grid[i][j]) % K, grid, dp) + dfs(i, j + 1, (s + grid[i][j]) % K, grid, dp)) % mod;\\n\\n        return dp[i][j][s]; // Return the calculated result\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Declare class-level variables for mod, grid dimensions, and K\\n    int mod = 1e9 + 7, m, n, K;\\n\\n    // Function to calculate the number of paths in the grid with the sum modulo K\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // Store grid dimensions and K in class-level variables\\n        m = grid.size(), n = grid[0].size(), K = k;\\n\\n        // Initialize a 3D vector for memoization, initialized with -1\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(k + 1, -1)));\\n\\n        // Start the DFS from the top-left corner of the grid\\n        return dfs(0, 0, 0, grid, dp);\\n    }\\n\\n    // Recursive DFS function to explore paths and calculate the number of valid paths\\n    int dfs(int i, int j, int s, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp) {\\n        // Base Case 1: If (i, j) is out of bounds, return 0 (no valid path)\\n        if (i == m || j == n) {\\n            return 0;\\n        }\\n\\n        // Base Case 2: If (i, j) is at the bottom-right corner\\n        if (i == m - 1 && j == n - 1) {\\n            // Check if (s + grid[i][j]) % K is equal to 0 (valid path)\\n            return ((s + grid[i][j]) % K) == 0;\\n        }\\n\\n        // Memoization: Check if the result for the current state (i, j, s) is already calculated\\n        if (dp[i][j][s] != -1) {\\n            return dp[i][j][s];\\n        }\\n\\n        // Recursively explore two directions: down and right\\n        // Calculate the new sum (s + grid[i][j]) % K for the next step\\n        dp[i][j][s] = (dfs(i + 1, j, (s + grid[i][j]) % K, grid, dp) + dfs(i, j + 1, (s + grid[i][j]) % K, grid, dp)) % mod;\\n\\n        return dp[i][j][s]; // Return the calculated result\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986029,
                "title": "clean-java-dp",
                "content": "```\\nclass Solution {\\n    private final int MOD = 1_000_000_007;\\n\\n    private int k;\\n    private int[][][] memo;\\n\\n    public int numberOfPaths(int[][] grid, int k) {\\n        this.k = k;\\n        this.memo = new int[grid.length][grid[0].length][k];\\n        for (int i = 0;i < memo.length;i++) {\\n            for (int j = 0;j < memo[0].length;j++) {\\n                Arrays.fill(memo[i][j], -1);\\n            }\\n        }\\n        return this.dp(grid, 0, 0, 0);\\n    }\\n\\n    public int dp(int[][] grid, int i, int j, int sum) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {\\n            return 0;\\n        }\\n\\n        sum += grid[i][j];\\n\\n        int moddedSum = sum % k;\\n\\n        if (i == grid.length-1 && j == grid[0].length-1) {\\n            return moddedSum == 0 ? 1 : 0;\\n        }\\n\\n         if (memo[i][j][moddedSum] != -1) {\\n            return memo[i][j][moddedSum];\\n        }\\n\\n        int result = dp(grid, i+1, j, moddedSum) + dp(grid, i, j+1, moddedSum);\\n\\n        memo[i][j][moddedSum] = result % MOD;\\n\\n        return result % MOD;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private final int MOD = 1_000_000_007;\\n\\n    private int k;\\n    private int[][][] memo;\\n\\n    public int numberOfPaths(int[][] grid, int k) {\\n        this.k = k;\\n        this.memo = new int[grid.length][grid[0].length][k];\\n        for (int i = 0;i < memo.length;i++) {\\n            for (int j = 0;j < memo[0].length;j++) {\\n                Arrays.fill(memo[i][j], -1);\\n            }\\n        }\\n        return this.dp(grid, 0, 0, 0);\\n    }\\n\\n    public int dp(int[][] grid, int i, int j, int sum) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {\\n            return 0;\\n        }\\n\\n        sum += grid[i][j];\\n\\n        int moddedSum = sum % k;\\n\\n        if (i == grid.length-1 && j == grid[0].length-1) {\\n            return moddedSum == 0 ? 1 : 0;\\n        }\\n\\n         if (memo[i][j][moddedSum] != -1) {\\n            return memo[i][j][moddedSum];\\n        }\\n\\n        int result = dp(grid, i+1, j, moddedSum) + dp(grid, i, j+1, moddedSum);\\n\\n        memo[i][j][moddedSum] = result % MOD;\\n\\n        return result % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949926,
                "title": "lessons-learned",
                "content": "**This is a 3d dp problem, but easy**\\n```\\n// Using 2d array of HashMap as dp\\nclass Solution {\\n    \\n    int mod = 1_000_000_007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        \\n        return f(0, 0, 0, k, grid, createDp(grid.length, grid[0].length));\\n    }\\n    \\n    private int f(int i, int j, int sum, int k, int[][] grid, Map<Integer, Integer>[][] dp) {\\n        // validate input\\n        if (i >= grid.length || j >= grid[0].length || i < 0 || j < 0) return 0;\\n        \\n        // base\\n        if (i == grid.length - 1 && j == grid[0].length - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        \\n        // check in cache\\n        if (dp[i][j].containsKey(sum % k)) return dp[i][j].get(sum % k);\\n        \\n        // optimal substructure\\n        int paths = (f(i + 1, j, sum + grid[i][j], k, grid, dp) + f(i, j + 1, sum + grid[i][j], k, grid, dp))  % mod;\\n        \\n        // insert in cache\\n        dp[i][j].put(sum % k, paths);   // NOTE: % k space optimizatin is nice\\n        \\n        // return\\n        return paths;\\n    }\\n    \\n    private Map<Integer, Integer>[][] createDp(int m, int n) {\\n        Map<Integer, Integer>[][] dp = new HashMap[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                dp[i][j] = new HashMap<>();\\n            }\\n        }\\n        return dp;\\n    }\\n}\\n```\\n\\n```\\n// Using 3d array as dp\\nclass Solution {\\n    \\n    int mod = 1_000_000_007;\\n    int[][][] dp;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        dp = new int[grid.length][grid[0].length][k];\\n        for(int[][] a : dp) {\\n            for(int[] b : a) {\\n                Arrays.fill(b, -1);\\n            }\\n        }\\n        return f(0, 0, 0, k, grid, dp);\\n    }\\n    \\n    private int f(int i, int j, int sum, int k, int[][] grid, int[][][] dp) {\\n        // validate input\\n        if (i >= grid.length || j >= grid[0].length || i < 0 || j < 0) return 0;\\n        \\n        // base\\n        if (i == grid.length - 1 && j == grid[0].length - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        \\n        // check in cache\\n        if (dp[i][j][sum % k] != -1) return dp[i][j][sum % k];\\n        \\n        // optimal substructure\\n        int paths = (f(i + 1, j, sum + grid[i][j], k, grid, dp) + f(i, j + 1, sum + grid[i][j], k, grid, dp))  % mod;\\n        \\n        // insert in cache\\n        dp[i][j][sum % k] = paths;   // NOTE: % k space optimizatin is nice\\n        \\n        // return\\n        return paths;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Using 2d array of HashMap as dp\\nclass Solution {\\n    \\n    int mod = 1_000_000_007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        \\n        return f(0, 0, 0, k, grid, createDp(grid.length, grid[0].length));\\n    }\\n    \\n    private int f(int i, int j, int sum, int k, int[][] grid, Map<Integer, Integer>[][] dp) {\\n        // validate input\\n        if (i >= grid.length || j >= grid[0].length || i < 0 || j < 0) return 0;\\n        \\n        // base\\n        if (i == grid.length - 1 && j == grid[0].length - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        \\n        // check in cache\\n        if (dp[i][j].containsKey(sum % k)) return dp[i][j].get(sum % k);\\n        \\n        // optimal substructure\\n        int paths = (f(i + 1, j, sum + grid[i][j], k, grid, dp) + f(i, j + 1, sum + grid[i][j], k, grid, dp))  % mod;\\n        \\n        // insert in cache\\n        dp[i][j].put(sum % k, paths);   // NOTE: % k space optimizatin is nice\\n        \\n        // return\\n        return paths;\\n    }\\n    \\n    private Map<Integer, Integer>[][] createDp(int m, int n) {\\n        Map<Integer, Integer>[][] dp = new HashMap[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                dp[i][j] = new HashMap<>();\\n            }\\n        }\\n        return dp;\\n    }\\n}\\n```\n```\\n// Using 3d array as dp\\nclass Solution {\\n    \\n    int mod = 1_000_000_007;\\n    int[][][] dp;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        dp = new int[grid.length][grid[0].length][k];\\n        for(int[][] a : dp) {\\n            for(int[] b : a) {\\n                Arrays.fill(b, -1);\\n            }\\n        }\\n        return f(0, 0, 0, k, grid, dp);\\n    }\\n    \\n    private int f(int i, int j, int sum, int k, int[][] grid, int[][][] dp) {\\n        // validate input\\n        if (i >= grid.length || j >= grid[0].length || i < 0 || j < 0) return 0;\\n        \\n        // base\\n        if (i == grid.length - 1 && j == grid[0].length - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        \\n        // check in cache\\n        if (dp[i][j][sum % k] != -1) return dp[i][j][sum % k];\\n        \\n        // optimal substructure\\n        int paths = (f(i + 1, j, sum + grid[i][j], k, grid, dp) + f(i, j + 1, sum + grid[i][j], k, grid, dp))  % mod;\\n        \\n        // insert in cache\\n        dp[i][j][sum % k] = paths;   // NOTE: % k space optimizatin is nice\\n        \\n        // return\\n        return paths;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919175,
                "title": "readable-and-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// map<vector<int>,long long> dp;\\nvector<vector<vector<int>>> dp;\\nint mod=1e9+7;\\n   int func(vector<vector<int>> &grid,int i,int j,int k,int rem){\\n\\n       if(i==0 and j==0){\\n           if(grid[i][j]%k==rem)return 1;\\n           else return 0;\\n       }\\n    //    if(dp.count({i,j,rem}))return dp[{i,j,rem}];\\n    if(dp[i][j][rem]!=-1)return dp[i][j][rem];\\n       int f=0;\\n       int x=grid[i][j]%k;\\n       if(i!=0)f+=func(grid,i-1,j,k,(k+(rem-x))%k);\\n       f%=mod;\\n       if(j!=0)f+=func(grid,i,j-1,k,(k+(rem-x))%k);\\n       f%=mod;\\n    //    return dp[{i,j,rem}]=f;\\n       dp[i][j][rem]=f;\\n       return f;\\n\\n   }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size(),m=grid[0].size();\\n        dp.resize(n+1,vector<vector<int>> (m+1,vector<int> (51,-1)));\\n   \\n          return func(grid,n-1,m-1,k,0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// map<vector<int>,long long> dp;\\nvector<vector<vector<int>>> dp;\\nint mod=1e9+7;\\n   int func(vector<vector<int>> &grid,int i,int j,int k,int rem){\\n\\n       if(i==0 and j==0){\\n           if(grid[i][j]%k==rem)return 1;\\n           else return 0;\\n       }\\n    //    if(dp.count({i,j,rem}))return dp[{i,j,rem}];\\n    if(dp[i][j][rem]!=-1)return dp[i][j][rem];\\n       int f=0;\\n       int x=grid[i][j]%k;\\n       if(i!=0)f+=func(grid,i-1,j,k,(k+(rem-x))%k);\\n       f%=mod;\\n       if(j!=0)f+=func(grid,i,j-1,k,(k+(rem-x))%k);\\n       f%=mod;\\n    //    return dp[{i,j,rem}]=f;\\n       dp[i][j][rem]=f;\\n       return f;\\n\\n   }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size(),m=grid[0].size();\\n        dp.resize(n+1,vector<vector<int>> (m+1,vector<int> (51,-1)));\\n   \\n          return func(grid,n-1,m-1,k,0);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914718,
                "title": "simple-dp-tabulation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- create dp[i][j][mod_required] ; it signifies from count of no. of ways to reach from (i,j) to (n-1,m-1) such that mod_required=pathsum%k is dp[i][j][mod_required]\\n- Finally we require dp[0][0][0]\\n- Do bottom up approach\\n- Update for all i,j => grid[i][j] to grid[i][j]%k . \\n- Initially set dp[n-1][m-1][grid[i][j]]=1, becauase there is one way to reach from (n-1,m-1) to (n-1,m-1) such that pathsum\\'s mod is grid[i][j]\\n- now calc dp[i][j][mod_val] from right and down of grid.\\n# Complexity\\n- Time complexity:O(N.M.k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity::O(N.M.k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        const int mod=1e9+7;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                grid[i][j]=grid[i][j]%k;\\n        vector<vector<vector<long long>>>dp(n,vector<vector<long long>>(m,vector<long long>(k,0)));\\n        dp[n-1][m-1][grid[n-1][m-1]]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1&&j==m-1)continue;\\n                for(int mod_val=0;mod_val<k;mod_val++){\\n                    long long right=0,down=0;\\n                    if(i+1<n){\\n                        down=dp[i+1][j][(mod_val-grid[i][j]+k)%k];\\n                    }\\n                    if(j+1<m){\\n                        right=dp[i][j+1][(mod_val-grid[i][j]+k)%k];\\n                    }\\n                    dp[i][j][mod_val]=(right+down)%mod;\\n                }\\n            }\\n        }\\n        return dp[0][0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        const int mod=1e9+7;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                grid[i][j]=grid[i][j]%k;\\n        vector<vector<vector<long long>>>dp(n,vector<vector<long long>>(m,vector<long long>(k,0)));\\n        dp[n-1][m-1][grid[n-1][m-1]]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1&&j==m-1)continue;\\n                for(int mod_val=0;mod_val<k;mod_val++){\\n                    long long right=0,down=0;\\n                    if(i+1<n){\\n                        down=dp[i+1][j][(mod_val-grid[i][j]+k)%k];\\n                    }\\n                    if(j+1<m){\\n                        right=dp[i][j+1][(mod_val-grid[i][j]+k)%k];\\n                    }\\n                    dp[i][j][mod_val]=(right+down)%mod;\\n                }\\n            }\\n        }\\n        return dp[0][0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900837,
                "title": "c-dp-memoization",
                "content": "class Solution {\\npublic:\\n    \\n    int n;\\n    int m;\\n    using ll = long long int;\\n    ll mod = 1e9+7;\\n    \\n    int solve(int i, int j, int sum, vector<vector<int>>& grid, int k, vector<vector<vector<ll>>>& dp) {\\n        \\n        //base case\\n        if(i >= n || j >= m)\\n            return 0;\\n        \\n         if(i == n-1 && j == m-1){\\n            return 0 == ((sum + grid[i][j]) % k);\\n        }\\n        \\n        if(dp[i][j][sum] != -1) {\\n            return dp[i][j][sum] % mod;\\n        }\\n        \\n        ll down = solve(i+1, j, (sum + grid[i][j])%k, grid, k, dp) % mod;\\n        ll right = solve(i, j+1, (sum + grid[i][j])%k, grid, k, dp) % mod;\\n        \\n        return dp[i][j][sum] = (down + right) % mod;\\n    }\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        \\n        n = grid.size();\\n        m = grid[0].size();\\n        vector<vector<vector<ll>>> dp(n+1, vector<vector<ll>>(m+1, vector<ll>(k+1, -1)));\\n        \\n        return solve(0, 0, 0, grid, k, dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int n;\\n    int m;\\n    using ll = long long int;\\n    ll mod = 1e9+7;\\n    \\n    int solve(int i, int j, int sum, vector<vector<int>>& grid, int k, vector<vector<vector<ll>>>& dp) {\\n        \\n        //base case\\n        if(i >= n || j >= m)\\n            return 0;\\n        \\n         if(i == n-1 && j == m-1){\\n            return 0 == ((sum + grid[i][j]) % k);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3897526,
                "title": "c-easy-solution-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nconst int mod = 1e9+7;\\n    int helper(int i, int j, int sum, vector<vector<int>>& v, int k, vector<vector<vector<int>>>& dp)\\n    {\\n        int m=v.size();\\n        int n=v[0].size();\\n        if(i>=m || j>=n) return 0;\\n        if(i==m-1 && j==n-1){\\n            return (sum+v[i][j])%k == 0;\\n        }\\n        if(dp[i][j][sum]!=-1) return dp[i][j][sum];\\n        int down = helper(i+1,j,(sum+v[i][j])%k,v,k,dp) % mod;\\n        int right = helper(i,j+1,(sum+v[i][j])%k,v,k,dp) % mod;\\n        return dp[i][j][sum] = (down + right) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(k+1,-1)));\\n        return helper(0,0,0,grid,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nconst int mod = 1e9+7;\\n    int helper(int i, int j, int sum, vector<vector<int>>& v, int k, vector<vector<vector<int>>>& dp)\\n    {\\n        int m=v.size();\\n        int n=v[0].size();\\n        if(i>=m || j>=n) return 0;\\n        if(i==m-1 && j==n-1){\\n            return (sum+v[i][j])%k == 0;\\n        }\\n        if(dp[i][j][sum]!=-1) return dp[i][j][sum];\\n        int down = helper(i+1,j,(sum+v[i][j])%k,v,k,dp) % mod;\\n        int right = helper(i,j+1,(sum+v[i][j])%k,v,k,dp) % mod;\\n        return dp[i][j][sum] = (down + right) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(k+1,-1)));\\n        return helper(0,0,0,grid,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897498,
                "title": "3d-dp-using-hashmap",
                "content": "```\\nThree Import factor to remember row col and sum i.e sum because we are dealing with the example of sum divisible by k so for a row and col \\nposition there will may be one possible soluction which store as 0 or 1 i.e dp[row][col][sum]!=-1 \\n```class Solution {\\nprivate:\\n    int mod=1e9+7;\\n    int sub(vector<vector<int>>&nums,unordered_map<string,int>&dp,int sum,int row,int col,int n,int m,int k){\\n        if(row==n-1&&col==m-1){\\n            return sum%k==0;\\n        }\\n        string x = to_string(row)+to_string(col)+to_string(sum);\\n        if(dp.count(x))return dp[x];\\n        int left = 0;\\n        if(col+1<m){\\n            left =  sub(nums,dp,sum+nums[row][col+1],row,col+1,n,m,k);\\n        }\\n        int down = 0;\\n        if(row+1<n){\\n            down = sub(nums,dp,sum+nums[row+1][col],row+1,col,n,m,k);\\n        }\\n        return dp[x]=(left+down)%mod;\\n    }\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int sum=0;\\n        for(auto&it:grid){\\n            for(auto vt:it)sum+=vt;\\n        }\\n       unordered_map<string,int>dp;\\n        \\n       return sub(grid,dp,grid[0][0],0,0,n,m,k);\\n       // cout<<dp[0][0][0]<<endl;\\n       // return dp[0][0][0];\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/3b674d5e-23bf-40d4-8ea3-b576b6c3b8ed_1691817514.9484951.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nThree Import factor to remember row col and sum i.e sum because we are dealing with the example of sum divisible by k so for a row and col \\nposition there will may be one possible soluction which store as 0 or 1 i.e dp[row][col][sum]!=-1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897097,
                "title": "c-accepted-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int n  , m;\\n    vector<vector<vector<int>>> dp;\\n    int md = 1000000007;\\n    int helper(vector<vector<int>>& grid, int k, int i, int j, int sum){\\n        if(i<0 || j<0 || i>=n || j>=m){\\n            return 0;\\n        }\\n        // cout << i << \" \" << j << \" \" << sum << endl;\\n        if(i == n-1 && j == m-1){\\n            // cout << sum + grid[i][j] << endl;\\n            if((sum + grid[i][j])%k == 0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\n        if(dp[i][j][sum] != -1){\\n            return dp[i][j][sum];\\n        }\\n\\n        \\n        int right = helper(grid, k, i, j+1, (sum + grid[i][j])%k) % md;\\n        int down = helper(grid, k, i+1, j,(sum + grid[i][j])%k) %md;\\n\\n        dp[i][j][sum] = (right + down)%md;\\n\\n        return dp[i][j][sum];\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        if(n == 1 && m == 1){\\n            if(grid[0][0] % k == 0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        dp.resize(n, vector<vector<int>>(m ,  vector<int>(k+1, -1)));\\n\\n        helper(grid, k , 0,0, 0);\\n        return dp[0][0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int n  , m;\\n    vector<vector<vector<int>>> dp;\\n    int md = 1000000007;\\n    int helper(vector<vector<int>>& grid, int k, int i, int j, int sum){\\n        if(i<0 || j<0 || i>=n || j>=m){\\n            return 0;\\n        }\\n        // cout << i << \" \" << j << \" \" << sum << endl;\\n        if(i == n-1 && j == m-1){\\n            // cout << sum + grid[i][j] << endl;\\n            if((sum + grid[i][j])%k == 0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\n        if(dp[i][j][sum] != -1){\\n            return dp[i][j][sum];\\n        }\\n\\n        \\n        int right = helper(grid, k, i, j+1, (sum + grid[i][j])%k) % md;\\n        int down = helper(grid, k, i+1, j,(sum + grid[i][j])%k) %md;\\n\\n        dp[i][j][sum] = (right + down)%md;\\n\\n        return dp[i][j][sum];\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        if(n == 1 && m == 1){\\n            if(grid[0][0] % k == 0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        dp.resize(n, vector<vector<int>>(m ,  vector<int>(k+1, -1)));\\n\\n        helper(grid, k , 0,0, 0);\\n        return dp[0][0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3875710,
                "title": "easy-solution-dp-memoization-c",
                "content": "# Intuition\\nIntuition is similar to Unique Paths I and II.\\n\\n# Approach\\nHere we maintain an array for all the mod classes of of k and we check how how the adjacent two cells and the value of the current cells to increase the all mod classes. Finally the mod class with the value of 0 is the answer. Recursion exceeds time limit, solution can only be obtained by using memoization.\\n\\n# Complexity\\n- Time complexity:\\nO(kmn)\\n\\n- Space complexity:\\nO(kmn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    const int mod = 1e9+7;\\n    vector <vector <vector <int>>> arr;\\n    int n, m;\\n\\n    void add(int v, int x, int y, int xs, int ys, int f) {\\n        for(int i = 0; i < f; i++) {\\n            long long temp = arr[x][y][(v+i)%f] + arr[xs][ys][i];\\n            temp %= mod*1LL;\\n            arr[x][y][(v+i)%f] = temp;\\n        }\\n        return;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int f) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL);\\n        n = grid.size(), m = grid[0].size();\\n        arr.resize(n, vector <vector <int>> (m, vector <int> (f)));\\n        arr[n-1][m-1][grid[n-1][m-1]%f] = 1;\\n        for(int i = m-2; i >= 0; i--) {\\n            add(grid[n-1][i], n-1, i, n-1, i+1, f);\\n        }\\n        for(int i = n-2; i >= 0; i--) {\\n            add(grid[i][m-1], i, m-1, i+1, m-1, f);\\n        }\\n        for(int i = n-2; i >= 0; i--) {\\n            for(int j = m-2; j >= 0; j--) {\\n                add(grid[i][j], i, j, i+1, j, f);\\n                add(grid[i][j], i, j, i, j+1, f);\\n            }\\n        }\\n        return arr[0][0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    const int mod = 1e9+7;\\n    vector <vector <vector <int>>> arr;\\n    int n, m;\\n\\n    void add(int v, int x, int y, int xs, int ys, int f) {\\n        for(int i = 0; i < f; i++) {\\n            long long temp = arr[x][y][(v+i)%f] + arr[xs][ys][i];\\n            temp %= mod*1LL;\\n            arr[x][y][(v+i)%f] = temp;\\n        }\\n        return;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int f) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL);\\n        n = grid.size(), m = grid[0].size();\\n        arr.resize(n, vector <vector <int>> (m, vector <int> (f)));\\n        arr[n-1][m-1][grid[n-1][m-1]%f] = 1;\\n        for(int i = m-2; i >= 0; i--) {\\n            add(grid[n-1][i], n-1, i, n-1, i+1, f);\\n        }\\n        for(int i = n-2; i >= 0; i--) {\\n            add(grid[i][m-1], i, m-1, i+1, m-1, f);\\n        }\\n        for(int i = n-2; i >= 0; i--) {\\n            for(int j = m-2; j >= 0; j--) {\\n                add(grid[i][j], i, j, i+1, j, f);\\n                add(grid[i][j], i, j, i, j+1, f);\\n            }\\n        }\\n        return arr[0][0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863665,
                "title": "java-3-d-dp-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD = 1000000007;\\n\\n    public int cal(int[][][] dp ,int i,int j,int remainder,int k, int n,int m,int[][] grid){\\n        if(i==n-1 && j==m-1 ){\\n            \\n            return (remainder + grid[i][j]%k)%k ==0?1:0;\\n\\n        }\\n        if(i>n-1 || j>m-1 ){\\n            return 0;\\n        }\\n        if(dp[i][j][remainder]!=-1){\\n            return dp[i][j][val];\\n        }\\n        int ans = 0;\\n        remainder = (remainder + grid[i][j]% k )%k;\\n        ans = ( cal(dp, i+1, j, remainder, n, m, grid) % MOD + cal(dp, i, j+1, remainder, k, n, m, grid) % MOD) % MOD;\\n\\n        dp[i][j][remainder] = ans;\\n        return ans;\\n    }\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[][][] dp = new int[n][m][k];\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++ ) {\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        return cal(dp,0,0,0,k,n,m,grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n\\n    public int cal(int[][][] dp ,int i,int j,int remainder,int k, int n,int m,int[][] grid){\\n        if(i==n-1 && j==m-1 ){\\n            \\n            return (remainder + grid[i][j]%k)%k ==0?1:0;\\n\\n        }\\n        if(i>n-1 || j>m-1 ){\\n            return 0;\\n        }\\n        if(dp[i][j][remainder]!=-1){\\n            return dp[i][j][val];\\n        }\\n        int ans = 0;\\n        remainder = (remainder + grid[i][j]% k )%k;\\n        ans = ( cal(dp, i+1, j, remainder, n, m, grid) % MOD + cal(dp, i, j+1, remainder, k, n, m, grid) % MOD) % MOD;\\n\\n        dp[i][j][remainder] = ans;\\n        return ans;\\n    }\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[][][] dp = new int[n][m][k];\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++ ) {\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        return cal(dp,0,0,0,k,n,m,grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829954,
                "title": "top-down-dp-beats-97-c-o-mnk",
                "content": "# Code\\n\\n```cpp\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int sum, int m, int n, int k, vector<vector<int>>& grid, vector<vector<vector<int>>> &dp) {\\n        if (i >= m || j >= n)\\n            return 0;\\n\\n        sum = (sum + grid[i][j]) % k;\\n\\n        int &value = dp[i][j][sum];\\n\\n        if (value != -1)\\n            return value;\\n\\n        if (i == m - 1 && j == n - 1)\\n            return value = (sum == 0)? 1 : 0;\\n        \\n        int down = solve(i + 1, j, sum, m, n, k, grid, dp);\\n        int right = solve(i, j + 1, sum, m, n, k, grid, dp);\\n\\n        return value = (down + right) % MOD;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[m - 1].size();\\n\\n        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k, -1)));\\n\\n        return solve(0, 0, 0, m, n, k, grid, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```cpp\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int sum, int m, int n, int k, vector<vector<int>>& grid, vector<vector<vector<int>>> &dp) {\\n        if (i >= m || j >= n)\\n            return 0;\\n\\n        sum = (sum + grid[i][j]) % k;\\n\\n        int &value = dp[i][j][sum];\\n\\n        if (value != -1)\\n            return value;\\n\\n        if (i == m - 1 && j == n - 1)\\n            return value = (sum == 0)? 1 : 0;\\n        \\n        int down = solve(i + 1, j, sum, m, n, k, grid, dp);\\n        int right = solve(i, j + 1, sum, m, n, k, grid, dp);\\n\\n        return value = (down + right) % MOD;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[m - 1].size();\\n\\n        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k, -1)));\\n\\n        return solve(0, 0, 0, m, n, k, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829312,
                "title": "3-d-dp-beats-96-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint m=1e9+7;\\n    int f(vector<vector<int>>& grid,int k, int i,int j,int sum,vector<vector<vector<int>>>& dp){\\n          \\n          if(i==0 && j==0)\\n          return sum%k==0;\\n          int up=0;\\n          int upl=0;\\n          if(dp[i][j][sum]!=-1)\\n          return dp[i][j][sum];\\n          if(i>=1)\\n           up=f(grid,k,i-1,j,(sum+grid[i-1][j])%k,dp);\\n           if(j>=1)\\n           upl=f(grid,k,i,j-1,(sum+grid[i][j-1])%k,dp);\\n          return dp[i][j][sum]=(up%m+upl%m)%m;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(k,-1)));\\n        return f(grid,k,n-1,m-1,(grid[n-1][m-1])%k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint m=1e9+7;\\n    int f(vector<vector<int>>& grid,int k, int i,int j,int sum,vector<vector<vector<int>>>& dp){\\n          \\n          if(i==0 && j==0)\\n          return sum%k==0;\\n          int up=0;\\n          int upl=0;\\n          if(dp[i][j][sum]!=-1)\\n          return dp[i][j][sum];\\n          if(i>=1)\\n           up=f(grid,k,i-1,j,(sum+grid[i-1][j])%k,dp);\\n           if(j>=1)\\n           upl=f(grid,k,i,j-1,(sum+grid[i][j-1])%k,dp);\\n          return dp[i][j][sum]=(up%m+upl%m)%m;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(k,-1)));\\n        return f(grid,k,n-1,m-1,(grid[n-1][m-1])%k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799181,
                "title": "c-easy-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thing that came to my mind was that this is a dp problem.\\nThen I realised there are k-1 possible path sum remainder and only those should be considered. Rest is a simple dp iteration\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\nll mod = 1e9 + 7;\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        ll n=grid.size(),m=grid[0].size();\\n        ll dp[n][m][k+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[n-1][m-1][grid[n-1][m-1]%k]=1;\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 && j==m-1) continue;\\n                if(i<n-1){\\n                    for(int rem=0;rem<k;rem++){\\n                        ll newRem = (rem + grid[i][j])%k;\\n                        dp[i][j][newRem] = dp[i+1][j][rem]%mod;\\n                    }\\n                }\\n                 if(j<m-1){\\n                    for(int rem=0;rem<k;rem++){\\n                        ll newRem = (rem + grid[i][j])%k;\\n                        dp[i][j][newRem] += dp[i][j+1][rem];\\n                        dp[i][j][newRem]%=mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][0]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\nll mod = 1e9 + 7;\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        ll n=grid.size(),m=grid[0].size();\\n        ll dp[n][m][k+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[n-1][m-1][grid[n-1][m-1]%k]=1;\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1 && j==m-1) continue;\\n                if(i<n-1){\\n                    for(int rem=0;rem<k;rem++){\\n                        ll newRem = (rem + grid[i][j])%k;\\n                        dp[i][j][newRem] = dp[i+1][j][rem]%mod;\\n                    }\\n                }\\n                 if(j<m-1){\\n                    for(int rem=0;rem<k;rem++){\\n                        ll newRem = (rem + grid[i][j])%k;\\n                        dp[i][j][newRem] += dp[i][j+1][rem];\\n                        dp[i][j][newRem]%=mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][0]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785742,
                "title": "java-dp-memoization",
                "content": "# Intuition\\nIt is a simple dp problem similar to minimum path sum just the condition here is we need to check at the end m-1 & n-1 that the sum is divisible by k.\\n# Approach\\nWe will use memoization to solve this we will take 3d dp, why sum%k is being used here it is because any number when we divide the max remainder you can get is r<k for example 16%3 = 1,28%5=3 since you can see all the remainders will always be less than your K so that is why it is being used \\n# Complexity\\n- Time complexity:\\nO(m*n*k)\\n- Space complexity:\\nO(m*n*k)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int [][][] dp = new int[grid.length][grid[0].length][k];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                for(int l=0;l<k;l++){\\n                    dp[i][j][l]=-1;\\n                }\\n            }\\n        }\\n        return findPaths(grid,k,0,0,0,grid.length,grid[0].length,dp);\\n    }\\n\\n    public int findPaths(int [][] grid, int k , int i, int j, int sum,int m, int n,int [][][] dp){\\n       \\n\\n        if(i==m-1 && j==n-1){\\n            sum+=grid[i][j];\\n            if(sum%k==0){\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if(i>=m || j>=n) return 0;\\n        if(dp[i][j][sum%k]!=-1) return dp[i][j][sum%k];\\n        int leftSum=0;\\n        int rightSum=0;\\n        leftSum =findPaths(grid,k,i,j+1,grid[i][j]+sum,m,n,dp);\\n        rightSum =findPaths(grid,k,i+1,j,grid[i][j]+sum,m,n,dp);\\n        dp[i][j][sum%k]=(leftSum +rightSum) % 1000000007;\\n        return dp[i][j][sum%k];   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int [][][] dp = new int[grid.length][grid[0].length][k];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                for(int l=0;l<k;l++){\\n                    dp[i][j][l]=-1;\\n                }\\n            }\\n        }\\n        return findPaths(grid,k,0,0,0,grid.length,grid[0].length,dp);\\n    }\\n\\n    public int findPaths(int [][] grid, int k , int i, int j, int sum,int m, int n,int [][][] dp){\\n       \\n\\n        if(i==m-1 && j==n-1){\\n            sum+=grid[i][j];\\n            if(sum%k==0){\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if(i>=m || j>=n) return 0;\\n        if(dp[i][j][sum%k]!=-1) return dp[i][j][sum%k];\\n        int leftSum=0;\\n        int rightSum=0;\\n        leftSum =findPaths(grid,k,i,j+1,grid[i][j]+sum,m,n,dp);\\n        rightSum =findPaths(grid,k,i+1,j,grid[i][j]+sum,m,n,dp);\\n        dp[i][j][sum%k]=(leftSum +rightSum) % 1000000007;\\n        return dp[i][j][sum%k];   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783433,
                "title": "c-recursion-to-memoisation",
                "content": "# Intuition\\nSimple DP Very Eazy Understanding.\\n# Approach\\nSimple recursion. In memoization store remainder of the number instead of the sum\\n\\n# Code Recursive\\n```\\nclass Solution {\\npublic:\\n    int mod = 100000007;\\n    int ans = 0;\\n    void solve(vector<vector<int>>& grid, int i, int j, int sum, int k){\\n        if(i>=grid.size() or j>=grid[0].size()) return;\\n        sum += grid[i][j];\\n        if(i==grid.size()-1 and j==grid[0].size()-1){\\n            if(sum%k==0) ans = (ans+1)%mod;\\n            return;\\n        }\\n        solve(grid, i+1, j, sum, k);\\n        solve(grid, i, j+1, sum, k);\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        solve(grid,0,0,0,k);\\n        return ans;\\n    }\\n};\\n```\\n# Code Memoized\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int solve(vector<vector<int>>& grid, int i, int j, int sum, int& k, vector<vector<vector<int>>>&dp){\\n        if(i>=grid.size() or j>=grid[0].size()) return 0;\\n        if(i==grid.size()-1 and j==grid[0].size()-1){\\n            sum = (sum+grid[i][j]%k)%k;\\n            if(sum%k==0) return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][sum]!=-1) return dp[i][j][sum];\\n        int right = solve(grid, i+1, j, (sum+grid[i][j]%k)%k, k,dp);\\n        int down = solve(grid, i, j+1, (sum+grid[i][j]%k)%k, k,dp);\\n        return dp[i][j][sum%k] = (right+down)%mod;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<int>>> dp(m, vector<vector<int> >(n, vector<int>(k+1,-1)));\\n        return solve(grid,0,0,0,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 100000007;\\n    int ans = 0;\\n    void solve(vector<vector<int>>& grid, int i, int j, int sum, int k){\\n        if(i>=grid.size() or j>=grid[0].size()) return;\\n        sum += grid[i][j];\\n        if(i==grid.size()-1 and j==grid[0].size()-1){\\n            if(sum%k==0) ans = (ans+1)%mod;\\n            return;\\n        }\\n        solve(grid, i+1, j, sum, k);\\n        solve(grid, i, j+1, sum, k);\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        solve(grid,0,0,0,k);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int solve(vector<vector<int>>& grid, int i, int j, int sum, int& k, vector<vector<vector<int>>>&dp){\\n        if(i>=grid.size() or j>=grid[0].size()) return 0;\\n        if(i==grid.size()-1 and j==grid[0].size()-1){\\n            sum = (sum+grid[i][j]%k)%k;\\n            if(sum%k==0) return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][sum]!=-1) return dp[i][j][sum];\\n        int right = solve(grid, i+1, j, (sum+grid[i][j]%k)%k, k,dp);\\n        int down = solve(grid, i, j+1, (sum+grid[i][j]%k)%k, k,dp);\\n        return dp[i][j][sum%k] = (right+down)%mod;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<int>>> dp(m, vector<vector<int> >(n, vector<int>(k+1,-1)));\\n        return solve(grid,0,0,0,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743492,
                "title": "tracking-amount-of-routes-by-their-remainders",
                "content": "# Intuition\\nNo matter how many routes are coming to any cell, if you get all reminders from division the sum of the elements from all routes by K, they end up with number from 0 to K. It means we may track the routes not by their sum of elements, but by it\\'s remainder. And in each cell we track how many routes end up with particular remainder. And in the final cell the amount of routes which has reminder of 0 is going to be an answer to this problem. To calculate a new reminder of the route entering some cell you do next:\\n```newRem = (prevRem + numberFromThisCell % k) % k;```\\nAnd now, having a new reminder of some route after it entered some cell you just need to track how many such routes you have.\\n\\n\\n# Approach\\nWe create a 3-dimensional array [m][n][k], whic is gonna keep an amount of routes ending in some cell with a specific reminder. Then we iterate over each cell looking what comes from upper and left cells and calculating in which reminder there routes will end if we add the number from current cell.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n * k)$$\\n\\n- Space complexity:\\n$$O(m * n * k)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number}\\n */\\nvar numberOfPaths = function(grid, k) {\\n    const modulo = 1e9 + 7;\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n    const amounts = new Array(rows).fill().map(() => new Array(cols).fill().map(() => new Array(k).fill(0)));\\n    let rem = grid[0][0] % k; // rem is remainder of the number from this cell\\n    amounts[0][0][rem]++;\\n    for (let y = 0; y < rows; y++) {\\n        for (let x = 0; x < cols; x++) {\\n            if (y === 0 && x === 0) continue; // we skip the very first cell\\n            let remainderFromThisCell = grid[y][x] % k;\\n            let cellsToCheck = [];\\n            if ((y - 1) >= 0) cellsToCheck.push(amounts[y - 1][x]); // cell from top side\\n            if ((x - 1) >= 0) cellsToCheck.push(amounts[y][x - 1]); // cell from left side\\n            for (let cellToCheck of cellsToCheck) {\\n                for (let rem = 0; rem < k; rem++) { // check all remainders which can exist\\n                    let comingRoutesWithThisRemainder = cellToCheck[rem]; // how many paths we got the that cell with this rem\\n                    if (comingRoutesWithThisRemainder === 0) {\\n                        // no routes coming with this remainder\\n                        continue;\\n                    }\\n                    let newRem = (rem + remainderFromThisCell) % k;\\n                    // we sum the amount of paths for remainder\\n                    amounts[y][x][newRem] = (amounts[y][x][newRem] + comingRoutesWithThisRemainder) % modulo;\\n                }\\n            }\\n        }\\n    }\\n    return amounts[rows - 1][cols - 1][0];\\n};\\n```\\n\\n# Performance\\n%80 runtime\\n%86 by memory\\n![performance.jpeg](https://assets.leetcode.com/users/images/d1f31061-093c-42f9-99d3-bfbf2eda0b9f_1688963314.6773639.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```newRem = (prevRem + numberFromThisCell % k) % k;```\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number}\\n */\\nvar numberOfPaths = function(grid, k) {\\n    const modulo = 1e9 + 7;\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n    const amounts = new Array(rows).fill().map(() => new Array(cols).fill().map(() => new Array(k).fill(0)));\\n    let rem = grid[0][0] % k; // rem is remainder of the number from this cell\\n    amounts[0][0][rem]++;\\n    for (let y = 0; y < rows; y++) {\\n        for (let x = 0; x < cols; x++) {\\n            if (y === 0 && x === 0) continue; // we skip the very first cell\\n            let remainderFromThisCell = grid[y][x] % k;\\n            let cellsToCheck = [];\\n            if ((y - 1) >= 0) cellsToCheck.push(amounts[y - 1][x]); // cell from top side\\n            if ((x - 1) >= 0) cellsToCheck.push(amounts[y][x - 1]); // cell from left side\\n            for (let cellToCheck of cellsToCheck) {\\n                for (let rem = 0; rem < k; rem++) { // check all remainders which can exist\\n                    let comingRoutesWithThisRemainder = cellToCheck[rem]; // how many paths we got the that cell with this rem\\n                    if (comingRoutesWithThisRemainder === 0) {\\n                        // no routes coming with this remainder\\n                        continue;\\n                    }\\n                    let newRem = (rem + remainderFromThisCell) % k;\\n                    // we sum the amount of paths for remainder\\n                    amounts[y][x][newRem] = (amounts[y][x][newRem] + comingRoutesWithThisRemainder) % modulo;\\n                }\\n            }\\n        }\\n    }\\n    return amounts[rows - 1][cols - 1][0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3724256,
                "title": "3d-dp-basic-approach-sum-sum-grid-i-j-k",
                "content": "# Intuition\\nhad to do sum=(sum+grid[i][j])%k everywhere else its showing runtime error\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n int solve(int i,int j,vector<vector<int>> &grid,int sum,int k,vector<vector<vector<int>>> &dp)\\n {\\n     if(i==0 && j==0)\\n     {\\n       sum=(sum+grid[i][j])%k;\\n       if(sum%k==0)\\n       {\\n           return 1;\\n       }\\n       else\\n       {\\n           return 0;\\n       }\\n     }\\n     if(i<0 || j<0)\\n     {\\n         return 0;\\n     }\\n     if(dp[i][j][sum]!=-1)\\n     {\\n         return dp[i][j][sum];\\n     }\\n     int up=solve(i-1,j,grid,(sum+grid[i][j])%k,k,dp);\\n     int left=solve(i,j-1,grid,(sum+grid[i][j])%k,k,dp);\\n    return dp[i][j][sum%k]=(up+left)%mod;;\\n }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(k+1,-1)));\\n        int sum=0;\\n       return solve(m-1,n-1,grid,0,k,dp);\\n    //    return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n int solve(int i,int j,vector<vector<int>> &grid,int sum,int k,vector<vector<vector<int>>> &dp)\\n {\\n     if(i==0 && j==0)\\n     {\\n       sum=(sum+grid[i][j])%k;\\n       if(sum%k==0)\\n       {\\n           return 1;\\n       }\\n       else\\n       {\\n           return 0;\\n       }\\n     }\\n     if(i<0 || j<0)\\n     {\\n         return 0;\\n     }\\n     if(dp[i][j][sum]!=-1)\\n     {\\n         return dp[i][j][sum];\\n     }\\n     int up=solve(i-1,j,grid,(sum+grid[i][j])%k,k,dp);\\n     int left=solve(i,j-1,grid,(sum+grid[i][j])%k,k,dp);\\n    return dp[i][j][sum%k]=(up+left)%mod;;\\n }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(k+1,-1)));\\n        int sum=0;\\n       return solve(m-1,n-1,grid,0,k,dp);\\n    //    return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713623,
                "title": "95-in-both-runtime-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        MOD = 1_000_000_007\\n        m = len(grid)\\n        n = len(grid[0])\\n        dp = [[0] * k for _ in range(n)]\\n        s = 0\\n        for j in range(n):\\n            s += grid[0][j]\\n            dp[j][s % k] = 1\\n        for i in range(1, m):\\n            # Case of first column\\n            memo = [v for v in dp[0]] # Because not 3D dp array\\n            curr = grid[i][0]\\n            for ind in range(k):\\n                dp[0][(ind + curr) % k] = memo[ind] % MOD\\n            # Case of other columns\\n            for j in range(1, n):\\n                memo = [v for v in dp[j]] # Because not 3D dp array \\n                curr = grid[i][j]\\n                for ind in range(k):                    \\n                    dp[j][(ind + curr) % k] = (memo[ind] + dp[j - 1][ind]) % MOD\\n        \\n        return dp[-1][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        MOD = 1_000_000_007\\n        m = len(grid)\\n        n = len(grid[0])\\n        dp = [[0] * k for _ in range(n)]\\n        s = 0\\n        for j in range(n):\\n            s += grid[0][j]\\n            dp[j][s % k] = 1\\n        for i in range(1, m):\\n            # Case of first column\\n            memo = [v for v in dp[0]] # Because not 3D dp array\\n            curr = grid[i][0]\\n            for ind in range(k):\\n                dp[0][(ind + curr) % k] = memo[ind] % MOD\\n            # Case of other columns\\n            for j in range(1, n):\\n                memo = [v for v in dp[j]] # Because not 3D dp array \\n                curr = grid[i][j]\\n                for ind in range(k):                    \\n                    dp[j][(ind + curr) % k] = (memo[ind] + dp[j - 1][ind]) % MOD\\n        \\n        return dp[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709566,
                "title": "simple-c-solution-dynamic-programming-memoization-just-one-simple-observation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int x,int y,int curr,vector<vector<int>>& grid,int &k,int &m,int &n,vector<vector<vector<long long>>>&dp){\\n    if(x==m-1 && y==n-1){\\n        if((((curr%k)+(grid[x][y])%k)%k)==0)return 1;\\n        if((((curr%k)+(grid[x][y])%k)%k)!=0)return 0;\\n    }\\n    if(dp[x][y][curr]!=-1)return dp[x][y][curr];\\n    long long right=0;\\n    if(x<m && y<n)right=hope(x+1,y,(curr+grid[x][y]%k)%k,grid,k,m,n,dp)%mod;\\n    long long down=0;\\n    if(x<m && y<n)down=hope(x,y+1,(curr+grid[x][y]%k)%k,grid,k,m,n,dp)%mod;\\n    return dp[x][y][curr]=(right+down)%mod;\\n}\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<long long>>dp1(n+1,vector<long long>(k+1,-1));\\n        vector<vector<vector<long long>>>dp(m+1,dp1);\\n        long long answer=hope(0,0,0,grid,k,m,n,dp);\\n        int final=(int)answer%mod;\\n        return final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int x,int y,int curr,vector<vector<int>>& grid,int &k,int &m,int &n,vector<vector<vector<long long>>>&dp){\\n    if(x==m-1 && y==n-1){\\n        if((((curr%k)+(grid[x][y])%k)%k)==0)return 1;\\n        if((((curr%k)+(grid[x][y])%k)%k)!=0)return 0;\\n    }\\n    if(dp[x][y][curr]!=-1)return dp[x][y][curr];\\n    long long right=0;\\n    if(x<m && y<n)right=hope(x+1,y,(curr+grid[x][y]%k)%k,grid,k,m,n,dp)%mod;\\n    long long down=0;\\n    if(x<m && y<n)down=hope(x,y+1,(curr+grid[x][y]%k)%k,grid,k,m,n,dp)%mod;\\n    return dp[x][y][curr]=(right+down)%mod;\\n}\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<long long>>dp1(n+1,vector<long long>(k+1,-1));\\n        vector<vector<vector<long long>>>dp(m+1,dp1);\\n        long long answer=hope(0,0,0,grid,k,m,n,dp);\\n        int final=(int)answer%mod;\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708145,
                "title": "c-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> Moves = {{0,1}, {1,0}};\\n    int solve(vector<vector<vector<int>>>& dp, vector<vector<int>> &grid, int i, int j, int val, int k)\\n    {\\n        int n = grid.size(), m = grid[0].size(), ans = 0, mod = 1e9+7;\\n        if(i == n-1 && j == m-1)\\n        {\\n            if(val%k == 0)return dp[i][j][val] = 1;\\n            return dp[i][j][val] = 0;\\n        }\\n        if(dp[i][j][val]!=-1)return dp[i][j][val];\\n        for(auto &x : Moves)\\n        {\\n            int pos_x = i + x[0], pos_y = j + x[1];\\n            if(pos_x < n && pos_y < m)\\n                ans = (ans + solve(dp, grid, pos_x, pos_y, (val + grid[pos_x][pos_y])%k, k))%mod;\\n        }\\n        return dp[i][j][val] = ans;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0, mod = 1e9+7;\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int> (k, -1)));\\n        return solve(dp, grid, 0, 0, grid[0][0]%k, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> Moves = {{0,1}, {1,0}};\\n    int solve(vector<vector<vector<int>>>& dp, vector<vector<int>> &grid, int i, int j, int val, int k)\\n    {\\n        int n = grid.size(), m = grid[0].size(), ans = 0, mod = 1e9+7;\\n        if(i == n-1 && j == m-1)\\n        {\\n            if(val%k == 0)return dp[i][j][val] = 1;\\n            return dp[i][j][val] = 0;\\n        }\\n        if(dp[i][j][val]!=-1)return dp[i][j][val];\\n        for(auto &x : Moves)\\n        {\\n            int pos_x = i + x[0], pos_y = j + x[1];\\n            if(pos_x < n && pos_y < m)\\n                ans = (ans + solve(dp, grid, pos_x, pos_y, (val + grid[pos_x][pos_y])%k, k))%mod;\\n        }\\n        return dp[i][j][val] = ans;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0, mod = 1e9+7;\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int> (k, -1)));\\n        return solve(dp, grid, 0, 0, grid[0][0]%k, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706321,
                "title": "short-python-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first try the top-down approach because thats more intuitive and easier to come up with, but it fails with memory limit exceeded. So we try bottom-up.\\nThe only thing to remember is that we don\\'t need to keep track of all possible path sums and take the `%` at the end, we can safely take `%` along the path so the memory space for keeping all possible remainders do not exceed limit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep a 3-D array representing `(i, j, rem)` triplets. and for each index, set `(i, j, rem)` from previous values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m * n * k)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m * n * k)$$\\n\\n# Code\\n```\\n    def numberOfPaths(self, grid, target):\\n        m, n = len(grid), len(grid[0])\\n        DP = [[[0 for _ in range(target)] for _ in range(n+1)] for _ in range(m+1)]\\n        DP[1][0][0] = 1\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                for k in range(target):\\n                    DP[i][j][(k + grid[i-1][j-1]) % target] = (DP[i - 1][j][k] + DP[i][j - 1][k]) % 1_000_000_007\\n        return DP[-1][-1][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def numberOfPaths(self, grid, target):\\n        m, n = len(grid), len(grid[0])\\n        DP = [[[0 for _ in range(target)] for _ in range(n+1)] for _ in range(m+1)]\\n        DP[1][0][0] = 1\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                for k in range(target):\\n                    DP[i][j][(k + grid[i-1][j-1]) % target] = (DP[i - 1][j][k] + DP[i][j - 1][k]) % 1_000_000_007\\n        return DP[-1][-1][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3706140,
                "title": "dfs-with-memory-code-with-comments",
                "content": "\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // DFS, exhaustive search. Also utilize a memorizing_grid with size (m,n,k).\\n        // When we reach a cell we have been before, and we have reached\\n        // here with the same residue w.r.t. k, we can directly query instead of\\n        // going forward.\\n        vector<vector<vector<int>>> memorizing(grid.size(), \\n                                              vector<vector<int>>(grid[0].size(),\\n                                              vector<int>(k, -1)));\\n        height_ = grid.size();\\n        width_ = grid[0].size();\\n        return DFS(grid, /*x=*/0, /*y=*/0, /*residue_so_far=*/0, k, memorizing);\\n    }\\nprivate:\\n    const int mod_ = static_cast<int>(1e9) + 7;\\n    int height_ = -1;\\n    int width_ = -1;\\n    int DFS(const vector<vector<int>>& grid, int x, int y, int residue_so_far, int k,\\n            vector<vector<vector<int>>>& memorizing) {\\n        // Early return if out of boudnary.\\n        if (x >= height_ || y >= width_) {\\n            return 0;\\n        }\\n        // Calculate the current residue.\\n        const int residue = (residue_so_far + grid[x][y]) % k;\\n        // Termination criteria.\\n        if (x == height_ - 1 && y == width_ - 1) {\\n            if (residue == 0) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        // Check if we have visited here with the same residue before.\\n        if (memorizing[x][y][residue] != -1) {\\n            return memorizing[x][y][residue];\\n        }\\n        int go_right = DFS(grid, x, y+1, residue, k, memorizing);\\n        int go_down = DFS(grid, x+1, y, residue, k, memorizing);\\n        // update the memorizing grid.\\n        // Note this memory only applies to the future visit with the same residue w.r.t. k.\\n        return memorizing[x][y][residue] = (go_right + go_down)%mod_;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // DFS, exhaustive search. Also utilize a memorizing_grid with size (m,n,k).\\n        // When we reach a cell we have been before, and we have reached\\n        // here with the same residue w.r.t. k, we can directly query instead of\\n        // going forward.\\n        vector<vector<vector<int>>> memorizing(grid.size(), \\n                                              vector<vector<int>>(grid[0].size(),\\n                                              vector<int>(k, -1)));\\n        height_ = grid.size();\\n        width_ = grid[0].size();\\n        return DFS(grid, /*x=*/0, /*y=*/0, /*residue_so_far=*/0, k, memorizing);\\n    }\\nprivate:\\n    const int mod_ = static_cast<int>(1e9) + 7;\\n    int height_ = -1;\\n    int width_ = -1;\\n    int DFS(const vector<vector<int>>& grid, int x, int y, int residue_so_far, int k,\\n            vector<vector<vector<int>>>& memorizing) {\\n        // Early return if out of boudnary.\\n        if (x >= height_ || y >= width_) {\\n            return 0;\\n        }\\n        // Calculate the current residue.\\n        const int residue = (residue_so_far + grid[x][y]) % k;\\n        // Termination criteria.\\n        if (x == height_ - 1 && y == width_ - 1) {\\n            if (residue == 0) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        // Check if we have visited here with the same residue before.\\n        if (memorizing[x][y][residue] != -1) {\\n            return memorizing[x][y][residue];\\n        }\\n        int go_right = DFS(grid, x, y+1, residue, k, memorizing);\\n        int go_down = DFS(grid, x+1, y, residue, k, memorizing);\\n        // update the memorizing grid.\\n        // Note this memory only applies to the future visit with the same residue w.r.t. k.\\n        return memorizing[x][y][residue] = (go_right + go_down)%mod_;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700514,
                "title": "c-dp-memoization",
                "content": "class Solution {\\npublic:\\n    \\n    vector<vector<vector<int>>>dp;\\n    int mod=1e9+7;\\n    \\n    int solve(vector<vector<int>>&grid,int i,int j,int n,int m,int k,int count){\\n          \\n          if(i<0 or j<0 or i>=n or j>=m)return 0;\\n        \\n          if(i==n-1 and j==m-1){\\n              if(count%k==0)return 1;\\n              return 0;\\n          }\\n          \\n          if(dp[i][j][count%k]!=-1)return dp[i][j][count%k];\\n         \\n          int ways=0;\\n          if(j+1<m)ways+=solve(grid,i,j+1,n,m,k,count+grid[i][j+1])%mod;\\n          if(i+1<n)ways+=solve(grid,i+1,j,n,m,k,count+grid[i+1][j])%mod;\\n        \\n        return dp[i][j][count%k]=ways%mod;\\n    }\\n    \\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        dp.resize(grid.size(),vector<vector<int>>(grid[0].size(),vector<int>(k+1,-1)));\\n        return solve(grid,0,0,grid.size(),grid[0].size(),k,grid[0][0]);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<vector<vector<int>>>dp;\\n    int mod=1e9+7;\\n    \\n    int solve(vector<vector<int>>&grid,int i,int j,int n,int m,int k,int count){\\n          \\n          if(i<0 or j<0 or i>=n or j>=m)return 0;\\n        \\n          if(i==n-1 and j==m-1){\\n              if(count%k==0)return 1;\\n              return 0;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 3677785,
                "title": "self-explanatory-code-c-dp-tabulation",
                "content": "# Intuition\\ndp[i][j][k] : no. of ways of reaching (i, j) with k remainder.\\n        \\n\\n# Approach\\n    Self Explanatory code\\n# Complexity\\n- Time complexity:\\nO(n*m*k)\\n\\n- Space complexity:\\nO(n*m*k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int m, n;\\n    vector<vector<vector<long long>>> dp;\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        n = grid.size(), m = grid[0].size();\\n        dp.resize(n, vector<vector<long long>>(m, vector<long long>(k)));\\n        dp[n-1][m-1][grid[n-1][m-1]%k] = 1;\\n        int s = grid[n-1][m-1];\\n        for(int i=n-2; i>=0; i--){\\n            s+=grid[i][m-1];\\n            dp[i][m-1][s%k] = 1;\\n        }\\n        s = grid[n-1][m-1];\\n        for(int i=m-2; i>=0; i--){\\n            s+=grid[n-1][i];\\n            dp[n-1][i][s%k] = 1;\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            for(int j=m-2; j>=0; j--){\\n                for(int a = 0; a<k; a++){\\n                    int x = grid[i][j];\\n                    dp[i][j][(a+x)%k] = (dp[i+1][j][a] + dp[i][j+1][a])%mod;\\n                }\\n            }\\n        }\\n        return dp[0][0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int m, n;\\n    vector<vector<vector<long long>>> dp;\\n    \\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        n = grid.size(), m = grid[0].size();\\n        dp.resize(n, vector<vector<long long>>(m, vector<long long>(k)));\\n        dp[n-1][m-1][grid[n-1][m-1]%k] = 1;\\n        int s = grid[n-1][m-1];\\n        for(int i=n-2; i>=0; i--){\\n            s+=grid[i][m-1];\\n            dp[i][m-1][s%k] = 1;\\n        }\\n        s = grid[n-1][m-1];\\n        for(int i=m-2; i>=0; i--){\\n            s+=grid[n-1][i];\\n            dp[n-1][i][s%k] = 1;\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            for(int j=m-2; j>=0; j--){\\n                for(int a = 0; a<k; a++){\\n                    int x = grid[i][j];\\n                    dp[i][j][(a+x)%k] = (dp[i+1][j][a] + dp[i][j+1][a])%mod;\\n                }\\n            }\\n        }\\n        return dp[0][0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653782,
                "title": "easy-c-memoization-code-with-detailed-approach-explained",
                "content": "# Intuition\\nAs we have to find total number of paths so 2 approaches comes to our mind. Greedy or DP. As greedy Approach will be teadeous to write so we will try DP\\n\\n# Approach\\nFor each cell we have 2 choices either go down or go right (if you are starting from (0,0)). As we go ahead we have to update the sum also. So another variable for that. But finally we need to check the divisibility with k so we will keep track of sum%k as it will be smaller number than sum.\\n\\nBase case for this will be if we reached the final index (n-1,m-1). At that index we need to check whether sum is divisible by k or not. If yes then return 1 else return 0. \\n\\n# Complexity\\n- Time complexity:\\nO(mnk)\\n\\n- Space complexity:\\nO(mnk)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n\\n    int f(int x, int y, int k, ll sum, vector<vector<int>>& grid, int m, int n, vector<vector<vector<int>>> &dp){\\n        if(x<0 || y<0 || x>=n || y>=m) return 0;\\n        if(x==n-1 && y==m-1){\\n            if((sum+grid[x][y])%k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\n        if(dp[x][y][sum]!=-1) return dp[x][y][sum]; \\n\\n        int down = f(x+1,y,k,(sum+grid[x][y])%k,grid,m,n,dp)%mod;\\n        int right = f(x,y+1,k,(sum+grid[x][y])%k,grid,m,n,dp)%mod;\\n        return dp[x][y][sum%k]=(down+right)%mod;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        ll sum=0;\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(k+1,-1)));\\n        int ans = f(0,0,k,sum,grid,m,n,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n\\n    int f(int x, int y, int k, ll sum, vector<vector<int>>& grid, int m, int n, vector<vector<vector<int>>> &dp){\\n        if(x<0 || y<0 || x>=n || y>=m) return 0;\\n        if(x==n-1 && y==m-1){\\n            if((sum+grid[x][y])%k==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n\\n        if(dp[x][y][sum]!=-1) return dp[x][y][sum]; \\n\\n        int down = f(x+1,y,k,(sum+grid[x][y])%k,grid,m,n,dp)%mod;\\n        int right = f(x,y+1,k,(sum+grid[x][y])%k,grid,m,n,dp)%mod;\\n        return dp[x][y][sum%k]=(down+right)%mod;\\n    }\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        ll sum=0;\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(k+1,-1)));\\n        int ans = f(0,0,k,sum,grid,m,n,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646939,
                "title": "simple-java-solution-memoization-easy-understatnding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   static long mod=1000000007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n       long dp[][][]=new long[grid.length+1][grid[0].length+1][k+1];\\n        return (int)helper(dp,grid,k,0,0,0);\\n    }\\n    static long helper(long dp[][][],int[][] grid, int k,int i,int j,int sum){\\n        if(i<0 || j<0 || j>=grid[0].length || i>=grid.length){\\n            return 0;\\n        }\\n        sum+=grid[i][j];\\n         \\n        if(i==grid.length-1 && j==grid[0].length-1 && sum%k==0){\\n            return 1;\\n        }\\n       if(dp[i][j][sum%k]!=0){\\n           return dp[i][j][sum%k];\\n       }\\n        \\n\\n        long down=helper(dp,grid,k,i+1,j,sum);\\n        long right=helper(dp,grid,k,i,j+1,sum);\\n        return dp[i][j][sum%k]=(down%mod+right%mod)%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n   static long mod=1000000007;\\n    public int numberOfPaths(int[][] grid, int k) {\\n       long dp[][][]=new long[grid.length+1][grid[0].length+1][k+1];\\n        return (int)helper(dp,grid,k,0,0,0);\\n    }\\n    static long helper(long dp[][][],int[][] grid, int k,int i,int j,int sum){\\n        if(i<0 || j<0 || j>=grid[0].length || i>=grid.length){\\n            return 0;\\n        }\\n        sum+=grid[i][j];\\n         \\n        if(i==grid.length-1 && j==grid[0].length-1 && sum%k==0){\\n            return 1;\\n        }\\n       if(dp[i][j][sum%k]!=0){\\n           return dp[i][j][sum%k];\\n       }\\n        \\n\\n        long down=helper(dp,grid,k,i+1,j,sum);\\n        long right=helper(dp,grid,k,i,j+1,sum);\\n        return dp[i][j][sum%k]=(down%mod+right%mod)%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633190,
                "title": "c-100",
                "content": "```\\npublic class Solution {\\n    public int NumberOfPaths(int[][] grid, int k) {\\n        int n=grid.Length;\\n        int m=grid[0].Length;\\n        long MOD=1_000_000_000 +7;\\n       long[][] dp= Enumerable.Range(0,m).Select(x=>new long[k]).ToArray();\\n        dp[0][0]=1;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<m;j++){\\n                long[] t=new long[k];\\n                for(int s=0;s<k;s++){\\n                    int s2=(grid[i][j]+s)%k;\\n                    t[s2]=(dp[j][s]+(j>0 ?dp[j-1][s] : 0))%MOD;\\n                    \\n                }\\n                dp[j]=t;\\n\\n            }\\n        }\\n        return (int)dp[m-1][0];\\n                           \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumberOfPaths(int[][] grid, int k) {\\n        int n=grid.Length;\\n        int m=grid[0].Length;\\n        long MOD=1_000_000_000 +7;\\n       long[][] dp= Enumerable.Range(0,m).Select(x=>new long[k]).ToArray();\\n        dp[0][0]=1;\\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<m;j++){\\n                long[] t=new long[k];\\n                for(int s=0;s<k;s++){\\n                    int s2=(grid[i][j]+s)%k;\\n                    t[s2]=(dp[j][s]+(j>0 ?dp[j-1][s] : 0))%MOD;\\n                    \\n                }\\n                dp[j]=t;\\n\\n            }\\n        }\\n        return (int)dp[m-1][0];\\n                           \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594384,
                "title": "python-3-dp-bottom-up-fast-and-low-space",
                "content": "![Capture d\\u2019\\xE9cran 2023-06-03 212911.png](https://assets.leetcode.com/users/images/d14345d4-c408-4ec1-984d-d5c6e4bcba7c_1685824161.660193.png)\\n\\n\\n# Approach\\nA 2D `dp[j]` array, for the current row, is a `k`-length array. It contains numbers of paths to the square at column `j`. If the sum of the paths is `ind` modulo `k`, this number is at index `ind` of the `k`-length array)\\n\\nWhen `dp` array is obtained for the last row, we return the first element (i.e. `sum` == 0 modulo k) of the last `dp` element (i.e. column `n -1`)\\n\\n# Complexity\\n- Time complexity:\\n$O(m * n * k)$\\n\\n- Space complexity:\\n$O(n * k)$\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        MOD = 1_000_000_007\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        # 2D dp array\\n        dp = [[0] * k for _ in range(n)]\\n        \\n        # Case of first row of grid\\n        s = 0\\n        for j in range(n):\\n            s += grid[0][j]\\n            dp[j][s % k] = 1\\n        \\n        # Cases of other rows\\n        for i in range(1, m):\\n            # Case of first column\\n            memo = [v for v in dp[0]] # Because not 3D dp array\\n            curr = grid[i][0]\\n            for ind in range(k):\\n                dp[0][(ind + curr) % k] = memo[ind] % MOD\\n            # Case of other columns\\n            for j in range(1, n):\\n                memo = [v for v in dp[j]] # Because not 3D dp array \\n                curr = grid[i][j]\\n                for ind in range(k):                    \\n                    dp[j][(ind + curr) % k] = (memo[ind] + dp[j - 1][ind]) % MOD\\n        \\n        return dp[-1][0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        MOD = 1_000_000_007\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        # 2D dp array\\n        dp = [[0] * k for _ in range(n)]\\n        \\n        # Case of first row of grid\\n        s = 0\\n        for j in range(n):\\n            s += grid[0][j]\\n            dp[j][s % k] = 1\\n        \\n        # Cases of other rows\\n        for i in range(1, m):\\n            # Case of first column\\n            memo = [v for v in dp[0]] # Because not 3D dp array\\n            curr = grid[i][0]\\n            for ind in range(k):\\n                dp[0][(ind + curr) % k] = memo[ind] % MOD\\n            # Case of other columns\\n            for j in range(1, n):\\n                memo = [v for v in dp[j]] # Because not 3D dp array \\n                curr = grid[i][j]\\n                for ind in range(k):                    \\n                    dp[j][(ind + curr) % k] = (memo[ind] + dp[j - 1][ind]) % MOD\\n        \\n        return dp[-1][0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592345,
                "title": "simple-java-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe overall idea of the code is to recursively explore all possible paths from the top-left corner to the bottom-right corner while keeping track of the sum of values along the path. The constraint k is used to determine the validity of a path, and memoization is used to avoid redundant computations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The problem is solved using a recursive approach with memoization. The main function numberOfPaths initializes a 3D array dp to store the computed results for subproblems.\\n\\n2. The recursive helper function findPaths is called from numberOfPaths to find the number of valid paths. It takes the current position (i, j) in the grid, the current sum of values along the path sum, the constraint k, and the dp array as input.\\n\\n3. The base case of the recursion is when the function reaches the bottom-right corner of the grid. At this point, it checks if the sum of values along the path modulo k is equal to 0. If it is, it returns 1 (indicating a valid path), otherwise 0.\\n\\n4. Before performing any computation, the function checks if the result for the current subproblem is already stored in the dp array. If it is, the function directly returns the stored result, avoiding redundant computation.\\n\\n5. The function initializes a variable ways to keep track of the number of valid paths. It then explores two possible moves: moving down (i+1) and moving right (j+1) in the grid.\\n\\n6. For each valid move, the function updates the sum by adding the current grid value (sum + grid[i][j]) % k to handle the constraint. The updated sum is passed to the recursive call.\\n\\n7. The number of valid paths from the current position is added to the ways variable. However, to avoid integer overflow, the result is computed modulo (int)(1E9 + 7).\\n\\n8. Finally, the function stores the computed result in the dp array at index dp[i][j][sum] and returns it.\\n\\n# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m + n) + O(m * n * k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int[][][] dp = new int[grid.length][grid[0].length][k];\\n        for (int[][] d1 : dp) {\\n            for (int[] d2 : d1) Arrays.fill(d2, -1);\\n        }\\n        return findPaths(grid, 0, 0, 0, k, dp);\\n    }\\n\\n    private int findPaths(int[][] grid, int i, int j, int sum, int k, int[][][] dp) {\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            return (sum + grid[i][j]) % k == 0 ? 1 : 0;\\n        }\\n        if (dp[i][j][sum] != -1) return dp[i][j][sum];\\n        int ways = 0;\\n\\n        if (i + 1 < grid.length) {\\n            ways = (ways + findPaths(grid, i + 1, j, \\n            (sum + grid[i][j]) % k, k, dp)) % (int)(1E9 + 7);\\n        }\\n        if (j + 1 < grid[0].length) {\\n            ways = (ways + findPaths(grid, i, j + 1, \\n            (sum + grid[i][j]) % k, k, dp)) % (int)(1E9 + 7);\\n        }\\n        return dp[i][j][sum] = ways;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int[][][] dp = new int[grid.length][grid[0].length][k];\\n        for (int[][] d1 : dp) {\\n            for (int[] d2 : d1) Arrays.fill(d2, -1);\\n        }\\n        return findPaths(grid, 0, 0, 0, k, dp);\\n    }\\n\\n    private int findPaths(int[][] grid, int i, int j, int sum, int k, int[][][] dp) {\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            return (sum + grid[i][j]) % k == 0 ? 1 : 0;\\n        }\\n        if (dp[i][j][sum] != -1) return dp[i][j][sum];\\n        int ways = 0;\\n\\n        if (i + 1 < grid.length) {\\n            ways = (ways + findPaths(grid, i + 1, j, \\n            (sum + grid[i][j]) % k, k, dp)) % (int)(1E9 + 7);\\n        }\\n        if (j + 1 < grid[0].length) {\\n            ways = (ways + findPaths(grid, i, j + 1, \\n            (sum + grid[i][j]) % k, k, dp)) % (int)(1E9 + 7);\\n        }\\n        return dp[i][j][sum] = ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591979,
                "title": "dynamic-programming-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConfused between bruteforce or Dynamic programming and after sometime got clarity on DP approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nVia DP approach, at every cell in matrix, we need to calculate based on previous cells (top and left).\\n\\nWe have a new dimension \"K\", so that we store the cumulative sum % k  at any moment for that cell.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(mnk)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(mnk)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumberOfPaths(int[][] grid, int k) {\\n        // I can think of bruteforce traversal of all paths.\\n        // And in this case Dynamic programming wont work because we need to find all the possible way\\n        // lets try bruteforce traversal and can see if there is better solution\\n\\n        // Wait let me think again, in case of brute force, we end up calculating small set again and again.\\n\\n        // so the DP can look like\\n        // ki in (1 to k) \\n        // Count[(i,j), (sum+ki)%k] +=  count[(i-1,j), ki] \\n        // Count[(i,j), (sum+ki)%k] +=  count[(i,j-1), ki] \\n        // return count[(m-1, n-1), k]\\n\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n\\n        var count = new long[m*n, k];\\n        count[0, grid[0][0]%k] = 1;\\n\\n        // initialize first row\\n        for(int i=1;i<n;i++) {\\n            for(int d=0;d<k;d++) {\\n                count[i, (grid[0][i]+d)%k] += count[i-1, d];\\n            }\\n        }\\n\\n        // initialize first column\\n        for(int i=1;i<m;i++) {\\n            for(int d=0;d<k;d++) {\\n                count[i*n, (grid[i][0]+d)%k] += count[(i-1)*n, d];\\n            }\\n        }\\n\\n        for(int i=1;i<m;i++) {\\n            for(int j=1;j<n;j++) {\\n                for(int d=0;d<k;d++) {\\n                    count[i*n+j, (grid[i][j]+d)%k] += count[(i-1)*n+j, d] + count[i*n+j-1, d];\\n                    count[i*n+j, (grid[i][j]+d)%k] %= 1000000007;\\n                }\\n            }\\n        }\\n        \\n        return (int)(count[m*n-1, 0]%(1000000007));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumberOfPaths(int[][] grid, int k) {\\n        // I can think of bruteforce traversal of all paths.\\n        // And in this case Dynamic programming wont work because we need to find all the possible way\\n        // lets try bruteforce traversal and can see if there is better solution\\n\\n        // Wait let me think again, in case of brute force, we end up calculating small set again and again.\\n\\n        // so the DP can look like\\n        // ki in (1 to k) \\n        // Count[(i,j), (sum+ki)%k] +=  count[(i-1,j), ki] \\n        // Count[(i,j), (sum+ki)%k] +=  count[(i,j-1), ki] \\n        // return count[(m-1, n-1), k]\\n\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n\\n        var count = new long[m*n, k];\\n        count[0, grid[0][0]%k] = 1;\\n\\n        // initialize first row\\n        for(int i=1;i<n;i++) {\\n            for(int d=0;d<k;d++) {\\n                count[i, (grid[0][i]+d)%k] += count[i-1, d];\\n            }\\n        }\\n\\n        // initialize first column\\n        for(int i=1;i<m;i++) {\\n            for(int d=0;d<k;d++) {\\n                count[i*n, (grid[i][0]+d)%k] += count[(i-1)*n, d];\\n            }\\n        }\\n\\n        for(int i=1;i<m;i++) {\\n            for(int j=1;j<n;j++) {\\n                for(int d=0;d<k;d++) {\\n                    count[i*n+j, (grid[i][j]+d)%k] += count[(i-1)*n+j, d] + count[i*n+j-1, d];\\n                    count[i*n+j, (grid[i][j]+d)%k] %= 1000000007;\\n                }\\n            }\\n        }\\n        \\n        return (int)(count[m*n-1, 0]%(1000000007));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589039,
                "title": "easy-c-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M*K)\\n\\n- Space complexity:O(N*M*K) + O(N*M) (Stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int help(vector<vector<int>>& grid, int i,int j,int sum,int k,vector<vector<vector<int>>> &dp){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i==n-1&&j==m-1){\\n            if((sum+grid[i][j])%k) return dp[i][j][sum%k]=0;\\n            return dp[i][j][sum%k]=1;\\n        }\\n        if(i>=n||j>=m){\\n            return 0;\\n        }\\n        if(dp[i][j][sum%k]!=-1) return dp[i][j][sum%k];\\n\\n        int a=help(grid,i+1,j,sum+grid[i][j],k,dp);\\n        int b=help(grid,i,j+1,sum+grid[i][j],k,dp);\\n\\n        return dp[i][j][sum%k]=(a+b)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(m+1,vector<int>(k,-1)));\\n        return help(grid,0,0,0,k,dp)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int help(vector<vector<int>>& grid, int i,int j,int sum,int k,vector<vector<vector<int>>> &dp){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i==n-1&&j==m-1){\\n            if((sum+grid[i][j])%k) return dp[i][j][sum%k]=0;\\n            return dp[i][j][sum%k]=1;\\n        }\\n        if(i>=n||j>=m){\\n            return 0;\\n        }\\n        if(dp[i][j][sum%k]!=-1) return dp[i][j][sum%k];\\n\\n        int a=help(grid,i+1,j,sum+grid[i][j],k,dp);\\n        int b=help(grid,i,j+1,sum+grid[i][j],k,dp);\\n\\n        return dp[i][j][sum%k]=(a+b)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(m+1,vector<int>(k,-1)));\\n        return help(grid,0,0,0,k,dp)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587789,
                "title": "z-z-is-for-zither-zither",
                "content": "# Intuition\\nI got no damned clue, i came up with it in between customers at work.  Essentially run a DFS with a memo block handy.  It\\'s like, 3 variables so its not terrible.  This is like, abstract algebra with extra steps.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        #another episode of OW MY BALLS\\n        N, M = len(grid), len(grid[0])\\n        MODULO = 10 ** 9 + 7\\n\\n        if k == 1:\\n            return math.comb((N + M - 2), (N - 1)) % MODULO\\n\\n        #might as well save some big sums...\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                grid[i][j] = grid[i][j] % k\\n\\n        #construct memo[_n, _m, _k], save runtime on modularly similar spaces\\n        memo = [[[-1 for _k in range(k)] for _m in range(M)] for _n in range(N)]\\n\\n        def dfs(n, m, curSum): #n and m coordinates, and current sum in |k| integer space\\n            nonlocal memo, grid\\n            \\n            if ((n == N) or (m == M)):\\n                return 0\\n            elif memo[n][m][curSum] != -1:\\n                return memo[n][m][curSum]\\n            elif ((n == N - 1) and (m == M - 1)):\\n                fullSum = (curSum + grid[n][m])\\n                return 1 if fullSum % k == 0 else 0\\n            else:\\n                nextSum = (curSum + grid[n][m]) % k\\n                validPaths = (dfs(n + 1, m, nextSum) + dfs(n, m + 1, nextSum)) % MODULO\\n                memo[n][m][curSum] = validPaths\\n                return validPaths \\n\\n        return dfs(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n        #another episode of OW MY BALLS\\n        N, M = len(grid), len(grid[0])\\n        MODULO = 10 ** 9 + 7\\n\\n        if k == 1:\\n            return math.comb((N + M - 2), (N - 1)) % MODULO\\n\\n        #might as well save some big sums...\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                grid[i][j] = grid[i][j] % k\\n\\n        #construct memo[_n, _m, _k], save runtime on modularly similar spaces\\n        memo = [[[-1 for _k in range(k)] for _m in range(M)] for _n in range(N)]\\n\\n        def dfs(n, m, curSum): #n and m coordinates, and current sum in |k| integer space\\n            nonlocal memo, grid\\n            \\n            if ((n == N) or (m == M)):\\n                return 0\\n            elif memo[n][m][curSum] != -1:\\n                return memo[n][m][curSum]\\n            elif ((n == N - 1) and (m == M - 1)):\\n                fullSum = (curSum + grid[n][m])\\n                return 1 if fullSum % k == 0 else 0\\n            else:\\n                nextSum = (curSum + grid[n][m]) % k\\n                validPaths = (dfs(n + 1, m, nextSum) + dfs(n, m + 1, nextSum)) % MODULO\\n                memo[n][m][curSum] = validPaths\\n                return validPaths \\n\\n        return dfs(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587632,
                "title": "java-o-mnk-tabulation-beats-99-dp",
                "content": "```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int mod = 1000000007;\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] mem = new int[m+1][n+1][k];\\n        mem[0][1][0] = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int u = i + 1, v = j + 1;\\n                int val = grid[i][j];\\n                for (int l = 0; l < k; l++) {\\n                    mem[u][v][(l+val) % k] = (mem[u][v-1][l] + mem[u-1][v][l])%mod;\\n                }\\n            }\\n        }\\n        return mem[m][n][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int mod = 1000000007;\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] mem = new int[m+1][n+1][k];\\n        mem[0][1][0] = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int u = i + 1, v = j + 1;\\n                int val = grid[i][j];\\n                for (int l = 0; l < k; l++) {\\n                    mem[u][v][(l+val) % k] = (mem[u][v-1][l] + mem[u-1][v][l])%mod;\\n                }\\n            }\\n        }\\n        return mem[m][n][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586592,
                "title": "c-dp-recursion-memoization-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long dfs(int i,int j,int m,int n,vector<vector<int>>& arr,int k,int sum,vector<vector<vector<int>>>& dp){\\n        if(i==m-1 and j==n-1){\\n            if(sum==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][j][sum]!=-1){\\n            return dp[i][j][sum];\\n        }\\n        long long ans=0;\\n        if(j+1<n){\\n            ans=(ans + dfs(i,j+1,m,n,arr,k,(sum+arr[i][j+1])%k,dp))%mod;\\n        }\\n        if(i+1<m){\\n            ans=(ans + dfs(i+1,j,m,n,arr,k,(sum+arr[i+1][j])%k,dp))%mod;\\n        }\\n        return dp[i][j][sum]=(ans%mod);\\n    }\\n    int numberOfPaths(vector<vector<int>>& arr, int k) {\\n        int m=arr.size();\\n        int n=arr[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(50,-1)));\\n        return dfs(0,0,m,n,arr,k,arr[0][0]%k,dp)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long dfs(int i,int j,int m,int n,vector<vector<int>>& arr,int k,int sum,vector<vector<vector<int>>>& dp){\\n        if(i==m-1 and j==n-1){\\n            if(sum==0){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[i][j][sum]!=-1){\\n            return dp[i][j][sum];\\n        }\\n        long long ans=0;\\n        if(j+1<n){\\n            ans=(ans + dfs(i,j+1,m,n,arr,k,(sum+arr[i][j+1])%k,dp))%mod;\\n        }\\n        if(i+1<m){\\n            ans=(ans + dfs(i+1,j,m,n,arr,k,(sum+arr[i+1][j])%k,dp))%mod;\\n        }\\n        return dp[i][j][sum]=(ans%mod);\\n    }\\n    int numberOfPaths(vector<vector<int>>& arr, int k) {\\n        int m=arr.size();\\n        int n=arr[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(50,-1)));\\n        return dfs(0,0,m,n,arr,k,arr[0][0]%k,dp)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586370,
                "title": "tle-removed-easy-to-understand-cpp-solution",
                "content": "# approach\\n\\nuse dynamic programming, just the catch is , keep the third state sum\\nin the range of 0 to k-1 by taking modulo by k at each step.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int M = (int)(1e9 + 7);\\n\\n    vector<vector<vector<int>>> dp;\\n\\n    int solve(int row, int col, vector<vector<int>>& grid, int k, int sum){\\n\\n        if (row >= grid.size() || col >= grid[0].size()){\\n            return 0;\\n        }\\n\\n        sum =  (sum % k + grid[row][col] % k) % k;\\n\\n        if (row == grid.size()-1 && col == grid[0].size()-1){\\n            return (sum % k == 0);\\n        }\\n\\n        if (dp[row][col][sum] != -1) return dp[row][col][sum];\\n\\n        int ans = 0;\\n\\n        ans =  (ans % M + solve(row+1, col, grid, k , sum) % M) % M;\\n        ans = (ans % M + solve(row, col+1, grid, k , sum) % M) % M;\\n\\n        return dp[row][col][sum] = ans%M;\\n    }\\n\\npublic:\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        dp= vector<vector<vector<int>>>(m,vector<vector<int>>(n, vector<int>(k,-1)));\\n        int ans = solve(0 , 0 , grid, k, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    int M = (int)(1e9 + 7);\\n\\n    vector<vector<vector<int>>> dp;\\n\\n    int solve(int row, int col, vector<vector<int>>& grid, int k, int sum){\\n\\n        if (row >= grid.size() || col >= grid[0].size()){\\n            return 0;\\n        }\\n\\n        sum =  (sum % k + grid[row][col] % k) % k;\\n\\n        if (row == grid.size()-1 && col == grid[0].size()-1){\\n            return (sum % k == 0);\\n        }\\n\\n        if (dp[row][col][sum] != -1) return dp[row][col][sum];\\n\\n        int ans = 0;\\n\\n        ans =  (ans % M + solve(row+1, col, grid, k , sum) % M) % M;\\n        ans = (ans % M + solve(row, col+1, grid, k , sum) % M) % M;\\n\\n        return dp[row][col][sum] = ans%M;\\n    }\\n\\npublic:\\n\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        dp= vector<vector<vector<int>>>(m,vector<vector<int>>(n, vector<int>(k,-1)));\\n        int ans = solve(0 , 0 , grid, k, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586026,
                "title": "python-clean-solution-dp-memoization",
                "content": "# Complexity\\n- Time complexity: O( m * n * k )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n- Space complexity: O( m * n * k )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        dp = {}\\n        mod = 7 + 10**9\\n\\n        def dfs(r, c):\\n\\n            if (r, c) in dp:\\n                return dp[(r, c)]\\n\\n            temp = [0 for i in range(k)]\\n\\n            if r == m-1 and c == n-1:\\n                v = grid[r][c]%k\\n                temp[v] = 1\\n                dp[(r, c)] = temp\\n                return temp\\n\\n            if r+1 < m:\\n                ret = dfs(r+1, c)\\n\\n                for i, val in enumerate(ret):\\n                    if val!=0:\\n                        box = (i + grid[r][c])%k\\n                        temp[box]+=val\\n                        temp[box] %= mod\\n\\n            if c+1 < n:\\n                ret = dfs(r, c+1)\\n\\n                for i, val in enumerate(ret):\\n                    if val!=0:\\n                        box = (i + grid[r][c])%k\\n                        temp[box]+=val\\n                        temp[box] %= mod\\n\\n            dp[(r, c)] = temp\\n            return temp\\n\\n        res = dfs(0, 0)\\n        return res[0]\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        dp = {}\\n        mod = 7 + 10**9\\n\\n        def dfs(r, c):\\n\\n            if (r, c) in dp:\\n                return dp[(r, c)]\\n\\n            temp = [0 for i in range(k)]\\n\\n            if r == m-1 and c == n-1:\\n                v = grid[r][c]%k\\n                temp[v] = 1\\n                dp[(r, c)] = temp\\n                return temp\\n\\n            if r+1 < m:\\n                ret = dfs(r+1, c)\\n\\n                for i, val in enumerate(ret):\\n                    if val!=0:\\n                        box = (i + grid[r][c])%k\\n                        temp[box]+=val\\n                        temp[box] %= mod\\n\\n            if c+1 < n:\\n                ret = dfs(r, c+1)\\n\\n                for i, val in enumerate(ret):\\n                    if val!=0:\\n                        box = (i + grid[r][c])%k\\n                        temp[box]+=val\\n                        temp[box] %= mod\\n\\n            dp[(r, c)] = temp\\n            return temp\\n\\n        res = dfs(0, 0)\\n        return res[0]\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585947,
                "title": "easy-c-code-recursive-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis Problem can be solved using recursive memoization technique in dp.\\nSo we are going to explore every possibility to reach from first (0,0) to (n-1,m-1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this code is as follows:\\n\\nThe solve function is a recursive function that takes the current position (i, j) in the grid, the current sum of values along the path curr_sum, the grid itself, and the value of k. It returns the number of paths satisfying the conditions.\\n\\nThe base cases are as follows:\\n\\nIf the current position is the bottom-right cell (n-1, m-1), we check if the sum of values along the path curr_sum plus the value of the current cell is divisible by k. If it is divisible, we return 1 (indicating that we have found a valid path), otherwise, we return 0.\\nIf the current position is outside the grid (i.e., i >= n or j >= m), we return 0.\\nThe code checks if the solution for the current position (i, j) and the current sum curr_sum is already computed and stored in the dp array. If it is, the stored value is returned.\\n\\nIf the solution for the current position (i, j) and the current sum curr_sum is not computed yet, the code recursively calls the solve function for the next positions:\\n\\n(i+1, j) (moving down) with the updated sum (curr_sum + grid[i][j]) % k\\n(i, j+1) (moving right) with the updated sum (curr_sum + grid[i][j]) % k\\nThe values returned by these recursive calls are added together modulo mod and stored in the dp array for memoization.\\n\\nFinally, the numberOfPaths function initializes the dp array with -1 values, calls the solve function with the initial position (0, 0), initial sum 0, and returns the result.\\n\\n# Complexity\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m*k)$$\\n\\nSpace complexity:\\n\\n$$O(n*m*k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>>dp;\\n    int mod = 1e9+7;\\n    int solve(int i,int j,int curr_sum,vector<vector<int>>&grid,int &k){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i==n-1&&j==m-1){\\n            return (curr_sum+grid[i][j])%k==0;\\n        }\\n        if(i>=n || j>=m)return 0;\\n        if(dp[i][j][curr_sum]!=-1){\\n            return dp[i][j][curr_sum]%mod;\\n        }\\n        int x = solve(i+1,j,(curr_sum+grid[i][j])%k,grid,k)%mod;\\n        int y = solve(i,j+1,(curr_sum+grid[i][j])%k,grid,k)%mod;\\n        return dp[i][j][curr_sum] =  (x +  y)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        dp.resize(n+1,vector<vector<int>>(m+1,vector<int>(k+1,-1)));\\n        return solve(0,0,0,grid,k);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>>dp;\\n    int mod = 1e9+7;\\n    int solve(int i,int j,int curr_sum,vector<vector<int>>&grid,int &k){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i==n-1&&j==m-1){\\n            return (curr_sum+grid[i][j])%k==0;\\n        }\\n        if(i>=n || j>=m)return 0;\\n        if(dp[i][j][curr_sum]!=-1){\\n            return dp[i][j][curr_sum]%mod;\\n        }\\n        int x = solve(i+1,j,(curr_sum+grid[i][j])%k,grid,k)%mod;\\n        int y = solve(i,j+1,(curr_sum+grid[i][j])%k,grid,k)%mod;\\n        return dp[i][j][curr_sum] =  (x +  y)%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        dp.resize(n+1,vector<vector<int>>(m+1,vector<int>(k+1,-1)));\\n        return solve(0,0,0,grid,k);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585732,
                "title": "c-clean-easy-to-understand-dfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int is_valid(int r, int c, int n, int m) {\\n        return !((r < 0) || (c < 0) || (c >= n) || (r >= m));\\n    }\\n\\n    void find(vector<vector<int>> &grid,vector<vector<int>> &visited, int k, int row, int col,vector<vector<vector<int>>> &dp) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if(visited[row][col])\\n            return;\\n        \\n        visited[row][col] = 1;\\n\\n        if ((row == (m-1)) &&  (col == (n-1))) {\\n            int per_mod = grid[row][col] % k; \\n            dp[row][col][per_mod] = 1;\\n            return;\\n        }\\n\\n        vector<int> dis_x({1,0});\\n        vector<int> dis_y({0,1});\\n\\n        long ans = 0; \\n        int curr_mod = grid[row][col] % k;\\n\\n        for(int i = 0;i<dis_x.size();i++) {\\n            int x = row + dis_x[i];\\n            int y = col + dis_y[i];\\n            if(!is_valid(x, y, n, m))\\n                continue;\\n            \\n            find(grid,visited, k, x, y, dp);\\n\\n            for(int j=0;j<k;j++) {\\n                int mod = (curr_mod + j) % k;\\n                dp[row][col][mod] = ((long)dp[row][col][mod] + (long)dp[x][y][j]) % 1000000007;\\n            }\\n\\n        }\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size(); \\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k+1,0)));\\n        find(grid,visited,k,0,0,dp);\\n        int ans = dp[0][0][0];\\n        visited.clear();\\n        dp.clear();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int is_valid(int r, int c, int n, int m) {\\n        return !((r < 0) || (c < 0) || (c >= n) || (r >= m));\\n    }\\n\\n    void find(vector<vector<int>> &grid,vector<vector<int>> &visited, int k, int row, int col,vector<vector<vector<int>>> &dp) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if(visited[row][col])\\n            return;\\n        \\n        visited[row][col] = 1;\\n\\n        if ((row == (m-1)) &&  (col == (n-1))) {\\n            int per_mod = grid[row][col] % k; \\n            dp[row][col][per_mod] = 1;\\n            return;\\n        }\\n\\n        vector<int> dis_x({1,0});\\n        vector<int> dis_y({0,1});\\n\\n        long ans = 0; \\n        int curr_mod = grid[row][col] % k;\\n\\n        for(int i = 0;i<dis_x.size();i++) {\\n            int x = row + dis_x[i];\\n            int y = col + dis_y[i];\\n            if(!is_valid(x, y, n, m))\\n                continue;\\n            \\n            find(grid,visited, k, x, y, dp);\\n\\n            for(int j=0;j<k;j++) {\\n                int mod = (curr_mod + j) % k;\\n                dp[row][col][mod] = ((long)dp[row][col][mod] + (long)dp[x][y][j]) % 1000000007;\\n            }\\n\\n        }\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size(); \\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k+1,0)));\\n        find(grid,visited,k,0,0,dp);\\n        int ans = dp[0][0][0];\\n        visited.clear();\\n        dp.clear();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585153,
                "title": "java-easy-solution-dp",
                "content": "\\n# Complexity\\n- Time complexity: $$O(m*n*k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//RITIK PATEL\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = grid[i][j]%k;\\n            }\\n        }\\n        HashMap<Pair<Integer,Integer>,int[]> DP = new HashMap();\\n        int ans[] = new int[k];\\n        ans[grid[m-1][n-1]] = 1;\\n        DP.put(new Pair(m-1,n-1), ans);\\n        for(int i=m-1; i>=0; i--){\\n            for(int j=n-1; j>=0; j--){\\n                int right[];\\n                int down[];\\n                //check left\\n                if(j+1<grid[0].length){\\n                    right = DP.get(new Pair(i, j+1));\\n                }\\n                else{\\n                    right = new int[k];\\n                }\\n                //check down\\n                if(i+1<grid.length){\\n                    down = DP.get(new Pair(i+1,j));\\n                }\\n                else{\\n                    down = new int[k];\\n                }\\n                for(int ind=0; ind<k; ind++){\\n                    down[ind] = (down[ind] + right[ind])%1000000007;\\n                }\\n                int []Ans = new int[k];\\n                for(int ind=0; ind<k; ind++){\\n                    Ans[(ind+grid[i][j])%k] = down[ind];\\n                }\\n                \\n                if(i==m-1&&j==n-1) continue;\\n                DP.put(new Pair(i,j), Ans);\\n            }\\n        }\\n        return (int)DP.get(new Pair(0,0))[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//RITIK PATEL\\nclass Solution {\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] = grid[i][j]%k;\\n            }\\n        }\\n        HashMap<Pair<Integer,Integer>,int[]> DP = new HashMap();\\n        int ans[] = new int[k];\\n        ans[grid[m-1][n-1]] = 1;\\n        DP.put(new Pair(m-1,n-1), ans);\\n        for(int i=m-1; i>=0; i--){\\n            for(int j=n-1; j>=0; j--){\\n                int right[];\\n                int down[];\\n                //check left\\n                if(j+1<grid[0].length){\\n                    right = DP.get(new Pair(i, j+1));\\n                }\\n                else{\\n                    right = new int[k];\\n                }\\n                //check down\\n                if(i+1<grid.length){\\n                    down = DP.get(new Pair(i+1,j));\\n                }\\n                else{\\n                    down = new int[k];\\n                }\\n                for(int ind=0; ind<k; ind++){\\n                    down[ind] = (down[ind] + right[ind])%1000000007;\\n                }\\n                int []Ans = new int[k];\\n                for(int ind=0; ind<k; ind++){\\n                    Ans[(ind+grid[i][j])%k] = down[ind];\\n                }\\n                \\n                if(i==m-1&&j==n-1) continue;\\n                DP.put(new Pair(i,j), Ans);\\n            }\\n        }\\n        return (int)DP.get(new Pair(0,0))[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584949,
                "title": "c-dp-recursion-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int mod=1e9+7;\\n    int solve(int i,int j,int sum,vector<vector<vector<int>>>& dp,int k,vector<vector<int>>& grid)\\n    {\\n        if(i>=m || j>=n || i<0 || j<0)\\n            return 0;\\n        if(i==m-1 && j==n-1)\\n        {\\n            sum+=grid[i][j];\\n            return (sum%k==0);\\n        }\\n        if(dp[i][j][sum%k]!=-1)\\n            return dp[i][j][sum%k];\\n        long long down = solve(i+1,j,sum+grid[i][j],dp,k,grid);\\n        long long right = solve(i,j+1,sum+grid[i][j],dp,k,grid);\\n        long long res = (down+right)%mod;\\n        return dp[i][j][sum%k]=res;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(51,-1)));\\n        return solve(0,0,0,dp,k,grid);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int mod=1e9+7;\\n    int solve(int i,int j,int sum,vector<vector<vector<int>>>& dp,int k,vector<vector<int>>& grid)\\n    {\\n        if(i>=m || j>=n || i<0 || j<0)\\n            return 0;\\n        if(i==m-1 && j==n-1)\\n        {\\n            sum+=grid[i][j];\\n            return (sum%k==0);\\n        }\\n        if(dp[i][j][sum%k]!=-1)\\n            return dp[i][j][sum%k];\\n        long long down = solve(i+1,j,sum+grid[i][j],dp,k,grid);\\n        long long right = solve(i,j+1,sum+grid[i][j],dp,k,grid);\\n        long long res = (down+right)%mod;\\n        return dp[i][j][sum%k]=res;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(51,-1)));\\n        return solve(0,0,0,dp,k,grid);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584809,
                "title": "recursive-3d-dp-easy-to-understand-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n      int MOD=1e9+7;\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n      \\n        int n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m+1,vector<vector<int>>(n+1,vector<int>(k,-1)));\\n        int sum=0;\\n        sum+=grid[0][0];\\n       return  dfs(0,0,k,sum,sum%k,grid,dp)%MOD;\\n    }\\n    int dfs(int row,int col,int k,int sum,int rem,vector<vector<int>>& grid,vector<vector<vector<int>>>& dp)\\n    {\\n        if(row>=grid.size()||col>=grid[0].size())\\n        return 0;\\n        if(row==grid.size()-1&&col==grid[0].size()-1)\\n        {\\n            if(sum%k==0)\\n            return 1;\\n        }\\n        if(dp[row][col][rem]!=-1)\\n        return dp[row][col][rem];\\n        int r2=row,c2=col+1;\\n        int a=0;\\n        if(c2>=0&&c2<grid[0].size())\\n        {\\n           a= dfs(r2,c2,k,sum+grid[r2][c2],(sum+grid[r2][c2])%k,grid,dp);\\n        }\\n        int r1=row+1,c1=col;\\n        int b=0;\\n        if(r1>=0&&r1<grid.size())\\n        {\\n            b=dfs(r1,c1,k,sum+grid[r1][c1],(sum+grid[r1][c1])%k,grid,dp);\\n        }\\n        return dp[row][col][rem]=(a+b)%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n      int MOD=1e9+7;\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m=grid.size();\\n      \\n        int n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m+1,vector<vector<int>>(n+1,vector<int>(k,-1)));\\n        int sum=0;\\n        sum+=grid[0][0];\\n       return  dfs(0,0,k,sum,sum%k,grid,dp)%MOD;\\n    }\\n    int dfs(int row,int col,int k,int sum,int rem,vector<vector<int>>& grid,vector<vector<vector<int>>>& dp)\\n    {\\n        if(row>=grid.size()||col>=grid[0].size())\\n        return 0;\\n        if(row==grid.size()-1&&col==grid[0].size()-1)\\n        {\\n            if(sum%k==0)\\n            return 1;\\n        }\\n        if(dp[row][col][rem]!=-1)\\n        return dp[row][col][rem];\\n        int r2=row,c2=col+1;\\n        int a=0;\\n        if(c2>=0&&c2<grid[0].size())\\n        {\\n           a= dfs(r2,c2,k,sum+grid[r2][c2],(sum+grid[r2][c2])%k,grid,dp);\\n        }\\n        int r1=row+1,c1=col;\\n        int b=0;\\n        if(r1>=0&&r1<grid.size())\\n        {\\n            b=dfs(r1,c1,k,sum+grid[r1][c1],(sum+grid[r1][c1])%k,grid,dp);\\n        }\\n        return dp[row][col][rem]=(a+b)%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584184,
                "title": "paths-in-matrix-with-sum-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int n,m,cnt,mod,K;\\n    vector<vector<vector<int>>> dp;\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n            n=grid.size();m=grid[0].size();\\n              K=k;\\n              mod=1e9+7;\\n              dp.resize(n,vector<vector<int>>(m,vector<int>(k,-1)));\\n              return dfs(0,0,0,grid);\\n              \\n    }\\n\\n     int  dfs(int i, int j,int rem,vector<vector<int>>& grid)\\n     {\\n         \\n         if(i<0 || j<0 || i>=n || j>=m)\\n         return 0;\\n         if(dp[i][j][rem]!=-1) return dp[i][j][rem];\\n         int p=(grid[i][j]+rem)%K;\\n         if(i==n-1 && j==m-1)\\n         {\\n             if(p==0)\\n             {\\n                 return dp[i][j][rem]=1;\\n             }\\n            //  return 0;\\n         }\\n        \\n         int right=dfs(i+1,j,p,grid);\\n         int down=dfs(i,j+1,p,grid);\\n         dp[i][j][rem]=(right+down)%mod;\\n        //  cout<<i<<j<<\" \"<<dp[i][j]<<\"return\"<<endl;\\n         return dp[i][j][rem];\\n     }\\n    \\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    int n,m,cnt,mod,K;\\n    vector<vector<vector<int>>> dp;\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n            n=grid.size();m=grid[0].size();\\n              K=k;\\n              mod=1e9+7;\\n              dp.resize(n,vector<vector<int>>(m,vector<int>(k,-1)));\\n              return dfs(0,0,0,grid);\\n              \\n    }\\n\\n     int  dfs(int i, int j,int rem,vector<vector<int>>& grid)\\n     {\\n         \\n         if(i<0 || j<0 || i>=n || j>=m)\\n         return 0;\\n         if(dp[i][j][rem]!=-1) return dp[i][j][rem];\\n         int p=(grid[i][j]+rem)%K;\\n         if(i==n-1 && j==m-1)\\n         {\\n             if(p==0)\\n             {\\n                 return dp[i][j][rem]=1;\\n             }\\n            //  return 0;\\n         }\\n        \\n         int right=dfs(i+1,j,p,grid);\\n         int down=dfs(i,j+1,p,grid);\\n         dp[i][j][rem]=(right+down)%mod;\\n        //  cout<<i<<j<<\" \"<<dp[i][j]<<\"return\"<<endl;\\n         return dp[i][j][rem];\\n     }\\n    \\n\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3552733,
                "title": "dp-bottom-up-python-simple-as-possible",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is the most simplest solution that I could think of after grappling\\nwith a tonne of DP and backtracking approaches. I find that this code is a lot more simpler and cleaner than most of the solutions out there. \\nhope it helps\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthe approach is bottom up as its the most space and time efficient. the key insight that I got from one of the solutions is that I only need to store k options at each dp[i][j]. the main insight was that the remainder itself becomes the index and I just need to update the dp counts from dp[i+1][j] and dp[i][j+1] for each k\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ntime = O(m*n*k) -> I really don\\'t know how to improve this any further\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace = O(m*n*k) again\\n# Code\\n```\\nclass Solution(object):\\n    def numberOfPaths(self, grid, k):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n        if m==0 and n==0:\\n            return 0\\n        mod = (10**9) + 7\\n        dp = [[[0 for _ in range(k)] for _ in range(n)]for _ in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                if i==m-1 and j==n-1:\\n                    cell_rem = grid[i][j]%k\\n                    dp[i][j][cell_rem] = 1\\n                    continue\\n                for l in range(k):\\n                    if i+1<m:\\n                        p = (grid[i][j]+l) % k\\n                        dp[i][j][p] += dp[i+1][j][l]\\n                    if j+1<n:\\n                        q = (grid[i][j]+l) % k\\n                        dp[i][j][q] += dp[i][j+1][l]\\n        #print(dp)\\n        res = dp[0][0][0]\\n        return res%mod\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numberOfPaths(self, grid, k):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n        if m==0 and n==0:\\n            return 0\\n        mod = (10**9) + 7\\n        dp = [[[0 for _ in range(k)] for _ in range(n)]for _ in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                if i==m-1 and j==n-1:\\n                    cell_rem = grid[i][j]%k\\n                    dp[i][j][cell_rem] = 1\\n                    continue\\n                for l in range(k):\\n                    if i+1<m:\\n                        p = (grid[i][j]+l) % k\\n                        dp[i][j][p] += dp[i+1][j][l]\\n                    if j+1<n:\\n                        q = (grid[i][j]+l) % k\\n                        dp[i][j][q] += dp[i][j+1][l]\\n        #print(dp)\\n        res = dp[0][0][0]\\n        return res%mod\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552553,
                "title": "c-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthere are 2 points to keep in mind :\\n\\n1. instead of storing path sum, store its modulus with k, this will reduce the size of dp array otherwise it will go out of bound\\n2. instead of creating 3d array by storing r and c seperately, store r*col_size+c as a single parameter. This will allow us to create a 2d array of allowed size.\\n\\nThese are the main key points of this problem, otherwise it is more like a medium dp problem. I hope it helps :)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dp[50001][51];\\n    int solve(vector<vector<int>>& grid,int r, int c, int sum, int k){\\n        int n=grid[0].size();\\n        if(r==grid.size()-1 && c==grid[0].size()-1)return (grid[r][c]+sum)%k==0;\\n        if(dp[r*n+c][sum]!=-1)return dp[r*n+c][sum];\\n        long long ans=0;\\n        if(r!=grid.size()-1) ans+=solve(grid,r+1,c,(sum+grid[r][c])%k,k)%mod;\\n        if(c!=grid[0].size()-1)ans+=solve(grid,r,c+1,(sum+grid[r][c])%k,k)%mod;\\n        return dp[r*n+c][sum]=ans%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        cout<<grid.size();\\n        return solve(grid,0,0,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dp[50001][51];\\n    int solve(vector<vector<int>>& grid,int r, int c, int sum, int k){\\n        int n=grid[0].size();\\n        if(r==grid.size()-1 && c==grid[0].size()-1)return (grid[r][c]+sum)%k==0;\\n        if(dp[r*n+c][sum]!=-1)return dp[r*n+c][sum];\\n        long long ans=0;\\n        if(r!=grid.size()-1) ans+=solve(grid,r+1,c,(sum+grid[r][c])%k,k)%mod;\\n        if(c!=grid[0].size()-1)ans+=solve(grid,r,c+1,(sum+grid[r][c])%k,k)%mod;\\n        return dp[r*n+c][sum]=ans%mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        cout<<grid.size();\\n        return solve(grid,0,0,0,k);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3544391,
                "title": "java-recursive-memoization-path-sum-remainder-with-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int ROW;\\n    int COL;\\n    int mod = 1000000007;\\n    Integer[][][] memo;\\n    \\n    boolean isOutOfBounds(int row, int col){\\n        return row < 0 || row >= ROW || col < 0 || col >= COL;\\n    }\\n    \\n    int helper(int[][] grid, int k, int row, int col, int currSum){\\n\\n        if(isOutOfBounds(row, col)) return 0;\\n\\n        if(row == ROW - 1 && col == COL - 1){\\n            return (currSum + grid[row][col]) % k == 0 ? 1 : 0;\\n        }\\n        \\n        if(memo[row][col][currSum] != null) return memo[row][col][currSum];\\n        \\n        int ways = 0;\\n\\n        ways = (ways + helper(grid, k, row + 1, col, (currSum + grid[row][col]) % k)) % mod;\\n        ways = (ways + helper(grid, k, row, col + 1, (currSum + grid[row][col]) % k)) % mod;\\n        \\n        return memo[row][col][currSum] = ways;\\n    }\\n    \\n    public int numberOfPaths(int[][] grid, int k) {\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        memo = new Integer[ROW][COL][51];\\n        return helper(grid, k, 0, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int ROW;\\n    int COL;\\n    int mod = 1000000007;\\n    Integer[][][] memo;\\n    \\n    boolean isOutOfBounds(int row, int col){\\n        return row < 0 || row >= ROW || col < 0 || col >= COL;\\n    }\\n    \\n    int helper(int[][] grid, int k, int row, int col, int currSum){\\n\\n        if(isOutOfBounds(row, col)) return 0;\\n\\n        if(row == ROW - 1 && col == COL - 1){\\n            return (currSum + grid[row][col]) % k == 0 ? 1 : 0;\\n        }\\n        \\n        if(memo[row][col][currSum] != null) return memo[row][col][currSum];\\n        \\n        int ways = 0;\\n\\n        ways = (ways + helper(grid, k, row + 1, col, (currSum + grid[row][col]) % k)) % mod;\\n        ways = (ways + helper(grid, k, row, col + 1, (currSum + grid[row][col]) % k)) % mod;\\n        \\n        return memo[row][col][currSum] = ways;\\n    }\\n    \\n    public int numberOfPaths(int[][] grid, int k) {\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        memo = new Integer[ROW][COL][51];\\n        return helper(grid, k, 0, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529521,
                "title": "intuition-recursive-memoization-thinking-process-2-d-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Starting Thinking : \\n- We have solved the probelm of finding the given target in a matrix \\n- Here when we reach the end Check whether it is divisble by k or not \\n- If it return 1 else return 0;\\n\\nBut we got TLE because the sum will be ghigher and memoizing that much larger sum will give TLE \\n- Now what we can improve\\n \\n# On thinking more\\n- We have k ranging from 1 to 50 and whenever the modulo of any number is 0 that means that number is divisble by K .\\n- So why not take a vector of k size instead of sum \\n- where when we come to any grid[i][j] and take modulo with k and then adding grid[i][j]%k  in the vector coming from right and down. \\n- At last we will return with 0 index because o indexed will tell us whether the number is divisble by k or not .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-   Approach hase been descibed above \\n- If you got the point please upvote .\\n- Recursive and DP solution(2D dp) are given below \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    For Recursion && DP : O(n*m*k);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    Recursion = O(n*m*k)+ Recursive stack space \\n    2D -DP Memoized : O(M*K) ;\\n# Code\\n## Recursion :\\n```\\nclass Solution {\\n    int mod= 1e9+7;\\npublic:\\n    vector<int> number(vector<vector<int>> & grid , int k , int i , int j   ,vector<vector<vector<int>>>& dp )\\n    {\\n        vector<int> ans (k,0);\\n        if(i>=grid.size() || j>=grid[0].size())\\n        {\\n            return ans;\\n        }\\n        if(i== grid.size()-1 && j== grid[0].size()-1)\\n        {\\n            ans[grid[i][j]%k]++;\\n            ans[grid[i][j]%k]%=mod;\\n            return ans ;\\n        }\\n        if(dp[i][j].size()!=0)\\n        {\\n            return dp[i][j];\\n        }\\n        int val = grid[i][j]%k ;\\n        vector<int> right = number(grid , k , i, j+1, dp);\\n        vector<int> down = number(grid , k , i+1, j, dp );\\n        for( int p=0 ;p<k ;p++)\\n        {\\n            ans[(p+val)%k]= right[p]+down[p];\\n            ans[(p+val)%k]%=mod;\\n        }\\n        return dp[i][j]=ans ;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        vector<vector<vector<int>>>dp(grid.size() ,vector<vector<int>>(grid[0].size()));\\n        vector<int> hey = number(grid , k , 0, 0 ,dp);\\n        return hey[0];\\n    }\\n};\\n```\\n## THE 2-D Dp solution :\\n```\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>>row1(grid[0].size()+1, vector<int>(k,0)) , row2(grid[0].size()+1, vector<int>(k,0));\\n        row2[grid[0].size()-1][grid[grid.size()-1][grid[0].size()-1]%k]++;\\n        for( int i =grid.size()-1 ;i>=0 ;i--)\\n        {\\n            for( int j =grid[0].size()-1 ;j>=0 ;j--)\\n            {\\n                if(j==grid[0].size()-1 && i== grid.size()-1)\\n                {\\n                    continue;\\n                }\\n               \\n                int val = grid[i][j]%k ;\\n                for(int p=0 ;p<k ;p++)\\n                {\\n                    row2[j][(p+val)%k]= row2[j+1][p]+row1[j][p];\\n                    row2[j][(p+val)%k]%=mod;\\n                }\\n            }\\n            row1 = row2;\\n            for( int i =0; i<grid[0].size() ;i++)\\n            {\\n                fill(row2[i].begin(), row2[i].end(),0);\\n            }\\n        }\\n        return row1[0][0];\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod= 1e9+7;\\npublic:\\n    vector<int> number(vector<vector<int>> & grid , int k , int i , int j   ,vector<vector<vector<int>>>& dp )\\n    {\\n        vector<int> ans (k,0);\\n        if(i>=grid.size() || j>=grid[0].size())\\n        {\\n            return ans;\\n        }\\n        if(i== grid.size()-1 && j== grid[0].size()-1)\\n        {\\n            ans[grid[i][j]%k]++;\\n            ans[grid[i][j]%k]%=mod;\\n            return ans ;\\n        }\\n        if(dp[i][j].size()!=0)\\n        {\\n            return dp[i][j];\\n        }\\n        int val = grid[i][j]%k ;\\n        vector<int> right = number(grid , k , i, j+1, dp);\\n        vector<int> down = number(grid , k , i+1, j, dp );\\n        for( int p=0 ;p<k ;p++)\\n        {\\n            ans[(p+val)%k]= right[p]+down[p];\\n            ans[(p+val)%k]%=mod;\\n        }\\n        return dp[i][j]=ans ;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        vector<vector<vector<int>>>dp(grid.size() ,vector<vector<int>>(grid[0].size()));\\n        vector<int> hey = number(grid , k , 0, 0 ,dp);\\n        return hey[0];\\n    }\\n};\\n```\n```\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>>row1(grid[0].size()+1, vector<int>(k,0)) , row2(grid[0].size()+1, vector<int>(k,0));\\n        row2[grid[0].size()-1][grid[grid.size()-1][grid[0].size()-1]%k]++;\\n        for( int i =grid.size()-1 ;i>=0 ;i--)\\n        {\\n            for( int j =grid[0].size()-1 ;j>=0 ;j--)\\n            {\\n                if(j==grid[0].size()-1 && i== grid.size()-1)\\n                {\\n                    continue;\\n                }\\n               \\n                int val = grid[i][j]%k ;\\n                for(int p=0 ;p<k ;p++)\\n                {\\n                    row2[j][(p+val)%k]= row2[j+1][p]+row1[j][p];\\n                    row2[j][(p+val)%k]%=mod;\\n                }\\n            }\\n            row1 = row2;\\n            for( int i =0; i<grid[0].size() ;i++)\\n            {\\n                fill(row2[i].begin(), row2[i].end(),0);\\n            }\\n        }\\n        return row1[0][0];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498285,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        \\n        int n = grid.size(), m = grid[0].size(), mod = 1000000007;\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(m + 1, vector<int>(k, 0)));\\n        dp[1][1][grid[0][0] % k] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                for (int a = 0; a < k; a++) {\\n                    dp[i][j][(grid[i - 1][j - 1] + a) % k] = (dp[i][j][(grid[i - 1][j - 1] + a) % k] + dp[i - 1][j][a] + dp[i][j - 1][a]) % mod;\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m][0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        \\n        int n = grid.size(), m = grid[0].size(), mod = 1000000007;\\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(m + 1, vector<int>(k, 0)));\\n        dp[1][1][grid[0][0] % k] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                for (int a = 0; a < k; a++) {\\n                    dp[i][j][(grid[i - 1][j - 1] + a) % k] = (dp[i][j][(grid[i - 1][j - 1] + a) % k] + dp[i - 1][j][a] + dp[i][j - 1][a]) % mod;\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m][0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494030,
                "title": "easy-c-code-simple-intuition",
                "content": "```\\n    #define ll long long int\\n    ll mod=1e9+7;\\n\\n\\n    int solve(vector<vector<int>>& g,int sum,int i,int j,int k,vector<vector<vector<int>>>&dp){\\n        if(i<0 || j<0) return 0;\\n        if(i==0 && j==0){\\n            sum += g[0][0];\\n            if (sum%k==0) return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][sum%k]!=-1) return dp[i][j][sum%k];\\n        ll u = solve(g,sum+g[i][j],i-1,j,k,dp);\\n        ll l = solve(g,sum+g[i][j],i,j-1,k,dp);\\n        return dp[i][j][sum%k] = (u%mod+l%mod)%mod;\\n        \\n    }\\n    int numberOfPaths(vector<vector<int>>& g, int k) {\\n        int m = g.size(), n=size(g[0]);\\n        // memset(dp,-1,sizeof(dp));\\n        vector<vector<vector<int>>>dp(m+1,vector<vector<int>>(n+1,vector<int>(52,-1)));\\n        return solve(g,0,m-1,n-1,k,dp);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n    #define ll long long int\\n    ll mod=1e9+7;\\n\\n\\n    int solve(vector<vector<int>>& g,int sum,int i,int j,int k,vector<vector<vector<int>>>&dp){\\n        if(i<0 || j<0) return 0;\\n        if(i==0 && j==0){\\n            sum += g[0][0];\\n            if (sum%k==0) return 1;\\n            return 0;\\n        }\\n        if(dp[i][j][sum%k]!=-1) return dp[i][j][sum%k];\\n        ll u = solve(g,sum+g[i][j],i-1,j,k,dp);\\n        ll l = solve(g,sum+g[i][j],i,j-1,k,dp);\\n        return dp[i][j][sum%k] = (u%mod+l%mod)%mod;\\n        \\n    }\\n    int numberOfPaths(vector<vector<int>>& g, int k) {\\n        int m = g.size(), n=size(g[0]);\\n        // memset(dp,-1,sizeof(dp));\\n        vector<vector<vector<int>>>dp(m+1,vector<vector<int>>(n+1,vector<int>(52,-1)));\\n        return solve(g,0,m-1,n-1,k,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480283,
                "title": "using-memorization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findans(vector<vector<int>>& grid,vector<vector<vector<int>>>& dp,int n,int m,int k,int sum){\\n        \\n        if(n<0 or m<0)return 0;\\n        if(n==0 and m==0){\\n            if((sum+grid[n][m])%k==0)return dp[n][m][0] = 1;\\n            else return dp[n][m][(sum+grid[n][m])%k] = 0;\\n        }\\n        sum = (sum + grid[n][m])%k;\\n        if(dp[n][m][sum]!=-1)return dp[n][m][sum];\\n        long long down = findans(grid,dp,n-1,m,k,sum);\\n        long long up = findans(grid,dp,n,m-1,k,sum);\\n        return dp[n][m][sum] = (down + up)%1000000007;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(k+1,-1)));\\n        return findans(grid,dp,n-1,m-1,k,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findans(vector<vector<int>>& grid,vector<vector<vector<int>>>& dp,int n,int m,int k,int sum){\\n        \\n        if(n<0 or m<0)return 0;\\n        if(n==0 and m==0){\\n            if((sum+grid[n][m])%k==0)return dp[n][m][0] = 1;\\n            else return dp[n][m][(sum+grid[n][m])%k] = 0;\\n        }\\n        sum = (sum + grid[n][m])%k;\\n        if(dp[n][m][sum]!=-1)return dp[n][m][sum];\\n        long long down = findans(grid,dp,n-1,m,k,sum);\\n        long long up = findans(grid,dp,n,m-1,k,sum);\\n        return dp[n][m][sum] = (down + up)%1000000007;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(k+1,-1)));\\n        return findans(grid,dp,n-1,m-1,k,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428741,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\n    int M = 1e9 + 7 ;\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        auto dp = vector<vector<vector<LL>>>(m, vector<vector<LL>>(n, vector<LL>(k))) ;\\n        LL sum = 0 ;\\n        for(int i = 0; i < m; i++){\\n            sum = (sum + grid[i][0]) % k ;\\n            dp[i][0][sum]++ ;\\n        }\\n\\n        sum = grid[0][0] ;\\n        for(int j = 1; j < n; j++){\\n            sum = (sum + grid[0][j]) % k ;\\n            dp[0][j][sum]++ ;\\n        }\\n\\n        for(int i  = 1; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                for(int r = 0; r < k ; r++){\\n                    int t = ((r - grid[i][j])%k + k)%k ;\\n                    dp[i][j][r] = (dp[i-1][j][t] + dp[i][j-1][t]) % M ;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1][0] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\n    int M = 1e9 + 7 ;\\npublic:\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        auto dp = vector<vector<vector<LL>>>(m, vector<vector<LL>>(n, vector<LL>(k))) ;\\n        LL sum = 0 ;\\n        for(int i = 0; i < m; i++){\\n            sum = (sum + grid[i][0]) % k ;\\n            dp[i][0][sum]++ ;\\n        }\\n\\n        sum = grid[0][0] ;\\n        for(int j = 1; j < n; j++){\\n            sum = (sum + grid[0][j]) % k ;\\n            dp[0][j][sum]++ ;\\n        }\\n\\n        for(int i  = 1; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                for(int r = 0; r < k ; r++){\\n                    int t = ((r - grid[i][j])%k + k)%k ;\\n                    dp[i][j][r] = (dp[i-1][j][t] + dp[i][j-1][t]) % M ;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1][0] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392849,
                "title": "java-memoized-recursive-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    private int mod = (int)1e9 + 7;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int[][][] memo = new int[grid.length][grid[0].length][k];\\n        for(int[][] matrix : memo) for(int[] row : matrix) Arrays.fill(row, -1);\\n\\n        return helper(grid, 0 , 0, k, 0, memo);\\n    }\\n\\n    private int helper(int[][] grid, int r, int c, int k, int sum, int[][][] memo){\\n        if (r>=grid.length || c>=grid[0].length) return 0;\\n        sum =  (sum + grid[r][c])%k;\\n        if (r == grid.length-1 && c==grid[0].length-1) {\\n            return (sum%k == 0 ? 1 : 0);\\n        }\\n        if (memo[r][c][sum] != -1) return memo[r][c][sum];\\n        int ans1 = helper(grid, r+1, c, k, sum, memo);\\n        int ans2 = helper(grid, r, c+1, k, sum, memo);\\n        return memo[r][c][sum] = (ans1%mod + ans2%mod)%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private int mod = (int)1e9 + 7;\\n    public int numberOfPaths(int[][] grid, int k) {\\n        int[][][] memo = new int[grid.length][grid[0].length][k];\\n        for(int[][] matrix : memo) for(int[] row : matrix) Arrays.fill(row, -1);\\n\\n        return helper(grid, 0 , 0, k, 0, memo);\\n    }\\n\\n    private int helper(int[][] grid, int r, int c, int k, int sum, int[][][] memo){\\n        if (r>=grid.length || c>=grid[0].length) return 0;\\n        sum =  (sum + grid[r][c])%k;\\n        if (r == grid.length-1 && c==grid[0].length-1) {\\n            return (sum%k == 0 ? 1 : 0);\\n        }\\n        if (memo[r][c][sum] != -1) return memo[r][c][sum];\\n        int ans1 = helper(grid, r+1, c, k, sum, memo);\\n        int ans2 = helper(grid, r, c+1, k, sum, memo);\\n        return memo[r][c][sum] = (ans1%mod + ans2%mod)%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1920497,
                "content": [
                    {
                        "username": "c-m-d-",
                        "content": "3d array/vector:\\ncache[i][j][k] == num ways to get a path ending at row i, col j with remainder k"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Thanks for the hint. Could you help me understand how it works? My initial thought was to store cache[i][j][sum] instead of cache[i][j][sum%k]."
                    },
                    {
                        "username": "darkhope",
                        "content": "What if k can be large enough (up to 10^9) and n,m <=16? (asked in Google OA)"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Use a hashmap to only store path remainders in cache that actually exist, instead of making a big vector to store all possible remainders 0, 1, 2, ... k-2, k-1. Other people were overhtinking this"
                    },
                    {
                        "username": "darkhope",
                        "content": "[@adas65](/adas65) but still there can be up to 16*16 cells, I think that only backtracking will give TLE. \\nAlgo like meet in middle might pass \\n"
                    },
                    {
                        "username": "adas65",
                        "content": "I think probably we can use Backtracking in that case\\n"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "Hi, can you please tell me why this gives WA? I made sum += grid[i][j] rather than passing it as a parameter.\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    // long long dp[10005][10005][50];\\n    vector<vector<vector<int>>> dp;\\n    int recursion(int i, int j, vector<vector<int>>&grid, int sum, int k){\\n        if(i >= grid.size() || j >= grid[0].size()) return 0;\\n        if(i == grid.size() - 1 &&  j == grid[0].size() - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        if(dp[i][j][sum] != -1) return dp[i][j][sum]; \\n        sum += grid[i][j];\\n        return dp[i][j][sum] = (recursion(i + 1, j, grid, sum % k, k) + recursion(i, j + 1, grid, sum % k, k)) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // memset(dp, -1, sizeof(dp));\\n        dp.resize(grid.size() + 1, vector<vector<int>>(grid[0].size() + 1, vector<int>(51, -1)));\\n        // cout << dp[0][0][0];\\n        return recursion(0, 0, grid, 0, k) % mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vijay0109",
                        "content": "you are not passing sum as a parameter, so when your function returning and storing in dp[i][j][sum] ,your sum has been changed because you added something before recursion call then overlap problem will not match and stored in dp in wrong way ."
                    },
                    {
                        "username": "layyy",
                        "content": "try minimum path sum or unique paths before this problem"
                    },
                    {
                        "username": "padmavathievi72625",
                        "content": "I\\'m getting memory limit exceeded\\nI request some one to help me with optimization\\n\\n`class Solution:\\n    def numberOfPaths(self, grid: List[List[int]], t: int) -> int:\\n        n= len(grid[0])\\n        m= len(grid)\\n        dp = [[[]] * (n) for _ in range(m)]\\n\\n        dp[0][0]=[grid[0][0]]\\n\\n        for i in range(1,m):#len(grid)\\n            dp[i][0]=[sum([grid[i][0]]+dp[i-1][0])]\\n        for i in range(1,n):#len(grid[0])\\n            dp[0][i]=[sum([grid[0][i]]+dp[0][i-1])]\\n        \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j]=[k+grid[i][j] for k in dp[i-1][j]]+[k+grid[i][j] for k in dp[i][j-1]]\\n        \\n        count=0\\n        \\n        for i in dp[-1][-1]:\\n            if i%t==0:\\n                count+=1\\n            \\n        return count%(10**(9)+7)`\\n"
                    },
                    {
                        "username": "sanky29",
                        "content": "Why does DFS with memorization give TLE?\n\n` \nclass Solution {\npublic:\n    vector<vector<int>> dir;\n    int n;\n    int m;\n    int k;\n    vector<vector<int>> grid;\n    long long md = 1000000007;\n\n    map<vector<int>, int> mem; \n\n    long long solve(int val, int x, int y){\n        //cout << x <<\" \"<<y <<\" \"<<val << endl;\n        \n        val += grid[x][y];\n\n        auto it = mem.find({x,y,val % k});\n        if(it != mem.end()){\n            return it->second;\n        }\n        if(x == m-1 && y == n-1){\n            if(val % k == 0){\n                return 1;\n            }\n            return 0;\n        }\n        long long ans = 0;\n        for(auto d: dir){\n            int nx = x+d[0];\n            int ny = y+d[1];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                ans = (ans + solve(val, nx, ny))%md;\n            }\n        }\n        vector<int> key = {x,y,val%k};\n        mem.insert(make_pair(key, ans));\n        return ans;\n    }\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        this->grid = grid;\n        this->m = grid.size();\n        this->n = grid[0].size();\n        this->k = k;\n        dir = {{0,1}, {1,0}};\n        return solve(0,0,0);\n    }\n};.\n`"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "Why my code was giving TLE?\n\n```\npublic int numberOfPaths(int[][] grid, int k) {\n        int n=grid.length,m=grid[0].length;\n        HashMap<String,Integer> dp=new HashMap<>();\n        return dfs(0,0,grid.length, grid[0].length,grid,0,k,dp);\n    }\n    int mod=1000000007;\n    public int dfs(int i, int j, int n,int m, int grid[][],int sum, int k,HashMap<String,Integer> dp)\n    {\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\n        sum+=grid[i][j];\n        if(i==n-1 && j==m-1 && sum%k==0) return 1;\n        \n        String key = i+\" \"+j+\" \"+sum;\n        if(dp.containsKey(key)) return dp.get(key);\n        int ans = dfs(i+1,j,n,m,grid,sum,k,dp) + dfs(i,j+1,n,m,grid,sum,k,dp);\n        dp.put(key,ans);\n        return dp.get(key) % mod;\n    }\n```"
                    },
                    {
                        "username": "Suraj6261",
                        "content": "why its giving TLE  --->\\n\\n\\'\\'class Solution {\\npublic:\\n   int mod = 1e9+7;\\n    int f(int i,int j,int k,int sum,vector<vector<int>>a,vector<vector<vector<int>>>&dp){\\n        if(i==0 && j==0){\\n            sum+=a[0][0];\\n            if(sum%k==0)return 1;\\n            return 0;\\n        }\\n        if(i<0 || j<0)return 0;\\n        if(dp[i][j][sum%k]!=-1)return dp[i][j][sum%k];\\n        \\n        int top  = f(i-1,j,k,sum+a[i][j],a,dp)%mod;\\n        int left = f(i,j-1,k,sum+a[i][j],a,dp)%mod;\\n        \\n        return dp[i][j][sum%k] = (top+left)%mod;\\n        \\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // c=0;\\n        int m =grid.size();\\n        int  n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n     int ans=  f(m-1,n-1,k,0,grid,dp)%mod;\\n         return ans%mod;\\n    }\\n};\\'"
                    },
                    {
                        "username": "yren2",
                        "content": "passing grid (or  \"a\" in f\\'s signature) as reference instead of copying."
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "Why is this solution giving a wrong answer on third test case. Can anyone help?\n\nclass Solution {\npublic:\n    const int m = 1000000007;\n    \n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        int n = grid.size();\n        int m = grid[0].size();\n        \n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                grid[i][j] = (grid[i][j]%k);\n            }\n        }\n        \n        int dp[n][m][k];\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                for(int l=0;l<k;l++)\n                {\n                    dp[i][j][l] = 0;\n                }\n            }\n        }\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                if(i==0 && j==0)\n                {\n                    dp[i][j][grid[i][j]] = 1;\n                }\n                else\n                {\n                    for(int l=0; l<k; l++)\n                    {\n                        int newSum = (grid[i][j] + l)%k;\n                        if(j > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i][j-1][l]%m )%m;\n                        }\n                        \n                        if(i > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i-1][j][l]%m )%m;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[n-1][m-1][0];\n    }\n};"
                    },
                    {
                        "username": "yren2",
                        "content": "[@Alcatraz11](/Alcatraz11) ;)"
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "[@yren2](/yren2) Shit!! and all this time I was thinking I am making some logical error. Wasted around 15-20min to debug during contest. Thanks!!\\n"
                    },
                    {
                        "username": "yren2",
                        "content": "your variable \"m\" serves as mod as well as the dimension of the grid. "
                    }
                ]
            },
            {
                "id": 1658506,
                "content": [
                    {
                        "username": "c-m-d-",
                        "content": "3d array/vector:\\ncache[i][j][k] == num ways to get a path ending at row i, col j with remainder k"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Thanks for the hint. Could you help me understand how it works? My initial thought was to store cache[i][j][sum] instead of cache[i][j][sum%k]."
                    },
                    {
                        "username": "darkhope",
                        "content": "What if k can be large enough (up to 10^9) and n,m <=16? (asked in Google OA)"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Use a hashmap to only store path remainders in cache that actually exist, instead of making a big vector to store all possible remainders 0, 1, 2, ... k-2, k-1. Other people were overhtinking this"
                    },
                    {
                        "username": "darkhope",
                        "content": "[@adas65](/adas65) but still there can be up to 16*16 cells, I think that only backtracking will give TLE. \\nAlgo like meet in middle might pass \\n"
                    },
                    {
                        "username": "adas65",
                        "content": "I think probably we can use Backtracking in that case\\n"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "Hi, can you please tell me why this gives WA? I made sum += grid[i][j] rather than passing it as a parameter.\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    // long long dp[10005][10005][50];\\n    vector<vector<vector<int>>> dp;\\n    int recursion(int i, int j, vector<vector<int>>&grid, int sum, int k){\\n        if(i >= grid.size() || j >= grid[0].size()) return 0;\\n        if(i == grid.size() - 1 &&  j == grid[0].size() - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        if(dp[i][j][sum] != -1) return dp[i][j][sum]; \\n        sum += grid[i][j];\\n        return dp[i][j][sum] = (recursion(i + 1, j, grid, sum % k, k) + recursion(i, j + 1, grid, sum % k, k)) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // memset(dp, -1, sizeof(dp));\\n        dp.resize(grid.size() + 1, vector<vector<int>>(grid[0].size() + 1, vector<int>(51, -1)));\\n        // cout << dp[0][0][0];\\n        return recursion(0, 0, grid, 0, k) % mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vijay0109",
                        "content": "you are not passing sum as a parameter, so when your function returning and storing in dp[i][j][sum] ,your sum has been changed because you added something before recursion call then overlap problem will not match and stored in dp in wrong way ."
                    },
                    {
                        "username": "layyy",
                        "content": "try minimum path sum or unique paths before this problem"
                    },
                    {
                        "username": "padmavathievi72625",
                        "content": "I\\'m getting memory limit exceeded\\nI request some one to help me with optimization\\n\\n`class Solution:\\n    def numberOfPaths(self, grid: List[List[int]], t: int) -> int:\\n        n= len(grid[0])\\n        m= len(grid)\\n        dp = [[[]] * (n) for _ in range(m)]\\n\\n        dp[0][0]=[grid[0][0]]\\n\\n        for i in range(1,m):#len(grid)\\n            dp[i][0]=[sum([grid[i][0]]+dp[i-1][0])]\\n        for i in range(1,n):#len(grid[0])\\n            dp[0][i]=[sum([grid[0][i]]+dp[0][i-1])]\\n        \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j]=[k+grid[i][j] for k in dp[i-1][j]]+[k+grid[i][j] for k in dp[i][j-1]]\\n        \\n        count=0\\n        \\n        for i in dp[-1][-1]:\\n            if i%t==0:\\n                count+=1\\n            \\n        return count%(10**(9)+7)`\\n"
                    },
                    {
                        "username": "sanky29",
                        "content": "Why does DFS with memorization give TLE?\n\n` \nclass Solution {\npublic:\n    vector<vector<int>> dir;\n    int n;\n    int m;\n    int k;\n    vector<vector<int>> grid;\n    long long md = 1000000007;\n\n    map<vector<int>, int> mem; \n\n    long long solve(int val, int x, int y){\n        //cout << x <<\" \"<<y <<\" \"<<val << endl;\n        \n        val += grid[x][y];\n\n        auto it = mem.find({x,y,val % k});\n        if(it != mem.end()){\n            return it->second;\n        }\n        if(x == m-1 && y == n-1){\n            if(val % k == 0){\n                return 1;\n            }\n            return 0;\n        }\n        long long ans = 0;\n        for(auto d: dir){\n            int nx = x+d[0];\n            int ny = y+d[1];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                ans = (ans + solve(val, nx, ny))%md;\n            }\n        }\n        vector<int> key = {x,y,val%k};\n        mem.insert(make_pair(key, ans));\n        return ans;\n    }\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        this->grid = grid;\n        this->m = grid.size();\n        this->n = grid[0].size();\n        this->k = k;\n        dir = {{0,1}, {1,0}};\n        return solve(0,0,0);\n    }\n};.\n`"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "Why my code was giving TLE?\n\n```\npublic int numberOfPaths(int[][] grid, int k) {\n        int n=grid.length,m=grid[0].length;\n        HashMap<String,Integer> dp=new HashMap<>();\n        return dfs(0,0,grid.length, grid[0].length,grid,0,k,dp);\n    }\n    int mod=1000000007;\n    public int dfs(int i, int j, int n,int m, int grid[][],int sum, int k,HashMap<String,Integer> dp)\n    {\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\n        sum+=grid[i][j];\n        if(i==n-1 && j==m-1 && sum%k==0) return 1;\n        \n        String key = i+\" \"+j+\" \"+sum;\n        if(dp.containsKey(key)) return dp.get(key);\n        int ans = dfs(i+1,j,n,m,grid,sum,k,dp) + dfs(i,j+1,n,m,grid,sum,k,dp);\n        dp.put(key,ans);\n        return dp.get(key) % mod;\n    }\n```"
                    },
                    {
                        "username": "Suraj6261",
                        "content": "why its giving TLE  --->\\n\\n\\'\\'class Solution {\\npublic:\\n   int mod = 1e9+7;\\n    int f(int i,int j,int k,int sum,vector<vector<int>>a,vector<vector<vector<int>>>&dp){\\n        if(i==0 && j==0){\\n            sum+=a[0][0];\\n            if(sum%k==0)return 1;\\n            return 0;\\n        }\\n        if(i<0 || j<0)return 0;\\n        if(dp[i][j][sum%k]!=-1)return dp[i][j][sum%k];\\n        \\n        int top  = f(i-1,j,k,sum+a[i][j],a,dp)%mod;\\n        int left = f(i,j-1,k,sum+a[i][j],a,dp)%mod;\\n        \\n        return dp[i][j][sum%k] = (top+left)%mod;\\n        \\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // c=0;\\n        int m =grid.size();\\n        int  n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n     int ans=  f(m-1,n-1,k,0,grid,dp)%mod;\\n         return ans%mod;\\n    }\\n};\\'"
                    },
                    {
                        "username": "yren2",
                        "content": "passing grid (or  \"a\" in f\\'s signature) as reference instead of copying."
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "Why is this solution giving a wrong answer on third test case. Can anyone help?\n\nclass Solution {\npublic:\n    const int m = 1000000007;\n    \n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        int n = grid.size();\n        int m = grid[0].size();\n        \n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                grid[i][j] = (grid[i][j]%k);\n            }\n        }\n        \n        int dp[n][m][k];\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                for(int l=0;l<k;l++)\n                {\n                    dp[i][j][l] = 0;\n                }\n            }\n        }\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                if(i==0 && j==0)\n                {\n                    dp[i][j][grid[i][j]] = 1;\n                }\n                else\n                {\n                    for(int l=0; l<k; l++)\n                    {\n                        int newSum = (grid[i][j] + l)%k;\n                        if(j > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i][j-1][l]%m )%m;\n                        }\n                        \n                        if(i > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i-1][j][l]%m )%m;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[n-1][m-1][0];\n    }\n};"
                    },
                    {
                        "username": "yren2",
                        "content": "[@Alcatraz11](/Alcatraz11) ;)"
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "[@yren2](/yren2) Shit!! and all this time I was thinking I am making some logical error. Wasted around 15-20min to debug during contest. Thanks!!\\n"
                    },
                    {
                        "username": "yren2",
                        "content": "your variable \"m\" serves as mod as well as the dimension of the grid. "
                    }
                ]
            },
            {
                "id": 1748230,
                "content": [
                    {
                        "username": "c-m-d-",
                        "content": "3d array/vector:\\ncache[i][j][k] == num ways to get a path ending at row i, col j with remainder k"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Thanks for the hint. Could you help me understand how it works? My initial thought was to store cache[i][j][sum] instead of cache[i][j][sum%k]."
                    },
                    {
                        "username": "darkhope",
                        "content": "What if k can be large enough (up to 10^9) and n,m <=16? (asked in Google OA)"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Use a hashmap to only store path remainders in cache that actually exist, instead of making a big vector to store all possible remainders 0, 1, 2, ... k-2, k-1. Other people were overhtinking this"
                    },
                    {
                        "username": "darkhope",
                        "content": "[@adas65](/adas65) but still there can be up to 16*16 cells, I think that only backtracking will give TLE. \\nAlgo like meet in middle might pass \\n"
                    },
                    {
                        "username": "adas65",
                        "content": "I think probably we can use Backtracking in that case\\n"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "Hi, can you please tell me why this gives WA? I made sum += grid[i][j] rather than passing it as a parameter.\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    // long long dp[10005][10005][50];\\n    vector<vector<vector<int>>> dp;\\n    int recursion(int i, int j, vector<vector<int>>&grid, int sum, int k){\\n        if(i >= grid.size() || j >= grid[0].size()) return 0;\\n        if(i == grid.size() - 1 &&  j == grid[0].size() - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        if(dp[i][j][sum] != -1) return dp[i][j][sum]; \\n        sum += grid[i][j];\\n        return dp[i][j][sum] = (recursion(i + 1, j, grid, sum % k, k) + recursion(i, j + 1, grid, sum % k, k)) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // memset(dp, -1, sizeof(dp));\\n        dp.resize(grid.size() + 1, vector<vector<int>>(grid[0].size() + 1, vector<int>(51, -1)));\\n        // cout << dp[0][0][0];\\n        return recursion(0, 0, grid, 0, k) % mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vijay0109",
                        "content": "you are not passing sum as a parameter, so when your function returning and storing in dp[i][j][sum] ,your sum has been changed because you added something before recursion call then overlap problem will not match and stored in dp in wrong way ."
                    },
                    {
                        "username": "layyy",
                        "content": "try minimum path sum or unique paths before this problem"
                    },
                    {
                        "username": "padmavathievi72625",
                        "content": "I\\'m getting memory limit exceeded\\nI request some one to help me with optimization\\n\\n`class Solution:\\n    def numberOfPaths(self, grid: List[List[int]], t: int) -> int:\\n        n= len(grid[0])\\n        m= len(grid)\\n        dp = [[[]] * (n) for _ in range(m)]\\n\\n        dp[0][0]=[grid[0][0]]\\n\\n        for i in range(1,m):#len(grid)\\n            dp[i][0]=[sum([grid[i][0]]+dp[i-1][0])]\\n        for i in range(1,n):#len(grid[0])\\n            dp[0][i]=[sum([grid[0][i]]+dp[0][i-1])]\\n        \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j]=[k+grid[i][j] for k in dp[i-1][j]]+[k+grid[i][j] for k in dp[i][j-1]]\\n        \\n        count=0\\n        \\n        for i in dp[-1][-1]:\\n            if i%t==0:\\n                count+=1\\n            \\n        return count%(10**(9)+7)`\\n"
                    },
                    {
                        "username": "sanky29",
                        "content": "Why does DFS with memorization give TLE?\n\n` \nclass Solution {\npublic:\n    vector<vector<int>> dir;\n    int n;\n    int m;\n    int k;\n    vector<vector<int>> grid;\n    long long md = 1000000007;\n\n    map<vector<int>, int> mem; \n\n    long long solve(int val, int x, int y){\n        //cout << x <<\" \"<<y <<\" \"<<val << endl;\n        \n        val += grid[x][y];\n\n        auto it = mem.find({x,y,val % k});\n        if(it != mem.end()){\n            return it->second;\n        }\n        if(x == m-1 && y == n-1){\n            if(val % k == 0){\n                return 1;\n            }\n            return 0;\n        }\n        long long ans = 0;\n        for(auto d: dir){\n            int nx = x+d[0];\n            int ny = y+d[1];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                ans = (ans + solve(val, nx, ny))%md;\n            }\n        }\n        vector<int> key = {x,y,val%k};\n        mem.insert(make_pair(key, ans));\n        return ans;\n    }\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        this->grid = grid;\n        this->m = grid.size();\n        this->n = grid[0].size();\n        this->k = k;\n        dir = {{0,1}, {1,0}};\n        return solve(0,0,0);\n    }\n};.\n`"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "Why my code was giving TLE?\n\n```\npublic int numberOfPaths(int[][] grid, int k) {\n        int n=grid.length,m=grid[0].length;\n        HashMap<String,Integer> dp=new HashMap<>();\n        return dfs(0,0,grid.length, grid[0].length,grid,0,k,dp);\n    }\n    int mod=1000000007;\n    public int dfs(int i, int j, int n,int m, int grid[][],int sum, int k,HashMap<String,Integer> dp)\n    {\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\n        sum+=grid[i][j];\n        if(i==n-1 && j==m-1 && sum%k==0) return 1;\n        \n        String key = i+\" \"+j+\" \"+sum;\n        if(dp.containsKey(key)) return dp.get(key);\n        int ans = dfs(i+1,j,n,m,grid,sum,k,dp) + dfs(i,j+1,n,m,grid,sum,k,dp);\n        dp.put(key,ans);\n        return dp.get(key) % mod;\n    }\n```"
                    },
                    {
                        "username": "Suraj6261",
                        "content": "why its giving TLE  --->\\n\\n\\'\\'class Solution {\\npublic:\\n   int mod = 1e9+7;\\n    int f(int i,int j,int k,int sum,vector<vector<int>>a,vector<vector<vector<int>>>&dp){\\n        if(i==0 && j==0){\\n            sum+=a[0][0];\\n            if(sum%k==0)return 1;\\n            return 0;\\n        }\\n        if(i<0 || j<0)return 0;\\n        if(dp[i][j][sum%k]!=-1)return dp[i][j][sum%k];\\n        \\n        int top  = f(i-1,j,k,sum+a[i][j],a,dp)%mod;\\n        int left = f(i,j-1,k,sum+a[i][j],a,dp)%mod;\\n        \\n        return dp[i][j][sum%k] = (top+left)%mod;\\n        \\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // c=0;\\n        int m =grid.size();\\n        int  n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n     int ans=  f(m-1,n-1,k,0,grid,dp)%mod;\\n         return ans%mod;\\n    }\\n};\\'"
                    },
                    {
                        "username": "yren2",
                        "content": "passing grid (or  \"a\" in f\\'s signature) as reference instead of copying."
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "Why is this solution giving a wrong answer on third test case. Can anyone help?\n\nclass Solution {\npublic:\n    const int m = 1000000007;\n    \n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        int n = grid.size();\n        int m = grid[0].size();\n        \n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                grid[i][j] = (grid[i][j]%k);\n            }\n        }\n        \n        int dp[n][m][k];\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                for(int l=0;l<k;l++)\n                {\n                    dp[i][j][l] = 0;\n                }\n            }\n        }\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                if(i==0 && j==0)\n                {\n                    dp[i][j][grid[i][j]] = 1;\n                }\n                else\n                {\n                    for(int l=0; l<k; l++)\n                    {\n                        int newSum = (grid[i][j] + l)%k;\n                        if(j > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i][j-1][l]%m )%m;\n                        }\n                        \n                        if(i > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i-1][j][l]%m )%m;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[n-1][m-1][0];\n    }\n};"
                    },
                    {
                        "username": "yren2",
                        "content": "[@Alcatraz11](/Alcatraz11) ;)"
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "[@yren2](/yren2) Shit!! and all this time I was thinking I am making some logical error. Wasted around 15-20min to debug during contest. Thanks!!\\n"
                    },
                    {
                        "username": "yren2",
                        "content": "your variable \"m\" serves as mod as well as the dimension of the grid. "
                    }
                ]
            },
            {
                "id": 2045405,
                "content": [
                    {
                        "username": "c-m-d-",
                        "content": "3d array/vector:\\ncache[i][j][k] == num ways to get a path ending at row i, col j with remainder k"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Thanks for the hint. Could you help me understand how it works? My initial thought was to store cache[i][j][sum] instead of cache[i][j][sum%k]."
                    },
                    {
                        "username": "darkhope",
                        "content": "What if k can be large enough (up to 10^9) and n,m <=16? (asked in Google OA)"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Use a hashmap to only store path remainders in cache that actually exist, instead of making a big vector to store all possible remainders 0, 1, 2, ... k-2, k-1. Other people were overhtinking this"
                    },
                    {
                        "username": "darkhope",
                        "content": "[@adas65](/adas65) but still there can be up to 16*16 cells, I think that only backtracking will give TLE. \\nAlgo like meet in middle might pass \\n"
                    },
                    {
                        "username": "adas65",
                        "content": "I think probably we can use Backtracking in that case\\n"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "Hi, can you please tell me why this gives WA? I made sum += grid[i][j] rather than passing it as a parameter.\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    // long long dp[10005][10005][50];\\n    vector<vector<vector<int>>> dp;\\n    int recursion(int i, int j, vector<vector<int>>&grid, int sum, int k){\\n        if(i >= grid.size() || j >= grid[0].size()) return 0;\\n        if(i == grid.size() - 1 &&  j == grid[0].size() - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        if(dp[i][j][sum] != -1) return dp[i][j][sum]; \\n        sum += grid[i][j];\\n        return dp[i][j][sum] = (recursion(i + 1, j, grid, sum % k, k) + recursion(i, j + 1, grid, sum % k, k)) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // memset(dp, -1, sizeof(dp));\\n        dp.resize(grid.size() + 1, vector<vector<int>>(grid[0].size() + 1, vector<int>(51, -1)));\\n        // cout << dp[0][0][0];\\n        return recursion(0, 0, grid, 0, k) % mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vijay0109",
                        "content": "you are not passing sum as a parameter, so when your function returning and storing in dp[i][j][sum] ,your sum has been changed because you added something before recursion call then overlap problem will not match and stored in dp in wrong way ."
                    },
                    {
                        "username": "layyy",
                        "content": "try minimum path sum or unique paths before this problem"
                    },
                    {
                        "username": "padmavathievi72625",
                        "content": "I\\'m getting memory limit exceeded\\nI request some one to help me with optimization\\n\\n`class Solution:\\n    def numberOfPaths(self, grid: List[List[int]], t: int) -> int:\\n        n= len(grid[0])\\n        m= len(grid)\\n        dp = [[[]] * (n) for _ in range(m)]\\n\\n        dp[0][0]=[grid[0][0]]\\n\\n        for i in range(1,m):#len(grid)\\n            dp[i][0]=[sum([grid[i][0]]+dp[i-1][0])]\\n        for i in range(1,n):#len(grid[0])\\n            dp[0][i]=[sum([grid[0][i]]+dp[0][i-1])]\\n        \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j]=[k+grid[i][j] for k in dp[i-1][j]]+[k+grid[i][j] for k in dp[i][j-1]]\\n        \\n        count=0\\n        \\n        for i in dp[-1][-1]:\\n            if i%t==0:\\n                count+=1\\n            \\n        return count%(10**(9)+7)`\\n"
                    },
                    {
                        "username": "sanky29",
                        "content": "Why does DFS with memorization give TLE?\n\n` \nclass Solution {\npublic:\n    vector<vector<int>> dir;\n    int n;\n    int m;\n    int k;\n    vector<vector<int>> grid;\n    long long md = 1000000007;\n\n    map<vector<int>, int> mem; \n\n    long long solve(int val, int x, int y){\n        //cout << x <<\" \"<<y <<\" \"<<val << endl;\n        \n        val += grid[x][y];\n\n        auto it = mem.find({x,y,val % k});\n        if(it != mem.end()){\n            return it->second;\n        }\n        if(x == m-1 && y == n-1){\n            if(val % k == 0){\n                return 1;\n            }\n            return 0;\n        }\n        long long ans = 0;\n        for(auto d: dir){\n            int nx = x+d[0];\n            int ny = y+d[1];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                ans = (ans + solve(val, nx, ny))%md;\n            }\n        }\n        vector<int> key = {x,y,val%k};\n        mem.insert(make_pair(key, ans));\n        return ans;\n    }\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        this->grid = grid;\n        this->m = grid.size();\n        this->n = grid[0].size();\n        this->k = k;\n        dir = {{0,1}, {1,0}};\n        return solve(0,0,0);\n    }\n};.\n`"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "Why my code was giving TLE?\n\n```\npublic int numberOfPaths(int[][] grid, int k) {\n        int n=grid.length,m=grid[0].length;\n        HashMap<String,Integer> dp=new HashMap<>();\n        return dfs(0,0,grid.length, grid[0].length,grid,0,k,dp);\n    }\n    int mod=1000000007;\n    public int dfs(int i, int j, int n,int m, int grid[][],int sum, int k,HashMap<String,Integer> dp)\n    {\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\n        sum+=grid[i][j];\n        if(i==n-1 && j==m-1 && sum%k==0) return 1;\n        \n        String key = i+\" \"+j+\" \"+sum;\n        if(dp.containsKey(key)) return dp.get(key);\n        int ans = dfs(i+1,j,n,m,grid,sum,k,dp) + dfs(i,j+1,n,m,grid,sum,k,dp);\n        dp.put(key,ans);\n        return dp.get(key) % mod;\n    }\n```"
                    },
                    {
                        "username": "Suraj6261",
                        "content": "why its giving TLE  --->\\n\\n\\'\\'class Solution {\\npublic:\\n   int mod = 1e9+7;\\n    int f(int i,int j,int k,int sum,vector<vector<int>>a,vector<vector<vector<int>>>&dp){\\n        if(i==0 && j==0){\\n            sum+=a[0][0];\\n            if(sum%k==0)return 1;\\n            return 0;\\n        }\\n        if(i<0 || j<0)return 0;\\n        if(dp[i][j][sum%k]!=-1)return dp[i][j][sum%k];\\n        \\n        int top  = f(i-1,j,k,sum+a[i][j],a,dp)%mod;\\n        int left = f(i,j-1,k,sum+a[i][j],a,dp)%mod;\\n        \\n        return dp[i][j][sum%k] = (top+left)%mod;\\n        \\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // c=0;\\n        int m =grid.size();\\n        int  n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n     int ans=  f(m-1,n-1,k,0,grid,dp)%mod;\\n         return ans%mod;\\n    }\\n};\\'"
                    },
                    {
                        "username": "yren2",
                        "content": "passing grid (or  \"a\" in f\\'s signature) as reference instead of copying."
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "Why is this solution giving a wrong answer on third test case. Can anyone help?\n\nclass Solution {\npublic:\n    const int m = 1000000007;\n    \n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        int n = grid.size();\n        int m = grid[0].size();\n        \n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                grid[i][j] = (grid[i][j]%k);\n            }\n        }\n        \n        int dp[n][m][k];\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                for(int l=0;l<k;l++)\n                {\n                    dp[i][j][l] = 0;\n                }\n            }\n        }\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                if(i==0 && j==0)\n                {\n                    dp[i][j][grid[i][j]] = 1;\n                }\n                else\n                {\n                    for(int l=0; l<k; l++)\n                    {\n                        int newSum = (grid[i][j] + l)%k;\n                        if(j > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i][j-1][l]%m )%m;\n                        }\n                        \n                        if(i > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i-1][j][l]%m )%m;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[n-1][m-1][0];\n    }\n};"
                    },
                    {
                        "username": "yren2",
                        "content": "[@Alcatraz11](/Alcatraz11) ;)"
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "[@yren2](/yren2) Shit!! and all this time I was thinking I am making some logical error. Wasted around 15-20min to debug during contest. Thanks!!\\n"
                    },
                    {
                        "username": "yren2",
                        "content": "your variable \"m\" serves as mod as well as the dimension of the grid. "
                    }
                ]
            },
            {
                "id": 2034662,
                "content": [
                    {
                        "username": "c-m-d-",
                        "content": "3d array/vector:\\ncache[i][j][k] == num ways to get a path ending at row i, col j with remainder k"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Thanks for the hint. Could you help me understand how it works? My initial thought was to store cache[i][j][sum] instead of cache[i][j][sum%k]."
                    },
                    {
                        "username": "darkhope",
                        "content": "What if k can be large enough (up to 10^9) and n,m <=16? (asked in Google OA)"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Use a hashmap to only store path remainders in cache that actually exist, instead of making a big vector to store all possible remainders 0, 1, 2, ... k-2, k-1. Other people were overhtinking this"
                    },
                    {
                        "username": "darkhope",
                        "content": "[@adas65](/adas65) but still there can be up to 16*16 cells, I think that only backtracking will give TLE. \\nAlgo like meet in middle might pass \\n"
                    },
                    {
                        "username": "adas65",
                        "content": "I think probably we can use Backtracking in that case\\n"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "Hi, can you please tell me why this gives WA? I made sum += grid[i][j] rather than passing it as a parameter.\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    // long long dp[10005][10005][50];\\n    vector<vector<vector<int>>> dp;\\n    int recursion(int i, int j, vector<vector<int>>&grid, int sum, int k){\\n        if(i >= grid.size() || j >= grid[0].size()) return 0;\\n        if(i == grid.size() - 1 &&  j == grid[0].size() - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        if(dp[i][j][sum] != -1) return dp[i][j][sum]; \\n        sum += grid[i][j];\\n        return dp[i][j][sum] = (recursion(i + 1, j, grid, sum % k, k) + recursion(i, j + 1, grid, sum % k, k)) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // memset(dp, -1, sizeof(dp));\\n        dp.resize(grid.size() + 1, vector<vector<int>>(grid[0].size() + 1, vector<int>(51, -1)));\\n        // cout << dp[0][0][0];\\n        return recursion(0, 0, grid, 0, k) % mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vijay0109",
                        "content": "you are not passing sum as a parameter, so when your function returning and storing in dp[i][j][sum] ,your sum has been changed because you added something before recursion call then overlap problem will not match and stored in dp in wrong way ."
                    },
                    {
                        "username": "layyy",
                        "content": "try minimum path sum or unique paths before this problem"
                    },
                    {
                        "username": "padmavathievi72625",
                        "content": "I\\'m getting memory limit exceeded\\nI request some one to help me with optimization\\n\\n`class Solution:\\n    def numberOfPaths(self, grid: List[List[int]], t: int) -> int:\\n        n= len(grid[0])\\n        m= len(grid)\\n        dp = [[[]] * (n) for _ in range(m)]\\n\\n        dp[0][0]=[grid[0][0]]\\n\\n        for i in range(1,m):#len(grid)\\n            dp[i][0]=[sum([grid[i][0]]+dp[i-1][0])]\\n        for i in range(1,n):#len(grid[0])\\n            dp[0][i]=[sum([grid[0][i]]+dp[0][i-1])]\\n        \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j]=[k+grid[i][j] for k in dp[i-1][j]]+[k+grid[i][j] for k in dp[i][j-1]]\\n        \\n        count=0\\n        \\n        for i in dp[-1][-1]:\\n            if i%t==0:\\n                count+=1\\n            \\n        return count%(10**(9)+7)`\\n"
                    },
                    {
                        "username": "sanky29",
                        "content": "Why does DFS with memorization give TLE?\n\n` \nclass Solution {\npublic:\n    vector<vector<int>> dir;\n    int n;\n    int m;\n    int k;\n    vector<vector<int>> grid;\n    long long md = 1000000007;\n\n    map<vector<int>, int> mem; \n\n    long long solve(int val, int x, int y){\n        //cout << x <<\" \"<<y <<\" \"<<val << endl;\n        \n        val += grid[x][y];\n\n        auto it = mem.find({x,y,val % k});\n        if(it != mem.end()){\n            return it->second;\n        }\n        if(x == m-1 && y == n-1){\n            if(val % k == 0){\n                return 1;\n            }\n            return 0;\n        }\n        long long ans = 0;\n        for(auto d: dir){\n            int nx = x+d[0];\n            int ny = y+d[1];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                ans = (ans + solve(val, nx, ny))%md;\n            }\n        }\n        vector<int> key = {x,y,val%k};\n        mem.insert(make_pair(key, ans));\n        return ans;\n    }\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        this->grid = grid;\n        this->m = grid.size();\n        this->n = grid[0].size();\n        this->k = k;\n        dir = {{0,1}, {1,0}};\n        return solve(0,0,0);\n    }\n};.\n`"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "Why my code was giving TLE?\n\n```\npublic int numberOfPaths(int[][] grid, int k) {\n        int n=grid.length,m=grid[0].length;\n        HashMap<String,Integer> dp=new HashMap<>();\n        return dfs(0,0,grid.length, grid[0].length,grid,0,k,dp);\n    }\n    int mod=1000000007;\n    public int dfs(int i, int j, int n,int m, int grid[][],int sum, int k,HashMap<String,Integer> dp)\n    {\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\n        sum+=grid[i][j];\n        if(i==n-1 && j==m-1 && sum%k==0) return 1;\n        \n        String key = i+\" \"+j+\" \"+sum;\n        if(dp.containsKey(key)) return dp.get(key);\n        int ans = dfs(i+1,j,n,m,grid,sum,k,dp) + dfs(i,j+1,n,m,grid,sum,k,dp);\n        dp.put(key,ans);\n        return dp.get(key) % mod;\n    }\n```"
                    },
                    {
                        "username": "Suraj6261",
                        "content": "why its giving TLE  --->\\n\\n\\'\\'class Solution {\\npublic:\\n   int mod = 1e9+7;\\n    int f(int i,int j,int k,int sum,vector<vector<int>>a,vector<vector<vector<int>>>&dp){\\n        if(i==0 && j==0){\\n            sum+=a[0][0];\\n            if(sum%k==0)return 1;\\n            return 0;\\n        }\\n        if(i<0 || j<0)return 0;\\n        if(dp[i][j][sum%k]!=-1)return dp[i][j][sum%k];\\n        \\n        int top  = f(i-1,j,k,sum+a[i][j],a,dp)%mod;\\n        int left = f(i,j-1,k,sum+a[i][j],a,dp)%mod;\\n        \\n        return dp[i][j][sum%k] = (top+left)%mod;\\n        \\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // c=0;\\n        int m =grid.size();\\n        int  n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n     int ans=  f(m-1,n-1,k,0,grid,dp)%mod;\\n         return ans%mod;\\n    }\\n};\\'"
                    },
                    {
                        "username": "yren2",
                        "content": "passing grid (or  \"a\" in f\\'s signature) as reference instead of copying."
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "Why is this solution giving a wrong answer on third test case. Can anyone help?\n\nclass Solution {\npublic:\n    const int m = 1000000007;\n    \n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        int n = grid.size();\n        int m = grid[0].size();\n        \n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                grid[i][j] = (grid[i][j]%k);\n            }\n        }\n        \n        int dp[n][m][k];\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                for(int l=0;l<k;l++)\n                {\n                    dp[i][j][l] = 0;\n                }\n            }\n        }\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                if(i==0 && j==0)\n                {\n                    dp[i][j][grid[i][j]] = 1;\n                }\n                else\n                {\n                    for(int l=0; l<k; l++)\n                    {\n                        int newSum = (grid[i][j] + l)%k;\n                        if(j > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i][j-1][l]%m )%m;\n                        }\n                        \n                        if(i > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i-1][j][l]%m )%m;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[n-1][m-1][0];\n    }\n};"
                    },
                    {
                        "username": "yren2",
                        "content": "[@Alcatraz11](/Alcatraz11) ;)"
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "[@yren2](/yren2) Shit!! and all this time I was thinking I am making some logical error. Wasted around 15-20min to debug during contest. Thanks!!\\n"
                    },
                    {
                        "username": "yren2",
                        "content": "your variable \"m\" serves as mod as well as the dimension of the grid. "
                    }
                ]
            },
            {
                "id": 1754214,
                "content": [
                    {
                        "username": "c-m-d-",
                        "content": "3d array/vector:\\ncache[i][j][k] == num ways to get a path ending at row i, col j with remainder k"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Thanks for the hint. Could you help me understand how it works? My initial thought was to store cache[i][j][sum] instead of cache[i][j][sum%k]."
                    },
                    {
                        "username": "darkhope",
                        "content": "What if k can be large enough (up to 10^9) and n,m <=16? (asked in Google OA)"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Use a hashmap to only store path remainders in cache that actually exist, instead of making a big vector to store all possible remainders 0, 1, 2, ... k-2, k-1. Other people were overhtinking this"
                    },
                    {
                        "username": "darkhope",
                        "content": "[@adas65](/adas65) but still there can be up to 16*16 cells, I think that only backtracking will give TLE. \\nAlgo like meet in middle might pass \\n"
                    },
                    {
                        "username": "adas65",
                        "content": "I think probably we can use Backtracking in that case\\n"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "Hi, can you please tell me why this gives WA? I made sum += grid[i][j] rather than passing it as a parameter.\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    // long long dp[10005][10005][50];\\n    vector<vector<vector<int>>> dp;\\n    int recursion(int i, int j, vector<vector<int>>&grid, int sum, int k){\\n        if(i >= grid.size() || j >= grid[0].size()) return 0;\\n        if(i == grid.size() - 1 &&  j == grid[0].size() - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        if(dp[i][j][sum] != -1) return dp[i][j][sum]; \\n        sum += grid[i][j];\\n        return dp[i][j][sum] = (recursion(i + 1, j, grid, sum % k, k) + recursion(i, j + 1, grid, sum % k, k)) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // memset(dp, -1, sizeof(dp));\\n        dp.resize(grid.size() + 1, vector<vector<int>>(grid[0].size() + 1, vector<int>(51, -1)));\\n        // cout << dp[0][0][0];\\n        return recursion(0, 0, grid, 0, k) % mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vijay0109",
                        "content": "you are not passing sum as a parameter, so when your function returning and storing in dp[i][j][sum] ,your sum has been changed because you added something before recursion call then overlap problem will not match and stored in dp in wrong way ."
                    },
                    {
                        "username": "layyy",
                        "content": "try minimum path sum or unique paths before this problem"
                    },
                    {
                        "username": "padmavathievi72625",
                        "content": "I\\'m getting memory limit exceeded\\nI request some one to help me with optimization\\n\\n`class Solution:\\n    def numberOfPaths(self, grid: List[List[int]], t: int) -> int:\\n        n= len(grid[0])\\n        m= len(grid)\\n        dp = [[[]] * (n) for _ in range(m)]\\n\\n        dp[0][0]=[grid[0][0]]\\n\\n        for i in range(1,m):#len(grid)\\n            dp[i][0]=[sum([grid[i][0]]+dp[i-1][0])]\\n        for i in range(1,n):#len(grid[0])\\n            dp[0][i]=[sum([grid[0][i]]+dp[0][i-1])]\\n        \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j]=[k+grid[i][j] for k in dp[i-1][j]]+[k+grid[i][j] for k in dp[i][j-1]]\\n        \\n        count=0\\n        \\n        for i in dp[-1][-1]:\\n            if i%t==0:\\n                count+=1\\n            \\n        return count%(10**(9)+7)`\\n"
                    },
                    {
                        "username": "sanky29",
                        "content": "Why does DFS with memorization give TLE?\n\n` \nclass Solution {\npublic:\n    vector<vector<int>> dir;\n    int n;\n    int m;\n    int k;\n    vector<vector<int>> grid;\n    long long md = 1000000007;\n\n    map<vector<int>, int> mem; \n\n    long long solve(int val, int x, int y){\n        //cout << x <<\" \"<<y <<\" \"<<val << endl;\n        \n        val += grid[x][y];\n\n        auto it = mem.find({x,y,val % k});\n        if(it != mem.end()){\n            return it->second;\n        }\n        if(x == m-1 && y == n-1){\n            if(val % k == 0){\n                return 1;\n            }\n            return 0;\n        }\n        long long ans = 0;\n        for(auto d: dir){\n            int nx = x+d[0];\n            int ny = y+d[1];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                ans = (ans + solve(val, nx, ny))%md;\n            }\n        }\n        vector<int> key = {x,y,val%k};\n        mem.insert(make_pair(key, ans));\n        return ans;\n    }\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        this->grid = grid;\n        this->m = grid.size();\n        this->n = grid[0].size();\n        this->k = k;\n        dir = {{0,1}, {1,0}};\n        return solve(0,0,0);\n    }\n};.\n`"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "Why my code was giving TLE?\n\n```\npublic int numberOfPaths(int[][] grid, int k) {\n        int n=grid.length,m=grid[0].length;\n        HashMap<String,Integer> dp=new HashMap<>();\n        return dfs(0,0,grid.length, grid[0].length,grid,0,k,dp);\n    }\n    int mod=1000000007;\n    public int dfs(int i, int j, int n,int m, int grid[][],int sum, int k,HashMap<String,Integer> dp)\n    {\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\n        sum+=grid[i][j];\n        if(i==n-1 && j==m-1 && sum%k==0) return 1;\n        \n        String key = i+\" \"+j+\" \"+sum;\n        if(dp.containsKey(key)) return dp.get(key);\n        int ans = dfs(i+1,j,n,m,grid,sum,k,dp) + dfs(i,j+1,n,m,grid,sum,k,dp);\n        dp.put(key,ans);\n        return dp.get(key) % mod;\n    }\n```"
                    },
                    {
                        "username": "Suraj6261",
                        "content": "why its giving TLE  --->\\n\\n\\'\\'class Solution {\\npublic:\\n   int mod = 1e9+7;\\n    int f(int i,int j,int k,int sum,vector<vector<int>>a,vector<vector<vector<int>>>&dp){\\n        if(i==0 && j==0){\\n            sum+=a[0][0];\\n            if(sum%k==0)return 1;\\n            return 0;\\n        }\\n        if(i<0 || j<0)return 0;\\n        if(dp[i][j][sum%k]!=-1)return dp[i][j][sum%k];\\n        \\n        int top  = f(i-1,j,k,sum+a[i][j],a,dp)%mod;\\n        int left = f(i,j-1,k,sum+a[i][j],a,dp)%mod;\\n        \\n        return dp[i][j][sum%k] = (top+left)%mod;\\n        \\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // c=0;\\n        int m =grid.size();\\n        int  n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n     int ans=  f(m-1,n-1,k,0,grid,dp)%mod;\\n         return ans%mod;\\n    }\\n};\\'"
                    },
                    {
                        "username": "yren2",
                        "content": "passing grid (or  \"a\" in f\\'s signature) as reference instead of copying."
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "Why is this solution giving a wrong answer on third test case. Can anyone help?\n\nclass Solution {\npublic:\n    const int m = 1000000007;\n    \n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        int n = grid.size();\n        int m = grid[0].size();\n        \n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                grid[i][j] = (grid[i][j]%k);\n            }\n        }\n        \n        int dp[n][m][k];\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                for(int l=0;l<k;l++)\n                {\n                    dp[i][j][l] = 0;\n                }\n            }\n        }\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                if(i==0 && j==0)\n                {\n                    dp[i][j][grid[i][j]] = 1;\n                }\n                else\n                {\n                    for(int l=0; l<k; l++)\n                    {\n                        int newSum = (grid[i][j] + l)%k;\n                        if(j > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i][j-1][l]%m )%m;\n                        }\n                        \n                        if(i > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i-1][j][l]%m )%m;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[n-1][m-1][0];\n    }\n};"
                    },
                    {
                        "username": "yren2",
                        "content": "[@Alcatraz11](/Alcatraz11) ;)"
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "[@yren2](/yren2) Shit!! and all this time I was thinking I am making some logical error. Wasted around 15-20min to debug during contest. Thanks!!\\n"
                    },
                    {
                        "username": "yren2",
                        "content": "your variable \"m\" serves as mod as well as the dimension of the grid. "
                    }
                ]
            },
            {
                "id": 1637676,
                "content": [
                    {
                        "username": "c-m-d-",
                        "content": "3d array/vector:\\ncache[i][j][k] == num ways to get a path ending at row i, col j with remainder k"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Thanks for the hint. Could you help me understand how it works? My initial thought was to store cache[i][j][sum] instead of cache[i][j][sum%k]."
                    },
                    {
                        "username": "darkhope",
                        "content": "What if k can be large enough (up to 10^9) and n,m <=16? (asked in Google OA)"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Use a hashmap to only store path remainders in cache that actually exist, instead of making a big vector to store all possible remainders 0, 1, 2, ... k-2, k-1. Other people were overhtinking this"
                    },
                    {
                        "username": "darkhope",
                        "content": "[@adas65](/adas65) but still there can be up to 16*16 cells, I think that only backtracking will give TLE. \\nAlgo like meet in middle might pass \\n"
                    },
                    {
                        "username": "adas65",
                        "content": "I think probably we can use Backtracking in that case\\n"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "Hi, can you please tell me why this gives WA? I made sum += grid[i][j] rather than passing it as a parameter.\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    // long long dp[10005][10005][50];\\n    vector<vector<vector<int>>> dp;\\n    int recursion(int i, int j, vector<vector<int>>&grid, int sum, int k){\\n        if(i >= grid.size() || j >= grid[0].size()) return 0;\\n        if(i == grid.size() - 1 &&  j == grid[0].size() - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        if(dp[i][j][sum] != -1) return dp[i][j][sum]; \\n        sum += grid[i][j];\\n        return dp[i][j][sum] = (recursion(i + 1, j, grid, sum % k, k) + recursion(i, j + 1, grid, sum % k, k)) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // memset(dp, -1, sizeof(dp));\\n        dp.resize(grid.size() + 1, vector<vector<int>>(grid[0].size() + 1, vector<int>(51, -1)));\\n        // cout << dp[0][0][0];\\n        return recursion(0, 0, grid, 0, k) % mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vijay0109",
                        "content": "you are not passing sum as a parameter, so when your function returning and storing in dp[i][j][sum] ,your sum has been changed because you added something before recursion call then overlap problem will not match and stored in dp in wrong way ."
                    },
                    {
                        "username": "layyy",
                        "content": "try minimum path sum or unique paths before this problem"
                    },
                    {
                        "username": "padmavathievi72625",
                        "content": "I\\'m getting memory limit exceeded\\nI request some one to help me with optimization\\n\\n`class Solution:\\n    def numberOfPaths(self, grid: List[List[int]], t: int) -> int:\\n        n= len(grid[0])\\n        m= len(grid)\\n        dp = [[[]] * (n) for _ in range(m)]\\n\\n        dp[0][0]=[grid[0][0]]\\n\\n        for i in range(1,m):#len(grid)\\n            dp[i][0]=[sum([grid[i][0]]+dp[i-1][0])]\\n        for i in range(1,n):#len(grid[0])\\n            dp[0][i]=[sum([grid[0][i]]+dp[0][i-1])]\\n        \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j]=[k+grid[i][j] for k in dp[i-1][j]]+[k+grid[i][j] for k in dp[i][j-1]]\\n        \\n        count=0\\n        \\n        for i in dp[-1][-1]:\\n            if i%t==0:\\n                count+=1\\n            \\n        return count%(10**(9)+7)`\\n"
                    },
                    {
                        "username": "sanky29",
                        "content": "Why does DFS with memorization give TLE?\n\n` \nclass Solution {\npublic:\n    vector<vector<int>> dir;\n    int n;\n    int m;\n    int k;\n    vector<vector<int>> grid;\n    long long md = 1000000007;\n\n    map<vector<int>, int> mem; \n\n    long long solve(int val, int x, int y){\n        //cout << x <<\" \"<<y <<\" \"<<val << endl;\n        \n        val += grid[x][y];\n\n        auto it = mem.find({x,y,val % k});\n        if(it != mem.end()){\n            return it->second;\n        }\n        if(x == m-1 && y == n-1){\n            if(val % k == 0){\n                return 1;\n            }\n            return 0;\n        }\n        long long ans = 0;\n        for(auto d: dir){\n            int nx = x+d[0];\n            int ny = y+d[1];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                ans = (ans + solve(val, nx, ny))%md;\n            }\n        }\n        vector<int> key = {x,y,val%k};\n        mem.insert(make_pair(key, ans));\n        return ans;\n    }\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        this->grid = grid;\n        this->m = grid.size();\n        this->n = grid[0].size();\n        this->k = k;\n        dir = {{0,1}, {1,0}};\n        return solve(0,0,0);\n    }\n};.\n`"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "Why my code was giving TLE?\n\n```\npublic int numberOfPaths(int[][] grid, int k) {\n        int n=grid.length,m=grid[0].length;\n        HashMap<String,Integer> dp=new HashMap<>();\n        return dfs(0,0,grid.length, grid[0].length,grid,0,k,dp);\n    }\n    int mod=1000000007;\n    public int dfs(int i, int j, int n,int m, int grid[][],int sum, int k,HashMap<String,Integer> dp)\n    {\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\n        sum+=grid[i][j];\n        if(i==n-1 && j==m-1 && sum%k==0) return 1;\n        \n        String key = i+\" \"+j+\" \"+sum;\n        if(dp.containsKey(key)) return dp.get(key);\n        int ans = dfs(i+1,j,n,m,grid,sum,k,dp) + dfs(i,j+1,n,m,grid,sum,k,dp);\n        dp.put(key,ans);\n        return dp.get(key) % mod;\n    }\n```"
                    },
                    {
                        "username": "Suraj6261",
                        "content": "why its giving TLE  --->\\n\\n\\'\\'class Solution {\\npublic:\\n   int mod = 1e9+7;\\n    int f(int i,int j,int k,int sum,vector<vector<int>>a,vector<vector<vector<int>>>&dp){\\n        if(i==0 && j==0){\\n            sum+=a[0][0];\\n            if(sum%k==0)return 1;\\n            return 0;\\n        }\\n        if(i<0 || j<0)return 0;\\n        if(dp[i][j][sum%k]!=-1)return dp[i][j][sum%k];\\n        \\n        int top  = f(i-1,j,k,sum+a[i][j],a,dp)%mod;\\n        int left = f(i,j-1,k,sum+a[i][j],a,dp)%mod;\\n        \\n        return dp[i][j][sum%k] = (top+left)%mod;\\n        \\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // c=0;\\n        int m =grid.size();\\n        int  n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n     int ans=  f(m-1,n-1,k,0,grid,dp)%mod;\\n         return ans%mod;\\n    }\\n};\\'"
                    },
                    {
                        "username": "yren2",
                        "content": "passing grid (or  \"a\" in f\\'s signature) as reference instead of copying."
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "Why is this solution giving a wrong answer on third test case. Can anyone help?\n\nclass Solution {\npublic:\n    const int m = 1000000007;\n    \n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        int n = grid.size();\n        int m = grid[0].size();\n        \n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                grid[i][j] = (grid[i][j]%k);\n            }\n        }\n        \n        int dp[n][m][k];\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                for(int l=0;l<k;l++)\n                {\n                    dp[i][j][l] = 0;\n                }\n            }\n        }\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                if(i==0 && j==0)\n                {\n                    dp[i][j][grid[i][j]] = 1;\n                }\n                else\n                {\n                    for(int l=0; l<k; l++)\n                    {\n                        int newSum = (grid[i][j] + l)%k;\n                        if(j > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i][j-1][l]%m )%m;\n                        }\n                        \n                        if(i > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i-1][j][l]%m )%m;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[n-1][m-1][0];\n    }\n};"
                    },
                    {
                        "username": "yren2",
                        "content": "[@Alcatraz11](/Alcatraz11) ;)"
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "[@yren2](/yren2) Shit!! and all this time I was thinking I am making some logical error. Wasted around 15-20min to debug during contest. Thanks!!\\n"
                    },
                    {
                        "username": "yren2",
                        "content": "your variable \"m\" serves as mod as well as the dimension of the grid. "
                    }
                ]
            },
            {
                "id": 1637436,
                "content": [
                    {
                        "username": "c-m-d-",
                        "content": "3d array/vector:\\ncache[i][j][k] == num ways to get a path ending at row i, col j with remainder k"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Thanks for the hint. Could you help me understand how it works? My initial thought was to store cache[i][j][sum] instead of cache[i][j][sum%k]."
                    },
                    {
                        "username": "darkhope",
                        "content": "What if k can be large enough (up to 10^9) and n,m <=16? (asked in Google OA)"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Use a hashmap to only store path remainders in cache that actually exist, instead of making a big vector to store all possible remainders 0, 1, 2, ... k-2, k-1. Other people were overhtinking this"
                    },
                    {
                        "username": "darkhope",
                        "content": "[@adas65](/adas65) but still there can be up to 16*16 cells, I think that only backtracking will give TLE. \\nAlgo like meet in middle might pass \\n"
                    },
                    {
                        "username": "adas65",
                        "content": "I think probably we can use Backtracking in that case\\n"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "Hi, can you please tell me why this gives WA? I made sum += grid[i][j] rather than passing it as a parameter.\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    // long long dp[10005][10005][50];\\n    vector<vector<vector<int>>> dp;\\n    int recursion(int i, int j, vector<vector<int>>&grid, int sum, int k){\\n        if(i >= grid.size() || j >= grid[0].size()) return 0;\\n        if(i == grid.size() - 1 &&  j == grid[0].size() - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        if(dp[i][j][sum] != -1) return dp[i][j][sum]; \\n        sum += grid[i][j];\\n        return dp[i][j][sum] = (recursion(i + 1, j, grid, sum % k, k) + recursion(i, j + 1, grid, sum % k, k)) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // memset(dp, -1, sizeof(dp));\\n        dp.resize(grid.size() + 1, vector<vector<int>>(grid[0].size() + 1, vector<int>(51, -1)));\\n        // cout << dp[0][0][0];\\n        return recursion(0, 0, grid, 0, k) % mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vijay0109",
                        "content": "you are not passing sum as a parameter, so when your function returning and storing in dp[i][j][sum] ,your sum has been changed because you added something before recursion call then overlap problem will not match and stored in dp in wrong way ."
                    },
                    {
                        "username": "layyy",
                        "content": "try minimum path sum or unique paths before this problem"
                    },
                    {
                        "username": "padmavathievi72625",
                        "content": "I\\'m getting memory limit exceeded\\nI request some one to help me with optimization\\n\\n`class Solution:\\n    def numberOfPaths(self, grid: List[List[int]], t: int) -> int:\\n        n= len(grid[0])\\n        m= len(grid)\\n        dp = [[[]] * (n) for _ in range(m)]\\n\\n        dp[0][0]=[grid[0][0]]\\n\\n        for i in range(1,m):#len(grid)\\n            dp[i][0]=[sum([grid[i][0]]+dp[i-1][0])]\\n        for i in range(1,n):#len(grid[0])\\n            dp[0][i]=[sum([grid[0][i]]+dp[0][i-1])]\\n        \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j]=[k+grid[i][j] for k in dp[i-1][j]]+[k+grid[i][j] for k in dp[i][j-1]]\\n        \\n        count=0\\n        \\n        for i in dp[-1][-1]:\\n            if i%t==0:\\n                count+=1\\n            \\n        return count%(10**(9)+7)`\\n"
                    },
                    {
                        "username": "sanky29",
                        "content": "Why does DFS with memorization give TLE?\n\n` \nclass Solution {\npublic:\n    vector<vector<int>> dir;\n    int n;\n    int m;\n    int k;\n    vector<vector<int>> grid;\n    long long md = 1000000007;\n\n    map<vector<int>, int> mem; \n\n    long long solve(int val, int x, int y){\n        //cout << x <<\" \"<<y <<\" \"<<val << endl;\n        \n        val += grid[x][y];\n\n        auto it = mem.find({x,y,val % k});\n        if(it != mem.end()){\n            return it->second;\n        }\n        if(x == m-1 && y == n-1){\n            if(val % k == 0){\n                return 1;\n            }\n            return 0;\n        }\n        long long ans = 0;\n        for(auto d: dir){\n            int nx = x+d[0];\n            int ny = y+d[1];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                ans = (ans + solve(val, nx, ny))%md;\n            }\n        }\n        vector<int> key = {x,y,val%k};\n        mem.insert(make_pair(key, ans));\n        return ans;\n    }\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        this->grid = grid;\n        this->m = grid.size();\n        this->n = grid[0].size();\n        this->k = k;\n        dir = {{0,1}, {1,0}};\n        return solve(0,0,0);\n    }\n};.\n`"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "Why my code was giving TLE?\n\n```\npublic int numberOfPaths(int[][] grid, int k) {\n        int n=grid.length,m=grid[0].length;\n        HashMap<String,Integer> dp=new HashMap<>();\n        return dfs(0,0,grid.length, grid[0].length,grid,0,k,dp);\n    }\n    int mod=1000000007;\n    public int dfs(int i, int j, int n,int m, int grid[][],int sum, int k,HashMap<String,Integer> dp)\n    {\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\n        sum+=grid[i][j];\n        if(i==n-1 && j==m-1 && sum%k==0) return 1;\n        \n        String key = i+\" \"+j+\" \"+sum;\n        if(dp.containsKey(key)) return dp.get(key);\n        int ans = dfs(i+1,j,n,m,grid,sum,k,dp) + dfs(i,j+1,n,m,grid,sum,k,dp);\n        dp.put(key,ans);\n        return dp.get(key) % mod;\n    }\n```"
                    },
                    {
                        "username": "Suraj6261",
                        "content": "why its giving TLE  --->\\n\\n\\'\\'class Solution {\\npublic:\\n   int mod = 1e9+7;\\n    int f(int i,int j,int k,int sum,vector<vector<int>>a,vector<vector<vector<int>>>&dp){\\n        if(i==0 && j==0){\\n            sum+=a[0][0];\\n            if(sum%k==0)return 1;\\n            return 0;\\n        }\\n        if(i<0 || j<0)return 0;\\n        if(dp[i][j][sum%k]!=-1)return dp[i][j][sum%k];\\n        \\n        int top  = f(i-1,j,k,sum+a[i][j],a,dp)%mod;\\n        int left = f(i,j-1,k,sum+a[i][j],a,dp)%mod;\\n        \\n        return dp[i][j][sum%k] = (top+left)%mod;\\n        \\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // c=0;\\n        int m =grid.size();\\n        int  n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n     int ans=  f(m-1,n-1,k,0,grid,dp)%mod;\\n         return ans%mod;\\n    }\\n};\\'"
                    },
                    {
                        "username": "yren2",
                        "content": "passing grid (or  \"a\" in f\\'s signature) as reference instead of copying."
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "Why is this solution giving a wrong answer on third test case. Can anyone help?\n\nclass Solution {\npublic:\n    const int m = 1000000007;\n    \n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        int n = grid.size();\n        int m = grid[0].size();\n        \n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                grid[i][j] = (grid[i][j]%k);\n            }\n        }\n        \n        int dp[n][m][k];\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                for(int l=0;l<k;l++)\n                {\n                    dp[i][j][l] = 0;\n                }\n            }\n        }\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                if(i==0 && j==0)\n                {\n                    dp[i][j][grid[i][j]] = 1;\n                }\n                else\n                {\n                    for(int l=0; l<k; l++)\n                    {\n                        int newSum = (grid[i][j] + l)%k;\n                        if(j > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i][j-1][l]%m )%m;\n                        }\n                        \n                        if(i > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i-1][j][l]%m )%m;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[n-1][m-1][0];\n    }\n};"
                    },
                    {
                        "username": "yren2",
                        "content": "[@Alcatraz11](/Alcatraz11) ;)"
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "[@yren2](/yren2) Shit!! and all this time I was thinking I am making some logical error. Wasted around 15-20min to debug during contest. Thanks!!\\n"
                    },
                    {
                        "username": "yren2",
                        "content": "your variable \"m\" serves as mod as well as the dimension of the grid. "
                    }
                ]
            },
            {
                "id": 1637329,
                "content": [
                    {
                        "username": "c-m-d-",
                        "content": "3d array/vector:\\ncache[i][j][k] == num ways to get a path ending at row i, col j with remainder k"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Thanks for the hint. Could you help me understand how it works? My initial thought was to store cache[i][j][sum] instead of cache[i][j][sum%k]."
                    },
                    {
                        "username": "darkhope",
                        "content": "What if k can be large enough (up to 10^9) and n,m <=16? (asked in Google OA)"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Use a hashmap to only store path remainders in cache that actually exist, instead of making a big vector to store all possible remainders 0, 1, 2, ... k-2, k-1. Other people were overhtinking this"
                    },
                    {
                        "username": "darkhope",
                        "content": "[@adas65](/adas65) but still there can be up to 16*16 cells, I think that only backtracking will give TLE. \\nAlgo like meet in middle might pass \\n"
                    },
                    {
                        "username": "adas65",
                        "content": "I think probably we can use Backtracking in that case\\n"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "Hi, can you please tell me why this gives WA? I made sum += grid[i][j] rather than passing it as a parameter.\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    // long long dp[10005][10005][50];\\n    vector<vector<vector<int>>> dp;\\n    int recursion(int i, int j, vector<vector<int>>&grid, int sum, int k){\\n        if(i >= grid.size() || j >= grid[0].size()) return 0;\\n        if(i == grid.size() - 1 &&  j == grid[0].size() - 1 && (sum + grid[i][j]) % k == 0) return 1;\\n        if(dp[i][j][sum] != -1) return dp[i][j][sum]; \\n        sum += grid[i][j];\\n        return dp[i][j][sum] = (recursion(i + 1, j, grid, sum % k, k) + recursion(i, j + 1, grid, sum % k, k)) % mod;\\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // memset(dp, -1, sizeof(dp));\\n        dp.resize(grid.size() + 1, vector<vector<int>>(grid[0].size() + 1, vector<int>(51, -1)));\\n        // cout << dp[0][0][0];\\n        return recursion(0, 0, grid, 0, k) % mod;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vijay0109",
                        "content": "you are not passing sum as a parameter, so when your function returning and storing in dp[i][j][sum] ,your sum has been changed because you added something before recursion call then overlap problem will not match and stored in dp in wrong way ."
                    },
                    {
                        "username": "layyy",
                        "content": "try minimum path sum or unique paths before this problem"
                    },
                    {
                        "username": "padmavathievi72625",
                        "content": "I\\'m getting memory limit exceeded\\nI request some one to help me with optimization\\n\\n`class Solution:\\n    def numberOfPaths(self, grid: List[List[int]], t: int) -> int:\\n        n= len(grid[0])\\n        m= len(grid)\\n        dp = [[[]] * (n) for _ in range(m)]\\n\\n        dp[0][0]=[grid[0][0]]\\n\\n        for i in range(1,m):#len(grid)\\n            dp[i][0]=[sum([grid[i][0]]+dp[i-1][0])]\\n        for i in range(1,n):#len(grid[0])\\n            dp[0][i]=[sum([grid[0][i]]+dp[0][i-1])]\\n        \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                dp[i][j]=[k+grid[i][j] for k in dp[i-1][j]]+[k+grid[i][j] for k in dp[i][j-1]]\\n        \\n        count=0\\n        \\n        for i in dp[-1][-1]:\\n            if i%t==0:\\n                count+=1\\n            \\n        return count%(10**(9)+7)`\\n"
                    },
                    {
                        "username": "sanky29",
                        "content": "Why does DFS with memorization give TLE?\n\n` \nclass Solution {\npublic:\n    vector<vector<int>> dir;\n    int n;\n    int m;\n    int k;\n    vector<vector<int>> grid;\n    long long md = 1000000007;\n\n    map<vector<int>, int> mem; \n\n    long long solve(int val, int x, int y){\n        //cout << x <<\" \"<<y <<\" \"<<val << endl;\n        \n        val += grid[x][y];\n\n        auto it = mem.find({x,y,val % k});\n        if(it != mem.end()){\n            return it->second;\n        }\n        if(x == m-1 && y == n-1){\n            if(val % k == 0){\n                return 1;\n            }\n            return 0;\n        }\n        long long ans = 0;\n        for(auto d: dir){\n            int nx = x+d[0];\n            int ny = y+d[1];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                ans = (ans + solve(val, nx, ny))%md;\n            }\n        }\n        vector<int> key = {x,y,val%k};\n        mem.insert(make_pair(key, ans));\n        return ans;\n    }\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        this->grid = grid;\n        this->m = grid.size();\n        this->n = grid[0].size();\n        this->k = k;\n        dir = {{0,1}, {1,0}};\n        return solve(0,0,0);\n    }\n};.\n`"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "Why my code was giving TLE?\n\n```\npublic int numberOfPaths(int[][] grid, int k) {\n        int n=grid.length,m=grid[0].length;\n        HashMap<String,Integer> dp=new HashMap<>();\n        return dfs(0,0,grid.length, grid[0].length,grid,0,k,dp);\n    }\n    int mod=1000000007;\n    public int dfs(int i, int j, int n,int m, int grid[][],int sum, int k,HashMap<String,Integer> dp)\n    {\n        if(i<0 || i>=n || j<0 || j>=m) return 0;\n        sum+=grid[i][j];\n        if(i==n-1 && j==m-1 && sum%k==0) return 1;\n        \n        String key = i+\" \"+j+\" \"+sum;\n        if(dp.containsKey(key)) return dp.get(key);\n        int ans = dfs(i+1,j,n,m,grid,sum,k,dp) + dfs(i,j+1,n,m,grid,sum,k,dp);\n        dp.put(key,ans);\n        return dp.get(key) % mod;\n    }\n```"
                    },
                    {
                        "username": "Suraj6261",
                        "content": "why its giving TLE  --->\\n\\n\\'\\'class Solution {\\npublic:\\n   int mod = 1e9+7;\\n    int f(int i,int j,int k,int sum,vector<vector<int>>a,vector<vector<vector<int>>>&dp){\\n        if(i==0 && j==0){\\n            sum+=a[0][0];\\n            if(sum%k==0)return 1;\\n            return 0;\\n        }\\n        if(i<0 || j<0)return 0;\\n        if(dp[i][j][sum%k]!=-1)return dp[i][j][sum%k];\\n        \\n        int top  = f(i-1,j,k,sum+a[i][j],a,dp)%mod;\\n        int left = f(i,j-1,k,sum+a[i][j],a,dp)%mod;\\n        \\n        return dp[i][j][sum%k] = (top+left)%mod;\\n        \\n    }\\n    int numberOfPaths(vector<vector<int>>& grid, int k) {\\n        // c=0;\\n        int m =grid.size();\\n        int  n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n     int ans=  f(m-1,n-1,k,0,grid,dp)%mod;\\n         return ans%mod;\\n    }\\n};\\'"
                    },
                    {
                        "username": "yren2",
                        "content": "passing grid (or  \"a\" in f\\'s signature) as reference instead of copying."
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "Why is this solution giving a wrong answer on third test case. Can anyone help?\n\nclass Solution {\npublic:\n    const int m = 1000000007;\n    \n    int numberOfPaths(vector<vector<int>>& grid, int k) {\n        int n = grid.size();\n        int m = grid[0].size();\n        \n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                grid[i][j] = (grid[i][j]%k);\n            }\n        }\n        \n        int dp[n][m][k];\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                for(int l=0;l<k;l++)\n                {\n                    dp[i][j][l] = 0;\n                }\n            }\n        }\n        \n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                if(i==0 && j==0)\n                {\n                    dp[i][j][grid[i][j]] = 1;\n                }\n                else\n                {\n                    for(int l=0; l<k; l++)\n                    {\n                        int newSum = (grid[i][j] + l)%k;\n                        if(j > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i][j-1][l]%m )%m;\n                        }\n                        \n                        if(i > 0){\n                            dp[i][j][newSum] = (dp[i][j][newSum]%m + dp[i-1][j][l]%m )%m;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[n-1][m-1][0];\n    }\n};"
                    },
                    {
                        "username": "yren2",
                        "content": "[@Alcatraz11](/Alcatraz11) ;)"
                    },
                    {
                        "username": "Alcatraz11",
                        "content": "[@yren2](/yren2) Shit!! and all this time I was thinking I am making some logical error. Wasted around 15-20min to debug during contest. Thanks!!\\n"
                    },
                    {
                        "username": "yren2",
                        "content": "your variable \"m\" serves as mod as well as the dimension of the grid. "
                    }
                ]
            }
        ]
    }
]