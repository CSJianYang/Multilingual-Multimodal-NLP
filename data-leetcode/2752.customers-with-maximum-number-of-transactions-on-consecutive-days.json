[
    {
        "title": "Cousins in Binary Tree II",
        "question_content": "Given the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins' values.\nTwo nodes of a binary tree are cousins if they have the same depth with different parents.\nReturn the root of the modified tree.\nNote that the depth of a node is the number of edges in the path from the root node to it.\n&nbsp;\nExample 1:\n\nInput: root = [5,4,9,1,10,null,7]\nOutput: [0,0,0,7,7,null,11]\nExplanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 5 does not have any cousins so its sum is 0.\n- Node with value 4 does not have any cousins so its sum is 0.\n- Node with value 9 does not have any cousins so its sum is 0.\n- Node with value 1 has a cousin with value 7 so its sum is 7.\n- Node with value 10 has a cousin with value 7 so its sum is 7.\n- Node with value 7 has cousins with values 1 and 10 so its sum is 11.\n\nExample 2:\n\nInput: root = [3,1,2]\nOutput: [0,0,0]\nExplanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 3 does not have any cousins so its sum is 0.\n- Node with value 1 does not have any cousins so its sum is 0.\n- Node with value 2 does not have any cousins so its sum is 0.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 105].\n\t1 <= Node.val <= 104",
        "solutions": [
            {
                "id": 3420099,
                "title": "simple-bfs-tracking-sum-of-child-very-simple-easy-to-understand",
                "content": "<b>Please Up Vote if you like the solution\\n```\\n/*\\n1. Run BFS \\n2. While traversing take the sum of the child nodes & also keep storing the node in a buffer\\n3. After each stage of the BFS, traverse the buf & update the node with value sum - (child\\'s sum)\\n*/\\n\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    root->val = 0;\\n    queue<TreeNode*> q;  q.push(root);\\n    while(!q.empty()){\\n        int n = q.size(), sum = 0;\\n        vector<TreeNode*> buf;\\n        while(n--){\\n            TreeNode* node = q.front(); q.pop();\\n            buf.push_back(node);\\n            if(node->left) { q.push(node->left); sum += node->left->val; }\\n            if(node->right){ q.push(node->right); sum += node->right->val; }\\n        }\\n        for(auto node: buf){\\n            int  t = sum;\\n            if(node->left)  t -= node->left->val;\\n            if(node->right) t -= node->right->val;\\n            if(node->left)  node->left->val = t;\\n            if(node->right) node->right->val = t;\\n        }\\n    }\\n    return root;\\n}\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n1. Run BFS \\n2. While traversing take the sum of the child nodes & also keep storing the node in a buffer\\n3. After each stage of the BFS, traverse the buf & update the node with value sum - (child\\'s sum)\\n*/\\n\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    root->val = 0;\\n    queue<TreeNode*> q;  q.push(root);\\n    while(!q.empty()){\\n        int n = q.size(), sum = 0;\\n        vector<TreeNode*> buf;\\n        while(n--){\\n            TreeNode* node = q.front(); q.pop();\\n            buf.push_back(node);\\n            if(node->left) { q.push(node->left); sum += node->left->val; }\\n            if(node->right){ q.push(node->right); sum += node->right->val; }\\n        }\\n        for(auto node: buf){\\n            int  t = sum;\\n            if(node->left)  t -= node->left->val;\\n            if(node->right) t -= node->right->val;\\n            if(node->left)  node->left->val = t;\\n            if(node->right) node->right->val = t;\\n        }\\n    }\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420081,
                "title": "level-sum",
                "content": "> My account (votrubac) was banned due to the contest rules violation... I sometimes re-use bits of my previous solutions, like standard algorithms. Not sure if it spooked the plagiarism checker or something.\\n\\nWe traverse the tree two times, tracking the current depth `d`.\\n\\nFirst time, we sum values for each level using `l_sum`.\\n\\nSecond time, we update the node value to the level sum, minus value of the current node and its sibling `sib`.\\n\\nFor that, we pass the value of a sibling from the parent node.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> l_sum;\\n    void level_sum(TreeNode* n, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        l_sum.resize(max((int)l_sum.size(), d + 1));\\n        l_sum[d] += n->val;\\n        level_sum(n->left, d + 1);\\n        level_sum(n->right, d + 1);\\n    }\\n    void update_sum(TreeNode* n, int sib_sum, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        n->val = l_sum[d] - sib_sum;\\n        sib_sum = (n->left == nullptr ? 0 : n->left->val)\\n            + (n->right == nullptr ? 0 : n->right->val);\\n        update_sum(n->left, sib_sum, d + 1);\\n        update_sum(n->right, sib_sum, d + 1);\\n    }    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        level_sum(root);\\n        update_sum(root, root->val);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> l_sum;\\n    void level_sum(TreeNode* n, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        l_sum.resize(max((int)l_sum.size(), d + 1));\\n        l_sum[d] += n->val;\\n        level_sum(n->left, d + 1);\\n        level_sum(n->right, d + 1);\\n    }\\n    void update_sum(TreeNode* n, int sib_sum, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        n->val = l_sum[d] - sib_sum;\\n        sib_sum = (n->left == nullptr ? 0 : n->left->val)\\n            + (n->right == nullptr ? 0 : n->right->val);\\n        update_sum(n->left, sib_sum, d + 1);\\n        update_sum(n->right, sib_sum, d + 1);\\n    }    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        level_sum(root);\\n        update_sum(root, root->val);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419991,
                "title": "c-java-python3-double-dfs",
                "content": "\\n# Intuition\\nFirst find sum of all nodes on each level. Then to find sum of cousin, just need to subtract the value of child and its direct siblings to find sum of cousins.\\n\\n# Approach\\nThe first dfs finds the sum of nodes on each level\\nThe second dfs finds the sum of cousins and creates new binary tree\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python3**:\\n```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    m = Counter()\\n    def dfs(r, l):\\n        if not r: return\\n        m[l] += r.val\\n        dfs(r.left, l + 1)\\n        dfs(r.right, l + 1)\\n    dfs(root, 0)\\n    \\n    def dfs1(r, l, curr):\\n        sum_of_cousins = m[l + 1] - (r.left.val if r.left else 0) - (r.right.val if r.right else 0)\\n        if r.left:\\n            curr.left = TreeNode(sum_of_cousins)\\n            dfs1(r.left, l + 1, curr.left)\\n        if r.right:\\n            curr.right = TreeNode(sum_of_cousins)\\n            dfs1(r.right, l + 1, curr.right)\\n        return curr\\n    return dfs1(root, 0, TreeNode(0))\\n```\\n\\n**C++**:\\n```\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    unordered_map<int, int> m;\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nvoid dfs(TreeNode* r, int l, unordered_map<int, int>& m) {\\n    if (!r) return;\\n    m[l] += r->val;\\n    dfs(r->left, l + 1, m);\\n    dfs(r->right, l + 1, m);\\n}\\nTreeNode* dfs1(TreeNode* r, int l, TreeNode* curr, unordered_map<int, int>& m) {\\n    int sum_of_cousins = m[l + 1] - (r->left ? r->left->val : 0) - (r->right ? r->right->val : 0);\\n    if (r->left) {\\n        curr->left = new TreeNode(sum_of_cousins);\\n        dfs1(r->left, l + 1, curr->left, m);\\n    }\\n    if (r->right) {\\n        curr->right = new TreeNode(sum_of_cousins);\\n        dfs1(r->right, l + 1, curr->right, m);\\n    }\\n    return curr;\\n}\\n```\\n\\n**Java**:\\n```\\npublic TreeNode replaceValueInTree(TreeNode root) {\\n    Map<Integer, Integer> m = new HashMap<>();\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nprivate void dfs(TreeNode r, int l, Map<Integer, Integer> m) {\\n    if (r == null) return;\\n    m.put(l, m.getOrDefault(l, 0) + r.val);\\n    dfs(r.left, l + 1, m);\\n    dfs(r.right, l + 1, m);\\n}\\nprivate TreeNode dfs1(TreeNode r, int l, TreeNode curr, Map<Integer, Integer> m) {\\n    int sum_of_cousins = m.getOrDefault(l + 1, 0) - ((r.left != null) ? r.left.val : 0) - ((r.right != null) ? r.right.val : 0);\\n    if (r.left != null) {\\n        curr.left = new TreeNode(sum_of_cousins);\\n        dfs1(r.left, l + 1, curr.left, m);\\n    }\\n    if (r.right != null) {\\n        curr.right = new TreeNode(sum_of_cousins);\\n        dfs1(r.right, l + 1, curr.right, m);\\n    }\\n    return curr;\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    m = Counter()\\n    def dfs(r, l):\\n        if not r: return\\n        m[l] += r.val\\n        dfs(r.left, l + 1)\\n        dfs(r.right, l + 1)\\n    dfs(root, 0)\\n    \\n    def dfs1(r, l, curr):\\n        sum_of_cousins = m[l + 1] - (r.left.val if r.left else 0) - (r.right.val if r.right else 0)\\n        if r.left:\\n            curr.left = TreeNode(sum_of_cousins)\\n            dfs1(r.left, l + 1, curr.left)\\n        if r.right:\\n            curr.right = TreeNode(sum_of_cousins)\\n            dfs1(r.right, l + 1, curr.right)\\n        return curr\\n    return dfs1(root, 0, TreeNode(0))\\n```\n```\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    unordered_map<int, int> m;\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nvoid dfs(TreeNode* r, int l, unordered_map<int, int>& m) {\\n    if (!r) return;\\n    m[l] += r->val;\\n    dfs(r->left, l + 1, m);\\n    dfs(r->right, l + 1, m);\\n}\\nTreeNode* dfs1(TreeNode* r, int l, TreeNode* curr, unordered_map<int, int>& m) {\\n    int sum_of_cousins = m[l + 1] - (r->left ? r->left->val : 0) - (r->right ? r->right->val : 0);\\n    if (r->left) {\\n        curr->left = new TreeNode(sum_of_cousins);\\n        dfs1(r->left, l + 1, curr->left, m);\\n    }\\n    if (r->right) {\\n        curr->right = new TreeNode(sum_of_cousins);\\n        dfs1(r->right, l + 1, curr->right, m);\\n    }\\n    return curr;\\n}\\n```\n```\\npublic TreeNode replaceValueInTree(TreeNode root) {\\n    Map<Integer, Integer> m = new HashMap<>();\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nprivate void dfs(TreeNode r, int l, Map<Integer, Integer> m) {\\n    if (r == null) return;\\n    m.put(l, m.getOrDefault(l, 0) + r.val);\\n    dfs(r.left, l + 1, m);\\n    dfs(r.right, l + 1, m);\\n}\\nprivate TreeNode dfs1(TreeNode r, int l, TreeNode curr, Map<Integer, Integer> m) {\\n    int sum_of_cousins = m.getOrDefault(l + 1, 0) - ((r.left != null) ? r.left.val : 0) - ((r.right != null) ? r.right.val : 0);\\n    if (r.left != null) {\\n        curr.left = new TreeNode(sum_of_cousins);\\n        dfs1(r.left, l + 1, curr.left, m);\\n    }\\n    if (r.right != null) {\\n        curr.right = new TreeNode(sum_of_cousins);\\n        dfs1(r.right, l + 1, curr.right, m);\\n    }\\n    return curr;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420337,
                "title": "c-simplest-and-easy-to-understand-superfast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we are going to find the level-wise sum of binary tree and store it in a vector `depthsum`. Thus, `depth[i]` will contain the sum of nodes at depth `i`. So, we can assign the node the value `depth[i]` and deduction the value of it\\'s own and it parental childer(sibling).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRead the comments you we will be able to get the solution easily.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> depthsum;\\n\\n    // Function to find the depth of each element.\\n    void solve(TreeNode* root, int d){\\n        if(root==NULL) return;\\n\\n        if(d>=depthsum.size()) depthsum.push_back(root->val);\\n        else depthsum[d] += root->val;\\n\\n        solve(root->left, d+1);\\n        solve(root->right, d+1);\\n    }\\n    \\n    // Function to recreate the tree \\n    void fill(TreeNode* root, int d){  \\n        if(root==NULL) return;\\n        int ded = 0;\\n\\n        // storing the value of children of current node in ded which to be deducted.\\n        if(root->left) ded += root->left->val;\\n        if(root->right) ded += root->right->val;\\n\\n        // then assigning the sum of all nodes at that depth and subtracting it\\'s own value and the value of its siblings which are stored in ded\\n        if(root->left) root->left->val = depthsum[d+1] -ded;\\n        if(root->right) root->right->val = depthsum[d+1] -ded;\\n        \\n        // then recursively do the same for all the nodes.\\n        fill(root->left, d+1);\\n        fill(root->right, d+1);\\n        \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        root->val=0;\\n        solve(root, 0); // Function to find the depth of each element.\\n        fill(root, 0); // Function to recreate the tree \\n        return root;    \\n    }\\n};\\n\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Backtracking",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> depthsum;\\n\\n    // Function to find the depth of each element.\\n    void solve(TreeNode* root, int d){\\n        if(root==NULL) return;\\n\\n        if(d>=depthsum.size()) depthsum.push_back(root->val);\\n        else depthsum[d] += root->val;\\n\\n        solve(root->left, d+1);\\n        solve(root->right, d+1);\\n    }\\n    \\n    // Function to recreate the tree \\n    void fill(TreeNode* root, int d){  \\n        if(root==NULL) return;\\n        int ded = 0;\\n\\n        // storing the value of children of current node in ded which to be deducted.\\n        if(root->left) ded += root->left->val;\\n        if(root->right) ded += root->right->val;\\n\\n        // then assigning the sum of all nodes at that depth and subtracting it\\'s own value and the value of its siblings which are stored in ded\\n        if(root->left) root->left->val = depthsum[d+1] -ded;\\n        if(root->right) root->right->val = depthsum[d+1] -ded;\\n        \\n        // then recursively do the same for all the nodes.\\n        fill(root->left, d+1);\\n        fill(root->right, d+1);\\n        \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        root->val=0;\\n        solve(root, 0); // Function to find the depth of each element.\\n        fill(root, 0); // Function to recreate the tree \\n        return root;    \\n    }\\n};\\n\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419993,
                "title": "java-python-3-dfs-and-bfs-w-brief-explanation-and-analysis",
                "content": "**DFS**\\n\\n\\n1. First `dfs` get the sum of each level;\\n2. In Second `dfs`, we first locate the nodes with `2` kids, then update the value of each kid to the sum of the `2`kids; then for each node use level sum to minus its updated value to get final value.\\n\\n```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> levelSum = new ArrayList<>();\\n        dfs(root, 0, levelSum);\\n        dfs2(root, 0, levelSum);\\n        return root;\\n    }\\n    private void dfs(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            if (depth == levelSum.size()) {\\n                levelSum.add(0);\\n            }\\n            levelSum.set(depth, levelSum.get(depth) + n.val);\\n            dfs(n.left, depth + 1, levelSum);    \\n            dfs(n.right, depth + 1, levelSum);    \\n        }\\n    }\\n    private void dfs2(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            n.val = levelSum.get(depth) - n.val;\\n            if (n.left != null && n.right != null) {\\n                int siblingsSum = n.left.val + n.right.val;\\n                n.left.val = n.right.val = siblingsSum;\\n            }\\n            dfs2(n.left, depth + 1, levelSum);\\n            dfs2(n.right, depth + 1, levelSum);\\n        }\\n    }\\n```\\n\\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\n        def dfs(node: TreeNode, depth: int) -> None:\\n            if node:\\n                if len(level_sum) == depth:\\n                    level_sum.append(0)\\n                level_sum[depth] += node.val\\n                dfs(node.left, depth + 1)\\n                dfs(node.right, depth + 1)\\n\\n        def dfs2(node: TreeNode, depth: int) -> None:\\n            if node:\\n                node.val = level_sum[depth] - node.val\\n                if node.left and node.right:\\n                    siblings_sum = node.left.val + node.right.val\\n                    node.left.val = node.right.val = siblings_sum\\n                dfs2(node.left, depth + 1)\\n                dfs2(node.right, depth + 1)\\n\\n        level_sum = []\\n        dfs(root, 0)        \\n        dfs2(root, 0)        \\n        return root\\n```\\n**Analysis:**\\nTime: `O(n)`, space: `O(h)`, where `n = # of nodes, h = height of the tree`.\\n\\n----\\n\\n**BFS**\\n\\nThe following idea and the corresponding 2 codes inspired by **@pbmessi**:\\n\\n1. BFS traversal to get next level sum, get the sum of each level;\\n2. During traversal, locate the nodes with `2` kids, then update the value of each kid to the sum of the `2`kids; then for each node use level sum to minus its updated value to get final value.\\n\\n\\n```java\\n    public TreeNode replaceValueInTree2(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int currentLevelSum = root.val;\\n        while (!q.isEmpty()) {\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                n.val = currentLevelSum - n.val;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n                if (n.left != null && n.right != null) {\\n                    int sum = n.left.val + n.right.val;\\n                    n.left.val = n.right.val = sum;\\n                }\\n            }\\n            currentLevelSum = nextLevelSum;\\n        }\\n        return root;        \\n    }\\n```\\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        current_level_sum = root.val\\n        q = [root]\\n        while q:\\n            next_level, next_level_sum = [], 0\\n            for node in q:\\n                node.val = current_level_sum - node.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n                if node.left and node.right:\\n                    sm = node.left.val + node.right.val\\n                    node.left.val = node.right.val = sm\\n            q, current_level_sum = next_level, next_level_sum\\n        return root\\n```\\n\\nAnother variant of **BFS**:\\n\\n1. BFS traversal to get next level sum, and keep a copy of current level of nodes;\\n2. For each node, use next level sum minus its kids\\' value sum to get the required value.\\n\\n```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        root.val = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            List<TreeNode> parents = new ArrayList<>(q);\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n            }\\n            for (TreeNode n : parents) {\\n                int replacedVal = nextLevelSum;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        replacedVal -= kid.val;\\n                    }\\n                }\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        kid.val = replacedVal;\\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n```\\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        q = [root]\\n        while q:\\n            next_level, parents = [], q[:]\\n            next_level_sum = 0\\n            for node in q:\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n            for node in parents:                \\n                replaced_val = next_level_sum\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        replaced_val -= kid.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        kid.val = replaced_val\\n            q = next_level        \\n        return root\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`,  space: `O(w)`, where `n = # of nodes, w = the max # of the nodes among all levels of the tree`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> levelSum = new ArrayList<>();\\n        dfs(root, 0, levelSum);\\n        dfs2(root, 0, levelSum);\\n        return root;\\n    }\\n    private void dfs(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            if (depth == levelSum.size()) {\\n                levelSum.add(0);\\n            }\\n            levelSum.set(depth, levelSum.get(depth) + n.val);\\n            dfs(n.left, depth + 1, levelSum);    \\n            dfs(n.right, depth + 1, levelSum);    \\n        }\\n    }\\n    private void dfs2(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            n.val = levelSum.get(depth) - n.val;\\n            if (n.left != null && n.right != null) {\\n                int siblingsSum = n.left.val + n.right.val;\\n                n.left.val = n.right.val = siblingsSum;\\n            }\\n            dfs2(n.left, depth + 1, levelSum);\\n            dfs2(n.right, depth + 1, levelSum);\\n        }\\n    }\\n```\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\n        def dfs(node: TreeNode, depth: int) -> None:\\n            if node:\\n                if len(level_sum) == depth:\\n                    level_sum.append(0)\\n                level_sum[depth] += node.val\\n                dfs(node.left, depth + 1)\\n                dfs(node.right, depth + 1)\\n\\n        def dfs2(node: TreeNode, depth: int) -> None:\\n            if node:\\n                node.val = level_sum[depth] - node.val\\n                if node.left and node.right:\\n                    siblings_sum = node.left.val + node.right.val\\n                    node.left.val = node.right.val = siblings_sum\\n                dfs2(node.left, depth + 1)\\n                dfs2(node.right, depth + 1)\\n\\n        level_sum = []\\n        dfs(root, 0)        \\n        dfs2(root, 0)        \\n        return root\\n```\n```java\\n    public TreeNode replaceValueInTree2(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int currentLevelSum = root.val;\\n        while (!q.isEmpty()) {\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                n.val = currentLevelSum - n.val;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n                if (n.left != null && n.right != null) {\\n                    int sum = n.left.val + n.right.val;\\n                    n.left.val = n.right.val = sum;\\n                }\\n            }\\n            currentLevelSum = nextLevelSum;\\n        }\\n        return root;        \\n    }\\n```\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        current_level_sum = root.val\\n        q = [root]\\n        while q:\\n            next_level, next_level_sum = [], 0\\n            for node in q:\\n                node.val = current_level_sum - node.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n                if node.left and node.right:\\n                    sm = node.left.val + node.right.val\\n                    node.left.val = node.right.val = sm\\n            q, current_level_sum = next_level, next_level_sum\\n        return root\\n```\n```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        root.val = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            List<TreeNode> parents = new ArrayList<>(q);\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n            }\\n            for (TreeNode n : parents) {\\n                int replacedVal = nextLevelSum;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        replacedVal -= kid.val;\\n                    }\\n                }\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        kid.val = replacedVal;\\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n```\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        q = [root]\\n        while q:\\n            next_level, parents = [], q[:]\\n            next_level_sum = 0\\n            for node in q:\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n            for node in parents:                \\n                replaced_val = next_level_sum\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        replaced_val -= kid.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        kid.val = replaced_val\\n            q = next_level        \\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420073,
                "title": "c-easy-beginner-friendly-level-order-traversal",
                "content": "# Intuition\\nOverall, this solution calculates the sum of values of nodes at each level in the first pass and uses that information to update the values of nodes in the second pass, effectively replacing the values in the tree as required.\\n\\n# Approach\\nThe approach used in this solution is a two-pass level-order traversal of the tree. In the first pass, the sum of values of nodes at each level is calculated and stored in an unordered map with the level as the key. In the second pass, the values of nodes are updated using the sum of values of its children nodes and its own original value, retrieved from the map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int lev=0;\\n        unordered_map<int, int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        mp[0]=root->val;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    mp[lev]+=(n->left->val);\\n                }\\n                if(n->right)\\n                {\\n                    q.push(n->right);\\n                    mp[lev]+=(n->right->val);\\n                }\\n            }\\n        }\\n\\n        q.push(root);\\n        lev=0;\\n        root->val=0;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                int lef=(n->left)?n->left->val:0;\\n                int ri=(n->right)?n->right->val:0;\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    n->left->val=mp[lev]-lef-ri;\\n                }\\n                if(n->right) \\n                {\\n                    q.push(n->right);\\n                    n->right->val=mp[lev]-lef-ri;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int lev=0;\\n        unordered_map<int, int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        mp[0]=root->val;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    mp[lev]+=(n->left->val);\\n                }\\n                if(n->right)\\n                {\\n                    q.push(n->right);\\n                    mp[lev]+=(n->right->val);\\n                }\\n            }\\n        }\\n\\n        q.push(root);\\n        lev=0;\\n        root->val=0;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                int lef=(n->left)?n->left->val:0;\\n                int ri=(n->right)?n->right->val:0;\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    n->left->val=mp[lev]-lef-ri;\\n                }\\n                if(n->right) \\n                {\\n                    q.push(n->right);\\n                    n->right->val=mp[lev]-lef-ri;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419973,
                "title": "c-full-explanation-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    //same depth means node at same level\\n    //for this we will use queue\\n    //As we need parent information of each node so queue will have curr_node and its parent as pair \\n    // The main point here is ans of node at particular level is =(Total_Sum at that level) - (sum of node having same parent)\\n    // now for calculating sum of node having same parent i am using map\\n    //The key point here is i am not using int as my key in map because two different node can have same value so i am using TreeNode* as key\\n    // I am modifying same tree so i have used temp arr to store node in a way they are coming in queue at each level\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>>q;       \\n        q.push({NULL,root});\\n        \\n        while(q.size())\\n        {\\n            int size=q.size();\\n            unordered_map<TreeNode*,int>mp;\\n            vector<pair<TreeNode*,TreeNode*>>temp;\\n            int total_sum=0;\\n            while(size--)\\n            {\\n                auto node=q.front(); //node.first=parent , node.second=curr_node\\n                q.pop();\\n                 \\n                total_sum+=node.second->val;  //calculating total sum at particular level\\n                mp[node.first]+=node.second->val;  //storing sum of node having same parent\\n                temp.push_back({node.first,node.second}); //this is used so that we can modify current tree\\n                \\n                if(node.second->left)\\n                    q.push({node.second,node.second->left});\\n                \\n                if(node.second->right)\\n                    q.push({node.second,node.second->right});\\n            }\\n            \\n            for(auto it:temp)\\n            {\\n                int val=total_sum-mp[it.first]; //formula\\n                it.second->val=val;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //same depth means node at same level\\n    //for this we will use queue\\n    //As we need parent information of each node so queue will have curr_node and its parent as pair \\n    // The main point here is ans of node at particular level is =(Total_Sum at that level) - (sum of node having same parent)\\n    // now for calculating sum of node having same parent i am using map\\n    //The key point here is i am not using int as my key in map because two different node can have same value so i am using TreeNode* as key\\n    // I am modifying same tree so i have used temp arr to store node in a way they are coming in queue at each level\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>>q;       \\n        q.push({NULL,root});\\n        \\n        while(q.size())\\n        {\\n            int size=q.size();\\n            unordered_map<TreeNode*,int>mp;\\n            vector<pair<TreeNode*,TreeNode*>>temp;\\n            int total_sum=0;\\n            while(size--)\\n            {\\n                auto node=q.front(); //node.first=parent , node.second=curr_node\\n                q.pop();\\n                 \\n                total_sum+=node.second->val;  //calculating total sum at particular level\\n                mp[node.first]+=node.second->val;  //storing sum of node having same parent\\n                temp.push_back({node.first,node.second}); //this is used so that we can modify current tree\\n                \\n                if(node.second->left)\\n                    q.push({node.second,node.second->left});\\n                \\n                if(node.second->right)\\n                    q.push({node.second,node.second->right});\\n            }\\n            \\n            for(auto it:temp)\\n            {\\n                int val=total_sum-mp[it.first]; //formula\\n                it.second->val=val;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420009,
                "title": "using-bfs-to-precompute-lvl-sum",
                "content": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> l=new ArrayList<>();\\n        l.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            l.add(sum1);\\n            \\n        }\\n       \\n        q.clear();\\n        q.add(root);\\n        int lvl=-1;\\n        while(!q.isEmpty()){\\n            lvl++;\\n            int size=q.size();\\n            \\n            while(size-->0){\\n                int sum1=0;\\n                TreeNode curr=q.poll();\\n                if(lvl==0 || lvl==1){\\n                    curr.val=0;\\n                }\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n               \\n                if(lvl>=1){\\n                  //   System.out.print(lvl+\" \");\\n                     if(curr.left!=null){\\n                          \\n                        curr.left.val=l.get(lvl+1)-sum1;\\n                     }\\n                    if(curr.right!=null){\\n                        curr.right.val=l.get(lvl+1)-sum1;\\n                     }\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> l=new ArrayList<>();\\n        l.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            l.add(sum1);\\n            \\n        }\\n       \\n        q.clear();\\n        q.add(root);\\n        int lvl=-1;\\n        while(!q.isEmpty()){\\n            lvl++;\\n            int size=q.size();\\n            \\n            while(size-->0){\\n                int sum1=0;\\n                TreeNode curr=q.poll();\\n                if(lvl==0 || lvl==1){\\n                    curr.val=0;\\n                }\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n               \\n                if(lvl>=1){\\n                  //   System.out.print(lvl+\" \");\\n                     if(curr.left!=null){\\n                          \\n                        curr.left.val=l.get(lvl+1)-sum1;\\n                     }\\n                    if(curr.right!=null){\\n                        curr.right.val=l.get(lvl+1)-sum1;\\n                     }\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420230,
                "title": "explained-simple-and-clear-python-code",
                "content": "# Intuition\\nTo replace the value of each node in the tree with the sum of all its cousins\\' values, we first need to find the sum of each level of the tree. We can then use a DFS approach to traverse the tree and replace the value of each node with the sum of its cousins\\' values.\\n\\n\\n# Approach\\nWe will start by defining a function level_sum to calculate the sum of each level of the tree. This function will use BFS to traverse the tree level by level and store the sum of each level in a list.\\n\\nNext, we will create a copy of the original tree using the copy_tree function. This is because we don\\'t want to modify the original tree.\\n\\nFinally, we will use a DFS approach to traverse the tree and replace the value of each node with the sum of its cousins\\' values. We will pass the parent node and the level of the current node to the DFS function so that we can identify the cousins of the current node. We will also pass a copy of the copied tree to the DFS function, which we will modify as we traverse the tree.\\n\\nIn the DFS function, we will calculate the sum of the current level using the levels_sum list that we calculated earlier. We will then calculate the value of the current node based on the value of its parent and its cousins. We will then recursively call the DFS function on the left and right child of the current node.\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(N), where N is the number of nodes in the tree. This is because we need to traverse the entire tree once to calculate the sum of each level and once again to replace the value of each node.\\n- Space complexity:\\nThe space complexity of this algorithm is O(N), where N is the number of nodes in the tree. This is because we need to store the sum of each level in a list, which can take up to N/2 space in the worst case (when the tree is a complete binary tree). Additionally, the recursive call stack can also take up to N space in the worst case.\\n# Code\\n```\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def level_sum(root):\\n            if not root:\\n                return []\\n\\n            result = []\\n            queue = [root]\\n\\n            while queue:\\n                current_level_sum = 0\\n                level_size = len(queue)\\n\\n                for _ in range(level_size):\\n                    node = queue.pop(0)\\n                    current_level_sum += node.val\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n\\n                result.append(current_level_sum)\\n\\n            return result\\n\\n        levels_sum = level_sum(root)\\n        print(levels_sum)\\n\\n        def copy_tree(node):\\n            if node is None:\\n                return None\\n            new_node = TreeNode(node.val)\\n            new_node.left = copy_tree(node.left)\\n            new_node.right = copy_tree(node.right)\\n            return new_node\\n\\n        ans_tree = copy_tree(root)\\n\\n        def dfs(node, parent, level, ans):\\n            if node is None:\\n                return\\n            level_sum = levels_sum[level]\\n            if level < 2:\\n                ans.val = 0\\n            else:\\n                left_val = 0 if not parent.left else parent.left.val\\n                right_val = 0 if not parent.right else parent.right.val\\n                new_val = level_sum - left_val - right_val\\n                ans.val = new_val\\n            dfs(node.left, node, level+1, ans.left)\\n            dfs(node.right, node, level+1, ans.right)\\n\\n        dfs(root, None, 0, ans_tree)\\n        return ans_tree\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def level_sum(root):\\n            if not root:\\n                return []\\n\\n            result = []\\n            queue = [root]\\n\\n            while queue:\\n                current_level_sum = 0\\n                level_size = len(queue)\\n\\n                for _ in range(level_size):\\n                    node = queue.pop(0)\\n                    current_level_sum += node.val\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n\\n                result.append(current_level_sum)\\n\\n            return result\\n\\n        levels_sum = level_sum(root)\\n        print(levels_sum)\\n\\n        def copy_tree(node):\\n            if node is None:\\n                return None\\n            new_node = TreeNode(node.val)\\n            new_node.left = copy_tree(node.left)\\n            new_node.right = copy_tree(node.right)\\n            return new_node\\n\\n        ans_tree = copy_tree(root)\\n\\n        def dfs(node, parent, level, ans):\\n            if node is None:\\n                return\\n            level_sum = levels_sum[level]\\n            if level < 2:\\n                ans.val = 0\\n            else:\\n                left_val = 0 if not parent.left else parent.left.val\\n                right_val = 0 if not parent.right else parent.right.val\\n                new_val = level_sum - left_val - right_val\\n                ans.val = new_val\\n            dfs(node.left, node, level+1, ans.left)\\n            dfs(node.right, node, level+1, ans.right)\\n\\n        dfs(root, None, 0, ans_tree)\\n        return ans_tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419999,
                "title": "explanation-inplace-simple-bfs-queue-time-o-n",
                "content": "# Approach\\nTop 3 nodes have no cousins, they will be 0. Use queue for BFS level order traversal. For a queue $\\\\{a_1,a_2,a_3\\\\}$, calculate the total sum of their next level. Then again traverse on **same** nodes ($\\\\{a_1,a_2,a_3\\\\}$) and change their children\\'s values, and push children to queue for next level order traversal.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int total, currSum;\\n        TreeNode* curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val = 0;\\n        while (!q.empty()) {\\n            total = 0;\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                total += (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                q.push(curr);\\n            }\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                currSum = (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                if (curr->left) {\\n                    curr->left->val = total - currSum;\\n                    q.push(curr->left);\\n                }\\n                if (curr->right) {\\n                    curr->right->val = total - currSum;\\n                    q.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int total, currSum;\\n        TreeNode* curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val = 0;\\n        while (!q.empty()) {\\n            total = 0;\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                total += (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                q.push(curr);\\n            }\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                currSum = (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                if (curr->left) {\\n                    curr->left->val = total - currSum;\\n                    q.push(curr->left);\\n                }\\n                if (curr->right) {\\n                    curr->right->val = total - currSum;\\n                    q.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421153,
                "title": "c-bfs-map",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    #define ll long long\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<ll,ll>m;\\n        map<pair<ll,TreeNode*>,ll>p;\\n        queue<pair<TreeNode*,TreeNode*>>q,z;\\n        q.push({root,NULL});\\n        int d=0;\\n        while(q.size()){\\n            int k=q.size();\\n            for(int i=0;i<k;i++){\\n                auto x=q.front();\\n                TreeNode* par=x.second;\\n                TreeNode* act=x.first;\\n                q.pop();\\n                int t=0;\\n                if(par!=NULL)t=par->val;\\n                p[{d,par}]+=act->val;\\n                m[d]+=act->val;\\n                if(act->right!=NULL)q.push({act->right,act});\\n                 if(act->left!=NULL)q.push({act->left,act});\\n            }\\n            d++;\\n        }\\n        d=0;\\n\\n        z.push({root,NULL});\\n        while(z.size()){\\n        int k=z.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            auto x=z.front().first;\\n            auto par=z.front().second;\\n            z.pop();\\n            x->val=m[d]-p[{d,par}];\\n             if(x->right!=NULL)z.push({x->right,x});\\n                 if(x->left!=NULL)z.push({x->left,x});\\n        }\\n            d++;\\n        }\\n        return root;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/c9199d51-858a-4e57-84bc-fa74dc1282e2_1681590164.240952.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    #define ll long long\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<ll,ll>m;\\n        map<pair<ll,TreeNode*>,ll>p;\\n        queue<pair<TreeNode*,TreeNode*>>q,z;\\n        q.push({root,NULL});\\n        int d=0;\\n        while(q.size()){\\n            int k=q.size();\\n            for(int i=0;i<k;i++){\\n                auto x=q.front();\\n                TreeNode* par=x.second;\\n                TreeNode* act=x.first;\\n                q.pop();\\n                int t=0;\\n                if(par!=NULL)t=par->val;\\n                p[{d,par}]+=act->val;\\n                m[d]+=act->val;\\n                if(act->right!=NULL)q.push({act->right,act});\\n                 if(act->left!=NULL)q.push({act->left,act});\\n            }\\n            d++;\\n        }\\n        d=0;\\n\\n        z.push({root,NULL});\\n        while(z.size()){\\n        int k=z.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            auto x=z.front().first;\\n            auto par=z.front().second;\\n            z.pop();\\n            x->val=m[d]-p[{d,par}];\\n             if(x->right!=NULL)z.push({x->right,x});\\n                 if(x->left!=NULL)z.push({x->left,x});\\n        }\\n            d++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422435,
                "title": "simple-approach-by-using-bfs-and-taking-sum-of-child-explanation-with-visualization",
                "content": "#### **Cousins in Binary Tree II**\\n\\n**Topic:** Binary Tree, DFS/BFS\\n**Hints1:** Find sum of values level wise\\n**Hints2:** Store the child sum of each node\\n\\nEssentially, this question can be divided into two distinct parts.\\n\\n##### **First Part:** Construct Required Things (level_wise_sum+child_sum)\\nIn this part, we need to store the level wise sum as well as child sum of each node. Here we can maintain the Map for storing the data that we need in future. \\n\\nThis code performs a BFS traversal of a binary tree and calculates the level wise sum of node values and the sum of child node values for each node. The code uses a queue to store nodes in the order they need to be processed, and a map to store the sums. During the traversal, for each node, the code adds the node value to the level wise sum and calculates the sum of child node values. The sum of child node values is stored in a map with the node pointer as the key.\\n\\n##### **Example:** \\n<img src=\"https://assets.leetcode.com/users/images/ea37b32e-7907-449d-abdc-c1bdb8bf8c66_1681625217.5710294.jpeg\" width=\"30%\"> <img src=\"https://assets.leetcode.com/users/images/a95d08c7-32a6-440d-92ee-e23074b9cccf_1681625269.7894928.jpeg\" width=\"30%\"> <img src=\"https://assets.leetcode.com/users/images/9093dfe5-4d53-4871-b714-e5b2554ab102_1681625306.391535.jpeg\" width=\"30%\">\\n\\n\\n##### **Second Part:** Final Answer prepare, modify the given Tree\\nTo determine if there are cousins of a given node in the binary tree, we can traverse the tree using either BFS or DFS. If the level_wise_sum value for a level is greater than the child_sum value stored in the parent node, then there must be at least one cousin node present in that level. In this case, we can remove the child_sum value from the level_wise_sum to calculate the sum of the cousin nodes. If the level_wise_sum value for a level is not greater than the child_sum value, then there are no cousin nodes in that level, and we store 0 as the sum of cousin nodes.\\n\\nThis code uses a queue to perform a BFS traversal of a binary tree and determine the sum of cousin nodes for each node. The pen queue stores pairs of nodes along with their level for processing. For each node, the code calculates whether the level wise sum of the node is greater than the sum of its child nodes. If so, the code calculates the difference and assigns it to the current node value. If not, the code assigns 0 to the current node value. Finally, the code sets the value of the root node to 0 and returns the root.\\n\\n#### **Code:**\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //First Part (Construct Required things)\\n        \\n        //store the each level sum\\n        map<int,long long> level_wise_sum;\\n        //store the parent-> child sum\\n        map<TreeNode*,long long> child_sum;\\n        //create a queue for BFS\\n        queue<pair<TreeNode*,int>> pending;\\n        pending.push({root,0});\\n        \\n        while(pending.size()!=0){\\n            TreeNode* temp = pending.front().first; \\n            int lvl = pending.front().second;\\n            pending.pop();\\n            \\n            //Store the level wise sum\\n            level_wise_sum[lvl]+=temp->val;\\n            //Take a variable sum that stores the child sum\\n            long long sum = 0;\\n            if(temp->left!=NULL){\\n                sum+=temp->left->val;\\n                pending.push({temp->left,lvl+1});\\n            }\\n            if(temp->right!=NULL){\\n                sum+=temp->right->val;\\n                pending.push({temp->right,lvl+1});\\n            }\\n            //store the each node-> child sum\\n            child_sum[temp]=sum;\\n        }\\n        \\n        \\n        \\n        // Second Part (Final ans prepare)\\n        \\n        //Create a queue for BFS <parent-child> and store level\\n        queue<pair<pair<TreeNode*,TreeNode*>,int>> pen;\\n        pen.push({{root,root},0});\\n        while(pen.size()!=0){\\n            TreeNode* parent = pen.front().first.first; \\n            TreeNode* curr = pen.front().first.second;\\n            int lvl = pen.front().second;\\n            pen.pop();\\n            \\n            //Calculate greater or not, if yes then store the substraction \\n            if(level_wise_sum[lvl]>=child_sum[parent]){\\n                curr->val = level_wise_sum[lvl]-child_sum[parent];\\n            }else{\\n                curr->val = 0;\\n            }\\n            \\n            if(curr->left!=NULL) pen.push({{curr,curr->left},lvl+1});\\n            if(curr->right!=NULL) pen.push({{curr,curr->right},lvl+1});\\n            \\n            \\n        }\\n        \\n        // Parent root will be always 0\\n        root->val=0;\\n        return root;\\n        \\n        \\n    }\\n};\\n```\\n\\n<br>\\n\\n##### **If you like this explanation, feel free to upvote this discussion ^^**",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //First Part (Construct Required things)\\n        \\n        //store the each level sum\\n        map<int,long long> level_wise_sum;\\n        //store the parent-> child sum\\n        map<TreeNode*,long long> child_sum;\\n        //create a queue for BFS\\n        queue<pair<TreeNode*,int>> pending;\\n        pending.push({root,0});\\n        \\n        while(pending.size()!=0){\\n            TreeNode* temp = pending.front().first; \\n            int lvl = pending.front().second;\\n            pending.pop();\\n            \\n            //Store the level wise sum\\n            level_wise_sum[lvl]+=temp->val;\\n            //Take a variable sum that stores the child sum\\n            long long sum = 0;\\n            if(temp->left!=NULL){\\n                sum+=temp->left->val;\\n                pending.push({temp->left,lvl+1});\\n            }\\n            if(temp->right!=NULL){\\n                sum+=temp->right->val;\\n                pending.push({temp->right,lvl+1});\\n            }\\n            //store the each node-> child sum\\n            child_sum[temp]=sum;\\n        }\\n        \\n        \\n        \\n        // Second Part (Final ans prepare)\\n        \\n        //Create a queue for BFS <parent-child> and store level\\n        queue<pair<pair<TreeNode*,TreeNode*>,int>> pen;\\n        pen.push({{root,root},0});\\n        while(pen.size()!=0){\\n            TreeNode* parent = pen.front().first.first; \\n            TreeNode* curr = pen.front().first.second;\\n            int lvl = pen.front().second;\\n            pen.pop();\\n            \\n            //Calculate greater or not, if yes then store the substraction \\n            if(level_wise_sum[lvl]>=child_sum[parent]){\\n                curr->val = level_wise_sum[lvl]-child_sum[parent];\\n            }else{\\n                curr->val = 0;\\n            }\\n            \\n            if(curr->left!=NULL) pen.push({{curr,curr->left},lvl+1});\\n            if(curr->right!=NULL) pen.push({{curr,curr->right},lvl+1});\\n            \\n            \\n        }\\n        \\n        // Parent root will be always 0\\n        root->val=0;\\n        return root;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420410,
                "title": "simply-the-bfs-way",
                "content": "**Time** O(n)\\n**Space** O(n+n)\\n\\n**Explanation**\\nEach node we need:\\ntotal childsum of the level\\nparent\\'s child sum\\nso putting in map with parent and childsum of parent\\nnode.val = (totalchildsum of prevlevel - parent\\'s child sum)\\n\\nPlease do dry run on test case\\n```\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        public Pair(TreeNode n, TreeNode p){\\n            node = n;\\n            parent = p;\\n        }\\n    }\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        // same depth diff parent\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(root, null));\\n        \\n        int curLevelChildSum = 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();       // storing parent : childsum   \\n        \\n        while(!q.isEmpty()){\\n           \\n            \\n            int lastLevelChildSum = curLevelChildSum;    // prevsum = cursum\\n            curLevelChildSum = 0;   // reset cursum\\n            \\n            int size = q.size();\\n            \\n            while(size-- > 0){\\n                Pair front = q.poll();\\n                \\n                TreeNode node = front.node;\\n                TreeNode par = front.parent;\\n\\n                int childsum = 0; \\n                // left\\n                if(node.left != null){\\n                    q.add(new Pair(node.left, node));\\n                    childsum += node.left.val;\\n                }\\n                // right\\n                if(node.right != null){\\n                    q.add(new Pair(node.right, node));\\n                    childsum += node.right.val;\\n                }\\n                \\n                // put value in map\\n                map.put(node, childsum);\\n                \\n                curLevelChildSum += childsum;\\n                \\n                node.val = lastLevelChildSum - map.getOrDefault(par, 0);  // get(par) gives me childsum of this node\\'s parent\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n}\\n```\\n\\nUpvote Kardo Yr !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        public Pair(TreeNode n, TreeNode p){\\n            node = n;\\n            parent = p;\\n        }\\n    }\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        // same depth diff parent\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(root, null));\\n        \\n        int curLevelChildSum = 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();       // storing parent : childsum   \\n        \\n        while(!q.isEmpty()){\\n           \\n            \\n            int lastLevelChildSum = curLevelChildSum;    // prevsum = cursum\\n            curLevelChildSum = 0;   // reset cursum\\n            \\n            int size = q.size();\\n            \\n            while(size-- > 0){\\n                Pair front = q.poll();\\n                \\n                TreeNode node = front.node;\\n                TreeNode par = front.parent;\\n\\n                int childsum = 0; \\n                // left\\n                if(node.left != null){\\n                    q.add(new Pair(node.left, node));\\n                    childsum += node.left.val;\\n                }\\n                // right\\n                if(node.right != null){\\n                    q.add(new Pair(node.right, node));\\n                    childsum += node.right.val;\\n                }\\n                \\n                // put value in map\\n                map.put(node, childsum);\\n                \\n                curLevelChildSum += childsum;\\n                \\n                node.val = lastLevelChildSum - map.getOrDefault(par, 0);  // get(par) gives me childsum of this node\\'s parent\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427535,
                "title": "simple-solution-bfs-o-n-time-o-n-space-comment-explained-cousins-in-binary-tree-ii",
                "content": "# Intuition\\n1. Initialize a queue and enqueue the root node with level -1.\\n2. Set the values of the root and its children to 0.\\n3. While the queue is not empty:\\na. Dequeue a node and its level from the front of the queue.\\nb. If the level is greater than 0 (i.e., the node is not at the root level):\\ni. Update the node value to the difference between the sum at the current level and the sum of its children.\\nc. Enqueue the node\\'s children along with their sum.\\nd. Update the sum at the current level.\\nReturn the root node.\\n\\n# Approach\\nWe can use a level-order traversal (BFS) to traverse the binary tree and update the node values.\\n\\nFor each node that we visit, we need to compute the sum of the values of its cousins. We can keep track of the sum of the values of the nodes at the current level by maintaining a sum variable. For each node at the current level, we add the values of its children to the sum and enqueue the children along with their sum. When we encounter a node at the next level, we update its value to the difference between the sum and the sum of its children.\\n\\nTo keep track of the level of each node, we can enqueue a pair containing the node and its level instead of just the node.\\n\\nWe also need to initialize the values of the root node and its children to 0.\\n\\n# Complexity\\n- **Time complexity:** We traverse each node of the tree once, so the time complexity is O(n), where n is the number of nodes in the tree.\\n\\n\\n- **Space complexity:**  Since we are using a queue data structure so space complexity is: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n    \\n        queue<pair<TreeNode*, int>> q; // make a queue which will store the node and will also store node\\'s children sum;\\n        int temp,k=0;\\n        q.push({root, -1}); //Since first node so will push -1 for sum\\n        root->val=0;\\n\\n        // Considering tree starts form level 1\\n        // for 2nd level since only 2 roots and have same parent so we will always push 0 for both the childs\\n        if(root->left)\\n            root->left->val=0;\\n        if(root->right)\\n            root->right->val=0;\\n\\n        while(!q.empty())\\n        {\\n            int s=q.size(); //current queue size\\n            int sum=0;\\n            k++;\\n\\n            //iterating through the current size of queue\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode* t=q.front().first;\\n                int psum=q.front().second;\\n                q.pop();\\n                int cs=0;\\n\\n                if(k>1)  // since we have already pushed 0,0 for 2nd level so we are ignoring for 2nd level\\n                    t->val=temp-psum;\\n                if(t->left)\\n                    cs=cs+t->left->val;\\n                if(t->right)\\n                    cs=cs+t->right->val;\\n\\n                sum+=cs;       // sum is carrying the total sum a level node\\'s value\\n                if(t->left)\\n                    q.push({t->left, cs});\\n                if(t->right)\\n                    q.push({t->right, cs});\\n            }\\n            temp=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n    \\n        queue<pair<TreeNode*, int>> q; // make a queue which will store the node and will also store node\\'s children sum;\\n        int temp,k=0;\\n        q.push({root, -1}); //Since first node so will push -1 for sum\\n        root->val=0;\\n\\n        // Considering tree starts form level 1\\n        // for 2nd level since only 2 roots and have same parent so we will always push 0 for both the childs\\n        if(root->left)\\n            root->left->val=0;\\n        if(root->right)\\n            root->right->val=0;\\n\\n        while(!q.empty())\\n        {\\n            int s=q.size(); //current queue size\\n            int sum=0;\\n            k++;\\n\\n            //iterating through the current size of queue\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode* t=q.front().first;\\n                int psum=q.front().second;\\n                q.pop();\\n                int cs=0;\\n\\n                if(k>1)  // since we have already pushed 0,0 for 2nd level so we are ignoring for 2nd level\\n                    t->val=temp-psum;\\n                if(t->left)\\n                    cs=cs+t->left->val;\\n                if(t->right)\\n                    cs=cs+t->right->val;\\n\\n                sum+=cs;       // sum is carrying the total sum a level node\\'s value\\n                if(t->left)\\n                    q.push({t->left, cs});\\n                if(t->right)\\n                    q.push({t->right, cs});\\n            }\\n            temp=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420260,
                "title": "c-single-bfs-no-extra-space",
                "content": "Time complexity- O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n         q.push(root);\\n        vector<int> v;\\n        int ans=root->val;\\n        while(!q.empty()){\\n            int sz=q.size(); int sum=0;\\n            for(int i=0;i<sz;i++){\\n                auto p=q.front(); q.pop();\\n                p->val=ans-p->val;\\n                if(p->left){  q.push(p->left); sum+=p->left->val; }\\n                if(p->right) { q.push(p->right); sum+=p->right->val; }\\n                if(p->left&&p->right){\\n                    int x=p->right->val+p->left->val;\\n                    p->left->val=x;\\n                    p->right->val=x;\\n                }\\n            }\\n            ans=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n         q.push(root);\\n        vector<int> v;\\n        int ans=root->val;\\n        while(!q.empty()){\\n            int sz=q.size(); int sum=0;\\n            for(int i=0;i<sz;i++){\\n                auto p=q.front(); q.pop();\\n                p->val=ans-p->val;\\n                if(p->left){  q.push(p->left); sum+=p->left->val; }\\n                if(p->right) { q.push(p->right); sum+=p->right->val; }\\n                if(p->left&&p->right){\\n                    int x=p->right->val+p->left->val;\\n                    p->left->val=x;\\n                    p->right->val=x;\\n                }\\n            }\\n            ans=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420221,
                "title": "level-order-traversal-and-then-dfs-hashmap",
                "content": "# Intuition\\nConsider a node, $$node$$. Another node, $$cousin$$ is that node which is on the same level/depth as $$node$$ but has a different (immediate) parent than $$node$$ does.\\n \\nWe need to find the sum of values of all the cousins for a given node, a simpler problem would be to first calculate the sum of all nodes at a given level(**Level Order Traversal**), and then subtract something to this value. That value is nothing but the sum of the value of current Node, and it\\'s sibling. \\nConsider the tree: \\n![image.png](https://assets.leetcode.com/users/images/e232ce90-dd2f-4bbe-8c8b-d8af60a63676_1681574863.7901134.png) \\n\\nFor $$1$$, the value is:\\n```\\nRequired value for node with value 1:\\n Sum of the values of every node at that level - (1+10)\\n-\\n```\\nOr simply, take the node with value **4**, keep track of the sum of it\\'s children, $$(1+10)$$, and use that to calculate their modified value. This can be done using a dfs\\n\\n# Approach\\nWe create two Hash Tables, one for:\\n# Level Sum = Sum of all the node values at a given level\\n# Parent Sum= For a given node, the sum of values of all its children(only **root.left and root.right**, or upto 1 level lower. )\\n\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        ArrayDeque<TreeNode> q= new ArrayDeque<>();\\n        q.add(root);\\n        HashMap<Integer,Integer> level = new HashMap<>(); \\n        int l=0; //variable for level.\\n        \\n        while(!q.isEmpty()){\\n            int tsize=q.size();\\n            l++;\\n            int levelsum=0;\\n            while(tsize-- >0 ){\\n                TreeNode node = q.removeFirst(); \\n                //maintaining level sum:\\n                levelsum+=node.val;\\n\\n                //Computing sum of children:\\n                int lsum=node.left==null?0:node.left.val;\\n                int rsum=node.right==null?0:node.right.val;\\n                map.put(node,lsum+rsum);\\n\\n\\n                if(node.left!=null) q.addLast(node.left);\\n                if(node.right!=null) q.addLast(node.right);\\n            }\\n            level.put(l,levelsum); //set the sum value for current level\\n            \\n        }\\n        //update node values in a pre-order traversal\\n        //keeping track of the parent for every node.\\n        f(root,null,1,map,level);\\n        root.val=0;\\n        return root;\\n        \\n    }\\n    public void f(TreeNode root,TreeNode parent,int lev, HashMap<TreeNode,Integer> map,HashMap<Integer,Integer> level ){\\n        if(root==null) return;\\n        int psum= map.getOrDefault(parent,0);\\n        int lsum=level.get(lev);\\n        root.val=lsum-psum;\\n        f(root.left,root,lev+1,map,level);\\n        f(root.right,root,lev+1,map,level);\\n\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nRequired value for node with value 1:\\n Sum of the values of every node at that level - (1+10)\\n-\\n```\n```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        ArrayDeque<TreeNode> q= new ArrayDeque<>();\\n        q.add(root);\\n        HashMap<Integer,Integer> level = new HashMap<>(); \\n        int l=0; //variable for level.\\n        \\n        while(!q.isEmpty()){\\n            int tsize=q.size();\\n            l++;\\n            int levelsum=0;\\n            while(tsize-- >0 ){\\n                TreeNode node = q.removeFirst(); \\n                //maintaining level sum:\\n                levelsum+=node.val;\\n\\n                //Computing sum of children:\\n                int lsum=node.left==null?0:node.left.val;\\n                int rsum=node.right==null?0:node.right.val;\\n                map.put(node,lsum+rsum);\\n\\n\\n                if(node.left!=null) q.addLast(node.left);\\n                if(node.right!=null) q.addLast(node.right);\\n            }\\n            level.put(l,levelsum); //set the sum value for current level\\n            \\n        }\\n        //update node values in a pre-order traversal\\n        //keeping track of the parent for every node.\\n        f(root,null,1,map,level);\\n        root.val=0;\\n        return root;\\n        \\n    }\\n    public void f(TreeNode root,TreeNode parent,int lev, HashMap<TreeNode,Integer> map,HashMap<Integer,Integer> level ){\\n        if(root==null) return;\\n        int psum= map.getOrDefault(parent,0);\\n        int lsum=level.get(lev);\\n        root.val=lsum-psum;\\n        f(root.left,root,lev+1,map,level);\\n        f(root.right,root,lev+1,map,level);\\n\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420085,
                "title": "simple-level-order-traversal-dfs",
                "content": "# Approach\\n- Used two hash table to store sum of each level and child sum to it\\'s parent respectively.\\n- then update current node value with the entire sum of that level minus parentSum of current node.\\n\\n# Complexity\\nWhere N is number of Nodes\\n- Time O(N)\\n- Space O(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def replaceValueInTree(self, root):\\n        def dfs(root, parent, lvl):\\n            if not root: return\\n            parentSum[parent] += root.val\\n            levelSum[lvl] += root.val\\n            dfs(root.left, root, lvl + 1)\\n            dfs(root.right, root, lvl + 1)\\n\\n        levelSum = defaultdict(int)\\n        parentSum = defaultdict(int)\\n        dfs(root, None, 0)\\n        queue = [[root, None, 0]]\\n        while queue:\\n            for _ in range(len(queue)):\\n                node, parent, lvl = queue.pop(0)\\n                sum_ = levelSum[lvl] - parentSum[parent]\\n                node.val = sum_\\n                if node.left: queue.append([node.left, node, lvl + 1])\\n                if node.right: queue.append([node.right, node, lvl + 1])\\n        return root\\n```\\nUpVote, if you like it **:)**",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def replaceValueInTree(self, root):\\n        def dfs(root, parent, lvl):\\n            if not root: return\\n            parentSum[parent] += root.val\\n            levelSum[lvl] += root.val\\n            dfs(root.left, root, lvl + 1)\\n            dfs(root.right, root, lvl + 1)\\n\\n        levelSum = defaultdict(int)\\n        parentSum = defaultdict(int)\\n        dfs(root, None, 0)\\n        queue = [[root, None, 0]]\\n        while queue:\\n            for _ in range(len(queue)):\\n                node, parent, lvl = queue.pop(0)\\n                sum_ = levelSum[lvl] - parentSum[parent]\\n                node.val = sum_\\n                if node.left: queue.append([node.left, node, lvl + 1])\\n                if node.right: queue.append([node.right, node, lvl + 1])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444565,
                "title": "level-order-c-easy-explanation",
                "content": "# Approach\\n   1. Find the sum at each level and store it in the map with depth as key and sum as pair\\n   2. Then to  a current Node the cousin sum for its each child Nodes will be (level sum of its children) - (sum of it\\'s childrent)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n         // Initialize a map to store the sum of nodes at each level\\n         map<int, int> mp;\\n       \\n         queue<TreeNode*>q;\\n       \\n         q.push(root);\\n       \\n         int depth = 0;\\n      \\n         while(!q.empty()){\\n             int l = q.size();\\n             int ans = 0;\\n      \\n             for(int i = 0;i<l;i++){\\n                 // Get the current node from the front of the queue\\n                 TreeNode* curr = q.front();\\n                 q.pop();\\n                 \\n                 ans+= curr->val;\\n                \\n                 if(curr->left) q.push(curr->left);\\n                 if(curr->right) q.push(curr->right);\\n             }\\n           \\n             mp[depth++] = ans;\\n         }\\n\\n         // Reset the depth to 0 and push the root node onto the queue again\\n         depth = 0;\\n         root->val = 0;\\n         q.push(root);\\n\\n         // Traverse the tree level by level again\\n         while(!q.empty()){\\n             int l = q.size();\\n             // Iterate through each node at the current level\\n             for(int i = 0;i<l;i++){\\n                // Get the current node from the front of the queue\\n                TreeNode* currNode = q.front();\\n                q.pop();\\n                // Get the sum of nodes at the next level\\n                int SumOfNextLevel = mp[depth+1];\\n                // Subtract the sum of the current node\\'s children from the sum of nodes at the next level\\n                if(currNode->left) SumOfNextLevel-= currNode->left->val;\\n                if(currNode->right) SumOfNextLevel-= currNode->right->val;\\n                // Set the current node\\'s value to the sum of its cousins\\n               \\n                if(currNode->left) {\\n                currNode->left->val = SumOfNextLevel;\\n                q.push(currNode->left);\\n                }\\n\\n                if(currNode->right) {\\n                currNode->right->val = SumOfNextLevel;\\n                q.push(currNode->right);\\n               }\\n             }\\n            \\n             depth++;\\n         }\\n         \\n         \\n         return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n         // Initialize a map to store the sum of nodes at each level\\n         map<int, int> mp;\\n       \\n         queue<TreeNode*>q;\\n       \\n         q.push(root);\\n       \\n         int depth = 0;\\n      \\n         while(!q.empty()){\\n             int l = q.size();\\n             int ans = 0;\\n      \\n             for(int i = 0;i<l;i++){\\n                 // Get the current node from the front of the queue\\n                 TreeNode* curr = q.front();\\n                 q.pop();\\n                 \\n                 ans+= curr->val;\\n                \\n                 if(curr->left) q.push(curr->left);\\n                 if(curr->right) q.push(curr->right);\\n             }\\n           \\n             mp[depth++] = ans;\\n         }\\n\\n         // Reset the depth to 0 and push the root node onto the queue again\\n         depth = 0;\\n         root->val = 0;\\n         q.push(root);\\n\\n         // Traverse the tree level by level again\\n         while(!q.empty()){\\n             int l = q.size();\\n             // Iterate through each node at the current level\\n             for(int i = 0;i<l;i++){\\n                // Get the current node from the front of the queue\\n                TreeNode* currNode = q.front();\\n                q.pop();\\n                // Get the sum of nodes at the next level\\n                int SumOfNextLevel = mp[depth+1];\\n                // Subtract the sum of the current node\\'s children from the sum of nodes at the next level\\n                if(currNode->left) SumOfNextLevel-= currNode->left->val;\\n                if(currNode->right) SumOfNextLevel-= currNode->right->val;\\n                // Set the current node\\'s value to the sum of its cousins\\n               \\n                if(currNode->left) {\\n                currNode->left->val = SumOfNextLevel;\\n                q.push(currNode->left);\\n                }\\n\\n                if(currNode->right) {\\n                currNode->right->val = SumOfNextLevel;\\n                q.push(currNode->right);\\n               }\\n             }\\n            \\n             depth++;\\n         }\\n         \\n         \\n         return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423474,
                "title": "bfs-and-dfs-java-solution",
                "content": "# Intuition\\nBFS , DFS\\n\\n# Approach\\n- First of All , traverse to every level and store the sum of every element of that level in a list.\\n- To store the level sum , we have created a method levelsum.\\n- Now traverse to every node again and if it has both child then put them in a map first child node as a key and its brother\\'s val as a value and vice-versa.\\n- For this, process there is a method called getRealBrothers.\\n- Now , do simple DFS to modify the values of every node.\\n- For this, just traverse to every node and if there exists it\\'s real brother then just substract it\\'s value and also it\\'s real brother\\'s value from the current level sum and modify the value of that node to the value you have got in the end after the substraction.\\n- Now you have the required modified tree.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void levelsum(TreeNode root,List<Integer>list){\\n        if(root==null) return;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        while(!q.isEmpty()){\\n            int sum = 0;\\n            while(q.peek()!=null){\\n               sum += q.peek().val;\\n               if(q.peek().left!=null) q.add(q.peek().left);\\n               if(q.peek().right!=null) q.add(q.peek().right);\\n               q.poll();\\n            }\\n            q.poll();\\n            list.add(sum);\\n            if(q.size()>0)  q.add(null);\\n        }\\n    }\\n    public void getRealBrothers(TreeNode root,HashMap<TreeNode,Integer> map){\\n        if(root==null) return;\\n        if(root.left != null && root.right != null){\\n            map.putIfAbsent(root.left,root.right.val);\\n            map.putIfAbsent(root.right,root.left.val);\\n        }\\n        getRealBrothers(root.left,map);\\n        getRealBrothers(root.right,map);\\n    }\\n    public void dfs(TreeNode root,HashMap<TreeNode,Integer> map,List<Integer>list,int level){\\n        if(root==null) return;\\n        int sum = map.containsKey(root)?map.get(root):0;\\n        root.val = list.get(level)-sum-root.val;\\n        dfs(root.left,map,list,level+1);\\n        dfs(root.right,map,list,level+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        levelsum(root,list);\\n        getRealBrothers(root,map);\\n        dfs(root,map,list,0);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void levelsum(TreeNode root,List<Integer>list){\\n        if(root==null) return;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        while(!q.isEmpty()){\\n            int sum = 0;\\n            while(q.peek()!=null){\\n               sum += q.peek().val;\\n               if(q.peek().left!=null) q.add(q.peek().left);\\n               if(q.peek().right!=null) q.add(q.peek().right);\\n               q.poll();\\n            }\\n            q.poll();\\n            list.add(sum);\\n            if(q.size()>0)  q.add(null);\\n        }\\n    }\\n    public void getRealBrothers(TreeNode root,HashMap<TreeNode,Integer> map){\\n        if(root==null) return;\\n        if(root.left != null && root.right != null){\\n            map.putIfAbsent(root.left,root.right.val);\\n            map.putIfAbsent(root.right,root.left.val);\\n        }\\n        getRealBrothers(root.left,map);\\n        getRealBrothers(root.right,map);\\n    }\\n    public void dfs(TreeNode root,HashMap<TreeNode,Integer> map,List<Integer>list,int level){\\n        if(root==null) return;\\n        int sum = map.containsKey(root)?map.get(root):0;\\n        root.val = list.get(level)-sum-root.val;\\n        dfs(root.left,map,list,level+1);\\n        dfs(root.right,map,list,level+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        levelsum(root,list);\\n        getRealBrothers(root,map);\\n        dfs(root,map,list,0);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422515,
                "title": "bsf-traversal-java-using-map-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        Map<TreeNode, List<Integer>> map = new HashMap<>();\\n        root.val = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int sum = 0;\\n            map = new HashMap<>();\\n            for(int i = 0; i < size; i++) {\\n                TreeNode cur = q.poll();\\n                map.put(cur, new ArrayList<>());\\n                if(cur.left != null) {\\n                    sum += cur.left.val;\\n                    q.add(cur.left);\\n                    map.get(cur).add(cur.left.val);\\n                }\\n                if(cur.right != null) {\\n                    sum += cur.right.val;\\n                    q.add(cur.right);\\n                    map.get(cur).add(cur.right.val);\\n                }\\n            }\\n            for(Map.Entry<TreeNode,List<Integer>> entry : map.entrySet()) {\\n                if(entry.getValue().size() == 2) {\\n                    int num = entry.getValue().get(0)+entry.getValue().get(1);\\n                    entry.getKey().left.val = sum - num;\\n                    entry.getKey().right.val = sum - num;\\n                } else if(entry.getValue().size() == 1) {\\n                    if(entry.getKey().left != null) entry.getKey().left.val = sum - entry.getValue().get(0);\\n                    else if(entry.getKey().right != null) entry.getKey().right.val = sum - entry.getValue().get(0);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        Map<TreeNode, List<Integer>> map = new HashMap<>();\\n        root.val = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int sum = 0;\\n            map = new HashMap<>();\\n            for(int i = 0; i < size; i++) {\\n                TreeNode cur = q.poll();\\n                map.put(cur, new ArrayList<>());\\n                if(cur.left != null) {\\n                    sum += cur.left.val;\\n                    q.add(cur.left);\\n                    map.get(cur).add(cur.left.val);\\n                }\\n                if(cur.right != null) {\\n                    sum += cur.right.val;\\n                    q.add(cur.right);\\n                    map.get(cur).add(cur.right.val);\\n                }\\n            }\\n            for(Map.Entry<TreeNode,List<Integer>> entry : map.entrySet()) {\\n                if(entry.getValue().size() == 2) {\\n                    int num = entry.getValue().get(0)+entry.getValue().get(1);\\n                    entry.getKey().left.val = sum - num;\\n                    entry.getKey().right.val = sum - num;\\n                } else if(entry.getValue().size() == 1) {\\n                    if(entry.getKey().left != null) entry.getKey().left.val = sum - entry.getValue().get(0);\\n                    else if(entry.getKey().right != null) entry.getKey().right.val = sum - entry.getValue().get(0);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420207,
                "title": "python3-simple-bfs",
                "content": "lets consider some node -> node X , \\nif node X has sibling then new value = (sum of level) - nodeX.val - (sibling of nodeX) , else new value =  (sum of level ) - nodeX.val . when storing child node in queue, check if it has sibling and if yes then store map[childnode] = (sibling node value)in hmap.\\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        dq = deque([root])\\n        hmap = {}\\n        total = 0\\n        while dq:\\n            size = len(dq)\\n            temp = 0\\n            for i in range(size):\\n                curr = dq.popleft()\\n                curr.val = max(0,total - curr.val - (hmap[curr] if curr in hmap else 0))\\n                if curr.left and curr.right:   \\n                    hmap[curr.left] = curr.right.val\\n                    hmap[curr.right] = curr.left.val\\n                    temp += curr.left.val + curr.right.val\\n                    dq.append(curr.left)\\n                    dq.append(curr.right)\\n                elif curr.right:\\n                    temp += curr.right.val\\n                    dq.append(curr.right)\\n                elif curr.left:\\n                    temp += curr.left.val\\n                    dq.append(curr.left)\\n            total = temp\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        dq = deque([root])\\n        hmap = {}\\n        total = 0\\n        while dq:\\n            size = len(dq)\\n            temp = 0\\n            for i in range(size):\\n                curr = dq.popleft()\\n                curr.val = max(0,total - curr.val - (hmap[curr] if curr in hmap else 0))\\n                if curr.left and curr.right:   \\n                    hmap[curr.left] = curr.right.val\\n                    hmap[curr.right] = curr.left.val\\n                    temp += curr.left.val + curr.right.val\\n                    dq.append(curr.left)\\n                    dq.append(curr.right)\\n                elif curr.right:\\n                    temp += curr.right.val\\n                    dq.append(curr.right)\\n                elif curr.left:\\n                    temp += curr.left.val\\n                    dq.append(curr.left)\\n            total = temp\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420196,
                "title": "c-level-order-traversal-easy-to-understand-code",
                "content": "````\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420195,
                "title": "simple-solution-maps-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, long long int> m; // To store the sum of the children \\n    vector<vector<TreeNode*>> depth; // to store the nodes at the given depth\\n    \\n    void dfs(TreeNode* root, int d){\\n        if(!root) return; \\n        if(depth.size()<d){\\n            depth.push_back({});\\n        }\\n        depth[d-1].push_back(root);\\n        long long int x = 0; \\n        \\n        if(root->right){\\n            x+=root->right->val; \\n            dfs(root->right, d+1); \\n        }\\n        if(root->left){ \\n            x+=root->left->val; \\n            dfs(root->left, d+1);\\n        } \\n        m[root] = x; \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        dfs(root, 1); \\n        \\n        for(int i = depth.size()-1; i>=0; i--){\\n            long long int sum = 0; // sum is used to store the sum of all the nodes that are at depth same as that of child of j  \\n            for(auto &j:depth[i]){\\n                j->val =0; \\n                if(m[j]) sum+=m[j]; \\n            }\\n            // If there are children, then we can change their values. \\n            if(sum){\\n                for(auto &j:depth[i]){\\n                    // (sum-m[j]) gives us the sum value of the other nodes that are at the same depth as that of the children of j \\n                    \\n                    if(j->left){\\n                        j->left->val = sum - m[j]; \\n                    }\\n                    if(j->right){\\n                        j->right->val = sum - m[j]; \\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, long long int> m; // To store the sum of the children \\n    vector<vector<TreeNode*>> depth; // to store the nodes at the given depth\\n    \\n    void dfs(TreeNode* root, int d){\\n        if(!root) return; \\n        if(depth.size()<d){\\n            depth.push_back({});\\n        }\\n        depth[d-1].push_back(root);\\n        long long int x = 0; \\n        \\n        if(root->right){\\n            x+=root->right->val; \\n            dfs(root->right, d+1); \\n        }\\n        if(root->left){ \\n            x+=root->left->val; \\n            dfs(root->left, d+1);\\n        } \\n        m[root] = x; \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        dfs(root, 1); \\n        \\n        for(int i = depth.size()-1; i>=0; i--){\\n            long long int sum = 0; // sum is used to store the sum of all the nodes that are at depth same as that of child of j  \\n            for(auto &j:depth[i]){\\n                j->val =0; \\n                if(m[j]) sum+=m[j]; \\n            }\\n            // If there are children, then we can change their values. \\n            if(sum){\\n                for(auto &j:depth[i]){\\n                    // (sum-m[j]) gives us the sum value of the other nodes that are at the same depth as that of the children of j \\n                    \\n                    if(j->left){\\n                        j->left->val = sum - m[j]; \\n                    }\\n                    if(j->right){\\n                        j->right->val = sum - m[j]; \\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420168,
                "title": "2-dfs-solution",
                "content": "# Intuition\\nUse DFS\\n\\n# Approach\\nDuring first DFS calculate sum of nodes on each level and store initial node value for every node.\\nDuring second DFS for every node:\\n1. Get node parent\\n2. Get both children of the current node parent.\\n3. Get total sum for node level\\n4. Extract sum of parent both child from total level sum.\\n5. Set this value as new value for the node.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\n\\nlet levelSums\\nlet nodeValues\\nlet parents\\nvar replaceValueInTree = function(root) {\\n    levelSums = new Map()\\n    nodeValues = new Map()\\n    parents = new Map()\\n    \\n    dfs1(root, 0, null)\\n    console.log(levelSums)\\n    dfs2(root, 0, null)\\n    \\n    return root\\n    \\n};\\n\\nfunction dfs1(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    nodeValues.set(node, node.val)\\n    \\n    if(!levelSums.has(level)){\\n        levelSums.set(level, 0)\\n    }\\n    \\n    levelSums.set(level, node.val + levelSums.get(level))\\n    dfs1(node.left, level + 1, node)\\n    \\n    dfs1(node.right, level + 1, node)\\n    \\n    \\n}\\n\\nfunction dfs2(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    if(parent == null){\\n        node.val = 0;\\n       \\n    } else{\\n\\n        let sum = levelSums.get(level);\\n        let left = parent.left\\n        let right = parent.right\\n\\n        if(left){\\n\\n            sum -= nodeValues.get(left)\\n        }\\n        if(right){\\n            sum -= nodeValues.get(right)\\n        }\\n\\n        node.val = sum;\\n    }\\n    \\n    dfs2(node.left, level+1, node)\\n    dfs2(node.right, level+1, node)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\n\\nlet levelSums\\nlet nodeValues\\nlet parents\\nvar replaceValueInTree = function(root) {\\n    levelSums = new Map()\\n    nodeValues = new Map()\\n    parents = new Map()\\n    \\n    dfs1(root, 0, null)\\n    console.log(levelSums)\\n    dfs2(root, 0, null)\\n    \\n    return root\\n    \\n};\\n\\nfunction dfs1(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    nodeValues.set(node, node.val)\\n    \\n    if(!levelSums.has(level)){\\n        levelSums.set(level, 0)\\n    }\\n    \\n    levelSums.set(level, node.val + levelSums.get(level))\\n    dfs1(node.left, level + 1, node)\\n    \\n    dfs1(node.right, level + 1, node)\\n    \\n    \\n}\\n\\nfunction dfs2(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    if(parent == null){\\n        node.val = 0;\\n       \\n    } else{\\n\\n        let sum = levelSums.get(level);\\n        let left = parent.left\\n        let right = parent.right\\n\\n        if(left){\\n\\n            sum -= nodeValues.get(left)\\n        }\\n        if(right){\\n            sum -= nodeValues.get(right)\\n        }\\n\\n        node.val = sum;\\n    }\\n    \\n    dfs2(node.left, level+1, node)\\n    dfs2(node.right, level+1, node)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420151,
                "title": "c-bfs-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        int n=1;\\n        vector<TreeNode*> a1;\\n        unordered_map<TreeNode*, TreeNode*> par;\\n        unordered_map<TreeNode*,int> childSum;\\n        a1.push_back(root);\\n        root->val = 0;\\n        \\n        while(n){\\n            int sum=0,sChild=0;\\n            vector<TreeNode*> a2;\\n            \\n            for(int i=0;i<n;i++){\\n                sChild=0;\\n                auto fr = a1[i];\\n                sum += fr->val;\\n                if(fr->left){\\n                    a2.push_back(fr->left);\\n                    sChild+=fr->left->val;\\n                    par[fr->left] = fr;\\n                }\\n                if(fr->right){\\n                    a2.push_back(fr->right);\\n                    sChild += fr->right->val;\\n                    par[fr->right] = fr;\\n                }\\n                childSum[fr] = sChild;\\n            }\\n            for(int i=0;i<n;i++){\\n                auto fr = a1[i];\\n                fr->val = sum - childSum[par[fr]];\\n            }\\n            a1=a2;\\n            n=a1.size();\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        int n=1;\\n        vector<TreeNode*> a1;\\n        unordered_map<TreeNode*, TreeNode*> par;\\n        unordered_map<TreeNode*,int> childSum;\\n        a1.push_back(root);\\n        root->val = 0;\\n        \\n        while(n){\\n            int sum=0,sChild=0;\\n            vector<TreeNode*> a2;\\n            \\n            for(int i=0;i<n;i++){\\n                sChild=0;\\n                auto fr = a1[i];\\n                sum += fr->val;\\n                if(fr->left){\\n                    a2.push_back(fr->left);\\n                    sChild+=fr->left->val;\\n                    par[fr->left] = fr;\\n                }\\n                if(fr->right){\\n                    a2.push_back(fr->right);\\n                    sChild += fr->right->val;\\n                    par[fr->right] = fr;\\n                }\\n                childSum[fr] = sChild;\\n            }\\n            for(int i=0;i<n;i++){\\n                auto fr = a1[i];\\n                fr->val = sum - childSum[par[fr]];\\n            }\\n            a1=a2;\\n            n=a1.size();\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420138,
                "title": "level-order-traversal-c-easy-to-understnad",
                "content": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        for(int i = 0; i < 1000; i++){}\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        for(int i = 0; i < 1000; i++){}\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420105,
                "title": "c-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void fill(unordered_map<int,int>&m,int level,TreeNode* root){\\n        if(root==NULL)return;\\n        m[level]+=root->val;\\n        fill(m,level+1,root->left);\\n        fill(m,level+1,root->right);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int>m;\\n        fill(m,0,root);\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int level=0;\\n        root->val=0;\\n        // for(auto i:m)cout<<i.first<<\" \"<<i.second<<endl;\\n        while(q.size()){\\n            int n=q.size();\\n            int sum=m[level+1];\\n            while(n--)\\n            {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                if(front->left)sum-=front->left->val;\\n                if(front->right)sum-=front->right->val;\\n                // cout<<sum<<\" \"<<front->val<<endl;\\n                if(front->left)\\n                front->left->val=sum;\\n                if(front->right)\\n                front->right->val=sum;\\n                sum=m[level+1];\\n                \\n                \\n                \\n                if(front->left)q.push(front->left);\\n                if(front->right)q.push(front->right);\\n            }\\n            level++;\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void fill(unordered_map<int,int>&m,int level,TreeNode* root){\\n        if(root==NULL)return;\\n        m[level]+=root->val;\\n        fill(m,level+1,root->left);\\n        fill(m,level+1,root->right);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int>m;\\n        fill(m,0,root);\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int level=0;\\n        root->val=0;\\n        // for(auto i:m)cout<<i.first<<\" \"<<i.second<<endl;\\n        while(q.size()){\\n            int n=q.size();\\n            int sum=m[level+1];\\n            while(n--)\\n            {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                if(front->left)sum-=front->left->val;\\n                if(front->right)sum-=front->right->val;\\n                // cout<<sum<<\" \"<<front->val<<endl;\\n                if(front->left)\\n                front->left->val=sum;\\n                if(front->right)\\n                front->right->val=sum;\\n                sum=m[level+1];\\n                \\n                \\n                \\n                if(front->left)q.push(front->left);\\n                if(front->right)q.push(front->right);\\n            }\\n            level++;\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3938051,
                "title": "c-one-level-order-traversal-without-storing-level-pointer",
                "content": "# Intuition\\nthe idea is to push the value of sibling along with the pointer into the queue and you will be having level sum in advance, replace node value with level sum - sibling - self\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\nn= total number of nodes\\n\\n- Space complexity:\\nO(k) where k is number of nodes in a single level\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n\\n        queue< pair<TreeNode*,int> > q;\\n        q.push({root,0});\\n\\n        //curr_sum stores value of total level sum and for next level\\'s sum calc next_sum is updated on every push to the queue\\n        //in the end curr_sum equals to next_sum \\n        int curr_sum=root->val;\\n        \\n        while(!q.empty()){\\n            int sz=q.size();\\n\\n            int next_sum = 0;\\n\\n            for(int i=0;i<sz;i++){\\n                auto it=q.front();\\n\\n                TreeNode* node= it.first;\\n                int sibling= it.second;\\n\\n                q.pop();\\n\\n                //total level sum - sum of sibling(left or right  we don\\'t know at this moment)\\n                int newVal= curr_sum-sibling- node->val;\\n                //assign new value\\n                node->val=newVal;\\n\\n                //get value of left and right child, send value of left to right child to the left child and vice versa\\n                int left=0, right=0;\\n                if(node->left){\\n                    left=node->left->val;\\n                }\\n                if(node->right){\\n                    right=node->right->val;\\n                }\\n\\n                if(node->left){\\n                    q.push({node->left, right});\\n                    next_sum+=node->left->val;\\n                }\\n                if(node->right){\\n                    q.push({node->right, left});\\n                    next_sum+=node->right->val;\\n\\n                }\\n            }\\n\\n            curr_sum=next_sum;\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n\\n        queue< pair<TreeNode*,int> > q;\\n        q.push({root,0});\\n\\n        //curr_sum stores value of total level sum and for next level\\'s sum calc next_sum is updated on every push to the queue\\n        //in the end curr_sum equals to next_sum \\n        int curr_sum=root->val;\\n        \\n        while(!q.empty()){\\n            int sz=q.size();\\n\\n            int next_sum = 0;\\n\\n            for(int i=0;i<sz;i++){\\n                auto it=q.front();\\n\\n                TreeNode* node= it.first;\\n                int sibling= it.second;\\n\\n                q.pop();\\n\\n                //total level sum - sum of sibling(left or right  we don\\'t know at this moment)\\n                int newVal= curr_sum-sibling- node->val;\\n                //assign new value\\n                node->val=newVal;\\n\\n                //get value of left and right child, send value of left to right child to the left child and vice versa\\n                int left=0, right=0;\\n                if(node->left){\\n                    left=node->left->val;\\n                }\\n                if(node->right){\\n                    right=node->right->val;\\n                }\\n\\n                if(node->left){\\n                    q.push({node->left, right});\\n                    next_sum+=node->left->val;\\n                }\\n                if(node->right){\\n                    q.push({node->right, left});\\n                    next_sum+=node->right->val;\\n\\n                }\\n            }\\n\\n            curr_sum=next_sum;\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430980,
                "title": "easy-c-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->BFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->we will calculate the sum of value of all the node at particular level using bfs then we can simply calculate value of that node by subtracting the value of that node and if it has real sibling then we will minus value of sibling also. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       map<TreeNode*,int>mp;//for storing the value of real sibling of a node\\n       \\n       while(!q.empty()){\\n           int sz =q.size();\\n           queue<TreeNode*>temp;//for storing all the node of current level\\n           int sum =0;          //sum of values of all the node at curent level\\n           for(int i=0;i<sz;i++){\\n               auto it =q.front();\\n               q.pop();\\n               \\n               sum+=it->val;  //calculating sum \\n               temp.push(it);\\n            if(it->left!=NULL){\\n                q.push(it->left);\\n                if(it->right!=NULL){\\n                mp[it->left]=it->right->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n            if(it->right!=NULL){\\n                q.push(it->right);\\n                if(it->left!=NULL){\\n                mp[it->right]=it->left->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n\\n           }\\n           while(!temp.empty()){\\n               auto it =temp.front();\\n               temp.pop();\\n               it->val=sum-it->val;\\n               if(mp.find(it)!=mp.end()){\\n                   it->val=it->val-mp[it];\\n               }\\n       } \\n    }\\n       return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       map<TreeNode*,int>mp;//for storing the value of real sibling of a node\\n       \\n       while(!q.empty()){\\n           int sz =q.size();\\n           queue<TreeNode*>temp;//for storing all the node of current level\\n           int sum =0;          //sum of values of all the node at curent level\\n           for(int i=0;i<sz;i++){\\n               auto it =q.front();\\n               q.pop();\\n               \\n               sum+=it->val;  //calculating sum \\n               temp.push(it);\\n            if(it->left!=NULL){\\n                q.push(it->left);\\n                if(it->right!=NULL){\\n                mp[it->left]=it->right->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n            if(it->right!=NULL){\\n                q.push(it->right);\\n                if(it->left!=NULL){\\n                mp[it->right]=it->left->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n\\n           }\\n           while(!temp.empty()){\\n               auto it =temp.front();\\n               temp.pop();\\n               it->val=sum-it->val;\\n               if(mp.find(it)!=mp.end()){\\n                   it->val=it->val-mp[it];\\n               }\\n       } \\n    }\\n       return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420809,
                "title": "simple-bfs-java-intuitive",
                "content": "# Code\\n```\\nclass Pair {\\n    public TreeNode node;\\n    public int p;\\n    public Pair(TreeNode node, int p) {\\n        this.node = node;\\n        this.p = p;\\n    }\\n}\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<Pair>();\\n        int sum=0;\\n        int prevSum=0;\\n        q.add(new Pair(root,0));\\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            for(int i=0;i<n;i++) {\\n                int s = 0;\\n                Pair nn = q.poll();\\n                nn.node.val = prevSum - nn.p;\\n                if(nn.node.left!=null) s+=nn.node.left.val;\\n                if(nn.node.right!=null) {\\n                    s+=nn.node.right.val;\\n                    q.add(new Pair(nn.node.right,s));\\n                }\\n                if(nn.node.left!=null) q.add(new Pair(nn.node.left,s));\\n                sum+=s;\\n            }\\n            prevSum = sum;\\n            sum=0;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Pair {\\n    public TreeNode node;\\n    public int p;\\n    public Pair(TreeNode node, int p) {\\n        this.node = node;\\n        this.p = p;\\n    }\\n}\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<Pair>();\\n        int sum=0;\\n        int prevSum=0;\\n        q.add(new Pair(root,0));\\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            for(int i=0;i<n;i++) {\\n                int s = 0;\\n                Pair nn = q.poll();\\n                nn.node.val = prevSum - nn.p;\\n                if(nn.node.left!=null) s+=nn.node.left.val;\\n                if(nn.node.right!=null) {\\n                    s+=nn.node.right.val;\\n                    q.add(new Pair(nn.node.right,s));\\n                }\\n                if(nn.node.left!=null) q.add(new Pair(nn.node.left,s));\\n                sum+=s;\\n            }\\n            prevSum = sum;\\n            sum=0;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420523,
                "title": "easy-to-understand-straightforward-solution-with-explanation-and-comments",
                "content": "# Intuition\\nThe solution is based on the follwing observations.\\n- Sum of cousins equals the difference between the sum of entire level AND the sum of siblings. \\n- We can use BFS to traverse the tree level-wise.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps :-\\n- Store the sum_of_children in a hashmap`hmap`, with the node refernece as the key.\\n- Maintain a running sum of the entire next level simultaneously.\\n- Now for each element in the current level do this:\\n    - pop out the node.\\n    - Use the hashmap to modify the children of the node : sum_of_next_level - sum_of_children\\n    - push the modified node into the queue for next level of operations.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if not root.left and not root.right: return root\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            hmap = {}       #store the sum of children of each node in the following fashion -> {node: node.left.val + node.right.val}\\n            size = len(q)\\n            runsum = 0      #store the running sum of next level.\\n            for i in range(size):\\n                childsum = 0      #sum of children of each node\\n                if q[i].left:\\n                    childsum+=q[i].left.val\\n                    runsum+=q[i].left.val\\n                if q[i].right:\\n                    childsum+=q[i].right.val\\n                    runsum+=q[i].right.val\\n                hmap[q[i]] = childsum       #add sum of children to hashmap\\n\\n            while size:\\n                node = q.popleft()\\n                if node.left:\\n                    node.left.val = runsum-hmap[node] #modify child\\n                    q.append(node.left) #push child in queue for next iteration       \\n                if node.right:\\n                    node.right.val =  runsum-hmap[node]\\n                    q.append(node.right)\\n                size-=1\\n                \\n        return root        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if not root.left and not root.right: return root\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            hmap = {}       #store the sum of children of each node in the following fashion -> {node: node.left.val + node.right.val}\\n            size = len(q)\\n            runsum = 0      #store the running sum of next level.\\n            for i in range(size):\\n                childsum = 0      #sum of children of each node\\n                if q[i].left:\\n                    childsum+=q[i].left.val\\n                    runsum+=q[i].left.val\\n                if q[i].right:\\n                    childsum+=q[i].right.val\\n                    runsum+=q[i].right.val\\n                hmap[q[i]] = childsum       #add sum of children to hashmap\\n\\n            while size:\\n                node = q.popleft()\\n                if node.left:\\n                    node.left.val = runsum-hmap[node] #modify child\\n                    q.append(node.left) #push child in queue for next iteration       \\n                if node.right:\\n                    node.right.val =  runsum-hmap[node]\\n                    q.append(node.right)\\n                size-=1\\n                \\n        return root        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420227,
                "title": "c-simple-bfs-level-order-traversal-clean-code-well-explained-beginner-friendly",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>> ans; \\n        //base case\\n        if(root == NULL) \\n            return ans; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root); \\n        \\n        //taking the level order or BFS traversal\\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<int> level;\\n            //this takes care of the whole level present\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                    level.push_back(node->val);\\n                }\\n//null nodes are assigned with 0 so that the total sum is not affected when we take level sum below\\n                else level.push_back(0);\\n                \\n            }\\n            ans.push_back(level);\\n        }\\n        return ans; \\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>> lvl = levelOrder(root);\\n        if(root == NULL) \\n            return root; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root);\\n        \\n        int n=0; //level number\\n        int l =lvl.size()-1;\\n        while(!q.empty() and n<l) {\\n            int size = q.size();\\n            long long sum = 0;\\n            int s = lvl[n].size();\\n            //taking the total sum present in the level\\n            for(int it=0;it<s;++it){\\n                sum+=lvl[n][it];\\n            }\\n            int j=0;\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                //node->val = 0 bcz they lie with the same parent\\n                    if(n<2)node->val=0;\\n                    else{\\n                        int temp = sum;\\n                        //only two adjacent nodes can be from the same parent\\n                        //so we are subracting it\\n                        if(j%2==0){\\n                            temp-=(lvl[n][j]+lvl[n][j+1]);\\n                        }\\n                        else{\\n                            temp-=(lvl[n][j]+lvl[n][j-1]);\\n                        }\\n                        node->val = temp;\\n                    }\\n                }\\n                ++j;\\n            }\\n            ++n;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>> ans; \\n        //base case\\n        if(root == NULL) \\n            return ans; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root); \\n        \\n        //taking the level order or BFS traversal\\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<int> level;\\n            //this takes care of the whole level present\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                    level.push_back(node->val);\\n                }\\n//null nodes are assigned with 0 so that the total sum is not affected when we take level sum below\\n                else level.push_back(0);\\n                \\n            }\\n            ans.push_back(level);\\n        }\\n        return ans; \\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>> lvl = levelOrder(root);\\n        if(root == NULL) \\n            return root; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root);\\n        \\n        int n=0; //level number\\n        int l =lvl.size()-1;\\n        while(!q.empty() and n<l) {\\n            int size = q.size();\\n            long long sum = 0;\\n            int s = lvl[n].size();\\n            //taking the total sum present in the level\\n            for(int it=0;it<s;++it){\\n                sum+=lvl[n][it];\\n            }\\n            int j=0;\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                //node->val = 0 bcz they lie with the same parent\\n                    if(n<2)node->val=0;\\n                    else{\\n                        int temp = sum;\\n                        //only two adjacent nodes can be from the same parent\\n                        //so we are subracting it\\n                        if(j%2==0){\\n                            temp-=(lvl[n][j]+lvl[n][j+1]);\\n                        }\\n                        else{\\n                            temp-=(lvl[n][j]+lvl[n][j-1]);\\n                        }\\n                        node->val = temp;\\n                    }\\n                }\\n                ++j;\\n            }\\n            ++n;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420088,
                "title": "just-dfs",
                "content": "# Intuition\\nJust DFS.\\n\\n# Approach\\nJust DFS. Save:\\n(1) The depth of each node.\\n(2) The parent of each node.\\n(3) The sum of values of all descants of each node.\\n(4) The sum of values of all nodes on for each depth.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(int d, TreeNode* root, TreeNode* parent, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons, unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        dep[root] = d;\\n        sons[parent] += root->val;\\n        s[d] += root->val;\\n        f[root] = parent;\\n        dfs(d + 1, root->left, root, dep, sons, s, f);\\n        dfs(d + 1, root->right, root, dep, sons, s, f);\\n    }\\n    \\n    void dfs(TreeNode* root, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons,\\n          unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        root->val = s[dep[root]] - sons[f[root]];\\n        dfs(root->left, dep, sons, s, f);\\n        dfs(root->right, dep, sons, s, f);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dep, sons;\\n        unordered_map<int, int> s;\\n        unordered_map<TreeNode*, TreeNode*> f;\\n        dfs(0, root, nullptr, dep, sons, s, f);\\n        dfs(root, dep, sons, s, f);\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(int d, TreeNode* root, TreeNode* parent, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons, unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        dep[root] = d;\\n        sons[parent] += root->val;\\n        s[d] += root->val;\\n        f[root] = parent;\\n        dfs(d + 1, root->left, root, dep, sons, s, f);\\n        dfs(d + 1, root->right, root, dep, sons, s, f);\\n    }\\n    \\n    void dfs(TreeNode* root, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons,\\n          unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        root->val = s[dep[root]] - sons[f[root]];\\n        dfs(root->left, dep, sons, s, f);\\n        dfs(root->right, dep, sons, s, f);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dep, sons;\\n        unordered_map<int, int> s;\\n        unordered_map<TreeNode*, TreeNode*> f;\\n        dfs(0, root, nullptr, dep, sons, s, f);\\n        dfs(root, dep, sons, s, f);\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419971,
                "title": "bfs-twice-to-find-sum-of-each-level",
                "content": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        sums = defaultdict(int)\\n        sumparents = defaultdict(lambda: defaultdict(int))\\n        q = deque([(root, 0)])\\n        while len(q) > 0:\\n            curr, d = q.pop()\\n            if curr:\\n                sums[d] += curr.val\\n                q.appendleft((curr.left, d + 1))\\n                q.appendleft((curr.right, d + 1))\\n        q = deque([(root, root.val if root else 0, 0, 0)])\\n        while len(q) > 0:\\n            curr, currval, other, d = q.pop()\\n            curr.val = sums[d] - currval - other\\n            if curr.left:\\n                q.appendleft((curr.left, curr.left.val, curr.right.val if curr.right else 0, d + 1))\\n            if curr.right:\\n                q.appendleft((curr.right, curr.right.val, curr.left.val if curr.left else 0, d + 1))\\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        sums = defaultdict(int)\\n        sumparents = defaultdict(lambda: defaultdict(int))\\n        q = deque([(root, 0)])\\n        while len(q) > 0:\\n            curr, d = q.pop()\\n            if curr:\\n                sums[d] += curr.val\\n                q.appendleft((curr.left, d + 1))\\n                q.appendleft((curr.right, d + 1))\\n        q = deque([(root, root.val if root else 0, 0, 0)])\\n        while len(q) > 0:\\n            curr, currval, other, d = q.pop()\\n            curr.val = sums[d] - currval - other\\n            if curr.left:\\n                q.appendleft((curr.left, curr.left.val, curr.right.val if curr.right else 0, d + 1))\\n            if curr.right:\\n                q.appendleft((curr.right, curr.right.val, curr.left.val if curr.left else 0, d + 1))\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920356,
                "title": "optimal-approach-with-full-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**- dfs1 Function:**\\nThis function performs a depth-first search (DFS) traversal of the binary tree while calculating the sum of node values at each depth. It uses a hash map mp to store the sum of values for each depth.\\n\\n**- dfs2 Function:**\\nThis function is another DFS traversal of the binary tree. It calculates the new value for each node based on the sum of values at its depth and the value of its sibling node. It first calculates the values of the left and right children of the current node and then updates the current node\\'s value according to the formula: new_value = sum_at_depth - current_value - sibling_value.\\n\\n**- replaceValueInTree Function:**\\nThis is the main function that orchestrates the entire process. It first creates an unordered map mp to store the sum of values at each depth. Then, it initiates the first DFS (dfs1) to populate the mp map. After that, it initiates the second DFS (dfs2) to update the values of the nodes.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1O)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs1(TreeNode* node,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        mp[depth] += node->val;\\n        \\n        dfs1(node->left,depth+1,mp);\\n        dfs1(node->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* node,int sibling,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        node->val = mp[depth] - node->val - sibling;\\n        \\n        int lVal;\\n        if(node->left) {\\n            lVal = node->left->val;\\n        }\\n        else {\\n            lVal = 0;\\n        }\\n        \\n        int rVal;\\n        if(node->right) {\\n            rVal = node->right->val;\\n        }\\n        else {\\n            rVal = 0;\\n        }\\n        \\n        \\n        dfs2(node->left,rVal,depth+1,mp);\\n        dfs2(node->right,lVal,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        \\n        \\n        \\n        TreeNode* dummy =  root;\\n        \\n        dfs1(root,0,mp);\\n        dfs2(root,0,0,mp);\\n            \\n            return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs1(TreeNode* node,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        mp[depth] += node->val;\\n        \\n        dfs1(node->left,depth+1,mp);\\n        dfs1(node->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* node,int sibling,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        node->val = mp[depth] - node->val - sibling;\\n        \\n        int lVal;\\n        if(node->left) {\\n            lVal = node->left->val;\\n        }\\n        else {\\n            lVal = 0;\\n        }\\n        \\n        int rVal;\\n        if(node->right) {\\n            rVal = node->right->val;\\n        }\\n        else {\\n            rVal = 0;\\n        }\\n        \\n        \\n        dfs2(node->left,rVal,depth+1,mp);\\n        dfs2(node->right,lVal,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        \\n        \\n        \\n        TreeNode* dummy =  root;\\n        \\n        dfs1(root,0,mp);\\n        dfs2(root,0,0,mp);\\n            \\n            return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843279,
                "title": "c-level-order-traversal-mapping-easy-solution-with-comments-and-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen i first read the question, it was clearly mentioned that we need to replace the value of nodes in tree with the sum of its cousins(nodes at the same level).Since, cousins are the nodes which are at the same level so i thought of traversing the tree level wise and while traversing i\\'ll keep a track of the sum of all nodes at that level.\\nAfter, mapping the level of tree with its respective sum i\\'ll again traverse the tree level wise and this time i\\'ll see if the node has left, right children, then i\\'ll subtract the sum which is mapped with that level and assign that value with the left and right children. \\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n    2*O(n) --> Two times level wise traversal\\n    O(1)--> insertion and retrieval in unordered_map\\n      **O(N)**\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->  \\n    O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        //map to store the sum at each level \\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        //queue for level order traversal\\n        q.push(root);\\n        mp[0]=root->val;\\n        //we are doing first time level wise traversal to map each level to the sum of the value of nodes at that level\\n        int level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto r=q.front();\\n                q.pop();\\n                if(r->left){\\n                    mp[level]+=r->left->val;\\n                    q.push(r->left);\\n                }\\n                if(r->right){\\n                    q.push(r->right);\\n                    mp[level]+=r->right->val;\\n                }\\n            }\\n        }\\n        //second time level order traversal to alter the value of nodes according to the question\\n        q.push(root);   \\n        root->val=0;\\n        level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto it=q.front();\\n                q.pop();\\n                int l=it->left!=NULL?it->left->val:0;\\n                int r=it->right!=NULL?it->right->val:0;\\n                if(it->left){\\n                    q.push(it->left);\\n                    it->left->val=mp[level]-l-r;\\n                }\\n                if(it->right){\\n                    q.push(it->right);\\n                    it->right->val=mp[level]-l-r;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        //map to store the sum at each level \\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        //queue for level order traversal\\n        q.push(root);\\n        mp[0]=root->val;\\n        //we are doing first time level wise traversal to map each level to the sum of the value of nodes at that level\\n        int level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto r=q.front();\\n                q.pop();\\n                if(r->left){\\n                    mp[level]+=r->left->val;\\n                    q.push(r->left);\\n                }\\n                if(r->right){\\n                    q.push(r->right);\\n                    mp[level]+=r->right->val;\\n                }\\n            }\\n        }\\n        //second time level order traversal to alter the value of nodes according to the question\\n        q.push(root);   \\n        root->val=0;\\n        level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto it=q.front();\\n                q.pop();\\n                int l=it->left!=NULL?it->left->val:0;\\n                int r=it->right!=NULL?it->right->val:0;\\n                if(it->left){\\n                    q.push(it->left);\\n                    it->left->val=mp[level]-l-r;\\n                }\\n                if(it->right){\\n                    q.push(it->right);\\n                    it->right->val=mp[level]-l-r;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641061,
                "title": "c-2-times-bfs-simple",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getSum(root, levelSum);\\n        return updateTree(root, levelSum);\\n    }\\n\\nprivate:\\n    void getSum(TreeNode* root, vector<int>& levelSum) {\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            int sum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                sum += curr->val;\\n                if (curr->left) Q.push(curr->left);\\n                if (curr->right) Q.push(curr->right);\\n            }\\n            levelSum.emplace_back(sum);\\n        }\\n    }\\n\\n    TreeNode* updateTree(TreeNode* root, vector<int>& levelSum) {\\n        int level = 0;\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                int siblingSum = (curr->left ? curr->left->val : 0) + \\n                                   (curr->right ? curr->right->val : 0);\\n                if (level == 0) curr->val = 0;\\n                if (curr->left) {\\n                    Q.push(curr->left);\\n                    curr->left->val = levelSum[level+1] - siblingSum;\\n                }\\n                if (curr->right) {\\n                    Q.push(curr->right);\\n                    curr->right->val = levelSum[level+1] - siblingSum;\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getSum(root, levelSum);\\n        return updateTree(root, levelSum);\\n    }\\n\\nprivate:\\n    void getSum(TreeNode* root, vector<int>& levelSum) {\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            int sum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                sum += curr->val;\\n                if (curr->left) Q.push(curr->left);\\n                if (curr->right) Q.push(curr->right);\\n            }\\n            levelSum.emplace_back(sum);\\n        }\\n    }\\n\\n    TreeNode* updateTree(TreeNode* root, vector<int>& levelSum) {\\n        int level = 0;\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                int siblingSum = (curr->left ? curr->left->val : 0) + \\n                                   (curr->right ? curr->right->val : 0);\\n                if (level == 0) curr->val = 0;\\n                if (curr->left) {\\n                    Q.push(curr->left);\\n                    curr->left->val = levelSum[level+1] - siblingSum;\\n                }\\n                if (curr->right) {\\n                    Q.push(curr->right);\\n                    curr->right->val = levelSum[level+1] - siblingSum;\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640932,
                "title": "python-simple-and-clean-beats-99-89",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n# Intuition\\nThe problem asks us to replace the value of each node in a binary tree with the sum of all its cousins\\' values. Two nodes are cousins if they have the same depth with different parents. One way to approach this problem is to use a breadth-first search (BFS) algorithm to traverse the tree level by level and keep track of the sum of values of nodes at each level and the sum of values of siblings at each level.\\n\\n# Approach\\n1. Initialize a queue with a tuple containing the root node and its value. This queue will be used to perform BFS on the tree.\\n2. Initialize a variable `level_sum` with the value of the root node. This variable will be used to keep track of the sum of values of nodes at each level.\\n3. While the queue is not empty:\\n    1. Initialize a list `level_q` to store the nodes in the next level.\\n    2. Initialize a variable `curr` to store the sum of values of siblings in the next level.\\n    3. For each tuple `(node, sib)` in `queue`:\\n        1. Update the value of `node` to `level_sum - sib`, where `level_sum` is the sum of values of nodes at the current level and `sib` is the sum of values of `node`\\'s siblings.\\n        2. Initialize a variable `next_sib` to store the sum of values of `node`\\'s left and right children (or 0 if they don\\'t exist).\\n        3. Add `next_sib` to `curr`.\\n        4. If `node` has a left child, append a tuple containing its left child and `next_sib` to `level_q`.\\n        5. If `node` has a right child, append a tuple containing its right child and `next_sib` to `level_q`.\\n    4. Update `queue` with `level_q`.\\n    5. Update `level_sum` with `curr`.\\n4. Return the root of the modified tree.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the number of nodes in the tree.\\n- Space complexity: $$O(n)$$ where n is the number of nodes in the tree.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [(root,root.val)] # [node,siblings_sum]\\n        level_sum = root.val # sum of nodes at a level\\n        \\n        #BFS\\n        while queue:\\n            curr = 0\\n            level_q = []\\n            for node, sib in queue:\\n                node.val = level_sum - sib # replace node value with sum of siblings\\n                next_sib = 0\\n                if node.left:\\n                    next_sib += node.left.val\\n                if node.right:\\n                    next_sib += node.right.val\\n                curr += next_sib\\n                if node.left:\\n                    level_q.append((node.left,next_sib))\\n                if node.right:\\n                    level_q.append((node.right,next_sib))\\n            queue = level_q\\n            level_sum = curr # update sum of nodes at current level\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [(root,root.val)] # [node,siblings_sum]\\n        level_sum = root.val # sum of nodes at a level\\n        \\n        #BFS\\n        while queue:\\n            curr = 0\\n            level_q = []\\n            for node, sib in queue:\\n                node.val = level_sum - sib # replace node value with sum of siblings\\n                next_sib = 0\\n                if node.left:\\n                    next_sib += node.left.val\\n                if node.right:\\n                    next_sib += node.right.val\\n                curr += next_sib\\n                if node.left:\\n                    level_q.append((node.left,next_sib))\\n                if node.right:\\n                    level_q.append((node.right,next_sib))\\n            queue = level_q\\n            level_sum = curr # update sum of nodes at current level\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516197,
                "title": "2641-cousins-in-binary-tree-ii-java",
                "content": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> sum=new ArrayList<>();\\n        sum.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            sum.add(sum1);\\n        }\\n        q.clear();\\n        q.add(root);\\n        int lev=-1;\\n        while(!q.isEmpty())\\n        {\\n            lev++;\\n            int size=q.size();\\n            while(size--!=0)\\n            {\\n                int civiling_sum=0;\\n                TreeNode cur=q.poll();\\n                if(lev==1||lev==0)\\n                    cur.val=0;\\n                if(cur.left!=null)\\n                {\\n                    civiling_sum+=cur.left.val;\\n                    q.add(cur.left);\\n                }\\n                \\n                if(cur.right!=null)\\n                {\\n                    civiling_sum+=cur.right.val;\\n                    q.add(cur.right);\\n                }\\n                if(lev>=1){\\n                     if(cur.left!=null){\\n                          \\n                        cur.left.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                    if(cur.right!=null){\\n                        cur.right.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                }\\n            }\\n        }\\n        return root;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> sum=new ArrayList<>();\\n        sum.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            sum.add(sum1);\\n        }\\n        q.clear();\\n        q.add(root);\\n        int lev=-1;\\n        while(!q.isEmpty())\\n        {\\n            lev++;\\n            int size=q.size();\\n            while(size--!=0)\\n            {\\n                int civiling_sum=0;\\n                TreeNode cur=q.poll();\\n                if(lev==1||lev==0)\\n                    cur.val=0;\\n                if(cur.left!=null)\\n                {\\n                    civiling_sum+=cur.left.val;\\n                    q.add(cur.left);\\n                }\\n                \\n                if(cur.right!=null)\\n                {\\n                    civiling_sum+=cur.right.val;\\n                    q.add(cur.right);\\n                }\\n                if(lev>=1){\\n                     if(cur.left!=null){\\n                          \\n                        cur.left.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                    if(cur.right!=null){\\n                        cur.right.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                }\\n            }\\n        }\\n        return root;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441647,
                "title": "hash-map-approach",
                "content": "class Solution {\\n    \\n    HashMap<Integer,Integer>map;\\n    HashMap<TreeNode,Integer>originalvalue;\\n    \\n    public void dfs(TreeNode root,int level){\\n        if(root==null)\\n            return;\\n        \\n        originalvalue.put(root,root.val);\\n        if(map.containsKey(level)){\\n            map.put(level,map.get(level)+root.val);\\n        }\\n        else\\n            map.put(level,root.val);\\n        \\n        dfs(root.left,level+1);\\n        dfs(root.right,level+1);\\n        \\n    }\\n    \\n    public void dfs2(TreeNode root,TreeNode par,int level){\\n        if(root==null){\\n            return;\\n        }\\n        \\n        if(par==null){\\n            root.val=0;\\n        }\\n        else{\\n            int total=map.get(level);\\n            if(par.left!=null)\\n                total-=originalvalue.get(par.left);\\n            if(par.right!=null)\\n                total-=originalvalue.get(par.right);\\n            root.val=total;\\n        }\\n        \\n        dfs2(root.left,root,level+1);\\n        dfs2(root.right,root,level+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        map=new HashMap<Integer,Integer>();\\n        originalvalue=new HashMap<>();\\n        dfs(root,1);\\n        \\n        for(int i=1;i<=3;i++)\\n            System.out.println(i+\" \"+map.get(i));\\n        \\n        dfs2(root,null,1);\\n        \\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    HashMap<Integer,Integer>map;\\n    HashMap<TreeNode,Integer>originalvalue;\\n    \\n    public void dfs(TreeNode root,int level){\\n        if(root==null)\\n            return;\\n        \\n        originalvalue.put(root,root.val);\\n        if(map.containsKey(level)){\\n            map.put(level,map.get(level)+root.val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3437493,
                "title": "java-6ms-100-bfs-speed-optimized-explanation-fastest",
                "content": "The following code uses a Breadth-First-Search (BFS) to descend through the levels of the tree to modify the tree to contain cousin sums.  \\n\\nThis code is optimized for execution speed.  It could be simpler and more general case, and therefore more readable, but those simplifications are slower.  Unless execution speed is needed, the simpler and more generalized coding techniques are usually thought of as better coding practices, because they are easier to modify, handle changes of requirements better, and are easier to maintain over time.  If at a job interview, using speed optimized code such as this takes more time to create, and is more difficult for the interviewer to read.  Using the simpler more general case code is usually thought of as better coding practices.  When creating code at an interview, I feel it is good to ask the interviewer what their priorities are, such as time to complete the coding, readability, commenting and documenting, execition time, error and bad input handling, etc.  This lets me create code to better meet the interviewer\\'s expectations, lets the interviewer know that I consider these priorities before coding, and gives the impression that I can write the code for any of these priorities.\\n\\nTo get faster execution speed, the code below uses a single `TreeNode[]` array to contain breadth first search\\'s list of tree nodes on a single level.  Using an array has faster execution time than a `Queue` or an `ArrayList` class.  The array actually contains two lists of TreeNode\\'s.  One list is the current level for the BFS, while the other is the list being built for the next BFS level.  Within the array, these lists alternate between being built from the start of the array going forward, and from the end of the array going backward.  As the list for the current BFS level is processed, it is shrinking, while the list that is being built for the next BFS level is growing, making for less needed space in the array, because the array will never have to hold complete lists for both current and next level at the same time.  One list is shrinking as the other list is growing.  The array has to be big enough for the worst case storage requirements, which will be (max_number_of_nodes+1)/2 = 100_001/2 = 50_000.\\n\\nIn April 2023, this code ran as fast as 6ms.  The next fastest code on the runtime graph was 12ms, which used two `Queue` for its BFS lists.\\n\\nIf useful, please upvote.\\n```\\nclass Solution {\\n    // The nodes[] array contains the list of nodes for a breadth \\n    // first search (BFS) of a level of the tree, while building \\n    // the list of nodes for the BFS for the next level.  These \\n    // two lists are stored in the nodes[] array at the same time.  \\n    // One list, the \"left\" list, is built from the start of \\n    // nodes[] going upward in the array.  The other list, the \\n    // \"right\" list, is built from the end of nodes[] going \\n    // downward.  Because the tree has a maximum of 100_000 (10^5) \\n    // nodes, we will need an array of size 100_000/2 == 50_000 \\n    // to simultaneously hold both lists in the same array.  \\n    // But for this leetcode problem\\'s test cases in April 2023, \\n    // an array length of 9000 is long enough.  By making this \\n    // array a static, the array will only be allocated once for \\n    // all the leetcode problem\\'s test cases, instead of allocating \\n    // the array again for each test case, which would require \\n    // slower runtime.\\n    static final TreeNode[] nodes = new TreeNode[50_000];\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        nodes[0] = root;\\n        int sumL = root.val;\\n        int sumR = 0;\\n        final int startL = 0;\\n        final int startR = nodes.length - 1;\\n        int lastL = startL + 1;\\n        int lastR = startR;\\n        TreeNode node = null;\\n        \\n        // Loop through the levels of the tree in a breadth first \\n        // search (BFS) of the tree nodes.  Each time through this \\n        // loop processes the next two levels of the tree.  First \\n        // processing the list of nodes on the left side of nodes[] \\n        // while building the list of the next level\\'s nodes on \\n        // the right side of nodes[].  Then secondly, processing \\n        // the list of nodes on the right side of nodes[] while \\n        // building the list of the next level\\'s nodes on the left \\n        // side of nodes[].\\n        while (lastL != 0) {\\n            // Process the list of nodes on the left side of nodes[] \\n            // while building the list of the next level\\'s nodes on \\n            // the right side of nodes[].\\n            sumR = 0;\\n            while (lastL > 0) {\\n                node = nodes[--lastL];\\n                node.val = sumL - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumR += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastR--] = node.left;\\n                        nodes[lastR--] = node.right;\\n                    } else {                     // If left child only.\\n                        sumR += node.left.val;\\n                        nodes[lastR--] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumR += node.right.val;\\n                    nodes[lastR--] = node.right;\\n                }\\n            }\\n            if (lastR == startR)  break;    // If no more levels.\\n            // Process the list of nodes on the right side of \\n            // nodes[] while building the list of the next level\\'s \\n            // nodes on the left side of nodes[].\\n            sumL = 0;\\n            while (lastR < startR) {\\n                node = nodes[++lastR];\\n                node.val = sumR - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumL += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastL++] = node.left;\\n                        nodes[lastL++] = node.right;\\n                    } else {                     // If left child only.\\n                        sumL += node.left.val;\\n                        nodes[lastL++] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumL += node.right.val;\\n                    nodes[lastL++] = node.right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    // The nodes[] array contains the list of nodes for a breadth \\n    // first search (BFS) of a level of the tree, while building \\n    // the list of nodes for the BFS for the next level.  These \\n    // two lists are stored in the nodes[] array at the same time.  \\n    // One list, the \"left\" list, is built from the start of \\n    // nodes[] going upward in the array.  The other list, the \\n    // \"right\" list, is built from the end of nodes[] going \\n    // downward.  Because the tree has a maximum of 100_000 (10^5) \\n    // nodes, we will need an array of size 100_000/2 == 50_000 \\n    // to simultaneously hold both lists in the same array.  \\n    // But for this leetcode problem\\'s test cases in April 2023, \\n    // an array length of 9000 is long enough.  By making this \\n    // array a static, the array will only be allocated once for \\n    // all the leetcode problem\\'s test cases, instead of allocating \\n    // the array again for each test case, which would require \\n    // slower runtime.\\n    static final TreeNode[] nodes = new TreeNode[50_000];\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        nodes[0] = root;\\n        int sumL = root.val;\\n        int sumR = 0;\\n        final int startL = 0;\\n        final int startR = nodes.length - 1;\\n        int lastL = startL + 1;\\n        int lastR = startR;\\n        TreeNode node = null;\\n        \\n        // Loop through the levels of the tree in a breadth first \\n        // search (BFS) of the tree nodes.  Each time through this \\n        // loop processes the next two levels of the tree.  First \\n        // processing the list of nodes on the left side of nodes[] \\n        // while building the list of the next level\\'s nodes on \\n        // the right side of nodes[].  Then secondly, processing \\n        // the list of nodes on the right side of nodes[] while \\n        // building the list of the next level\\'s nodes on the left \\n        // side of nodes[].\\n        while (lastL != 0) {\\n            // Process the list of nodes on the left side of nodes[] \\n            // while building the list of the next level\\'s nodes on \\n            // the right side of nodes[].\\n            sumR = 0;\\n            while (lastL > 0) {\\n                node = nodes[--lastL];\\n                node.val = sumL - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumR += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastR--] = node.left;\\n                        nodes[lastR--] = node.right;\\n                    } else {                     // If left child only.\\n                        sumR += node.left.val;\\n                        nodes[lastR--] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumR += node.right.val;\\n                    nodes[lastR--] = node.right;\\n                }\\n            }\\n            if (lastR == startR)  break;    // If no more levels.\\n            // Process the list of nodes on the right side of \\n            // nodes[] while building the list of the next level\\'s \\n            // nodes on the left side of nodes[].\\n            sumL = 0;\\n            while (lastR < startR) {\\n                node = nodes[++lastR];\\n                node.val = sumR - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumL += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastL++] = node.left;\\n                        nodes[lastL++] = node.right;\\n                    } else {                     // If left child only.\\n                        sumL += node.left.val;\\n                        nodes[lastL++] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumL += node.right.val;\\n                    nodes[lastL++] = node.right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431529,
                "title": "c-bfs-sum-at-each-level-dfs-calculate-for-each-child",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n        void dfs2(TreeNode* root,vector<int>&dep,int d){\\n        if(root==NULL || d+1==dep.size())\\n        return ;\\n\\n        int l=(root->left)?root->left->val:0;\\n        int r=(root->right)?root->right->val:0;\\n\\n        if((l+r<=dep[d+1])){\\n            if(l!=0)\\n            root->left->val=(dep[d+1]-(l+r));\\n\\n            if(r!=0)\\n            root->right->val=(dep[d+1]-(l+r));\\n        }\\n        dfs2(root->left,dep,d+1);\\n        dfs2(root->right,dep,d+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>dep;\\n\\n         int level=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        dep.push_back(0);  \\n            \\n        while(q.empty()==false){\\n           int size=q.size();\\n           int sum=0;\\n        \\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                 q.pop();\\n                 if(node->left){\\n                      q.push(node->left);\\n                      sum+=node->left->val;\\n                 }  \\n               if (node->right){\\n                  q.push(node->right);\\n                  sum+=node->right->val;\\n               }\\n                 \\n            }\\n            if(!q.empty())\\n            dep.push_back(sum);    \\n        }\\n\\n        dfs2(root,dep,0);\\n        root->val=0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n        void dfs2(TreeNode* root,vector<int>&dep,int d){\\n        if(root==NULL || d+1==dep.size())\\n        return ;\\n\\n        int l=(root->left)?root->left->val:0;\\n        int r=(root->right)?root->right->val:0;\\n\\n        if((l+r<=dep[d+1])){\\n            if(l!=0)\\n            root->left->val=(dep[d+1]-(l+r));\\n\\n            if(r!=0)\\n            root->right->val=(dep[d+1]-(l+r));\\n        }\\n        dfs2(root->left,dep,d+1);\\n        dfs2(root->right,dep,d+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>dep;\\n\\n         int level=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        dep.push_back(0);  \\n            \\n        while(q.empty()==false){\\n           int size=q.size();\\n           int sum=0;\\n        \\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                 q.pop();\\n                 if(node->left){\\n                      q.push(node->left);\\n                      sum+=node->left->val;\\n                 }  \\n               if (node->right){\\n                  q.push(node->right);\\n                  sum+=node->right->val;\\n               }\\n                 \\n            }\\n            if(!q.empty())\\n            dep.push_back(sum);    \\n        }\\n\\n        dfs2(root,dep,0);\\n        root->val=0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427575,
                "title": "bfs-and-childsum-easy-to-understand",
                "content": "Please UpVote if you  like the solution !\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is store every node\\'s child value for future reference i.e **futureSum** and a temporary sum which stores the sum for the siblings sum and then assign those siblings node their sibling sum i.e **tempsum** , after one level we have our **totalSum** in the form of **futureSum**. And the node for which we doing these calculations just assign totalSum-siblingsSum.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        unordered_map<TreeNode*,int>mp;\\n        TreeNode* r = root;\\n        if(root == NULL)\\n            return r;\\n        q.push(root);\\n        int totalSum = root->val;\\n        mp[root] = root->val;\\n        while(!q.empty())\\n        {\\n            int size = q.size(), futureSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                int tempsum = 0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left){ \\n                    q.push(node->left);\\n                    futureSum += node->left->val; \\n                    tempsum += node->left->val;\\n                }\\n                    \\n                if(node->right){\\n                    q.push(node->right);\\n                    futureSum += node->right->val;\\n                    tempsum += node->right->val;\\n                }\\n                \\n                if(node->left)\\n                    mp[node->left] = tempsum;\\n                if(node->right)\\n                    mp[node->right] = tempsum;\\n\\n                node->val = totalSum-mp[node];\\n                mp.erase(node);\\n            }\\n            totalSum = futureSum;\\n         }\\n        return r;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        unordered_map<TreeNode*,int>mp;\\n        TreeNode* r = root;\\n        if(root == NULL)\\n            return r;\\n        q.push(root);\\n        int totalSum = root->val;\\n        mp[root] = root->val;\\n        while(!q.empty())\\n        {\\n            int size = q.size(), futureSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                int tempsum = 0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left){ \\n                    q.push(node->left);\\n                    futureSum += node->left->val; \\n                    tempsum += node->left->val;\\n                }\\n                    \\n                if(node->right){\\n                    q.push(node->right);\\n                    futureSum += node->right->val;\\n                    tempsum += node->right->val;\\n                }\\n                \\n                if(node->left)\\n                    mp[node->left] = tempsum;\\n                if(node->right)\\n                    mp[node->right] = tempsum;\\n\\n                node->val = totalSum-mp[node];\\n                mp.erase(node);\\n            }\\n            totalSum = futureSum;\\n         }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426376,
                "title": "a-simple-bfs-with-one-time-traversal",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        \\n        Queue<Pair<TreeNode,Integer>> q = new LinkedList<>();\\n        \\n        q.offer(new Pair(root,0));\\n        \\n        int totalSumAtSameHeight = 0;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int k=q.size();\\n            \\n            int prev = totalSumAtSameHeight;\\n            totalSumAtSameHeight = 0;\\n            \\n            while(k-->0){\\n                \\n                Pair<TreeNode,Integer> p=q.poll();\\n                \\n                int siblingSum = 0;\\n                \\n                TreeNode curr = p.getKey();\\n                \\n                if(curr.left!=null){\\n                    siblingSum += curr.left.val;\\n                    totalSumAtSameHeight += curr.left.val;\\n                }\\n                \\n                if(curr.right!=null){\\n                    siblingSum += curr.right.val;\\n                    totalSumAtSameHeight += curr.right.val;\\n\\n                }\\n                \\n                if(p.getKey().left!=null){\\n                    q.offer(new Pair(curr.left, siblingSum));\\n                }\\n                \\n                if(p.getKey().right!=null){\\n                    q.offer(new Pair(curr.right, siblingSum));\\n                }\\n                \\n                curr.val = prev - p.getValue();\\n            }\\n            \\n        }\\n        \\n        \\n        return root;\\n        \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        \\n        Queue<Pair<TreeNode,Integer>> q = new LinkedList<>();\\n        \\n        q.offer(new Pair(root,0));\\n        \\n        int totalSumAtSameHeight = 0;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int k=q.size();\\n            \\n            int prev = totalSumAtSameHeight;\\n            totalSumAtSameHeight = 0;\\n            \\n            while(k-->0){\\n                \\n                Pair<TreeNode,Integer> p=q.poll();\\n                \\n                int siblingSum = 0;\\n                \\n                TreeNode curr = p.getKey();\\n                \\n                if(curr.left!=null){\\n                    siblingSum += curr.left.val;\\n                    totalSumAtSameHeight += curr.left.val;\\n                }\\n                \\n                if(curr.right!=null){\\n                    siblingSum += curr.right.val;\\n                    totalSumAtSameHeight += curr.right.val;\\n\\n                }\\n                \\n                if(p.getKey().left!=null){\\n                    q.offer(new Pair(curr.left, siblingSum));\\n                }\\n                \\n                if(p.getKey().right!=null){\\n                    q.offer(new Pair(curr.right, siblingSum));\\n                }\\n                \\n                curr.val = prev - p.getValue();\\n            }\\n            \\n        }\\n        \\n        \\n        return root;\\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425996,
                "title": "100-beats-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        Pair(TreeNode node, TreeNode parent){\\n            this.node = node;\\n            this.parent = parent;\\n        }\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> que = new LinkedList<>();\\n        que.add(new Pair(root,null));\\n        while(que.size() > 0){\\n            int sz = que.size();\\n            HashMap<TreeNode, Integer> map = new HashMap<>();\\n            ArrayList<Pair> kids = new ArrayList<>();\\n            int totalsum = 0;\\n            while(sz-- > 0){\\n                Pair rem = que.remove();\\n                totalsum += rem.node.val;\\n                kids.add(rem);\\n                if(map.containsKey(rem.parent) == false){\\n                    map.put(rem.parent,rem.node.val);\\n                }else{\\n                    map.put(rem.parent, map.get(rem.parent) + rem.node.val);\\n                }\\n                if(rem.node.left != null){\\n                    que.add(new Pair(rem.node.left,rem.node));\\n                }\\n                if(rem.node.right != null){\\n                    que.add(new Pair(rem.node.right,rem.node));\\n                }\\n            }\\n            for(Pair kid: kids){\\n                kid.node.val = totalsum - map.get(kid.parent);\\n            }            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        Pair(TreeNode node, TreeNode parent){\\n            this.node = node;\\n            this.parent = parent;\\n        }\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> que = new LinkedList<>();\\n        que.add(new Pair(root,null));\\n        while(que.size() > 0){\\n            int sz = que.size();\\n            HashMap<TreeNode, Integer> map = new HashMap<>();\\n            ArrayList<Pair> kids = new ArrayList<>();\\n            int totalsum = 0;\\n            while(sz-- > 0){\\n                Pair rem = que.remove();\\n                totalsum += rem.node.val;\\n                kids.add(rem);\\n                if(map.containsKey(rem.parent) == false){\\n                    map.put(rem.parent,rem.node.val);\\n                }else{\\n                    map.put(rem.parent, map.get(rem.parent) + rem.node.val);\\n                }\\n                if(rem.node.left != null){\\n                    que.add(new Pair(rem.node.left,rem.node));\\n                }\\n                if(rem.node.right != null){\\n                    que.add(new Pair(rem.node.right,rem.node));\\n                }\\n            }\\n            for(Pair kid: kids){\\n                kid.node.val = totalsum - map.get(kid.parent);\\n            }            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425973,
                "title": "parent-tracking-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n{\\n    unordered_map<TreeNode*,TreeNode*>mp;\\n\\tfillmap(root,mp);         \\n\\t\\n\\tint level=0;\\n    unordered_map<int,int>level_sum;\\n    dfs(root,level_sum,level);\\n    \\n    //now preforming the bfs stuff\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    level = 0;\\n    \\n    unordered_map<int,vector<int>>result;  //temporory map to store the result\\n    while(!q.empty())\\n    {\\n    \\tint size = q.size();\\n    \\tfor(int i=0;i<size;i++)\\n    \\t{\\n    \\t\\tTreeNode* temp = q.front();\\n    \\t\\tq.pop();\\n    \\t\\t\\n    \\t\\tif(temp == root)\\n    \\t\\t{\\n    \\t\\t\\tresult[level].push_back(0);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelsum  = level_sum[level];\\n\\t\\t\\t\\tTreeNode* par = mp[temp];\\n                //7 9\\n                //10 4\\n                //1 4\\n                //9 5\\n                //4 5\\n                if(par->left != NULL)\\n                levelsum = levelsum - (par->left->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(par->right != NULL)\\n\\t\\t\\t\\tlevelsum = levelsum - (par->right->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tresult[level].push_back(levelsum); \\n\\t\\t\\t}\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n    }\\n\\t\\n\\t//making the queue empty\\n\\twhile(!q.empty())\\n\\tq.pop();\\n\\t\\n    //again doing the bsf to fill the valus in the tree\\n\\tq.push(root);\\n\\tlevel = 0;\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tint idx = 0;\\n\\t\\tint size = q.size();\\n\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t{\\n\\t\\t\\tTreeNode* temp = q.front();\\n\\t\\t\\ttemp->val = result[level][idx];\\n\\t\\t\\tidx++;\\n\\t\\t\\tq.pop();\\n\\t\\t\\t\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n\\t}\\n\\treturn root;\\n}\\nvoid dfs(TreeNode* root,unordered_map<int,int>&level_sum,int level)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\tlevel_sum[level]+=root->val;\\n\\tdfs(root->left,level_sum,level+1);\\n\\tdfs(root->right,level_sum,level+1);\\n}\\nvoid fillmap(TreeNode* root,unordered_map<TreeNode*,TreeNode*>&mp)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t//if the left child exist\\n\\tif(root->left != NULL)\\n\\t{\\n\\t\\tmp[root->left] = root;\\n\\t}\\n\\t//if the right child exist\\n\\tif(root->right != NULL)\\n\\t{\\n\\t\\tmp[root->right] = root;\\n\\t}\\n\\tfillmap(root->left,mp);\\n\\tfillmap(root->right,mp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n{\\n    unordered_map<TreeNode*,TreeNode*>mp;\\n\\tfillmap(root,mp);         \\n\\t\\n\\tint level=0;\\n    unordered_map<int,int>level_sum;\\n    dfs(root,level_sum,level);\\n    \\n    //now preforming the bfs stuff\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    level = 0;\\n    \\n    unordered_map<int,vector<int>>result;  //temporory map to store the result\\n    while(!q.empty())\\n    {\\n    \\tint size = q.size();\\n    \\tfor(int i=0;i<size;i++)\\n    \\t{\\n    \\t\\tTreeNode* temp = q.front();\\n    \\t\\tq.pop();\\n    \\t\\t\\n    \\t\\tif(temp == root)\\n    \\t\\t{\\n    \\t\\t\\tresult[level].push_back(0);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelsum  = level_sum[level];\\n\\t\\t\\t\\tTreeNode* par = mp[temp];\\n                //7 9\\n                //10 4\\n                //1 4\\n                //9 5\\n                //4 5\\n                if(par->left != NULL)\\n                levelsum = levelsum - (par->left->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(par->right != NULL)\\n\\t\\t\\t\\tlevelsum = levelsum - (par->right->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tresult[level].push_back(levelsum); \\n\\t\\t\\t}\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n    }\\n\\t\\n\\t//making the queue empty\\n\\twhile(!q.empty())\\n\\tq.pop();\\n\\t\\n    //again doing the bsf to fill the valus in the tree\\n\\tq.push(root);\\n\\tlevel = 0;\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tint idx = 0;\\n\\t\\tint size = q.size();\\n\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t{\\n\\t\\t\\tTreeNode* temp = q.front();\\n\\t\\t\\ttemp->val = result[level][idx];\\n\\t\\t\\tidx++;\\n\\t\\t\\tq.pop();\\n\\t\\t\\t\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n\\t}\\n\\treturn root;\\n}\\nvoid dfs(TreeNode* root,unordered_map<int,int>&level_sum,int level)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\tlevel_sum[level]+=root->val;\\n\\tdfs(root->left,level_sum,level+1);\\n\\tdfs(root->right,level_sum,level+1);\\n}\\nvoid fillmap(TreeNode* root,unordered_map<TreeNode*,TreeNode*>&mp)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t//if the left child exist\\n\\tif(root->left != NULL)\\n\\t{\\n\\t\\tmp[root->left] = root;\\n\\t}\\n\\t//if the right child exist\\n\\tif(root->right != NULL)\\n\\t{\\n\\t\\tmp[root->right] = root;\\n\\t}\\n\\tfillmap(root->left,mp);\\n\\tfillmap(root->right,mp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424785,
                "title": "c-single-bfs-faster-92",
                "content": "**Intiution**\\n- To store metadata for each node in a data structure, we incorporate a wrapper node that holds the sum of the values of two siblings.\\n- This strategy is crucial in allowing us to perform subtraction of the `sum of values of two siblings` from the `total value sum` at every level.\\n- Then we sinply run `BFS` fro level order traversal.\\n\\n**Code**\\n```c++\\nstruct NodeWrapper {\\n    TreeNode* inner = NULL;\\n    int sibling_val_sum = 0;\\n    NodeWrapper(TreeNode* inner, int sibling_val_sum): inner(inner), sibling_val_sum(sibling_val_sum) {}\\n};\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<NodeWrapper*> q{ new NodeWrapper(root, root->val) };\\n        \\n        while (q.size()) {\\n            int sum = 0;\\n            for (auto w: q) sum += w->inner->val;\\n            \\n            vector<NodeWrapper*> t;\\n            for (auto w: q) {\\n                auto n = w->inner; int total = w->sibling_val_sum;\\n                n->val = sum - total;\\n                \\n                auto sum = (n->left ? n->left->val: 0) + (n->right ? n->right->val: 0);\\n                \\n                if (n->left) t.push_back(new NodeWrapper(n->left, sum));\\n                if (n->right) t.push_back(new NodeWrapper(n->right, sum));\\n            }\\n            q = t;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nstruct NodeWrapper {\\n    TreeNode* inner = NULL;\\n    int sibling_val_sum = 0;\\n    NodeWrapper(TreeNode* inner, int sibling_val_sum): inner(inner), sibling_val_sum(sibling_val_sum) {}\\n};\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<NodeWrapper*> q{ new NodeWrapper(root, root->val) };\\n        \\n        while (q.size()) {\\n            int sum = 0;\\n            for (auto w: q) sum += w->inner->val;\\n            \\n            vector<NodeWrapper*> t;\\n            for (auto w: q) {\\n                auto n = w->inner; int total = w->sibling_val_sum;\\n                n->val = sum - total;\\n                \\n                auto sum = (n->left ? n->left->val: 0) + (n->right ? n->right->val: 0);\\n                \\n                if (n->left) t.push_back(new NodeWrapper(n->left, sum));\\n                if (n->right) t.push_back(new NodeWrapper(n->right, sum));\\n            }\\n            q = t;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424011,
                "title": "c-code-for-this-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsolve this problem by storing the parent of each node and \\nvalue corresponding to each node\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode *root,map<TreeNode*,TreeNode*> &mp){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root->left)mp[root->left] = root;\\n        if(root->right)mp[root->right] = root;\\n        \\n        solve(root->left,mp);\\n        solve(root->right,mp);\\n    }\\n    void accvalue(TreeNode *root,unordered_map<TreeNode*,int> &mp){\\n        if(root == NULL)return;\\n        mp[root] = root->val;\\n        accvalue(root->left,mp);\\n        accvalue(root->right,mp);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        if(root == NULL)return NULL;\\n        map<TreeNode*,TreeNode*> mp;\\n        solve(root,mp);\\n        mp[root] = NULL;\\n        unordered_map<TreeNode*,int> m;\\n        accvalue(root,m);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<int> ans;\\n        while(q.empty() == false){\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode = q.front();\\n                q.pop();\\n                sum+=currnode->val;\\n                if(currnode->left)q.push(currnode->left);\\n                if(currnode->right)q.push(currnode->right);\\n            }\\n            ans.push_back(sum);\\n        }\\n        \\n        queue<TreeNode*> pq;\\n        pq.push(root);\\n        int ptr = 0;\\n        while(pq.empty() == false){\\n            int n = pq.size();\\n            int levelsum = ans[ptr++];\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode= pq.front();\\n                pq.pop();\\n                TreeNode *par = mp[currnode];\\n                if(par == NULL){\\n                    currnode->val = 0;\\n                }\\n                else if(par->left == currnode){\\n                   // if(par->right)cout<<m[par->right]<<endl;\\n                    if(par->right)currnode->val = levelsum - currnode->val - m[par->right];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                else if(par->right == currnode){\\n                    if(par->left)cout<<m[par->left]<<endl;\\n                    if(par->left)currnode->val = levelsum - currnode->val - m[par->left];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                if(currnode->left)pq.push(currnode->left);\\n                if(currnode->right)pq.push(currnode->right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode *root,map<TreeNode*,TreeNode*> &mp){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root->left)mp[root->left] = root;\\n        if(root->right)mp[root->right] = root;\\n        \\n        solve(root->left,mp);\\n        solve(root->right,mp);\\n    }\\n    void accvalue(TreeNode *root,unordered_map<TreeNode*,int> &mp){\\n        if(root == NULL)return;\\n        mp[root] = root->val;\\n        accvalue(root->left,mp);\\n        accvalue(root->right,mp);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        if(root == NULL)return NULL;\\n        map<TreeNode*,TreeNode*> mp;\\n        solve(root,mp);\\n        mp[root] = NULL;\\n        unordered_map<TreeNode*,int> m;\\n        accvalue(root,m);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<int> ans;\\n        while(q.empty() == false){\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode = q.front();\\n                q.pop();\\n                sum+=currnode->val;\\n                if(currnode->left)q.push(currnode->left);\\n                if(currnode->right)q.push(currnode->right);\\n            }\\n            ans.push_back(sum);\\n        }\\n        \\n        queue<TreeNode*> pq;\\n        pq.push(root);\\n        int ptr = 0;\\n        while(pq.empty() == false){\\n            int n = pq.size();\\n            int levelsum = ans[ptr++];\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode= pq.front();\\n                pq.pop();\\n                TreeNode *par = mp[currnode];\\n                if(par == NULL){\\n                    currnode->val = 0;\\n                }\\n                else if(par->left == currnode){\\n                   // if(par->right)cout<<m[par->right]<<endl;\\n                    if(par->right)currnode->val = levelsum - currnode->val - m[par->right];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                else if(par->right == currnode){\\n                    if(par->left)cout<<m[par->left]<<endl;\\n                    if(par->left)currnode->val = levelsum - currnode->val - m[par->left];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                if(currnode->left)pq.push(currnode->left);\\n                if(currnode->right)pq.push(currnode->right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3423874,
                "title": "bfs-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        while(q.size()) {\\n            int n = q.size(), levelSum = 0;\\n            vector<pair<TreeNode*, int>> v;\\n            \\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = q.front().first;\\n                int value = q.front().second; q.pop();\\n                v.push_back({temp, value});\\n\\n                if(temp -> left) levelSum += temp -> left -> val;\\n                if(temp -> right)  levelSum += temp -> right -> val;\\n            }\\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = v[i].first;\\n                int value = v[i].second;\\n                \\n                if(temp -> left) {\\n                    q.push({temp -> left, levelSum - temp -> left -> val - (temp -> right ? temp -> right -> val : 0)});\\n                }\\n                if(temp -> right) {\\n                    q.push({temp -> right, levelSum - temp -> right -> val - (temp -> left ? temp -> left -> val : 0)});\\n                }\\n                temp -> val = value;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        while(q.size()) {\\n            int n = q.size(), levelSum = 0;\\n            vector<pair<TreeNode*, int>> v;\\n            \\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = q.front().first;\\n                int value = q.front().second; q.pop();\\n                v.push_back({temp, value});\\n\\n                if(temp -> left) levelSum += temp -> left -> val;\\n                if(temp -> right)  levelSum += temp -> right -> val;\\n            }\\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = v[i].first;\\n                int value = v[i].second;\\n                \\n                if(temp -> left) {\\n                    q.push({temp -> left, levelSum - temp -> left -> val - (temp -> right ? temp -> right -> val : 0)});\\n                }\\n                if(temp -> right) {\\n                    q.push({temp -> right, levelSum - temp -> right -> val - (temp -> left ? temp -> left -> val : 0)});\\n                }\\n                temp -> val = value;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423709,
                "title": "java-beats-100-bfs",
                "content": "My idea was simple. \\n\\nTraverse every node in Tree with BFS. In every level traverse twice.\\nHashMap map is used to find the parent\\'s value\\nHashMap nodes is used to find the parent node of the node\\n\\n- First is to find the total of the all values.\\n- Second is to find the value of the node ( total - parent\\'s value). And the node is added to`nodes` map as parent with its children if they exist. And the total of left and right children are added to `map` \\n\\nRoot.val is never changed. So,` root.val=0` then we can return root safely. \\n```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        HashMap<TreeNode, Integer> map = new HashMap<>();\\n        HashMap<TreeNode, TreeNode> nodes = new HashMap<>();    \\n        q.add(root);\\n        \\n        while(!q.isEmpty()){\\n            int size= q.size();\\n            int total= 0;\\n            for(TreeNode t: q) total+= t.val;\\n            for(int i=0; i<size; i++){\\n                TreeNode curr = q.poll();        \\n                if(curr != root){  // to avoid null pointer exception\\n                    TreeNode parent = nodes.get(curr);\\n                    curr.val = total - map.get(parent);\\n                }\\n                int left = 0;\\n                int right= 0;\\n                if(curr.left != null){ \\n                    left = curr.left.val;\\n                    q.add(curr.left);\\n                    nodes.put(curr.left, curr);\\n                }\\n                if(curr.right != null){\\n                    right = curr.right.val;\\n                    q.add(curr.right);\\n                    nodes.put(curr.right, curr);\\n                }\\n                map.put(curr, left+right);\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```\\nIf the data is correct, it is pretty efficient. \\n![image](https://assets.leetcode.com/users/images/249c1a0f-d481-419e-8129-c1b2fd29f415_1681652315.6029444.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        HashMap<TreeNode, Integer> map = new HashMap<>();\\n        HashMap<TreeNode, TreeNode> nodes = new HashMap<>();    \\n        q.add(root);\\n        \\n        while(!q.isEmpty()){\\n            int size= q.size();\\n            int total= 0;\\n            for(TreeNode t: q) total+= t.val;\\n            for(int i=0; i<size; i++){\\n                TreeNode curr = q.poll();        \\n                if(curr != root){  // to avoid null pointer exception\\n                    TreeNode parent = nodes.get(curr);\\n                    curr.val = total - map.get(parent);\\n                }\\n                int left = 0;\\n                int right= 0;\\n                if(curr.left != null){ \\n                    left = curr.left.val;\\n                    q.add(curr.left);\\n                    nodes.put(curr.left, curr);\\n                }\\n                if(curr.right != null){\\n                    right = curr.right.val;\\n                    q.add(curr.right);\\n                    nodes.put(curr.right, curr);\\n                }\\n                map.put(curr, left+right);\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423095,
                "title": "easy-to-understand-c-solution-binary-tree-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int height(TreeNode* root)\\n    {\\n        if(root==nullptr)return 0;\\n        int l = height(root->left);\\n        int r = height(root->right);\\n        return max(l,r)+1;\\n    }\\n    void f(TreeNode* root,int x)\\n    {\\n        if(root==nullptr)return ;\\n        ans[x]+= root->val;\\n        f(root->left,x+1);\\n        f(root->right,x+1);\\n    }\\n    \\n    TreeNode* dfs(TreeNode* par,TreeNode* root,int x)\\n    {\\n        if(root==NULL)return NULL;\\n        TreeNode* node;\\n        if(x==1 || x==2)\\n        {\\n            node = new TreeNode(0);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n        }\\n        else\\n        {\\n            int sum = ans[x];\\n               if(par->left) sum-=par->left->val;\\n            if(par->right) sum-=par->right->val;\\n            node = new TreeNode(sum);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n\\n        }\\n        return node;\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==nullptr)return nullptr;\\n        ans.resize(height(root)+1,0);\\n        f(root,1);\\n        return dfs(nullptr,root,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int height(TreeNode* root)\\n    {\\n        if(root==nullptr)return 0;\\n        int l = height(root->left);\\n        int r = height(root->right);\\n        return max(l,r)+1;\\n    }\\n    void f(TreeNode* root,int x)\\n    {\\n        if(root==nullptr)return ;\\n        ans[x]+= root->val;\\n        f(root->left,x+1);\\n        f(root->right,x+1);\\n    }\\n    \\n    TreeNode* dfs(TreeNode* par,TreeNode* root,int x)\\n    {\\n        if(root==NULL)return NULL;\\n        TreeNode* node;\\n        if(x==1 || x==2)\\n        {\\n            node = new TreeNode(0);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n        }\\n        else\\n        {\\n            int sum = ans[x];\\n               if(par->left) sum-=par->left->val;\\n            if(par->right) sum-=par->right->val;\\n            node = new TreeNode(sum);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n\\n        }\\n        return node;\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==nullptr)return nullptr;\\n        ans.resize(height(root)+1,0);\\n        f(root,1);\\n        return dfs(nullptr,root,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422551,
                "title": "2-dfs-c-readable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, int>m;// To store sum of all Node val at each level\\n    void dfs(TreeNode *root,int k)\\n    {\\n        if(!root) return ;\\n        m[k]=m[k]+root->val;\\n        dfs(root->left,k+1);\\n        dfs(root->right,k+1);\\n\\n    }\\n    void Dfs(TreeNode *root,int k)\\n    {\\n         if(!root) return ;\\n         Dfs(root->left,k+1);\\n         Dfs(root->right,k+1);\\n         if(root->left && root->right)\\n         {\\n        \\n          root->left->val=m[k+1]-(root->left->val+root->right->val);\\n          root->right->val=root->left->val;\\n         }\\n         else if(root->left)\\n         {\\n             root->left->val=m[k+1]-(root->left->val);\\n         }\\n          else if(root->right)\\n         {\\n             root->right->val=m[k+1]-(root->right->val);\\n         }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n          dfs(root,0);//update our map that will store sum at every level\\n          Dfs(root,0);// update node val\\n          root->val=0;// updating root to 0\\n          return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, int>m;// To store sum of all Node val at each level\\n    void dfs(TreeNode *root,int k)\\n    {\\n        if(!root) return ;\\n        m[k]=m[k]+root->val;\\n        dfs(root->left,k+1);\\n        dfs(root->right,k+1);\\n\\n    }\\n    void Dfs(TreeNode *root,int k)\\n    {\\n         if(!root) return ;\\n         Dfs(root->left,k+1);\\n         Dfs(root->right,k+1);\\n         if(root->left && root->right)\\n         {\\n        \\n          root->left->val=m[k+1]-(root->left->val+root->right->val);\\n          root->right->val=root->left->val;\\n         }\\n         else if(root->left)\\n         {\\n             root->left->val=m[k+1]-(root->left->val);\\n         }\\n          else if(root->right)\\n         {\\n             root->right->val=m[k+1]-(root->right->val);\\n         }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n          dfs(root,0);//update our map that will store sum at every level\\n          Dfs(root,0);// update node val\\n          root->val=0;// updating root to 0\\n          return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422255,
                "title": "dfs-with-diagram-o-n",
                "content": "\\n![BinaryTree_Cousins.jpg](https://assets.leetcode.com/users/images/88b12fae-0e7a-4d94-b9a1-cd0675a938db_1681622795.4665618.jpeg)\\n# Complexity-Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIf you have any suggestion to improve it then please tell. \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n        public TreeNode replaceValueInTree(TreeNode root) {\\n            root.val=0;\\n            Queue<TreeNode>que=new LinkedList<>();\\n            que.add(root);\\n            while(!que.isEmpty()){\\n                int size=que.size();\\n                LinkedList<TreeNode>parentnode=new LinkedList<>(que);\\n                int sum=0;\\n                while(size>0){\\n                    TreeNode tr=que.remove();\\n                    if(tr.left!=null){sum+=tr.left.val;que.add(tr.left);}\\n                    if(tr.right!=null){sum+=tr.right.val;que.add(tr.right);}\\n                    size--;\\n                }\\n                for(TreeNode n:parentnode){int tempsum=sum;\\n                    if(n.left!=null){tempsum-=n.left.val;}\\n                    if(n.right!=null){tempsum-=n.right.val;}\\n                    if(n.left!=null) n.left.val=tempsum;\\n                   if(n.right!=null) n.right.val=tempsum;\\n                }\\n            }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n        public TreeNode replaceValueInTree(TreeNode root) {\\n            root.val=0;\\n            Queue<TreeNode>que=new LinkedList<>();\\n            que.add(root);\\n            while(!que.isEmpty()){\\n                int size=que.size();\\n                LinkedList<TreeNode>parentnode=new LinkedList<>(que);\\n                int sum=0;\\n                while(size>0){\\n                    TreeNode tr=que.remove();\\n                    if(tr.left!=null){sum+=tr.left.val;que.add(tr.left);}\\n                    if(tr.right!=null){sum+=tr.right.val;que.add(tr.right);}\\n                    size--;\\n                }\\n                for(TreeNode n:parentnode){int tempsum=sum;\\n                    if(n.left!=null){tempsum-=n.left.val;}\\n                    if(n.right!=null){tempsum-=n.right.val;}\\n                    if(n.left!=null) n.left.val=tempsum;\\n                   if(n.right!=null) n.right.val=tempsum;\\n                }\\n            }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421399,
                "title": "i-kotlin-bfs-with-illustrated-explanation",
                "content": "# Intuition\\nThe first approach that may come to one\\u2019s mind is pretty straightforward: calculate the sum of all cousines and then replace each cousin\\'s value with the difference if this sum and a sum of thise node siblings values.\\n\\n# Approach\\nLet\\u2019s take a look at a tree. \\n\\n![A Tree](https://assets.leetcode.com/users/images/bd390a75-a75f-40c5-b21b-55e13b252653_1681603051.9156284.png)\\n\\n\\nTraversing the tree level by level we can calculate a sum of all values at each level. This sum is the sum of all cousines. The next step would be assigning the sum minus values of all node siblings.\\n\\n![](https://assets.leetcode.com/users/images/491435a6-6e97-4fa9-8efd-4d39f6aed356_1681603084.5572708.png)\\n\\n\\nUnfortunately, this approach won\\'t work, because we don\\'t possess the information about siblings. As one of possible options we can operate with nodes children, instead of nodes itself.\\n\\n**Step 1.** Sum all children values and put it to sum\\n\\n![](https://assets.leetcode.com/users/images/95f66493-bab0-459c-89af-47b0c755ecae_1681603075.0084324.png)\\n\\n\\n**Step 2.** For each node, calculate the value of sum - value of the left child if it exists - value of the right child, if it exists.\\n**Step 3.** Assign the values to all node children\\n\\n![](https://assets.leetcode.com/users/images/7d08671a-5659-43d9-a70c-3da594946a86_1681603170.5213504.png)\\n\\n\\n**Step 4.** Repeat all previous steps for the children.\\n\\n\\n# Complexity\\n- Time complexity: $O(nlog(n))$\\n\\n- Space complexity: $O(log(n))$\\n\\n# Code\\n```\\nclass Solution {\\n    fun replaceValueInTree(root: TreeNode): TreeNode {\\n        \\n        fun TreeNode.sumOfChildrenValues() = \\n            (left?.`val` ?: 0) + (right?.`val` ?: 0)\\n\\n        var nodes = mutableListOf(root.apply { `val` = 0 })\\n        while (nodes.isNotEmpty()) {\\n            val sumOfAllCousins = nodes\\n                .map(TreeNode::sumOfChildrenValues).sum()\\n            \\n            nodes = mutableListOf<TreeNode>().apply {\\n                for (node in nodes) {\\n                    val sumOfOtherCousines = \\n                        sumOfAllCousins - node.sumOfChildrenValues()\\n                    node.left?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                    node.right?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                }\\n            }\\n        }\\n\\n        return root\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    fun replaceValueInTree(root: TreeNode): TreeNode {\\n        \\n        fun TreeNode.sumOfChildrenValues() = \\n            (left?.`val` ?: 0) + (right?.`val` ?: 0)\\n\\n        var nodes = mutableListOf(root.apply { `val` = 0 })\\n        while (nodes.isNotEmpty()) {\\n            val sumOfAllCousins = nodes\\n                .map(TreeNode::sumOfChildrenValues).sum()\\n            \\n            nodes = mutableListOf<TreeNode>().apply {\\n                for (node in nodes) {\\n                    val sumOfOtherCousines = \\n                        sumOfAllCousins - node.sumOfChildrenValues()\\n                    node.left?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                    node.right?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                }\\n            }\\n        }\\n\\n        return root\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420939,
                "title": "pretty-hard-to-understand-but-works-flawless-not-a-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == nullptr) return root;\\n        \\n        root->val = 0;\\n        \\n        if(!root->left && !root->right) return root;\\n    \\n        if(root->left) {\\n            root->left->val = 0;    \\n        }\\n        \\n        if(root->right) {\\n            root->right->val = 0; \\n        }\\n        \\n        vector<vector<pair<int,int>>> values;\\n        \\n        TreeNode* root_node = root;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root_node);\\n        \\n        while(!q.empty()) {\\n            int n = q.size();\\n            vector<pair<int,int>> vec;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                pair<int,int> vals = {0, 0};\\n\\n                if(node->left) {\\n                    vals.first = node->left->val;\\n                    q.push(node->left);\\n                }\\n\\n                if(node->right) {\\n                    vals.second = node->right->val;\\n                    q.push(node->right);\\n                }\\n                \\n                vec.push_back(vals);\\n            }\\n            \\n            values.push_back(vec);\\n        }\\n                \\n        root_node = root;\\n        \\n        if(root_node->left) {\\n            q.push(root_node->left);        \\n        }\\n        \\n        if(root_node->right) {\\n            q.push(root_node->right);        \\n        }\\n        \\n        int index = 1;\\n        int m = values.size();\\n        \\n        while(!q.empty() && index < m) {\\n            int n = q.size();\\n            \\n            int sum = 0;\\n            \\n            for(pair<int,int>& p : values[index]) {\\n                sum += p.first + p.second;\\n            }\\n            \\n            index++;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left && node->right) {\\n                    int val = sum - (node->left->val + node->right->val);\\n                    \\n                    node->left->val = val;\\n                    node->right->val = val;\\n                                        \\n                    q.push(node->left);\\n                    q.push(node->right);\\n                } else if(node->left) {\\n                    int val = sum - node->left->val;\\n                    \\n                    node->left->val = val;\\n                    \\n                    q.push(node->left);\\n                } else if(node->right) {\\n                    int val = sum - node->right->val;\\n                    \\n                    node->right->val = val;\\n                    \\n                    q.push(node->right);\\n                }\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == nullptr) return root;\\n        \\n        root->val = 0;\\n        \\n        if(!root->left && !root->right) return root;\\n    \\n        if(root->left) {\\n            root->left->val = 0;    \\n        }\\n        \\n        if(root->right) {\\n            root->right->val = 0; \\n        }\\n        \\n        vector<vector<pair<int,int>>> values;\\n        \\n        TreeNode* root_node = root;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root_node);\\n        \\n        while(!q.empty()) {\\n            int n = q.size();\\n            vector<pair<int,int>> vec;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                pair<int,int> vals = {0, 0};\\n\\n                if(node->left) {\\n                    vals.first = node->left->val;\\n                    q.push(node->left);\\n                }\\n\\n                if(node->right) {\\n                    vals.second = node->right->val;\\n                    q.push(node->right);\\n                }\\n                \\n                vec.push_back(vals);\\n            }\\n            \\n            values.push_back(vec);\\n        }\\n                \\n        root_node = root;\\n        \\n        if(root_node->left) {\\n            q.push(root_node->left);        \\n        }\\n        \\n        if(root_node->right) {\\n            q.push(root_node->right);        \\n        }\\n        \\n        int index = 1;\\n        int m = values.size();\\n        \\n        while(!q.empty() && index < m) {\\n            int n = q.size();\\n            \\n            int sum = 0;\\n            \\n            for(pair<int,int>& p : values[index]) {\\n                sum += p.first + p.second;\\n            }\\n            \\n            index++;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left && node->right) {\\n                    int val = sum - (node->left->val + node->right->val);\\n                    \\n                    node->left->val = val;\\n                    node->right->val = val;\\n                                        \\n                    q.push(node->left);\\n                    q.push(node->right);\\n                } else if(node->left) {\\n                    int val = sum - node->left->val;\\n                    \\n                    node->left->val = val;\\n                    \\n                    q.push(node->left);\\n                } else if(node->right) {\\n                    int val = sum - node->right->val;\\n                    \\n                    node->right->val = val;\\n                    \\n                    q.push(node->right);\\n                }\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420930,
                "title": "100-fast-easiest-java-solution-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q.offer(root);\\n        q2.offer(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int s = 0;\\n            System.out.println(size);\\n            while(size-- > 0) {\\n                TreeNode p = q.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q.offer(p.right);\\n                }\\n                s += sum;\\n            }\\n            size = q2.size();\\n            while(size-- > 0) {\\n                TreeNode p = q2.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q2.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q2.offer(p.right);\\n                }\\n                if(p.left != null) {\\n                    p.left.val = s - sum;\\n                }\\n                if(p.right != null) {\\n                    p.right.val = s - sum;\\n                }\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q.offer(root);\\n        q2.offer(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int s = 0;\\n            System.out.println(size);\\n            while(size-- > 0) {\\n                TreeNode p = q.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q.offer(p.right);\\n                }\\n                s += sum;\\n            }\\n            size = q2.size();\\n            while(size-- > 0) {\\n                TreeNode p = q2.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q2.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q2.offer(p.right);\\n                }\\n                if(p.left != null) {\\n                    p.left.val = s - sum;\\n                }\\n                if(p.right != null) {\\n                    p.right.val = s - sum;\\n                }\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420892,
                "title": "simple-bfs-codes-gives-explanation-tracking-previous-value",
                "content": "# Intuition\\n***Summing up All the TreeNode values within a particular level and\\nSubstracting the value of particular node and sibling node value.***\\n# Approach\\n***Simple BFS to track the child along with parent\\nComputed sum of all the nodes of the previous level used in the particular level for summing up other than sibling nodes.***\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# please upvote if it helped\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> qu;\\n        \\n        qu.push(root);\\n        int prev_sum=root->val;\\n        root->val=-root->val;\\n\\n        while(!qu.empty())\\n        {\\n            queue<TreeNode*> qu2;\\n            int sum_=0;\\n            int size = qu.size();\\n            for(int i=0;i<size;i++)\\n            {    \\n                TreeNode *cur= qu.front();\\n                int a=0,b=0;\\n                if(cur->left)\\n                {\\n                    qu.push(cur->left);  \\n                    if(cur->right)\\n                    {\\n                       a=cur->right->val;           \\n                    }       \\n                }\\n                if(cur->right)\\n                {\\n                    qu.push(cur->right);\\n                    if(cur->left)\\n                    {\\n                        b=cur->left->val;\\n                    }\\n                }\\n                if(cur->right)\\n                {\\n                    sum_+=cur->right->val;\\n                    cur->right->val+=b;\\n                    cur->right->val=-cur->right->val;\\n                }\\n                if(cur->left)\\n                {\\n                    sum_+=cur->left->val;\\n                    cur->left->val+=a;\\n                    cur->left->val=-cur->left->val;\\n                }\\n\\n                qu2.push(qu.front());\\n                qu.pop();\\n            }\\n            while(!qu2.empty())\\n            {\\n                TreeNode *cur=qu2.front();\\n                qu2.pop();\\n                cur->val+=prev_sum;\\n            } \\n            prev_sum=sum_; \\n        }\\n\\n        return root;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> qu;\\n        \\n        qu.push(root);\\n        int prev_sum=root->val;\\n        root->val=-root->val;\\n\\n        while(!qu.empty())\\n        {\\n            queue<TreeNode*> qu2;\\n            int sum_=0;\\n            int size = qu.size();\\n            for(int i=0;i<size;i++)\\n            {    \\n                TreeNode *cur= qu.front();\\n                int a=0,b=0;\\n                if(cur->left)\\n                {\\n                    qu.push(cur->left);  \\n                    if(cur->right)\\n                    {\\n                       a=cur->right->val;           \\n                    }       \\n                }\\n                if(cur->right)\\n                {\\n                    qu.push(cur->right);\\n                    if(cur->left)\\n                    {\\n                        b=cur->left->val;\\n                    }\\n                }\\n                if(cur->right)\\n                {\\n                    sum_+=cur->right->val;\\n                    cur->right->val+=b;\\n                    cur->right->val=-cur->right->val;\\n                }\\n                if(cur->left)\\n                {\\n                    sum_+=cur->left->val;\\n                    cur->left->val+=a;\\n                    cur->left->val=-cur->left->val;\\n                }\\n\\n                qu2.push(qu.front());\\n                qu.pop();\\n            }\\n            while(!qu2.empty())\\n            {\\n                TreeNode *cur=qu2.front();\\n                qu2.pop();\\n                cur->val+=prev_sum;\\n            } \\n            prev_sum=sum_; \\n        }\\n\\n        return root;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420849,
                "title": "python-two-dfs",
                "content": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        def dfs(node, p, d):\\n            if not node:\\n                return\\n\\n            vals[d] += node.val\\n            pars[d][hash(p)] += node.val\\n            dfs(node.left, node, d + 1)\\n            dfs(node.right, node, d + 1)\\n\\n        vals = defaultdict(int)\\n        pars = defaultdict(lambda: defaultdict(int))\\n        dfs(root, 0, 0)\\n\\n        def modify(node, p, d):\\n            if not node:\\n                return\\n\\n            s = vals[d] - pars[d][p]\\n            orig = hash(node)\\n            node.val = s\\n\\n            modify(node.left, orig, d + 1)\\n            modify(node.right, orig, d + 1)\\n\\n        modify(root, 0, 0)\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        def dfs(node, p, d):\\n            if not node:\\n                return\\n\\n            vals[d] += node.val\\n            pars[d][hash(p)] += node.val\\n            dfs(node.left, node, d + 1)\\n            dfs(node.right, node, d + 1)\\n\\n        vals = defaultdict(int)\\n        pars = defaultdict(lambda: defaultdict(int))\\n        dfs(root, 0, 0)\\n\\n        def modify(node, p, d):\\n            if not node:\\n                return\\n\\n            s = vals[d] - pars[d][p]\\n            orig = hash(node)\\n            node.val = s\\n\\n            modify(node.left, orig, d + 1)\\n            modify(node.right, orig, d + 1)\\n\\n        modify(root, 0, 0)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420656,
                "title": "golang-simple-bfs",
                "content": "# Approach\\n```\\n           5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\\n\\n```\\n                        parents=[]\\n\\n          5-5           children=[5], sum=5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\\n\\n```    \\n           0            parents=[x]\\n         /   \\\\\\n    sum-4-9  sum-4-9    children=[4, 9], sum=13\\n     /   \\\\       \\\\\\n   1       10      7\\n```\\n\\n```   \\n           0           \\n         /   \\\\\\n       0       0        parents=[x, x]\\n     /   \\\\       \\\\\\nsum-1-10 sum-1-10 sum-7 children=[1, 10, 7], sum=18\\n```\\n\\n```     \\n           0           \\n         /   \\\\\\n       0       0        \\n     /   \\\\       \\\\\\n   7       7      11    parents=[x, x, x]\\n\\n                        children=[]\\n```\\n\\n# Code\\n```\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n    children := []*TreeNode{root}\\n    root.Val = 0\\n\\n    // Each iteration children list contains all elements with the same depth\\n    for len(children) > 0 {\\n        parents := children\\n        children = []*TreeNode{}\\n\\n        // Find sum of all children in this depth\\n        sum := 0\\n        for _, parent := range parents {\\n            if parent.Left != nil { sum += parent.Left.Val }\\n            if parent.Right != nil { sum += parent.Right.Val } \\n        }\\n\\n        // Update children values:\\n        // Calculated sum minus the current childer values (if they exist)\\n        // Also add all children to the list for the next iteration (depth+1)\\n        for _, parent := range parents {\\n            reduce := 0\\n            if parent.Left != nil { reduce += parent.Left.Val }\\n            if parent.Right != nil { reduce += parent.Right.Val }\\n            \\n            if parent.Left != nil {\\n                parent.Left.Val = sum - reduce\\n                children = append(children, parent.Left)\\n            }\\n            if parent.Right != nil {\\n                parent.Right.Val = sum - reduce\\n                children = append(children, parent.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n           5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\n```\\n                        parents=[]\\n\\n          5-5           children=[5], sum=5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\n```    \\n           0            parents=[x]\\n         /   \\\\\\n    sum-4-9  sum-4-9    children=[4, 9], sum=13\\n     /   \\\\       \\\\\\n   1       10      7\\n```\n```   \\n           0           \\n         /   \\\\\\n       0       0        parents=[x, x]\\n     /   \\\\       \\\\\\nsum-1-10 sum-1-10 sum-7 children=[1, 10, 7], sum=18\\n```\n```     \\n           0           \\n         /   \\\\\\n       0       0        \\n     /   \\\\       \\\\\\n   7       7      11    parents=[x, x, x]\\n\\n                        children=[]\\n```\n```\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n    children := []*TreeNode{root}\\n    root.Val = 0\\n\\n    // Each iteration children list contains all elements with the same depth\\n    for len(children) > 0 {\\n        parents := children\\n        children = []*TreeNode{}\\n\\n        // Find sum of all children in this depth\\n        sum := 0\\n        for _, parent := range parents {\\n            if parent.Left != nil { sum += parent.Left.Val }\\n            if parent.Right != nil { sum += parent.Right.Val } \\n        }\\n\\n        // Update children values:\\n        // Calculated sum minus the current childer values (if they exist)\\n        // Also add all children to the list for the next iteration (depth+1)\\n        for _, parent := range parents {\\n            reduce := 0\\n            if parent.Left != nil { reduce += parent.Left.Val }\\n            if parent.Right != nil { reduce += parent.Right.Val }\\n            \\n            if parent.Left != nil {\\n                parent.Left.Val = sum - reduce\\n                children = append(children, parent.Left)\\n            }\\n            if parent.Right != nil {\\n                parent.Right.Val = sum - reduce\\n                children = append(children, parent.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420594,
                "title": "python3-easy-and-clean-bfs-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        \\n        \\n        queue = deque([(root,None)])\\n        \\n        while queue:\\n            \\n            child_sum = defaultdict(int)\\n            p = {}\\n            curr = 0\\n            \\n            for _ in range(len(queue)):\\n\\n                node, parent = queue.popleft()\\n                child_sum[parent] += node.val\\n                p[node] = parent\\n                curr += node.val\\n\\n                if node.left:\\n                    queue.append((node.left, node))\\n                if node.right:\\n                    queue.append((node.right, node))\\n            \\n            for node in p:\\n                node.val = curr - child_sum[p[node]]\\n            \\n            \\n        \\n        return root\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        \\n        \\n        queue = deque([(root,None)])\\n        \\n        while queue:\\n            \\n            child_sum = defaultdict(int)\\n            p = {}\\n            curr = 0\\n            \\n            for _ in range(len(queue)):\\n\\n                node, parent = queue.popleft()\\n                child_sum[parent] += node.val\\n                p[node] = parent\\n                curr += node.val\\n\\n                if node.left:\\n                    queue.append((node.left, node))\\n                if node.right:\\n                    queue.append((node.right, node))\\n            \\n            for node in p:\\n                node.val = curr - child_sum[p[node]]\\n            \\n            \\n        \\n        return root\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420521,
                "title": "c-well-explained-level-order-traversal-o-n-time",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlevel order traversal of binary tree\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root)   return root;\\n        map<int, int> mp;   // this map stores the total sum of every level\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int lvl = 0;\\n\\n        // level order traversing : storing the sum every level in the map\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                mp[lvl] += frNode -> val;\\n                if(frNode -> left)  q.push(frNode -> left);\\n                if(frNode -> right) q.push(frNode -> right);\\n            }\\n            lvl++;\\n        }\\n\\n        q.push(root);   lvl = 0;\\n\\n        // modifing the value of every node\\n        // node value = (total level sum) - node->parent -> (left & right)\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                int l = frNode->left ? frNode->left->val : 0;\\n                int r = frNode->right ? frNode->right->val : 0;\\n                if(frNode -> left)  {\\n                    q.push(frNode->left);\\n                    frNode->left->val = mp[lvl + 1] - (l+r);\\n                }\\n                if(frNode->right)   {\\n                    q.push(frNode->right);\\n                    frNode->right->val = mp[lvl + 1] - (l+r);   \\n                }\\n            }\\n            lvl++;\\n        }\\n\\n        root -> val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root)   return root;\\n        map<int, int> mp;   // this map stores the total sum of every level\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int lvl = 0;\\n\\n        // level order traversing : storing the sum every level in the map\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                mp[lvl] += frNode -> val;\\n                if(frNode -> left)  q.push(frNode -> left);\\n                if(frNode -> right) q.push(frNode -> right);\\n            }\\n            lvl++;\\n        }\\n\\n        q.push(root);   lvl = 0;\\n\\n        // modifing the value of every node\\n        // node value = (total level sum) - node->parent -> (left & right)\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                int l = frNode->left ? frNode->left->val : 0;\\n                int r = frNode->right ? frNode->right->val : 0;\\n                if(frNode -> left)  {\\n                    q.push(frNode->left);\\n                    frNode->left->val = mp[lvl + 1] - (l+r);\\n                }\\n                if(frNode->right)   {\\n                    q.push(frNode->right);\\n                    frNode->right->val = mp[lvl + 1] - (l+r);   \\n                }\\n            }\\n            lvl++;\\n        }\\n\\n        root -> val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420368,
                "title": "scala-two-dfs-tle",
                "content": "# Intuition\\nFirst find sum of all nodes on each level. Then, subtract cousins sum from the level sums. Value is replaced in the tree nodes to save memory allocations. Nevertheless, the solution doesn\\'t pass the tests.\\n\\n# Code\\n```\\ndef replaceValueInTree(root: TreeNode): TreeNode = {\\n    val levels = scala.collection.mutable.Map.empty[Int, Long].withDefaultValue(0)\\n    def goSums(node: TreeNode, level: Int): Unit =\\n      if (node != null) {\\n        levels(level) += node.value\\n        goSums(node.left, level + 1)\\n        goSums(node.right, level + 1)\\n      }\\n\\n    goSums(root, 0)\\n\\n    def go(node: TreeNode, level: Int, parentSum: Long): Unit = {\\n      if(node != null) {\\n        val nodeSum = computeParentSum(node)\\n        node.value = (levels(level) - parentSum).toInt\\n        go(node.left, level + 1, nodeSum)\\n        go(node.right, level + 1, nodeSum)\\n      }\\n    }\\n\\n    val rootSum = computeParentSum(root)\\n    go(root.left, 1, rootSum)\\n    go(root.right, 1, rootSum)\\n    root.value = 0\\n    root\\n  }\\n\\n  def computeParentSum(node: TreeNode) = {\\n    val left = if(node.left == null) 0 else node.left.value\\n    val right = if(node.right == null) 0 else node.right.value\\n    left.toLong + right\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef replaceValueInTree(root: TreeNode): TreeNode = {\\n    val levels = scala.collection.mutable.Map.empty[Int, Long].withDefaultValue(0)\\n    def goSums(node: TreeNode, level: Int): Unit =\\n      if (node != null) {\\n        levels(level) += node.value\\n        goSums(node.left, level + 1)\\n        goSums(node.right, level + 1)\\n      }\\n\\n    goSums(root, 0)\\n\\n    def go(node: TreeNode, level: Int, parentSum: Long): Unit = {\\n      if(node != null) {\\n        val nodeSum = computeParentSum(node)\\n        node.value = (levels(level) - parentSum).toInt\\n        go(node.left, level + 1, nodeSum)\\n        go(node.right, level + 1, nodeSum)\\n      }\\n    }\\n\\n    val rootSum = computeParentSum(root)\\n    go(root.left, 1, rootSum)\\n    go(root.right, 1, rootSum)\\n    root.value = 0\\n    root\\n  }\\n\\n  def computeParentSum(node: TreeNode) = {\\n    val left = if(node.left == null) 0 else node.left.value\\n    val right = if(node.right == null) 0 else node.right.value\\n    left.toLong + right\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420359,
                "title": "simple-dfs-level-ordering-find-sum-at-depth-o-n",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    void dfs(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return;\\n        mp[depth] += root->val;\\n        dfs(root->left,depth+1,mp);\\n        dfs(root->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return ;\\n        ll l = 0, r = 0;\\n        if(root->left) l = root->left->val;\\n        if(root->right) r = root->right->val;\\n        \\n        ll k = mp[depth+1] - l - r;\\n        // cout<<root->val<<\" \"<<l<<\" \"<<r<<\" \"<<k<<\" \"<<mp[depth+1]<<endl;\\n        if(root->left) root->left->val = k;\\n        if(root->right) root->right->val = k;\\n        \\n        \\n        dfs2(root->left,depth+1,mp);\\n        dfs2(root->right,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        map<ll,ll>mp;\\n        dfs(root,0,mp);\\n        dfs2(root,0,mp);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    void dfs(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return;\\n        mp[depth] += root->val;\\n        dfs(root->left,depth+1,mp);\\n        dfs(root->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return ;\\n        ll l = 0, r = 0;\\n        if(root->left) l = root->left->val;\\n        if(root->right) r = root->right->val;\\n        \\n        ll k = mp[depth+1] - l - r;\\n        // cout<<root->val<<\" \"<<l<<\" \"<<r<<\" \"<<k<<\" \"<<mp[depth+1]<<endl;\\n        if(root->left) root->left->val = k;\\n        if(root->right) root->right->val = k;\\n        \\n        \\n        dfs2(root->left,depth+1,mp);\\n        dfs2(root->right,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        map<ll,ll>mp;\\n        dfs(root,0,mp);\\n        dfs2(root,0,mp);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3420240,
                "title": "c-level-order-traversal",
                "content": "## Explanation\\nPerform level order traversal. Use hashmap to store the parent and its children at each level. Accumulate the sum of all node values in the level too using a variable. \\n\\nFor each node, assign value as `sumOfValues - currentNodeVal - siblingNodeVal`. Finally make the root value as 0 too.\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root) return root;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s = q.size();\\n            long long sum = 0;\\n            unordered_map <TreeNode*,pair<TreeNode*,TreeNode*>> mp;\\n            for(int i = 0 ; i < s ; i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left){\\n                    mp[node].first = node->left;\\n                    sum += node->left->val;\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    mp[node].second = node->right;\\n                    sum += node->right->val;\\n                    q.push(node->right);\\n                }\\n            }\\n\\n            for(auto &[k,v] : mp){\\n                int f = (v.first == nullptr) ? 0 : v.first->val , s = ( v.second == nullptr ) ? 0 : v.second->val;\\n                if(v.first) v.first->val = sum-f-s;\\n                if(v.second) v.second->val = sum-f-s;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n\\n```\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root) return root;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s = q.size();\\n            long long sum = 0;\\n            unordered_map <TreeNode*,pair<TreeNode*,TreeNode*>> mp;\\n            for(int i = 0 ; i < s ; i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left){\\n                    mp[node].first = node->left;\\n                    sum += node->left->val;\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    mp[node].second = node->right;\\n                    sum += node->right->val;\\n                    q.push(node->right);\\n                }\\n            }\\n\\n            for(auto &[k,v] : mp){\\n                int f = (v.first == nullptr) ? 0 : v.first->val , s = ( v.second == nullptr ) ? 0 : v.second->val;\\n                if(v.first) v.first->val = sum-f-s;\\n                if(v.second) v.second->val = sum-f-s;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420192,
                "title": "level-order-traversing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector< pair<TreeNode*, int > > arr;\\n        arr.push_back({root, 0});\\n        root->val = 0;\\n        while(arr.size() != 0) {\\n            vector< pair<TreeNode*, int > > x;\\n            int sum = 0;\\n            for(auto i : arr) {\\n                int left = 0, right = 0;\\n                if(i.first -> left != NULL) {\\n                    left = i.first ->left -> val;\\n                    sum += left;\\n                }\\n                if(i.first -> right != NULL) {\\n                    right = i.first ->right -> val;\\n                    sum += right;\\n                }\\n                if(i.first -> left != NULL) {\\n                    x.push_back({i.first ->left, right});\\n                }\\n                if(i.first -> right != NULL) {\\n                    x.push_back({i.first ->right, left});\\n                }\\n            }\\n            for(auto i : x) {\\n                i.first->val = sum - i.second - i.first->val;\\n            }\\n            arr = x;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector< pair<TreeNode*, int > > arr;\\n        arr.push_back({root, 0});\\n        root->val = 0;\\n        while(arr.size() != 0) {\\n            vector< pair<TreeNode*, int > > x;\\n            int sum = 0;\\n            for(auto i : arr) {\\n                int left = 0, right = 0;\\n                if(i.first -> left != NULL) {\\n                    left = i.first ->left -> val;\\n                    sum += left;\\n                }\\n                if(i.first -> right != NULL) {\\n                    right = i.first ->right -> val;\\n                    sum += right;\\n                }\\n                if(i.first -> left != NULL) {\\n                    x.push_back({i.first ->left, right});\\n                }\\n                if(i.first -> right != NULL) {\\n                    x.push_back({i.first ->right, left});\\n                }\\n            }\\n            for(auto i : x) {\\n                i.first->val = sum - i.second - i.first->val;\\n            }\\n            arr = x;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420191,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        sumLevels = list()\\n        sumLevels.append(dict())\\n        sumLevels[-1][None] = 0\\n        totalLevels = list()\\n        totalLevels.append(0)\\n        \\n        def calculateLevelSum(root, level, parent):\\n            if not root:\\n                return\\n            \\n            if parent in sumLevels[level-1]:\\n                sumLevels[level-1][parent] += root.val\\n            \\n            if len(totalLevels) < level + 1:\\n                totalLevels.append(0)\\n            \\n            totalLevels[level] += root.val\\n            \\n            if len(sumLevels) < level + 1:\\n                sumLevels.append(dict())\\n            \\n            sumLevels[level][root] = 0\\n            \\n            calculateLevelSum(root.left, level+1, root)\\n            calculateLevelSum(root.right, level+1, root)\\n        \\n        calculateLevelSum(root, 1, None)\\n        \\n        def reassignValues(root, level, parent):\\n            if not root:\\n                return\\n            \\n            curValue = totalLevels[level] - sumLevels[level-1][parent]\\n\\n            root.val = curValue\\n            reassignValues(root.left, level+1, root)\\n            reassignValues(root.right, level+1, root)\\n            \\n        reassignValues(root, 1, None)\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        sumLevels = list()\\n        sumLevels.append(dict())\\n        sumLevels[-1][None] = 0\\n        totalLevels = list()\\n        totalLevels.append(0)\\n        \\n        def calculateLevelSum(root, level, parent):\\n            if not root:\\n                return\\n            \\n            if parent in sumLevels[level-1]:\\n                sumLevels[level-1][parent] += root.val\\n            \\n            if len(totalLevels) < level + 1:\\n                totalLevels.append(0)\\n            \\n            totalLevels[level] += root.val\\n            \\n            if len(sumLevels) < level + 1:\\n                sumLevels.append(dict())\\n            \\n            sumLevels[level][root] = 0\\n            \\n            calculateLevelSum(root.left, level+1, root)\\n            calculateLevelSum(root.right, level+1, root)\\n        \\n        calculateLevelSum(root, 1, None)\\n        \\n        def reassignValues(root, level, parent):\\n            if not root:\\n                return\\n            \\n            curValue = totalLevels[level] - sumLevels[level-1][parent]\\n\\n            root.val = curValue\\n            reassignValues(root.left, level+1, root)\\n            reassignValues(root.right, level+1, root)\\n            \\n        reassignValues(root, 1, None)\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420179,
                "title": "easy-c-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        //pushing NULL after every siblings\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int> v;\\n            //made copy queue for changing values\\n            queue<TreeNode*> q1(q);\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                //if NULL then we push 0 to separate the cousins\\n                if(temp == NULL)\\n                {\\n                    v.push_back(0);\\n                }\\n                else\\n                {\\n                    if(temp->left)\\n                    {\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        q.push(temp->right);\\n                    }\\n                    //pushing NULL after every siblings ( NOT COUSINS )\\n                    q.push(NULL);\\n                    v.push_back(temp->val);\\n                }\\n            }\\n            \\n            int sum = 0;\\n            int count = 0;\\n            // summing whole one level of tree and counting number of 0\\'s\\n            for(int i = 0; i < v.size(); i++)\\n            {\\n                sum = sum + v[i];\\n                if(v[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            // if count is 0 then it means it is level 1 and 2 so make all nodes 0 using temp queue we kept\\n            if(count == 1)\\n            {\\n                while(!q1.empty())\\n                {\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = 0;\\n                    }\\n                    q1.pop();\\n                }\\n            }\\n            //if count > 1 means other levels then\\n            else if(count > 1)\\n            {\\n                for(int i = 0; i < v.size();)\\n                {\\n                    // we remove siblings from sum and make them equal to that new sum ( sum of all cousins )\\n                    if(v[i] == 0)\\n                    {\\n                        i++;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && v[i+1])\\n                    {\\n                        v[i] = sum-v[i]-v[i+1];\\n                        v[i+1] = v[i];\\n                        i = i + 2;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && !v[i+1])\\n                    {\\n                        v[i] = sum-v[i];\\n                        i++;\\n                    }\\n                }\\n                int i = 0;\\n                while(!q1.empty())\\n                {\\n                    // assigning sum to all nodes\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = v[i];\\n                    }\\n                    i++;\\n                    q1.pop();\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        //pushing NULL after every siblings\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int> v;\\n            //made copy queue for changing values\\n            queue<TreeNode*> q1(q);\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                //if NULL then we push 0 to separate the cousins\\n                if(temp == NULL)\\n                {\\n                    v.push_back(0);\\n                }\\n                else\\n                {\\n                    if(temp->left)\\n                    {\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        q.push(temp->right);\\n                    }\\n                    //pushing NULL after every siblings ( NOT COUSINS )\\n                    q.push(NULL);\\n                    v.push_back(temp->val);\\n                }\\n            }\\n            \\n            int sum = 0;\\n            int count = 0;\\n            // summing whole one level of tree and counting number of 0\\'s\\n            for(int i = 0; i < v.size(); i++)\\n            {\\n                sum = sum + v[i];\\n                if(v[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            // if count is 0 then it means it is level 1 and 2 so make all nodes 0 using temp queue we kept\\n            if(count == 1)\\n            {\\n                while(!q1.empty())\\n                {\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = 0;\\n                    }\\n                    q1.pop();\\n                }\\n            }\\n            //if count > 1 means other levels then\\n            else if(count > 1)\\n            {\\n                for(int i = 0; i < v.size();)\\n                {\\n                    // we remove siblings from sum and make them equal to that new sum ( sum of all cousins )\\n                    if(v[i] == 0)\\n                    {\\n                        i++;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && v[i+1])\\n                    {\\n                        v[i] = sum-v[i]-v[i+1];\\n                        v[i+1] = v[i];\\n                        i = i + 2;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && !v[i+1])\\n                    {\\n                        v[i] = sum-v[i];\\n                        i++;\\n                    }\\n                }\\n                int i = 0;\\n                while(!q1.empty())\\n                {\\n                    // assigning sum to all nodes\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = v[i];\\n                    }\\n                    i++;\\n                    q1.pop();\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420086,
                "title": "easy-bfs-java-solution-using-2-queue",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null) return root;\\n        TreeNode res = new TreeNode(0);\\n        Queue<TreeNode> resq = new LinkedList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        resq.offer(res);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            TreeNode[] t = new TreeNode[size];\\n            int sum = 0;\\n            for(int i = 0; i<size; i++){\\n                t[i] = q.poll();\\n                if(t[i].left != null){\\n                    q.offer(t[i].left);\\n                    sum += t[i].left.val;\\n                }\\n                if(t[i].right != null){\\n                    q.offer(t[i].right);\\n                    sum += t[i].right.val;\\n                }\\n            }\\n            for(int i = 0; i<size; i++){\\n                TreeNode curr = resq.poll();\\n                int cusins = sum - (t[i].left != null ? t[i].left.val : 0) - (t[i].right != null ? t[i].right.val : 0);\\n                if(t[i].left != null){\\n                    curr.left = new TreeNode(cusins);\\n                    resq.offer(curr.left);\\n                }\\n                if(t[i].right != null){\\n                    curr.right = new TreeNode(cusins);\\n                    resq.offer(curr.right);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null) return root;\\n        TreeNode res = new TreeNode(0);\\n        Queue<TreeNode> resq = new LinkedList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        resq.offer(res);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            TreeNode[] t = new TreeNode[size];\\n            int sum = 0;\\n            for(int i = 0; i<size; i++){\\n                t[i] = q.poll();\\n                if(t[i].left != null){\\n                    q.offer(t[i].left);\\n                    sum += t[i].left.val;\\n                }\\n                if(t[i].right != null){\\n                    q.offer(t[i].right);\\n                    sum += t[i].right.val;\\n                }\\n            }\\n            for(int i = 0; i<size; i++){\\n                TreeNode curr = resq.poll();\\n                int cusins = sum - (t[i].left != null ? t[i].left.val : 0) - (t[i].right != null ? t[i].right.val : 0);\\n                if(t[i].left != null){\\n                    curr.left = new TreeNode(cusins);\\n                    resq.offer(curr.left);\\n                }\\n                if(t[i].right != null){\\n                    curr.right = new TreeNode(cusins);\\n                    resq.offer(curr.right);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420019,
                "title": "c-bfs-using-mapping-of-parent",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>> q;\\n        q.push({root,nullptr});\\n        while(q.size()){\\n            long long sz = q.size();\\n            vector<pair<TreeNode*,TreeNode*>> arr;\\n            unordered_map<TreeNode*,long long> mp;\\n            long long sum = 0; \\n            for(int i=0;i<sz;i++){\\n                auto xx = q.front();\\n                auto x = xx.first;\\n                if(xx.second!=nullptr)\\n                    mp[xx.second] += x->val;\\n                sum += x->val;\\n                arr.push_back(xx);\\n                q.pop();\\n                if(x->left) q.push({x->left,x});\\n                if(x->right) q.push({x->right,x});\\n            }\\n            for(int i=0;i<arr.size();i++){\\n                arr[i].first->val = (sum - mp[arr[i].second]);\\n            }\\n            if(sz == 1) arr[0].first->val = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>> q;\\n        q.push({root,nullptr});\\n        while(q.size()){\\n            long long sz = q.size();\\n            vector<pair<TreeNode*,TreeNode*>> arr;\\n            unordered_map<TreeNode*,long long> mp;\\n            long long sum = 0; \\n            for(int i=0;i<sz;i++){\\n                auto xx = q.front();\\n                auto x = xx.first;\\n                if(xx.second!=nullptr)\\n                    mp[xx.second] += x->val;\\n                sum += x->val;\\n                arr.push_back(xx);\\n                q.pop();\\n                if(x->left) q.push({x->left,x});\\n                if(x->right) q.push({x->right,x});\\n            }\\n            for(int i=0;i<arr.size();i++){\\n                arr[i].first->val = (sum - mp[arr[i].second]);\\n            }\\n            if(sz == 1) arr[0].first->val = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420010,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution{\\n    typedef TreeNode tn;\\npublic:\\n    void bfs(tn*rt){\\n        rt->val=0;\\n        list<tn*>l={rt}; // transformed parents\\n        while(!l.empty()){\\n            int sum=0; // sum of the values of all the nodes at the next depth level\\n            for(tn* par : l){\\n                if(par->left){\\n                    sum+=par->left->val;\\n                }\\n                if(par->right){\\n                    sum+=par->right->val;\\n                }\\n            }\\n            int sz=l.size();\\n            while(sz--){\\n                tn* par = l.front();\\n                l.pop_front();\\n                int lc = (par->left ? par->left->val : 0),\\n                    rc = (par->right ? par->right->val : 0);\\n                if(par->left){\\n                    par->left->val=sum-lc-rc;\\n                    l.push_back(par->left);\\n                }\\n                if(par->right){\\n                    par->right->val=sum-lc-rc;\\n                    l.push_back(par->right);\\n                }\\n            }\\n        }\\n    }\\n    tn* replaceValueInTree(tn* root) {\\n        bfs(root);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution{\\n    typedef TreeNode tn;\\npublic:\\n    void bfs(tn*rt){\\n        rt->val=0;\\n        list<tn*>l={rt}; // transformed parents\\n        while(!l.empty()){\\n            int sum=0; // sum of the values of all the nodes at the next depth level\\n            for(tn* par : l){\\n                if(par->left){\\n                    sum+=par->left->val;\\n                }\\n                if(par->right){\\n                    sum+=par->right->val;\\n                }\\n            }\\n            int sz=l.size();\\n            while(sz--){\\n                tn* par = l.front();\\n                l.pop_front();\\n                int lc = (par->left ? par->left->val : 0),\\n                    rc = (par->right ? par->right->val : 0);\\n                if(par->left){\\n                    par->left->val=sum-lc-rc;\\n                    l.push_back(par->left);\\n                }\\n                if(par->right){\\n                    par->right->val=sum-lc-rc;\\n                    l.push_back(par->right);\\n                }\\n            }\\n        }\\n    }\\n    tn* replaceValueInTree(tn* root) {\\n        bfs(root);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419989,
                "title": "java-c-simple-solution-dfs-hashmap",
                "content": "\\n``` java []\\nclass Solution {\\n    Map<Integer,Integer> map;\\n    Map<TreeNode,Integer> map2;\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        map = new HashMap<>();\\n        map2 = new HashMap<>();\\n        dfs(root, null, 0);\\n        fillSum(root, null, 0);\\n        return root;\\n    }\\n    \\n    private void dfs(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        if(parent!=null){\\n           map2.put(parent,map2.getOrDefault(parent,0)+root.val);\\n           map.put(c,map.getOrDefault(c,0)+root.val);\\n        }\\n        dfs(root.left,root,c+1);\\n        dfs(root.right,root,c+1);\\n    }\\n\\n    private void fillSum(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        root.val = parent==null? 0: (map.get(c)-map2.get(parent));\\n        fillSum(root.left,root,c+1);\\n        fillSum(root.right,root,c+1);\\n    }\\n}\\n```\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    unordered_map<int,int> depthSumMap;\\n    unordered_map<TreeNode*,int> cousinSumMap;\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       dfs(root,NULL, 0);\\n       fillSum(root,NULL,0);\\n       return root;\\n    }\\n    \\n    void dfs(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(parent!=NULL){\\n            cousinSumMap[parent] += root->val;\\n            depthSumMap[depth] += root->val;\\n        }\\n        dfs(root->left,root,depth+1);\\n        dfs(root->right,root,depth+1);\\n    }\\n    \\n    void fillSum(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        root->val = parent==NULL? 0 :(depthSumMap[depth] - cousinSumMap[parent]);\\n        fillSum(root->left,root,depth+1);\\n        fillSum(root->right,root,depth+1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    Map<Integer,Integer> map;\\n    Map<TreeNode,Integer> map2;\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        map = new HashMap<>();\\n        map2 = new HashMap<>();\\n        dfs(root, null, 0);\\n        fillSum(root, null, 0);\\n        return root;\\n    }\\n    \\n    private void dfs(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        if(parent!=null){\\n           map2.put(parent,map2.getOrDefault(parent,0)+root.val);\\n           map.put(c,map.getOrDefault(c,0)+root.val);\\n        }\\n        dfs(root.left,root,c+1);\\n        dfs(root.right,root,c+1);\\n    }\\n\\n    private void fillSum(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        root.val = parent==null? 0: (map.get(c)-map2.get(parent));\\n        fillSum(root.left,root,c+1);\\n        fillSum(root.right,root,c+1);\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    unordered_map<int,int> depthSumMap;\\n    unordered_map<TreeNode*,int> cousinSumMap;\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       dfs(root,NULL, 0);\\n       fillSum(root,NULL,0);\\n       return root;\\n    }\\n    \\n    void dfs(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(parent!=NULL){\\n            cousinSumMap[parent] += root->val;\\n            depthSumMap[depth] += root->val;\\n        }\\n        dfs(root->left,root,depth+1);\\n        dfs(root->right,root,depth+1);\\n    }\\n    \\n    void fillSum(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        root->val = parent==NULL? 0 :(depthSumMap[depth] - cousinSumMap[parent]);\\n        fillSum(root->left,root,depth+1);\\n        fillSum(root->right,root,depth+1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419981,
                "title": "c-explained",
                "content": "\\t// Firstly find and store the level wise sum of all nodes in the sum array (use level order traversal for this).\\n\\n\\t// Secondly do preorder traversal and subtract the left and right sibling value (which are from same parent) from the sum of that current level values \\n\\t// and replace the values of these two nodes with these levelSum - leftChild - rightChild.\\n\\n\\t// Finally for 0th level and 1st level value of nodes will always remain zero.\\n\\n\\tclass Solution {\\n\\t\\n\\t\\tpublic:\\n\\n\\t\\tvoid levelorder(TreeNode* root,vector<int> &sum)\\n\\t\\t{\\n\\t\\t\\tqueue<TreeNode*> q;\\n\\t\\t\\tq.push(root);\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelSum=0;\\n\\t\\t\\t\\tint size=q.size();\\n\\n\\t\\t\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tauto node = q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\t\\tlevelSum += node->val;\\n\\n\\t\\t\\t\\t\\tif(node->left)\\n\\t\\t\\t\\t\\t\\tq.push(node->left);\\n\\t\\t\\t\\t\\tif(node->right)\\n\\t\\t\\t\\t\\t\\tq.push(node->right);\\n\\t\\t\\t\\t}            \\n\\t\\t\\t\\tsum.push_back(levelSum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid preorder(TreeNode* root,int level,vector<int> &sum)\\n\\t\\t{\\n\\t\\t\\tif(!root)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint leftVal=-1,rightVal=-1;\\n\\n\\t\\t\\tif(level!=0 && root->left)\\n\\t\\t\\t\\tleftVal = root->left->val;\\n\\n\\t\\t\\tif(level!=0 && root->right)\\n\\t\\t\\t\\trightVal = root->right->val;    \\n\\n\\t\\t\\tif(level+1<sum.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint val = sum[level+1];\\n\\t\\t\\t\\tif(leftVal!=-1)\\n\\t\\t\\t\\t\\tval -= leftVal;\\n\\t\\t\\t\\tif(rightVal!=-1)\\n\\t\\t\\t\\t\\tval -= rightVal;\\n\\n\\t\\t\\t\\tif(root->left)\\n\\t\\t\\t\\t\\troot->left->val = val;\\n\\n\\t\\t\\t\\tif(root->right)\\n\\t\\t\\t\\t\\troot->right->val = val;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpreorder(root->left,level+1,sum);\\n\\t\\t\\tpreorder(root->right,level+1,sum);\\n\\t\\t}\\n\\n\\t\\tTreeNode* replaceValueInTree(TreeNode* root) {\\n\\n\\t\\t\\tvector<int> sum;\\n\\n\\t\\t\\tlevelorder(root,sum);\\n\\t\\t\\tpreorder(root,0,sum);\\n\\n\\t\\t\\troot->val = 0;                          // Root node and its child Nodes will always remain zero\\n\\t\\t\\tif(root->left)\\n\\t\\t\\t\\troot->left->val=0;\\n\\n\\t\\t\\tif(root->right)\\n\\t\\t\\t\\troot->right->val=0;\\n\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t \\n\\t };",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\n\\t\\tpublic:\\n\\n\\t\\tvoid levelorder(TreeNode* root,vector<int> &sum)\\n\\t\\t{\\n\\t\\t\\tqueue<TreeNode*> q;\\n\\t\\t\\tq.push(root);\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelSum=0;\\n\\t\\t\\t\\tint size=q.size();\\n\\n\\t\\t\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tauto node = q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\t\\tlevelSum += node->val;\\n\\n\\t\\t\\t\\t\\tif(node->left)\\n\\t\\t\\t\\t\\t\\tq.push(node->left);\\n\\t\\t\\t\\t\\tif(node->right)\\n\\t\\t\\t\\t\\t\\tq.push(node->right);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3419968,
                "title": "depth-sum-minus-parent-sum",
                "content": "A cousin by definition has the same depth of the node and also a different parent. So we can calculate the sum of each level of the tree, as well as the sum of each parent\\'s children. Then the sum of all non-cousins is the sum of the entire level of the tree minus the sum of the node\\'s parent\\'s children. We can do this easily in two traversals, one to calculate depth and parent sums, and one to set the values to the correct answer.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    long long v[100001] = {};\\n    map<TreeNode*, long long> par;\\n    void trav(TreeNode* root, int h, int& id, TreeNode* last){\\n        if(root == nullptr) return;\\n        v[h] += root->val;\\n        if(last != nullptr) par[last] += root->val;\\n        trav(root->left, h+1, id, root);\\n        trav(root->right, h+1, id, root);\\n    }\\n    void fix(TreeNode* root, int h, int& id, TreeNode* last){\\n        if(root == nullptr) return;\\n        if(last == nullptr) root->val = 0;\\n        else root->val = v[h]-par[last];\\n        fix(root->left, h+1, root);\\n        fix(root->right, h+1, root);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        trav(root, 1, nullptr);\\n        fix(root, 1, nullptr);\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long v[100001] = {}",
                "codeTag": "Java"
            },
            {
                "id": 4080973,
                "title": "simple-bfs-simple-solution",
                "content": "# Intuition\\nSolved it using BFS. Calculated the sum of all all node keys at each individual level and then subtracted from the sum of the node keys of a particular parent and assigned that value to its children nodes. Easy and Simple to understand.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            queue<TreeNode*>parent;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                parent.push(temp);\\n                if(temp->left!=NULL)\\n                {\\n                    q.push(temp->left);\\n                    sum+=temp->left->val;\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                    q.push(temp->right);\\n                    sum+=temp->right->val;\\n                }\\n            }\\n                while(!parent.empty())\\n                {\\n                    TreeNode* lul=parent.front();\\n                    parent.pop();\\n                    int nv=0;\\n                    if(lul->left!=NULL)\\n                    {\\n                        nv+=lul->left->val;\\n                    }\\n                    if(lul->right!=NULL)\\n                    {\\n                        nv+=lul->right->val;\\n                    }\\n                    if(lul->left!=NULL)\\n                        lul->left->val=sum-nv;\\n                    if(lul->right!=NULL)\\n                        lul->right->val=sum-nv;\\n                }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            queue<TreeNode*>parent;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                parent.push(temp);\\n                if(temp->left!=NULL)\\n                {\\n                    q.push(temp->left);\\n                    sum+=temp->left->val;\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                    q.push(temp->right);\\n                    sum+=temp->right->val;\\n                }\\n            }\\n                while(!parent.empty())\\n                {\\n                    TreeNode* lul=parent.front();\\n                    parent.pop();\\n                    int nv=0;\\n                    if(lul->left!=NULL)\\n                    {\\n                        nv+=lul->left->val;\\n                    }\\n                    if(lul->right!=NULL)\\n                    {\\n                        nv+=lul->right->val;\\n                    }\\n                    if(lul->left!=NULL)\\n                        lul->left->val=sum-nv;\\n                    if(lul->right!=NULL)\\n                        lul->right->val=sum-nv;\\n                }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067854,
                "title": "using-2-dfs-with-o-n-run-time-and-space-complexity",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_somme=defaultdict(int)\\n        def levelSomme(root,depth):\\n            if not root:\\n                return\\n            level_somme[depth]+=root.val\\n            levelSomme(root.left,depth+1)\\n            levelSomme(root.right,depth+1)\\n\\n        def dfs(root,depth,sib):\\n            if not root:\\n                return\\n            root.val=level_somme[depth]-root.val-sib\\n            left_val=root.left.val if root.left else 0\\n            right_val=root.right.val if root.right else 0\\n\\n            dfs(root.left,depth+1,right_val)\\n            dfs(root.right,depth+1,left_val)\\n\\n        levelSomme(root,0)\\n        dfs(root,0,0)\\n        return root\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_somme=defaultdict(int)\\n        def levelSomme(root,depth):\\n            if not root:\\n                return\\n            level_somme[depth]+=root.val\\n            levelSomme(root.left,depth+1)\\n            levelSomme(root.right,depth+1)\\n\\n        def dfs(root,depth,sib):\\n            if not root:\\n                return\\n            root.val=level_somme[depth]-root.val-sib\\n            left_val=root.left.val if root.left else 0\\n            right_val=root.right.val if root.right else 0\\n\\n            dfs(root.left,depth+1,right_val)\\n            dfs(root.right,depth+1,left_val)\\n\\n        levelSomme(root,0)\\n        dfs(root,0,0)\\n        return root\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061254,
                "title": "c-solution-using-map",
                "content": "class Solution {\\npublic:\\n    void levelSum(TreeNode* root,int level,map<int,int>&mp){\\n        if(!root)return;\\n        mp[level]+=root->val;\\n        levelSum(root->left,level+1,mp);\\n        levelSum(root->right,level+1,mp);\\n    }\\n    void solve(TreeNode* root,int level,map<int,int>&mp){\\n        if(!root)return;\\n        if(root->left and root->right){\\n        root->left->val=mp[level+1]-root->left->val-root->right->val;\\n        root->right->val=root->left->val;\\n        }\\n         if(root->left and !root->right)\\n        root->left->val=mp[level+1]-root->left->val;\\n         if(!root->left and root->right)\\n        root->right->val=mp[level+1]-root->right->val;\\n        solve(root->left,level+1,mp);\\n        solve(root->right,level+1,mp);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root)return NULL;\\n        map<int,int>mp;\\n        levelSum(root,0,mp);\\n        solve(root,0,mp);\\n        root->val=0;\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void levelSum(TreeNode* root,int level,map<int,int>&mp){\\n        if(!root)return;\\n        mp[level]+=root->val;\\n        levelSum(root->left,level+1,mp);\\n        levelSum(root->right,level+1,mp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4032291,
                "title": "o-n-level-order-traversal-optimized-solution-by-anurag",
                "content": "# Intuition\\nThe goal is to replace the value of each node in the binary tree with the sum of its cousins\\' values. Cousins are nodes at the same depth but with different parents. We can use a level-order traversal (BFS) to compute the sum of cousins for each node in the tree and update their values accordingly.\\n\\n# Approach\\n1.Initialize a queue for level-order traversal, a map to store the sum of cousins for each node at the current level, and a variable to keep track of the sum of cousins.\\n\\n2.Start with the root node and push it into the queue.\\n\\n3.While the queue is not empty, process each level:\\n\\na. For each node at the current level, calculate the sum of its left and right children\\'s values and update the map.\\n\\nb. Update the value of the current node with the sum of its cousins.\\n\\nc. If the current node has left and right children, adjust their values accordingly.\\n\\nd. Push the left and right children of the current node into the queue for the next level.\\n\\n4.Continue this process until all levels have been processed.\\n\\n5.Return the modified root node.\\n\\n# Complexity\\n- Time complexity:O(N),Visiting each node in BFS.\\n\\n- Space complexity:O(M),Where M is the maximum number of nodes at any level (Worse case space complexity).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  TreeNode* replaceValueInTree(TreeNode* root) {\\n    queue<TreeNode*>q;\\n    TreeNode*dummy=root;\\n    root->val=0;\\n    q.push(dummy);\\n    while(q.size()){\\n        queue<TreeNode*>temp;\\n        map<TreeNode*,int>m;\\n        while(q.size()){\\n            if(q.front()->left){\\n                temp.push(q.front()->left);\\n                m[q.front()]+=q.front()->left->val;\\n            }\\n             if(q.front()->right){\\n                temp.push(q.front()->right);\\n                m[q.front()]+=q.front()->right->val;\\n            }\\n            q.pop();\\n        }\\n        int sum=0;\\n        map<TreeNode*,int> ::iterator i;\\n        for(i=m.begin();i!=m.end();i++){\\n            sum+=(*i).second;\\n        }\\n       \\n        for(i=m.begin();i!=m.end();i++){\\n            int temp2=0;\\n            if((*i).first->left){\\n                temp2+=(*i).first->left->val;\\n            }\\n            if((*i).first->right){\\n                temp2+=(*i).first->right->val;\\n            }\\n            temp2=sum-temp2;\\n            if((*i).first->left){\\n                (*i).first->left->val=temp2;\\n            }\\n            if((*i).first->right){\\n                (*i).first->right->val=temp2;\\n            }\\n            q=temp;\\n        }\\n    }\\n    return root;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  TreeNode* replaceValueInTree(TreeNode* root) {\\n    queue<TreeNode*>q;\\n    TreeNode*dummy=root;\\n    root->val=0;\\n    q.push(dummy);\\n    while(q.size()){\\n        queue<TreeNode*>temp;\\n        map<TreeNode*,int>m;\\n        while(q.size()){\\n            if(q.front()->left){\\n                temp.push(q.front()->left);\\n                m[q.front()]+=q.front()->left->val;\\n            }\\n             if(q.front()->right){\\n                temp.push(q.front()->right);\\n                m[q.front()]+=q.front()->right->val;\\n            }\\n            q.pop();\\n        }\\n        int sum=0;\\n        map<TreeNode*,int> ::iterator i;\\n        for(i=m.begin();i!=m.end();i++){\\n            sum+=(*i).second;\\n        }\\n       \\n        for(i=m.begin();i!=m.end();i++){\\n            int temp2=0;\\n            if((*i).first->left){\\n                temp2+=(*i).first->left->val;\\n            }\\n            if((*i).first->right){\\n                temp2+=(*i).first->right->val;\\n            }\\n            temp2=sum-temp2;\\n            if((*i).first->left){\\n                (*i).first->left->val=temp2;\\n            }\\n            if((*i).first->right){\\n                (*i).first->right->val=temp2;\\n            }\\n            q=temp;\\n        }\\n    }\\n    return root;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998816,
                "title": "two-solutions-bfs-and-dfs",
                "content": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [root]\\n        root.val = 0\\n        while queue:\\n            dic_sum_children, new_queue, sum_level = {}, [], 0\\n            for node in queue:\\n                old_sum_level = sum_level\\n                if node.left:\\n                    sum_level += node.left.val\\n                if node.right:\\n                    sum_level += node.right.val        \\n                dic_sum_children[node] = sum_level - old_sum_level\\n            for node in queue:\\n                sum_chidren = dic_sum_children[node]  \\n                if node.left:\\n                    node.left.val = sum_level - sum_chidren\\n                    new_queue.append(node.left)\\n                if node.right:\\n                    node.right.val = sum_level - sum_chidren\\n                    new_queue.append(node.right)\\n            queue = new_queue\\n        return root\\n```\\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        return self.replase_val(root, TreeNode(left= root), 0, self.sum_level(root, 0 ,[]))\\n\\n    def sum_level(self, root, depth, list_sum):\\n        if not root:\\n            return list_sum\\n        if depth == len(list_sum):\\n            list_sum.append(root.val)\\n        else:\\n            list_sum[depth] += root.val\\n        self.sum_level(root.left, depth+1, list_sum)\\n        self.sum_level(root.right, depth+1, list_sum)\\n        return list_sum\\n\\n    def replase_val(self, root, parent, depth, list_sum):\\n        if not root:\\n            return None\\n        if parent.left and parent.left is root:  \\n            if parent.right:     \\n                root.val = parent.right.val = list_sum[depth]-root.val-parent.right.val  \\n            else: \\n                root.val = list_sum[depth]-root.val\\n        elif not parent.left:\\n            root.val = list_sum[depth]-root.val\\n        self.replase_val(root.left, root, depth+1, list_sum)\\n        self.replase_val(root.right, root, depth+1, list_sum)\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [root]\\n        root.val = 0\\n        while queue:\\n            dic_sum_children, new_queue, sum_level = {}, [], 0\\n            for node in queue:\\n                old_sum_level = sum_level\\n                if node.left:\\n                    sum_level += node.left.val\\n                if node.right:\\n                    sum_level += node.right.val        \\n                dic_sum_children[node] = sum_level - old_sum_level\\n            for node in queue:\\n                sum_chidren = dic_sum_children[node]  \\n                if node.left:\\n                    node.left.val = sum_level - sum_chidren\\n                    new_queue.append(node.left)\\n                if node.right:\\n                    node.right.val = sum_level - sum_chidren\\n                    new_queue.append(node.right)\\n            queue = new_queue\\n        return root\\n```\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        return self.replase_val(root, TreeNode(left= root), 0, self.sum_level(root, 0 ,[]))\\n\\n    def sum_level(self, root, depth, list_sum):\\n        if not root:\\n            return list_sum\\n        if depth == len(list_sum):\\n            list_sum.append(root.val)\\n        else:\\n            list_sum[depth] += root.val\\n        self.sum_level(root.left, depth+1, list_sum)\\n        self.sum_level(root.right, depth+1, list_sum)\\n        return list_sum\\n\\n    def replase_val(self, root, parent, depth, list_sum):\\n        if not root:\\n            return None\\n        if parent.left and parent.left is root:  \\n            if parent.right:     \\n                root.val = parent.right.val = list_sum[depth]-root.val-parent.right.val  \\n            else: \\n                root.val = list_sum[depth]-root.val\\n        elif not parent.left:\\n            root.val = list_sum[depth]-root.val\\n        self.replase_val(root.left, root, depth+1, list_sum)\\n        self.replase_val(root.right, root, depth+1, list_sum)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979218,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStore sum of node values of all heights in dictionary.\\nthen substract dictionary[height] - left-right.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(height)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        total, root.val = {}, 0\\n        def getSumOfHeights(node, height):\\n            if height not in total:\\n                total[height] = 0\\n            total[height] += node.val\\n            if node.left:\\n                getSumOfHeights(node.left, height+1)\\n            if node.right:\\n                getSumOfHeights(node.right, height+1)\\n        getSumOfHeights(root, 0)\\n        \\n        def helper(node,height):\\n            left,right = 0,0\\n            if node.left:\\n                helper(node.left,height+1)\\n                left = node.left.val\\n\\n            if node.right:\\n                helper(node.right,height+1)\\n                right = node.right.val\\n            if left+right != 0:\\n                if node.left:\\n                    node.left.val = total[height+1]-(left+right)\\n                if node.right:\\n                    node.right.val = total[height+1]-(left+right)\\n        helper(root,0)\\n        return root\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        total, root.val = {}, 0\\n        def getSumOfHeights(node, height):\\n            if height not in total:\\n                total[height] = 0\\n            total[height] += node.val\\n            if node.left:\\n                getSumOfHeights(node.left, height+1)\\n            if node.right:\\n                getSumOfHeights(node.right, height+1)\\n        getSumOfHeights(root, 0)\\n        \\n        def helper(node,height):\\n            left,right = 0,0\\n            if node.left:\\n                helper(node.left,height+1)\\n                left = node.left.val\\n\\n            if node.right:\\n                helper(node.right,height+1)\\n                right = node.right.val\\n            if left+right != 0:\\n                if node.left:\\n                    node.left.val = total[height+1]-(left+right)\\n                if node.right:\\n                    node.right.val = total[height+1]-(left+right)\\n        helper(root,0)\\n        return root\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976447,
                "title": "bfs-dfs",
                "content": "**bfs**\\n```\\nclass Solution \\n{\\n    void transform_tree(TreeNode* r)\\n    {\\n        vector<TreeNode*> v{r}, vv;\\n        for( ; !empty(v); )\\n        {\\n            int sum{};\\n            for(auto & v : v)\\n            {\\n                auto t = (v->left ? v->left->val : 0)+(v->right ? v->right->val : 0);\\n                if(v->left)  \\n                {\\n                    vv.push_back(v->left);\\n                    v->left->val = -t;\\n                }\\n                if(v->right) \\n                {\\n                    vv.push_back(v->right);\\n                    v->right->val = -t;\\n                }\\n                sum += t;\\n            }\\n            for(auto & v : v)\\n            {\\n                if(v->left)  v->left->val  += sum;\\n                if(v->right) v->right->val += sum;\\n            }\\n            v.clear();\\n            swap(v,vv);\\n        }\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n};\\n```\\n**dfs**\\n```\\nclass Solution \\n{\\n    unordered_map<int,int> m;\\n\\n    void make_sum(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        m[d]+=r->val;\\n        make_sum(r->left, d+1);\\n        make_sum(r->right, d+1);\\n    }\\n    void transform_tree(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        int t = (r->left ? r->left->val : 0)+(r->right ? r->right->val : 0);\\n        if(r->left)    \\n              r->left->val = m[d+1]-t;\\n        if(r->right)    \\n              r->right->val = m[d+1]-t;\\n        transform_tree(r->left, d+1);\\n        transform_tree(r->right, d+1);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        make_sum(r);\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n```\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    void transform_tree(TreeNode* r)\\n    {\\n        vector<TreeNode*> v{r}, vv;\\n        for( ; !empty(v); )\\n        {\\n            int sum{};\\n            for(auto & v : v)\\n            {\\n                auto t = (v->left ? v->left->val : 0)+(v->right ? v->right->val : 0);\\n                if(v->left)  \\n                {\\n                    vv.push_back(v->left);\\n                    v->left->val = -t;\\n                }\\n                if(v->right) \\n                {\\n                    vv.push_back(v->right);\\n                    v->right->val = -t;\\n                }\\n                sum += t;\\n            }\\n            for(auto & v : v)\\n            {\\n                if(v->left)  v->left->val  += sum;\\n                if(v->right) v->right->val += sum;\\n            }\\n            v.clear();\\n            swap(v,vv);\\n        }\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    unordered_map<int,int> m;\\n\\n    void make_sum(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        m[d]+=r->val;\\n        make_sum(r->left, d+1);\\n        make_sum(r->right, d+1);\\n    }\\n    void transform_tree(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        int t = (r->left ? r->left->val : 0)+(r->right ? r->right->val : 0);\\n        if(r->left)    \\n              r->left->val = m[d+1]-t;\\n        if(r->right)    \\n              r->right->val = m[d+1]-t;\\n        transform_tree(r->left, d+1);\\n        transform_tree(r->right, d+1);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        make_sum(r);\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953288,
                "title": "simple-bfs",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> temp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            int sum =0;\\n            for(int i=0;i<size;i++){\\n                sum+=(q.front()->val);\\n                TreeNode* node = q.front();\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n                q.pop();\\n            }\\n            temp.push_back(sum);\\n        }\\n         q.push(root);\\n        int level =0;\\n        root->val =0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(level==0){\\n                      if(node->left){\\n                    q.push(node->left);\\n                          node->left->val=0;\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                    node->right->val=0;\\n                }\\n                }\\n                else{\\n                    int sum =0;\\n                     if(node->left){\\n                    q.push(node->left);\\n                         sum+=(node->left->val);\\n                         \\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                   sum+=(node->right->val);\\n                }\\n                    if(node->left){\\n                        node->left->val = temp[level+1]-sum;\\n                    }\\n                    if(node->right){\\n                        node->right->val = temp[level+1]-sum;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> temp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            int sum =0;\\n            for(int i=0;i<size;i++){\\n                sum+=(q.front()->val);\\n                TreeNode* node = q.front();\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n                q.pop();\\n            }\\n            temp.push_back(sum);\\n        }\\n         q.push(root);\\n        int level =0;\\n        root->val =0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(level==0){\\n                      if(node->left){\\n                    q.push(node->left);\\n                          node->left->val=0;\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                    node->right->val=0;\\n                }\\n                }\\n                else{\\n                    int sum =0;\\n                     if(node->left){\\n                    q.push(node->left);\\n                         sum+=(node->left->val);\\n                         \\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                   sum+=(node->right->val);\\n                }\\n                    if(node->left){\\n                        node->left->val = temp[level+1]-sum;\\n                    }\\n                    if(node->right){\\n                        node->right->val = temp[level+1]-sum;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909119,
                "title": "level-order-bfs-traversal-hashmap",
                "content": "# Intuition\\n- Finding the level sum excluding those under the same parent will give sum of cousins\\n\\n# Approach\\n- Iterate through in level order\\n- At each level, create a hashmap of `parent -> total child sum`\\n- Also calculate the total sum at each level\\n- In each iteration, update current node values, subtracting as mentioned above (i.e. `total_sum - parent_sum[par]`)\\n\\n# Complexity\\n- Time complexity: O(N), as we visit each nodes twice so 2N times\\n\\n- Space complexity: O(N), at most (N+1)/2 nodes in the queue\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n      queue = deque([(root, None)])\\n      while queue:\\n        level = []\\n        parent_sum = defaultdict(int)\\n        total_sum = 0\\n        for _ in range(len(queue)):\\n          node, par = queue.popleft()\\n          level.append((node, par))\\n          parent_sum[par] += node.val\\n          total_sum += node.val\\n          if node.left:\\n            queue.append((node.left, node))\\n          if node.right:\\n            queue.append((node.right, node))\\n        for node, par in level:\\n          node.val = total_sum - parent_sum[par]\\n      return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n      queue = deque([(root, None)])\\n      while queue:\\n        level = []\\n        parent_sum = defaultdict(int)\\n        total_sum = 0\\n        for _ in range(len(queue)):\\n          node, par = queue.popleft()\\n          level.append((node, par))\\n          parent_sum[par] += node.val\\n          total_sum += node.val\\n          if node.left:\\n            queue.append((node.left, node))\\n          if node.right:\\n            queue.append((node.right, node))\\n        for node, par in level:\\n          node.val = total_sum - parent_sum[par]\\n      return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899815,
                "title": "simple-fast-easy-c",
                "content": "# Intuition\\nFirst thought: To use level sum wisely\\nSecond thought: Intoduce BFS\\n\\n# Complexit\\n- Time complexity:\\n  O(n)\\n  where n is the number of nodes in the tree\\n- Space complexity:\\n- O(h)\\n- where h is the height of the tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private: \\n    void getLevelSum(TreeNode* root,int depth,vector<int>& levelSum)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        if(levelSum.size()==depth)\\n        {\\n            levelSum.push_back(root->val);\\n        }\\n        else{\\n            levelSum[depth]+=root->val;\\n        }\\n        getLevelSum(root->left,depth+1,levelSum);\\n        getLevelSum(root->right,depth+1,levelSum);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getLevelSum(root,0,levelSum);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        int depth=1;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int nodeChildSum=0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left!=NULL)\\n                {\\n                    nodeChildSum+=node->left->val;\\n                }\\n                if(node->right!=NULL)\\n                {\\n                    nodeChildSum+=node->right->val;\\n                }\\n                if(node->left)\\n                {\\n                    node->left->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->left);\\n                }\\n                if(node->right)\\n                {\\n                    node->right->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->right);\\n                }\\n            }\\n            depth++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private: \\n    void getLevelSum(TreeNode* root,int depth,vector<int>& levelSum)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        if(levelSum.size()==depth)\\n        {\\n            levelSum.push_back(root->val);\\n        }\\n        else{\\n            levelSum[depth]+=root->val;\\n        }\\n        getLevelSum(root->left,depth+1,levelSum);\\n        getLevelSum(root->right,depth+1,levelSum);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getLevelSum(root,0,levelSum);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        int depth=1;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int nodeChildSum=0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left!=NULL)\\n                {\\n                    nodeChildSum+=node->left->val;\\n                }\\n                if(node->right!=NULL)\\n                {\\n                    nodeChildSum+=node->right->val;\\n                }\\n                if(node->left)\\n                {\\n                    node->left->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->left);\\n                }\\n                if(node->right)\\n                {\\n                    node->right->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->right);\\n                }\\n            }\\n            depth++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892360,
                "title": "simple-java-recursion-2-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<Integer,Integer>hm = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        fill(root, 0);\\n        modify(root,0);\\n        root.val = 0;\\n        return root;\\n    }\\n\\n    public void modify(TreeNode root, int depth){\\n        if(root == null || (root.left == null && root.right == null))return;\\n        if(root.right == null)root.left.val = hm.get(depth+1)-root.left.val;\\n        else if(root.left == null)root.right.val = hm.get(depth+1)-root.right.val;\\n        else{\\n            int temp = hm.get(depth+1)-root.left.val-root.right.val;\\n            root.left.val = temp;\\n            root.right.val = temp;\\n        }\\n        modify(root.left, depth+1);\\n        modify(root.right, depth+1);\\n    }\\n\\n    public void fill(TreeNode root, int depth){\\n        if(root == null)return;\\n        int val = hm.getOrDefault(depth,0);\\n        hm.put(depth,val+root.val);\\n        fill(root.left, depth+1);\\n        fill(root.right, depth+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<Integer,Integer>hm = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        fill(root, 0);\\n        modify(root,0);\\n        root.val = 0;\\n        return root;\\n    }\\n\\n    public void modify(TreeNode root, int depth){\\n        if(root == null || (root.left == null && root.right == null))return;\\n        if(root.right == null)root.left.val = hm.get(depth+1)-root.left.val;\\n        else if(root.left == null)root.right.val = hm.get(depth+1)-root.right.val;\\n        else{\\n            int temp = hm.get(depth+1)-root.left.val-root.right.val;\\n            root.left.val = temp;\\n            root.right.val = temp;\\n        }\\n        modify(root.left, depth+1);\\n        modify(root.right, depth+1);\\n    }\\n\\n    public void fill(TreeNode root, int depth){\\n        if(root == null)return;\\n        int val = hm.getOrDefault(depth,0);\\n        hm.put(depth,val+root.val);\\n        fill(root.left, depth+1);\\n        fill(root.right, depth+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883029,
                "title": "well-commented-c-code-dfs",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Good very good question classical dfs question\\n\\n    // Stores sum at every depth\\n    unordered_map<int,int> depthSum;\\\\\\n\\n    // Stores child ---> parent \\n    unordered_map<TreeNode* , TreeNode*> parentChild;\\n\\n    // stores sum of both the child of a parent\\n    unordered_map<TreeNode* , int> parentSum;\\n\\n    // This dfs call will actually replace the values of all the nodes with the cousins sum\\n    void dfs2(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left != NULL){\\n            dfs2(root->left , depth+1);\\n        }\\n\\n        if(root->right != NULL){\\n            dfs2(root->right , depth+1);\\n        }\\n\\n        int sum = depthSum[depth];\\n        int parentsum = 0;\\n        \\n        TreeNode* parent = parentChild[root];\\n        parentsum = parentSum[parent];\\n        \\n\\n        root->val = sum - parentsum;\\n    }\\n\\n    // Here in first dfs call we will try to fill all the three maps\\n    void dfs(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }   \\n\\n        if(root->right != NULL){\\n            depthSum[depth+1] += root->right->val;\\n            parentSum[root] += root->right->val;\\n            parentChild[root->right] = root;\\n            dfs(root->right , depth+1);\\n        }\\n\\n        if(root->left != NULL){\\n            depthSum[depth+1] += root->left->val;\\n            parentSum[root] += root->left->val;\\n            parentChild[root->left] = root;\\n            dfs(root->left , depth+1);\\n        }\\n        return;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n\\n        \\n        // We are passing root and depth\\n        parentChild[root] = NULL;\\n        depthSum[0] = root->val;\\n        parentSum[NULL] = 0;\\n        dfs(root,0);\\n        dfs2(root,0);\\n        \\n        // At final to check if root->val != 0 we replace it with zero\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Good very good question classical dfs question\\n\\n    // Stores sum at every depth\\n    unordered_map<int,int> depthSum;\\\\\\n\\n    // Stores child ---> parent \\n    unordered_map<TreeNode* , TreeNode*> parentChild;\\n\\n    // stores sum of both the child of a parent\\n    unordered_map<TreeNode* , int> parentSum;\\n\\n    // This dfs call will actually replace the values of all the nodes with the cousins sum\\n    void dfs2(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left != NULL){\\n            dfs2(root->left , depth+1);\\n        }\\n\\n        if(root->right != NULL){\\n            dfs2(root->right , depth+1);\\n        }\\n\\n        int sum = depthSum[depth];\\n        int parentsum = 0;\\n        \\n        TreeNode* parent = parentChild[root];\\n        parentsum = parentSum[parent];\\n        \\n\\n        root->val = sum - parentsum;\\n    }\\n\\n    // Here in first dfs call we will try to fill all the three maps\\n    void dfs(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }   \\n\\n        if(root->right != NULL){\\n            depthSum[depth+1] += root->right->val;\\n            parentSum[root] += root->right->val;\\n            parentChild[root->right] = root;\\n            dfs(root->right , depth+1);\\n        }\\n\\n        if(root->left != NULL){\\n            depthSum[depth+1] += root->left->val;\\n            parentSum[root] += root->left->val;\\n            parentChild[root->left] = root;\\n            dfs(root->left , depth+1);\\n        }\\n        return;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n\\n        \\n        // We are passing root and depth\\n        parentChild[root] = NULL;\\n        depthSum[0] = root->val;\\n        parentSum[NULL] = 0;\\n        dfs(root,0);\\n        dfs2(root,0);\\n        \\n        // At final to check if root->val != 0 we replace it with zero\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878642,
                "title": "readable-one-pass-solution-in-c",
                "content": "This is an attempt to make [this (original)](https://leetcode.com/problems/cousins-in-binary-tree-ii/discuss/3420010/easy-short-efficient-clean-code) solution more readable.\\n```\\nclass Solution {\\npublic:\\n    int getChildrenSum(const TreeNode* node) {\\n        return ((node->left) ? node->left->val : 0) + ((node->right) ? node->right->val : 0);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        list <TreeNode*> q;\\n        q.push_back(root);\\n        \\n        root->val = 0;\\n        \\n        while(!q.empty()) {\\n            int nextLevelSum = 0;\\n            for(const TreeNode* node : q) {\\n                nextLevelSum += getChildrenSum(node);\\n            }\\n            \\n            int len = q.size();\\n            for(int i = 1; i <= len; i++) {\\n                TreeNode* curr = q.front();\\n                q.pop_front();\\n                \\n                int currNodeChildrenSum = getChildrenSum(curr);\\n                \\n                if(curr->left) {\\n                    curr->left->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->left);\\n                }\\n                if(curr->right) {\\n                    curr->right->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->right);\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getChildrenSum(const TreeNode* node) {\\n        return ((node->left) ? node->left->val : 0) + ((node->right) ? node->right->val : 0);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        list <TreeNode*> q;\\n        q.push_back(root);\\n        \\n        root->val = 0;\\n        \\n        while(!q.empty()) {\\n            int nextLevelSum = 0;\\n            for(const TreeNode* node : q) {\\n                nextLevelSum += getChildrenSum(node);\\n            }\\n            \\n            int len = q.size();\\n            for(int i = 1; i <= len; i++) {\\n                TreeNode* curr = q.front();\\n                q.pop_front();\\n                \\n                int currNodeChildrenSum = getChildrenSum(curr);\\n                \\n                if(curr->left) {\\n                    curr->left->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->left);\\n                }\\n                if(curr->right) {\\n                    curr->right->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->right);\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876864,
                "title": "c-2-pass-dfs",
                "content": "# Intuition\\n- DFS 1 : store sum of all levels.\\n- DFS 2 : $$root -> left$$, $$root -> right$$ = `(sum of level of [root]) - sum(root->left, root->right)`\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> l;\\n    void dfs1(TreeNode* root, int h) {\\n        if(!root) return;\\n        l[h] += root->val;\\n        dfs1(root->left, h + 1);\\n        dfs1(root->right, h + 1);\\n    }\\n\\n    void dfs2(TreeNode* root, int h = 0) {\\n        if(!root) return;\\n        int s = 0, lvl = l[h + 1];\\n        if(root->left) s += root->left->val;\\n        if(root->right) s += root->right->val;\\n        if(root->left) root->left->val = lvl - s;\\n        if(root->right) root->right->val = lvl - s;\\n        dfs2(root->left, h + 1);\\n        dfs2(root->right, h + 1);\\n    } \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        l.resize(100005, 0);\\n        dfs1(root, 0);\\n        dfs2(root);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> l;\\n    void dfs1(TreeNode* root, int h) {\\n        if(!root) return;\\n        l[h] += root->val;\\n        dfs1(root->left, h + 1);\\n        dfs1(root->right, h + 1);\\n    }\\n\\n    void dfs2(TreeNode* root, int h = 0) {\\n        if(!root) return;\\n        int s = 0, lvl = l[h + 1];\\n        if(root->left) s += root->left->val;\\n        if(root->right) s += root->right->val;\\n        if(root->left) root->left->val = lvl - s;\\n        if(root->right) root->right->val = lvl - s;\\n        dfs2(root->left, h + 1);\\n        dfs2(root->right, h + 1);\\n    } \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        l.resize(100005, 0);\\n        dfs1(root, 0);\\n        dfs2(root);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860491,
                "title": "easy-cpp-solution-using-recursion-and-mapping-brute-force-solution-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void getmp(TreeNode* root, map<TreeNode*, TreeNode*> &mp, map<TreeNode*, int> &smp, vector<int> &lsum, int level){\\n        if(root == NULL) return;\\n        if(level < lsum.size())\\n                lsum[level] += root->val;\\n            else\\n                lsum.push_back(root->val);\\n        if(root->left){\\n            mp[root->left] = root;\\n            smp[root] = root->left->val;\\n            getmp(root->left, mp, smp, lsum, level+1);\\n        }\\n        if(root->right){\\n            mp[root->right] = root;\\n            smp[root] += root->right->val;\\n            getmp(root->right, mp, smp, lsum, level+1);\\n        }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL) return root;\\n        else root->val = 0;\\n        if(root->left == NULL && root->right == NULL) return root;\\n        // For storing mappping of child with parent node\\n        map<TreeNode*, TreeNode*> mp;\\n        // For storing mapping of prent node with child nodes\\' sum\\n        map<TreeNode*, int> smp;\\n        // For storing level wise sum\\n        vector<int> lsum;\\n        // Getting all the values inserted into map\\n        getmp(root, mp, smp, lsum, 0);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        int level = 0;\\n        while(!q.empty()){\\n            TreeNode* front = q.front();\\n            q.pop();\\n            if(front == NULL){\\n                if(!q.empty()){\\n                    front = q.front();\\n                    q.pop();\\n                    q.push(NULL);\\n                    level++;\\n                }\\n                else break;\\n            }\\n            front->val = lsum[level] - smp[mp[front]];\\n            if(front->left)\\n                q.push(front->left);\\n            if(front->right)\\n                q.push(front->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void getmp(TreeNode* root, map<TreeNode*, TreeNode*> &mp, map<TreeNode*, int> &smp, vector<int> &lsum, int level){\\n        if(root == NULL) return;\\n        if(level < lsum.size())\\n                lsum[level] += root->val;\\n            else\\n                lsum.push_back(root->val);\\n        if(root->left){\\n            mp[root->left] = root;\\n            smp[root] = root->left->val;\\n            getmp(root->left, mp, smp, lsum, level+1);\\n        }\\n        if(root->right){\\n            mp[root->right] = root;\\n            smp[root] += root->right->val;\\n            getmp(root->right, mp, smp, lsum, level+1);\\n        }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL) return root;\\n        else root->val = 0;\\n        if(root->left == NULL && root->right == NULL) return root;\\n        // For storing mappping of child with parent node\\n        map<TreeNode*, TreeNode*> mp;\\n        // For storing mapping of prent node with child nodes\\' sum\\n        map<TreeNode*, int> smp;\\n        // For storing level wise sum\\n        vector<int> lsum;\\n        // Getting all the values inserted into map\\n        getmp(root, mp, smp, lsum, 0);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        int level = 0;\\n        while(!q.empty()){\\n            TreeNode* front = q.front();\\n            q.pop();\\n            if(front == NULL){\\n                if(!q.empty()){\\n                    front = q.front();\\n                    q.pop();\\n                    q.push(NULL);\\n                    level++;\\n                }\\n                else break;\\n            }\\n            front->val = lsum[level] - smp[mp[front]];\\n            if(front->left)\\n                q.push(front->left);\\n            if(front->right)\\n                q.push(front->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853893,
                "title": "golang-dfs-solution-beat-90",
                "content": "# Code\\n```go\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tlevelSummation := make(map[int]int)\\n\\twalk(root, 0, levelSummation)\\n\\ttree := &TreeNode{\\n\\t\\tVal: 0,\\n\\t\\tLeft: nil,\\n\\t\\tRight: nil,\\n\\t}\\n\\tcalc(root, tree, 0, levelSummation)\\n\\treturn tree\\n}\\n\\nfunc walk(node *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevelSummation[level] += node.Val\\n\\twalk(node.Left, level+1, levelSummation)\\n\\twalk(node.Right, level+1, levelSummation)\\n}\\n\\nfunc calc(node *TreeNode, resultTree *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevel++\\n\\tval := 0\\n\\tif node.Left != nil {\\n\\t\\tval += node.Left.Val\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tval += node.Right.Val\\n\\t}\\n\\tif node.Left != nil {\\n\\t\\tresultTree.Left = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Left, resultTree.Left, level, levelSummation)\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tresultTree.Right = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Right, resultTree.Right, level, levelSummation)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tlevelSummation := make(map[int]int)\\n\\twalk(root, 0, levelSummation)\\n\\ttree := &TreeNode{\\n\\t\\tVal: 0,\\n\\t\\tLeft: nil,\\n\\t\\tRight: nil,\\n\\t}\\n\\tcalc(root, tree, 0, levelSummation)\\n\\treturn tree\\n}\\n\\nfunc walk(node *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevelSummation[level] += node.Val\\n\\twalk(node.Left, level+1, levelSummation)\\n\\twalk(node.Right, level+1, levelSummation)\\n}\\n\\nfunc calc(node *TreeNode, resultTree *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevel++\\n\\tval := 0\\n\\tif node.Left != nil {\\n\\t\\tval += node.Left.Val\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tval += node.Right.Val\\n\\t}\\n\\tif node.Left != nil {\\n\\t\\tresultTree.Left = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Left, resultTree.Left, level, levelSummation)\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tresultTree.Right = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Right, resultTree.Right, level, levelSummation)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848282,
                "title": "bfs-with-hashmap-node-siblings-sums",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        List<TreeNode> bfsQueue = new ArrayList<>();\\n        root.val = 0;\\n        bfsQueue.add(root);\\n        Map<TreeNode, Integer> parentChildrenSum = new HashMap<>();\\n\\n        while (!bfsQueue.isEmpty()) {\\n            List<TreeNode> nodesToProcessNext = new ArrayList<>();\\n            int sum = 0;\\n            for (TreeNode node : bfsQueue) {\\n                int childSum = 0;\\n                if (node.left != null) {\\n                    nodesToProcessNext.add(node.left);\\n                    childSum += node.left.val;\\n                }\\n                if (node.right != null) {\\n                    nodesToProcessNext.add(node.right);\\n                    childSum += node.right.val;\\n                }\\n\\n                if (node.left != null) {\\n                    parentChildrenSum.put(node.left, childSum);\\n                }\\n                if (node.right != null) {\\n                    parentChildrenSum.put(node.right, childSum);\\n                }\\n                sum += node.val;\\n            }\\n\\n            for (TreeNode node : bfsQueue) {\\n                node.val = sum - parentChildrenSum.getOrDefault(node, 0);\\n            }\\n\\n            bfsQueue = nodesToProcessNext;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        List<TreeNode> bfsQueue = new ArrayList<>();\\n        root.val = 0;\\n        bfsQueue.add(root);\\n        Map<TreeNode, Integer> parentChildrenSum = new HashMap<>();\\n\\n        while (!bfsQueue.isEmpty()) {\\n            List<TreeNode> nodesToProcessNext = new ArrayList<>();\\n            int sum = 0;\\n            for (TreeNode node : bfsQueue) {\\n                int childSum = 0;\\n                if (node.left != null) {\\n                    nodesToProcessNext.add(node.left);\\n                    childSum += node.left.val;\\n                }\\n                if (node.right != null) {\\n                    nodesToProcessNext.add(node.right);\\n                    childSum += node.right.val;\\n                }\\n\\n                if (node.left != null) {\\n                    parentChildrenSum.put(node.left, childSum);\\n                }\\n                if (node.right != null) {\\n                    parentChildrenSum.put(node.right, childSum);\\n                }\\n                sum += node.val;\\n            }\\n\\n            for (TreeNode node : bfsQueue) {\\n                node.val = sum - parentChildrenSum.getOrDefault(node, 0);\\n            }\\n\\n            bfsQueue = nodesToProcessNext;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844010,
                "title": "python-clean-bfs-solution",
                "content": "```python\\nfrom itertools import chain\\nfrom operator import attrgetter\\nfrom typing import Optional\\n\\nflatten = chain.from_iterable\\n\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        siblings = [[root]]\\n\\n        while siblings:\\n            self.update_siblings(siblings)\\n\\n            _siblings = []  # solution structure requires do-while loop\\n\\n            for parent in flatten(siblings):\\n                _siblings.append(children := [])\\n\\n                if parent.left:\\n                    children.append(parent.left)\\n\\n                if parent.right:\\n                    children.append(parent.right)\\n\\n            siblings = _siblings\\n\\n        return root\\n\\n    @staticmethod\\n    def update_siblings(siblings: list[list[TreeNode]]):\\n        \"\"\"\\n        if i and j be two value index in \"siblings\" and i != j then nodes in siblings[i]\\n        are sibling to nodes in siblings[j]\\n        :param siblings:\\n        \"\"\"\\n        values = [Solution.total_sum_of_node_values(children) for children in siblings]\\n        total = sum(values)\\n\\n        for children, child_val_sum in zip(siblings, values):\\n            sibling_val_sum = total - child_val_sum\\n\\n            for child in children:\\n                child.val = sibling_val_sum\\n\\n    @staticmethod\\n    def total_sum_of_node_values(nodes: list[TreeNode]) -> int:\\n        return sum(map(attrgetter(\\'val\\'), nodes))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nfrom itertools import chain\\nfrom operator import attrgetter\\nfrom typing import Optional\\n\\nflatten = chain.from_iterable\\n\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        siblings = [[root]]\\n\\n        while siblings:\\n            self.update_siblings(siblings)\\n\\n            _siblings = []  # solution structure requires do-while loop\\n\\n            for parent in flatten(siblings):\\n                _siblings.append(children := [])\\n\\n                if parent.left:\\n                    children.append(parent.left)\\n\\n                if parent.right:\\n                    children.append(parent.right)\\n\\n            siblings = _siblings\\n\\n        return root\\n\\n    @staticmethod\\n    def update_siblings(siblings: list[list[TreeNode]]):\\n        \"\"\"\\n        if i and j be two value index in \"siblings\" and i != j then nodes in siblings[i]\\n        are sibling to nodes in siblings[j]\\n        :param siblings:\\n        \"\"\"\\n        values = [Solution.total_sum_of_node_values(children) for children in siblings]\\n        total = sum(values)\\n\\n        for children, child_val_sum in zip(siblings, values):\\n            sibling_val_sum = total - child_val_sum\\n\\n            for child in children:\\n                child.val = sibling_val_sum\\n\\n    @staticmethod\\n    def total_sum_of_node_values(nodes: list[TreeNode]) -> int:\\n        return sum(map(attrgetter(\\'val\\'), nodes))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841705,
                "title": "c-easy-to-understand-simple-traversal-to-store-sum-on-level-basis",
                "content": "First I am storing sum of nodes on level basis and keeping track of parent and its child. We can avoi storing parents too. And in the I am subtracting all sblings from sum so that we can get sum of cousins.\\n\\n```\\nvoid solve(TreeNode* root, TreeNode* parent, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent, int l){\\n        if(!root){\\n            return;\\n        }\\n        mpLevel[l] += root->val;\\n        mpParent[root] = parent;\\n        solve(root->left,root,mpLevel,mpParent,l+1);\\n        solve(root->right,root,mpLevel,mpParent,l+1);\\n    }\\n    void traverse(TreeNode* root, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent,unordered_map<TreeNode*,int> &cousinValue, int l){\\n        if(!root){\\n            return;\\n        }\\n        int s=0;\\n        s = mpLevel[l];\\n        TreeNode* parent = mpParent[root];\\n        if(!parent){\\n            s = s - root->val;\\n        }else{\\n            if(parent->left){\\n                s = s - parent->left->val;\\n            }\\n            if(parent->right){\\n                s = s - parent->right->val;\\n            }\\n        }\\n        cousinValue[root] = s;\\n        \\n        traverse(root->left,mpLevel,mpParent,cousinValue,l+1);\\n        traverse(root->right,mpLevel,mpParent,cousinValue,l+1);\\n    }\\n    void fillCousinValue(TreeNode* root, unordered_map<TreeNode*,int> &cousinValue){\\n        if(!root){\\n            return;\\n        }\\n        \\n        root->val = cousinValue[root];\\n        fillCousinValue(root->left,cousinValue);\\n        fillCousinValue(root->right,cousinValue);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mpLevel;\\n        unordered_map<TreeNode*,TreeNode*> mpParent;\\n        unordered_map<TreeNode*,int> cousinValue;\\n\\n        solve(root,nullptr,mpLevel,mpParent,1);\\n        traverse(root,mpLevel,mpParent,cousinValue,1);\\n        fillCousinValue(root,cousinValue);\\n        return root;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nvoid solve(TreeNode* root, TreeNode* parent, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent, int l){\\n        if(!root){\\n            return;\\n        }\\n        mpLevel[l] += root->val;\\n        mpParent[root] = parent;\\n        solve(root->left,root,mpLevel,mpParent,l+1);\\n        solve(root->right,root,mpLevel,mpParent,l+1);\\n    }\\n    void traverse(TreeNode* root, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent,unordered_map<TreeNode*,int> &cousinValue, int l){\\n        if(!root){\\n            return;\\n        }\\n        int s=0;\\n        s = mpLevel[l];\\n        TreeNode* parent = mpParent[root];\\n        if(!parent){\\n            s = s - root->val;\\n        }else{\\n            if(parent->left){\\n                s = s - parent->left->val;\\n            }\\n            if(parent->right){\\n                s = s - parent->right->val;\\n            }\\n        }\\n        cousinValue[root] = s;\\n        \\n        traverse(root->left,mpLevel,mpParent,cousinValue,l+1);\\n        traverse(root->right,mpLevel,mpParent,cousinValue,l+1);\\n    }\\n    void fillCousinValue(TreeNode* root, unordered_map<TreeNode*,int> &cousinValue){\\n        if(!root){\\n            return;\\n        }\\n        \\n        root->val = cousinValue[root];\\n        fillCousinValue(root->left,cousinValue);\\n        fillCousinValue(root->right,cousinValue);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mpLevel;\\n        unordered_map<TreeNode*,TreeNode*> mpParent;\\n        unordered_map<TreeNode*,int> cousinValue;\\n\\n        solve(root,nullptr,mpLevel,mpParent,1);\\n        traverse(root,mpLevel,mpParent,cousinValue,1);\\n        fillCousinValue(root,cousinValue);\\n        return root;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3829849,
                "title": "easy-to-read-bfs-solution",
                "content": "bfs\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\'\\'\\'\\nGiven the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins\\' values.\\nSo if you are given a tree with 3 pairs of cousins\\nIt will be the sum of the other two \\n\\nIDEA:\\n\\n    Level_sum - children_sum = sum_of_cousins\\n\\n    level_sum = sum of all the children in that level \\n    children_sum = given parent and its children: sum the children\\n\\n\\nBFS:\\n    Maintain level sum\\n    When working with current level : Maintain / build up sum for the next level\\n    That way, when working with that next level, we have that sum to begin with \\n\\n    CAVEAT:\\n        When encountering parents with left and right children:\\n            We need to update their values to be the sum \\n\\n            why?\\n            Those values will be the same to begin with \\n            solves many gaps of this problem\\n                level 1 == 0 \\n\\'\\'\\'\\n\\nfrom collections import deque\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        que = deque()\\n        que.append(root)\\n        level_sum = root.val \\n        while que:\\n            length = len(que)\\n            next_level_sum = 0\\n            for i in range(length):\\n                node = que.popleft()\\n                #update node value with cousins sum \\n                node.val = level_sum - node.val\\n\\n                #get next level sum to work with \\n                if node.left:\\n                    next_level_sum += node.left.val\\n                    que.append(node.left)\\n                \\n                if node.right:\\n                    next_level_sum += node.right.val\\n                    que.append(node.right)\\n                \\n                #CAVEAT updating values for parents with two kids \\n                if node.left and node.right:\\n                    children_sum = node.left.val + node.right.val\\n                    node.left.val = children_sum\\n                    node.right.val = children_sum\\n            \\n            level_sum = next_level_sum\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\'\\'\\'\\nGiven the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins\\' values.\\nSo if you are given a tree with 3 pairs of cousins\\nIt will be the sum of the other two \\n\\nIDEA:\\n\\n    Level_sum - children_sum = sum_of_cousins\\n\\n    level_sum = sum of all the children in that level \\n    children_sum = given parent and its children: sum the children\\n\\n\\nBFS:\\n    Maintain level sum\\n    When working with current level : Maintain / build up sum for the next level\\n    That way, when working with that next level, we have that sum to begin with \\n\\n    CAVEAT:\\n        When encountering parents with left and right children:\\n            We need to update their values to be the sum \\n\\n            why?\\n            Those values will be the same to begin with \\n            solves many gaps of this problem\\n                level 1 == 0 \\n\\'\\'\\'\\n\\nfrom collections import deque\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        que = deque()\\n        que.append(root)\\n        level_sum = root.val \\n        while que:\\n            length = len(que)\\n            next_level_sum = 0\\n            for i in range(length):\\n                node = que.popleft()\\n                #update node value with cousins sum \\n                node.val = level_sum - node.val\\n\\n                #get next level sum to work with \\n                if node.left:\\n                    next_level_sum += node.left.val\\n                    que.append(node.left)\\n                \\n                if node.right:\\n                    next_level_sum += node.right.val\\n                    que.append(node.right)\\n                \\n                #CAVEAT updating values for parents with two kids \\n                if node.left and node.right:\\n                    children_sum = node.left.val + node.right.val\\n                    node.left.val = children_sum\\n                    node.right.val = children_sum\\n            \\n            level_sum = next_level_sum\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825495,
                "title": "python3-level-order-traversal-beats-100",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        prev,curr = [],[root]\\n\\n        while curr:\\n            sums = []\\n            for node in curr:\\n                s = 0\\n                if node.left: s += node.left.val\\n                if node.right: s += node.right.val\\n                sums.append(s)\\n\\n            total = sum(sums)\\n            for i,node in enumerate(curr):\\n                if node.left: node.left.val = total - sums[i]\\n                if node.right: node.right.val = total - sums[i]\\n\\n            prev,curr = curr, [child for node in curr for child in [node.left,node.right] if child]\\n\\n        root.val = 0\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        prev,curr = [],[root]\\n\\n        while curr:\\n            sums = []\\n            for node in curr:\\n                s = 0\\n                if node.left: s += node.left.val\\n                if node.right: s += node.right.val\\n                sums.append(s)\\n\\n            total = sum(sums)\\n            for i,node in enumerate(curr):\\n                if node.left: node.left.val = total - sums[i]\\n                if node.right: node.right.val = total - sums[i]\\n\\n            prev,curr = curr, [child for node in curr for child in [node.left,node.right] if child]\\n\\n        root.val = 0\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820213,
                "title": "easy-bfs-solution-c-just-addition-and-subtraction-from-sum-of-levels",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// #include <queue>\\n// #include <vector>\\n// #include <cmath>\\n\\n// struct TreeNode {\\n//     int val;\\n//     TreeNode *left;\\n//     TreeNode *right;\\n//     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n// };\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (root == nullptr) \\n        {\\n            return nullptr;\\n        }\\n\\n        queue<TreeNode*> q;\\n        vector<int> sumL;\\n        int sum = 0;\\n\\n        q.push(root);\\n        while (!q.empty()) \\n        {\\n            int size = q.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q.front();\\n                sum += t->val;\\n                q.pop();\\n                if (t->left) \\n                {\\n                    q.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q.push(t->right);\\n                }\\n            }\\n            sumL.push_back(sum);\\n            sum = 0;\\n        }\\n\\n\\n        queue<TreeNode*> q1; \\n        q1.push(root);\\n        int i = 0;\\n        while (!q1.empty()) \\n        {\\n            int size = q1.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q1.front();\\n                q1.pop();\\n                 t->val = abs(t->val - sumL[i]);\\n                if (t->left && t->right) \\n                {\\n                    int l=t->left->val;\\n                    int r=t->right->val;\\n                    t->left->val = l + r;\\n                    t->right->val = r + l;\\n                }\\n                if (t->left) \\n                {\\n                    q1.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q1.push(t->right);\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// #include <queue>\\n// #include <vector>\\n// #include <cmath>\\n\\n// struct TreeNode {\\n//     int val;\\n//     TreeNode *left;\\n//     TreeNode *right;\\n//     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n// };\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (root == nullptr) \\n        {\\n            return nullptr;\\n        }\\n\\n        queue<TreeNode*> q;\\n        vector<int> sumL;\\n        int sum = 0;\\n\\n        q.push(root);\\n        while (!q.empty()) \\n        {\\n            int size = q.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q.front();\\n                sum += t->val;\\n                q.pop();\\n                if (t->left) \\n                {\\n                    q.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q.push(t->right);\\n                }\\n            }\\n            sumL.push_back(sum);\\n            sum = 0;\\n        }\\n\\n\\n        queue<TreeNode*> q1; \\n        q1.push(root);\\n        int i = 0;\\n        while (!q1.empty()) \\n        {\\n            int size = q1.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q1.front();\\n                q1.pop();\\n                 t->val = abs(t->val - sumL[i]);\\n                if (t->left && t->right) \\n                {\\n                    int l=t->left->val;\\n                    int r=t->right->val;\\n                    t->left->val = l + r;\\n                    t->right->val = r + l;\\n                }\\n                if (t->left) \\n                {\\n                    q1.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q1.push(t->right);\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3818772,
                "title": "c-simple-solution-using-level-order-and-parent-mapping",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ParentMapping(TreeNode* root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    if(root==NULL)\\n    return;\\n    if(root->left==NULL && root->right==NULL)\\n    return;\\n\\n    if(root->left){\\n        TreeNode* child = root->left;\\n        parent[child] = root;\\n        ParentMapping(root->left, parent);\\n    }\\n    if(root->right){\\n        TreeNode* child = root->right;\\n        parent[child] = root;\\n        ParentMapping(root->right, parent);\\n    }\\n}\\n\\nvoid levelOrder(TreeNode* &root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    queue<TreeNode*> q;\\n    q.push(root);\\n\\n    while(!q.empty()){\\n        \\n        unordered_map<TreeNode*, int> mp;\\n        int sum = 0;\\n        queue<TreeNode*> temp;\\n        int n = q.size();\\n\\n        for(int i=0 ;i<n ;i++){\\n            TreeNode* frt = q.front();\\n            q.pop();\\n\\n            temp.push(frt);\\n            sum += frt->val;\\n\\n            if(mp.find(parent[frt]) == mp.end())\\n            mp[parent[frt]] = frt->val;\\n            else\\n            mp[parent[frt]] = mp[parent[frt]]+frt->val;\\n\\n            if(frt->left)\\n            q.push(frt->left);\\n            if(frt->right)\\n            q.push(frt->right);\\n        }\\n        \\n        while(!temp.empty()){\\n            TreeNode* frt = temp.front();\\n            temp.pop();\\n\\n            frt->val = sum-mp[parent[frt]];\\n        }\\n    }\\n    return;\\n}\\n\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root] = new TreeNode(-1);\\n        ParentMapping(root, parent);\\n\\n        int depthX = -1, depthY = -1;\\n        levelOrder(root, parent);\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ParentMapping(TreeNode* root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    if(root==NULL)\\n    return;\\n    if(root->left==NULL && root->right==NULL)\\n    return;\\n\\n    if(root->left){\\n        TreeNode* child = root->left;\\n        parent[child] = root;\\n        ParentMapping(root->left, parent);\\n    }\\n    if(root->right){\\n        TreeNode* child = root->right;\\n        parent[child] = root;\\n        ParentMapping(root->right, parent);\\n    }\\n}\\n\\nvoid levelOrder(TreeNode* &root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    queue<TreeNode*> q;\\n    q.push(root);\\n\\n    while(!q.empty()){\\n        \\n        unordered_map<TreeNode*, int> mp;\\n        int sum = 0;\\n        queue<TreeNode*> temp;\\n        int n = q.size();\\n\\n        for(int i=0 ;i<n ;i++){\\n            TreeNode* frt = q.front();\\n            q.pop();\\n\\n            temp.push(frt);\\n            sum += frt->val;\\n\\n            if(mp.find(parent[frt]) == mp.end())\\n            mp[parent[frt]] = frt->val;\\n            else\\n            mp[parent[frt]] = mp[parent[frt]]+frt->val;\\n\\n            if(frt->left)\\n            q.push(frt->left);\\n            if(frt->right)\\n            q.push(frt->right);\\n        }\\n        \\n        while(!temp.empty()){\\n            TreeNode* frt = temp.front();\\n            temp.pop();\\n\\n            frt->val = sum-mp[parent[frt]];\\n        }\\n    }\\n    return;\\n}\\n\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root] = new TreeNode(-1);\\n        ParentMapping(root, parent);\\n\\n        int depthX = -1, depthY = -1;\\n        levelOrder(root, parent);\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813889,
                "title": "using-hashmap-and-level-order",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root==null)return root;\\n       HashMap<Integer,Integer> map=new HashMap<>();\\n       int lvl=0;\\n       Queue <TreeNode> q=new ArrayDeque<>();\\n        if(root!=null)\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            int max=0;\\n\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                max+=curr.val;\\n                if(curr.left!=null)\\n                {\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    q.offer(curr.right);\\n                }\\n            }map.put(lvl,max);  \\n            lvl++;\\n        }\\n        lvl=0;\\n        root.val=0;\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                int sum=0;\\n                if(curr.left!=null)\\n                {\\n                    sum+=curr.left.val;\\n                }\\n                if(curr.right!=null)\\n                {\\n                    sum+=curr.right.val;\\n                }\\n                 if(curr.left!=null)\\n                {\\n                    curr.left.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    curr.right.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.right);\\n                }\\n            } \\n            lvl++;\\n        }\\n      \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root==null)return root;\\n       HashMap<Integer,Integer> map=new HashMap<>();\\n       int lvl=0;\\n       Queue <TreeNode> q=new ArrayDeque<>();\\n        if(root!=null)\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            int max=0;\\n\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                max+=curr.val;\\n                if(curr.left!=null)\\n                {\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    q.offer(curr.right);\\n                }\\n            }map.put(lvl,max);  \\n            lvl++;\\n        }\\n        lvl=0;\\n        root.val=0;\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                int sum=0;\\n                if(curr.left!=null)\\n                {\\n                    sum+=curr.left.val;\\n                }\\n                if(curr.right!=null)\\n                {\\n                    sum+=curr.right.val;\\n                }\\n                 if(curr.left!=null)\\n                {\\n                    curr.left.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    curr.right.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.right);\\n                }\\n            } \\n            lvl++;\\n        }\\n      \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813678,
                "title": "c-solution-using-inorder-and-level-order-traversal-beats-89-15",
                "content": "# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root, vector<long long> &v, int level){\\n        if(root == nullptr){\\n            return;\\n        }\\n        int sum = 0;\\n        if(root->left){\\n            sum += root->left->val;\\n        }\\n        if(root->right){\\n            sum += root->right->val;\\n        }\\n        if(root->left){\\n            root->left->val = v[level] - sum;\\n        }\\n        if(root->right){\\n            root->right->val = v[level] - sum;\\n        }\\n        solve(root->left, v, level+1);\\n        solve(root->right, v, level+1);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> v;\\n        int level = 1;\\n        kthLargestLevelSum(root, v);\\n        if(root){\\n            root->val = 0;\\n        }\\n        solve(root, v, level);\\n        return root;\\n    }\\n    void kthLargestLevelSum(TreeNode* root, vector<long long> &v) {\\n        queue<TreeNode*> q;\\n        long long sum = 0;\\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node == nullptr){\\n                v.push_back(sum);\\n                sum = 0;\\n                if(!q.empty()){\\n                    q.push(nullptr);\\n                }\\n            }else{\\n                sum += node->val;\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root, vector<long long> &v, int level){\\n        if(root == nullptr){\\n            return;\\n        }\\n        int sum = 0;\\n        if(root->left){\\n            sum += root->left->val;\\n        }\\n        if(root->right){\\n            sum += root->right->val;\\n        }\\n        if(root->left){\\n            root->left->val = v[level] - sum;\\n        }\\n        if(root->right){\\n            root->right->val = v[level] - sum;\\n        }\\n        solve(root->left, v, level+1);\\n        solve(root->right, v, level+1);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> v;\\n        int level = 1;\\n        kthLargestLevelSum(root, v);\\n        if(root){\\n            root->val = 0;\\n        }\\n        solve(root, v, level);\\n        return root;\\n    }\\n    void kthLargestLevelSum(TreeNode* root, vector<long long> &v) {\\n        queue<TreeNode*> q;\\n        long long sum = 0;\\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node == nullptr){\\n                v.push_back(sum);\\n                sum = 0;\\n                if(!q.empty()){\\n                    q.push(nullptr);\\n                }\\n            }else{\\n                sum += node->val;\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806098,
                "title": "c-bfs-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        \\n        \\n        while(q.empty()==false){\\n            int n=q.size();\\n            int sum=0;\\n            vector<TreeNode*> childs;\\n            for(int i=0;i<n;i++){\\n                auto node=q.front();\\n                q.pop();\\n                childs.push_back(node);\\n                if(node->left){\\n                    q.push(node->left);\\n                    sum+=node->left->val;\\n                    // childs.push_back(node->left);\\n                }\\n                \\n                if(node->right){\\n                    q.push(node->right);\\n                    sum+=node->right->val;\\n                    // childs.push_back(node->right);\\n                }\\n                \\n            }\\n            \\n            for(auto child:childs){\\n                int dummySum=sum;\\n                // cout<<sum<<\"\\\\n\";\\n                if(child->left){\\n                    dummySum-=child->left->val;\\n                }\\n                \\n                if(child->right){\\n                    dummySum-=child->right->val;\\n                }\\n                if(child->left){\\n                    child->left->val=dummySum;\\n                }\\n                if(child->right){\\n                    child->right->val=dummySum;\\n                }\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        \\n        \\n        while(q.empty()==false){\\n            int n=q.size();\\n            int sum=0;\\n            vector<TreeNode*> childs;\\n            for(int i=0;i<n;i++){\\n                auto node=q.front();\\n                q.pop();\\n                childs.push_back(node);\\n                if(node->left){\\n                    q.push(node->left);\\n                    sum+=node->left->val;\\n                    // childs.push_back(node->left);\\n                }\\n                \\n                if(node->right){\\n                    q.push(node->right);\\n                    sum+=node->right->val;\\n                    // childs.push_back(node->right);\\n                }\\n                \\n            }\\n            \\n            for(auto child:childs){\\n                int dummySum=sum;\\n                // cout<<sum<<\"\\\\n\";\\n                if(child->left){\\n                    dummySum-=child->left->val;\\n                }\\n                \\n                if(child->right){\\n                    dummySum-=child->right->val;\\n                }\\n                if(child->left){\\n                    child->left->val=dummySum;\\n                }\\n                if(child->right){\\n                    child->right->val=dummySum;\\n                }\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3800491,
                "title": "c-bfs-o-n-one-traversal-super-easy-solution-using-child-sum-and-current-and-last-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2^H)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return root;\\n        queue<pair<TreeNode*,long long int>> q;\\n        q.push({root,root->val});\\n        int long long lastSum=root->val;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            long long int currSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                auto it=q.front();\\n                TreeNode* currNode=it.first;\\n                q.pop();\\n                long long int childSum=0;\\n                if(currNode->left) childSum+=currNode->left->val;\\n                if(currNode->right) childSum+=currNode->right->val;\\n                currSum+=childSum;\\n                if(currNode->left) q.push({currNode->left,childSum});\\n                if(currNode->right)q.push({currNode->right,childSum});\\n                currNode->val=abs(lastSum-it.second);\\n            }\\n            lastSum=currSum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return root;\\n        queue<pair<TreeNode*,long long int>> q;\\n        q.push({root,root->val});\\n        int long long lastSum=root->val;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            long long int currSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                auto it=q.front();\\n                TreeNode* currNode=it.first;\\n                q.pop();\\n                long long int childSum=0;\\n                if(currNode->left) childSum+=currNode->left->val;\\n                if(currNode->right) childSum+=currNode->right->val;\\n                currSum+=childSum;\\n                if(currNode->left) q.push({currNode->left,childSum});\\n                if(currNode->right)q.push({currNode->right,childSum});\\n                currNode->val=abs(lastSum-it.second);\\n            }\\n            lastSum=currSum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789552,
                "title": "easy-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity:\\nO(h) , h=height of the binary tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   void rec(TreeNode* node,int sum,vector<int>&v,int level)\\n   {\\n       if (!node) return;\\n       node->val=v[level]-sum;\\n       int cur=0;\\n       if (node->left) cur+=node->left->val;\\n       if (node->right) cur+=node->right->val;\\n       rec(node->left,cur,v,level+1);\\n       rec(node->right,cur,v,level+1);\\n\\n   }\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       vector<int>v;\\n       while(!q.empty())\\n       {\\n           int sz=q.size();\\n           int sum=0;\\n           while(sz--)\\n           {\\n               TreeNode* node=q.front();\\n               q.pop();\\n               sum+=node->val;\\n               if (node->left)\\n               {\\n                   q.push(node->left);\\n               }\\n               if (node->right)\\n               {\\n                   q.push(node->right);\\n               }\\n           }\\n           v.push_back(sum);\\n       }\\n       rec(root,root->val,v,0);\\n       return root;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   void rec(TreeNode* node,int sum,vector<int>&v,int level)\\n   {\\n       if (!node) return;\\n       node->val=v[level]-sum;\\n       int cur=0;\\n       if (node->left) cur+=node->left->val;\\n       if (node->right) cur+=node->right->val;\\n       rec(node->left,cur,v,level+1);\\n       rec(node->right,cur,v,level+1);\\n\\n   }\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       vector<int>v;\\n       while(!q.empty())\\n       {\\n           int sz=q.size();\\n           int sum=0;\\n           while(sz--)\\n           {\\n               TreeNode* node=q.front();\\n               q.pop();\\n               sum+=node->val;\\n               if (node->left)\\n               {\\n                   q.push(node->left);\\n               }\\n               if (node->right)\\n               {\\n                   q.push(node->right);\\n               }\\n           }\\n           v.push_back(sum);\\n       }\\n       rec(root,root->val,v,0);\\n       return root;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785332,
                "title": "python-medium",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        alias = root\\n        \\n        q = deque()\\n        q.append((root, None, 0))\\n        \\n        level = 0\\n        \\n        \\n        while q:\\n            \\n            nxt = deque()\\n            \\n            \\n            total = 0\\n            \\n            for n, par, other in q:\\n                total += n.val\\n                \\n                \\n            \\n            while q:\\n                node, par, otherVal = q.popleft()\\n                \\n                \\n                        \\n                node.val = total - node.val - otherVal\\n                \\n                \\n                if node.left and node.right:\\n                    nxt.append((node.left, node, node.right.val))\\n                    nxt.append((node.right, node, node.left.val))\\n                    \\n                elif node.left:\\n                    nxt.append((node.left, node, 0))\\n                    \\n                elif node.right:\\n                    nxt.append((node.right, node, 0))\\n                    \\n                \\n                \\n                \\n        \\n        \\n            \\n            q = nxt\\n            level += 1\\n            \\n        \\n        return alias\\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        alias = root\\n        \\n        q = deque()\\n        q.append((root, None, 0))\\n        \\n        level = 0\\n        \\n        \\n        while q:\\n            \\n            nxt = deque()\\n            \\n            \\n            total = 0\\n            \\n            for n, par, other in q:\\n                total += n.val\\n                \\n                \\n            \\n            while q:\\n                node, par, otherVal = q.popleft()\\n                \\n                \\n                        \\n                node.val = total - node.val - otherVal\\n                \\n                \\n                if node.left and node.right:\\n                    nxt.append((node.left, node, node.right.val))\\n                    nxt.append((node.right, node, node.left.val))\\n                    \\n                elif node.left:\\n                    nxt.append((node.left, node, 0))\\n                    \\n                elif node.right:\\n                    nxt.append((node.right, node, 0))\\n                    \\n                \\n                \\n                \\n        \\n        \\n            \\n            q = nxt\\n            level += 1\\n            \\n        \\n        return alias\\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784425,
                "title": "2-times-bfs-level-order-traversal-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst calulcate level order sum and store in map then replace values by calculating children sum and substracting it from children\\'s level sum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe use one map to store sum of all nodes at a level and one queue for doing level order traversal/BFS.\\nfirst calulcate level order sum and store in map,set root\\'s value to zero, then replace values by calculating children sum and substracting it from children\\'s level sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q); \\n    void changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q);\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        CalculateLevelSum(mp,q);\\n        root->val=0;\\n        q.push(root);\\n        changeValues(mp,q);\\n        return root;\\n    }\\n};\\nvoid Solution::CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size(),sum=0;\\n        while(n--)\\n        {\\n            TreeNode *f=q.front();\\n            q.pop();\\n            sum+=f->val;\\n            if(f->left)\\n                q.push(f->left);\\n            if(f->right)\\n                q.push(f->right);\\n        }\\n        mp[level]=sum;\\n        level++;\\n    }\\n}\\nvoid Solution::changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size();\\n        while(n--)\\n        {\\n            int sum=0;\\n            TreeNode *f=q.front();\\n            q.pop();\\n            if(f->left) sum+=f->left->val;\\n            if(f->right) sum+=f->right->val;\\n            if(f->left)\\n            {\\n                f->left->val=mp[level+1]-sum;\\n                q.push(f->left);\\n            }\\n            if(f->right)\\n            {\\n                f->right->val=mp[level+1]-sum;\\n                q.push(f->right);\\n            } \\n        }\\n        level++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q); \\n    void changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q);\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        CalculateLevelSum(mp,q);\\n        root->val=0;\\n        q.push(root);\\n        changeValues(mp,q);\\n        return root;\\n    }\\n};\\nvoid Solution::CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size(),sum=0;\\n        while(n--)\\n        {\\n            TreeNode *f=q.front();\\n            q.pop();\\n            sum+=f->val;\\n            if(f->left)\\n                q.push(f->left);\\n            if(f->right)\\n                q.push(f->right);\\n        }\\n        mp[level]=sum;\\n        level++;\\n    }\\n}\\nvoid Solution::changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size();\\n        while(n--)\\n        {\\n            int sum=0;\\n            TreeNode *f=q.front();\\n            q.pop();\\n            if(f->left) sum+=f->left->val;\\n            if(f->right) sum+=f->right->val;\\n            if(f->left)\\n            {\\n                f->left->val=mp[level+1]-sum;\\n                q.push(f->left);\\n            }\\n            if(f->right)\\n            {\\n                f->right->val=mp[level+1]-sum;\\n                q.push(f->right);\\n            } \\n        }\\n        level++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780429,
                "title": "python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\nclass Solution:\\n    def dfs(self, root, parent, level_sum, depth, clone):\\n        if root is None:\\n            return\\n        if parent is None:\\n            clone.val = 0\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n        else:\\n            siblings_sum = 0\\n            if parent.left:\\n                siblings_sum+=parent.left.val\\n            if parent.right:\\n                siblings_sum+=parent.right.val\\n            cousins_sum = level_sum[depth] - siblings_sum\\n            clone.val = cousins_sum\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n            \\n    def copy_tree(self, root):\\n        if root is None:\\n            return None\\n        new_node = TreeNode(root.val)\\n        new_node.left = self.copy_tree(root.left)\\n        new_node.right = self.copy_tree(root.right)\\n        return new_node\\n    \\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum = {}\\n        q = Queue(maxsize=0)\\n        q.put(root)\\n        depth = 0\\n        while q.empty() is False:\\n            curr_nodes = []\\n            while q.empty() is False:\\n                crr = q.get()\\n                curr_nodes.append(crr)\\n            sum = 0\\n            for x in curr_nodes:\\n                sum = sum + x.val\\n            level_sum[depth] = sum\\n            for x in curr_nodes:\\n                if x.left is not None:\\n                    q.put(x.left)\\n                if x.right is not None:\\n                    q.put(x.right)\\n            depth+=1\\n        #print(level_sum)\\n        clone = self.copy_tree(root)\\n        self.dfs(root, None, level_sum, 0, clone)\\n        return clone\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\nclass Solution:\\n    def dfs(self, root, parent, level_sum, depth, clone):\\n        if root is None:\\n            return\\n        if parent is None:\\n            clone.val = 0\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n        else:\\n            siblings_sum = 0\\n            if parent.left:\\n                siblings_sum+=parent.left.val\\n            if parent.right:\\n                siblings_sum+=parent.right.val\\n            cousins_sum = level_sum[depth] - siblings_sum\\n            clone.val = cousins_sum\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n            \\n    def copy_tree(self, root):\\n        if root is None:\\n            return None\\n        new_node = TreeNode(root.val)\\n        new_node.left = self.copy_tree(root.left)\\n        new_node.right = self.copy_tree(root.right)\\n        return new_node\\n    \\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum = {}\\n        q = Queue(maxsize=0)\\n        q.put(root)\\n        depth = 0\\n        while q.empty() is False:\\n            curr_nodes = []\\n            while q.empty() is False:\\n                crr = q.get()\\n                curr_nodes.append(crr)\\n            sum = 0\\n            for x in curr_nodes:\\n                sum = sum + x.val\\n            level_sum[depth] = sum\\n            for x in curr_nodes:\\n                if x.left is not None:\\n                    q.put(x.left)\\n                if x.right is not None:\\n                    q.put(x.right)\\n            depth+=1\\n        #print(level_sum)\\n        clone = self.copy_tree(root)\\n        self.dfs(root, None, level_sum, 0, clone)\\n        return clone\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776780,
                "title": "c-solution-using-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,vector<pair<TreeNode*,int>>> m;\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        traverse(root, 0, NULL);\\n        cousinSum(root, 0, NULL);\\n        return root;\\n    }\\n\\n    void traverse(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        \\n        m[d].push_back(make_pair(prev, r->val));\\n        \\n        traverse(r->left, d+1, r);\\n        traverse(r->right, d+1, r);\\n    }\\n\\n    void cousinSum(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        int sum = 0;\\n        for(auto it : m[d]){\\n            if(it.first != prev && prev != NULL) sum += it.second;\\n        }\\n        r->val = sum;\\n        cousinSum(r->left, d + 1, r);\\n        cousinSum(r->right, d + 1, r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,vector<pair<TreeNode*,int>>> m;\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        traverse(root, 0, NULL);\\n        cousinSum(root, 0, NULL);\\n        return root;\\n    }\\n\\n    void traverse(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        \\n        m[d].push_back(make_pair(prev, r->val));\\n        \\n        traverse(r->left, d+1, r);\\n        traverse(r->right, d+1, r);\\n    }\\n\\n    void cousinSum(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        int sum = 0;\\n        for(auto it : m[d]){\\n            if(it.first != prev && prev != NULL) sum += it.second;\\n        }\\n        r->val = sum;\\n        cousinSum(r->left, d + 1, r);\\n        cousinSum(r->right, d + 1, r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770660,
                "title": "level-ordertraversal-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void func(TreeNode *root,int sum,int h,vector<int>&presum)\\n    {\\n        if(root==NULL)\\n            return;\\n        int tmp=0;\\n        if(root->right!=NULL)\\n            tmp+=root->right->val;\\n        if(root->left!=NULL)\\n            tmp+=root->left->val;\\n        root->val=presum[h]-sum;\\n        func(root->left,tmp,h+1,presum);\\n        func(root->right,tmp,h+1,presum);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>presum;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* node=q.front();\\n                q.pop();\\n                sum+=node->val;\\n\\n                if(node->left!=NULL)\\n                    q.push(node->left);\\n\\n                if(node->right!=NULL)\\n                    q.push(node->right);\\n            }\\n            presum.push_back(sum);\\n        }\\n     \\n        func(root,root->val,0,presum);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void func(TreeNode *root,int sum,int h,vector<int>&presum)\\n    {\\n        if(root==NULL)\\n            return;\\n        int tmp=0;\\n        if(root->right!=NULL)\\n            tmp+=root->right->val;\\n        if(root->left!=NULL)\\n            tmp+=root->left->val;\\n        root->val=presum[h]-sum;\\n        func(root->left,tmp,h+1,presum);\\n        func(root->right,tmp,h+1,presum);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>presum;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* node=q.front();\\n                q.pop();\\n                sum+=node->val;\\n\\n                if(node->left!=NULL)\\n                    q.push(node->left);\\n\\n                if(node->right!=NULL)\\n                    q.push(node->right);\\n            }\\n            presum.push_back(sum);\\n        }\\n     \\n        func(root,root->val,0,presum);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765298,
                "title": "python-bfs-o-n-no-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing BFS to access nodes level by level. Calculate the sum of each level in first iteration, and subtract the value of `currrent node and its brother` to get the `cousin sum` in second iteration.\\n\\nInstead of using a deque, I use two variables, `cur_level` and `next_level`. This is also a queue because we append children to `next_level` while iterating `cur_level`, and disregard the original `cur_level` and reassign `next_level` to `cur_level` when iteration is done.\\n\\n**First For-Loop:**\\nCalculate the sum of current level, and append the children along with sum of its left child\\'s value and right child\\'s value. If a child is missing, we treat its value as 0. The reason we push the sum of children is `cousin_sum = level_sum - brother_sum`.\\n\\n**Second For-Loop:**\\nUse the formula `cousin_sum = level_sum - brother_sum` to get the cousin sum for each node and update the value of each node.\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # find cur level sum\\n        # when pushing the node, push the sum of its brother also, so we can get the sum of cousins by substracting it\\n        \\n        cur_level, next_level = [[root, root.val]], []\\n        while cur_level:\\n            level_sum = 0\\n            # calculate current level sum and push the next level to queue\\n            for [node, brother_sum] in cur_level:\\n                level_sum += node.val\\n\\n                left_val = node.left.val if node.left else 0\\n                right_val = node.right.val if node.right else 0\\n                brother_sum = left_val + right_val\\n                if node.left:\\n                    next_level.append([node.left, brother_sum])\\n                if node.right:\\n                    next_level.append([node.right, brother_sum])\\n\\n            # replace the value of current level nodes\\n            for [node, brother_sum] in cur_level:\\n                node.val = level_sum - brother_sum\\n            \\n            cur_level, next_level = next_level, []\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # find cur level sum\\n        # when pushing the node, push the sum of its brother also, so we can get the sum of cousins by substracting it\\n        \\n        cur_level, next_level = [[root, root.val]], []\\n        while cur_level:\\n            level_sum = 0\\n            # calculate current level sum and push the next level to queue\\n            for [node, brother_sum] in cur_level:\\n                level_sum += node.val\\n\\n                left_val = node.left.val if node.left else 0\\n                right_val = node.right.val if node.right else 0\\n                brother_sum = left_val + right_val\\n                if node.left:\\n                    next_level.append([node.left, brother_sum])\\n                if node.right:\\n                    next_level.append([node.right, brother_sum])\\n\\n            # replace the value of current level nodes\\n            for [node, brother_sum] in cur_level:\\n                node.val = level_sum - brother_sum\\n            \\n            cur_level, next_level = next_level, []\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747073,
                "title": "level-order-traversal-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(N)*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<pair<TreeNode*,int>> curr,temp,empty;\\n        \\n        curr.push_back({root,0});\\n        int sum=0;\\n        int a,b;\\n        while(curr.size()){\\n            temp=empty;\\n            sum=0;\\n            for(int i=0;i<curr.size();i++){\\n                sum+=curr[i].first->val;\\n                if(curr[i].first->left){\\n                    if(curr[i].first->right)\\n                       temp.push_back({curr[i].first->left,curr[i].first->right->val}); \\n                    else \\n                       temp.push_back({curr[i].first->left,0}); \\n                }\\n                if(curr[i].first->right){\\n                    if(curr[i].first->left)\\n                       temp.push_back({curr[i].first->right,curr[i].first->left->val});\\n                    else\\n                       temp.push_back({curr[i].first->right,0}); \\n                }\\n            }\\n\\n            for(int i=0;i<curr.size();i++){\\n                a=curr[i].first->val;\\n                b=curr[i].second;\\n                curr[i].first->val=sum-a-b;\\n            }\\n\\n            curr=temp;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<pair<TreeNode*,int>> curr,temp,empty;\\n        \\n        curr.push_back({root,0});\\n        int sum=0;\\n        int a,b;\\n        while(curr.size()){\\n            temp=empty;\\n            sum=0;\\n            for(int i=0;i<curr.size();i++){\\n                sum+=curr[i].first->val;\\n                if(curr[i].first->left){\\n                    if(curr[i].first->right)\\n                       temp.push_back({curr[i].first->left,curr[i].first->right->val}); \\n                    else \\n                       temp.push_back({curr[i].first->left,0}); \\n                }\\n                if(curr[i].first->right){\\n                    if(curr[i].first->left)\\n                       temp.push_back({curr[i].first->right,curr[i].first->left->val});\\n                    else\\n                       temp.push_back({curr[i].first->right,0}); \\n                }\\n            }\\n\\n            for(int i=0;i<curr.size();i++){\\n                a=curr[i].first->val;\\n                b=curr[i].second;\\n                curr[i].first->val=sum-a-b;\\n            }\\n\\n            curr=temp;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742685,
                "title": "2dfs-refined",
                "content": "# Intuition\\ngot the approach from the solution 2DFS, but refined the code and tried to make it more reable\\n\\n# Approach\\ncreate sums of each level\\ncreate node and node value has hashmap\\nand in second DFS, just used the recursion call stack to get the parent left and right, to substract their values\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar replaceValueInTree = function(root) {\\n    const levelSums = new Map();\\n    const nodeValues = new Map();\\n    const createLevelSums = (node, level) => {\\n        if(!node) return;\\n        nodeValues.set(node,node.val);\\n        if(!levelSums.has(level)) levelSums.set(level,0);\\n        levelSums.set(level,node.val + levelSums.get(level));\\n        createLevelSums(node.left,level+1);\\n        createLevelSums(node.right, level+1);\\n    }\\n\\n    const refineBinaryTree = (node,level,parent) => {\\n        if(!node) return;\\n        if(!parent) node.val = 0;\\n        else {\\n            let sum = levelSums.get(level);\\n            let left = parent.left;\\n            let right = parent.right;\\n            if(left) sum-=nodeValues.get(left);\\n            if(right) sum-=nodeValues.get(right);\\n            node.val = sum;\\n        }\\n        refineBinaryTree(node.left,level+1,node);\\n        refineBinaryTree(node.right,level+1,node);\\n    }\\n\\n    createLevelSums(root,0);\\n    refineBinaryTree(root,0,null);\\n    return root;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar replaceValueInTree = function(root) {\\n    const levelSums = new Map();\\n    const nodeValues = new Map();\\n    const createLevelSums = (node, level) => {\\n        if(!node) return;\\n        nodeValues.set(node,node.val);\\n        if(!levelSums.has(level)) levelSums.set(level,0);\\n        levelSums.set(level,node.val + levelSums.get(level));\\n        createLevelSums(node.left,level+1);\\n        createLevelSums(node.right, level+1);\\n    }\\n\\n    const refineBinaryTree = (node,level,parent) => {\\n        if(!node) return;\\n        if(!parent) node.val = 0;\\n        else {\\n            let sum = levelSums.get(level);\\n            let left = parent.left;\\n            let right = parent.right;\\n            if(left) sum-=nodeValues.get(left);\\n            if(right) sum-=nodeValues.get(right);\\n            node.val = sum;\\n        }\\n        refineBinaryTree(node.left,level+1,node);\\n        refineBinaryTree(node.right,level+1,node);\\n    }\\n\\n    createLevelSums(root,0);\\n    refineBinaryTree(root,0,null);\\n    return root;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3724125,
                "title": "python-linear-time-in-place-modification-with-explanation",
                "content": "# Intuition\\nLet\\'s take a look at some level of this binary tree and their parents. \\n\\n```\\n   4      5      6      7          - parents of that level\\n  / \\\\    / \\\\    / \\\\    / \\\\\\n 8   9  10 11  12 13  14  15       - our level\\n```\\n\\nWe can have this information by traversing the tree level by level in BFS fashion. When we cover this level, we store two additional pieces of information:\\n - total sum in the level `(8 + 9 + 10 + ... + 15)`\\n - dictionary which maps parent to a sum of children `4 -> (8 + 9), ..., 6 -> (12 + 13)`\\n\\nThen using this information we can find the updated value of the node is `node.val = total_sum - parent_to_sum[parent]`\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n  def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    frontier = [(root, -1)]\\n\\n    while frontier:\\n      new_frontier, total_sum, parent_to_sum = [], 0, {}\\n      for (node, parent) in frontier:\\n        total_sum += node.val\\n        parent_to_sum[parent] = parent_to_sum.get(parent, 0) + node.val\\n\\n        if node.left:\\n          new_frontier.append((node.left, node))\\n        if node.right:\\n          new_frontier.append((node.right, node))\\n      \\n      for (node, parent) in frontier:\\n        node.val = total_sum - parent_to_sum[parent]\\n\\n      frontier = new_frontier\\n    \\n    return root\\n      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n   4      5      6      7          - parents of that level\\n  / \\\\    / \\\\    / \\\\    / \\\\\\n 8   9  10 11  12 13  14  15       - our level\\n```\n```\\nclass Solution:\\n  def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    frontier = [(root, -1)]\\n\\n    while frontier:\\n      new_frontier, total_sum, parent_to_sum = [], 0, {}\\n      for (node, parent) in frontier:\\n        total_sum += node.val\\n        parent_to_sum[parent] = parent_to_sum.get(parent, 0) + node.val\\n\\n        if node.left:\\n          new_frontier.append((node.left, node))\\n        if node.right:\\n          new_frontier.append((node.right, node))\\n      \\n      for (node, parent) in frontier:\\n        node.val = total_sum - parent_to_sum[parent]\\n\\n      frontier = new_frontier\\n    \\n    return root\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709342,
                "title": "go-level-order-traversal-then-dfs",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc calculateCousinsSum(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth > 1 {\\n\\t\\tm[depth] += node.Val\\n\\t}\\n\\n\\tcalculateCousinsSum(node.Left, depth+1, m)\\n\\tcalculateCousinsSum(node.Right, depth+1, m)\\n}\\n\\nfunc replaceValueInTreeUtil(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth == 0 {\\n\\t\\tnode.Val = 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = 0\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = 0\\n\\t\\t}\\n\\t} else {\\n\\n\\t\\tsiblingsSum := 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tsiblingsSum += node.Left.Val\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tsiblingsSum += node.Right.Val\\n\\t\\t}\\n\\n\\t\\tcousinsSum := m[depth+1] - siblingsSum\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = cousinsSum\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = cousinsSum\\n\\t\\t}\\n\\t}\\n\\n\\tdepth++\\n\\n\\treplaceValueInTreeUtil(node.Left, depth, m)\\n\\treplaceValueInTreeUtil(node.Right, depth, m)\\n}\\n\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tm := make(map[int]int)\\n\\n\\tcalculateCousinsSum(root, 0, m)\\n\\treplaceValueInTreeUtil(root, 0, m)\\n\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc calculateCousinsSum(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth > 1 {\\n\\t\\tm[depth] += node.Val\\n\\t}\\n\\n\\tcalculateCousinsSum(node.Left, depth+1, m)\\n\\tcalculateCousinsSum(node.Right, depth+1, m)\\n}\\n\\nfunc replaceValueInTreeUtil(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth == 0 {\\n\\t\\tnode.Val = 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = 0\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = 0\\n\\t\\t}\\n\\t} else {\\n\\n\\t\\tsiblingsSum := 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tsiblingsSum += node.Left.Val\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tsiblingsSum += node.Right.Val\\n\\t\\t}\\n\\n\\t\\tcousinsSum := m[depth+1] - siblingsSum\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = cousinsSum\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = cousinsSum\\n\\t\\t}\\n\\t}\\n\\n\\tdepth++\\n\\n\\treplaceValueInTreeUtil(node.Left, depth, m)\\n\\treplaceValueInTreeUtil(node.Right, depth, m)\\n}\\n\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tm := make(map[int]int)\\n\\n\\tcalculateCousinsSum(root, 0, m)\\n\\treplaceValueInTreeUtil(root, 0, m)\\n\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683893,
                "title": "simple-bfs-solution-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTraverse the tree by bfs approach and replace each roots value with the sum of its sibling value .Also maintain a currS variable which calculates the sum of all the nodes at a particular level .Finally just substract the replaced value with the currS for each node.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int preS = root->val;\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            int currS = 0;\\n            while(s-- >0)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                temp->val = preS - temp->val;\\n                int sibS = temp->left ? temp->left->val:0;\\n                sibS += temp->right ? temp->right->val:0;\\n                if(temp->left!=NULL)\\n                {\\n                currS = currS + temp->left->val;\\n                temp->left->val=sibS;\\n                q.push(temp->left);\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                currS = currS + temp->right->val;\\n                temp->right->val=sibS;\\n                q.push(temp->right);\\n                }\\n            }\\n            preS = currS;\\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int preS = root->val;\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            int currS = 0;\\n            while(s-- >0)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                temp->val = preS - temp->val;\\n                int sibS = temp->left ? temp->left->val:0;\\n                sibS += temp->right ? temp->right->val:0;\\n                if(temp->left!=NULL)\\n                {\\n                currS = currS + temp->left->val;\\n                temp->left->val=sibS;\\n                q.push(temp->left);\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                currS = currS + temp->right->val;\\n                temp->right->val=sibS;\\n                q.push(temp->right);\\n                }\\n            }\\n            preS = currS;\\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678189,
                "title": "c-level-order-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void UpdateTree(TreeNode* root, int level, vector<long long>& levelSum)\\n    {\\n        if(root==NULL)    return;\\n        int sum = 0;\\n        if(root->left)    sum += root->left->val;\\n        if(root->right)   sum += root->right->val;\\n        if(root->left)    root->left->val = levelSum[level+1] - sum;\\n        if(root->right)   root->right->val = levelSum[level+1] - sum;\\n\\n        UpdateTree(root->left, level+1, levelSum);\\n        UpdateTree(root->right, level+1, levelSum);  \\n    }\\n\\n    vector<long long> CalculateLevelSum(TreeNode* root)\\n    {\\n        vector<long long> levelSum;\\n        queue<TreeNode *> q; \\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                sum += curr->val;\\n                if(curr->left)    q.push(curr->left);\\n                if(curr->right)   q.push(curr->right);\\n            }\\n\\n            levelSum.push_back(sum);\\n        }\\n\\n        return levelSum;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> levelSum = CalculateLevelSum(root);\\n        int level = 0;\\n        UpdateTree(root, level, levelSum);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void UpdateTree(TreeNode* root, int level, vector<long long>& levelSum)\\n    {\\n        if(root==NULL)    return;\\n        int sum = 0;\\n        if(root->left)    sum += root->left->val;\\n        if(root->right)   sum += root->right->val;\\n        if(root->left)    root->left->val = levelSum[level+1] - sum;\\n        if(root->right)   root->right->val = levelSum[level+1] - sum;\\n\\n        UpdateTree(root->left, level+1, levelSum);\\n        UpdateTree(root->right, level+1, levelSum);  \\n    }\\n\\n    vector<long long> CalculateLevelSum(TreeNode* root)\\n    {\\n        vector<long long> levelSum;\\n        queue<TreeNode *> q; \\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                sum += curr->val;\\n                if(curr->left)    q.push(curr->left);\\n                if(curr->right)   q.push(curr->right);\\n            }\\n\\n            levelSum.push_back(sum);\\n        }\\n\\n        return levelSum;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> levelSum = CalculateLevelSum(root);\\n        int level = 0;\\n        UpdateTree(root, level, levelSum);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675313,
                "title": "shortest-code-using-level-order-traversal",
                "content": "# Intuition\\nlevel order traversal \\n\\n# Approach\\nnode\\'s value = sum of all the nodes in that level - (sum of node\\' value and its siblings value i.e. they both are the left and right child of the same node\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^l) ; l = max depth of binary tree.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {     \\n\\n        queue<pair<TreeNode*,int>>q;\\n      \\n        q.push({root,0});\\n        int prev=0;\\n        while(!q.empty()){\\n            \\n            int n = q.size();\\n            \\n            int Tsum=0;\\n            for(int i=0; i<n; i++){\\n                int sum=0;\\n                auto [node,rootSum] = q.front();\\n                q.pop();\\n                \\n                if(!node) continue;\\n                \\n                node->val= prev - rootSum; // total sum of level - sibling sum.\\n                \\n                if(node->left)\\n                    sum+= node->left->val;\\n                \\n                if(node->right)\\n                    sum+= node->right->val;\\n                Tsum+= sum;\\n                \\n                q.push({node->left,sum}); // sibling sum\\n                q.push({node->right, sum});\\n            }\\n            prev = Tsum; // storing the total sum of a level so that we can use in the next iteration.\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {     \\n\\n        queue<pair<TreeNode*,int>>q;\\n      \\n        q.push({root,0});\\n        int prev=0;\\n        while(!q.empty()){\\n            \\n            int n = q.size();\\n            \\n            int Tsum=0;\\n            for(int i=0; i<n; i++){\\n                int sum=0;\\n                auto [node,rootSum] = q.front();\\n                q.pop();\\n                \\n                if(!node) continue;\\n                \\n                node->val= prev - rootSum; // total sum of level - sibling sum.\\n                \\n                if(node->left)\\n                    sum+= node->left->val;\\n                \\n                if(node->right)\\n                    sum+= node->right->val;\\n                Tsum+= sum;\\n                \\n                q.push({node->left,sum}); // sibling sum\\n                q.push({node->right, sum});\\n            }\\n            prev = Tsum; // storing the total sum of a level so that we can use in the next iteration.\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671958,
                "title": "simple-bfs",
                "content": "# Intuition\\nBreadth first search\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if root == None:\\n            return root\\n        root.val = 0\\n        parents = collections.deque()\\n        parents.append(root)\\n        while parents:\\n            children = []\\n            total = 0\\n            for parent in parents:\\n                if parent.left:\\n                    children.append(parent.left)\\n                    total += parent.left.val\\n                if parent.right:\\n                    children.append(parent.right)\\n                    total += parent.right.val\\n            while parents:\\n                parent = parents.popleft()\\n                subtotal = 0\\n                if parent.left:\\n                    subtotal += parent.left.val\\n                if parent.right:\\n                    subtotal += parent.right.val\\n                    parent.right.val = total - subtotal\\n                if parent.left:\\n                    parent.left.val = total - subtotal\\n            parents.extend(children)\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if root == None:\\n            return root\\n        root.val = 0\\n        parents = collections.deque()\\n        parents.append(root)\\n        while parents:\\n            children = []\\n            total = 0\\n            for parent in parents:\\n                if parent.left:\\n                    children.append(parent.left)\\n                    total += parent.left.val\\n                if parent.right:\\n                    children.append(parent.right)\\n                    total += parent.right.val\\n            while parents:\\n                parent = parents.popleft()\\n                subtotal = 0\\n                if parent.left:\\n                    subtotal += parent.left.val\\n                if parent.right:\\n                    subtotal += parent.right.val\\n                    parent.right.val = total - subtotal\\n                if parent.left:\\n                    parent.left.val = total - subtotal\\n            parents.extend(children)\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668081,
                "title": "bfs-w-level-sums",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst replaceValueInTree = (root) => {\\n  let queue = [[root, root.val]];\\n  let currentSum = root.val;\\n  while (queue.length) {\\n    let nextSum = 0;\\n    const nextLevel = [];\\n    for (let [node, sum] of queue) {\\n      const leftVal = node.left ? node.left.val : 0;\\n      const rightVal = node.right ? node.right.val : 0;\\n      node.val = currentSum - sum;\\n      if (node.left) {\\n        nextSum += node.left.val;\\n        nextLevel.push([node.left, leftVal + rightVal]);\\n      }\\n      if (node.right) {\\n        nextSum += node.right.val;\\n        nextLevel.push([node.right, leftVal + rightVal]);\\n      }\\n    }\\n    currentSum = nextSum;\\n    queue = nextLevel;\\n  }\\n  return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst replaceValueInTree = (root) => {\\n  let queue = [[root, root.val]];\\n  let currentSum = root.val;\\n  while (queue.length) {\\n    let nextSum = 0;\\n    const nextLevel = [];\\n    for (let [node, sum] of queue) {\\n      const leftVal = node.left ? node.left.val : 0;\\n      const rightVal = node.right ? node.right.val : 0;\\n      node.val = currentSum - sum;\\n      if (node.left) {\\n        nextSum += node.left.val;\\n        nextLevel.push([node.left, leftVal + rightVal]);\\n      }\\n      if (node.right) {\\n        nextSum += node.right.val;\\n        nextLevel.push([node.right, leftVal + rightVal]);\\n      }\\n    }\\n    currentSum = nextSum;\\n    queue = nextLevel;\\n  }\\n  return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3667230,
                "title": "simple-level-sum-double-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOverwriting values as you do a single traversal can be difficult to wrap your head around, and is prone to coding errors. Once you understand that the final value of a node is\\n\\n```\\nnode_val = sum_of_level - original_self_val - sibling_val\\n```\\n\\nthings get much simpler.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI separated out level sum code and overwrite into separate methods for clarity. A single method with a long parameter list, and lots of ifs may have been feasible, but would be messy.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) - traverses all nodes twice\\n\\n- Space complexity:\\nO(Log(n)) additional space for level sums\\n**Additional stack space for recursion\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    level_sum = None\\n\\n    def lvl_sum_helper(self, node: Optional[TreeNode], level: int):\\n        if node is None:\\n            return\\n\\n        Solution.level_sum[level] += node.val\\n\\n        self.lvl_sum_helper(node.left, level+1)\\n        self.lvl_sum_helper(node.right, level+1)\\n\\n    def write_trav_helper(self, node: Optional[TreeNode], level: int, sub: int) -> None:\\n        if node is None:\\n            return\\n\\n        node.val = Solution.level_sum[level] - sub\\n\\n        left_val = node.left.val if node.left else 0\\n        right_val = node.right.val if node.right else 0\\n\\n        self.write_trav_helper(node.left, level+1, left_val+right_val)\\n        self.write_trav_helper(node.right, level+1, left_val+right_val)\\n\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        Solution.level_sum = [0]*(10**5)\\n        \\n        # First pass, we iterate through and find original level sums\\n        self.lvl_sum_helper(root, 0)\\n\\n        # Second pass we overwrite, value should be level_sum-self-sibs\\n        self.write_trav_helper(root, 0, root.val)\\n\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nnode_val = sum_of_level - original_self_val - sibling_val\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    level_sum = None\\n\\n    def lvl_sum_helper(self, node: Optional[TreeNode], level: int):\\n        if node is None:\\n            return\\n\\n        Solution.level_sum[level] += node.val\\n\\n        self.lvl_sum_helper(node.left, level+1)\\n        self.lvl_sum_helper(node.right, level+1)\\n\\n    def write_trav_helper(self, node: Optional[TreeNode], level: int, sub: int) -> None:\\n        if node is None:\\n            return\\n\\n        node.val = Solution.level_sum[level] - sub\\n\\n        left_val = node.left.val if node.left else 0\\n        right_val = node.right.val if node.right else 0\\n\\n        self.write_trav_helper(node.left, level+1, left_val+right_val)\\n        self.write_trav_helper(node.right, level+1, left_val+right_val)\\n\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        Solution.level_sum = [0]*(10**5)\\n        \\n        # First pass, we iterate through and find original level sums\\n        self.lvl_sum_helper(root, 0)\\n\\n        # Second pass we overwrite, value should be level_sum-self-sibs\\n        self.write_trav_helper(root, 0, root.val)\\n\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666968,
                "title": "beats-100-java-clean-solution-2-dfs-with-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root.left == null && root.right == null)\\n            return new TreeNode(0);\\n        TreeNode nroot = null;\\n        dfs1(root, 0);\\n        dfs2(root, 0, root.val);\\n        return root;\\n    }\\n    private void dfs1(TreeNode root, int depth){\\n        if(root == null)\\n            return;\\n        map.put(depth, map.getOrDefault(depth, 0) + root.val);\\n        dfs1(root.left, depth+1);\\n        dfs1(root.right, depth+1);    \\n    }\\n    private void dfs2(TreeNode root, int depth, int sibling){\\n        if(root == null)\\n            return;\\n        \\n        root.val = map.get(depth) - sibling;\\n        sibling = (root.left == null ? 0 : root.left.val) + (root.right == null ? 0 : root.right.val);\\n        dfs2(root.left, depth+1, sibling);\\n        dfs2(root.right, depth+1, sibling);                    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root.left == null && root.right == null)\\n            return new TreeNode(0);\\n        TreeNode nroot = null;\\n        dfs1(root, 0);\\n        dfs2(root, 0, root.val);\\n        return root;\\n    }\\n    private void dfs1(TreeNode root, int depth){\\n        if(root == null)\\n            return;\\n        map.put(depth, map.getOrDefault(depth, 0) + root.val);\\n        dfs1(root.left, depth+1);\\n        dfs1(root.right, depth+1);    \\n    }\\n    private void dfs2(TreeNode root, int depth, int sibling){\\n        if(root == null)\\n            return;\\n        \\n        root.val = map.get(depth) - sibling;\\n        sibling = (root.left == null ? 0 : root.left.val) + (root.right == null ? 0 : root.right.val);\\n        dfs2(root.left, depth+1, sibling);\\n        dfs2(root.right, depth+1, sibling);                    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664398,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>pq;\\n\\n        if(!root){\\n            return root;\\n        }\\n        pq.push(root);\\n\\n        while(pq.size()){\\n            int size = pq.size();\\n            int sum = 0;\\n            vector<pair<TreeNode*,int>>M;\\n            while(size--){\\n                TreeNode* temp = pq.front();\\n                pq.pop();\\n                int curr_sum = 0;\\n                if(temp -> left){\\n                    sum += temp -> left->val;\\n                    curr_sum += temp -> left->val; \\n                    pq.push(temp->left);\\n                }\\n                if(temp -> right){\\n                    sum += temp -> right->val;\\n                    curr_sum += temp -> right->val; \\n                    pq.push(temp->right);\\n                }\\n                M.push_back({temp,curr_sum});\\n            }\\n            for(int i=0;i<M.size();i++){\\n                TreeNode* curr = M[i].first;\\n                int total = M[i].second;\\n                if(curr -> left){\\n                    curr->left->val = sum-total;\\n                }\\n                if(curr -> right){\\n                    curr->right->val = sum-total;\\n                }\\n            }\\n        }\\n        root->val =  0;\\n        return root;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>pq;\\n\\n        if(!root){\\n            return root;\\n        }\\n        pq.push(root);\\n\\n        while(pq.size()){\\n            int size = pq.size();\\n            int sum = 0;\\n            vector<pair<TreeNode*,int>>M;\\n            while(size--){\\n                TreeNode* temp = pq.front();\\n                pq.pop();\\n                int curr_sum = 0;\\n                if(temp -> left){\\n                    sum += temp -> left->val;\\n                    curr_sum += temp -> left->val; \\n                    pq.push(temp->left);\\n                }\\n                if(temp -> right){\\n                    sum += temp -> right->val;\\n                    curr_sum += temp -> right->val; \\n                    pq.push(temp->right);\\n                }\\n                M.push_back({temp,curr_sum});\\n            }\\n            for(int i=0;i<M.size();i++){\\n                TreeNode* curr = M[i].first;\\n                int total = M[i].second;\\n                if(curr -> left){\\n                    curr->left->val = sum-total;\\n                }\\n                if(curr -> right){\\n                    curr->right->val = sum-total;\\n                }\\n            }\\n        }\\n        root->val =  0;\\n        return root;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651926,
                "title": "java-horizontal-level-sum",
                "content": "# Intuition\\nUse horizontal level sum\\n\\n# Approach\\nFind horizontal level sum, once you are ready with this then for each parent you need to get their children sum and update children with with new value which is horizontalLevelSum[depth+1]-childrenSum;\\nHere I used horizontalLevelSum[depth+1] instead of horizontalLevelSum[depth] because it\\'s easy to get both child from parent and since you\\'re at the parent level so to get children\\'s level sum the you have to increase depth by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> horizontalSum;\\n    public void traverse(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth<horizontalSum.size()) {\\n            horizontalSum.set(depth, horizontalSum.get(depth)+root.val);\\n        } else {\\n            horizontalSum.add(root.val);\\n        }\\n        traverse(root.left, depth+1);\\n        traverse(root.right, depth+1);\\n    }\\n    public void traverse1(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth>0) {\\n            int sum=0;\\n            if(root.left!=null) {\\n                sum+=root.left.val;\\n            }\\n            if(root.right!=null) {\\n                sum+=root.right.val;\\n            }\\n            if(root.left!=null) {\\n                root.left.val=horizontalSum.get(depth+1)-sum;\\n            }\\n            if(root.right!=null) {\\n                root.right.val=horizontalSum.get(depth+1)-sum;\\n            }\\n        }\\n        traverse1(root.left, depth+1);\\n        traverse1(root.right, depth+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        horizontalSum = new ArrayList();\\n        root.val = 0;\\n        if(root.left!=null) {\\n            root.left.val = 0;\\n        }\\n        if(root.right!=null) {\\n            root.right.val = 0;\\n        }\\n        traverse(root, 0);\\n        traverse1(root,0);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> horizontalSum;\\n    public void traverse(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth<horizontalSum.size()) {\\n            horizontalSum.set(depth, horizontalSum.get(depth)+root.val);\\n        } else {\\n            horizontalSum.add(root.val);\\n        }\\n        traverse(root.left, depth+1);\\n        traverse(root.right, depth+1);\\n    }\\n    public void traverse1(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth>0) {\\n            int sum=0;\\n            if(root.left!=null) {\\n                sum+=root.left.val;\\n            }\\n            if(root.right!=null) {\\n                sum+=root.right.val;\\n            }\\n            if(root.left!=null) {\\n                root.left.val=horizontalSum.get(depth+1)-sum;\\n            }\\n            if(root.right!=null) {\\n                root.right.val=horizontalSum.get(depth+1)-sum;\\n            }\\n        }\\n        traverse1(root.left, depth+1);\\n        traverse1(root.right, depth+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        horizontalSum = new ArrayList();\\n        root.val = 0;\\n        if(root.left!=null) {\\n            root.left.val = 0;\\n        }\\n        if(root.right!=null) {\\n            root.right.val = 0;\\n        }\\n        traverse(root, 0);\\n        traverse1(root,0);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646700,
                "title": "python3-w-detailed-explanation",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        from collections import deque\\n        \\n        q = deque([root])\\n        l_sum = []\\n        \\n\\t\\t# Use BFS to collect the sum of each level\\n        while q:\\n            _sum = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                _sum += node.val\\n                \\n                if node.left:\\n                    q.append(node.left)\\n                    \\n                if node.right:\\n                    q.append(node.right)\\n                    \\n            l_sum.append(_sum)\\n            \\n        def helper(node, sib_sum, level):\\n            if not node:\\n                return\\n            \\n\\t\\t\\t# `sib_sum` here consists of the values of every nodes under one parent\\n\\t\\t\\t# i.e. value of the node itself and its sibling nodes.\\n            node.val = l_sum[level] - sib_sum\\n            \\n            sib_sum = 0\\n            \\n            if node.left:\\n                sib_sum += node.left.val\\n                \\n            if node.right:\\n                sib_sum += node.right.val\\n            \\n            helper(node.left, sib_sum, level+1)\\n            helper(node.right, sib_sum, level+1)\\n            \\n\\t\\t# Use DFS to go through every node to update its value\\n\\t\\t# The key point is that - \\n\\t\\t# Sum of one level consists of \\n\\t\\t# 1. value of the node itself\\n\\t\\t# 2. values of the node\\'s sibilings (same parent) \\n\\t\\t# 3. and values of the node\\'s cousins (different parent)\\n        helper(root, root.val, 0)\\n        \\n        return root\\n```\\t\\t\\n\\nTime complexity: O(2n) = O(n) - we traverse the tree twice to count the sum of each level and update the values\\nSpace complexity: O(n) - we used queue to store nodes and list to store sum of each level",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        from collections import deque\\n        \\n        q = deque([root])\\n        l_sum = []\\n        \\n\\t\\t# Use BFS to collect the sum of each level\\n        while q:\\n            _sum = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                _sum += node.val\\n                \\n                if node.left:\\n                    q.append(node.left)\\n                    \\n                if node.right:\\n                    q.append(node.right)\\n                    \\n            l_sum.append(_sum)\\n            \\n        def helper(node, sib_sum, level):\\n            if not node:\\n                return\\n            \\n\\t\\t\\t# `sib_sum` here consists of the values of every nodes under one parent\\n\\t\\t\\t# i.e. value of the node itself and its sibling nodes.\\n            node.val = l_sum[level] - sib_sum\\n            \\n            sib_sum = 0\\n            \\n            if node.left:\\n                sib_sum += node.left.val\\n                \\n            if node.right:\\n                sib_sum += node.right.val\\n            \\n            helper(node.left, sib_sum, level+1)\\n            helper(node.right, sib_sum, level+1)\\n            \\n\\t\\t# Use DFS to go through every node to update its value\\n\\t\\t# The key point is that - \\n\\t\\t# Sum of one level consists of \\n\\t\\t# 1. value of the node itself\\n\\t\\t# 2. values of the node\\'s sibilings (same parent) \\n\\t\\t# 3. and values of the node\\'s cousins (different parent)\\n        helper(root, root.val, 0)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644460,
                "title": "if-you-still-didn-t-get-it-see-this",
                "content": "# Intuition\\nIf you get the sum of all values of nodes in a level and for any node you subtract the value of itself and its siblings from the total sum of nodes of it level, you get the sum of its cousins. You update the node value with that answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all you need to get the sum of values of all nodes in a level and for that purpose we use a map to store the sum level wise by calling the sum fn(dfs).\\n\\nAfter the first function call(dfs), we run another dfs call(solve fn), where we update the node values with the sum of their cousin nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe Sum function will run max O(n) times, as it will visit each node.\\nThe solve function shall run for another O(n) times as we traverse each node once.\\n\\nOverall T.C. = O(n)\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe hashmap shall store max n nodes if the tree is skewed i.e. n different levels so,\\n\\nS.C. = O(n)\\n(Ignoring the stack space used due to the function calls)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n\\n        sum(root, 0, mp);\\n        solve(root, 0,mp);\\n        return root;\\n        \\n    }\\n\\n\\n    void solve(TreeNode* root, int level, unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        if(level == 1){\\n            root->val = 0;\\n        }\\n        int right_val = 0,left_val= 0 ;\\n\\n        if(root->left){\\n            left_val = root->left->val;\\n            if(root->right){\\n                right_val = root->right->val;\\n            }\\n            root->left->val = mp[level+1] - (root->left->val + right_val);\\n        }\\n\\n        if(root->right){\\n           \\n           \\n            \\n            root->right->val = mp[level+1] - (root->right->val + left_val);\\n        }\\n\\n        solve(root->left,level,mp);\\n        solve(root->right,level,mp);\\n\\n        return;\\n\\n\\n    }\\n\\n    void sum(TreeNode* root, int level,  unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        sum(root -> left, level, mp);\\n        sum(root->right,level,mp);\\n\\n        if(mp.find(level) != mp.end()){\\n            mp[level] += root->val;\\n        }else{\\n            mp[level]=root->val;\\n        }\\n\\n        return;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n\\n        sum(root, 0, mp);\\n        solve(root, 0,mp);\\n        return root;\\n        \\n    }\\n\\n\\n    void solve(TreeNode* root, int level, unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        if(level == 1){\\n            root->val = 0;\\n        }\\n        int right_val = 0,left_val= 0 ;\\n\\n        if(root->left){\\n            left_val = root->left->val;\\n            if(root->right){\\n                right_val = root->right->val;\\n            }\\n            root->left->val = mp[level+1] - (root->left->val + right_val);\\n        }\\n\\n        if(root->right){\\n           \\n           \\n            \\n            root->right->val = mp[level+1] - (root->right->val + left_val);\\n        }\\n\\n        solve(root->left,level,mp);\\n        solve(root->right,level,mp);\\n\\n        return;\\n\\n\\n    }\\n\\n    void sum(TreeNode* root, int level,  unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        sum(root -> left, level, mp);\\n        sum(root->right,level,mp);\\n\\n        if(mp.find(level) != mp.end()){\\n            mp[level] += root->val;\\n        }else{\\n            mp[level]=root->val;\\n        }\\n\\n        return;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642738,
                "title": "2-bfs",
                "content": "\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root->left && !root->right){\\n            root->val=0;\\n            return root;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int lvll=1;\\n        \\n        vector<long long>lvlsum;\\n        queue<TreeNode*>lvl;\\n        lvl.push(root);\\n        while(lvl.size()){\\n            int size=lvl.size();\\n            long long sum=0;\\n            while(size--){\\n                TreeNode*f=lvl.front();\\n                lvl.pop();\\n                sum+=f->val;\\n                if(f->left)lvl.push(f->left);\\n                if(f->right)lvl.push(f->right);\\n            }\\n            lvlsum.push_back(sum);\\n        }\\n        while(q.size()){\\n            int size=q.size();\\n            while(size--){\\n                TreeNode*f=q.front();\\n                q.pop();\\n                long long x=0;\\n                if(!f->left && !f->right)continue;\\n                if(f->left){\\n                    x+=f->left->val;\\n                    q.push(f->left);\\n                }\\n                if(f->right){\\n                    x+=f->right->val;\\n                    q.push(f->right);\\n                }\\n                // cout<<x<<endl;\\n                if(f->left)f->left->val=lvlsum[lvll]-x;\\n                if(f->right)f->right->val=lvlsum[lvll]-x;\\n            }\\n            lvll++;\\n        }\\n        root->val=0;\\n        return root;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root->left && !root->right){\\n            root->val=0;\\n            return root;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int lvll=1;\\n        \\n        vector<long long>lvlsum;\\n        queue<TreeNode*>lvl;\\n        lvl.push(root);\\n        while(lvl.size()){\\n            int size=lvl.size();\\n            long long sum=0;\\n            while(size--){\\n                TreeNode*f=lvl.front();\\n                lvl.pop();\\n                sum+=f->val;\\n                if(f->left)lvl.push(f->left);\\n                if(f->right)lvl.push(f->right);\\n            }\\n            lvlsum.push_back(sum);\\n        }\\n        while(q.size()){\\n            int size=q.size();\\n            while(size--){\\n                TreeNode*f=q.front();\\n                q.pop();\\n                long long x=0;\\n                if(!f->left && !f->right)continue;\\n                if(f->left){\\n                    x+=f->left->val;\\n                    q.push(f->left);\\n                }\\n                if(f->right){\\n                    x+=f->right->val;\\n                    q.push(f->right);\\n                }\\n                // cout<<x<<endl;\\n                if(f->left)f->left->val=lvlsum[lvll]-x;\\n                if(f->right)f->right->val=lvlsum[lvll]-x;\\n            }\\n            lvll++;\\n        }\\n        root->val=0;\\n        return root;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 3642198,
                "title": "bfs-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>>arr;\\n        vector<int>tarr;\\n        vector<int>sumarr;\\n        int nnode=10001;\\n        int childSum=0,totsum=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        q.push(new TreeNode(nnode));\\n        q.push(NULL);\\n        arr.push_back({root->val});\\n        sumarr.push_back(root->val);\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL && n->val!=nnode){\\n                childSum=0;\\n                if(n->left){\\n                    q.push(n->left);\\n                    childSum+=n->left->val;\\n                }\\n                if(n->right){\\n                    q.push(n->right);\\n                    childSum+=n->right->val;\\n                }\\n                totsum+= childSum;\\n                tarr.push_back(childSum); \\n                q.push(new TreeNode(nnode));       \\n            }\\n            else if(n!=NULL && n->val==nnode){\\n                childSum=0;\\n            }\\n            else if(!q.empty()){\\n                arr.push_back(tarr);\\n                sumarr.push_back(totsum);\\n                tarr.clear();\\n                totsum=0;\\n                childSum=0;\\n                q.push(NULL);\\n            }\\n        }\\n\\n        root->val=0;\\n        q.push(root);\\n        q.push(NULL);\\n        int lvl=1,indx=0;\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL){\\n                //cout<<lvl<<\" \"<<sumarr[lvl]<<\" \"<<arr[lvl][indx]<<\"\\\\n\";\\n                if(n->left){\\n                    n->left->val=sumarr[lvl]-arr[lvl][indx];\\n                    q.push(n->left);\\n                }\\n                if(n->right)\\n                 {\\n                     n->right->val=sumarr[lvl]-arr[lvl][indx];\\n                     q.push(n->right);\\n                 }\\n                indx++;\\n            }\\n            else if(!q.empty()){\\n                q.push(NULL);\\n                indx=0;\\n                lvl++;\\n            }          \\n        }\\n        return root;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>>arr;\\n        vector<int>tarr;\\n        vector<int>sumarr;\\n        int nnode=10001;\\n        int childSum=0,totsum=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        q.push(new TreeNode(nnode));\\n        q.push(NULL);\\n        arr.push_back({root->val});\\n        sumarr.push_back(root->val);\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL && n->val!=nnode){\\n                childSum=0;\\n                if(n->left){\\n                    q.push(n->left);\\n                    childSum+=n->left->val;\\n                }\\n                if(n->right){\\n                    q.push(n->right);\\n                    childSum+=n->right->val;\\n                }\\n                totsum+= childSum;\\n                tarr.push_back(childSum); \\n                q.push(new TreeNode(nnode));       \\n            }\\n            else if(n!=NULL && n->val==nnode){\\n                childSum=0;\\n            }\\n            else if(!q.empty()){\\n                arr.push_back(tarr);\\n                sumarr.push_back(totsum);\\n                tarr.clear();\\n                totsum=0;\\n                childSum=0;\\n                q.push(NULL);\\n            }\\n        }\\n\\n        root->val=0;\\n        q.push(root);\\n        q.push(NULL);\\n        int lvl=1,indx=0;\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL){\\n                //cout<<lvl<<\" \"<<sumarr[lvl]<<\" \"<<arr[lvl][indx]<<\"\\\\n\";\\n                if(n->left){\\n                    n->left->val=sumarr[lvl]-arr[lvl][indx];\\n                    q.push(n->left);\\n                }\\n                if(n->right)\\n                 {\\n                     n->right->val=sumarr[lvl]-arr[lvl][indx];\\n                     q.push(n->right);\\n                 }\\n                indx++;\\n            }\\n            else if(!q.empty()){\\n                q.push(NULL);\\n                indx=0;\\n                lvl++;\\n            }          \\n        }\\n        return root;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3642036,
                "title": "python-faster-than-98-bfs-precalculate-level-sum",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if root.left:\\n            root.left.val = 0\\n        if root.right:\\n            root.right.val = 0\\n        cur_level = [(root.left, root.right)]\\n        while cur_level:\\n            next_level = []\\n            s = 0\\n            for node_info in cur_level:\\n                l, r = node_info\\n                if l:\\n                    s += l.val\\n                    next_level.append((l.left, l.right))\\n                if r:\\n                    s += r.val\\n                    next_level.append((r.left, r.right))\\n            \\n            for node_info in cur_level:\\n                l, r = node_info\\n                val = s - (l.val if l else 0) - (r.val if r else 0)\\n                if l:\\n                    l.val = val\\n                if r:\\n                    r.val = val\\n\\n            cur_level = next_level\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if root.left:\\n            root.left.val = 0\\n        if root.right:\\n            root.right.val = 0\\n        cur_level = [(root.left, root.right)]\\n        while cur_level:\\n            next_level = []\\n            s = 0\\n            for node_info in cur_level:\\n                l, r = node_info\\n                if l:\\n                    s += l.val\\n                    next_level.append((l.left, l.right))\\n                if r:\\n                    s += r.val\\n                    next_level.append((r.left, r.right))\\n            \\n            for node_info in cur_level:\\n                l, r = node_info\\n                val = s - (l.val if l else 0) - (r.val if r else 0)\\n                if l:\\n                    l.val = val\\n                if r:\\n                    r.val = val\\n\\n            cur_level = next_level\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641975,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n  public:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      TreeNode* guard = root;\\n      vector<int> diff, level;\\n      diff.push_back(root->val);\\n      level.push_back(root->val);\\n      int i = 0, sum = 0, l = 0;\\n      while (!q.empty()) {\\n        TreeNode* c = q.front();\\n        q.pop();\\n        c->val = level[l] - diff[i++];\\n        int v = 0;\\n        if (c->left) {\\n          v += c->left->val;\\n          q.push(c->left);\\n        }\\n        if (c->right) {\\n          v += c->right->val;\\n          q.push(c->right);\\n        }\\n        if (c->left)\\n          diff.push_back(v);\\n        if (c->right)\\n          diff.push_back(v);\\n        sum += v;\\n        if (c == guard) {\\n          guard = !q.empty() ? q.back() : nullptr;\\n          level.push_back(sum);\\n          sum = 0;\\n          l++;\\n        }\\n      }\\n      return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n  public:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      TreeNode* guard = root;\\n      vector<int> diff, level;\\n      diff.push_back(root->val);\\n      level.push_back(root->val);\\n      int i = 0, sum = 0, l = 0;\\n      while (!q.empty()) {\\n        TreeNode* c = q.front();\\n        q.pop();\\n        c->val = level[l] - diff[i++];\\n        int v = 0;\\n        if (c->left) {\\n          v += c->left->val;\\n          q.push(c->left);\\n        }\\n        if (c->right) {\\n          v += c->right->val;\\n          q.push(c->right);\\n        }\\n        if (c->left)\\n          diff.push_back(v);\\n        if (c->right)\\n          diff.push_back(v);\\n        sum += v;\\n        if (c == guard) {\\n          guard = !q.empty() ? q.back() : nullptr;\\n          level.push_back(sum);\\n          sum = 0;\\n          l++;\\n        }\\n      }\\n      return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641728,
                "title": "c-solution-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution \\n{\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        int i,n,sum,prevsum;\\n\\n        vector<int> v,prev;\\n        queue<TreeNode *> q;\\n        TreeNode *temp;\\n\\n        prevsum=0;\\n        prev.push_back(0);\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            n=q.size();\\n            sum=0;\\n\\n            for(i=0;i<n;i++)\\n            {\\n                temp=q.front();\\n                q.pop();\\n                temp->val=prevsum-prev[i];\\n\\n                if(temp->left)\\n                {\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    q.push(temp->right);\\n                }\\n\\n                if(temp->left && temp->right)\\n                {\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(!temp->left && temp->right)\\n                {\\n                    v.push_back(temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(temp->left && !temp->right)\\n                {\\n                    v.push_back(temp->left->val);\\n                    sum+=v.back();\\n                }\\n            }\\n\\n            prevsum=sum;\\n            prev=v;\\n            v.clear();\\n        }        \\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution \\n{\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        int i,n,sum,prevsum;\\n\\n        vector<int> v,prev;\\n        queue<TreeNode *> q;\\n        TreeNode *temp;\\n\\n        prevsum=0;\\n        prev.push_back(0);\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            n=q.size();\\n            sum=0;\\n\\n            for(i=0;i<n;i++)\\n            {\\n                temp=q.front();\\n                q.pop();\\n                temp->val=prevsum-prev[i];\\n\\n                if(temp->left)\\n                {\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    q.push(temp->right);\\n                }\\n\\n                if(temp->left && temp->right)\\n                {\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(!temp->left && temp->right)\\n                {\\n                    v.push_back(temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(temp->left && !temp->right)\\n                {\\n                    v.push_back(temp->left->val);\\n                    sum+=v.back();\\n                }\\n            }\\n\\n            prevsum=sum;\\n            prev=v;\\n            v.clear();\\n        }        \\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641620,
                "title": "simple-java-o-n-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSum of all cousins at level i = (Sum of all nodes at level i) - (val of sibling) - (val of self)\\n\\nWe can precompute sum of each level in one traversal of tree in O(n). Then in second traversal we can update values. Small catch is to get value of sibling, which can be passed by parent node.\\n\\nIf going to left subtree, then siblingValue will be of right node.\\nIf going to right subtree, then siblingValue will be of left node.\\n\\nBFS traversal is not necessarily required to solve this problem. Any traversal would work(in-order, pre-order, postorder, BFS). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps:\\n1. Calculate depth of tree(This can be avoided if using List instead of array): depth = 1 + max(leftDepth, rightDepth);\\n2. Compute level sum. You can use any traversal, I used pre-order. \\n3. Update node values. You can choose to create new tree instead of updating existing one if asked by interviewer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O (n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        int levels = depth(root);\\n        int[] arr = new int[levels]; // Stores sum of level\\n        computeLevelSum(root, 0, arr);\\n        updateNodes(root, 0, 0, arr);\\n        return root;\\n    }\\n\\n    private void updateNodes(TreeNode root, int siblingVal, int i, int[] arr) {\\n        if (root == null) return;\\n        \\n        int leftValue = root.left != null ? root.left.val : 0;\\n        int rightValue = root.right != null ? root.right.val : 0;\\n        updateNodes(root.left, rightValue, i+1, arr);\\n        updateNodes(root.right, leftValue, i+1, arr);\\n\\n        root.val = arr[i] - root.val - siblingVal;\\n    }\\n\\n    private void computeLevelSum(TreeNode root, int i, int[] arr) {\\n        if (root == null) return;\\n\\n        arr[i] += root.val;\\n        computeLevelSum(root.left, i+1, arr);\\n        computeLevelSum(root.right, i+1, arr);\\n    }\\n\\n    private int depth(TreeNode root) {\\n        if (root == null) return 0;\\n        return Math.max(depth(root.left), depth(root.right)) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        int levels = depth(root);\\n        int[] arr = new int[levels]; // Stores sum of level\\n        computeLevelSum(root, 0, arr);\\n        updateNodes(root, 0, 0, arr);\\n        return root;\\n    }\\n\\n    private void updateNodes(TreeNode root, int siblingVal, int i, int[] arr) {\\n        if (root == null) return;\\n        \\n        int leftValue = root.left != null ? root.left.val : 0;\\n        int rightValue = root.right != null ? root.right.val : 0;\\n        updateNodes(root.left, rightValue, i+1, arr);\\n        updateNodes(root.right, leftValue, i+1, arr);\\n\\n        root.val = arr[i] - root.val - siblingVal;\\n    }\\n\\n    private void computeLevelSum(TreeNode root, int i, int[] arr) {\\n        if (root == null) return;\\n\\n        arr[i] += root.val;\\n        computeLevelSum(root.left, i+1, arr);\\n        computeLevelSum(root.right, i+1, arr);\\n    }\\n\\n    private int depth(TreeNode root) {\\n        if (root == null) return 0;\\n        return Math.max(depth(root.left), depth(root.right)) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641423,
                "title": "simple-bfs-pysthon",
                "content": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        node = root\\n        st = [node]\\n        while st:\\n            k = []\\n            s = 0\\n            for i in st:\\n                if i.left:\\n                    s += i.left.val\\n                if i.right:\\n                    s += i.right.val\\n            for i in st:\\n                node_sum = 0\\n                if i.left:\\n                    node_sum += i.left.val\\n                if i.right:\\n                    node_sum += i.right.val\\n                if i.left:\\n                    i.left.val = s-node_sum\\n                    k.append(i.left)\\n                if i.right:\\n                    i.right.val = s-node_sum\\n                    k.append(i.right)\\n            st = k\\n        root.val = 0\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        node = root\\n        st = [node]\\n        while st:\\n            k = []\\n            s = 0\\n            for i in st:\\n                if i.left:\\n                    s += i.left.val\\n                if i.right:\\n                    s += i.right.val\\n            for i in st:\\n                node_sum = 0\\n                if i.left:\\n                    node_sum += i.left.val\\n                if i.right:\\n                    node_sum += i.right.val\\n                if i.left:\\n                    i.left.val = s-node_sum\\n                    k.append(i.left)\\n                if i.right:\\n                    i.right.val = s-node_sum\\n                    k.append(i.right)\\n            st = k\\n        root.val = 0\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641378,
                "title": "dfs-bfs-easy-to-understand",
                "content": "# Intuition\\nreplaced_value = (sum of all nodes at a level) - (node itself + its siblings)\\nuse a standard bfs level order approach to store the sum of all nodes at a level in a level array(vector)\\nthen recursively(dfs) go for every node and first store both the left and right child values(only 2 sibling for every node as it is a binary tree that has the property of max 2 child per node) in a sibling variable.\\nif left child is not null then replace its value with totalsumatthatlevel-sibling, do the same with right child\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define ll long long\\nclass Solution {\\npublic:\\n    void dfs(TreeNode*root, vector<ll>&level, int i){\\n        if(!root) return;\\n        ll sibling=0;\\n        if(root->left) sibling+=root->left->val;\\n        if(root->right) sibling+=root->right->val;\\n        if(root->left) root->left->val=level[i+1]-sibling;\\n        if(root->right) root->right->val=level[i+1]-sibling;\\n        dfs(root->left,level,i+1);\\n        dfs(root->right,level,i+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<ll> level;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            ll sum=0;\\n            int s=q.size();\\n            while(s--){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            level.push_back(sum);\\n        }\\n        if(root) root->val=0;\\n        dfs(root,level,0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define ll long long\\nclass Solution {\\npublic:\\n    void dfs(TreeNode*root, vector<ll>&level, int i){\\n        if(!root) return;\\n        ll sibling=0;\\n        if(root->left) sibling+=root->left->val;\\n        if(root->right) sibling+=root->right->val;\\n        if(root->left) root->left->val=level[i+1]-sibling;\\n        if(root->right) root->right->val=level[i+1]-sibling;\\n        dfs(root->left,level,i+1);\\n        dfs(root->right,level,i+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<ll> level;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            ll sum=0;\\n            int s=q.size();\\n            while(s--){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            level.push_back(sum);\\n        }\\n        if(root) root->val=0;\\n        dfs(root,level,0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640324,
                "title": "cpp-solution-using-hashmap",
                "content": "Level order traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nusing map & queue\\n<!-- Describe your approach to solving the problem. -->\\n\\nO(N)\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       root->val = 0;\\n\\n       while(!q.empty()){\\n           int n = q.size();\\n           unordered_map<TreeNode* , int>m;\\n           for(int i=0;i<n;i++){\\n               TreeNode* topNode = q.front();\\n               if(topNode->left){\\n                   q.push(topNode->left);\\n                   m[topNode] += topNode->left->val;\\n               }\\n               if(topNode->right){\\n                   q.push(topNode->right);\\n                   m[topNode] += topNode->right->val;\\n               }\\n               q.pop();\\n           }\\n           int sum = 0;\\n           for(auto it:m){\\n               sum += it.second;\\n           }\\n           for(auto it : m){\\n            if(it.first->left)\\n            it.first->left->val = sum-it.second;\\n            if(it.first->right)\\n            it.first->right->val = sum-it.second;\\n           }\\n       } \\n       return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       root->val = 0;\\n\\n       while(!q.empty()){\\n           int n = q.size();\\n           unordered_map<TreeNode* , int>m;\\n           for(int i=0;i<n;i++){\\n               TreeNode* topNode = q.front();\\n               if(topNode->left){\\n                   q.push(topNode->left);\\n                   m[topNode] += topNode->left->val;\\n               }\\n               if(topNode->right){\\n                   q.push(topNode->right);\\n                   m[topNode] += topNode->right->val;\\n               }\\n               q.pop();\\n           }\\n           int sum = 0;\\n           for(auto it:m){\\n               sum += it.second;\\n           }\\n           for(auto it : m){\\n            if(it.first->left)\\n            it.first->left->val = sum-it.second;\\n            if(it.first->right)\\n            it.first->right->val = sum-it.second;\\n           }\\n       } \\n       return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639609,
                "title": "level-sum-then-preorder-dfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> level_sum;\\n    void find_sum(TreeNode* root,int level){\\n        if(!root) return;\\n        if(level>=level_sum.size()) level_sum.push_back(0);\\n        level_sum[level]+=root->val;\\n        find_sum(root->left,level+1);\\n        find_sum(root->right,level+1);\\n    }\\n\\n    void preorder(TreeNode* root, int brothersum,int level){\\n        if(!root) return;\\n        int cousin_sum=level_sum[level]-brothersum;\\n        root->val=cousin_sum;\\n\\n        int childsum=0;\\n        childsum+=(root->left)? root->left->val : 0;\\n        childsum+=(root->right)? root->right->val : 0;\\n\\n        preorder(root->left,childsum,level+1);\\n        preorder(root->right,childsum,level+1);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        find_sum(root,0);\\n        preorder(root,root->val,0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> level_sum;\\n    void find_sum(TreeNode* root,int level){\\n        if(!root) return;\\n        if(level>=level_sum.size()) level_sum.push_back(0);\\n        level_sum[level]+=root->val;\\n        find_sum(root->left,level+1);\\n        find_sum(root->right,level+1);\\n    }\\n\\n    void preorder(TreeNode* root, int brothersum,int level){\\n        if(!root) return;\\n        int cousin_sum=level_sum[level]-brothersum;\\n        root->val=cousin_sum;\\n\\n        int childsum=0;\\n        childsum+=(root->left)? root->left->val : 0;\\n        childsum+=(root->right)? root->right->val : 0;\\n\\n        preorder(root->left,childsum,level+1);\\n        preorder(root->right,childsum,level+1);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        find_sum(root,0);\\n        preorder(root,root->val,0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639510,
                "title": "python-queue",
                "content": "Key here is to record in each node, the value of it\\'s sibling, in the queue.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [[root, 0]]\\n        tot_sum = 0\\n\\n        while queue:\\n            nextQ = []\\n            cur_sum = 0\\n\\n            for [node, sib_val] in queue:\\n                cur_sum += node.val\\n\\n                if node.left and node.right:\\n                    nextQ.append([node.left, node.right.val])\\n                    nextQ.append([node.right, node.left.val])\\n                elif node.left:\\n                    nextQ.append([node.left, 0])\\n                elif node.right:\\n                    nextQ.append([node.right, 0])\\n\\n            for [node, sib_val] in queue:\\n                node.val = cur_sum - sib_val - node.val\\n\\n            queue = nextQ\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [[root, 0]]\\n        tot_sum = 0\\n\\n        while queue:\\n            nextQ = []\\n            cur_sum = 0\\n\\n            for [node, sib_val] in queue:\\n                cur_sum += node.val\\n\\n                if node.left and node.right:\\n                    nextQ.append([node.left, node.right.val])\\n                    nextQ.append([node.right, node.left.val])\\n                elif node.left:\\n                    nextQ.append([node.left, 0])\\n                elif node.right:\\n                    nextQ.append([node.right, 0])\\n\\n            for [node, sib_val] in queue:\\n                node.val = cur_sum - sib_val - node.val\\n\\n            queue = nextQ\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639437,
                "title": "python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum=defaultdict(int)\\n        def dfs(root,height):\\n            if not root:return\\n            level_sum[height]+=root.val\\n            if root.left:dfs(root.left,height+1)\\n            if root.right:dfs(root.right,height+1)\\n        dfs(root,0)\\n        def dfs_sum(sib_val,own,height):\\n            if not own:\\n                return \\n            own.val=level_sum[height]-own.val-sib_val\\n            if own.left:\\n                left=own.left.val\\n            else:\\n                left=0\\n            right=own.right.val if own.right else 0\\n            dfs_sum(left,own.right,height+1)\\n            dfs_sum(right,own.left,height+1)\\n        dfs_sum(0,root,0)\\n        return root     \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum=defaultdict(int)\\n        def dfs(root,height):\\n            if not root:return\\n            level_sum[height]+=root.val\\n            if root.left:dfs(root.left,height+1)\\n            if root.right:dfs(root.right,height+1)\\n        dfs(root,0)\\n        def dfs_sum(sib_val,own,height):\\n            if not own:\\n                return \\n            own.val=level_sum[height]-own.val-sib_val\\n            if own.left:\\n                left=own.left.val\\n            else:\\n                left=0\\n            right=own.right.val if own.right else 0\\n            dfs_sum(left,own.right,height+1)\\n            dfs_sum(right,own.left,height+1)\\n        dfs_sum(0,root,0)\\n        return root     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639381,
                "title": "level-order-traversal-and-hashing",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     TreeNode *replaceValueInTree(TreeNode *root)\\n    {\\n        queue<pair<TreeNode *, TreeNode *>> q;\\n        q.push({nullptr, root});\\n\\n        while (!q.empty())\\n        {\\n            unordered_map<TreeNode *, int> mp;\\n            vector<pair<TreeNode *, TreeNode *>> dummy;\\n            int tot = 0;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++)\\n            {\\n                TreeNode *par = q.front().first;\\n                TreeNode *node = q.front().second;\\n                q.pop();\\n                if (node->left)\\n                {\\n                    q.push({node, node->left});\\n                }\\n                if (node->right)\\n                {\\n                    q.push({node, node->right});\\n                }\\n\\n                if (par == nullptr)\\n                {\\n                    node->val = 0;\\n                    continue;\\n                }\\n                dummy.push_back({node, par});\\n\\n                mp[par] += node->val;\\n                tot += node->val;\\n            }\\n\\n            for (auto it : dummy)\\n            {\\n                TreeNode *node = it.first;\\n                TreeNode *par = it.second;\\n\\n                node->val = tot - mp[par];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     TreeNode *replaceValueInTree(TreeNode *root)\\n    {\\n        queue<pair<TreeNode *, TreeNode *>> q;\\n        q.push({nullptr, root});\\n\\n        while (!q.empty())\\n        {\\n            unordered_map<TreeNode *, int> mp;\\n            vector<pair<TreeNode *, TreeNode *>> dummy;\\n            int tot = 0;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++)\\n            {\\n                TreeNode *par = q.front().first;\\n                TreeNode *node = q.front().second;\\n                q.pop();\\n                if (node->left)\\n                {\\n                    q.push({node, node->left});\\n                }\\n                if (node->right)\\n                {\\n                    q.push({node, node->right});\\n                }\\n\\n                if (par == nullptr)\\n                {\\n                    node->val = 0;\\n                    continue;\\n                }\\n                dummy.push_back({node, par});\\n\\n                mp[par] += node->val;\\n                tot += node->val;\\n            }\\n\\n            for (auto it : dummy)\\n            {\\n                TreeNode *node = it.first;\\n                TreeNode *par = it.second;\\n\\n                node->val = tot - mp[par];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639184,
                "title": "easy-java-soluation-freshser",
                "content": "\\n  \\n  \\n  \\n\\n  \\n  class Pair{\\n    TreeNode node,par;\\n    public Pair(TreeNode a,TreeNode b){\\n        node =a;\\n        par =b;\\n    }\\n}\\n\\nclass Demo {\\n \\n public TreeNode replaceValueInTree(TreeNode root) {\\n \\n        Queue<Pair>q = new LinkedList<>();\\n        \\n        q.add(new Pair(root,root));\\n        \\n        while(!q.isEmpty()){\\n            int n=q.size();\\n            Queue<Pair>tq = new LinkedList<>();\\n             long sum=0;\\n            for(int i=0;i<n;i++){\\n                Pair p=q.remove();\\n                tq.add(p);\\n                sum+=p.node.val;\\n                if(p.node.left!=null){\\n                    q.add(new Pair(p.node.left,p.node));\\n                }\\n                 if(p.node.right!=null){\\n                    q.add(new Pair(p.node.right,p.node));\\n                }\\n            }\\n            //updating the value\\n            \\n            while(!tq.isEmpty()){\\n                Pair p=tq.remove();\\n               //node ans par are same example: parent node\\n                if(p.node==p.par)\\n                    p.node.val=0;\\n                else{\\n                    //if current node siblings not exist ;\\n                    if(p.par.left==null||p.par.right==null){\\n                     long tempSum=0;\\n                     tempSum=((p.par.left!=null?p.par.left.val:0)+(p.par.right!=null?p.par.right.val:0));\\n                     p.node.val=(int) (sum-tempSum);\\n                    }else{\\n                        //if current node siblings exist \\n                    \\n                    long l=p.par.left.val;\\n                    long r=p.par.right.val; \\n                     p.par.left.val=(int) (sum-(l+r));\\n                     p.par.right.val=(int) (sum-(l+r));\\n                    //both node and its siblings update together so remove its sibling for queue\\n                        tq.remove();\\n                    }\\n                   \\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "\\n  \\n  \\n  \\n\\n  \\n  class Pair{\\n    TreeNode node,par;\\n    public Pair(TreeNode a,TreeNode b){\\n        node =a;\\n        par =b;\\n    }\\n}\\n\\nclass Demo {\\n \\n public TreeNode replaceValueInTree(TreeNode root) {\\n \\n        Queue<Pair>q = new LinkedList<>();\\n        \\n        q.add(new Pair(root,root));\\n        \\n        while(!q.isEmpty()){\\n            int n=q.size();\\n            Queue<Pair>tq = new LinkedList<>();\\n             long sum=0;\\n            for(int i=0;i<n;i++){\\n                Pair p=q.remove();\\n                tq.add(p);\\n                sum+=p.node.val;\\n                if(p.node.left!=null){\\n                    q.add(new Pair(p.node.left,p.node));\\n                }\\n                 if(p.node.right!=null){\\n                    q.add(new Pair(p.node.right,p.node));\\n                }\\n            }\\n            //updating the value\\n            \\n            while(!tq.isEmpty()){\\n                Pair p=tq.remove();\\n               //node ans par are same example: parent node\\n                if(p.node==p.par)\\n                    p.node.val=0;\\n                else{\\n                    //if current node siblings not exist ;\\n                    if(p.par.left==null||p.par.right==null){\\n                     long tempSum=0;\\n                     tempSum=((p.par.left!=null?p.par.left.val:0)+(p.par.right!=null?p.par.right.val:0));\\n                     p.node.val=(int) (sum-tempSum);\\n                    }else{\\n                        //if current node siblings exist \\n                    \\n                    long l=p.par.left.val;\\n                    long r=p.par.right.val; \\n                     p.par.left.val=(int) (sum-(l+r));\\n                     p.par.right.val=(int) (sum-(l+r));\\n                    //both node and its siblings update together so remove its sibling for queue\\n                        tq.remove();\\n                    }\\n                   \\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3639091,
                "title": "java-code-using-bfs-16-ms-beats-93-of-all-java-submissions",
                "content": "# Intuition\\nUse BFS to iterate level by level, getting the level sum and for each node get the parent sum.\\nThe new node value = levelSum - parentSum.\\n\\n# Approach\\nCreate an annotated tree node class to hold the tree node and its parent children sum.\\n\\nUse standard BFS search with initial level Sum = root.val.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private class AnnotatedTreeNode {\\n\\n        public int parentSum;\\n\\n        public TreeNode node;\\n\\n        public AnnotatedTreeNode(int parentSum, TreeNode node) {\\n\\n            this.parentSum = parentSum;\\n\\n            this.node = node;\\n\\n        } \\n\\n\\n    }\\n\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        Queue<AnnotatedTreeNode> current = new LinkedList<>();\\n\\n        int levelSum = root.val;\\n\\n        current.offer(new AnnotatedTreeNode(root.val, root));\\n\\n        while (!current.isEmpty()) {\\n\\n            int sum = 0;\\n\\n            int length = current.size();\\n\\n            for (int index = 0; index < length; ++index) {\\n\\n                AnnotatedTreeNode curr = current.poll();\\n\\n                curr.node.val = levelSum - curr.parentSum;\\n\\n                int parentSum = (curr.node.left == null ? 0 : curr.node.left.val) + (curr.node.right == null ? 0 : curr.node.right.val);\\n\\n                sum += parentSum;\\n\\n                if (curr.node.left != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.left)) ;         \\n\\n                if (curr.node.right != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.right)) ;         \\n\\n           }\\n\\n           levelSum = sum;\\n\\n        }\\n\\n        return root;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private class AnnotatedTreeNode {\\n\\n        public int parentSum;\\n\\n        public TreeNode node;\\n\\n        public AnnotatedTreeNode(int parentSum, TreeNode node) {\\n\\n            this.parentSum = parentSum;\\n\\n            this.node = node;\\n\\n        } \\n\\n\\n    }\\n\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        Queue<AnnotatedTreeNode> current = new LinkedList<>();\\n\\n        int levelSum = root.val;\\n\\n        current.offer(new AnnotatedTreeNode(root.val, root));\\n\\n        while (!current.isEmpty()) {\\n\\n            int sum = 0;\\n\\n            int length = current.size();\\n\\n            for (int index = 0; index < length; ++index) {\\n\\n                AnnotatedTreeNode curr = current.poll();\\n\\n                curr.node.val = levelSum - curr.parentSum;\\n\\n                int parentSum = (curr.node.left == null ? 0 : curr.node.left.val) + (curr.node.right == null ? 0 : curr.node.right.val);\\n\\n                sum += parentSum;\\n\\n                if (curr.node.left != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.left)) ;         \\n\\n                if (curr.node.right != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.right)) ;         \\n\\n           }\\n\\n           levelSum = sum;\\n\\n        }\\n\\n        return root;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639070,
                "title": "two-solutions-pre-order-traversal-easy-to-understand",
                "content": "# Solution 1\\n\\n1439 ms Beats 68.18%\\n\\n```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    getSums(root, 0, &sums)\\n    assign(root, 0, sums)\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func getSums(_ node: TreeNode?, _ level: Int, _ sums: inout [Int]) {\\n    guard let node = node else { return }\\n    if level < sums.count {\\n        sums[level] += node.val\\n    } else {\\n        sums.append(node.val)\\n    }\\n    getSums(node.left, 1 + level, &sums)\\n    getSums(node.right, 1 + level, &sums)\\n}\\n\\nprivate func assign(_ node: TreeNode?, _ level: Int, _ sums: [Int]) {\\n    guard let node = node, (node.left != nil || node.right != nil) else { return }\\n    let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n    node.left?.val = value\\n    node.right?.val = value\\n    assign(node.left, 1 + level, sums)\\n    assign(node.right, 1 + level, sums)\\n}\\n```\\n\\n# Solution 2\\n\\n1453 ms Beats 54.54%\\n\\n```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    traverse(root, 0) { node, level in\\n        if level < sums.count {\\n            sums[level] += node.val\\n        } else {\\n            sums.append(node.val)\\n        }\\n        return true\\n    }\\n    traverse(root, 0) { node, level in\\n        guard node.left != nil || node.right != nil else { return false }\\n        let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n        node.left?.val = value\\n        node.right?.val = value\\n        return true\\n    }\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func traverse(_ node: TreeNode?, _ level: Int, _ visitAndContinue: (TreeNode, Int) -> Bool) {\\n    guard let node = node, visitAndContinue(node, level) else { return }\\n    traverse(node.left, 1 + level, visitAndContinue)\\n    traverse(node.right, 1 + level, visitAndContinue)\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Recursion"
                ],
                "code": "```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    getSums(root, 0, &sums)\\n    assign(root, 0, sums)\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func getSums(_ node: TreeNode?, _ level: Int, _ sums: inout [Int]) {\\n    guard let node = node else { return }\\n    if level < sums.count {\\n        sums[level] += node.val\\n    } else {\\n        sums.append(node.val)\\n    }\\n    getSums(node.left, 1 + level, &sums)\\n    getSums(node.right, 1 + level, &sums)\\n}\\n\\nprivate func assign(_ node: TreeNode?, _ level: Int, _ sums: [Int]) {\\n    guard let node = node, (node.left != nil || node.right != nil) else { return }\\n    let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n    node.left?.val = value\\n    node.right?.val = value\\n    assign(node.left, 1 + level, sums)\\n    assign(node.right, 1 + level, sums)\\n}\\n```\n```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    traverse(root, 0) { node, level in\\n        if level < sums.count {\\n            sums[level] += node.val\\n        } else {\\n            sums.append(node.val)\\n        }\\n        return true\\n    }\\n    traverse(root, 0) { node, level in\\n        guard node.left != nil || node.right != nil else { return false }\\n        let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n        node.left?.val = value\\n        node.right?.val = value\\n        return true\\n    }\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func traverse(_ node: TreeNode?, _ level: Int, _ visitAndContinue: (TreeNode, Int) -> Bool) {\\n    guard let node = node, visitAndContinue(node, level) else { return }\\n    traverse(node.left, 1 + level, visitAndContinue)\\n    traverse(node.right, 1 + level, visitAndContinue)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3634434,
                "title": "java-bfs-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Queue<List<TreeNode>> queue = new LinkedList<>();\\n        \\n        List<TreeNode> listRoot = new ArrayList<>();\\n        listRoot.add(root);\\n        queue.add(listRoot);\\n        int sum = 0;\\n        for (TreeNode node : listRoot)\\n            sum += node.val;\\n        \\n        map.put(0, sum);\\n        int level = -1;\\n        \\n        while (!queue.isEmpty()) {\\n            int n = queue.size();\\n            level++;\\n            for (int i = 0; i < n; i++) {\\n                List<TreeNode> list = queue.poll();\\n                int  localSum = 0;\\n                \\n                for (TreeNode node : list) {\\n                    localSum += node.val;\\n                }\\n                for (TreeNode node : list) {\\n                    node.val = map.get(level) - localSum;\\n                    List<TreeNode> list1 = new ArrayList<>();\\n                    \\n                    if (node.left != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.left.val);\\n                        list1.add(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.right.val);\\n                        list1.add(node.right);\\n                    }\\n                    if (list1.size() > 0)\\n                        queue.add(list1);\\n                }   \\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Queue<List<TreeNode>> queue = new LinkedList<>();\\n        \\n        List<TreeNode> listRoot = new ArrayList<>();\\n        listRoot.add(root);\\n        queue.add(listRoot);\\n        int sum = 0;\\n        for (TreeNode node : listRoot)\\n            sum += node.val;\\n        \\n        map.put(0, sum);\\n        int level = -1;\\n        \\n        while (!queue.isEmpty()) {\\n            int n = queue.size();\\n            level++;\\n            for (int i = 0; i < n; i++) {\\n                List<TreeNode> list = queue.poll();\\n                int  localSum = 0;\\n                \\n                for (TreeNode node : list) {\\n                    localSum += node.val;\\n                }\\n                for (TreeNode node : list) {\\n                    node.val = map.get(level) - localSum;\\n                    List<TreeNode> list1 = new ArrayList<>();\\n                    \\n                    if (node.left != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.left.val);\\n                        list1.add(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.right.val);\\n                        list1.add(node.right);\\n                    }\\n                    if (list1.size() > 0)\\n                        queue.add(list1);\\n                }   \\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632507,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\n//RITIK PATEL\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> que = new LinkedList();\\n        HashMap<TreeNode,TreeNode> par = new HashMap();\\n        HashMap<Integer, Integer> levelSum = new HashMap();\\n        que.add(root);\\n        par.put(root, null);\\n        int level = 0;\\n        while(que.size()!=0){\\n            int size = que.size();\\n            int sum = 0;\\n            level+=1;\\n            while(size!=0){\\n                size--;\\n                TreeNode top = que.poll();\\n                sum+=top.val;\\n                if(top.left!=null){\\n                    que.add(top.left);\\n                    par.put(top.left,top);\\n                }\\n                if(top.right!=null){\\n                    que.add(top.right);\\n                    par.put(top.right,top);\\n                }\\n            }\\n            levelSum.put(level,sum);\\n        }\\n        TreeNode newNode = new TreeNode();\\n        DFS(root,newNode, par,levelSum,1);\\n        return newNode;   \\n    }\\n    void DFS(TreeNode root,TreeNode newNode, HashMap<TreeNode,TreeNode> par,HashMap<Integer, Integer> levelSum, int level){\\n        //check neighbour\\n        newNode.val = levelSum.get(level);\\n        TreeNode parent = par.get(root);\\n        if(parent!=null){\\n            int val = 0;\\n            if(parent.left!=null){\\n                val = parent.left.val;\\n            }\\n            if(parent.right!=null){\\n                val += parent.right.val;\\n            }\\n            newNode.val-=val;\\n        }\\n        else{\\n            newNode.val-=root.val;\\n        }\\n        if(root.left!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.left = node;\\n            DFS(root.left, newNode.left, par, levelSum, level+1);\\n        }\\n        if(root.right!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.right = node;\\n            DFS(root.right, newNode.right, par, levelSum, level+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n//RITIK PATEL\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> que = new LinkedList();\\n        HashMap<TreeNode,TreeNode> par = new HashMap();\\n        HashMap<Integer, Integer> levelSum = new HashMap();\\n        que.add(root);\\n        par.put(root, null);\\n        int level = 0;\\n        while(que.size()!=0){\\n            int size = que.size();\\n            int sum = 0;\\n            level+=1;\\n            while(size!=0){\\n                size--;\\n                TreeNode top = que.poll();\\n                sum+=top.val;\\n                if(top.left!=null){\\n                    que.add(top.left);\\n                    par.put(top.left,top);\\n                }\\n                if(top.right!=null){\\n                    que.add(top.right);\\n                    par.put(top.right,top);\\n                }\\n            }\\n            levelSum.put(level,sum);\\n        }\\n        TreeNode newNode = new TreeNode();\\n        DFS(root,newNode, par,levelSum,1);\\n        return newNode;   \\n    }\\n    void DFS(TreeNode root,TreeNode newNode, HashMap<TreeNode,TreeNode> par,HashMap<Integer, Integer> levelSum, int level){\\n        //check neighbour\\n        newNode.val = levelSum.get(level);\\n        TreeNode parent = par.get(root);\\n        if(parent!=null){\\n            int val = 0;\\n            if(parent.left!=null){\\n                val = parent.left.val;\\n            }\\n            if(parent.right!=null){\\n                val += parent.right.val;\\n            }\\n            newNode.val-=val;\\n        }\\n        else{\\n            newNode.val-=root.val;\\n        }\\n        if(root.left!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.left = node;\\n            DFS(root.left, newNode.left, par, levelSum, level+1);\\n        }\\n        if(root.right!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.right = node;\\n            DFS(root.right, newNode.right, par, levelSum, level+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620265,
                "title": "python-dfs-modify-tree-in-place",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTrack the layer sum and the sum of every node\\'s immediate children node. \\nSibling sum for any node becomes (layerSum - the children sum from parent).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![IMG_0007.jpg](https://assets.leetcode.com/users/images/5b293152-1994-4c3d-a704-910845a7f97c_1686371153.119484.jpeg)\\n\\n\\nDFS once to calculate layerSum. In the same DFS pass, calculate the sum of immediate children and store the sum in parent node.\\n\\nDFS a second time, for each node, we want to set its children to the (layerSum - the children sum this node is tracking), then reset the sibling sum of itself.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(L), where L is the number of layers.\\n\\n# Code\\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        layerSum = collections.defaultdict(int)\\n\\n        def dfs1(node, layer):\\n            if node is None:\\n                return\\n            layerSum[layer] += node.val\\n            leftSum = node.left.val if node.left else 0\\n            rightSum = node.right.val if node.right else 0\\n            node.val = leftSum + rightSum\\n            dfs1(node.left, layer+1)\\n            dfs1(node.right, layer+1)\\n        \\n        dfs1(root, 0)\\n\\n        def setSiblingSum(node, layer, ss):\\n            if node is None:\\n                return\\n            siblingSum = layerSum[layer+1] - node.val\\n            setSiblingSum(node.left, layer+1, siblingSum)\\n            setSiblingSum(node.right, layer+1, siblingSum)\\n            node.val = ss\\n\\n        setSiblingSum(root.left, 1, 0)\\n        setSiblingSum(root.right, 1, 0)\\n        root.val = 0\\n        return root\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        layerSum = collections.defaultdict(int)\\n\\n        def dfs1(node, layer):\\n            if node is None:\\n                return\\n            layerSum[layer] += node.val\\n            leftSum = node.left.val if node.left else 0\\n            rightSum = node.right.val if node.right else 0\\n            node.val = leftSum + rightSum\\n            dfs1(node.left, layer+1)\\n            dfs1(node.right, layer+1)\\n        \\n        dfs1(root, 0)\\n\\n        def setSiblingSum(node, layer, ss):\\n            if node is None:\\n                return\\n            siblingSum = layerSum[layer+1] - node.val\\n            setSiblingSum(node.left, layer+1, siblingSum)\\n            setSiblingSum(node.right, layer+1, siblingSum)\\n            node.val = ss\\n\\n        setSiblingSum(root.left, 1, 0)\\n        setSiblingSum(root.right, 1, 0)\\n        root.val = 0\\n        return root\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615361,
                "title": "bfs-96-time-99-space",
                "content": "```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # 2023/06/08 13:30PM -> 13:55PM\\n        total, q = root.val, collections.deque([(root, root.val)])\\n        while q:\\n            new_total = 0\\n            for _ in range(len(q)):\\n                cur, vals = q.popleft()\\n                l = cur.left.val if cur.left else 0\\n                r = cur.right.val if cur.right else 0\\n                new_total += (l + r)\\n                if cur.left:\\n                    q.append((cur.left, l + r))\\n                if cur.right:\\n                    q.append((cur.right, l + r))\\n                cur.val = total - vals\\n            total = new_total\\n        return root\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # 2023/06/08 13:30PM -> 13:55PM\\n        total, q = root.val, collections.deque([(root, root.val)])\\n        while q:\\n            new_total = 0\\n            for _ in range(len(q)):\\n                cur, vals = q.popleft()\\n                l = cur.left.val if cur.left else 0\\n                r = cur.right.val if cur.right else 0\\n                new_total += (l + r)\\n                if cur.left:\\n                    q.append((cur.left, l + r))\\n                if cur.right:\\n                    q.append((cur.right, l + r))\\n                cur.val = total - vals\\n            total = new_total\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3589099,
                "title": "bfs-explained",
                "content": "# Intuition\\nWe need cousins how can we get it my first reaction was level order traversal. Now bfs offers same but efficiently.\\n\\n# Approach\\nSimply run bfs and have a vector or a set your call and on each level take the sum of the nodes at that level and keep inserting them in the vector. Once a level has been traversed for every child of the node in the vector subract the left and right value and voila what is left is the value of it\\'s cousin.\\nRemember you have subtracted the left and right values of each node so if any value is left it is definitely the cousin.\\n\\n# Complexity\\n- Time complexity:\\nO(v+e)\\n\\n- Space complexity:\\n- o(max number of nodes at any level) o(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        root->val=0;// initialising the root to be 0 as it has 0 cousin;\\n        queue<TreeNode*> q; q.push(root);\\n        while(!q.empty()){\\n            vector<TreeNode*> buffer;\\n            int szq=q.size();\\n            int sum=0;\\n            while(szq--){\\n                TreeNode* curr=q.front();\\n                buffer.push_back(curr);\\n                q.pop();\\n                if(curr->left){\\n                    q.push(curr->left);\\n                    sum+=curr->left->val;\\n                }if(curr->right){\\n                    q.push(curr->right);\\n                    sum+=curr->right->val;\\n                }\\n            }\\n            for(TreeNode* nodes:buffer){\\n                int temp=sum;\\n                if(nodes->left)temp-=nodes->left->val;\\n                if(nodes->right)temp-=nodes->right->val;\\n                if(nodes->left)nodes->left->val=temp;\\n                if(nodes->right)nodes->right->val=temp;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        root->val=0;// initialising the root to be 0 as it has 0 cousin;\\n        queue<TreeNode*> q; q.push(root);\\n        while(!q.empty()){\\n            vector<TreeNode*> buffer;\\n            int szq=q.size();\\n            int sum=0;\\n            while(szq--){\\n                TreeNode* curr=q.front();\\n                buffer.push_back(curr);\\n                q.pop();\\n                if(curr->left){\\n                    q.push(curr->left);\\n                    sum+=curr->left->val;\\n                }if(curr->right){\\n                    q.push(curr->right);\\n                    sum+=curr->right->val;\\n                }\\n            }\\n            for(TreeNode* nodes:buffer){\\n                int temp=sum;\\n                if(nodes->left)temp-=nodes->left->val;\\n                if(nodes->right)temp-=nodes->right->val;\\n                if(nodes->left)nodes->left->val=temp;\\n                if(nodes->right)nodes->right->val=temp;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588991,
                "title": "c-solution-level-order-traversal",
                "content": "# Intuition\\nWe will perform level-order traversal on the tree, ans calculate the sum of all the nodes on the levels, ans store the sum of all nodes for the respective parent nodes for each node on that level. Then change the node values by `(total sum of all the nodes in that level) - (sum of nodes of that parent).`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, TreeNode*>> q;\\n        q.push({NULL, root});\\n        while(q.size()){\\n           int s = q.size(), sum=0;\\n           unordered_map<TreeNode*, int> sumIn;\\n           vector<pair<TreeNode*, TreeNode*>> layer;\\n           while(s--){\\n                auto [parent, node] = q.front();\\n                sum+=node->val;\\n                layer.push_back({parent, node});\\n                q.pop();\\n                sumIn[parent]+=node->val;\\n                if(node->left) q.push({node, node->left});\\n                if(node->right) q.push({node, node->right});\\n           }\\n           for(auto &[parent, node]: layer)\\n                if(parent==nullptr)\\n                    node->val = 0;\\n                else\\n                    node->val = sum-sumIn[parent];\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, TreeNode*>> q;\\n        q.push({NULL, root});\\n        while(q.size()){\\n           int s = q.size(), sum=0;\\n           unordered_map<TreeNode*, int> sumIn;\\n           vector<pair<TreeNode*, TreeNode*>> layer;\\n           while(s--){\\n                auto [parent, node] = q.front();\\n                sum+=node->val;\\n                layer.push_back({parent, node});\\n                q.pop();\\n                sumIn[parent]+=node->val;\\n                if(node->left) q.push({node, node->left});\\n                if(node->right) q.push({node, node->right});\\n           }\\n           for(auto &[parent, node]: layer)\\n                if(parent==nullptr)\\n                    node->val = 0;\\n                else\\n                    node->val = sum-sumIn[parent];\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587175,
                "title": "java-solution-92-runtime-62-memory-bfs-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need to replace the value of each node in the tree with the sum of all its cousins\\' values, we shall use **Breadth First Traversal**. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile traversing any level, we will be adding the next level node\\'s value to a int variable `nextLevelSum` and we will push the left and right child of the current level nodes by modifying it\\'s `val`. The modified value will be the sum of that node\\'s `val` and it\\'s cousin\\'s `val`.\\nThis modification is done so that in the next level traversal, we can use the `nextLevelSum` by assigning it to `curLevelSum` and the final `val` of the current level nodes will be `curLevelSum - node.val`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null)return root;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int nextLevelSum = root.val;\\n        int curLevelSum = 0;\\n        while(!q.isEmpty()){\\n            curLevelSum = nextLevelSum;\\n            nextLevelSum = 0;\\n            Queue<TreeNode> temp = new LinkedList<>();\\n            while(!q.isEmpty()){\\n                TreeNode t = q.poll();\\n                t.val = curLevelSum-t.val;\\n                if(t.left!=null && t.right!=null){\\n                    nextLevelSum+=t.left.val;\\n                    nextLevelSum+=t.right.val;\\n\\n                    int val = t.left.val + t.right.val;\\n                    t.left.val = val;\\n                    t.right.val = val;\\n\\n                    temp.add(t.left);\\n                    temp.add(t.right);\\n                }else if(t.left!=null){\\n                    nextLevelSum+=t.left.val;\\n                    temp.add(t.left);\\n                }else if(t.right!=null){\\n                    nextLevelSum+=t.right.val;\\n                    temp.add(t.right);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null)return root;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int nextLevelSum = root.val;\\n        int curLevelSum = 0;\\n        while(!q.isEmpty()){\\n            curLevelSum = nextLevelSum;\\n            nextLevelSum = 0;\\n            Queue<TreeNode> temp = new LinkedList<>();\\n            while(!q.isEmpty()){\\n                TreeNode t = q.poll();\\n                t.val = curLevelSum-t.val;\\n                if(t.left!=null && t.right!=null){\\n                    nextLevelSum+=t.left.val;\\n                    nextLevelSum+=t.right.val;\\n\\n                    int val = t.left.val + t.right.val;\\n                    t.left.val = val;\\n                    t.right.val = val;\\n\\n                    temp.add(t.left);\\n                    temp.add(t.right);\\n                }else if(t.left!=null){\\n                    nextLevelSum+=t.left.val;\\n                    temp.add(t.left);\\n                }else if(t.right!=null){\\n                    nextLevelSum+=t.right.val;\\n                    temp.add(t.right);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581166,
                "title": "bfs-very-detailed-comments-so-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581163,
                "title": "bfs-very-detailed-comments-so-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571273,
                "title": "bfs-easy-java-solution-beats-90-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        List<Integer> level_sum = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int sum = 0;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                sum += res.val;\\n\\n                if(res.left != null){\\n                    q.offer(res.left);\\n                }\\n                if(res.right != null){\\n                    q.offer(res.right);\\n                }\\n            }\\n\\n            level_sum.add(sum);\\n        }\\n\\n        int i = 0;\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            i++;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                int sum = 0;\\n\\n                if(res.left != null){\\n                    q.add(res.left);\\n                    sum += res.left.val;\\n                }\\n\\n                if(res.right != null){\\n                    q.add(res.right);\\n                    sum += res.right.val;\\n                }\\n                if(res.left != null){\\n                    res.left.val = level_sum.get(i) - sum;\\n                }\\n\\n                if(res.right != null){\\n                    res.right.val = level_sum.get(i) - sum;\\n                }\\n\\n            }\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        List<Integer> level_sum = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int sum = 0;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                sum += res.val;\\n\\n                if(res.left != null){\\n                    q.offer(res.left);\\n                }\\n                if(res.right != null){\\n                    q.offer(res.right);\\n                }\\n            }\\n\\n            level_sum.add(sum);\\n        }\\n\\n        int i = 0;\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            i++;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                int sum = 0;\\n\\n                if(res.left != null){\\n                    q.add(res.left);\\n                    sum += res.left.val;\\n                }\\n\\n                if(res.right != null){\\n                    q.add(res.right);\\n                    sum += res.right.val;\\n                }\\n                if(res.left != null){\\n                    res.left.val = level_sum.get(i) - sum;\\n                }\\n\\n                if(res.right != null){\\n                    res.right.val = level_sum.get(i) - sum;\\n                }\\n\\n            }\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568189,
                "title": "c-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (!root)\\n            return root;\\n        deque<pair<TreeNode*, TreeNode*>> deque;\\n        deque.push_back({root, nullptr});\\n        while (!deque.empty()) \\n        {\\n            int totalSum = 0;\\n            for (const auto& [node, _] : deque)\\n                totalSum += node -> val;\\n            int qSize = deque.size();\\n            while (qSize) \\n            {\\n                auto [firstChild, firstChildParent] = deque.front();\\n                deque.pop_front();\\n                --qSize;\\n                if (deque.empty())\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                    if (firstChild -> left)\\n                        deque.push_back({firstChild -> left, firstChild});\\n                    if (firstChild -> right)\\n                        deque.push_back({firstChild -> right, firstChild});\\n                    continue;\\n                }\\n                auto [secondChild, secondChildParent] = deque.front();\\n                if (firstChild -> left)\\n                    deque.push_back({firstChild -> left, firstChild});\\n                if (firstChild -> right)\\n                    deque.push_back({firstChild -> right, firstChild});\\n                if (firstChildParent == secondChildParent)\\n                {\\n                    deque.pop_front();\\n                    --qSize;\\n                    int newVal = totalSum - (firstChild -> val + secondChild -> val);\\n                    firstChild -> val = newVal;\\n                    secondChild -> val = newVal;\\n                    if (secondChild -> left)\\n                        deque.push_back({secondChild -> left, secondChild});\\n                    if (secondChild -> right)\\n                        deque.push_back({secondChild -> right, secondChild});\\n                }\\n                else\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (!root)\\n            return root;\\n        deque<pair<TreeNode*, TreeNode*>> deque;\\n        deque.push_back({root, nullptr});\\n        while (!deque.empty()) \\n        {\\n            int totalSum = 0;\\n            for (const auto& [node, _] : deque)\\n                totalSum += node -> val;\\n            int qSize = deque.size();\\n            while (qSize) \\n            {\\n                auto [firstChild, firstChildParent] = deque.front();\\n                deque.pop_front();\\n                --qSize;\\n                if (deque.empty())\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                    if (firstChild -> left)\\n                        deque.push_back({firstChild -> left, firstChild});\\n                    if (firstChild -> right)\\n                        deque.push_back({firstChild -> right, firstChild});\\n                    continue;\\n                }\\n                auto [secondChild, secondChildParent] = deque.front();\\n                if (firstChild -> left)\\n                    deque.push_back({firstChild -> left, firstChild});\\n                if (firstChild -> right)\\n                    deque.push_back({firstChild -> right, firstChild});\\n                if (firstChildParent == secondChildParent)\\n                {\\n                    deque.pop_front();\\n                    --qSize;\\n                    int newVal = totalSum - (firstChild -> val + secondChild -> val);\\n                    firstChild -> val = newVal;\\n                    secondChild -> val = newVal;\\n                    if (secondChild -> left)\\n                        deque.push_back({secondChild -> left, secondChild});\\n                    if (secondChild -> right)\\n                        deque.push_back({secondChild -> right, secondChild});\\n                }\\n                else\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556994,
                "title": "c-single-method-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n    public class Solution\\n    {\\n        public TreeNode ReplaceValueInTree(TreeNode root)\\n        {\\n            var wave = new List<TreeNode>();\\n            var nextWave = new List<TreeNode>();\\n\\n            wave.Add(root);\\n\\n            while (wave.Count > 0)\\n            {\\n                var waveSum = 0;\\n\\n                foreach (var node in wave)\\n                {\\n                    if (node != null)\\n                    {\\n                        nextWave.Add(node?.left);\\n                        nextWave.Add(node?.right);\\n                        waveSum += node.val;\\n                    }\\n                }\\n\\n                var couple = 0;\\n\\n                for (int i = 0; i < wave.Count; i++)\\n                {\\n                    if (i % 2 == 0)\\n                    {\\n                        couple = 0;\\n                        if (wave[i] != null) couple += wave[i].val;\\n                        if (i + 1 < wave.Count && wave[i + 1] != null) couple += wave[i + 1].val;\\n                    }\\n                    if (wave[i] != null) wave[i].val = waveSum - couple;\\n                }\\n\\n                wave = nextWave;\\n                nextWave = new List<TreeNode>();\\n            }\\n            return root;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n    public class Solution\\n    {\\n        public TreeNode ReplaceValueInTree(TreeNode root)\\n        {\\n            var wave = new List<TreeNode>();\\n            var nextWave = new List<TreeNode>();\\n\\n            wave.Add(root);\\n\\n            while (wave.Count > 0)\\n            {\\n                var waveSum = 0;\\n\\n                foreach (var node in wave)\\n                {\\n                    if (node != null)\\n                    {\\n                        nextWave.Add(node?.left);\\n                        nextWave.Add(node?.right);\\n                        waveSum += node.val;\\n                    }\\n                }\\n\\n                var couple = 0;\\n\\n                for (int i = 0; i < wave.Count; i++)\\n                {\\n                    if (i % 2 == 0)\\n                    {\\n                        couple = 0;\\n                        if (wave[i] != null) couple += wave[i].val;\\n                        if (i + 1 < wave.Count && wave[i + 1] != null) couple += wave[i + 1].val;\\n                    }\\n                    if (wave[i] != null) wave[i].val = waveSum - couple;\\n                }\\n\\n                wave = nextWave;\\n                nextWave = new List<TreeNode>();\\n            }\\n            return root;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2040655,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 2010958,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1931021,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1930458,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1864489,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1864324,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Calculate Delayed Arrival Time",
        "question_content": "<p>You are given a positive integer <code>arrivalTime</code> denoting the arrival time of a train in hours, and another positive integer <code>delayedTime</code> denoting the amount of delay in hours.</p>\n\n<p>Return <em>the time when the train will arrive at the station.</em></p>\n\n<p>Note that the time in this problem is in 24-hours format.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arrivalTime = 15, delayedTime = 5 \n<strong>Output:</strong> 20 \n<strong>Explanation:</strong> Arrival time of the train was 15:00 hours. It is delayed by 5 hours. Now it will reach at 15+5 = 20 (20:00 hours).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arrivalTime = 13, delayedTime = 11\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Arrival time of the train was 13:00 hours. It is delayed by 11 hours. Now it will reach at 13+11=24 (Which is denoted by 00:00 in 24 hours format so return 0).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arrivaltime &lt;&nbsp;24</code></li>\n\t<li><code>1 &lt;= delayedTime &lt;= 24</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3446050,
                "title": "one-liner-using-modulo-24-very-simple-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n};\\n```\\n<b> Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446040,
                "title": "leetcode-the-hard-way-one-line",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```\\n\\n```java\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```\n```java\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445952,
                "title": "easiest-best-solution-in-3-lines-time-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n        //     Or\\n        // if(a+b>=24) return (a+b)-24;\\n        // else return a+b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n        //     Or\\n        // if(a+b>=24) return (a+b)-24;\\n        // else return a+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445669,
                "title": "simple-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int aT, int dT) {\\n        return (aT+dT)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int aT, int dT) {\\n        return (aT+dT)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446380,
                "title": "c-python-o-1-time-and-space",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int at, int dt) {\\n        int arrive = at + dt;\\n        return arrive >= 24 ? arrive - 24 : arrive;\\n    }\\n};\\n```\\n\\n# Python / Python 3\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, at: int, dt: int) -> int:\\n        arrive = at + dt\\n        if arrive >= 24:\\n            return arrive - 24\\n        return arrive\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int at, int dt) {\\n        int arrive = at + dt;\\n        return arrive >= 24 ? arrive - 24 : arrive;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, at: int, dt: int) -> int:\\n        arrive = at + dt\\n        if arrive >= 24:\\n            return arrive - 24\\n        return arrive\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492584,
                "title": "c-math-retuen-a-b-24",
                "content": "# Complexity\\n- Time complexity:\\no(1)\\n\\n- Space complexity:\\n(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488470,
                "title": "python-go-easy-solution",
                "content": "# Python\\u2705\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n            return (arrivalTime + delayedTime)%24\\n}\\n```\\n# Go\\u2705\\n```\\nfunc findDelayedArrivalTime(arrivalTime int, delayedTime int) int {\\n    return (arrivalTime+delayedTime)%24\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n            return (arrivalTime + delayedTime)%24\\n}\\n```\n```\\nfunc findDelayedArrivalTime(arrivalTime int, delayedTime int) int {\\n    return (arrivalTime+delayedTime)%24\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469224,
                "title": "simple-one-line-solution",
                "content": "\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3445936,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime)%24\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime)%24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592642,
                "title": "very-easy-java-solution-beats-100-runtime-0ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int arriveAt = arrivalTime + delayedTime;\\n        if(arriveAt >= 24) return (arriveAt - 24);\\n        else return arriveAt;\\n    }\\n}\\n```\\n\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int arriveAt = arrivalTime + delayedTime;\\n        if(arriveAt >= 24) return (arriveAt - 24);\\n        else return arriveAt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545787,
                "title": "java-just-2-line-and-that-s-it",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime >= 24) return Math.abs((arrivalTime+delayedTime) - 24);\\n        return arrivalTime+delayedTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime >= 24) return Math.abs((arrivalTime+delayedTime) - 24);\\n        return arrivalTime+delayedTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446023,
                "title": "javascript-2651-calculate-delayed-arrival-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar findDelayedArrivalTime = function (arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n};\\n```\\n\\n---\\n\\n**Contest**\\n- https://leetcode.com/contest/weekly-contest-342/ranking/67/\\n\\n**All Answers**\\n- **Q1** - https://leetcode.com/problems/calculate-delayed-arrival-time/solutions/3446023/javascript-2651-calculate-delayed-arrival-time/?orderBy=most_votes\\n- **Q2** - https://leetcode.com/problems/sum-multiples/solutions/3446027/javascript-2652-sum-multiples/?orderBy=most_votes\\n- **Q3** - https://leetcode.com/problems/sliding-subarray-beauty/solutions/3446035/javascript-2653-sliding-subarray-beauty/?orderBy=most_votes\\n- **Q4** - https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solutions/3446411/javascript-2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1/?orderBy=most_votes\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/37970e7b-b559-4aa9-834c-e178df5ddaa7_1682232917.7638698.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findDelayedArrivalTime = function (arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445855,
                "title": "two-liner-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAns is totalTime%24.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find total time and return totaltime % 24.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n       int time=arrivalTime+delayedTime;\\n        return time%24;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n       int time=arrivalTime+delayedTime;\\n        return time%24;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445660,
                "title": "java-one-liner",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478275,
                "title": "1-liner-c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447662,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(1)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447038,
                "title": "c-oneliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTypical modulo arithmetic problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple formula\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindDelayedArrivalTime(int arrivalTime, int delayedTime) => \\n      (arrivalTime + delayedTime) % 24;    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindDelayedArrivalTime(int arrivalTime, int delayedTime) => \\n      (arrivalTime + delayedTime) % 24;    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446669,
                "title": "100-fast-and-space-optimized-c-1-liner",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrival, int delay) {\\n        return (arrival+delay)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Design"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrival, int delay) {\\n        return (arrival+delay)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446085,
                "title": "1line-c",
                "content": "````\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446053,
                "title": "easy-and-simplest-c-approach-1-line-code",
                "content": "# Intuition\\n sum of arrival and delayed time was done and remainder of sum is returned \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$ \\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sum = arrivalTime + delayedTime ;\\n                return sum % 24 ;\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sum = arrivalTime + delayedTime ;\\n                return sum % 24 ;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445791,
                "title": "c-well-explained-1-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445703,
                "title": "one-line-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445682,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arr, int del) {\\n        return (arr+del)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arr, int del) {\\n        return (arr+del)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097910,
                "title": "solution-of-calculate-delayed-arrival-time-problem",
                "content": "# Approach\\n- The problem of availability of 24 hours is solved using %\\n\\n# Complexity\\n- Time complexity:\\nO(1) - as, no functions were called\\n\\n- Space complexity:\\nO(1) - as, no extra space is required.\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966648,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int a=arrivalTime+delayedTime;\\n      return a%24;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int a=arrivalTime+delayedTime;\\n      return a%24;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865349,
                "title": "java-one-liner-0ms-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748908,
                "title": "one-liner",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return ((arrivalTime+delayedTime)%24);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return ((arrivalTime+delayedTime)%24);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710960,
                "title": "super-easy-simpe-great-best-start-good-solution-in-js-d",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    let time = arrivalTime + delayedTime\\n    return time >= 24 ? time - 24 : time\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    let time = arrivalTime + delayedTime\\n    return time >= 24 ? time - 24 : time\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710748,
                "title": "calculate-delayed-arrival-time-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time = 24;\\n        int temp_time = arrivalTime + delayedTime;\\n        if(temp_time > time){\\n            temp_time = temp_time % time;\\n            return temp_time;\\n        }\\n        else if(time > temp_time){\\n            return temp_time;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time = 24;\\n        int temp_time = arrivalTime + delayedTime;\\n        if(temp_time > time){\\n            temp_time = temp_time % time;\\n            return temp_time;\\n        }\\n        else if(time > temp_time){\\n            return temp_time;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651228,
                "title": "beats-in-runtime-and-97-beats-in-memory-usage-easy-solution-with-one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590637,
                "title": "actual-one-liner-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDay resets at 24.So the count gets set back to 0 upon time>=24;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf delay==24 we reset it 0. Delay caps at 24,so simply mod 24 works.\\nNow for the final time,it is just addition but we will reset to 0 after 23.\\nThus,we again with mod 24 over the final sum.\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public:\\n        int findDelayedArrivalTime(int a,int d) \\n        {\\n            return (a+(d%24))%24;\\n        }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n        int findDelayedArrivalTime(int a,int d) \\n        {\\n            return (a+(d%24))%24;\\n        }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533404,
                "title": "simplest-efficient-1-liner-c-code-time-o-1-space-o-1",
                "content": "# Intuition\\nThe problem asks for finding the delayed arrival time given the original arrival time and the amount of delay. We need to consider the possibility of the arrival time crossing midnight (i.e., going beyond 24 hours).\\n\\n# Approach\\nTo solve this problem, we can use the modulus operator (%), which calculates the remainder when the arrival time and delayed time are divided by 24. This operation ensures that the result is always within the range of 0 to 23, representing the hours of a day. By adding the arrival time and delayed time together and then taking the modulus 24, we can find the delayed arrival time.\\n\\nFor example, if the arrival time is 20 (8 PM) and the delayed time is 6, adding them together gives us 26. Taking the modulus 24 of 26, we get 2, which represents 2 AM, indicating the delayed arrival time.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is $O(1)$ since it only involves a simple calculation and a modulus operation, which are constant time operations.\\n\\n- Space complexity: The space complexity is also $O(1)$ as there is no additional space used apart from the return value.\\n\\n# Code\\n```\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime){\\n    return (arrivalTime + delayedTime)%24;}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime){\\n    return (arrivalTime + delayedTime)%24;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479012,
                "title": "c-easy-solution-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      \\n        int sum=arrivalTime+delayedTime;\\n\\n        if(sum==24){\\n            sum=0;\\n        }\\n        else if(sum>24){\\n            sum=sum-24;\\n        }\\n   return sum; }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      \\n        int sum=arrivalTime+delayedTime;\\n\\n        if(sum==24){\\n            sum=0;\\n        }\\n        else if(sum>24){\\n            sum=sum-24;\\n        }\\n   return sum; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463571,
                "title": "easy-1-liner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        int x = (a+b);\\n        return x%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        int x = (a+b);\\n        return x%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453891,
                "title": "simple-way-to-find-out-time-using-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrival, int delayed) {\\n        \\n        int time =0;\\n   if(arrival + delayed >=24)\\n       return ( arrival + delayed - 24);\\n\\n       else{\\n           time = arrival + delayed;\\n       }\\n     \\n        return time;\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrival, int delayed) {\\n        \\n        int time =0;\\n   if(arrival + delayed >=24)\\n       return ( arrival + delayed - 24);\\n\\n       else{\\n           time = arrival + delayed;\\n       }\\n     \\n        return time;\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453850,
                "title": "beats-100-simple-ready-to-begin-question-in-cpp-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we can see we have to convert total time taken by train ie(arrivalTime + delayedTime)in 24 hour format. We calculate total time and if it is greater than 23 then take mod 24 of that time and return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time=arrivalTime+delayedTime;\\n        if(time>23){\\n        time=time%24;}\\n        return time;\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time=arrivalTime+delayedTime;\\n        if(time>23){\\n        time=time%24;}\\n        return time;\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449994,
                "title": "one-liner-code-in-java-python-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt adds the delayed time to the arrival time, and then calculates the modulo 24.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n```\\n```python []\\ndef findDelayedArrivalTime(arrivalTime, delayedTime):\\n    return (arrivalTime + delayedTime) % 24\\n\\n```\\n```C++ []\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```JAVA []\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n```\n```python []\\ndef findDelayedArrivalTime(arrivalTime, delayedTime):\\n    return (arrivalTime + delayedTime) % 24\\n\\n```\n```C++ []\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3447596,
                "title": "easiest-one-line-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int at, int dt) {\\n         return (at + dt) %24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int at, int dt) {\\n         return (at + dt) %24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447112,
                "title": "learn-maths-ye-nahi-dekha-to-kya-dekha",
                "content": "# Intuition\\n```AGAR YE BHI NAHI HUA TO BHAI APKO CODING BADME SIKHNI HAI FIRST LEARN BASICS OF MATHEMATICS. (NO NEED TO OFFEND JUST KIDDING \\uD83E\\uDD71\\uD83D\\uDE25\\uD83D\\uDE1E)```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```AGAR YE BHI NAHI HUA TO BHAI APKO CODING BADME SIKHNI HAI FIRST LEARN BASICS OF MATHEMATICS. (NO NEED TO OFFEND JUST KIDDING \\uD83E\\uDD71\\uD83D\\uDE25\\uD83D\\uDE1E)```\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446862,
                "title": "one-liner-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a + b) % 24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a + b) % 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446651,
                "title": "python3-simple-one-line",
                "content": "Just sum the arrivalTime and the delayedTime and check if the sum is outside the limits of 24.\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return arrivalTime + delayedTime if arrivalTime + delayedTime < 24 else arrivalTime + delayedTime - 24\\n```\\nor shorter version using **mod**:\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return arrivalTime + delayedTime if arrivalTime + delayedTime < 24 else arrivalTime + delayedTime - 24\\n```\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446635,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans=arrivalTime+delayedTime;\\n        if(ans>=24){\\n            return ans-24;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans=arrivalTime+delayedTime;\\n        if(ans>=24){\\n            return ans-24;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446531,
                "title": "java-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans=arrivalTime+delayedTime;\\n        if(ans>=24){\\n            return ans-24;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans=arrivalTime+delayedTime;\\n        if(ans>=24){\\n            return ans-24;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446119,
                "title": "easy-c-1-line-code-beats-100-time",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445953,
                "title": "simple-logic-c-no-need-of-modulo-operator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime)\\n{\\n    if (arrivalTime + delayedTime < 24)\\n    {\\n        return arrivalTime + delayedTime;\\n    }\\n    else\\n    {\\n        return arrivalTime + delayedTime - 24;\\n    }\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime)\\n{\\n    if (arrivalTime + delayedTime < 24)\\n    {\\n        return arrivalTime + delayedTime;\\n    }\\n    else\\n    {\\n        return arrivalTime + delayedTime - 24;\\n    }\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445935,
                "title": "c-one-line-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n      \\n        return (a+d)%24;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n      \\n        return (a+d)%24;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445714,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        if arrivalTime + delayedTime == 24: return 0\\n        elif arrivalTime + delayedTime > 24: return abs(24 - (arrivalTime + delayedTime))\\n        else: return arrivalTime + delayedTime\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        if arrivalTime + delayedTime == 24: return 0\\n        elif arrivalTime + delayedTime > 24: return abs(24 - (arrivalTime + delayedTime))\\n        else: return arrivalTime + delayedTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445676,
                "title": "c-a-d-24",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101341,
                "title": "java-one-line-solution-beats-100",
                "content": "# Approach\\nJust simply using modulo to get the remainder, which is the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100994,
                "title": "simple-and-easy-to-understand-java-solution-2liner",
                "content": "\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int actualTime = arrivalTime + delayedTime;\\n        return actualTime%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int actualTime = arrivalTime + delayedTime;\\n        return actualTime%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092377,
                "title": "3line-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int time=arrivalTime+delayedTime;\\n      if(time>=24){\\n          return time%24;\\n      }  else return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int time=arrivalTime+delayedTime;\\n      if(time>=24){\\n          return time%24;\\n      }  else return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089448,
                "title": "0-ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085284,
                "title": "best-java-solution-for-beginners-beats-100",
                "content": "**UP VOTE IF YOU LIKE IT**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int val=arrivalTime+delayedTime;\\n        if(val<=23){\\n            return val;\\n        }\\n        else{\\n            int val2=val-24;\\n            if (val==24){\\n                return 0;\\n            }\\n            return val2;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int val=arrivalTime+delayedTime;\\n        if(val<=23){\\n            return val;\\n        }\\n        else{\\n            int val2=val-24;\\n            if (val==24){\\n                return 0;\\n            }\\n            return val2;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082219,
                "title": "php-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $arrivalTime\\n     * @param Integer $delayedTime\\n     * @return Integer\\n     */\\n    function findDelayedArrivalTime($arrivalTime, $delayedTime) {\\n        $result = $arrivalTime + $delayedTime;\\n        // return $result;\\n        if($result == \\'24\\'){\\n          return \\'0\\';\\n        }else if($result > \\'24\\'){\\n         return  $result - \\'24\\';\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $arrivalTime\\n     * @param Integer $delayedTime\\n     * @return Integer\\n     */\\n    function findDelayedArrivalTime($arrivalTime, $delayedTime) {\\n        $result = $arrivalTime + $delayedTime;\\n        // return $result;\\n        if($result == \\'24\\'){\\n          return \\'0\\';\\n        }else if($result > \\'24\\'){\\n         return  $result - \\'24\\';\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080215,
                "title": "c-python-easiest-solution-ever-t-c-o-1-s-c-o-1",
                "content": "# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int aT, int dT) {\\n        return (aT + dT)%24;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def findDelayedArrivalTime(self, aT: int, dT: int) -> int:\\n        return (aT + dT)%24\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int aT, int dT) {\\n        return (aT + dT)%24;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def findDelayedArrivalTime(self, aT: int, dT: int) -> int:\\n        return (aT + dT)%24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077356,
                "title": "0ms-solution-one-line-of-code",
                "content": "# Intuition\\n<!-- At first glance I thought that I was going to need a way to wrap around back to 0 after the total time reaches 24 -->\\n\\n# Approach\\n<!-- I first needed to add the two times. Once I did that I needed a way to have all times over 24h be reset back to 0. I found that the modulo operation best performed this and would allow me to output everything in one line -->\\n\\n# Time and Space\\n- Runtime: 0 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Memory Used: 39.12 \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        //adding the arrival time and the delayed time together then modulo-ing that by 24. This allows any time over 24h to be reset back to 0. (Ex: 25%24 = 1 | 40%24 = 16 )\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        //adding the arrival time and the delayed time together then modulo-ing that by 24. This allows any time over 24h to be reset back to 0. (Ex: 25%24 = 1 | 40%24 = 16 )\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077123,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072086,
                "title": "swift-runtime-beating-100-upvote-if-helpful",
                "content": "# Intuition\\nTo calculate the actual time when the train had arrived.\\n\\n# Approach\\nMathematical\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    func findDelayedArrivalTime(_ arrivalTime: Int, _ delayedTime: Int) -> Int {\\n        // 24 or 48 hours mean 0 (i.e. 00:00 in time standards)\\n        if(arrivalTime + delayedTime == 24 || arrivalTime + delayedTime == 48){\\n            return 0\\n        }\\n        if(arrivalTime + delayedTime < 24){\\n            return arrivalTime + delayedTime\\n        }\\n        // when the time is greater than 24 but less than 48 hours\\n        if(arrivalTime + delayedTime > 24 && arrivalTime + delayedTime < 48) {\\n            return arrivalTime + delayedTime - 24\\n        }\\n        return arrivalTime + delayedTime\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    func findDelayedArrivalTime(_ arrivalTime: Int, _ delayedTime: Int) -> Int {\\n        // 24 or 48 hours mean 0 (i.e. 00:00 in time standards)\\n        if(arrivalTime + delayedTime == 24 || arrivalTime + delayedTime == 48){\\n            return 0\\n        }\\n        if(arrivalTime + delayedTime < 24){\\n            return arrivalTime + delayedTime\\n        }\\n        // when the time is greater than 24 but less than 48 hours\\n        if(arrivalTime + delayedTime > 24 && arrivalTime + delayedTime < 48) {\\n            return arrivalTime + delayedTime - 24\\n        }\\n        return arrivalTime + delayedTime\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056843,
                "title": "100-beats-0ms-1-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n           \\n               return  (arrivalTime+delayedTime)%24;\\n           \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n           \\n               return  (arrivalTime+delayedTime)%24;\\n           \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050730,
                "title": "java-so-lution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042710,
                "title": "simple-straight-forward-without-any-optimisation",
                "content": "# Intuition\\nIt\\'s a very simple problem, use reminder of 24 to get hours\\n\\n# Approach\\nBrute force approach\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int {\\n        var time = arrivalTime + delayedTime\\n\\n        time = time % 24\\n\\n        return time\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int {\\n        var time = arrivalTime + delayedTime\\n\\n        time = time % 24\\n\\n        return time\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036292,
                "title": "2-lines-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int res = (arrivalTime + delayedTime);\\n        return res % 24 ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int res = (arrivalTime + delayedTime);\\n        return res % 24 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027381,
                "title": "simplest-code-0ms-runtime",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) \\n    {\\n     \\n      int sum = arrivalTime + delayedTime;\\n       if(sum >= 24)\\n       {\\n           sum -= 24;  // sum = sum - 24\\n       }  \\n       return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) \\n    {\\n     \\n      int sum = arrivalTime + delayedTime;\\n       if(sum >= 24)\\n       {\\n           sum -= 24;  // sum = sum - 24\\n       }  \\n       return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023884,
                "title": "beginner-friendly-python-runtime-8ms-beats-96-5",
                "content": "# Complexity\\n- Time complexity:\\nRuntime 8ms || Beats 96.5%\\n\\n- Space complexity:\\nMemory 13.2MB || Beats 39.13%\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        return (arrivalTime + delayedTime) % 24\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        return (arrivalTime + delayedTime) % 24\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022072,
                "title": "easiest-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014498,
                "title": "solution-using-python",
                "content": "# Complexity\\n- Time complexity: 9ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 13.30MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        \"\"\"\\n        :type arrivalTime: int\\n        :type delayedTime: int\\n        :rtype: int\\n        \"\"\"\\n        res = arrivalTime + delayedTime\\n        res1 = res%24\\n        if res <= 24:\\n            if res1!=0:\\n                return res\\n            elif res1==0:\\n                return 0\\n        elif res <= 47:\\n            res1 = res1%24\\n            return res1\\n        else:\\n            return 0\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        \"\"\"\\n        :type arrivalTime: int\\n        :type delayedTime: int\\n        :rtype: int\\n        \"\"\"\\n        res = arrivalTime + delayedTime\\n        res1 = res%24\\n        if res <= 24:\\n            if res1!=0:\\n                return res\\n            elif res1==0:\\n                return 0\\n        elif res <= 47:\\n            res1 = res1%24\\n            return res1\\n        else:\\n            return 0\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008143,
                "title": "python-simple-solution-math",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n  def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n    return (arrivalTime + delayedTime) % 24\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n  def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n    return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998172,
                "title": "o-1-100-beats-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime>=24){            \\n            return (arrivalTime+delayedTime)-24;\\n        }else{\\n            return arrivalTime+delayedTime;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime>=24){            \\n            return (arrivalTime+delayedTime)-24;\\n        }else{\\n            return arrivalTime+delayedTime;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995903,
                "title": "one-line-python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991512,
                "title": "only-one-line-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nonly one line code using Modulo operator.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983551,
                "title": "c-very-simple-and-easy-to-understand-solution",
                "content": "# Intuition\\nThe intuition behind this solution is to calculate the time when the train will arrive at the station after accounting for the delay.\\n\\n# Approach\\nThe approach to solving this problem involves adding the `arrivalTime` and `delayedTime` to determine the new arrival time after the delay. If the sum of `arrivalTime` and `delayedTime` exceeds 23 (the maximum hour in 24-hour format), we need to subtract 24 to get the correct time within the 24-hour format.\\n\\n# Complexity\\n- Time complexity: **O(1)**  \\n\\n- Space complexity: **O(1)**  \\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if (arrivalTime + delayedTime > 23) {\\n            return (arrivalTime + delayedTime) - 24;\\n        }\\n        return arrivalTime + delayedTime;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if (arrivalTime + delayedTime > 23) {\\n            return (arrivalTime + delayedTime) - 24;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3977565,
                "title": "easiest-c-solution-2023",
                "content": "```\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime){\\nreturn (arrivalTime+delayedTime)%24;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime){\\nreturn (arrivalTime+delayedTime)%24;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3967568,
                "title": "simplest-java-code-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time = arrivalTime + delayedTime;\\n        if(time < 24){\\n            return time;\\n        }\\n        return time-24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time = arrivalTime + delayedTime;\\n        if(time < 24){\\n            return time;\\n        }\\n        return time-24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967379,
                "title": "simple-solution-using-java",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950413,
                "title": "beginner-friendly-100-beats-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a basic question which can easily be easily solved from if and else condition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve this problem first we need to compare the sum of the arrivaltime and delayed time with 24 as the output should be in 24 hrs format.\\nIf the sum is greater or equal to 24 we can simply return (time-24).\\nelse directly we will return the sum.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time=arrivalTime+delayedTime;\\n        if(time>=24){\\n            return (time-24);\\n        }\\n        else {\\n            return time;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time=arrivalTime+delayedTime;\\n        if(time>=24){\\n            return (time-24);\\n        }\\n        else {\\n            return time;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944981,
                "title": "c-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int  s=arrivalTime+delayedTime;\\n        if(s==24){\\n            return 0;\\n        }else if(s<24){\\n            return s;\\n        }else{\\n            return s-24;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int  s=arrivalTime+delayedTime;\\n        if(s==24){\\n            return 0;\\n        }else if(s<24){\\n            return s;\\n        }else{\\n            return s-24;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941933,
                "title": "single-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime) if arrivalTime+delayedTime<24 else arrivalTime+delayedTime-24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime) if arrivalTime+delayedTime<24 else arrivalTime+delayedTime-24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941090,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return ((arrivalTime  + delayedTime) % 24);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return ((arrivalTime  + delayedTime) % 24);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937822,
                "title": "calculate-delayed-arrival-time-in-java",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931685,
                "title": "very-easy-math-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int at = arrivalTime;\\n        int dt = delayedTime;\\n        int t = dt + at;\\n        if(t >= 24){\\n            return t - 24;\\n        }\\n        return t % 24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int at = arrivalTime;\\n        int dt = delayedTime;\\n        int t = dt + at;\\n        if(t >= 24){\\n            return t - 24;\\n        }\\n        return t % 24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925999,
                "title": "one-line-code-beats-100-memory-and-100-time",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924631,
                "title": "simple-elixir-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec find_delayed_arrival_time(arrival_time :: integer, delayed_time :: integer) :: integer\\n  def find_delayed_arrival_time(arrival_time, delayed_time) do\\n      new_time = arrival_time + delayed_time\\n      new_time = if new_time >= 24 do\\n                   new_time - 24\\n                 else\\n                   new_time\\n                 end\\n                  \\n      \\n      new_time\\n\\n  end\\nend\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndefmodule Solution do\\n  @spec find_delayed_arrival_time(arrival_time :: integer, delayed_time :: integer) :: integer\\n  def find_delayed_arrival_time(arrival_time, delayed_time) do\\n      new_time = arrival_time + delayed_time\\n      new_time = if new_time >= 24 do\\n                   new_time - 24\\n                 else\\n                   new_time\\n                 end\\n                  \\n      \\n      new_time\\n\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3922014,
                "title": "kotlin-oneline-solution",
                "content": "```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int = (arrivalTime + delayedTime) % 24\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int = (arrivalTime + delayedTime) % 24\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921241,
                "title": "solved-in-c-00ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sumOfHours=delayedTime+arrivalTime;\\n        if (sumOfHours >= 24){\\n            return sumOfHours -24;\\n        }\\n        return sumOfHours;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sumOfHours=delayedTime+arrivalTime;\\n        if (sumOfHours >= 24){\\n            return sumOfHours -24;\\n        }\\n        return sumOfHours;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911397,
                "title": "beats-100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int x=arrivalTime+delayedTime;\\n        if(x>=24)\\n        x=x%24;\\n        return x;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int x=arrivalTime+delayedTime;\\n        if(x>=24)\\n        x=x%24;\\n        return x;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910105,
                "title": "2651-calculate-delayed-arrival-time-solution-for-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        resTime = arrivalTime\\n        more = delayedTime\\n        \\n        while more != 0:\\n            more -= 1\\n            resTime += 1\\n            if resTime == 24:\\n                resTime = 0\\n        return resTime\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        resTime = arrivalTime\\n        more = delayedTime\\n        \\n        while more != 0:\\n            more -= 1\\n            resTime += 1\\n            if resTime == 24:\\n                resTime = 0\\n        return resTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908727,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n     int delayedArrival=arrivalTime+delayedTime;\\n     return delayedArrival%24;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n     int delayedArrival=arrivalTime+delayedTime;\\n     return delayedArrival%24;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908324,
                "title": "give-the-delayed-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899659,
                "title": "beats-100-veryy-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) \\n    {\\n        int sum = a + b;\\n        \\n        if (sum >= 24) {\\n            sum -= 24;  // Adjust the time if it\\'s past 24 hours\\n        }\\n        \\n        return sum; // Convert and return the integer part of sum\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) \\n    {\\n        int sum = a + b;\\n        \\n        if (sum >= 24) {\\n            sum -= 24;  // Adjust the time if it\\'s past 24 hours\\n        }\\n        \\n        return sum; // Convert and return the integer part of sum\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896868,
                "title": "go-simple-solution",
                "content": "```go\\n// Improve documentation\\nconst (\\n    maxHourPerDay = 24\\n)\\n\\nfunc findDelayedArrivalTime(arrivalTime, delayedTime int) int {\\n    return (arrivalTime + delayedTime) % maxHourPerDay\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// Improve documentation\\nconst (\\n    maxHourPerDay = 24\\n)\\n\\nfunc findDelayedArrivalTime(arrivalTime, delayedTime int) int {\\n    return (arrivalTime + delayedTime) % maxHourPerDay\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895451,
                "title": "beats-100-00-of-users-with-c-hope-you-upvote-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime + delayedTime >=24)\\n        return arrivalTime +delayedTime-24;\\n        return arrivalTime +delayedTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime + delayedTime >=24)\\n        return arrivalTime +delayedTime-24;\\n        return arrivalTime +delayedTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892346,
                "title": "100-simple-python-solution-with-best-efficiency-90",
                "content": "# Intuition\\n>First Just plus two Numbers\\n> Check on 24\\n> If more then take Remainder\\n\\n\\n# Approach\\n> Brut Force\\n\\n# Complexity\\n- Time complexity:\\n> O(1)\\n\\n- Space complexity:\\n> O(1)\\n\\n\\n> ----\\n\\n\\n![Capture.JPG](https://assets.leetcode.com/users/images/c297efbb-4c3f-4a24-b8fb-f7ecd6edcd0b_1691698542.1492267.jpeg)\\n\\n> -----\\n\\n\\n> ### kindly Like my Solution. Please It will Support me. Thanks.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        \"\"\"\\n        :type arrivalTime: int\\n        :type delayedTime: int\\n        :rtype: int\\n        \"\"\"\\n        arrivalTime = arrivalTime + delayedTime   # O(1)\\n        if arrivalTime >= 24:                     # O(1)\\n          arrivalTime = arrivalTime % 24          \\n\\n        return arrivalTime\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        \"\"\"\\n        :type arrivalTime: int\\n        :type delayedTime: int\\n        :rtype: int\\n        \"\"\"\\n        arrivalTime = arrivalTime + delayedTime   # O(1)\\n        if arrivalTime >= 24:                     # O(1)\\n          arrivalTime = arrivalTime % 24          \\n\\n        return arrivalTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891580,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n       int ans = 0;\\n\\n        if (arrivalTime + delayedTime >= 24) {\\n            ans = (arrivalTime + delayedTime) - 24;\\n        } else {\\n            ans = arrivalTime + delayedTime;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n       int ans = 0;\\n\\n        if (arrivalTime + delayedTime >= 24) {\\n            ans = (arrivalTime + delayedTime) - 24;\\n        } else {\\n            ans = arrivalTime + delayedTime;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891490,
                "title": "easy-cpp-solution-single-line-solution-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        // By using % 24, we ensure that \\n        // The arrivalTime + delayedTime does not exceeds 24\\n        // and remains in the 24 hours format as mentioned in problem statement\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        // By using % 24, we ensure that \\n        // The arrivalTime + delayedTime does not exceeds 24\\n        // and remains in the 24 hours format as mentioned in problem statement\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890474,
                "title": "delayed-arrival-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime)%24\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime)%24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889307,
                "title": "simple-and-easy-java-solution-single-line-answer-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884765,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n       int sum=0;\\n       sum=arrivalTime+delayedTime;\\n\\n       if(sum<24){\\n           sum=sum;\\n       } \\n\\n       else if(sum>24){\\n           sum=sum-24;\\n       }\\n       else{\\n           sum=0;\\n       }\\n       return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n       int sum=0;\\n       sum=arrivalTime+delayedTime;\\n\\n       if(sum<24){\\n           sum=sum;\\n       } \\n\\n       else if(sum>24){\\n           sum=sum-24;\\n       }\\n       else{\\n           sum=0;\\n       }\\n       return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882462,
                "title": "python3-the-best-uzbekistan",
                "content": "# Intuition\\n![Screenshot from 2023-08-08 20-44-45.png](https://assets.leetcode.com/users/images/87a76601-8951-4284-ac96-648a53aef00f_1691509531.998496.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880681,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans = arrivalTime + delayedTime;\\n\\n        if(ans>=24) return ans-24;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans = arrivalTime + delayedTime;\\n\\n        if(ans>=24) return ans-24;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872027,
                "title": "beats-99-07-99-40-solution-from-a-noob",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n***30ms\\nBeats 99.07%of users with Python3***\\n\\n- Space complexity:\\n***16.06mb\\nBeats 99.40%of users with Python3***\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, a: int, d: int) -> int:\\n        s=a+d\\n        #sum of arrival and delay\\n        while s>24:\\n            s=s-24\\n        #Note that the time in this problem is in 24-hours format.(desc.)\\n        if s==24:\\n            s=0\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, a: int, d: int) -> int:\\n        s=a+d\\n        #sum of arrival and delay\\n        while s>24:\\n            s=s-24\\n        #Note that the time in this problem is in 24-hours format.(desc.)\\n        if s==24:\\n            s=0\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871508,
                "title": "short-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n          return (arrivalTime+delayedTime)%24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n          return (arrivalTime+delayedTime)%24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861519,
                "title": "beats-88-easy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        if (arrivalTime+delayedTime)>=24: return (arrivalTime+delayedTime)-24\\n        else: return arrivalTime + delayedTime\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        if (arrivalTime+delayedTime)>=24: return (arrivalTime+delayedTime)-24\\n        else: return arrivalTime + delayedTime\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860743,
                "title": "2651-calculate-delayed-arrival-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        output=arrivalTime+delayedTime\\n        if output>=24:\\n            output-=24\\n        return output        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        output=arrivalTime+delayedTime\\n        if output>=24:\\n            output-=24\\n        return output        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858678,
                "title": "using-mod",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int r=arrivalTime+delayedTime;\\n        return (r%24);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int r=arrivalTime+delayedTime;\\n        return (r%24);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857196,
                "title": "beats-100-cpp-users-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n       int ans=arrivalTime+delayedTime;\\n       if(ans>=24){\\n           ans=ans-24;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n       int ans=arrivalTime+delayedTime;\\n       if(ans>=24){\\n           ans=ans-24;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853554,
                "title": "c-easy-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:***O(1)***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ***O(1)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime + delayedTime >= 24)\\n        {\\n            return arrivalTime + delayedTime - 24;\\n        }\\n        return arrivalTime + delayedTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime + delayedTime >= 24)\\n        {\\n            return arrivalTime + delayedTime - 24;\\n        }\\n        return arrivalTime + delayedTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844377,
                "title": "easy-and-quick-solution-using-javascript-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function (arrivalTime, delayedTime) {\\n    let totalTime = arrivalTime + delayedTime; // initialize totalTime is the sum of arrivalTime and delayedTime\\n\\n    if (totalTime == 24) { // if totalTime is equal to 24 then return 0\\n        return 0;\\n    } else if (totalTime < 24) { // if totalTime is less than 24 then return totalTime\\n        return totalTime;\\n    } else { // else return subtraction of totalTime to 24\\n        return totalTime - 24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function (arrivalTime, delayedTime) {\\n    let totalTime = arrivalTime + delayedTime; // initialize totalTime is the sum of arrivalTime and delayedTime\\n\\n    if (totalTime == 24) { // if totalTime is equal to 24 then return 0\\n        return 0;\\n    } else if (totalTime < 24) { // if totalTime is less than 24 then return totalTime\\n        return totalTime;\\n    } else { // else return subtraction of totalTime to 24\\n        return totalTime - 24;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3841522,
                "title": "java-one-line-100-faster",
                "content": "\\tclass Solution {\\n\\t\\tpublic int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\t\\t\\treturn (arrivalTime + delayedTime)%24;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\t\\t\\treturn (arrivalTime + delayedTime)%24;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3840534,
                "title": "python-easy-clean-one-line-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```\\n![catty.png](https://assets.leetcode.com/users/images/99367335-87d2-40e4-a585-9428dd5db020_1690761949.3162441.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839250,
                "title": "sreeja-s-approach-python3-easy-solution-beats-84",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        time = arrivalTime + delayedTime\\n        if time == 24:\\n            return 0\\n        elif time > 24:\\n            return time - 24\\n        else:\\n            return time\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        time = arrivalTime + delayedTime\\n        if time == 24:\\n            return 0\\n        elif time > 24:\\n            return time - 24\\n        else:\\n            return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837250,
                "title": "java-beats-100-00-of-users-with-java-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sum =arrivalTime+delayedTime;\\n        int tot=0;\\n        if(sum==24){\\n            tot =0;\\n        }\\n        else if(sum>24){\\n            tot =(arrivalTime+delayedTime)-24;\\n        }\\n        else if(sum<24){\\n            tot =sum;\\n        }\\n        return tot;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sum =arrivalTime+delayedTime;\\n        int tot=0;\\n        if(sum==24){\\n            tot =0;\\n        }\\n        else if(sum>24){\\n            tot =(arrivalTime+delayedTime)-24;\\n        }\\n        else if(sum<24){\\n            tot =sum;\\n        }\\n        return tot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834162,
                "title": "easiest-100-beats-one-line-ans",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime +delayedTime)%24;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime +delayedTime)%24;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833877,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans;\\n        int totalHours = arrivalTime + delayedTime;\\n        \\n        if (totalHours >= 24) {\\n            ans = totalHours % 24;\\n        } else {\\n            ans = totalHours;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans;\\n        int totalHours = arrivalTime + delayedTime;\\n        \\n        if (totalHours >= 24) {\\n            ans = totalHours % 24;\\n        } else {\\n            ans = totalHours;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832953,
                "title": "delayed-arrival-time-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n0s\\n\\n- Space complexity:\\n6MB\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int result = arrivalTime+delayedTime;\\n        if(result < 24){\\n            return result;\\n        }else{\\n            result -= 24;\\n            return result;\\n        }    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int result = arrivalTime+delayedTime;\\n        if(result < 24){\\n            return result;\\n        }else{\\n            result -= 24;\\n            return result;\\n        }    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831459,
                "title": "c-easy-solution-3-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayed) {\\n        if(arrivalTime+delayed==24)\\n        {\\n            return 0;\\n        }\\n        if(arrivalTime+delayed>24)\\n        {\\n            return (arrivalTime+delayed)-24;\\n        }\\n        return arrivalTime+delayed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayed) {\\n        if(arrivalTime+delayed==24)\\n        {\\n            return 0;\\n        }\\n        if(arrivalTime+delayed>24)\\n        {\\n            return (arrivalTime+delayed)-24;\\n        }\\n        return arrivalTime+delayed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821581,
                "title": "2651-calculate-delayed-arrival-time",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        if(a+d>=24){\\n            return (a+d-24);\\n        }\\n        else{\\n            return a+d;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        if(a+d>=24){\\n            return (a+d-24);\\n        }\\n        else{\\n            return a+d;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819360,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        finaltime = arrivalTime + delayedTime\\n        return finaltime % 24\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        finaltime = arrivalTime + delayedTime\\n        return finaltime % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819010,
                "title": "c-beats-100-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity:\\nThe time complexity of the code is O(1)\\n- Space complexity:\\nThe space complexity of the code is also O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n        int ans = arrivalTime+delayedTime;\\n        if(ans>=24)\\n        {\\n            ans = ans-24;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n        int ans = arrivalTime+delayedTime;\\n        if(ans>=24)\\n        {\\n            ans = ans-24;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818754,
                "title": "java-beats-97-memory-beats-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int total=arrivalTime+delayedTime;\\n      return total%24; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int total=arrivalTime+delayedTime;\\n      return total%24; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813016,
                "title": "easy-solution-in-c-beats-100",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime) % 24;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime) % 24;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812297,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810422,
                "title": "c-one-line-code-simple-and-easy-approach",
                "content": "# Intuition\\nWe are given a positive integer arrivalTime denoting the arrival time of a train in hours, and another positive integer delayedTime denoting the amount of delay in hours. We have to return the time when the train will arrive at the station where the time in this problem is in 24-hours format.\\n\\n# Approach\\nThe time when train will arrive at the station is (arrivalTime+delayedTime)%24, that is because the total time train will take to arrive is arrivalTime+delayedTime and in 24-hour clock the clock resets at 24th hour to 00:00 as it is cyclic in nature, so we return (arrivalTime+delayedTime)%24.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806562,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int result = arrivalTime + delayedTime;\\n        if(result >= 24) return result - 24;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int result = arrivalTime + delayedTime;\\n        if(result >= 24) return result - 24;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801864,
                "title": "with-explanation-comments-time-xx-ms-98-97-space-xx-mb-89-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime < 24) ? arrivalTime+delayedTime : arrivalTime+delayedTime-24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime < 24) ? arrivalTime+delayedTime : arrivalTime+delayedTime-24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801042,
                "title": "simple-kotlin-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int {\\n        return if (arrivalTime + delayedTime >= 24) {\\n            arrivalTime + delayedTime - 24\\n        } else {\\n            arrivalTime + delayedTime\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int {\\n        return if (arrivalTime + delayedTime >= 24) {\\n            arrivalTime + delayedTime - 24\\n        } else {\\n            arrivalTime + delayedTime\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799743,
                "title": "python-rust-solution-0-ms",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```\\n```rust []\\nimpl Solution {\\n    pub fn find_delayed_arrival_time(arrival_time: i32, delayed_time: i32) -> i32 {\\n        (arrival_time + delayed_time) % 24\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```\n```rust []\\nimpl Solution {\\n    pub fn find_delayed_arrival_time(arrival_time: i32, delayed_time: i32) -> i32 {\\n        (arrival_time + delayed_time) % 24\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797546,
                "title": "very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24) {\\n            return (arrivalTime+delayedTime);\\n        }else {\\n            return (arrivalTime+delayedTime-24);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24) {\\n            return (arrivalTime+delayedTime);\\n        }else {\\n            return (arrivalTime+delayedTime-24);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796231,
                "title": "simple-solution-in-java",
                "content": "In this code we takes two integer parameters and they returns an integer value. after that we add both arrivalTime and delayedTime and store the result in the variable \\'ans\\'. and then we take condition if our ans is greater than 24(time exceeded one day). it means arrival will happen on next day, in this case, code subtracts 24 from \\'ans\\' to adjust time within 24 hour format. After that code returns calculated \\'ans\\', which represents delayed arrival time.\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans = arrivalTime+delayedTime;\\n        int num = 0;\\n        if(ans>=24){\\n            ans = ans-24;\\n            return ans;\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans = arrivalTime+delayedTime;\\n        int num = 0;\\n        if(ans>=24){\\n            ans = ans-24;\\n            return ans;\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795093,
                "title": "c-one-line-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793976,
                "title": "java",
                "content": "# Code\\n```\\nclass Solution \\n{\\n    public int findDelayedArrivalTime(int a, int d) \\n    {\\n        int t = a + d;\\n        if(t >= 24)\\n        t = t % 24;\\n        return t;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int findDelayedArrivalTime(int a, int d) \\n    {\\n        int t = a + d;\\n        if(t >= 24)\\n        t = t % 24;\\n        return t;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791711,
                "title": "java-easy-solution-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        if(a+d<24)\\n        return a+d;\\n        else\\n        return Math.abs(24-(a+d));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        if(a+d<24)\\n        return a+d;\\n        else\\n        return Math.abs(24-(a+d));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788379,
                "title": "one-line-solution-and-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 26 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 26.72mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782361,
                "title": "simple-formula",
                "content": "![image.png](https://assets.leetcode.com/users/images/65869e86-149f-4098-8467-fdc086e9f5b8_1689674214.6587172.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780598,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        sum = arrivalTime + delayedTime\\n        if sum != 24 and sum< 24:\\n            return sum\\n        else:\\n            return sum -24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        sum = arrivalTime + delayedTime\\n        if sum != 24 and sum< 24:\\n            return sum\\n        else:\\n            return sum -24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778733,
                "title": "java-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int r = arrivalTime + delayedTime;\\n        if(r >= 24){\\n            r = r-24;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int r = arrivalTime + delayedTime;\\n        if(r >= 24){\\n            r = r-24;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774831,
                "title": "time-o-1-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n\\n        a = arrivalTime + delayedTime\\n        if a==24:\\n            return 0\\n        elif a>24:\\n            return a-24\\n        else:\\n            return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n\\n        a = arrivalTime + delayedTime\\n        if a==24:\\n            return 0\\n        elif a>24:\\n            return a-24\\n        else:\\n            return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774556,
                "title": "easy-3-line-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        \\n        return arrivalTime+delayedTime-24;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        \\n        return arrivalTime+delayedTime-24;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767009,
                "title": "100-faster-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763845,
                "title": "one-liner-solution-containing-only-return-statement-beating-100-in-both-runtime-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        return ((a+d)%24); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        return ((a+d)%24); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761529,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(logn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3758127,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int ar, int de) {\\n        if(ar+de>=24 || de+ar>=24){\\n            return Math.abs(ar+de-24); \\n        }\\n        return (ar+de)==24?0:ar+de;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int ar, int de) {\\n        if(ar+de>=24 || de+ar>=24){\\n            return Math.abs(ar+de-24); \\n        }\\n        return (ar+de)==24?0:ar+de;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752938,
                "title": "c-100-faster-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\t\\treturn (arrivalTime + delayedTime) % 24;       \\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\t\\treturn (arrivalTime + delayedTime) % 24;       \\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750432,
                "title": "java-delayed-arrival-time-explained",
                "content": "# Approach\\nJust some Cases to take care of like the sum being 24 or above.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int aT, int dT) {\\n        int sum=aT+dT;\\n        if(sum==24){return 0;}\\n        if(sum>24){return sum-24;}\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int aT, int dT) {\\n        int sum=aT+dT;\\n        if(sum==24){return 0;}\\n        if(sum>24){return sum-24;}\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747098,
                "title": "simple-solution-c",
                "content": "# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741750,
                "title": "very-very-easy-solution-simple-to-understand-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        int c = a+d;\\n        if(c>24)\\n            return c-24;\\n        else if(c==24)\\n            return 0;\\n        else\\n            return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        int c = a+d;\\n        if(c>24)\\n            return c-24;\\n        else if(c==24)\\n            return 0;\\n        else\\n            return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741746,
                "title": "very-very-easy-solution-simple-to-understand-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        int c = a+d;\\n        if(c>24)\\n            return c-24;\\n        else if(c==24)\\n            return 0;\\n        else\\n            return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        int c = a+d;\\n        if(c>24)\\n            return c-24;\\n        else if(c==24)\\n            return 0;\\n        else\\n            return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737386,
                "title": "just-one-line-javascript",
                "content": "# Have fun with my code\\n```\\nconst findDelayedArrivalTime = (arrivalTime, delayedTime) => (arrivalTime + delayedTime) % 24\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findDelayedArrivalTime = (arrivalTime, delayedTime) => (arrivalTime + delayedTime) % 24\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736602,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int c= arrivalTime+delayedTime;\\n        int d=c-24;\\n        if(c<24){\\n            return c;\\n        }\\n        else \\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int c= arrivalTime+delayedTime;\\n        int d=c-24;\\n        if(c<24){\\n            return c;\\n        }\\n        else \\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735271,
                "title": "finddelayedarrivaltime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n\\n     let time = arrivalTime + delayedTime;\\n     let output = time >= 24 ? time - 24 : time; \\n\\n     return output;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n\\n     let time = arrivalTime + delayedTime;\\n     let output = time >= 24 ? time - 24 : time; \\n\\n     return output;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731824,
                "title": "one-line-code-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n             return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n             return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1871512,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 2047912,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1874264,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1872350,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1943111,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 2069849,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1991763,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1964413,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1959184,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1936237,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1871512,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 2047912,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1874264,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1872350,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1943111,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 2069849,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1991763,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1964413,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1959184,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1936237,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            }
        ]
    },
    {
        "title": "Allow One Function Call",
        "question_content": "<p>Given a function <code>fn</code>, return a new function that is identical to the original function except that it ensures&nbsp;<code>fn</code>&nbsp;is&nbsp;called at most once.</p>\n\n<ul>\n\t<li>The first time the returned function is called, it should return the same result as&nbsp;<code>fn</code>.</li>\n\t<li>Every subsequent time it is called, it should return&nbsp;<code>undefined</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (a,b,c) =&gt; (a + b + c), calls = [[1,2,3],[2,3,6]]\n<strong>Output:</strong> [{&quot;calls&quot;:1,&quot;value&quot;:6}]\n<strong>Explanation:</strong>\nconst onceFn = once(fn);\nonceFn(1, 2, 3); // 6\nonceFn(2, 3, 6); // undefined, fn was not called\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (a,b,c) =&gt; (a * b * c), calls = [[5,7,4],[2,3,6],[4,6,8]]\n<strong>Output:</strong> [{&quot;calls&quot;:1,&quot;value&quot;:140}]\n<strong>Explanation:</strong>\nconst onceFn = once(fn);\nonceFn(5, 7, 4); // 140\nonceFn(2, 3, 6); // undefined, fn was not called\nonceFn(4, 6, 8); // undefined, fn was not called\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>calls</code> is a valid JSON array</li>\n\t<li><code>1 &lt;= calls.length &lt;= 10</code></li>\n\t<li><code>1 &lt;= calls[i].length &lt;= 100</code></li>\n\t<li><code>2 &lt;= JSON.stringify(calls).length &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3514065,
                "title": "o-1-sc-o-1-tc-4-diff-method-solution-in-js-and-typescript-day-8",
                "content": "# Intuition\\nThe problem is asking us to return a `new function` that behaves differently depending on whether it has been called before. If it has not been called before, it should call the original function and return its result. If it has been called before, it should return `undefined` without calling the original function again.\\n\\n# Approach\\nTo solve this problem, we can return a `new function `that keeps track of whether it has been called before. We can do this by using a `closure `to store a `boolean flag` that is initially set to false. The first time the new function is called, we call the original function and set the flag to `true`. We also store the result of the original function. Subsequent calls to the new function simply return `undefined `without calling the original function again.\\n\\n# Complexity\\n- Time complexity:\\nO(1) for both the first and subsequent calls to the returned function. This is because checking the hasBeenCalled flag and returning either the result or undefined are constant-time operations.\\n\\n- Space complexity:\\nO(1) as well. This is because we only use a constant amount of extra space to store the hasBeenCalled flag and the result of the original function. \\n\\n# Learning \\nThe key idea behind this problem is to use a closure to store the state of the returned function. By doing this, we can keep track of whether the function has been called before and behave accordingly.\\n\\n# Code In JS\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n```\\n\\n# Code In TypeScript\\n```\\ntype Func<T, U> = (...args: T[]) => U;\\n\\nfunction once<T, U>(fn: Func<T, U>): Func<T, U | undefined> {\\n  let hasBeenCalled = false;\\n  let result: U;\\n\\n  return function (...args: T[]): U | undefined {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\n// Example usage:\\nlet fn = (a: number, b: number, c: number) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1, 2, 3)); // 6\\nconsole.log(onceFn(2, 3, 6)); // undefined\\n\\n```\\n\\n# Using a closure and an arrow function\\n\\nIn this approach, we use an `arrow function` to create the returned function. We store the` hasBeenCalled flag` and result in a closure, and use an if statement to check whether the function has already been called.\\n\\n```\\nfunction once(fn) {\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return (...args) => {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\\n\\n# Using a class\\n\\nIn this approach, we define a `Once class` that has a call method that behaves like the returned function in the previous approaches. We use a class property to store the hasBeenCalled flag and result.\\n\\n```\\nclass Once {\\n  hasBeenCalled = false;\\n  result;\\n\\n  call(fn, ...args) {\\n    if (!this.hasBeenCalled) {\\n      this.result = fn(...args);\\n      this.hasBeenCalled = true;\\n      return this.result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\nfunction once(fn) {\\n  const instance = new Once();\\n  return instance.call.bind(instance, fn);\\n}\\n\\n```\\n# Using a traditional function and an object\\n\\nwe use a` traditional function` to create the returned function. Instead of using a `closure`, we store the `hasBeenCalled flag` and result in an object that is passed as an argument to the returned function.\\n\\n```\\nfunction once(fn) {\\n  return function(...args) {\\n    const state = {\\n      hasBeenCalled: false,\\n      result: undefined\\n    };\\n\\n    if (!state.hasBeenCalled) {\\n      state.result = fn(...args);\\n      state.hasBeenCalled = true;\\n      return state.result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\\n![upvote-2.png](https://assets.leetcode.com/users/images/e79ad083-6070-43a5-903c-7a0bdf69dcf4_1683853739.9399579.png)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n```\n```\\ntype Func<T, U> = (...args: T[]) => U;\\n\\nfunction once<T, U>(fn: Func<T, U>): Func<T, U | undefined> {\\n  let hasBeenCalled = false;\\n  let result: U;\\n\\n  return function (...args: T[]): U | undefined {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\n// Example usage:\\nlet fn = (a: number, b: number, c: number) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1, 2, 3)); // 6\\nconsole.log(onceFn(2, 3, 6)); // undefined\\n\\n```\n```\\nfunction once(fn) {\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return (...args) => {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\n```\\nclass Once {\\n  hasBeenCalled = false;\\n  result;\\n\\n  call(fn, ...args) {\\n    if (!this.hasBeenCalled) {\\n      this.result = fn(...args);\\n      this.hasBeenCalled = true;\\n      return this.result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\nfunction once(fn) {\\n  const instance = new Once();\\n  return instance.call.bind(instance, fn);\\n}\\n\\n```\n```\\nfunction once(fn) {\\n  return function(...args) {\\n    const state = {\\n      hasBeenCalled: false,\\n      result: undefined\\n    };\\n\\n    if (!state.hasBeenCalled) {\\n      state.result = fn(...args);\\n      state.hasBeenCalled = true;\\n      return state.result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514233,
                "title": "dry-run-beginner-friendly-explanation-js-ts-o-1-sc-o-1-tc-day8",
                "content": "## Intuition: \\nWe can keep a boolean which can track if a function is called or not\\n***\\n## Explanation: \\n* The returned function uses a **[Closure](https://leetcode.com/problems/counter/discuss/3491300/Day2O(1)greaterUnderstanding-Closure-in-easy-way-and-its-practical-uses!!)** to keep track of whether `fn` has already been called. The `usedOnce` variable is initially set to `false`, indicating that `fn` has not yet been called.\\n* When the returned function is **called for the first time**, it sets `usedOnce` to `true`, calls `fn` with the input arguments `args`, stores the result in the `result` variable, and returns the `result`.\\n* When the returned function is **called subsequent times**, it simply returns `undefined`, since fn has already been called and its result has been stored in result.\\n* The use of the rest parameter `...args` allows the returned function to **accept any number of arguments**, which are then passed to `fn`.\\n\\t* To be more clear, `...args` represents the **input arguments** that are passed to the returned function. The use of the **spread syntax** allows the function to accept any number of input arguments, which are then passed as an **array** to the `fn` function using the spread syntax `...args`.\\n\\t* **For example,** if you call the returned function with `myFunc(1, 2, 4)`, the `...args` syntax will **convert the input arguments** into an `array [1, 2, 4]` that can be passed to the `fn` function using the spread syntax `...args`.\\n\\n*Dry Run is given after the solution part :)*\\n***\\n**JavaScript Solution:** \\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let usedOnce = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!usedOnce) {\\n      result = fn(...args);\\n      usedOnce = true;\\n      return result;\\n    }\\n    return undefined;\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n***\\n**TypeScript Solution:**\\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n     let usedOnce = false;\\n  return function (...args) {\\n      if(!usedOnce){\\n          usedOnce = true;\\n          return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n***\\n**Dry Run :**\\n```\\nvar myFunc = function(a, b, c) {\\n  return a + b + c;\\n};\\nvar onceFunc = once(myFunc);\\nconsole.log(onceFunc(1, 2, 3));    // O/P:6\\nconsole.log(onceFunc(4, 5, 6));    // O/P:undefined\\n```\\n* We call `onceFunc` for the first time with arguments `1, 2, 3.` Since this is the first call to `onceFunc`, the `usedOnce` variable is `false`, so the `result` variable is set to the `result` of calling `myFunc` with the arguments `1, 2, 3`, and `usedOnce` is set to `true`. The value of `result (= 6)` is then returned by `onceFunc`.\\n* We then call `onceFunc` for the second time with `arguments 4, 5, 6`. Since `usedOnce` is now `true`, `onceFunc` does not call `myFunc`, but instead returns `undefined`.\\n***\\n**Time Complexity: O(1)\\nSpace Complexity: O(1)**\\n***",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let usedOnce = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!usedOnce) {\\n      result = fn(...args);\\n      usedOnce = true;\\n      return result;\\n    }\\n    return undefined;\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n     let usedOnce = false;\\n  return function (...args) {\\n      if(!usedOnce){\\n          usedOnce = true;\\n          return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n```\\nvar myFunc = function(a, b, c) {\\n  return a + b + c;\\n};\\nvar onceFunc = once(myFunc);\\nconsole.log(onceFunc(1, 2, 3));    // O/P:6\\nconsole.log(onceFunc(4, 5, 6));    // O/P:undefined\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514984,
                "title": "2666-allow-one-function-call-level-up-your-javascript-skills-day-8",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>The goal of the `once` function is to create a new function that ensures the original function is called at most once. The implementation achieves this by defining a variable that keeps track of whether the function has been called already, and returning a new function that checks whether the function has been called already before calling the original function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>The approach taken by the `once` function is to return a new function that wraps the original function and ensures that it is called at most once. The implementation achieves this by defining a variable `called` that keeps track of whether the function has been called already. The returned function checks whether `called` is true or false. If `called` is false, it calls the original function with the given arguments and stores the result in a variable `result`. It then sets `called` to true and returns `result`. If `called` is true, it simply returns `undefined` without calling the original function again.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>The time complexity of the `once` function is O(1) for the returned function since it checks the value of a single boolean variable before calling the original function. The time complexity of the original function passed to `once` is not considered since it depends on the implementation of the function itself\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>The space complexity of the `once` function is O(1) since it only defines a few variables that are used to keep track of whether the function has been called and store the result of the first call. The space complexity of the original function passed to `once` is not considered since it depends on the implementation of the function itself.\\n\\n\\n# Code\\n``` JS []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result;\\n    let called = false;\\n    return function(...args) {\\n        if (!called) {\\n            result = fn(...args);\\n            called = true;\\n            return result;\\n        }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n``` TS []\\nfunction once<T extends (...args: any[]) => any>(fn: T): ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n  let called = false;\\n  let result: ReturnType<T>;\\n\\n  return function (...args: Parameters<T>) {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n> Here are a few more ways to implement the `once` function in JavaScript:\\n\\n\\n1.Using a `closure` and an `arrow function`:\\n```\\nconst once = (fn) => {\\n  let called = false;\\n  let result;\\n  \\n  return (...args) => {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    }\\n  };\\n};\\n\\n```\\n>In this implementation, we use an arrow function to define the returned function. The rest of the implementation is similar to the closure-based implementation described earlier.\\n\\n2. Using an `object` with a `method`:\\n```\\nfunction once(fn) {\\n  return {\\n    called: false,\\n    result: undefined,\\n    execute(...args) {\\n      if (!this.called) {\\n        this.result = fn(...args);\\n        this.called = true;\\n      }\\n      return this.result;\\n    }\\n  };\\n}\\n```\\n>In this implementation, we define an object with two properties: `called` and `result`. We also define a method `execute` that checks whether `called` is true or false. If `called` is false, it calls the original function with the given arguments and stores the result in `result`. It then sets `called` to true and returns `result`. If called` is true, it simply returns `result` without calling the original function again.\\n\\n3. Using a `class`:\\n```\\nclass Once {\\n  constructor(fn) {\\n    this.called = false;\\n    this.result = undefined;\\n    this.fn = fn;\\n  }\\n  \\n  execute(...args) {\\n    if (!this.called) {\\n      this.result = this.fn(...args);\\n      this.called = true;\\n    }\\n    return this.result;\\n  }\\n}\\n\\nconst onceFn = new Once(fn).execute;\\nonceFn(1, 2, 3); // returns 6\\nonceFn(2, 3, 6); // returns undefined\\n\\n```\\n\\n# Important topic to Learn\\n\\n##### One important topic related to this problem is the concept of \"memoization\". \\n>Memoization is a technique used in computer science to speed up computations by storing the results of expensive function calls and returning the cached result when the same inputs occur again.\\n\\n>The once function we have implemented is a simple example of memoization, as it ensures that the original function is only called once, and then returns the cached result on subsequent calls.\\n\\n>Memoization can be used to optimize performance in a wide range of scenarios, such as:\\n\\n1. >Recursive functions that repeatedly compute the same value for different inputs.\\n2. >Functions that make expensive network requests or database queries.\\n3. >Functions that perform complex computations that are computationally expensive. By memoizing these functions, we can avoid recomputing the same values multiple times, which can lead to significant performance improvements.\\n\\n>It\\'s worth noting that memoization should be used judiciously, as caching results can also use up memory and slow down the program if not managed properly. Additionally, memoization can only be used when the function being memoized is pure (i.e. it always returns the same output for a given input), otherwise the cached result may not be correct.\\n\\n| Sr No. | Topic |\\n|-----|-----|\\n1.|Array methods|\\n2.|Functional programming|\\n3.|Higher-order functions|\\n4.|Memoization|\\n\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` JS []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result;\\n    let called = false;\\n    return function(...args) {\\n        if (!called) {\\n            result = fn(...args);\\n            called = true;\\n            return result;\\n        }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n``` TS []\\nfunction once<T extends (...args: any[]) => any>(fn: T): ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n  let called = false;\\n  let result: ReturnType<T>;\\n\\n  return function (...args: Parameters<T>) {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```\\nconst once = (fn) => {\\n  let called = false;\\n  let result;\\n  \\n  return (...args) => {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    }\\n  };\\n};\\n\\n```\n```\\nfunction once(fn) {\\n  return {\\n    called: false,\\n    result: undefined,\\n    execute(...args) {\\n      if (!this.called) {\\n        this.result = fn(...args);\\n        this.called = true;\\n      }\\n      return this.result;\\n    }\\n  };\\n}\\n```\n```\\nclass Once {\\n  constructor(fn) {\\n    this.called = false;\\n    this.result = undefined;\\n    this.fn = fn;\\n  }\\n  \\n  execute(...args) {\\n    if (!this.called) {\\n      this.result = this.fn(...args);\\n      this.called = true;\\n    }\\n    return this.result;\\n  }\\n}\\n\\nconst onceFn = new Once(fn).execute;\\nonceFn(1, 2, 3); // returns 6\\nonceFn(2, 3, 6); // returns undefined\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484232,
                "title": "save-an-internal-boolean",
                "content": "# Intuition\\nSave an internal boolean.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n \\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (!called) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n \\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (!called) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3512772,
                "title": "simple-and-easy-solution-using-javascript-with-intuition-and-approach-o-1-tc-and-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We will use a variable which handle the count of times function has been called .\\n- On the basis of count ,we will return result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  1. Declare a variable `times` and intialize it with zero.`times`  will holds number of times given function has been called.  \\n  2. If `times` is one,fn() will be ans.\\n  3. Else undefined will return. \\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let times=0;\\n    return function(...args){\\n           times+=1;     \\n           if(times==1)\\n               return fn(...args);\\n           return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let times=0;\\n    return function(...args){\\n           times+=1;     \\n           if(times==1)\\n               return fn(...args);\\n           return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514408,
                "title": "day-o-1-o-7-commented-with-examples",
                "content": "This code defines a JavaScript function called **once**, which is used to create a new function that can only be invoked once. The ***once function*** takes another function fn as its ***parameter***.\\n\\nHere\\'s how the code works:\\n\\n* The ***once function*** creates a variable ans and initializes it to true. This variable keeps track of whether the wrapped function has been invoked before or not.\\n\\n* The ***once function*** returns an ***anonymous*** function that accepts any number of arguments using the rest parameter syntax (...args).\\n\\n* Inside the anonymous function, there is an if statement that checks the value of the ans variable. If it is true, it means that the wrapped function has not been invoked before.\\n \\n* If the condition is true, the ans variable is set to false to indicate that the wrapped function has now been invoked.\\n \\n* Finally, the wrapped **function** (fn) is called with the provided arguments using the spread operator (...args), and its result is returned.\\n\\nLet\\'s see an example to better understand how this code can be used:\\n```\\n// Example function\\nfunction sayHello(name) {\\n  console.log(\"Hello, \" + name);\\n}\\n\\n// Creating a new function using `once`\\nvar sayHelloOnce = once(sayHello);\\n\\n// Invoking the new function multiple times\\nsayHelloOnce(\"Alice\"); // Output: Hello, Alice\\nsayHelloOnce(\"Bob\");   // (no output)\\n\\n// The wrapped function is invoked only once\\n\\n```\\n\\nIn this example, the ***sayHelloOnce function*** is created using the once function and wraps the sayHello function. When sayHelloOnce is called the first time with the **argument** \"Alice\",\\n it invokes the wrapped sayHello function and prints \"Hello, Alice\" to the console. \\nHowever, when sayHelloOnce is called the second time with the **argument** \"Bob\", nothing happens because the wrapped function is set to be invoked only once.\\n\\n\\n***Here is the code to the current Problem :- ***\\n\\n```\\n\\nvar once = function(fn) {\\n    let ans = true;\\n    return function(...args){\\n        if (ans) {\\n            ans = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n// Example function\\nfunction sayHello(name) {\\n  console.log(\"Hello, \" + name);\\n}\\n\\n// Creating a new function using `once`\\nvar sayHelloOnce = once(sayHello);\\n\\n// Invoking the new function multiple times\\nsayHelloOnce(\"Alice\"); // Output: Hello, Alice\\nsayHelloOnce(\"Bob\");   // (no output)\\n\\n// The wrapped function is invoked only once\\n\\n```\n```\\n\\nvar once = function(fn) {\\n    let ans = true;\\n    return function(...args){\\n        if (ans) {\\n            ans = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514735,
                "title": "understand-question-step-by-step-solution-with-comments-javascript-typescript",
                "content": "# Understand the problem\\n\\nGiven a function `fn`, return a new function that is identical to the original function except that it ensures `fn` is called at most once.\\n\\nBreakdown -\\n\\nGiven a function `fn` -> means we have to give a function `fn` as an input\\n```\\n// give fn as an input\\nvar once = function(fn){\\n\\n}\\n```\\n\\nreturn a new function -> we have to return a function \\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n    }\\n};\\n```\\n\\nthat is identical to the original function -> means return function is identical like original function ,**that means it should also return a function becasue original function is return a function.**\\n\\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n      // it will also return a function\\n      return someFunction(...args){ }\\n    }\\n};\\n```\\n\\n except that it ensures `fn` is called at most once -> means we have to return a function `fn` and ensure one thing that it called only one time, means we have to track that function is called or not. \\n\\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // for tracking like function is called or not\\n    let isCalled = false;\\n    // we have to return a function\\n    return function(...args){\\n        // if function is called , we have to return undefined\\n        if(isCalled) return undefined;\\n        // change is called to true\\n        isCalled = !isCalled;\\n        // it will also return a function (otherwise)\\n        return fn(...args);\\n    }\\n};\\n```\\n\\nTypescript \\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCalled = false;\\n        return function(...args){\\n            if(isCalled) return undefined;\\n            isCalled = !isCalled;\\n            return fn(...args);\\n        }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// give fn as an input\\nvar once = function(fn){\\n\\n}\\n```\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n    }\\n};\\n```\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n      // it will also return a function\\n      return someFunction(...args){ }\\n    }\\n};\\n```\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // for tracking like function is called or not\\n    let isCalled = false;\\n    // we have to return a function\\n    return function(...args){\\n        // if function is called , we have to return undefined\\n        if(isCalled) return undefined;\\n        // change is called to true\\n        isCalled = !isCalled;\\n        // it will also return a function (otherwise)\\n        return fn(...args);\\n    }\\n};\\n```\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCalled = false;\\n        return function(...args){\\n            if(isCalled) return undefined;\\n            isCalled = !isCalled;\\n            return fn(...args);\\n        }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485421,
                "title": "2-solutions-closure-and-return-by-reference",
                "content": "# Closure\\n\\n```\\nfunction once(fn) {\\n    let called = false;\\n\\n    return (...args) => {\\n        if (called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n```\\n\\n# Return by reference\\n\\n```\\nfunction once(fn) {\\n    return (...args) => {\\n        const result = fn(...args);\\n\\n        fn = Function();\\n\\n        return result;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction once(fn) {\\n    let called = false;\\n\\n    return (...args) => {\\n        if (called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n```\n```\\nfunction once(fn) {\\n    return (...args) => {\\n        const result = fn(...args);\\n\\n        fn = Function();\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516813,
                "title": "easy-to-understand-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514632,
                "title": "java-script-solution-for-allow-one-function-call-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the once function is to create a wrapper function that ensures the original function fn is called only once. Subsequent calls to the wrapper function will not invoke fn but return undefined instead.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken by the once function is to use a closure to store a flag (hasBeenCalled) indicating whether fn has already been called. The wrapper function checks the flag and conditionally invokes fn only if it has not been called before\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the once function is O(1) because it performs a constant number of operations regardless of the size of the input.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n    return function(...args){\\n        if (!hasBeenCalled) {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n    return function(...args){\\n        if (!hasBeenCalled) {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836594,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516941,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        cnt++;\\n        if(cnt == 1)\\n        {\\n            return fn(...args);\\n        }\\n        return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        cnt++;\\n        if(cnt == 1)\\n        {\\n            return fn(...args);\\n        }\\n        return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516647,
                "title": "javascript-day-8-of-30-days-challange",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515793,
                "title": "limit-function-to-one-call",
                "content": "The code defines a function called `once` that takes a function `fn` as its parameter. The `once` function returns a new function that wraps around `fn` and ensures that it is called at most once.\\n\\nThe inner function keeps track of whether `fn` has been called before by setting a boolean variable `hasBeenCalled` to `false`. It also declares a variable `result` that will store the result of the first call to `fn`.\\n\\nThe inner function takes any number of arguments using the spread syntax `(...args)`. When the inner function is called for the first time, it checks whether `hasBeenCalled` is `false`. If so, it calls `fn` with the provided arguments using the spread syntax `fn(...args)`, and stores the result in the `result` variable. It then sets `hasBeenCalled` to `true` and returns the result.\\n\\nIf the inner function is called a second time or later, `hasBeenCalled` will be true, and the inner function will simply return `undefined`. This ensures that `fn` is only called once.\\n\\nThe expression `hasBeenCalled ? undefined : ((hasBeenCalled = true), (result = fn(...args)))` is used as the return value of the inner function. If `hasBeenCalled` is true, the function returns `undefined`. Otherwise, it sets `hasBeenCalled` to true, calls `fn` with the provided arguments, and stores the result in `result`, then returns `result`.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n  let result;\\n  let hasBeenCalled = false;\\n  return (...args) => hasBeenCalled ? undefined : ((hasBeenCalled = true), (result = fn(...args)));\\n}\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n  let result;\\n  let hasBeenCalled = false;\\n  return (...args) => hasBeenCalled ? undefined : ((hasBeenCalled = true), (result = fn(...args)));\\n}\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515785,
                "title": "javascript-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/708964a3-2181-4495-af4b-dfc3650f3c50_1683887783.4264705.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515110,
                "title": "simplest-code-in-javascript-using-counter-variable",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515043,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 52 ms, faster than 88.74% of JavaScript online submissions for Allow One Function Call.\\n# Memory Usage: 41.8 MB, less than 62.02% of JavaScript online submissions for Allow One Function Call.\\n\\tvar once = function(fn) {\\n\\n\\t\\tlet Flag = true\\n\\t\\treturn function(...args){\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n# Approach 2 Using Typescript :\\n# Runtime: 63 ms, faster than 54.55% of TypeScript online submissions for Allow One Function Call.\\n# Memory Usage: 42.8 MB, less than 62.03% of TypeScript online submissions for Allow One Function Call.\\n\\n\\tfunction once<T extends (...args: any[]) => any>(fn: T): \\n\\t ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n\\n\\t\\tlet Flag = true\\n\\n\\t\\treturn function (...args) {\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\n\\t  };\\n\\t}\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 52 ms, faster than 88.74% of JavaScript online submissions for Allow One Function Call.\\n# Memory Usage: 41.8 MB, less than 62.02% of JavaScript online submissions for Allow One Function Call.\\n\\tvar once = function(fn) {\\n\\n\\t\\tlet Flag = true\\n\\t\\treturn function(...args){\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n# Approach 2 Using Typescript :\\n# Runtime: 63 ms, faster than 54.55% of TypeScript online submissions for Allow One Function Call.\\n# Memory Usage: 42.8 MB, less than 62.03% of TypeScript online submissions for Allow One Function Call.\\n\\n\\tfunction once<T extends (...args: any[]) => any>(fn: T): \\n\\t ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n\\n\\t\\tlet Flag = true\\n\\n\\t\\treturn function (...args) {\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\n\\t  };\\n\\t}\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3514953,
                "title": "javascript-solution-best-solution-with-99-efficiency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe `once` function takes a function `fn` as an argument and returns a new function that ensures `fn` is called at most once. The new function returns the result of the first call to `fn` and returns `undefined` for all subsequent calls.\\n\\n![Screenshot 2023-05-12 113031.png](https://assets.leetcode.com/users/images/886d7a34-d878-493f-a074-fb88a12e4aeb_1683871248.2008448.png)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. `once` is a function that takes a function `fn` as an argument.\\n\\n2. Inside the `once` function, we initialize a boolean flag `flag` to `true`. This `flag` will be used to determine whether `fn` has been called before.\\n\\n3. We also declare a variable `result` to store the result of the function. This will allow us to return the same `result` every time the function is called.\\n\\n4. We return a new function that takes any number of arguments using the rest parameter syntax `...args`.\\n\\n5. Inside the new function, we check if the `flag` is `true`. If it is, we call the original function fn with the `args`, store the result in result, set the `flag` to `false`, and return the `result`.\\n\\n6. If the `flag` is `false`, we simply return `undefined` without calling the original function.\\n\\n7. We now have a new function that behaves like the original function, but ensures that it is only called `once`.\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    let result;\\n    return function(...args){\\n        if(flag) {\\n            result = fn(...args);\\n            flag = false;\\n            return result;\\n        } else return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    let result;\\n    return function(...args){\\n        if(flag) {\\n            result = fn(...args);\\n            flag = false;\\n            return result;\\n        } else return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514757,
                "title": "editorial-one-in-javascript-0-0",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let hasBeenCalled = false;\\n  return function(...args){\\n    if (hasBeenCalled) {\\n      return undefined;\\n    } else {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let hasBeenCalled = false;\\n  return function(...args){\\n    if (hasBeenCalled) {\\n      return undefined;\\n    } else {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514370,
                "title": "simple-javascript-solution-o-1",
                "content": "# Intuition\\nTake a boolean variable or integer variable and track if function is called once.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let count  = 0;\\n    return function(...args){\\n        if(count<1) {\\n            count++;\\n            return fn(...args);\\n        }\\n        else {\\n         return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let count  = 0;\\n    return function(...args){\\n        if(count<1) {\\n            count++;\\n            return fn(...args);\\n        }\\n        else {\\n         return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3500997,
                "title": "js-simple-solution",
                "content": "# Approach\\nWe must keep the information if we\\'ve already triggered the function in a variable. Then on first trigger just set it and from then just return undefined.\\n\\nIt is possible to use Function.apply also to trigger the function with an array of arguments (works in older versions of ES):\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```js\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n    let isTriggered = false\\n    return (...args) => {\\n        if (isTriggered) return\\n        isTriggered = true\\n        return fn(...args)\\n    }\\n};\\n```\\n\\nAlternatively, we can use Function.apply method:\\n```js\\nfn.apply(this, args)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n    let isTriggered = false\\n    return (...args) => {\\n        if (isTriggered) return\\n        isTriggered = true\\n        return fn(...args)\\n    }\\n};\\n```\n```js\\nfn.apply(this, args)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493253,
                "title": "my-once",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let calls = false;\\n  \\n  return function (...args) {\\n    if (calls === false) {\\n      calls = true;\\n      return fn(...args);\\n    }\\n    else\\n      return undefined;\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let calls = false;\\n  \\n  return function (...args) {\\n    if (calls === false) {\\n      calls = true;\\n      return fn(...args);\\n    }\\n    else\\n      return undefined;\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3488425,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return function(...args){\\n        const ans=fn(...args);\\n        fn=Function();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return function(...args){\\n        const ans=fn(...args);\\n        fn=Function();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485777,
                "title": "1-liner",
                "content": "```\\nvar once = f => (...a) => f ? [f(...a), f=undefined][0] : f\\n```",
                "solutionTags": [],
                "code": "```\\nvar once = f => (...a) => f ? [f(...a), f=undefined][0] : f\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485501,
                "title": "3-lines-js-solution-beats-100",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n    let count=0;\\n    return function(...args){\\n        if (count++==0) return fn(...args);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let count=0;\\n    return function(...args){\\n        if (count++==0) return fn(...args);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523010,
                "title": "very-easy-to-understand-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let used = false;\\n    return function(...args){\\n       if(used) return undefined\\n       used = true\\n       return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let used = false;\\n    return function(...args){\\n       if(used) return undefined\\n       used = true\\n       return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514171,
                "title": "use-a-generator-function",
                "content": "# Intuition\\nUse generator function and put an infinite loop with a undefined yeild.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    function* OnceOnly()\\n    {\\n        const args = yield;\\n        const result = fn.apply(null, args);\\n        yield result;\\n        while (true)\\n        {\\n            yield undefined\\n        }\\n    }\\n    \\n    const gen = OnceOnly();\\n    \\n    return function(...args)\\n    {\\n        gen.next(args); // First value sent to generator is always lost. we will run it twice every subsequent time but thats fine because after second call the generator always returns undefined\\n        let result = gen.next(args)\\n        \\n        return result.value;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    function* OnceOnly()\\n    {\\n        const args = yield;\\n        const result = fn.apply(null, args);\\n        yield result;\\n        while (true)\\n        {\\n            yield undefined\\n        }\\n    }\\n    \\n    const gen = OnceOnly();\\n    \\n    return function(...args)\\n    {\\n        gen.next(args); // First value sent to generator is always lost. we will run it twice every subsequent time but thats fine because after second call the generator always returns undefined\\n        let result = gen.next(args)\\n        \\n        return result.value;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3502193,
                "title": "ts-simple-boolean-flag-52ms-41-9mb",
                "content": "Pretty simple problem to be solved with encapsulation, similar to other [base](https://leetcode.com/problems/counter/solutions/3492591/) [ones](https://leetcode.com/problems/counter-ii/solutions/3492633/) we already solved with a wrapper. The classic [debounce challenge](https://leetcode.com/problems/debounce/) ([solved here](https://leetcode.com/problems/debounce/solutions/3517553/)) might be a good next step.\\n\\nIn this specific case we will just need a boolean flag `isCallable` initially set to `true`, right outside the wrapper function we are going to `return`.\\n\\nSaid wrapper will check if `callable == true` and if so, it will:\\n* flag `isCallable` to `false`;\\n* `return` the expected result, invoking `fn` with all the arguments (`args`) it was called with.\\n\\nIf the flag is set to `false`, it means `fn` was already invoked once, so we will just `return` `undefined`.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```ts\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCallable = true;\\n    return function (...args) {\\n        return isCallable ? (isCallable = false, fn(...args)) : undefined;\\n    };\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```ts\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCallable = true;\\n    return function (...args) {\\n        return isCallable ? (isCallable = false, fn(...args)) : undefined;\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494782,
                "title": "simple-solution-happy-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result = false;\\n    return function(...args){\\n        if(!result){\\n            result = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result = false;\\n    return function(...args){\\n        if(!result){\\n            result = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100680,
                "title": "allow-one-function-call-javascript-solution-by-bharadwaj",
                "content": "# Approach\\nFunctional Programming\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let count = 0;\\n    return function(...args){\\n        if(count++ === 0) return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let count = 0;\\n    return function(...args){\\n        if(count++ === 0) return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097518,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = true\\n\\treturn function(...args){\\n        if(called) {\\n            called = false\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = true\\n\\treturn function(...args){\\n        if(called) {\\n            called = false\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096082,
                "title": "the-solution-only-by-two-lines-of-code",
                "content": "\\n# Code\\n```\\nvar once = function (fn)\\n{\\n      let expired = false;\\n      // if expired == true  retrun undefined\\n      // else set expierd to true and return orginal function\\n      //this is calld ternany operator \\n      return (...args) => (expired ? undefined : ((expired = true), fn(...args)));\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function (fn)\\n{\\n      let expired = false;\\n      // if expired == true  retrun undefined\\n      // else set expierd to true and return orginal function\\n      //this is calld ternany operator \\n      return (...args) => (expired ? undefined : ((expired = true), fn(...args)));\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096013,
                "title": "easy-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasCalled = false;\\n\\treturn function(...args){\\n        if(!hasCalled){\\n            result  = fn(...args);\\n            hasCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasCalled = false;\\n\\treturn function(...args){\\n        if(!hasCalled){\\n            result  = fn(...args);\\n            hasCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088217,
                "title": "allow-function-to-be-called-only-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.\\n -->\\nClosure concept: internal function will have access to the lexical scope of its parent, \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso we can keep a flag or number there to check if the internal function has been called or not\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype OnceFn = (...args: JSONValue[]) => JSONValue | undefined\\n\\nfunction once(fn: Function): OnceFn {\\n    let called = false;\\n    return function (...args) {\\n        if (called) {\\n            return;\\n        }\\n        else {\\n            called = true;\\n            return fn(...args);\\n        }\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype OnceFn = (...args: JSONValue[]) => JSONValue | undefined\\n\\nfunction once(fn: Function): OnceFn {\\n    let called = false;\\n    return function (...args) {\\n        if (called) {\\n            return;\\n        }\\n        else {\\n            called = true;\\n            return fn(...args);\\n        }\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087225,
                "title": "why-not-nullify-func-after-first-call",
                "content": "# Intuition\\nMy first thoughts in solving this problems were to either keep track of whether the func call was made or simply nullify the func. So that the actual fn call is not made. \\n\\nIdeally this approach should not be used, as it tampers the func definition, which we do not want. A calling function in general does not expect the called function to update any of its params. \\n\\nBut here we are solving the problems in all ways possible for the sake of learning!\\n\\n# Approach\\nJust nullify the func after invoke statement\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return (...args) => {\\n        let a = fn(...args);\\n        fn = () => {null};\\n        return a;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return (...args) => {\\n        let a = fn(...args);\\n        fn = () => {null};\\n        return a;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082559,
                "title": "solution-with-conditional-ternary-operator-and-apply-method-using-count-in-a-let-to-manage-state",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let count = 0\\n\\n    return function (...args) {\\n        count += 1\\n        return count > 1 ?  undefined :  fn.apply(this, args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let count = 0\\n\\n    return function (...args) {\\n        count += 1\\n        return count > 1 ?  undefined :  fn.apply(this, args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081167,
                "title": "js-simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(isCalled) return;\\n        isCalled = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(isCalled) return;\\n        isCalled = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078995,
                "title": "very-very-simple-and-clean-javascript-typescript-solution",
                "content": "```\\nconst once = (fn) => {\\n    let isCalled = 0;\\n    \\n    return function(...args) {\\n        if (isCalled) return;\\n\\n        isCalled = true;\\n\\n        return fn.apply(this, args);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst once = (fn) => {\\n    let isCalled = 0;\\n    \\n    return function(...args) {\\n        if (isCalled) return;\\n\\n        isCalled = true;\\n\\n        return fn.apply(this, args);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072258,
                "title": "straightforward-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calledBefore = false;\\n    return function(...args){\\n        if(!calledBefore){\\n            calledBefore = true;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calledBefore = false;\\n    return function(...args){\\n        if(!calledBefore){\\n            calledBefore = true;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071326,
                "title": "allow-one-function-call-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let status = false;\\n    return function(...args){\\n        if(status){\\n            return undefined;\\n        }\\n        status = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let status = false;\\n    return function(...args){\\n        if(status){\\n            return undefined;\\n        }\\n        status = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069367,
                "title": "js-closure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    \\n    return function(...args){\\n        if (isCalled) {\\n            return undefined;\\n        } else {\\n            isCalled = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    \\n    return function(...args){\\n        if (isCalled) {\\n            return undefined;\\n        } else {\\n            isCalled = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068172,
                "title": "beats-97-48-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let called=false;\\n\\n    return (...args) => {\\n        if(called) return;\\n        \\n        called=true;\\n        \\n        return fn(...args)\\n    }\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let called=false;\\n\\n    return (...args) => {\\n        if(called) return;\\n        \\n        called=true;\\n        \\n        return fn(...args)\\n    }\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068158,
                "title": "allow-one-function-call-with-constant-time-complexity",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$Big-O = O(1) - Constant$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet once = function (fn) {\\n  let flag = false;\\n  return function (...args) {\\n    if (!flag) {\\n      flag = true;\\n     return fn(...args)\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet once = function (fn) {\\n  let flag = false;\\n  return function (...args) {\\n    if (!flag) {\\n      flag = true;\\n     return fn(...args)\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067085,
                "title": "2666-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0;\\n\\n    return function(...args){\\n       \\n        if (count > 0) return undefined; count++;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0;\\n\\n    return function(...args){\\n       \\n        if (count > 0) return undefined; count++;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062288,
                "title": "beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var count=0;\\n    let result;\\n    return function(...args){\\n       if(count<1){\\n           result = fn(...args);\\n           count += 1\\n           return result;\\n       }else{\\n           return undefined;\\n       }\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var count=0;\\n    let result;\\n    return function(...args){\\n       if(count<1){\\n           result = fn(...args);\\n           count += 1\\n           return result;\\n       }else{\\n           return undefined;\\n       }\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058710,
                "title": "simplest-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let x;\\n    return function(...args){\\n        if(x == null) return x = fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let x;\\n    return function(...args){\\n        if(x == null) return x = fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056677,
                "title": "simple-function-for-return-func-one-tiome",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let runner = 0\\n    return function(...args){\\n        for(let i = 0; i < args.length; i++) {\\n            if(runner === 0) {\\n            runner = 1\\n            return fn(...args)\\n            } else {\\n                return undefined\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let runner = 0\\n    return function(...args){\\n        for(let i = 0; i < args.length; i++) {\\n            if(runner === 0) {\\n            runner = 1\\n            return fn(...args)\\n            } else {\\n                return undefined\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055983,
                "title": "the-fastest-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    counter = 0;\\n    return function(...args){\\n        if(counter > 0) return undefined\\n        counter++\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    counter = 0;\\n    return function(...args){\\n        if(counter > 0) return undefined\\n        counter++\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051156,
                "title": "simple-solution-in-js-ts",
                "content": "# Code\\n```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n    let fnCalled: boolean = false;\\n\\n    return function (...args): Fn {\\n        if (fnCalled) return undefined;\\n\\n        fnCalled = true;\\n        return fn(...args);\\n\\n    };\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n    let fnCalled: boolean = false;\\n\\n    return function (...args): Fn {\\n        if (fnCalled) return undefined;\\n\\n        fnCalled = true;\\n        return fn(...args);\\n\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048303,
                "title": "allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let hasBeenCalled = false;\\n    let result;\\n\\n    return function(...args){\\n        if(!hasBeenCalled){\\n            result = fn(...args);\\n            hasBeenCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let hasBeenCalled = false;\\n    let result;\\n\\n    return function(...args){\\n        if(!hasBeenCalled){\\n            result = fn(...args);\\n            hasBeenCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048005,
                "title": "js-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nconst once = (fn: Fn): Fn  =>{\\n    let fun;\\n  return function (...args) {\\n    if(fun !== undefined) return undefined;\\n   return fun = fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nconst once = (fn: Fn): Fn  =>{\\n    let fun;\\n  return function (...args) {\\n    if(fun !== undefined) return undefined;\\n   return fun = fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047007,
                "title": "creating-a-javascript-once-function-execute-functions-only-once-and-cache-results",
                "content": "# Intuition\\n<!-- Provide a brief description of your initial thoughts and strategies for solving this problem. -->\\n\\nThe goal of this code is to create a function called `once` that takes another function (`fn`) as its argument and returns a new function. This new function ensures that the original `fn` is executed only once, and its result is cached and returned on subsequent calls.\\n\\n# Approach\\n<!-- Describe the approach you took to solve the problem. -->\\n\\nI\\'ve implemented the `once` function to encapsulate the behavior of the original function (`fn`). Here\\'s how it works:\\n\\n- We initialize a `called` variable to track whether the `fn` function has been called before.\\n- We also declare a `result` variable to store the result of the `fn` function when it\\'s called.\\n\\n- The returned function accepts any number of arguments using the `...args` syntax. This allows it to work with functions that accept different argument lists.\\n\\n- Inside the returned function:\\n  - It checks if `called` is `true`. If it\\'s true, the function returns the cached `result` without calling `fn` again.\\n  - If `called` is `false`, it sets `called` to `true`, calls the original `fn` with the provided `args`, stores the result in `result`, and then returns the result.\\n\\nThis design ensures that the `fn` function is executed only once, and subsequent calls return the cached result.\\n\\n# Code\\n```javascript\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false \\n    let result;\\n    return function(...args){\\n        if(called) return undefined\\n        called = true \\n        result = fn(...args)\\n        return result \\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false \\n    let result;\\n    return function(...args){\\n        if(called) return undefined\\n        called = true \\n        result = fn(...args)\\n        return result \\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044293,
                "title": "once",
                "content": "# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    var hasUsed:boolean = false    \\n    return function (...args) {\\n        var result = hasUsed ? undefined : fn(...args); hasUsed = true; return result;\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    var hasUsed:boolean = false    \\n    return function (...args) {\\n        var result = hasUsed ? undefined : fn(...args); hasUsed = true; return result;\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044275,
                "title": "once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar c = true;\\nvar once = (fn) => {\\n    c = true\\n    return (...args) => {\\n        var res = c ? fn(...args) : undefined\\n        c = false\\n        return res\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar c = true;\\nvar once = (fn) => {\\n    c = true\\n    return (...args) => {\\n        var res = c ? fn(...args) : undefined\\n        c = false\\n        return res\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044140,
                "title": "the-most-simple-single-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(1)\\n- Space complexity:\\n    O(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0\\n    return function(...args){\\n        if(!count++) return fn(...args)    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0\\n    return function(...args){\\n        if(!count++) return fn(...args)    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041566,
                "title": "using-clouser",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let hasBeenCalled = false\\n    let result;\\n    return function (...args) {\\n        if (!hasBeenCalled) {\\n            hasBeenCalled = 1 //true\\n            result = fn(...args)\\n            return result\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let hasBeenCalled = false\\n    let result;\\n    return function (...args) {\\n        if (!hasBeenCalled) {\\n            hasBeenCalled = 1 //true\\n            result = fn(...args)\\n            return result\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041206,
                "title": "javascript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n\\n    return function(...args) {\\n        if (hasBeenCalled) return undefined;\\n        hasBeenCalled = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n\\n    return function(...args) {\\n        if (hasBeenCalled) return undefined;\\n        hasBeenCalled = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037119,
                "title": "a-c-analogy",
                "content": "### cpp thoughts...\\n New to js. Related to cpp to make sense of it! Thought of sharing!\\n\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let flag=false;\\n    return function(...args){\\n        if(!flag){ \\n            flag=true;\\n            // console.log(args[0]);\\n            return fn(...args); \\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n```cpp []\\n// made my data type- func() :)\\n\\nfunc() once(function){\\n    // code\\n    return function(); // obv\\n}\\n\\nfunc() x=once(fn); // x is a function right?! `once` returns x\\nx(...args); // now x can be parameterized (this case).\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let flag=false;\\n    return function(...args){\\n        if(!flag){ \\n            flag=true;\\n            // console.log(args[0]);\\n            return fn(...args); \\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n```cpp []\\n// made my data type- func() :)\\n\\nfunc() once(function){\\n    // code\\n    return function(); // obv\\n}\\n\\nfunc() x=once(fn); // x is a function right?! `once` returns x\\nx(...args); // now x can be parameterized (this case).\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036829,
                "title": "simple-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var Oncecall=true;\\n    return function(...args){\\n        if(Oncecall){\\n            Oncecall=false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var Oncecall=true;\\n    return function(...args){\\n        if(Oncecall){\\n            Oncecall=false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036301,
                "title": "allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false\\n    return function(...args){\\n         if(!isCalled){\\n            isCalled=true\\n            return fn(...args)\\n         }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false\\n    return function(...args){\\n         if(!isCalled){\\n            isCalled=true\\n            return fn(...args)\\n         }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035292,
                "title": "learn-closures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if(!isCalled){\\n           \\n            isCalled=true;\\n             return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if(!isCalled){\\n           \\n            isCalled=true;\\n             return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029763,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    let flag = false;\\n    return function(...args){\\n        \\n        if(!flag) {\\n            flag = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    let flag = false;\\n    return function(...args){\\n        \\n        if(!flag) {\\n            flag = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4026281,
                "title": "ok",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n   \\n    let called = false;\\n    return function(...args){\\n         \\n        if(called){\\n            return undefined\\n        }\\n       called = true;\\n\\n    if(called){\\n        return fn(...args);\\n    }\\n\\n\\n\\n\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n   \\n    let called = false;\\n    return function(...args){\\n         \\n        if(called){\\n            return undefined\\n        }\\n       called = true;\\n\\n    if(called){\\n        return fn(...args);\\n    }\\n\\n\\n\\n\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024273,
                "title": "perfect-solution-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet fn = (a,b,c) => (a + b + c);\\nvar once = function(fn) {\\n    let call = 0;\\n    return function(...args){\\n        if (call ==0){\\n            call +=1;\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet fn = (a,b,c) => (a + b + c);\\nvar once = function(fn) {\\n    let call = 0;\\n    return function(...args){\\n        if (call ==0){\\n            call +=1;\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019836,
                "title": "x",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n var once = function(fn) {\\n let o = true\\n  let onceFn    \\n    return function(...args){\\n        if(o){  \\n        o = false\\n       onceFn = fn(...args)\\n     return onceFn;         \\n     }else{\\n      return undefined  \\n        }  \\n    }\\n};\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n var once = function(fn) {\\n let o = true\\n  let onceFn    \\n    return function(...args){\\n        if(o){  \\n        o = false\\n       onceFn = fn(...args)\\n     return onceFn;         \\n     }else{\\n      return undefined  \\n        }  \\n    }\\n};\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018094,
                "title": "clean-solution-with-detailed-explanation",
                "content": "#  Explanation\\nWhen `once` is called the first time, it returns another function and do nothing. Since it is a closure, the inner function will still have access to lexical scope or the arguments that were passed in the parent function.. which is `fn` in this case. We don\\'t know the internals of what that function does but **OUR TASK** is to pass all the arguments we have to that callback function and let it do its part. The only thing we need to make sure is we should only let this function invoke once. To solve this, define a variable, `called` in my case and set it to `false` and set it to `true` before we call the `callback fn` and wrap this logic with.\\n```\\nif(!called) {\\n    called = true\\n    return fn(...args)\\n}\\n```\\nI could have `if/else` condition here like `if(called) return undefined`. But just wrapping it like this will do the trick too. If the `if condition` is not met, then `javascript` will return `undefined` itself since there is nothing to return.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false\\n    \\n    return function(...args){\\n    if(!called) {\\n        called = true\\n        return fn(...args)\\n    }\\n    }\\n};\\n\\n\\n  // let fn = (a,b,c) => (a + b + c)\\n  // let onceFn = once(fn)\\n \\n  // onceFn(1,2,3); // 6\\n  // onceFn(2,3,6); // returns undefined without calling fn\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nif(!called) {\\n    called = true\\n    return fn(...args)\\n}\\n```\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false\\n    \\n    return function(...args){\\n    if(!called) {\\n        called = true\\n        return fn(...args)\\n    }\\n    }\\n};\\n\\n\\n  // let fn = (a,b,c) => (a + b + c)\\n  // let onceFn = once(fn)\\n \\n  // onceFn(1,2,3); // 6\\n  // onceFn(2,3,6); // returns undefined without calling fn\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005231,
                "title": "js-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    var cnt=0;  \\n    return function(...args){\\n        cnt++;\\n         if(cnt==1)return fn(...args)\\n         else return undefined\\n         \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    var cnt=0;  \\n    return function(...args){\\n        cnt++;\\n         if(cnt==1)return fn(...args)\\n         else return undefined\\n         \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000085,
                "title": "javascript-solution-for-beginners",
                "content": "# JavaScript Solution\\n1.```let called = false;``` Inside the once function, a variable ***called*** is declared and initialized with false. This variable is used to keep track of whether the fn function has been called before.\\n\\n2.```if (called === false) { ... }```: Inside the inner function, it checks if the called variable is false, which means that fn has not been called before.\\n\\n3.```called = true;``` If fn has not been called before, it sets called to true, indicating that fn has now been called.\\n\\n4.```return fn(...args);``` It then calls the fn function with the provided arguments (args) and returns its result. This essentially allows you to call fn only once, and subsequent calls will return undefined.\\n\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let called = false;\\n  \\n    return function (...args) {\\n        if (called === false) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        else return undefined;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```let called = false;```\n```if (called === false) { ... }```\n```called = true;```\n```return fn(...args);```\n```\\nvar once = function(fn) {\\n    let called = false;\\n  \\n    return function (...args) {\\n        if (called === false) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        else return undefined;\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997948,
                "title": "javascript-easy-simple-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n<!-- upvote if it helps -->\\n\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let t=true;\\n    let result;\\n    return function(...args){\\n        if(t)\\n        {\\n            result = fn(...args);\\n            t= false;\\n            return result;\\n        }\\n        else\\n       { return undefined;}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n<!-- upvote if it helps -->\\n\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let t=true;\\n    let result;\\n    return function(...args){\\n        if(t)\\n        {\\n            result = fn(...args);\\n            t= false;\\n            return result;\\n        }\\n        else\\n       { return undefined;}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997718,
                "title": "best-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n      if(c==0)  {\\n          c++;\\n          return fn(...args);\\n      }\\n      else{\\n          return undefined;\\n      }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n      if(c==0)  {\\n          c++;\\n          return fn(...args);\\n      }\\n      else{\\n          return undefined;\\n      }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996909,
                "title": "yea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = (fn) => {\\n  let executed = false;\\n  return (...args) => {\\n    if (!executed) {\\n      executed = true;\\n      return fn(...args);\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = (fn) => {\\n  let executed = false;\\n  return (...args) => {\\n    if (!executed) {\\n      executed = true;\\n      return fn(...args);\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983468,
                "title": "easy-to-understand",
                "content": "\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let call=0;\\n  return function (...args) {\\n      if(call==1) return undefined\\n      ++call;\\n      return fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let call=0;\\n  return function (...args) {\\n      if(call==1) return undefined\\n      ++call;\\n      return fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982969,
                "title": "a-really-short-solution",
                "content": "# Solution\\nJust change the reference of the argument, we do not need any more extra variables.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n        let rs = fn(...args);\\n        fn = ()=>undefined;\\n        return rs;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n        let rs = fn(...args);\\n        fn = ()=>undefined;\\n        return rs;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978446,
                "title": "explaining-a-closure-based-once-only-function-counter",
                "content": "# Intuition\\nThe purpose of this code is to create a function `once` that takes another function `fn` as input and returns a new function. This new function ensures that the provided function `fn` is executed only the first time it\\'s called, and subsequent calls will not execute `fn` again.\\n\\n# Approach\\n\\nThe code uses a closure and a counter variable to achieve its goal. Here\\'s how it works:\\n\\n1. The `once` function is called with an input function `fn`.\\n\\n2. Inside `once`, a `counter` variable is initialized with a value of 0.\\n\\n3. The `once` function returns an inner function (a closure) that captures the `counter` variable and takes any number of arguments using the spread operator `...args`.\\n\\n4. When the inner function is called, it first increments the `counter` using `++counter`. This means that the `counter` is incremented before its value is used in the comparison.\\n\\n5. The incremented value of `counter` is then compared to 1 using `=== 1`. If the comparison is true (meaning this is the first call to the inner function), it executes the original function `fn` with the provided arguments using `fn(...args)`.\\n\\n6. If the comparison is false (meaning this is not the first call), the inner function returns `undefined` without executing `fn`.\\n\\n**Explanation of ++counter:**\\nThe `++counter` part is a pre-increment operation on the `counter` variable. This means that before the value of counter is used for comparison, it is incremented by 1. In other words, the value of `counter` is increased by 1 before it\\'s checked in the comparison `++counter === 1`.\\n\\nThis pre-increment is crucial for ensuring that fn is executed only on the very first call to the inner function. Once the counter is incremented to 1 and the comparison succeeds, it ensures that subsequent calls to the inner function will result in counter being greater than 1, thus preventing fn from executing again.\\n\\n# Complexity\\n**- Time complexity:**\\nThe time complexity of this code is constant time, `O(1)`, regardless of how many times the functions are called.\\n\\n\\n**- Space complexity:**\\nThe space complexity is also constant, `O(1)`, as the memory used is fixed and does not increase with the number of function calls.\\n\\nIn summary, the code leverages a closure and a pre-increment operation to create a function that executes the provided function only on its first call and returns `undefined` on `subsequent calls`.\\n\\n\\n# Code\\n```\\nconst once = fn => {\\n  let counter = 0\\n\\n  return (...args) => (++counter === 1 ? fn(...args) : undefined)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst once = fn => {\\n  let counter = 0\\n\\n  return (...args) => (++counter === 1 ? fn(...args) : undefined)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975950,
                "title": "l",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\nif(called){\\n    return  undefined;\\n}\\ncalled = true;\\n              return fn.apply(this,args)\\n\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\nif(called){\\n    return  undefined;\\n}\\ncalled = true;\\n              return fn.apply(this,args)\\n\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973416,
                "title": "super-simple-and-straightforward-approach-stringifying-the-function-with-map-javascript",
                "content": "# Intuition\\nThis seems like the Memoization problem, except we want to remember the function itself.\\n\\n# Approach\\n- We can save the function into a Map as a string.\\n- When a function is passed, we check if it exist in the map, if it does, return undefined.\\n- If it doesn\\'t, stringify the function, save it as an entry in the map, and returns the function result with the argument paramenter \\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const map = new Map();\\n    \\n    return function(...args) {\\n        if (map.get(\"\" + fn)) return undefined;\\n        map.set(\"\" + fn, 1);\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const map = new Map();\\n    \\n    return function(...args) {\\n        if (map.get(\"\" + fn)) return undefined;\\n        map.set(\"\" + fn, 1);\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972906,
                "title": "o-1-sc-o-1-tc-solution-in-js-day-8",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to return a new function that behaves differently depending on whether it has been called before. If it has not been called before, it should call the original function and return its result. If it has been called before, it should return undefined without calling the original function again.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can return a new function that keeps track of whether it has been called before. We can do this by using a closure to store a boolean flag that is initially set to false. The first time the new function is called, we call the original function and set the flag to true. We also store the result of the original function. Subsequent calls to the new function simply return undefined without calling the original function again\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) for both the first and subsequent calls to the returned function. This is because checking the hasBeenCalled flag and returning either the result or undefined are constant-time operations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as well. This is because we only use a constant amount of extra space to store the hasBeenCalled flag and the result of the original function\\n# Code In JS\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972004,
                "title": "easy-solution-runtime-53-ms-space-41-77-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved if we somehow restrict the function(...args) from calling it more than one time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we can start with initialising a boolean variable witha true value (example let val = true) outside the function to be returned and by using a while loop we can check for val as the condition for the while loop. When the function is being called for once we can change the value of val to false. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let val =true;\\n    return function(...args){\\n        while(val){\\n            val = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let val =true;\\n    return function(...args){\\n        while(val){\\n            val = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971151,
                "title": "simple-o-1-o-1-complexities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n            if(counter ===0){\\n                counter++;\\n                return fn(...args)\\n            }\\n            return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n            if(counter ===0){\\n                counter++;\\n                return fn(...args)\\n            }\\n            return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966505,
                "title": "sweet-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args) {\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args) {\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963242,
                "title": "one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let trigger = 0;\\n    return function(...args){\\n        if(trigger == 0){\\n            trigger++;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let trigger = 0;\\n    return function(...args){\\n        if(trigger == 0){\\n            trigger++;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962458,
                "title": "closure",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = function(fn) {\\n\\n    let wasCalled = false\\n    \\n    return function(...args){\\n        if (!wasCalled) {\\n            wasCalled = true\\n            const result = fn(...args)\\n            return result\\n        }    \\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = function(fn) {\\n\\n    let wasCalled = false\\n    \\n    return function(...args){\\n        if (!wasCalled) {\\n            wasCalled = true\\n            const result = fn(...args)\\n            return result\\n        }    \\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957853,
                "title": "very-simple-solution-using-flag",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955653,
                "title": "js-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let k=0;\\n\\n    return function(...args){\\n        \\n        if(k>0){\\n            return undefined;\\n        }\\n\\n        k++;\\n        return fn(...args);\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let k=0;\\n\\n    return function(...args){\\n        \\n        if(k>0){\\n            return undefined;\\n        }\\n\\n        k++;\\n        return fn(...args);\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955273,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0 \\n    return function(...args){\\n        if(count < 1){\\n            count++\\n            return fn(...args)\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0 \\n    return function(...args){\\n        if(count < 1){\\n            count++\\n            return fn(...args)\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954054,
                "title": "allow-one-function-call-day-10-javascript-solution-apply",
                "content": "# Intuition\\nThe problem is asking us to return a result as fn but on consequent calls it should return undefined.\\n\\n# Approach\\n- Assign a new variable `val` to the result of calling the passed function.\\n- Reassign the function `fn` to return undefined.\\n- Return the new variable `val`.\\n\\n# Complexity\\n- Time complexity:\\n0(1)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n      const val = fn.apply(this, args)\\n      fn = () => undefined\\n      return val\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n      const val = fn.apply(this, args)\\n      fn = () => undefined\\n      return val\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953782,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(called === false){\\n            called=true;\\n            return fn(...args);\\n        }\\n        else {\\n            return undefined;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(called === false){\\n            called=true;\\n            return fn(...args);\\n        }\\n        else {\\n            return undefined;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3948148,
                "title": "allow-once-function-call-in-simple-way",
                "content": "# Intuition\\nFunction needs to be called only once we need counter or we need to assign null or undefined to that function and first call will return function so function needs to be stored as variable of outer function so we can use closure concept\\n\\n# Approach\\nfirst we assigned function to variable in outerfunction so returned function will hold reference to that function due to closure and when first time called if check will be true and after calling we will assign undefined or null so next time call that if check will fail and return undefined\\n\\n# Complexity\\n- Time complexity:\\n  -\\n\\n- Space complexity:\\n -\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnToCall = fn;\\n    return function(...args){\\n      if(fnToCall) {\\n       let result =  fnToCall(...arguments);\\n       fnToCall = undefined;\\n       return result;\\n      }\\n      return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnToCall = fn;\\n    return function(...args){\\n      if(fnToCall) {\\n       let result =  fnToCall(...arguments);\\n       fnToCall = undefined;\\n       return result;\\n      }\\n      return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947942,
                "title": "easy-solution-with-proper-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let firstCalled = false;\\n    return function(...args){\\n // we have  first need to return the same function \\n//    with its argument (...args)\\n   \\n   // to check wheather it is called for one time only\\n   if (firstCalled ){\\n       return undefined;\\n   }\\n    firstCalled =!firstCalled\\n    return fn(...args)\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let firstCalled = false;\\n    return function(...args){\\n // we have  first need to return the same function \\n//    with its argument (...args)\\n   \\n   // to check wheather it is called for one time only\\n   if (firstCalled ){\\n       return undefined;\\n   }\\n    firstCalled =!firstCalled\\n    return fn(...args)\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947476,
                "title": "javascript-solution",
                "content": "\\n- se crea un state called para saber cuando una fn fue llamada\\n\\n- el if (called) si es true significa que la funci\\xF3n ya fue llamada entonces retornara undefined\\n\\n- si no es true proceder\\xE1 a convertir called=true y llamar la funci\\xF3n que este quiera ejecutar\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) {\\n            return undefined;\\n        }\\n        called = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) {\\n            return undefined;\\n        }\\n        called = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946528,
                "title": "no-return-undefined-needed-if-statement-only",
                "content": "# Approach\\nSimple if statement to check if the function has been called at least once. It returns undefined automatically if we remove the return statement.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = (fn) => {\\n    let res\\n    return (...args) => {\\n        if (!res) {\\n            res = fn(...args)\\n            return res \\n        } \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = (fn) => {\\n    let res\\n    return (...args) => {\\n        if (!res) {\\n            res = fn(...args)\\n            return res \\n        } \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945579,
                "title": "shortest-typescript-solution",
                "content": "# Approach\\nThe once function creates a closure over a `counter` variable, which is incremented each time the returned function is called. If `counter` is equal to 1, the original function is called with the provided arguments and its result is returned. Otherwise, `undefined` is returned.\\n\\n# Complexity\\nTime complexity: The time complexity of calling the returned function is `O(1)`, since it only involves incrementing a counter and checking its value.\\nSpace complexity: The space complexity of the once function is `O(1)`, since it only needs to store a single counter variable. However, keep in mind that the returned function also maintains a reference to the original function and its arguments, so the total space complexity will depend on the size of those objects.\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let counter = 0;\\n  return function (...args) {\\n    counter++;\\n    return counter === 1 ? fn(...args) : undefined;\\n  };\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let counter = 0;\\n  return function (...args) {\\n    counter++;\\n    return counter === 1 ? fn(...args) : undefined;\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944565,
                "title": "resolved-the-problem-using-js",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const memorizeFunction = {}\\n    \\n    return (...arg) => {\\n        if(fn in memorizeFunction) {\\n           return undefined\\n        }\\n        \\n        let result = fn(...arg)\\n        memorizeFunction[fn] = result\\n        return result\\n    }\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const memorizeFunction = {}\\n    \\n    return (...arg) => {\\n        if(fn in memorizeFunction) {\\n           return undefined\\n        }\\n        \\n        let result = fn(...arg)\\n        memorizeFunction[fn] = result\\n        return result\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3941484,
                "title": "simple-logic",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936617,
                "title": "function-as-objects-smart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn Javascript functions are treated as objects. We can leverage this property and use it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd a count variable to the function `fn`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\t  fn.count = 0\\n    return function(...args){\\n\\t\\t\\t if(fn.count == 1){\\n\\t\\t\\t\\t return undefined\\n\\t\\t\\t }else{\\n\\t\\t\\t\\t fn.count = 1\\n\\t\\t\\t\\t return fn(...args)\\n\\t\\t\\t }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\t  fn.count = 0\\n    return function(...args){\\n\\t\\t\\t if(fn.count == 1){\\n\\t\\t\\t\\t return undefined\\n\\t\\t\\t }else{\\n\\t\\t\\t\\t fn.count = 1\\n\\t\\t\\t\\t return fn(...args)\\n\\t\\t\\t }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936595,
                "title": "flag-closure-and-one-if-statement",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, you just need a flag to say when is the first time and then you turn it to false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used closure in the first function and then i added a condition to the second function with just 1 \"if\", cause that\\'s the only one we need and in the same if we change the value of the \"flag\" to \"false\", so it won\\'t run in the second time and return \"undefined\" by default.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    return function(...args){\\n        if(flag){\\n        flag = false;\\n        return fn(...args)\\n    }\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    return function(...args){\\n        if(flag){\\n        flag = false;\\n        return fn(...args)\\n    }\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935468,
                "title": "allow-one-function-call-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to return a new function that behaves differently depending on whether it has been called before. If it has not been called before, it should call the original function and return its result. If it has been called before, it should return undefined without calling the original function again.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled =false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled=true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled =false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled=true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3927737,
                "title": "alternative-approach-using-a-ternary",
                "content": "# Intuition\\nI solved this first with the a separate `hasBeenCalled` variable. In that solution I was already declaring `result` which also gets changed, so I worked out a solution relies on this change instead.\\n\\n# Approach\\nSince `result` is already declared, we set its value to null (to avoid any issues with `fn()` returning a falsy value). Then we use a ternary to reassign `result` if it\\'s not still `null`.\\n\\n# Complexity\\n- Time complexity: Constant\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let result = null;\\n    \\n    return (...args) => {\\n        result = result === null ? fn(...args) : undefined;\\n        \\n        return result;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let result = null;\\n    \\n    return (...args) => {\\n        result = result === null ? fn(...args) : undefined;\\n        \\n        return result;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925559,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let usedOnce = false;\\n    let result;\\n\\n    return function (...args) {\\n        if (!usedOnce) {\\n            result = fn(...args);\\n            usedOnce = true;\\n            return result;\\n        }\\n        return undefined;\\n    };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let usedOnce = false;\\n    let result;\\n\\n    return function (...args) {\\n        if (!usedOnce) {\\n            result = fn(...args);\\n            usedOnce = true;\\n            return result;\\n        }\\n        return undefined;\\n    };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924468,
                "title": "typescript-my-solution",
                "content": "# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let wasCalled = false;    \\n  return function (...args) {\\n      return wasCalled ? undefined : (wasCalled = true) && fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let wasCalled = false;    \\n  return function (...args) {\\n      return wasCalled ? undefined : (wasCalled = true) && fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923735,
                "title": "simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: *```O()```* -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    \\n    let callStatus = false;\\n\\n    return function(...args){\\n    \\n        if(callStatus)\\n            return undefined;\\n    \\n        let result = fn(...args);\\n        callStatus = true;\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```O()```\n```\\nvar once = function(fn) {\\n    \\n    let callStatus = false;\\n\\n    return function(...args){\\n    \\n        if(callStatus)\\n            return undefined;\\n    \\n        let result = fn(...args);\\n        callStatus = true;\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916412,
                "title": "easy-javascript-solution",
                "content": "> Vote Up if You Like it\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called=true;\\n    return function(...args){\\n        let value=fn(...args)\\n        if(called){\\n           called=false\\n           return value\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called=true;\\n    return function(...args){\\n        let value=fn(...args)\\n        if(called){\\n           called=false\\n           return value\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914774,
                "title": "js-solution-with-explanation",
                "content": "# Approach\\nWhat we have to do here is that, we have to return the result of fn if once is called atmost 1 time else we return undefined.\\n\\n- So, to keep track of calling we keep a boolean variable HasBeenCalled initially to true.\\n- and for the first time it will enter the fn function and return the result and also set HasBeenCalled to true.\\n- What happens now is that if fn function is called directly then, it will check if !hasbeencalled which will result in false and the undefined will be returned. \\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) =>{\\n    let HasbeenCalled = false;\\n    let  result;\\n\\n    return (...args) =>{\\n      if(!HasbeenCalled){\\n        result = fn(...args)\\n        HasbeenCalled = true;\\n        return result;\\n      }\\n      else{\\n        return undefined;\\n      }\\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) =>{\\n    let HasbeenCalled = false;\\n    let  result;\\n\\n    return (...args) =>{\\n      if(!HasbeenCalled){\\n        result = fn(...args)\\n        HasbeenCalled = true;\\n        return result;\\n      }\\n      else{\\n        return undefined;\\n      }\\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914293,
                "title": "easiest-way-javascript-closure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = false;\\n    return function(...args){\\n        if(call) return;\\n        call = true;\\n        return fn(...args);\\n    }\\n};\\n\\n\\nlet fn = (a,b,c) => (a + b + c)\\nlet onceFn = once(fn)\\n\\nonceFn(1,2,3); // 6\\nonceFn(2,3,6); // returns undefined without calling fn\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = false;\\n    return function(...args){\\n        if(call) return;\\n        call = true;\\n        return fn(...args);\\n    }\\n};\\n\\n\\nlet fn = (a,b,c) => (a + b + c)\\nlet onceFn = once(fn)\\n\\nonceFn(1,2,3); // 6\\nonceFn(2,3,6); // returns undefined without calling fn\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3912370,
                "title": "js-solution",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n    let beenCalled = false\\n    let result\\n    return function(...args){\\n        if (!beenCalled) {\\n            result = fn(...args)\\n            beenCalled = true\\n            return result\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let beenCalled = false\\n    let result\\n    return function(...args){\\n        if (!beenCalled) {\\n            result = fn(...args)\\n            beenCalled = true\\n            return result\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908795,
                "title": "easy-peasy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn){\\n    var c = true;\\n    return (...args) =>  c ? (()=>{ c = !c ; return fn(...args) })()  : undefined\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn){\\n    var c = true;\\n    return (...args) =>  c ? (()=>{ c = !c ; return fn(...args) })()  : undefined\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907216,
                "title": "simple-solution",
                "content": "\\n```\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        if(++cnt > 1) return undefined;\\n        return fn(...args)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        if(++cnt > 1) return undefined;\\n        return fn(...args)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906380,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args)=>{\\n        if(called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args)=>{\\n        if(called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899310,
                "title": "beginner-friendly-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe must have a boolean trigger to prevent function from running twice or more. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this solution this boolean value represented by `let onced`\\nThen we check condition and if fuction hasn\\'t ran before we set `onced` to `true` return input fn with its `...args`. Otherwise we return `undefined`\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let onced = false\\n    return function(...args){\\n        if(!onced){\\n            onced = true\\n            return fn(...args)\\n        }else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let onced = false\\n    return function(...args){\\n        if(!onced){\\n            onced = true\\n            return fn(...args)\\n        }else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897336,
                "title": "simple-two-line-solution-javascript-using-boolean-variable",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialised a boolean variable , for checking the data as if it is  called at least once.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if (!isCalled) {\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if (!isCalled) {\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892509,
                "title": "beats-98-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 40ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 41.2mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892035,
                "title": "js-solution-runtime-48-ms-beats-91-2-memory-41-7-mb-beats-66-11",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n\\nvar once = function(fn) {\\n    this.isCalled = false;\\n    return function(...args){\\n        if(this.isCalled )return ;\\n        this.isCalled = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n\\nvar once = function(fn) {\\n    this.isCalled = false;\\n    return function(...args){\\n        if(this.isCalled )return ;\\n        this.isCalled = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888922,
                "title": "single-invocation-enforcer-for-javascript-functions",
                "content": "# Intuition and Approach:\\nThe intuition behind the solution is to use closure and a flag to keep track of whether the original function has been called before. The approach involves creating a new function that checks this flag. If the original function hasn\\'t been called before, it invokes the original function with the provided arguments and returns the result. Subsequent calls return undefined, ensuring that the original function is executed only once.\\n\\n# Time Complexity:\\nThe time complexity of the once function is constant (O(1)) for each call, regardless of the original function\\'s complexity. The main operation is checking the hasBeenCalled flag and invoking the original function if necessary.\\n\\n# Space Complexity:\\nThe space complexity is influenced by the closure created by the returned function and the storage of the hasBeenCalled flag and result. This takes up constant space (O(1)) for each invocation.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let Hascalled=false;\\n    let result;\\n    return function(...args){\\n        if(!Hascalled){\\n            result=fn(...args);\\n            Hascalled = true;\\n            return result;\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n\\n```\\nThe once function is designed to wrap an original function and ensure it\\'s called at most once. It achieves this by creating a new function that keeps track of whether the original function has been invoked. The solution has a constant time and space complexity and enhances control over function invocations.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let Hascalled=false;\\n    let result;\\n    return function(...args){\\n        if(!Hascalled){\\n            result=fn(...args);\\n            Hascalled = true;\\n            return result;\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888089,
                "title": "simple-solution",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    was_executed = false\\n    return function(...args){\\n        if (!was_executed){\\n            was_executed = true\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    was_executed = false\\n    return function(...args){\\n        if (!was_executed){\\n            was_executed = true\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3887719,
                "title": "allow-one-function-call",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var called = false; \\n    return function(...args){\\n        if(!called){\\n        //return args.reduce(fn);\\n        called = true;\\n        return fn(...args);\\n        }\\n    } \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var called = false; \\n    return function(...args){\\n        if(!called){\\n        //return args.reduce(fn);\\n        called = true;\\n        return fn(...args);\\n        }\\n    } \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879026,
                "title": "top-1-answer",
                "content": "# Intuition\\nFirst is done. When it is called, it triggered a flag and done. then just pass the function and array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have to handle the done variable. I don\\'t use boolean but use integer as boolean variable. So, I can omit update statement of done.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let done = 0\\n    return function(...args){\\n        return (done++)? undefined: fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let done = 0\\n    return function(...args){\\n        return (done++)? undefined: fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878454,
                "title": "easy-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = 0;\\n\\n    return function(...args){\\n        if(call>0)\\n            return undefined;\\n        call += 1 ; \\n        let ans = fn(...args);\\n        return ans;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = 0;\\n\\n    return function(...args){\\n        if(call>0)\\n            return undefined;\\n        call += 1 ; \\n        let ans = fn(...args);\\n        return ans;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3868848,
                "title": "3-lines-of-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let count = 0;\\n    return function (...args) {\\n        count++;\\n        return count === 1 ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let count = 0;\\n    return function (...args) {\\n        count++;\\n        return count === 1 ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864483,
                "title": "easy-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n  \\nvar once = function(fn) {\\n\\n    return function(...args){\\n\\n            var k = fn(...args)\\n           if(k[\"calls\"]==1){\\n               return k\\n           }\\n            \\n     \\n      \\n     \\n        \\n    }\\n}\\n\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n  \\nvar once = function(fn) {\\n\\n    return function(...args){\\n\\n            var k = fn(...args)\\n           if(k[\"calls\"]==1){\\n               return k\\n           }\\n            \\n     \\n      \\n     \\n        \\n    }\\n}\\n\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861979,
                "title": "intuitive-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Closure to track the number of functions calls\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUtilize Closure to keep track of how many times fn has been called, return undefined after the first call\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnCalls = 0;\\n    \\n    return function(...args){\\n        if(fnCalls < 1){\\n            fnCalls++\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnCalls = 0;\\n    \\n    return function(...args){\\n        if(fnCalls < 1){\\n            fnCalls++\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855225,
                "title": "simple-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n        if(counter == 0){\\n            counter =1;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n        if(counter == 0){\\n            counter =1;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854212,
                "title": "simpler-js-code-with-o-1-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    x = 0\\n    return function(...args){\\n        if(x == 0){x++; return fn(...args)}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    x = 0\\n    return function(...args){\\n        if(x == 0){x++; return fn(...args)}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854062,
                "title": "1-line-simple-solution-with-minimal-code-unique-approach",
                "content": "# Intuition\\nThese approach emphasizes achieving performance with minimal code.\\n\\n1. Use of **Arrow functions** to reduce the code.\\n2. Utilization of **ternary operator and parentheses** to simplify the code.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args) => \\n        (called == true) ? undefined : ((called = true), (fn(...args)));\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args) => \\n        (called == true) ? undefined : ((called = true), (fn(...args)));\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851517,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let func_called = true;\\n\\n    return function(...args){\\n        if(func_called){\\n            func_called = false;\\n            return fn(...args);\\n        }    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let func_called = true;\\n\\n    return function(...args){\\n        if(func_called){\\n            func_called = false;\\n            return fn(...args);\\n        }    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850182,
                "title": "very-easy-short-solution-javascript",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n\\n    let cont = 0;\\n\\n    return function(...args){\\n\\n        return cont !== 0 ? undefined : (cont++, fn(...args));\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n\\n    let cont = 0;\\n\\n    return function(...args){\\n\\n        return cont !== 0 ? undefined : (cont++, fn(...args));\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847941,
                "title": "runtime-beats-75-01-memory-beats-91-04",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let iscalled=false;\\n    \\n    return function(...args){\\n        if(!iscalled){\\n            iscalled=true;\\n            return fn(...args);\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let iscalled=false;\\n    \\n    return function(...args){\\n        if(!iscalled){\\n            iscalled=true;\\n            return fn(...args);\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845396,
                "title": "simple-js-solution",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (called) return undefined;\\n      called = true;\\n      return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (called) return undefined;\\n      called = true;\\n      return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3843912,
                "title": "typescript-based",
                "content": "```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n  let called: boolean = false;\\n  return function (...args) {\\n    if (called) return undefined;\\n    called = true;\\n    return fn.apply(this,args);\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n  let called: boolean = false;\\n  return function (...args) {\\n    if (called) return undefined;\\n    called = true;\\n    return fn.apply(this,args);\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3838780,
                "title": "use-boolearn-internal-to-solve-this-question",
                "content": "# Intuition\\nJust use an internal boolean to test whether it\\'s been called or not.\\nIf not once, one can define a counter to check how many times `fn` can be called.\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let called = false;\\n  return function (...args) {\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let called = false;\\n  return function (...args) {\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837534,
                "title": "day3-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n        if(c==0){\\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n        if(c==0){\\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836632,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = \\'a\\'\\n    return function(...args){\\n        if(limiter == \\'a\\'){\\n            limiter = \\'b\\'\\n            return fn(...args)\\n        }\\n        else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = \\'a\\'\\n    return function(...args){\\n        if(limiter == \\'a\\'){\\n            limiter = \\'b\\'\\n            return fn(...args)\\n        }\\n        else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836615,
                "title": "concise-fast-memory-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith the fact that booleans are only two bytes as compared to 4 for ints, setting a simple \"counter\" with bool not only faster but saves memory\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = false\\n    return function(...args){\\n      return (!limiter++) ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = false\\n    return function(...args){\\n      return (!limiter++) ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831581,
                "title": "fast-js-w-o-booleans",
                "content": "# Code\\n```\\nlet once = (fn) => {\\n    return (...args) => { \\n        let x = fn(...args);\\n        fn = () => {};\\n        return x;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet once = (fn) => {\\n    return (...args) => { \\n        let x = fn(...args);\\n        fn = () => {};\\n        return x;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831572,
                "title": "2666-allow-one-function-call-top-96",
                "content": "# Intuition\\nThe goal of this problem is to create a new function that behaves exactly like the original function fn, but it should only execute fn once and return the result on the first call. All subsequent calls to the new function should return undefined.\\n\\n# Approach\\nWe can use a closure to keep track of whether fn has been called before. By using a single variable to store the result of the first call, we can easily determine if the function has already been executed. If it has, we return undefined, otherwise, we call fn and store the result for future reference.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the once function is O(1) because it only performs a constant number of operations, regardless of the number of times the returned function is called.\\n\\n- Space complexity:\\nThe space complexity of the once function is also O(1) because it uses a fixed amount of memory to store the result and whether fn has been called before. The size of the input does not affect the space complexity.\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let result;\\n\\n    return function(...args) {\\n        if (typeof result === \\'undefined\\') {\\n            result = fn(...args);\\n            return result;\\n        } else {\\n            return undefined;\\n        }\\n    };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let result;\\n\\n    return function(...args) {\\n        if (typeof result === \\'undefined\\') {\\n            result = fn(...args);\\n            return result;\\n        } else {\\n            return undefined;\\n        }\\n    };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831099,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  return function (...args) {\\n    if (fn) {\\n      let f = fn;\\n      fn = undefined;\\n      return f(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  return function (...args) {\\n    if (fn) {\\n      let f = fn;\\n      fn = undefined;\\n      return f(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819719,
                "title": "beginner-s-attempt-at-a-beginners-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially I figured the simplest way would be to implement some sort of counter variable that would keep track of how many times fn was called.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI initialized the counter variable outside of the return function so that it would not be overwritten.\\n`var counter = 0;`\\n\\nAfter learning that \"...args\" is called a **spread** I was able to understand that \"...args\" is essentially just passing the arguments from \"fn\" to this return function.\\n\\nI then implemented a loop to check if counter is greater than 0. If so it returns \"undefined\". It is important to ensure that you increment counter by 1 each time the function is called.\\n```\\nif (counter > 0) {\\n    return undefined;\\n}\\n\\ncounter++;\\n```\\nAt this stage I ran into a wall with trying to simply input the \"args\" array of values into the fn. This wasn\\'t working but after looking in the Function documents for JavaScript I found a prototype called \"apply\" which is similar to \"call()\" but you are able to pass in an array of values.\\n\\nThe main difference between call() and apply is that call() typically only handles lists of elements like:\\n\\n```\\nfn.call(this, \"value0\", \"value1\", \"value2\", \"...\")\\n\\nconst exampleArray = [\"value0\", \"value1\", \"value2\",\"...\"]\\n\\nfn.apply(this, exampleArray)\\n```\\nWith apply you are also able to call an arbitrary value for the \"this\" if you are calling an existing function:\\n```\\nfn.apply(null, exampleArray)\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) -> Since we are going through each function 1 at a time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    var counter = 0;\\n    \\n    return function(...args){\\n\\n        if (counter > 0) {\\n            return undefined;\\n        }\\n\\n        counter++;\\n\\n        let value = fn.apply(null, args);\\n\\n        return value;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nif (counter > 0) {\\n    return undefined;\\n}\\n\\ncounter++;\\n```\n```\\nfn.call(this, \"value0\", \"value1\", \"value2\", \"...\")\\n\\nconst exampleArray = [\"value0\", \"value1\", \"value2\",\"...\"]\\n\\nfn.apply(this, exampleArray)\\n```\n```\\nfn.apply(null, exampleArray)\\n```\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    var counter = 0;\\n    \\n    return function(...args){\\n\\n        if (counter > 0) {\\n            return undefined;\\n        }\\n\\n        counter++;\\n\\n        let value = fn.apply(null, args);\\n\\n        return value;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818939,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function (fn) {\\n    var first_call = true;\\n    return function (...args) {\\n        if (first_call) {\\n            first_call = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function (fn) {\\n    var first_call = true;\\n    return function (...args) {\\n        if (first_call) {\\n            first_call = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815584,
                "title": "just-use-a-boolean-switch",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    <!-- boolean switch -->\\n    let once = true;\\n\\n    return function(...args){        \\n        if(once){\\n            once = false\\n            return fn(...args)\\n        }\\n        return\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    <!-- boolean switch -->\\n    let once = true;\\n\\n    return function(...args){        \\n        if(once){\\n            once = false\\n            return fn(...args)\\n        }\\n        return\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813299,
                "title": "line-by-line-beat-80-90-in-terms-of-time-memory",
                "content": "# Intuition\\nFirst, we have to understand the question thoroughly. It is a skill of its own.\\n\\n1. From the code template: `var once = function(fn){...}` we can derive 2 things:\\n    i. There is a function called `once` with a parameter that is another function. The parameter takes on an argument called `fn`.\\n    ii. Since `once` is a function and can take another function `fn` as an argument, we can conclude that `once` is a higher-order function.\\n\\n2. From the code template: `return function(...args){...}` we can confirm 1 thing:\\n    i. `once` is indeed a higher-order function since it is a function that returns another function.\\n\\n3. `fn` is a function that takes on a parameter of arrays. The arguments have been left as `...args`.\\n\\n**What the question wants**\\n- When `once(fn)` is called, return `fn(...args)` as is.\\n- If `once(fn)` is called for the >1th time, return the value `undefined`.\\n\\n# Approach\\nThere are multiple approaches to this question. I prefer doing each step one at a time.\\n\\n**When `once(fn)` is called, return `fn(...args)` as is:**\\n\\n`return function(...args) {`\\n(when `once(fn)` is called with `...args`...)\\n`result = fn(...args);` \\n(run `fn(...args)` and save the output as a variable called `result`)\\n`return result; }`\\n(return the output stored as `result`)\\n\\nThe first step is now done.\\n\\n**If `once(fn)` is called for the >1th time, return the value `undefined`**\\n\\n`let called = false;`\\n(use a variable called `called` to check if `once(fn)` has been called before)\\n`let result;`\\n(create a variable called `result` which has no value at first, giving an output of `undefined`)\\n\\n`if(called===false){`\\n(if the variable `called` has a value of `false`, run the next lines of code)\\n`called = true;`\\n(change the value of `called` to `true`)\\n\\nNow, the second step is done.\\n\\nI was not able to explain where each line of code should go into. Please check my code solution below to decipher that on your own.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    let result;\\n\\n    return function(...args){\\n        if (called == false) {\\n            called = true;\\n            result = fn(...args);\\n            return result;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    let result;\\n\\n    return function(...args){\\n        if (called == false) {\\n            called = true;\\n            result = fn(...args);\\n            return result;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810623,
                "title": "limiter-function",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0\\n    return function(...args){\\n        if(calls<=0){\\n            calls++\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0\\n    return function(...args){\\n        if(calls<=0){\\n            calls++\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806322,
                "title": "javascript-o-1-solution",
                "content": "# Intuition\\nFlag based approach, early exit if already executed\\n\\n# Approach\\n1. Take a flag and initialize it to false. \\n2. Write the trigger condition for it to be true inside the function capturing the inputs. \\n3. Now that trigger has been set, one line above it, handle the early exit condition for the function when flag value is \"true\"\\n4. Below the trigger, use apply method to pass the captured inputs to the input function.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let executed = false;\\n    return function(...args){\\n        if(executed) return;\\n        executed = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let executed = false;\\n    return function(...args){\\n        if(executed) return;\\n        executed = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805268,
                "title": "crisp-and-clear",
                "content": "\\n\\n# Code\\n```\\nconst once = (fn) => {\\n  let calls = 0\\n  return (...args) => {\\n    if (calls > 0) return \\n    ++calls\\n    return fn(...args.flat(Infinity))\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst once = (fn) => {\\n  let calls = 0\\n  return (...args) => {\\n    if (calls > 0) return \\n    ++calls\\n    return fn(...args.flat(Infinity))\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3800962,
                "title": "js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0;\\n    return function(...args){\\n        if (!calls) {\\n            calls++;\\n            return fn(...args)\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0;\\n    return function(...args){\\n        if (!calls) {\\n            calls++;\\n            return fn(...args)\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797338,
                "title": "call-only-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let count = 0\\n  \\n    return function (...args) {\\n        if(!(count > 0)){\\n            count++;\\n            return fn(...args);\\n        }   \\n    };\\n  \\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let count = 0\\n  \\n    return function (...args) {\\n        if(!(count > 0)){\\n            count++;\\n            return fn(...args);\\n        }   \\n    };\\n  \\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796932,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count =0;\\n    return function(...args){\\n       if(count<1){\\n        count++;\\n        return fn(...args)\\n       }else return undefined\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count =0;\\n    return function(...args){\\n       if(count<1){\\n        count++;\\n        return fn(...args)\\n       }else return undefined\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796631,
                "title": "allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n      let hasBeenCalled = 0;\\n   return function (...args) {\\n      hasBeenCalled ++;\\n   if(hasBeenCalled==1)\\n    {\\n    return fn(...args); \\n    } \\n    return undefined;\\n   }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n      let hasBeenCalled = 0;\\n   return function (...args) {\\n      hasBeenCalled ++;\\n   if(hasBeenCalled==1)\\n    {\\n    return fn(...args); \\n    } \\n    return undefined;\\n   }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794963,
                "title": "2666-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794962,
                "title": "2666-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794769,
                "title": "javascript-solution-and-order-of-execution",
                "content": "# Execution Order of Code\\nI found this super useful website that shows the order in which JavaScript code gets executed. It\\'s just for anyone who\\'s just starting out with JS like me. Here\\'s the link:  https://pythontutor.com/visualize.html#mode=edit\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\nlet times=[];\\n\\n\\n    return function(...args){\\n  \\n    times.push(1); \\n    if(times.length ===1){\\n        return (fn(...args))\\n        }else {\\n\\n    return undefined}\\n    \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\nlet times=[];\\n\\n\\n    return function(...args){\\n  \\n    times.push(1); \\n    if(times.length ===1){\\n        return (fn(...args))\\n        }else {\\n\\n    return undefined}\\n    \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3788847,
                "title": "using-if-statement",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought is clicked on my mind is we need to returns a new function but condition is it will call only once so setting counter to 0 and checking with condition if counter is 0 then increment by 1 and call the function if it will try to run on counter 2 return undefined because we cannot run twice.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconditional statement \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter = 0\\n    return function(...args){\\n        if(counter == 0){\\n            counter ++\\n            return fn(...args)\\n        }else{\\n        return undefined\\n        }\\n        \\n    }\\n\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter = 0\\n    return function(...args){\\n        if(counter == 0){\\n            counter ++\\n            return fn(...args)\\n        }else{\\n        return undefined\\n        }\\n        \\n    }\\n\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1890874,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1951035,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890911,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2017399,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890956,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2005696,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1965347,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891536,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891145,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890795,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890874,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1951035,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890911,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2017399,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890956,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2005696,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1965347,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891536,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891145,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890795,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            }
        ]
    },
    {
        "title": "Throttle",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1899833,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1899769,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1898831,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1899628,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1899533,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1900100,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1900088,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1899865,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1900012,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            }
        ]
    },
    {
        "title": "Immediate Food Delivery III",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1926748,
                "content": [
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT order_date,\\nROUND(AVG(order_date = customer_pref_delivery_date) * 100,2) AS immediate_percentage\\nFROM delivery\\nGROUP BY 1\\nORDER BY 1;"
                    }
                ]
            }
        ]
    },
    {
        "title": "Return Length of Arguments Passed",
        "question_content": "Write a function&nbsp;<code>argumentsLength</code> that returns the count of arguments passed to it.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> args = [5]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nargumentsLength(5); // 1\n\nOne value was passed to the function so it should return 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> args = [{}, null, &quot;3&quot;]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> \nargumentsLength({}, null, &quot;3&quot;); // 3\n\nThree values were passed to the function so it should return 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>args</code>&nbsp;is a valid JSON array</li>\n\t<li><code>0 &lt;= args.length &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3586843,
                "title": "learn-rest-parameter-argument-handling-in-function-1-line-easy-sol-in-js-ts",
                "content": "# Why rest parameter ?\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRest parameters in JavaScript allow us to represent an indefinite number of arguments as an array within a function. It enables us to handle multiple arguments without explicitly defining each one in the function signature. \\n\\nThe rest parameter is denoted by three dots (`...`) followed by a parameter name in a function declaration or function expression.\\n\\nlets understand with example where we have an array and we want to pass all its value to a function :-\\n\\n```\\nlet array = [1,2,3,4,5];\\n\\n// we expect argument to be passed in this way\\nfunction sum (a,b,c,d,e){\\n    console.log(a,b,c,d,e) // 1 2 3 4 5 \\n}\\n\\n// brute force method \\nsum(array[0],array[1],array[2],array[3],array[4]);\\n\\n// Problem :- we have to pass each value individually & \\n// if we have 1000 values in array then \\n// we have to pass 1000 arguments in function which is not feasible.\\n\\n\\n// using rest parameter we can pass all the values of array in one go\\nsum(...array); \\n\\n//rest parameter allows us to pass indefinite number of arguments as an array within a function.\\n\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we know `args` is an array of arguments passed to a function. We can use `args.length` to get the number of arguments passed to a function.\\n\\nhence we will return `args.length` to get the number of arguments passed to a function.\\n\\n# Complexity \\n- Time complexity: $$O(1)$$ \\n- Space complexity: $$O(1)$$\\n\\n<img src=\"https://assets.leetcode.com/users/images/b93dcc50-7e19-44d3-80ec-c41558d719ba_1684043630.2104852.png\" width=\"50%\">\\n\\n# Code\\n```javascript []\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\\n\\n```typescript []\\nfunction argumentsLength(...args: any[]): number {\\n  return args.length\\n};\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\nlet array = [1,2,3,4,5];\\n\\n// we expect argument to be passed in this way\\nfunction sum (a,b,c,d,e){\\n    console.log(a,b,c,d,e) // 1 2 3 4 5 \\n}\\n\\n// brute force method \\nsum(array[0],array[1],array[2],array[3],array[4]);\\n\\n// Problem :- we have to pass each value individually & \\n// if we have 1000 values in array then \\n// we have to pass 1000 arguments in function which is not feasible.\\n\\n\\n// using rest parameter we can pass all the values of array in one go\\nsum(...array); \\n\\n//rest parameter allows us to pass indefinite number of arguments as an array within a function.\\n\\n```\n```javascript []\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\n```typescript []\\nfunction argumentsLength(...args: any[]): number {\\n  return args.length\\n};\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567330,
                "title": "one-liner-full-simple-short-explanation",
                "content": "# Approach\\nIn JavaScript, arguments are passed as an array-like object. Because of this, you can use a lot of the same kind of functions on arguments as you can on arrays, including using ```args.length```.\\n\\nAnd so, in the same way you would find the number of elements in an array ```arr``` with ```arr.length```, you can find the number of arguments in ```args``` with ```args.length```.\\n\\n# Code\\n```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```args.length```\n```arr```\n```arr.length```\n```args```\n```args.length```\n```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567802,
                "title": "very-tough-ques",
                "content": "# Intuition\\n### you need to have a thorough understanding of nothing actually.\\n\\n\\n# Complexity\\n- Time complexity and Space complexity -> too complex, cant even tell you\\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568918,
                "title": "ok",
                "content": "```\\nvar argumentsLength = (...args) => args.length; \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvar argumentsLength = (...args) => args.length; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566162,
                "title": "simple-1-line",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023446,
                "title": "two-line-solution-using-javascript",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)Create array.\\n2)use spread operator to copy all arguments into array.\\n3)use length method to get the length of array and retrun it.\\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args]\\n let len=arr.length;\\n return len\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\\n### Please Upvote\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args]\\n let len=arr.length;\\n return len\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836496,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\n\\nfunction argumentsLength(){\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\n\\nfunction argumentsLength(){\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665162,
                "title": "just-1-line-code",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3658044,
                "title": "90-1-line-solution",
                "content": "# Intuition\\nWe can calculate total amount of arguments by comprising an array from args.\\n\\n# Approach\\nSpread all the arguments into an empty array, then count its length\\n\\n# Code\\n```\\nvar argumentsLength = function(...args) {\\n    return [...args].length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return [...args].length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3648775,
                "title": "oneliner-return-args-length",
                "content": "```\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567070,
                "title": "simple-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  let count = 0;\\n  for (let i = 0; i < args.length; i++) {\\n    if (args[i] !== undefined) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  let count = 0;\\n  for (let i = 0; i < args.length; i++) {\\n    if (args[i] !== undefined) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566898,
                "title": "javascript",
                "content": "\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983467,
                "title": "super-easy-52ms-beats-64-40mb-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst I was going to use the for loop but then I said why would\\'t I just use the length function , And that\\'s how I solved the problem\\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854288,
                "title": "return-length-of-arguments-passed-javascript-solution-code",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\nreturn args.length;\\n \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\nreturn args.length;\\n \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582473,
                "title": "ts-return-args-length-58ms-42-7mb",
                "content": "I guess LC really thinks that JS developers are a few notches less capable than all the rest, seeing problems like this or [hello world](https://leetcode.com/problems/create-hello-world-function/) ([cracked here](https://leetcode.com/problems/create-hello-world-function/solutions/3492572/ts-traditional-vs-arrow-function-with-differences-50ms-42-8mb/)).\\n\\nWell, guess what? We will just `return` the `.length` property on `args` and be done with the problem.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569813,
                "title": "best-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nfunction argumentsLength() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nfunction argumentsLength() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566246,
                "title": "2-simple-solutions",
                "content": "\\n# Length of `args`\\n\\n```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n```\\n\\n\\n# Length of [the arguments object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)\\n```\\nfunction argumentsLength(...args: any[]): number {\\n    return arguments.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n```\n```\\nfunction argumentsLength(...args: any[]): number {\\n    return arguments.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100670,
                "title": "return-length-of-arguments-passed-javascript-solution-by-bharadwaj",
                "content": "# Approach\\nFunctional Programming\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar argumentsLength = function(...args) {\\n   \\treturn args.length\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n   \\treturn args.length\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099715,
                "title": "one-of-the-easiest-problem-single-line-answer",
                "content": "# Intuition\\nJust return length of Args and done . \\uD83D\\uDD25 \\n\\n\\n# Code\\n```\\n\\nvar argumentsLength = function(...args) {\\n\\treturn args.length\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar argumentsLength = function(...args) {\\n\\treturn args.length\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096699,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction argumentsLength  () {\\n\\treturn arguments.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction argumentsLength  () {\\n\\treturn arguments.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092596,
                "title": "solution-with-arguments-lenght",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {...(null|boolean|number|string|Array|Object)} args\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\treturn args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {...(null|boolean|number|string|Array|Object)} args\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\treturn args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091643,
                "title": "javascript-function-for-determining-the-number-of-arguments-using-the-rest-parameter",
                "content": "# Intuition\\nThe intuition here is that by using the JavaScript rest parameter (...args), we can capture all the arguments passed to the function and then determine the number of arguments based on the length of the args array.\\n# Approach\\nDefine a function argumentsLength that uses the rest parameter ...args to collect all the arguments passed to it.\\nReturn the length of the args array, which represents the count of arguments.\\n\\n# Complexity\\nTime complexity: O(1)\\nThe length of the args array can be determined in constant time because it\\'s based on the number of arguments passed to the function.\\nSpace complexity: O(1)\\nThe args array doesn\\'t consume additional memory because it\\'s a reference to the arguments passed to the function, and its length property is used to determine the count.\\n\\n\\n# Code\\n```\\nfunction argumentsLength(...args) {\\n  return args.length;\\n}\\n// Example 1:\\nconst result1 = argumentsLength(5);\\nconsole.log(result1); // Output: 1\\n// Example 2:\\nconst result2 = argumentsLength({}, null, \"3\");\\nconsole.log(result2); // Output: 3\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction argumentsLength(...args) {\\n  return args.length;\\n}\\n// Example 1:\\nconst result1 = argumentsLength(5);\\nconsole.log(result1); // Output: 1\\n// Example 2:\\nconst result2 = argumentsLength({}, null, \"3\");\\nconsole.log(result2); // Output: 3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088434,
                "title": "100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088420,
                "title": "array-length",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084402,
                "title": "finally-a-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084275,
                "title": "simple-js-solution-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->using length\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n \\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n \\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080907,
                "title": "arguments-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbasic return array.length method\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nreturn the length of the array of arguments\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\\nanother solution for better runtime\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\n\\nvar argumentsLength = (...args) => args.length;\\n\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\n```\\n/**\\n * @return {number}\\n */\\n\\nvar argumentsLength = (...args) => args.length;\\n\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078266,
                "title": "javascript-array-length-41ms-beats-95-98-41-1mb-beats-98-64",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s a valid JSON Array, so I just get the length using Javascript Array.length and return it immediatly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt worked.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073128,
                "title": "first-win",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070176,
                "title": "object-arguments-o-1",
                "content": "# Intuition\\nUse the object arguments which in an object inside the function and contains the paramtters passed to the function\\n\\n# Complexity\\n- Time complexity:O(1)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070146,
                "title": "javascript-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var count = 0;\\n args.map(index=>{\\n        count++\\n })\\n return count\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var count = 0;\\n args.map(index=>{\\n        count++\\n })\\n return count\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068905,
                "title": "simple-one-line-solution",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return [...args].length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return [...args].length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066916,
                "title": "return-length-of-arguments-passed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062271,
                "title": "beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var result = 0;\\n    for (let arg of args){\\n        result += 1\\n    }\\n    return result;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var result = 0;\\n    for (let arg of args){\\n        result += 1\\n    }\\n    return result;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062025,
                "title": "return-length-of-the-argument",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    // let a = [...args];\\n    // let length = a.length;\\n    // return length;\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    // let a = [...args];\\n    // let length = a.length;\\n    // return length;\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059993,
                "title": "easy-peasy-solution",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059917,
                "title": "return-length-of-arguments-passed-with-one-line-solution-o-1",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$Big-O = O(1) - Constant$$\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nlet argumentsLength = function (...args) {\\n  return args.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nlet argumentsLength = function (...args) {\\n  return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056638,
                "title": "using-length-method",
                "content": "ribe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use  ```<array>.length``` method\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```<array>.length```\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050643,
                "title": "beginners-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args]\\n let argLength=arr.length;\\n return argLength;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args]\\n let argLength=arr.length;\\n return argLength;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049607,
                "title": "js-one-liner-very-easy-beginner-friendly",
                "content": "# Please Upvote Guys\\n```\\nreturn args.length;\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nreturn args.length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048347,
                "title": "js-ts-one-line-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\n\\nconst argumentsLength = (...args: JSONValue[]): number => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\n\\nconst argumentsLength = (...args: JSONValue[]): number => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047360,
                "title": "array-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thougth was to determine the length.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used array.length on the args to determine the length\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047058,
                "title": "1-line-solution-using-javascript",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045707,
                "title": "return-length-of-arguments-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let leng = args.length;\\n    return leng\\n};\\n\\nargumentsLength(1,2,3)\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let leng = args.length;\\n    return leng\\n};\\n\\nargumentsLength(1,2,3)\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045090,
                "title": "1-line-solution",
                "content": "# Easy way to solve\\n\\nIf we have ... in function argument - this is Rest Operator. Rest operator compact all arguments into array, so we can easy use length parametr of array \\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044985,
                "title": "return",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr = [...args]\\n let len = arr.length;\\n return len\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr = [...args]\\n let len = arr.length;\\n return len\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044106,
                "title": "1-line-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => [...args].length\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => [...args].length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043568,
                "title": "one-line-code-rohit-raj",
                "content": "# Intuition\\ncode in just one line....\\n\\n# Approach\\njust return arr length like arr i used args only .you can also use [...args].length\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041179,
                "title": "javascript-1-liner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040940,
                "title": "just-in-one-line",
                "content": "# Intuition\\nuse  array length function to tacle it \\n\\n# Approach\\nreturn array.length for this args.length()\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040482,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038641,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse the inbuilt .length method on the array and return it .\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let n= args.length;\\n return n;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let n= args.length;\\n return n;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038570,
                "title": "if-you-like-pls-upvote-it-for-any-doubt-feel-free-to-ask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\n    var i=0;\\n    args.forEach((st) => { \\n        console.log(st); i++;   })\\n     return i;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\n    var i=0;\\n    args.forEach((st) => { \\n        console.log(st); i++;   })\\n     return i;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036563,
                "title": "javascript-one-line",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nreturn the length of the array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function (...args) {\\n  return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function (...args) {\\n  return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036220,
                "title": "return-length-of-arguments-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035279,
                "title": "learn-array-destructuring",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args];\\n let length = arr.length;\\n return length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args];\\n let length = arr.length;\\n return length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035019,
                "title": "much-simplest-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n \\n let array=[...args]\\n return array.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n \\n let array=[...args]\\n return array.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034381,
                "title": "simple-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\n  \\nvar argumentsLength = function(...args) {\\n  var c=args.length;\\n  return c\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\n  \\nvar argumentsLength = function(...args) {\\n  var c=args.length;\\n  return c\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030760,
                "title": "neat-short-solution-with-explanation-es6",
                "content": "# Explanation\\n`...` in `...args` refers to rest paramters when used in parameters and returns an array of whatever arguments passed. Since, it\\'s an array, simply return the length.\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029744,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028166,
                "title": "single-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince```args```is an array you can access it\\'s```length```property.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply return the```length```property of```args```.\\n# Code\\n```\\nconst argumentsLength = (...args) => args.length\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```args```\n```length```\n```length```\n```args```\n```\\nconst argumentsLength = (...args) => args.length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021896,
                "title": "easy-one-line-solution",
                "content": "\\n\\n# Approach\\nwe know that when we want to get all the arguments we use ...args that is the rest operator which give us all the arguments in form of an array,\\nnow to get the count of arguments simple get the length or args array\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n         return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n         return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021127,
                "title": "length-of-arguments-passed-to-any-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018364,
                "title": "easy-one-line-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015877,
                "title": "extremely-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust add a return with the array.length\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015477,
                "title": "easy-to-understand-quick-solution",
                "content": "# Intuition\\nUsing the arguments object we do not have to reassign or use any other object to access the length of the arguments passed.\\n\\n# Approach\\nUse the arguments object with the length accessor to provide yourself with the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013764,
                "title": "code-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  let count = 0;\\n  for (let i = 0; i < args.length; i++){\\n    count++\\n  }\\n  return count\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  let count = 0;\\n  for (let i = 0; i < args.length; i++){\\n    count++\\n  }\\n  return count\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013339,
                "title": "simple-javascript-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011923,
                "title": "one-line-solution-return-length-of-arguments-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nargu By argu\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007096,
                "title": "o-1-javascript-solution-one-liner",
                "content": "# Approach\\nIn JavaScript, arguments are passed as an array-like object. Because of this, you can use a lot of the same kind of functions on arguments as you can on arrays, including using args.length.\\n\\nAnd so, in the same way you would find the number of elements in an array arr with arr.length, you can find the number of arguments in args with args.length.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002681,
                "title": "easy-way-of-the-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust one line code you should only return arguments.length. That\\'s all.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001698,
                "title": "find-the-length-of-the-arguments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000016,
                "title": "one-line-javascript-solution",
                "content": "# JavaScript Solution\\n\\n\\n\\n# Code\\n```\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n```\\n\\n\"*return args.length*\" returns the length of the args array, which is equivalent to the number of arguments passed to the function.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997851,
                "title": "javascript-easy-simple-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n<!-- upvote if it helps -->\\n\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n<!-- upvote if it helps -->\\n\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997276,
                "title": "my-first-easy-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var len = parseInt(args.length)\\n    return len;\\n \\n};\\n\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var len = parseInt(args.length)\\n    return len;\\n \\n};\\n\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991655,
                "title": "obvious-answer-js",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3986707,
                "title": "shortest-javascript-solutions",
                "content": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985875,
                "title": "one-line-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984653,
                "title": "okay",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964213,
                "title": "js-two-solutions-with-explanation",
                "content": "1) **arguments** is an array-like object accessible inside functions that contains the values of the arguments passed to that function;\\n\\n# Code\\n```\\n\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n```\\n2) the **rest parameter** syntax allows a function to accept an indefinite number of arguments *as an array*;\\n\\n# Code\\n```\\n\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n```\n```\\n\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963225,
                "title": "rest-arguments-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n...args is a rest arguments and its an array. So we can use array length property to get the size of the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962951,
                "title": "easy-and-efficiant-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- 0(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n     var n=args.length;\\n     return n;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n     var n=args.length;\\n     return n;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3956453,
                "title": "simplest-solution",
                "content": "# Intuition\\nProbably the easiest problem in entirety of Leetcode\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954586,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar argumentsLength = function(...args) {\\n      return args.length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n      return args.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954065,
                "title": "javascript-solution",
                "content": "# Factors\\n- Runtime\\n50ms\\n\\n- Memory\\n41.10MB\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952328,
                "title": "way-too-easy",
                "content": "# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3950869,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949832,
                "title": "javascript-oneliner-o-1",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947875,
                "title": "simple-one-liner-with-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith the help of spread operator we can easily we can easily do it.\\nwe just have to return the length of spread operator.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947409,
                "title": "return-length-of-arguments-passed-javascript-solution-code",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943188,
                "title": "2-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 62 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n const p = Array.from(args);\\n return p.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n const p = Array.from(args);\\n return p.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931856,
                "title": "return-length-of-arguments-passed-easy-solution",
                "content": "# Rest Parameters\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe rest parameter syntax allows a function to accept an indefinite number of arguments as an array, providing a way to represent variadic functions in JavaScript.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we know args is an array of arguments passed to a function. We can use args.length to get the number of arguments passed to a function.\\n\\nhence we will return args.length to get the number of arguments passed to a function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n      return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n      return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931027,
                "title": "1-line-solution",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930392,
                "title": "return-length-js-three-solutions",
                "content": "1. Intuitive Solution \\n```\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n```\\n2. Use variable arguments to access arguments of function\\n```\\nvar argumentsLength = function(...args) {\\n    count = 0\\n\\n    for (i = 0; i < arguments.length; i++) {\\n        count ++\\n        // arguments[i] - contain argument value\\n    }\\n\\n    return count\\n};\\n```\\n3. Reduce\\n```\\nvar argumentsLength = (...args) => args.reduce(sum => sum + 1, 0)\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n```\n```\\nvar argumentsLength = function(...args) {\\n    count = 0\\n\\n    for (i = 0; i < arguments.length; i++) {\\n        count ++\\n        // arguments[i] - contain argument value\\n    }\\n\\n    return count\\n};\\n```\n```\\nvar argumentsLength = (...args) => args.reduce(sum => sum + 1, 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929977,
                "title": "typescript-simple-approach",
                "content": "# Complexity\\n- Time complexity: $O(1)$\\n- Space complexity: $O(1)$\\n\\n\\n# Code\\n```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3928477,
                "title": "the-trick-is-in-the-length",
                "content": "# Intuition\\nWhen length was mentioned I already had in mind that I had to pass in the argumenta and apply the length method to it.\\n\\nI than returned it as a function.\\n\\n# Code\\n```\\n\\nvar argumentsLength = function(...args) {\\n \\n return args.length;\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar argumentsLength = function(...args) {\\n \\n return args.length;\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923625,
                "title": "single-line-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *```O(1)```*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar argumentsLength = (...args) => args.length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```O(1)```\n```\\nvar argumentsLength = (...args) => args.length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921483,
                "title": "javascript-args-length",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919560,
                "title": "simple-two-line-submit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let count=0;\\n   for(let i=0;i<args.length;i++){\\n      count++;\\n   }\\n   return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let count=0;\\n   for(let i=0;i<args.length;i++){\\n      count++;\\n   }\\n   return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917603,
                "title": "easiest-single-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\nreturn args.length;\\n};\\n\\n\\n  argumentsLength(1, 2, 3); // 3\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\nreturn args.length;\\n};\\n\\n\\n  argumentsLength(1, 2, 3); // 3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916616,
                "title": "easy-javascript-solution-one-line-code",
                "content": "> vote up if you like it\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915136,
                "title": "simple-1-line-solution",
                "content": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914241,
                "title": "typescript-solution-one-liner",
                "content": "```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914121,
                "title": "easiest-way-and-shortest-way-return-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913935,
                "title": "with-one-line-solution",
                "content": "# Intuition\\nthe input can be a number ,array etc. So the important thing for us the length of the input . And as we think the input is \"args\" the func will be like this.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911526,
                "title": "argument-length",
                "content": "```\\nargument is a simple HTML collection of arguments passed to \\nvar argumentsLength = function(...args) {\\n    \\n    return arguments.length;\\n }\\n```",
                "solutionTags": [],
                "code": "```\\nargument is a simple HTML collection of arguments passed to \\nvar argumentsLength = function(...args) {\\n    \\n    return arguments.length;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908453,
                "title": "simple-solution-of-return-length-of-arguments-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907240,
                "title": "javascript-have-method-for-same",
                "content": "# Intuition\\n\\nBasic array length method\\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\n var argsArr = [5];\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n\\nargumentsLength(1, 2, 3); // 3\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\n var argsArr = [5];\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n\\nargumentsLength(1, 2, 3); // 3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906326,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n        return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n        return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905189,
                "title": "easy-fast-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905090,
                "title": "javascript-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3902850,
                "title": "easy",
                "content": "\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894157,
                "title": "1-line-solution",
                "content": "# Intuition\\nAll we have to do is return the length of the argument which is \"...args\"\\n\\n# Approach\\nBy using .length we can easily achieve this. Just return the array.length.\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891752,
                "title": "js-solution-runtime-43-ms-beats-97-63-memory-42-2-mb-beats-15-8",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n* @return {number}\\n*/\\nvar argumentsLength = function(...args) {\\n    return args.length ;\\n};\\n\\n/**\\n* argumentsLength(1, 2, 3); // 3\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n* @return {number}\\n*/\\nvar argumentsLength = function(...args) {\\n    return args.length ;\\n};\\n\\n/**\\n* argumentsLength(1, 2, 3); // 3\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888674,
                "title": "i-though-this-was-going-to-be-more-complicated-than-return-args-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3887668,
                "title": "return-length-of-arguments-passed",
                "content": "Return Length of Arguments Passed\\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3887125,
                "title": "very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885299,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3884094,
                "title": "runtime-details-43ms-beats-97-71-args-length-not-used-simple-method-javascript",
                "content": "# Intuition\\nLets not directly try to use length which might not be the best testing of concepts. \\nIf the array arguments are undefined we can just travel with a count variable and it will automatically  increase the count unless it finds undefined in array and simply return the count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let count = 0 ;\\n    if(args == null ) return count;\\n    while(args[count] !== undefined)\\n        count++;\\n    \\n \\n return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let count = 0 ;\\n    if(args == null ) return count;\\n    while(args[count] !== undefined)\\n        count++;\\n    \\n \\n return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3883442,
                "title": "easy-code-for-this-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Rest operator concept is used here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs rest operator collects individual elements and groups them into a array and return the array. we need to just print the array length.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\nreturn args.length;\\n\\n\\n};\\n\\n\\n argumentsLength(1, 2, 3); // 3\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\nreturn args.length;\\n\\n\\n};\\n\\n\\n argumentsLength(1, 2, 3); // 3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879016,
                "title": "simple-solution-one-liner",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return [...args].length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return [...args].length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878368,
                "title": "easiest-solution-possible-on-internet",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) // N => Number of arguments\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n const arr = [...args];\\n return arr.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n const arr = [...args];\\n return arr.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3877090,
                "title": "one-line-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876149,
                "title": "accepted-javascript",
                "content": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3874721,
                "title": "1-line-code-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We have to find number of arguments passed to that function(argumentsLength).\\nargumentsLength(1, 2, 3); // 3\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have argumenst.length statement to return number of arguments passed to a function.\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We have to find number of arguments passed to that function(argumentsLength).\\nargumentsLength(1, 2, 3); // 3\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have argumenst.length statement to return number of arguments passed to a function.\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3873740,
                "title": "javascript-solution",
                "content": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872797,
                "title": "js-one-liner-the-wrong-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.reduce((acc,args,i)=>acc+1,0)\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.reduce((acc,args,i)=>acc+1,0)\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872690,
                "title": "easiest-solution-js",
                "content": "# Approach\\nArgs has the list of all Arguments so return its length.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871260,
                "title": "1-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function (...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function (...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3858634,
                "title": "without-using-array-length-or-for-foreach-loop-using-array-reduce-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every element int the array reduce the arraysize and increase the number of elements.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPassing 0 as initial value for count, which will be used as return value and initial value for next iteration.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    // return args.length;\\n    /*let count = 0;\\n    args.forEach(()=>count++);\\n    return count;*/\\n    return args.reduce((count, el) => ++count, 0);\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    // return args.length;\\n    /*let count = 0;\\n    args.forEach(()=>count++);\\n    return count;*/\\n    return args.reduce((count, el) => ++count, 0);\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857600,
                "title": "simple-js-using-arrow-function",
                "content": "# Intuition\\n- The code uses the rest parameter to collect all function arguments into an array.\\n\\n# Approach\\n- By using the rest parameter, the code gathers all arguments in the args array.\\n- It then returns the length of the args array, which represents the number of arguments passed.\\n\\n\\n# Complexity\\n- Time complexity: O(1) - Constant time complexity, as it directly returns the length of the array.\\n\\n- Space complexity: O(n) - Linear space complexity, where n is the number of function arguments. The rest parameter creates an array with all the arguments.\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args )=> args.length;\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args )=> args.length;\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857351,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855133,
                "title": "1st",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854883,
                "title": "runtime-40ms-beats-99-44",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854689,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   let count = 0;\\n   return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   let count = 0;\\n   return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854003,
                "title": "1-line-simple-solution",
                "content": "# Intuition\\nThese approach emphasizes achieving performance with minimal code.\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853706,
                "title": "solved",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nfunction argumentsLength() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nfunction argumentsLength() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853247,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust return length of the given array\\n\\n# Complexity\\n- Time complexity:\\n- O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3844990,
                "title": "avoiding-the-native-and-obvious-one-liner",
                "content": "# Intuition\\nAvoid the obvious \"One liner\" using for-loop and verifying if next argument in the array is available\\n\\n# Approach\\nCounting using for loop and avoid when not needed\\n\\n# Complexity\\n- Time complexity:\\n38ms\\n\\n- Space complexity:\\n41.50mb\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    if (args[0] === undefined) return 0;\\n\\n    let index = -1;\\n    while (args[index + 1] !== undefined) {\\n        index++;\\n    }\\n\\n    return index + 1;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    if (args[0] === undefined) return 0;\\n\\n    let index = -1;\\n    while (args[index + 1] !== undefined) {\\n        index++;\\n    }\\n\\n    return index + 1;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3844304,
                "title": "using-special-argument-variable-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe \"**arguments.length**\" data property contains the number of arguments passed to the function.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3842222,
                "title": "simple-js-1-line-solution",
                "content": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3839065,
                "title": "seriously-1-line-easy-task",
                "content": "\\n```\\nconst argumentsLength = (...args) => args.length;\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\nconst argumentsLength = (...args) => args.length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837524,
                "title": "day3-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833708,
                "title": "args-is-an-array",
                "content": "# Intuition\\nwell to solve this problem u have to know only one thing which is ...args is an array parameter that is used when u dont know the the number of passed arguments\\n# Approach\\nwe r going to use the .length method to determine the length of an array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833038,
                "title": "length-of-argument-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830892,
                "title": "javascript-fast-execution",
                "content": "# Runtime\\n39ms\\nBeats 99.79%of users with JavaScript\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3828397,
                "title": "one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827375,
                "title": "length-of-array-beginner-friendly-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->check what the question is asking about\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will make a variable let n= args.length and then we will return it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let n = args.length;\\n    \\n     \\n         return n;\\n     \\n\\n\\n\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let n = args.length;\\n    \\n     \\n         return n;\\n     \\n\\n\\n\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3824514,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821642,
                "title": "literal-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst argumentsLength = (...args) => args.length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst argumentsLength = (...args) => args.length;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1977171,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1907883,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1985754,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1941449,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1945228,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1940272,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1930589,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2075513,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2061550,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2050131,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1977171,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1907883,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1985754,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1941449,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1945228,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1940272,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1930589,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2075513,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2061550,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2050131,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Strictly Increasing Cells in a Matrix",
        "question_content": "<p>Given a <strong>1-indexed</strong>&nbsp;<code>m x n</code> integer matrix <code>mat</code>, you can select any cell in the matrix as your <strong>starting cell</strong>.</p>\n\n<p>From the starting cell, you can move to any other cell <strong>in the</strong> <strong>same row or column</strong>, but only if the value of the destination cell is <strong>strictly greater</strong> than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.</p>\n\n<p>Your task is to find the <strong>maximum number of cells</strong> that you can visit in the matrix by starting from some cell.</p>\n\n<p>Return <em>an integer denoting the maximum number of cells that can be visited.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong class=\"example\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/23/diag1drawio.png\" style=\"width: 200px; height: 176px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[3,1],[3,4]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong class=\"example\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/23/diag3drawio.png\" style=\"width: 200px; height: 176px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[1,1],[1,1]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Since the cells must be strictly increasing, we can only visit one cell in this example. \n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong class=\"example\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/23/diag4drawio.png\" style=\"width: 350px; height: 250px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[3,1,6],[-9,5,7]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length&nbsp;</code></li>\n\t<li><code>n == mat[i].length&nbsp;</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3570296,
                "title": "java-c-python-dp-solution",
                "content": "# **Intuition**\\nApply `dp` solution,\\n`dp[i][j]` means the maximum steps can go from the first cell.\\nInitial all `dp[i][j] = 0` at first,\\nand the smallest cell `A[i][j]` will start with `dp[i][j] = 1`.\\n<br>\\n\\n# **Explanation**\\nSort pairs `[i, j]` by value of `M[i][j]`,\\nand then iterate cells in increasing order.\\n\\nFor each `M[i][j]`,\\nfind out the current maximum steps in the same row and col,\\n`dp[i][j] = max(max steps in row, max steps in col) + 1`.\\n\\nTo make this process efficient,\\nwe use `res[i]` to record the maximum step for row `i`,\\nwe use `res[m + j]` to record the maximum step for col `j`.\\n\\nRepeat this process until we find the steps for all cells,\\nreturn the maximum one.\\n<br>\\n\\n# **Complexity**\\nTime `O(mnlogmn)`\\nSpace `O(mn)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maxIncreasingCells(int[][] M) {\\n        int m = M.length, n = M[0].length;\\n        Map<Integer, List<int[]>> A = new TreeMap<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int val = M[i][j];\\n                if (!A.containsKey(val)) {\\n                    A.put(val, new ArrayList<int[]>());\\n                }\\n                A.get(val).add(new int[] {i, j});\\n            }\\n        }\\n        int[][] dp = new int[m][n];\\n        int[] res = new int[n + m];\\n        for (int a : A.keySet()) {\\n            for (int[] pos : A.get(a)) {\\n                int i = pos[0], j = pos[1];\\n                dp[i][j] = Math.max(res[i], res[m + j]) + 1;\\n            }\\n            for (int[] pos : A.get(a)) {\\n                int i = pos[0], j = pos[1];\\n                res[m + j] = Math.max(res[m + j], dp[i][j]);\\n                res[i] = Math.max(res[i], dp[i][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for (int a : res)\\n            ans = Math.max(ans, a);\\n        return ans;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maxIncreasingCells(vector<vector<int>>& M) {\\n        int m = M.size(), n = M[0].size();\\n        map<int, vector<int>> A;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                A[M[i][j]].push_back(i * n + j);\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<int> res(n + m, 0);\\n        for (auto& [a, pos] : A) {\\n            for (int p : pos) {\\n                int i = p / n, j = p % n;\\n                dp[i][j] = max(res[i], res[m + j]) + 1;\\n            }\\n            for (int p : pos) {\\n                int i = p / n, j = p % n;\\n                res[m + j] = max(res[m + j], dp[i][j]);\\n                res[i] = max(res[i], dp[i][j]);\\n            }\\n        }\\n        return *max_element(res.begin(), res.end());\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maxIncreasingCells(self, M: List[List[int]]) -> int:\\n        m, n = len(M), len(M[0])\\n        A = defaultdict(list)\\n        for i in range(m):\\n            for j in range(n):\\n                A[M[i][j]].append([i, j])\\n        dp = [[0] * n for i in range(m)]\\n        res = [0] * (n + m)\\n        for a in sorted(A):\\n            for i, j in A[a]:\\n                dp[i][j] = max(res[i], res[~j]) + 1\\n            for i, j in A[a]:\\n                res[~j] = max(res[~j], dp[i][j])\\n                res[i] = max(res[i], dp[i][j])\\n        return max(res)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maxIncreasingCells(int[][] M) {\\n        int m = M.length, n = M[0].length;\\n        Map<Integer, List<int[]>> A = new TreeMap<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int val = M[i][j];\\n                if (!A.containsKey(val)) {\\n                    A.put(val, new ArrayList<int[]>());\\n                }\\n                A.get(val).add(new int[] {i, j});\\n            }\\n        }\\n        int[][] dp = new int[m][n];\\n        int[] res = new int[n + m];\\n        for (int a : A.keySet()) {\\n            for (int[] pos : A.get(a)) {\\n                int i = pos[0], j = pos[1];\\n                dp[i][j] = Math.max(res[i], res[m + j]) + 1;\\n            }\\n            for (int[] pos : A.get(a)) {\\n                int i = pos[0], j = pos[1];\\n                res[m + j] = Math.max(res[m + j], dp[i][j]);\\n                res[i] = Math.max(res[i], dp[i][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for (int a : res)\\n            ans = Math.max(ans, a);\\n        return ans;\\n    }\\n```\n```cpp\\n    int maxIncreasingCells(vector<vector<int>>& M) {\\n        int m = M.size(), n = M[0].size();\\n        map<int, vector<int>> A;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                A[M[i][j]].push_back(i * n + j);\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<int> res(n + m, 0);\\n        for (auto& [a, pos] : A) {\\n            for (int p : pos) {\\n                int i = p / n, j = p % n;\\n                dp[i][j] = max(res[i], res[m + j]) + 1;\\n            }\\n            for (int p : pos) {\\n                int i = p / n, j = p % n;\\n                res[m + j] = max(res[m + j], dp[i][j]);\\n                res[i] = max(res[i], dp[i][j]);\\n            }\\n        }\\n        return *max_element(res.begin(), res.end());\\n    }\\n```\n```py\\n    def maxIncreasingCells(self, M: List[List[int]]) -> int:\\n        m, n = len(M), len(M[0])\\n        A = defaultdict(list)\\n        for i in range(m):\\n            for j in range(n):\\n                A[M[i][j]].append([i, j])\\n        dp = [[0] * n for i in range(m)]\\n        res = [0] * (n + m)\\n        for a in sorted(A):\\n            for i, j in A[a]:\\n                dp[i][j] = max(res[i], res[~j]) + 1\\n            for i, j in A[a]:\\n                res[~j] = max(res[~j], dp[i][j])\\n                res[i] = max(res[i], dp[i][j])\\n        return max(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3570268,
                "title": "all-possible-solution-with-explanation-dp-binarysearch-recursion-and-more",
                "content": "# Intuition\\nwe find the longest increasing paths starting from each value in the matrix. By keeping track of the longest paths for rows and columns, we determine the maximum number of cells we can visit. The final result is the maximum path length among all rows and columns.\\n\\n# Algo\\n1-: We have a grid of numbers, and we want to find the most cells we can visit by starting from any cell and moving only to cells with higher numbers.\\n\\n2-: We go through the grid and remember where each number is located, and also keep track of the unique numbers in reverse order.\\n\\n3 -: Starting from the highest number, we calculate the longest paths by moving only to cells with higher numbers. We keep track of the longest path for each row and column.\\n\\nAfter going through all the numbers, we update the longest paths for each row and column based on the calculated paths.\\n\\nFinally, we find the longest path among all the rows and columns, which represents the maximum number of cells we can visit.\\nComplexity\\nTime complexity:\\nO(m * n * log(m * n))\\n\\nSpace complexity:\\nO(m * n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& matrix) {\\n        const int rows = matrix.size();\\n        const int cols = matrix[0].size();\\n\\n        vector<int> rowPaths(rows);\\n        vector<int> colPaths(cols);\\n        unordered_map<int, vector<vector<int>>> valuePositions;\\n        vector<vector<int>> temp(rows, vector<int>(cols));\\n        set<int> uniqueValues;\\n\\n        // Populate valuePositions and uniqueValues\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                int value = matrix[i][j];\\n                valuePositions[-value].push_back({i, j});\\n                uniqueValues.insert(-value);\\n            }\\n        }\\n\\n        // Calculate longest paths\\n        for (int value : uniqueValues) {\\n            for (const auto& position : valuePositions[value]) {\\n                int row = position[0];\\n                int col = position[1];\\n                temp[row][col] = max(rowPaths[row], colPaths[col]) + 1;\\n            }\\n\\n            for (const auto& position : valuePositions[value]) {\\n                int row = position[0];\\n                int col = position[1];\\n                rowPaths[row] = max(rowPaths[row], temp[row][col]);\\n                colPaths[col] = max(colPaths[col], temp[row][col]);\\n            }\\n        }\\n\\n        // Return the maximum path length\\n        return max(*max_element(rowPaths.begin(), rowPaths.end()), *max_element(colPaths.begin(), colPaths.end()));\\n    }\\n};\\n```\\n# Method 2-> Recursion ( Dfs )\\nBut it passed only 557 cases and give tle at 558\\nSuggest me how to reduce complexity of recursion\\nMy logic\\n1. Fisrt make array and mark -1 at each point \\n2. make a call in same row and same column for given point \\n3. Returm maximum of both calls \\n```\\n     class Solution {\\npublic:\\n    vector<vector<int>>vis;\\n    int m,n;\\n    int dfs(int x,int y,vector<vector<int>>&mat)\\n    {\\n        if(vis[x][y]!=-1)return vis[x][y];\\n        // for col\\n        int ans=1;\\n        for(int col=0;col<n;col++)\\n        {\\n           if(mat[x][y]<mat[x][col])\\n           {\\n               int colans=1+dfs(x,col,mat);\\n               ans=max(ans,colans);\\n           }\\n        }\\n\\n        // for row\\n        for(int row=0;row<m;row++)\\n        {\\n           if(mat[x][y]<mat[row][y])\\n           {\\n               int rowans=1+dfs(row,y,mat);\\n               ans=max(ans,rowans);\\n           }\\n        }\\n      return vis[x][y]=ans;\\n    }\\n    int maxIncreasingCells(vector<vector<int>>& mat)\\n    {  \\n         m=mat.size(),n=mat[0].size();\\n         vis.resize(m+1,vector<int>(n+1,-1));\\n         int ans=1;\\n         for(int i=0 ;i< m ;i++)\\n         for(int j=0 ;j<n ;j++)\\n         {\\n             ans=max(ans,dfs(i,j,mat));\\n         }\\n         return ans;\\n\\n    }\\n};\\n```\\n# Method 3 -> Binary Search along with dfs\\n But its also give tle at case 558\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>vis;\\n    vector<vector<pair<int,int>>>scol,srow;\\n    int m,n;\\n    int bs(vector<pair<int,int>>&sorted,int target)\\n    {\\n        int low=0,high=sorted.size()-1,ans=-1;\\n        vector<int>greater;\\n        while(high>=low)\\n        {\\n            int mid=(low+high)/2;\\n            if(sorted[mid].first>target)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans ;\\n    }\\n    int dfs(int x,int y,vector<vector<int>>&mat)\\n    {\\n    \\n        int ans=1;\\n        int c=bs(scol[x],mat[x][y]);\\n        int r=bs(srow[y],mat[x][y]);\\n        if(vis[x][y]!=-1)return vis[x][y];\\n        //-1 means no element left in that row or column\\n         while(c!=-1 and c<scol[x].size())\\n        {\\n            int newcol=scol[x][c].second;\\n            int colans=1+dfs(x,newcol,mat);\\n            ans=max(ans ,colans);\\n            c++;\\n        }\\n\\n          while(r!=-1 and r< srow[y].size())\\n        {   \\n            int newrow=srow[y][r].second;\\n            int rowans=1+dfs(newrow,y,mat);\\n            ans=max(ans ,rowans);\\n            r++;\\n        }\\n       \\n        return vis[x][y]=ans;\\n    }\\n    int maxIncreasingCells(vector<vector<int>>& mat)\\n    {  \\n         m=mat.size(),n=mat[0].size();\\n         scol.resize(m),srow.resize(n);\\n         // create sorted col\\n         for(int i=0 ;i<m ;i++)\\n         {   \\n             for(int j=0 ;j<n ;j++)\\n             scol[i].push_back({mat[i][j],j});\\n             sort(begin(scol[i]),end(scol[i]));\\n         }\\n        // create sorted row\\n          for(int i=0 ;i< n;i++)\\n         {   \\n             for(int j=0 ;j<m;j++)\\n             srow[i].push_back({mat[j][i],j});\\n             sort(begin(srow[i]),end(srow[i]));\\n         }\\n         vis.resize(m+1,vector<int>(n+1,-1));\\n         int ans=1;\\n         for(int i=0 ;i< m ;i++)\\n         for(int j=0 ;j< n ;j++)\\n         {\\n             ans=max(ans,dfs(i,j,mat));\\n         }\\n         return ans;\\n\\n    }\\n};\\n```\\n# 4 Dfs using map and binary Search 100% accepted\\n```\\n\\nclass Solution {\\nprivate:\\n    int dfs(vector<vector<int>> &arr,int i,int j,map<int,vector<int>> row[],map<int,vector<int>> col[],vector<vector<int>> &dp){\\n        \\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=1;\\n        //move in row\\n        auto c=row[i].lower_bound(arr[i][j]+1);\\n        if(c!=row[i].end()){\\n            vector<int> x=(*c).second;\\n            for(auto ele:x)\\n                ans=max(ans,1+dfs(arr,i,ele,row,col,dp));\\n        }\\n        //move in col\\n        auto r=col[j].lower_bound(arr[i][j]+1);\\n        if(r!=col[j].end()){\\n            vector<int> x=(*r).second;\\n            for(auto ele:x)\\n                ans=max(ans,1+dfs(arr,ele,j,row,col,dp));\\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& arr) {\\n        \\n        int m=arr.size(),n=arr[0].size(),i,j;\\n        map<int,vector<int>> row[m];\\n        map<int,vector<int>> col[n];\\n        \\n        for(i=0;i<m;++i){\\n            for(j=0;j<n;++j){\\n                int ele=arr[i][j];\\n                row[i][ele].push_back(j);\\n                col[j][ele].push_back(i);\\n            }\\n        }\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int ans=0;\\n       \\n        for(i=0;i<m;++i){\\n            for(j=0;j<n;++j){\\n                ans=max(ans,dfs(arr,i,j,row,col,dp));\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& matrix) {\\n        const int rows = matrix.size();\\n        const int cols = matrix[0].size();\\n\\n        vector<int> rowPaths(rows);\\n        vector<int> colPaths(cols);\\n        unordered_map<int, vector<vector<int>>> valuePositions;\\n        vector<vector<int>> temp(rows, vector<int>(cols));\\n        set<int> uniqueValues;\\n\\n        // Populate valuePositions and uniqueValues\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                int value = matrix[i][j];\\n                valuePositions[-value].push_back({i, j});\\n                uniqueValues.insert(-value);\\n            }\\n        }\\n\\n        // Calculate longest paths\\n        for (int value : uniqueValues) {\\n            for (const auto& position : valuePositions[value]) {\\n                int row = position[0];\\n                int col = position[1];\\n                temp[row][col] = max(rowPaths[row], colPaths[col]) + 1;\\n            }\\n\\n            for (const auto& position : valuePositions[value]) {\\n                int row = position[0];\\n                int col = position[1];\\n                rowPaths[row] = max(rowPaths[row], temp[row][col]);\\n                colPaths[col] = max(colPaths[col], temp[row][col]);\\n            }\\n        }\\n\\n        // Return the maximum path length\\n        return max(*max_element(rowPaths.begin(), rowPaths.end()), *max_element(colPaths.begin(), colPaths.end()));\\n    }\\n};\\n```\n```\\n     class Solution {\\npublic:\\n    vector<vector<int>>vis;\\n    int m,n;\\n    int dfs(int x,int y,vector<vector<int>>&mat)\\n    {\\n        if(vis[x][y]!=-1)return vis[x][y];\\n        // for col\\n        int ans=1;\\n        for(int col=0;col<n;col++)\\n        {\\n           if(mat[x][y]<mat[x][col])\\n           {\\n               int colans=1+dfs(x,col,mat);\\n               ans=max(ans,colans);\\n           }\\n        }\\n\\n        // for row\\n        for(int row=0;row<m;row++)\\n        {\\n           if(mat[x][y]<mat[row][y])\\n           {\\n               int rowans=1+dfs(row,y,mat);\\n               ans=max(ans,rowans);\\n           }\\n        }\\n      return vis[x][y]=ans;\\n    }\\n    int maxIncreasingCells(vector<vector<int>>& mat)\\n    {  \\n         m=mat.size(),n=mat[0].size();\\n         vis.resize(m+1,vector<int>(n+1,-1));\\n         int ans=1;\\n         for(int i=0 ;i< m ;i++)\\n         for(int j=0 ;j<n ;j++)\\n         {\\n             ans=max(ans,dfs(i,j,mat));\\n         }\\n         return ans;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>vis;\\n    vector<vector<pair<int,int>>>scol,srow;\\n    int m,n;\\n    int bs(vector<pair<int,int>>&sorted,int target)\\n    {\\n        int low=0,high=sorted.size()-1,ans=-1;\\n        vector<int>greater;\\n        while(high>=low)\\n        {\\n            int mid=(low+high)/2;\\n            if(sorted[mid].first>target)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans ;\\n    }\\n    int dfs(int x,int y,vector<vector<int>>&mat)\\n    {\\n    \\n        int ans=1;\\n        int c=bs(scol[x],mat[x][y]);\\n        int r=bs(srow[y],mat[x][y]);\\n        if(vis[x][y]!=-1)return vis[x][y];\\n        //-1 means no element left in that row or column\\n         while(c!=-1 and c<scol[x].size())\\n        {\\n            int newcol=scol[x][c].second;\\n            int colans=1+dfs(x,newcol,mat);\\n            ans=max(ans ,colans);\\n            c++;\\n        }\\n\\n          while(r!=-1 and r< srow[y].size())\\n        {   \\n            int newrow=srow[y][r].second;\\n            int rowans=1+dfs(newrow,y,mat);\\n            ans=max(ans ,rowans);\\n            r++;\\n        }\\n       \\n        return vis[x][y]=ans;\\n    }\\n    int maxIncreasingCells(vector<vector<int>>& mat)\\n    {  \\n         m=mat.size(),n=mat[0].size();\\n         scol.resize(m),srow.resize(n);\\n         // create sorted col\\n         for(int i=0 ;i<m ;i++)\\n         {   \\n             for(int j=0 ;j<n ;j++)\\n             scol[i].push_back({mat[i][j],j});\\n             sort(begin(scol[i]),end(scol[i]));\\n         }\\n        // create sorted row\\n          for(int i=0 ;i< n;i++)\\n         {   \\n             for(int j=0 ;j<m;j++)\\n             srow[i].push_back({mat[j][i],j});\\n             sort(begin(srow[i]),end(srow[i]));\\n         }\\n         vis.resize(m+1,vector<int>(n+1,-1));\\n         int ans=1;\\n         for(int i=0 ;i< m ;i++)\\n         for(int j=0 ;j< n ;j++)\\n         {\\n             ans=max(ans,dfs(i,j,mat));\\n         }\\n         return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570203,
                "title": "longest-path-in-c-java-python",
                "content": "# Intuition\\nIt\\u2019s another version of the longest path problem which can be solved by DP.\\n\\n\\n\\n\\n# Approach\\n1. Let m and n be the number of rows and columns of the matrix. Create 2 arrays r and c whose lengths are m and n. Initialize them to all 0s. They are the maximum path length of each row or column.\\n2. Sort all the values in the matrix in non increasing order, for each value v, save all the positions (x, y) of that value in a list (reverse indexed).\\n3. Loop all the values from largest to smallest, for each v, all the occurrence positions (x, y), save temp[x][y] = max(r[x], c[y]) + 1, this is the longest path starting from that value.\\n4. Update r[x] = max(r[x], temp[x][y]) and c[y] = max(c[y], temp[x][y]) for all the above (x, y)s. This is to update the longest path for each row and column. Also note this step should be done after step 3 is fully complete.\\n5. The maximum value in arrays r and c is the final answer.\\n\\n\\n\\n\\n# Complexity\\n\\n\\n\\n\\n- Time complexity:\\nO(m * n * log(m * n))\\n\\n\\n- Space complexity:\\nO(m * n)\\n\\n\\n# Code\\n\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        const int m = mat.size(), n = mat[0].size();\\n        vector<int> r(m), c(n);\\n        unordered_map<int, vector<vector<int>>> vmap;\\n        vector<vector<int>> temp(m, vector<int>(n));\\n        set<int> s;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vmap[-mat[i][j]].push_back({i, j});\\n                s.insert(-mat[i][j]);\\n            }\\n            \\n        }\\n        for (int x : s) {\\n            for (const auto& v : vmap[x]) {\\n                temp[v[0]][v[1]] = max(r[v[0]], c[v[1]]) + 1;\\n            }\\n            for (const auto& v : vmap[x]) {\\n                r[v[0]] = max(r[v[0]], temp[v[0]][v[1]]);\\n                c[v[1]] = max(c[v[1]], temp[v[0]][v[1]]);\\n            }   \\n        }\\n        return max(*max_element(r.begin(), r.end()), *max_element(c.begin(), c.end()));\\n        \\n    }\\n};\\n     \\n```\\n\\n\\nJava:\\n```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        final int m = mat.length, n = mat[0].length;\\n        int[] r = new int[m], c = new int[n];\\n        Map<Integer, List<int[]>> vmap = new HashMap<>();\\n        int[][] temp = new int[m][n];\\n        Set<Integer> s = new TreeSet<>();\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vmap.computeIfAbsent(-mat[i][j], k->new ArrayList<>()).add(new int[]{i,j});\\n                s.add(-mat[i][j]);\\n            }\\n            \\n        }\\n        for (Integer x : s) {\\n            for (int[] v : vmap.get(x)) {\\n                temp[v[0]][v[1]] = Math.max(r[v[0]], c[v[1]]) + 1;\\n            }\\n            for (int[] v : vmap.get(x)) {\\n                r[v[0]] = Math.max(r[v[0]], temp[v[0]][v[1]]);\\n                c[v[1]] = Math.max(c[v[1]], temp[v[0]][v[1]]);\\n            }   \\n        }\\n        int ans = Integer.MIN_VALUE;\\n        for (int x : r) {\\n            ans = Math.max(ans, x);\\n        }\\n        for (int x : c) {\\n            ans = Math.max(ans, x);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\nPython3:\\n```\\n class Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        r, c = [0] * m, [0] * n\\n        vmap = {}\\n        from sortedcontainers import SortedSet\\n        s = SortedSet()\\n        for i in range(0, m):\\n            for j in range(0, n):\\n                if not -mat[i][j] in vmap:\\n                    vmap[-mat[i][j]] = []\\n                vmap[-mat[i][j]].append([i, j])\\n                s.add(-mat[i][j])\\n        temp = [[0] * n for _ in range(m)]\\n        for x in s:\\n            for v in vmap.get(x):\\n                temp[v[0]][v[1]] = max(r[v[0]], c[v[1]]) + 1\\n            for v in vmap.get(x):\\n                r[v[0]] = max(r[v[0]], temp[v[0]][v[1]])\\n                c[v[1]] = max(c[v[1]], temp[v[0]][v[1]])\\n        return max(max(r), max(c))\\n             \\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        const int m = mat.size(), n = mat[0].size();\\n        vector<int> r(m), c(n);\\n        unordered_map<int, vector<vector<int>>> vmap;\\n        vector<vector<int>> temp(m, vector<int>(n));\\n        set<int> s;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vmap[-mat[i][j]].push_back({i, j});\\n                s.insert(-mat[i][j]);\\n            }\\n            \\n        }\\n        for (int x : s) {\\n            for (const auto& v : vmap[x]) {\\n                temp[v[0]][v[1]] = max(r[v[0]], c[v[1]]) + 1;\\n            }\\n            for (const auto& v : vmap[x]) {\\n                r[v[0]] = max(r[v[0]], temp[v[0]][v[1]]);\\n                c[v[1]] = max(c[v[1]], temp[v[0]][v[1]]);\\n            }   \\n        }\\n        return max(*max_element(r.begin(), r.end()), *max_element(c.begin(), c.end()));\\n        \\n    }\\n};\\n     \\n```\n```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        final int m = mat.length, n = mat[0].length;\\n        int[] r = new int[m], c = new int[n];\\n        Map<Integer, List<int[]>> vmap = new HashMap<>();\\n        int[][] temp = new int[m][n];\\n        Set<Integer> s = new TreeSet<>();\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vmap.computeIfAbsent(-mat[i][j], k->new ArrayList<>()).add(new int[]{i,j});\\n                s.add(-mat[i][j]);\\n            }\\n            \\n        }\\n        for (Integer x : s) {\\n            for (int[] v : vmap.get(x)) {\\n                temp[v[0]][v[1]] = Math.max(r[v[0]], c[v[1]]) + 1;\\n            }\\n            for (int[] v : vmap.get(x)) {\\n                r[v[0]] = Math.max(r[v[0]], temp[v[0]][v[1]]);\\n                c[v[1]] = Math.max(c[v[1]], temp[v[0]][v[1]]);\\n            }   \\n        }\\n        int ans = Integer.MIN_VALUE;\\n        for (int x : r) {\\n            ans = Math.max(ans, x);\\n        }\\n        for (int x : c) {\\n            ans = Math.max(ans, x);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n class Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        r, c = [0] * m, [0] * n\\n        vmap = {}\\n        from sortedcontainers import SortedSet\\n        s = SortedSet()\\n        for i in range(0, m):\\n            for j in range(0, n):\\n                if not -mat[i][j] in vmap:\\n                    vmap[-mat[i][j]] = []\\n                vmap[-mat[i][j]].append([i, j])\\n                s.add(-mat[i][j])\\n        temp = [[0] * n for _ in range(m)]\\n        for x in s:\\n            for v in vmap.get(x):\\n                temp[v[0]][v[1]] = max(r[v[0]], c[v[1]]) + 1\\n            for v in vmap.get(x):\\n                r[v[0]] = max(r[v[0]], temp[v[0]][v[1]])\\n                c[v[1]] = max(c[v[1]], temp[v[0]][v[1]])\\n        return max(max(r), max(c))\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570337,
                "title": "c-java-python-detailed-explanation",
                "content": "# Intuition\\n1. We can jump between a row or a column. **So the elements in same row or same column can be understood as equivalent**.\\n    It\\'s because if in the last time we can jump in a row from $a_{ij}$to $a_{ik}$, it must be able to jump to other $a_{i*}$ as well. The same goes for jumping within a column.\\n2. **That being the case, it is better to maintain information in units of rows and columns instead of grids**.\\n3. And because it can only jump from small to large, it can be enumerated in order of value from small to large. Constantly update the \"maximum jumping times when staying in each row/column\". We use `row` and `col` array to record this information.\\n4. One trouble is what if the same number appears? It is necessary to ensure that `row` and `col` are not \"polluted\" before the update is complete. \\n    We can use another two arrays `tmpR` and `tmpC` to record the temporary result without polluting the original `row` and `col`.\\n\\n# Approach\\n- We can use `std::map` in C++ or `TreeMap` in Java or sorted dict in Python to enumerate from small to large.\\n- Notice that the different values can reach $mn$, so copy the whole `tmpR` and `tmpC` to `row` and `col` is not a good idea. \\n    But notice that we will only modify partial positions, so we can just record and copy the modified positions.\\n\\n# Complexity\\n- Time complexity: $O(mn\\\\log(mn))$\\n- Space complexity: $O(mn)$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        map<int, vector<pair<int, int>>> mp;\\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                mp[mat[i][j]].push_back(make_pair(i, j));\\n        vector<int> row(m, 0), col(n, 0), tmpR(m), tmpC(n);\\n        for (auto &[k, v]: mp) {\\n            for (auto &[x, y]: v) {\\n                int s = max(row[x], col[y]);\\n                tmpR[x] = max(tmpR[x], s + 1);\\n                tmpC[y] = max(tmpC[y], s + 1);\\n            }\\n            for (auto &[x, y]: v) {\\n                row[x] = tmpR[x];\\n                col[y] = tmpC[y];\\n            }\\n        }\\n        return *max_element(col.begin(), col.end());\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        TreeMap<Integer, List<int[]>> mp = new TreeMap<>();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                mp.computeIfAbsent(mat[i][j], k -> new ArrayList<>()).add(new int[]{i, j});\\n        int[] row = new int[m], col = new int[n];\\n        int[] tmpR = new int[m], tmpC = new int[n];\\n        for (var v: mp.values()) {\\n            for (int i = 0; i < v.size(); ++i) {\\n                int x = v.get(i)[0], y = v.get(i)[1];\\n                int s = Math.max(row[x], col[y]);\\n                tmpR[x] = Math.max(tmpR[x], s + 1);\\n                tmpC[y] = Math.max(tmpC[y], s + 1);\\n            }\\n            for (int i = 0; i < v.size(); ++i) {\\n                int x = v.get(i)[0], y = v.get(i)[1];\\n                row[x] = tmpR[x];\\n                col[y] = tmpC[y];\\n            }\\n        }\\n        return Arrays.stream(row).max().getAsInt();\\n    }\\n}\\n```\\n``` Python3 []\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        mp = dict()\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j] not in mp:\\n                    mp[mat[i][j]] = []\\n                mp[mat[i][j]].append((i, j))\\n        row, col = [0] * m, [0] * n\\n        tmpR, tmpC = [0] * m, [0] * n\\n        for k, v in sorted(mp.items()):\\n            for (x, y) in v:\\n                s = max(row[x], col[y])\\n                tmpR[x] = max(tmpR[x], s + 1)\\n                tmpC[y] = max(tmpC[y], s + 1)\\n            for (x, y) in v:\\n                row[x] = tmpR[x]\\n                col[y] = tmpC[y]\\n        return max(row)\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        map<int, vector<pair<int, int>>> mp;\\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                mp[mat[i][j]].push_back(make_pair(i, j));\\n        vector<int> row(m, 0), col(n, 0), tmpR(m), tmpC(n);\\n        for (auto &[k, v]: mp) {\\n            for (auto &[x, y]: v) {\\n                int s = max(row[x], col[y]);\\n                tmpR[x] = max(tmpR[x], s + 1);\\n                tmpC[y] = max(tmpC[y], s + 1);\\n            }\\n            for (auto &[x, y]: v) {\\n                row[x] = tmpR[x];\\n                col[y] = tmpC[y];\\n            }\\n        }\\n        return *max_element(col.begin(), col.end());\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        TreeMap<Integer, List<int[]>> mp = new TreeMap<>();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                mp.computeIfAbsent(mat[i][j], k -> new ArrayList<>()).add(new int[]{i, j});\\n        int[] row = new int[m], col = new int[n];\\n        int[] tmpR = new int[m], tmpC = new int[n];\\n        for (var v: mp.values()) {\\n            for (int i = 0; i < v.size(); ++i) {\\n                int x = v.get(i)[0], y = v.get(i)[1];\\n                int s = Math.max(row[x], col[y]);\\n                tmpR[x] = Math.max(tmpR[x], s + 1);\\n                tmpC[y] = Math.max(tmpC[y], s + 1);\\n            }\\n            for (int i = 0; i < v.size(); ++i) {\\n                int x = v.get(i)[0], y = v.get(i)[1];\\n                row[x] = tmpR[x];\\n                col[y] = tmpC[y];\\n            }\\n        }\\n        return Arrays.stream(row).max().getAsInt();\\n    }\\n}\\n```\n``` Python3 []\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        mp = dict()\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j] not in mp:\\n                    mp[mat[i][j]] = []\\n                mp[mat[i][j]].append((i, j))\\n        row, col = [0] * m, [0] * n\\n        tmpR, tmpC = [0] * m, [0] * n\\n        for k, v in sorted(mp.items()):\\n            for (x, y) in v:\\n                s = max(row[x], col[y])\\n                tmpR[x] = max(tmpR[x], s + 1)\\n                tmpC[y] = max(tmpC[y], s + 1)\\n            for (x, y) in v:\\n                row[x] = tmpR[x]\\n                col[y] = tmpC[y]\\n        return max(row)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570898,
                "title": "current-and-previous",
                "content": "The idea is to process cells from smallest to largest, track and increment the count for the corresponding row and column.\\n\\nThe difficult part for me was how to handle duplicate values. \\n\\nSo, for each row and column , we track the last (largest) value we processed (`v_r` and `v_c`).\\n\\nAlso, we track the count for each row and column (`cnt_r` and `cnt_c`).\\n\\nIf the new value is larger than the last one, we get the maximum of two counts, increment it, and assign it as the new count for both row and column:\\n\\n> ` cnt_r[i] = cnt_c[j] = 1 + max(cnt_r[i], cnt_c[j)`\\n\\nHowever, if the new value if the same, we need to use count for the previos smaller value.\\n\\n> We can store all previous values, but we actually need just the most recent one.\\n\\nSo, we store two counts for each row and column:\\n- `cnt_*[0]` - count for the most recent value\\n- `cnt_*[1]` - count the previous value.\\n\\nWhen the new value is greater, we save the count for the current value (`cnt_*[1] = cnt_*[0]`).\\n\\nThe picture below demonstrates how the previous count is used for the duplicate `-7` value.\\n\\n![image](https://assets.leetcode.com/users/images/57502fbd-20e2-48e6-8a12-6d1e01e48648_1685257560.7367897.png)\\n\\n**C++**\\n```cpp\\nint maxIncreasingCells(vector<vector<int>>& mat) {\\n    vector<array<int, 3>> vij;\\n    int m = mat.size(), n = mat[0].size();\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            vij.push_back({mat[i][j], i, j});\\n    sort(begin(vij), end(vij));\\n    vector<int> v_r(m, INT_MIN), v_c(n, INT_MIN);\\n    vector<vector<int>> cnt_r(m, vector<int>(2)), cnt_c(n, vector<int>(2));\\n    for (auto [v, i, j] : vij) {\\n        int cnt = max(cnt_r[i][v == v_r[i]], cnt_c[j][v == v_c[j]]);\\n        if (v > v_r[i])\\n            cnt_r[i][1] = cnt_r[i][0];\\n        if (v > v_c[j])\\n            cnt_c[j][1] = cnt_c[j][0];\\n        cnt_r[i][0] = max(1 + cnt, cnt_r[i][0]);\\n        cnt_c[j][0] = max(1 + cnt, cnt_c[j][0]);\\n        v_r[i] = v_c[j] = v;\\n    }\\n    return (*max_element(begin(cnt_r), end(cnt_r)))[0];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maxIncreasingCells(vector<vector<int>>& mat) {\\n    vector<array<int, 3>> vij;\\n    int m = mat.size(), n = mat[0].size();\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            vij.push_back({mat[i][j], i, j});\\n    sort(begin(vij), end(vij));\\n    vector<int> v_r(m, INT_MIN), v_c(n, INT_MIN);\\n    vector<vector<int>> cnt_r(m, vector<int>(2)), cnt_c(n, vector<int>(2));\\n    for (auto [v, i, j] : vij) {\\n        int cnt = max(cnt_r[i][v == v_r[i]], cnt_c[j][v == v_c[j]]);\\n        if (v > v_r[i])\\n            cnt_r[i][1] = cnt_r[i][0];\\n        if (v > v_c[j])\\n            cnt_c[j][1] = cnt_c[j][0];\\n        cnt_r[i][0] = max(1 + cnt, cnt_r[i][0]);\\n        cnt_c[j][0] = max(1 + cnt, cnt_c[j][0]);\\n        v_r[i] = v_c[j] = v;\\n    }\\n    return (*max_element(begin(cnt_r), end(cnt_r)))[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570184,
                "title": "sort-cells-in-decreasing-order-of-value-longest-path-in-dag",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        // we can maintain the maximum and minimum for each row and col directly\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        using ll = long long;\\n        vector<ll> rowMax(m, 0);\\n        vector<ll> colMax(n, 0);\\n        \\n        map<int,vector<pair<int,int>>,greater<int>> cells;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                cells[mat[i][j]].push_back({i,j});\\n            }\\n        }\\n        \\n        ll result = 0;\\n        \\n        for(auto& it : cells) {\\n            vector<pair<int,int>>& arr = it.second;\\n            vector<ll> val(arr.size());\\n            \\n            for(int i=0; i<arr.size(); i++) {\\n                auto [x, y] = arr[i];\\n                val[i] = max(rowMax[x], colMax[y]) + 1;\\n                result = max(result, val[i]);\\n            }\\n            \\n            for(int i=0; i<arr.size(); i++) {\\n                auto [x, y] = arr[i];\\n                rowMax[x] = max(rowMax[x], val[i]);\\n                colMax[y] = max(colMax[y], val[i]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        // we can maintain the maximum and minimum for each row and col directly\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        using ll = long long;\\n        vector<ll> rowMax(m, 0);\\n        vector<ll> colMax(n, 0);\\n        \\n        map<int,vector<pair<int,int>>,greater<int>> cells;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                cells[mat[i][j]].push_back({i,j});\\n            }\\n        }\\n        \\n        ll result = 0;\\n        \\n        for(auto& it : cells) {\\n            vector<pair<int,int>>& arr = it.second;\\n            vector<ll> val(arr.size());\\n            \\n            for(int i=0; i<arr.size(); i++) {\\n                auto [x, y] = arr[i];\\n                val[i] = max(rowMax[x], colMax[y]) + 1;\\n                result = max(result, val[i]);\\n            }\\n            \\n            for(int i=0; i<arr.size(); i++) {\\n                auto [x, y] = arr[i];\\n                rowMax[x] = max(rowMax[x], val[i]);\\n                colMax[y] = max(colMax[y], val[i]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570385,
                "title": "dp-orderedmap-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**1)Longest Increasing subsequence in a matrix intution**\\n**2)Do not require visited array here**\\n3)Try to find **next** element in **log n** due to 10^5 constraints\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMap each row and column in seperate array of ordered Maps which gives next greater element in that row(if moving in row) or column(if moving in column) in **log n** time\\nUse DP for every index\\nCall the function for every index(thinking the possibility that each element can be starting element)\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n*log(max(m,n)))$$ \\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int help(vector<vector<int>> &arr,int i,int j,map<int,vector<int>> row[],map<int,vector<int>> col[],vector<vector<int>> &dp){\\n        // cout<<i<<\" \"<<j<<endl;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=1;\\n        //move in row\\n        auto c=row[i].lower_bound(arr[i][j]+1);\\n        if(c!=row[i].end()){\\n            vector<int> x=(*c).second;\\n            for(auto ele:x)\\n                ans=max(ans,1+help(arr,i,ele,row,col,dp));\\n        }\\n        //move in col\\n        auto r=col[j].lower_bound(arr[i][j]+1);\\n        if(r!=col[j].end()){\\n            vector<int> x=(*r).second;\\n            for(auto ele:x)\\n                ans=max(ans,1+help(arr,ele,j,row,col,dp));\\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& arr) {\\n        // cout<<\"Here\"<<endl;\\n        int m=arr.size(),n=arr[0].size(),i,j;\\n        map<int,vector<int>> row[m];\\n        map<int,vector<int>> col[n];\\n        // cout<<\"Here\"<<endl;\\n        for(i=0;i<m;++i){\\n            for(j=0;j<n;++j){\\n                int ele=arr[i][j];\\n                row[i][ele].push_back(j);\\n                col[j][ele].push_back(i);\\n            }\\n        }\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        // cout<<\"Here\"<<endl;\\n        for(i=0;i<m;++i){\\n            for(j=0;j<n;++j){\\n                ans=max(ans,help(arr,i,j,row,col,dp));\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int help(vector<vector<int>> &arr,int i,int j,map<int,vector<int>> row[],map<int,vector<int>> col[],vector<vector<int>> &dp){\\n        // cout<<i<<\" \"<<j<<endl;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=1;\\n        //move in row\\n        auto c=row[i].lower_bound(arr[i][j]+1);\\n        if(c!=row[i].end()){\\n            vector<int> x=(*c).second;\\n            for(auto ele:x)\\n                ans=max(ans,1+help(arr,i,ele,row,col,dp));\\n        }\\n        //move in col\\n        auto r=col[j].lower_bound(arr[i][j]+1);\\n        if(r!=col[j].end()){\\n            vector<int> x=(*r).second;\\n            for(auto ele:x)\\n                ans=max(ans,1+help(arr,ele,j,row,col,dp));\\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& arr) {\\n        // cout<<\"Here\"<<endl;\\n        int m=arr.size(),n=arr[0].size(),i,j;\\n        map<int,vector<int>> row[m];\\n        map<int,vector<int>> col[n];\\n        // cout<<\"Here\"<<endl;\\n        for(i=0;i<m;++i){\\n            for(j=0;j<n;++j){\\n                int ele=arr[i][j];\\n                row[i][ele].push_back(j);\\n                col[j][ele].push_back(i);\\n            }\\n        }\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        // cout<<\"Here\"<<endl;\\n        for(i=0;i<m;++i){\\n            for(j=0;j<n;++j){\\n                ans=max(ans,help(arr,i,j,row,col,dp));\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3570677,
                "title": "explained-o-m-n-log-m-n-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n`next_r[r]`: The max path length starting from `val` in row `r`\\n`next_c[c]`: The max path length starting from `val` in column `c`\\n`prev_r[r]`: The max path length starting from `val+1` in row `r`\\n`prev_r[r]`: The max path length starting from `val+1` in column `c`\\n\\nWe iterate over all values (`val`) in matrix in descending order. For all positions `r`, `c` with the value `val`, we can go to any cell in the same row or column with value `val+1` which is stored in `prev_r`.\\n\\nAfter iterating over cells with value `val` we update `prev_r` and `prev_c` using `next_r` and `next_c`.\\n\\nAnswer is the maximum path starting from minimum value from any row or column.\\n\\n# Complexity\\n- Time complexity: O(m*n*log(m*n))\\n\\n- Space complexity: m*n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        \\n        # Positions of values\\n        pos = {}\\n        for r in range(m):\\n            for c in range(n):\\n                if mat[r][c] not in pos:\\n                    pos[mat[r][c]] = []\\n                pos[mat[r][c]].append((r, c))\\n        \\n        # the max_path starting from row or col with val-1\\n        prev_r = defaultdict(int)\\n        prev_c = defaultdict(int)\\n        \\n        for val in sorted(pos.keys(), reverse=True):\\n            \\n            # the max_path starting from row or col with val\\n            next_r = defaultdict(int)\\n            next_c = defaultdict(int)\\n            for r, c in pos[val]:\\n                next_r[r] = max(next_r[r], prev_r[r]+1, prev_c[c]+1)\\n                next_c[c] = max(next_c[c], prev_r[r]+1, prev_c[c]+1)\\n\\n            # Update max paths\\n            prev_r.update(next_r)\\n            prev_c.update(next_c)\\n\\n        # Answer is max_path from minimum value starting from any row or col\\n        return max(max(prev_r.values()), max(prev_c.values()))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        \\n        # Positions of values\\n        pos = {}\\n        for r in range(m):\\n            for c in range(n):\\n                if mat[r][c] not in pos:\\n                    pos[mat[r][c]] = []\\n                pos[mat[r][c]].append((r, c))\\n        \\n        # the max_path starting from row or col with val-1\\n        prev_r = defaultdict(int)\\n        prev_c = defaultdict(int)\\n        \\n        for val in sorted(pos.keys(), reverse=True):\\n            \\n            # the max_path starting from row or col with val\\n            next_r = defaultdict(int)\\n            next_c = defaultdict(int)\\n            for r, c in pos[val]:\\n                next_r[r] = max(next_r[r], prev_r[r]+1, prev_c[c]+1)\\n                next_c[c] = max(next_c[c], prev_r[r]+1, prev_c[c]+1)\\n\\n            # Update max paths\\n            prev_r.update(next_r)\\n            prev_c.update(next_c)\\n\\n        # Answer is max_path from minimum value starting from any row or col\\n        return max(max(prev_r.values()), max(prev_c.values()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570654,
                "title": "java-diagram-dp-framework-concept-note-how-idea-comes",
                "content": "# Intuition\\nAfter checking [lee\\' solution](https://leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/solutions/3570296/java-c-python-dp-solution/) and [cpcs\\' solution](https://leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/solutions/3570203/longest-path-in-c-java-python/), I wonder how to use DP concept to think out solution. I will talk about some dp key points here and hope it can help others.\\n\\n# DP\\n## Prev -> Curr\\nIn short, in DP problem, current state will be contributed by previous state.\\n![image.png](https://assets.leetcode.com/users/images/51ad036e-14d8-4649-977a-45df08b3f958_1685250270.603888.png)\\n\\nLike above, `curr` state could be contributed by one or many `prev` state.\\n\\nSome example:\\n+ climb stairs problem:  `curr = 5`, you can step from `prev = 4, 3` if possible.\\n![image.png](https://assets.leetcode.com/users/images/877432ec-cb95-411f-98c5-ce62f425938d_1685250793.6545436.png)\\n+ frog jump problem: same above\\n![image.png](https://assets.leetcode.com/users/images/efbc5a4a-d34b-4155-b9e0-9c341f20643d_1685250862.2895057.png)\\n\\n+ knight jump following left -> right: same but adding one dimension\\n![image.png](https://assets.leetcode.com/users/images/f480cda6-75ac-44cd-9404-61d9b4f2c9c8_1685250620.995348.png)\\n+ Number of ways from left top to right bottom\\n<img src=https://assets.leetcode.com/users/images/3ff90754-9fec-445a-a956-4984e01afc33_1685250703.0512414.png width=300>\\n\\nThe contribution is basically an **aggregation** function with **edge weight**:\\n+ count + 1\\n+ min + weight\\n+ max + weight\\n\\n---\\nFor this problem, for current pos `(r,c)`, legal previous state is strictly smaller same row or same col state.\\n![image.png](https://assets.leetcode.com/users/images/3ecc3d50-80ee-42f6-8bcb-944cefc15181_1685251309.7833006.png)\\n\\nThe aggregration is count since we care about number of ways.\\n\\n\\n## DP Direction\\nDP must have direction to iterate. It is acyclic. Or it would iterate infinitely.\\n\\nEach of above examples: they both have direction explicitly\\n+ stairs: always go up, cannot go back\\n+ frop jump: always go right\\n+ knight: left\\n+ left top to right bottom: can only down or right\\n\\n---\\n\\nFor our problem, it is the value direction.\\n\\n## Optimize\\nIf following above, we have a lot time complexity when finding previous legal state. (for curr row and curr max).\\n\\nSo here using `int[] rMax, int[]cMax` to store `row[i]` max result and `col[j]` max result.\\n\\nRemeber after computing `dp[i][j]`, we need to MAINTAIN `rMax` and `cMax`.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        int[] rMax = new int[n];\\n        int[] cMax = new int[m];\\n\\n        // dp: direction: value from small to big, increasing order\\n\\n        // preparion:  prev: val -> [[i, j]]\\n        TreeMap<Integer, List<int[]>> map = new TreeMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                map.putIfAbsent(mat[i][j], new ArrayList<>());\\n                map.get(mat[i][j]).add(new int[]{i, j});\\n            }\\n        }\\n\\n        // [...prev] --> curr : agg max, + 1\\n        int[][] dp = new int[n][m];\\n        // iterate based on value\\n        for (int v : map.keySet()) {\\n            // update current pos result\\n            for (int[] pos : map.get(v)) {\\n                dp[pos[0]][pos[1]] = Math.max(rMax[pos[0]], cMax[pos[1]]) + 1;\\n            }\\n            // update r and c max result\\n            for (int[] pos : map.get(v)) {\\n                rMax[pos[0]] = Math.max(rMax[pos[0]], dp[pos[0]][pos[1]]);\\n                cMax[pos[1]] = Math.max(cMax[pos[1]], dp[pos[0]][pos[1]]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int[] d : dp)\\n            for (int x : d)\\n                ans = Math.max(ans, x);\\n\\n        return ans;\\n    \\n                \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        int[] rMax = new int[n];\\n        int[] cMax = new int[m];\\n\\n        // dp: direction: value from small to big, increasing order\\n\\n        // preparion:  prev: val -> [[i, j]]\\n        TreeMap<Integer, List<int[]>> map = new TreeMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                map.putIfAbsent(mat[i][j], new ArrayList<>());\\n                map.get(mat[i][j]).add(new int[]{i, j});\\n            }\\n        }\\n\\n        // [...prev] --> curr : agg max, + 1\\n        int[][] dp = new int[n][m];\\n        // iterate based on value\\n        for (int v : map.keySet()) {\\n            // update current pos result\\n            for (int[] pos : map.get(v)) {\\n                dp[pos[0]][pos[1]] = Math.max(rMax[pos[0]], cMax[pos[1]]) + 1;\\n            }\\n            // update r and c max result\\n            for (int[] pos : map.get(v)) {\\n                rMax[pos[0]] = Math.max(rMax[pos[0]], dp[pos[0]][pos[1]]);\\n                cMax[pos[1]] = Math.max(cMax[pos[1]], dp[pos[0]][pos[1]]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int[] d : dp)\\n            for (int x : d)\\n                ans = Math.max(ans, x);\\n\\n        return ans;\\n    \\n                \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570262,
                "title": "c-dp",
                "content": "# Intuition\\nAt first I thought of a 2d dp. You can iterate through the matrix in order of decreasing cell value, storing the max number of cells reachable from each cell `mat[i][j]` in `dp[i][j]`. However, for each cell you have to look at all reachable cells (its entire row and column), so the time complexity would be $$O(n*m*(n+m))$$, which isn\\u2019t fast enough.\\n\\nThen I realized you don\\u2019t need to store the max for every cell. As you iterate through the matrix in order of decreasing cell value, you always take the maximum path already found starting in the same row or column. This means you can get away with just storing the max for each row and column.\\n\\n# Approach\\nCreate a map of cell values in decreasing order to (r, c) positions in the matrix with those values. Iterate through this map, updating the vectors row_max and col_max, which store the max number of cells reachable starting from somewhere in each row and column. Be careful to only update row_max and col_max after every cell with a given value has been processed.\\n\\n\\n# Complexity\\n- Time complexity\\n$$O(n*m*log(n*m))$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row_max(n), col_max(m);\\n        \\n        map<int, vector<pair<int, int>>, greater<int>> pos;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                pos[mat[i][j]].push_back({i, j});\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (auto& [num, cells]: pos) {\\n            int k = cells.size();\\n            vector<int> next(k);\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                next[i] = max(row_max[r], col_max[c]) + 1;\\n                ans = max(ans, next[i]);\\n            }\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                row_max[r] = max(row_max[r], next[i]);\\n                col_max[c] = max(col_max[c], next[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row_max(n), col_max(m);\\n        \\n        map<int, vector<pair<int, int>>, greater<int>> pos;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                pos[mat[i][j]].push_back({i, j});\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (auto& [num, cells]: pos) {\\n            int k = cells.size();\\n            vector<int> next(k);\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                next[i] = max(row_max[r], col_max[c]) + 1;\\n                ans = max(ans, next[i]);\\n            }\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                row_max[r] = max(row_max[r], next[i]);\\n                col_max[c] = max(col_max[c], next[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570176,
                "title": "sorting-dp-like",
                "content": "Let <code>dp[i][j]</code> denote the maximum number of moves we can make if we start from <code>ith row</code> and <code>jth column</code>\\n\\nSome useful obersvations\\n1. If we start from the largest number answer is always 1.\\n2. If ` mat[r][c] < mat[r1][c1]` then one of the possible solution for ` r,c` can be `dp[r1][c1]+1` if either the row or column is same.\\n3. For every `mat[r][c] `choose  `mat[i][j]` such that `mat[r][c] < mat[i][j]` && `dp[i][j]` is maximum among the `rth row` and `cth column`\\n4. Answer will be the maximum in `dp` matrix.\\n\\nImplementation\\n1. By sorting matrix elements in Descending  order we always have to choose the maximum in current row and current column. \\n2. Finding maximum in row and column will be O(N) making time complexity O(N^2), so we can create two arrays `rowMax` and `colMax` which store maximum `dp[i][j]` in their respective rows and columns. \\n\\t\\tLike `rowMax[2]` = maximum dp[i][j] in 2nd row\\n3. But how will we handle equal elements in current row and column. They will increase our answer unnecessary (because we cannot jump to euqal elements)\\n\\tTo handle that we will update `rowMax` and `colMax` only when the previous number was greater than the current numbe. \\n\\t\\nCode\\n```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        List<Cell> sortedCells = new ArrayList<>();\\n        int rows=mat.length;\\n        int cols = mat[0].length;\\n        for(int r=0;r<rows;r++){\\n            for(int c=0;c<cols;c++) sortedCells.add(new Cell(r,c,mat[r][c]));\\n        }\\n        sortedCells.sort((n1, n2)-> n2.value-n1.value);\\n        int answer = 0;\\n        int[] rowMax = new int[rows];\\n        int[] colMax = new int[cols];\\n        List<Cell> notUpdatedCells = new ArrayList<>();\\n        int prev_value = Integer.MAX_VALUE;\\n        for(Cell node: sortedCells){\\n            int r=node.r;\\n            int c=node.c;\\n            int value = node.value;\\n            if(prev_value!=value){ \\n                for(Cell cell : notUpdatedCells){\\n                    rowMax[cell.r] = Math.max(cell.value,rowMax[cell.r]);\\n                    colMax[cell.c] = Math.max(cell.value,colMax[cell.c]);\\n                }\\n                notUpdatedCells = new ArrayList<>();\\n            }\\n            int cur = Math.max(rowMax[r],colMax[c])+1; //dp[r][c]\\n            answer = Math.max(cur,answer);\\n            prev_value = value;\\n            node.value = cur; //Storing dp[r][c] so that we can use it after all cells with equal value are processed.\\n            notUpdatedCells.add(node);\\n        }\\n        return answer;\\n    }\\n}\\nclass Cell {\\n    int r,c,value;\\n    public Cell(int r, int c, int value) {\\n        this.r = r;\\n        this.c = c;\\n        this.value = value;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        List<Cell> sortedCells = new ArrayList<>();\\n        int rows=mat.length;\\n        int cols = mat[0].length;\\n        for(int r=0;r<rows;r++){\\n            for(int c=0;c<cols;c++) sortedCells.add(new Cell(r,c,mat[r][c]));\\n        }\\n        sortedCells.sort((n1, n2)-> n2.value-n1.value);\\n        int answer = 0;\\n        int[] rowMax = new int[rows];\\n        int[] colMax = new int[cols];\\n        List<Cell> notUpdatedCells = new ArrayList<>();\\n        int prev_value = Integer.MAX_VALUE;\\n        for(Cell node: sortedCells){\\n            int r=node.r;\\n            int c=node.c;\\n            int value = node.value;\\n            if(prev_value!=value){ \\n                for(Cell cell : notUpdatedCells){\\n                    rowMax[cell.r] = Math.max(cell.value,rowMax[cell.r]);\\n                    colMax[cell.c] = Math.max(cell.value,colMax[cell.c]);\\n                }\\n                notUpdatedCells = new ArrayList<>();\\n            }\\n            int cur = Math.max(rowMax[r],colMax[c])+1; //dp[r][c]\\n            answer = Math.max(cur,answer);\\n            prev_value = value;\\n            node.value = cur; //Storing dp[r][c] so that we can use it after all cells with equal value are processed.\\n            notUpdatedCells.add(node);\\n        }\\n        return answer;\\n    }\\n}\\nclass Cell {\\n    int r,c,value;\\n    public Cell(int r, int c, int value) {\\n        this.r = r;\\n        this.c = c;\\n        this.value = value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591660,
                "title": "c-max-in-ith-row-and-jth-column-set-and-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) \\n    {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        unordered_map<int,vector<pair<int,int>>> mp;\\n        set<int> uniquevalues;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mp[mat[i][j]].push_back({i,j});\\n                // just for equalvalues -> store all pair of i,j\\n                uniquevalues.insert(mat[i][j]);\\n            }\\n        }\\n        vector<vector<int>> temp(m, vector<int>(n));\\n        vector<int> row(mat.size(),0);\\n        // store max count in ith row \\n        vector<int> colu(mat[0].size(),0);\\n        // store max count jth col\\n        for(auto cur:uniquevalues)\\n        {\\n            vector<vector<int>> equalvalued;\\n            for(auto curpositions:mp[cur])\\n            {\\n                int i=curpositions.first;\\n                int j=curpositions.second;\\n                // cout<<cur<<\" ::   \"<< i<<\" \"<<j<<\"   \" <<row[i]<<\"-\"<<colu[j]<<endl;\\n                equalvalued.push_back({max(row[i],colu[j])+1,i,j});\\n            }\\n            // equalvalued cannot update in same single for loop as they can be in same row /column and increase count so just we store and traverse and update for corresponding row and col \\n            for(auto e:equalvalued)\\n            {\\n                int i=e[1];\\n                int j=e[2];\\n                row[i]=max(e[0],row[i]);\\n                colu[j]=max(e[0],colu[j]);\\n            }\\n        }\\n        int ans=0;\\n        for(auto e:row)\\n        {\\n            ans=max(ans,e);\\n        }\\n        for(auto e:colu)\\n        {\\n            ans=max(ans,e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Interactive",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) \\n    {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        unordered_map<int,vector<pair<int,int>>> mp;\\n        set<int> uniquevalues;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mp[mat[i][j]].push_back({i,j});\\n                // just for equalvalues -> store all pair of i,j\\n                uniquevalues.insert(mat[i][j]);\\n            }\\n        }\\n        vector<vector<int>> temp(m, vector<int>(n));\\n        vector<int> row(mat.size(),0);\\n        // store max count in ith row \\n        vector<int> colu(mat[0].size(),0);\\n        // store max count jth col\\n        for(auto cur:uniquevalues)\\n        {\\n            vector<vector<int>> equalvalued;\\n            for(auto curpositions:mp[cur])\\n            {\\n                int i=curpositions.first;\\n                int j=curpositions.second;\\n                // cout<<cur<<\" ::   \"<< i<<\" \"<<j<<\"   \" <<row[i]<<\"-\"<<colu[j]<<endl;\\n                equalvalued.push_back({max(row[i],colu[j])+1,i,j});\\n            }\\n            // equalvalued cannot update in same single for loop as they can be in same row /column and increase count so just we store and traverse and update for corresponding row and col \\n            for(auto e:equalvalued)\\n            {\\n                int i=e[1];\\n                int j=e[2];\\n                row[i]=max(e[0],row[i]);\\n                colu[j]=max(e[0],colu[j]);\\n            }\\n        }\\n        int ans=0;\\n        for(auto e:row)\\n        {\\n            ans=max(ans,e);\\n        }\\n        for(auto e:colu)\\n        {\\n            ans=max(ans,e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3572074,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\nll n, m;\\nvector<vector<int>>mat;\\nll value (ll i, ll j ,ll num,  vector<vector<vector<ll>>>&nextrow, vector<vector<vector<ll>>>&nextcol, vector<vector<ll>>&isvis)\\n{\\n    if(mat[i][j]<=num)return 0;\\n    if(isvis[i][j]!=-1)return isvis[i][j];\\n    // return 1;\\n    ll ans = 0;\\n    for (auto & x : nextrow[i][j])\\n    {\\n        ans = max(ans, value(i, x,mat[i][j], nextrow, nextcol, isvis));\\n    }\\n    // return ans;\\n    for (auto & y: nextcol[j][i])\\n    {\\n        ans = max(ans, value(y, j,mat[i][j], nextrow, nextcol, isvis));\\n    }\\n    return isvis[i][j]= ans+1;\\n}\\nint maxIncreasingCells(vector<vector<int>>& ma) {\\n    n = ma.size();\\n    mat = ma;\\n    m = ma[0].size();\\n    vector<vector<vector<ll>>>nextrow(n, vector<vector<ll>>(m));\\n    vector<vector<vector<ll>>>nextcol(m, vector<vector<ll>>(n));\\n    // vector<vector<ll>>nextcol(m, vector<ll>(n,0));\\n    for(int i = 0 ; i < n ; i++)\\n    {\\n        set<ll> st;\\n        map<ll,vector<ll>>mp;\\n        for (int j = 0 ; j < m ; j++){\\n            st.insert(ma[i][j]);\\n            mp[ma[i][j]].push_back(j);\\n        }\\n        while(st.size()>1)\\n        {\\n            ll it = (*st.begin());\\n            st.erase(st.begin());\\n            for (auto &x : mp[it])\\n            {\\n                for(auto &y : mp[(*st.begin())])\\n                {\\n                    nextrow[i][x].push_back(y);\\n                }\\n            }\\n        }\\n    } \\n    for (int i = 0; i < m; ++i)\\n    {\\n        set<ll>st;\\n        map<ll,vector<ll>>mp;\\n        for (int j = 0; j < n; ++j)\\n        {\\n            st.insert(ma[j][i]);\\n            mp[ma[j][i]].push_back(j);\\n        }\\n        while(st.size()>1)\\n        {\\n            ll it = (*st.begin());\\n            st.erase(st.begin());\\n            for (auto &x: mp[it])\\n            {\\n                for (auto &y : mp[*st.begin()])\\n                {\\n                    nextcol[i][x].push_back(y);\\n                }\\n            }\\n        }\\n    }\\n    for(auto &x : nextcol[0][0])cout<<x<<\" \";\\n    // return 0;\\n    vector<vector<ll>>isvis(n, vector<ll>(m, -1));\\n    ll ans= 0 ;\\n    for (int i = 0; i < n; ++i)\\n    {\\n        for (int j = 0; j < m; ++j)\\n        {\\n            ans= max(ans, value(i, j,INT_MIN, nextrow, nextcol, isvis));\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\nll n, m;\\nvector<vector<int>>mat;\\nll value (ll i, ll j ,ll num,  vector<vector<vector<ll>>>&nextrow, vector<vector<vector<ll>>>&nextcol, vector<vector<ll>>&isvis)\\n{\\n    if(mat[i][j]<=num)return 0;\\n    if(isvis[i][j]!=-1)return isvis[i][j];\\n    // return 1;\\n    ll ans = 0;\\n    for (auto & x : nextrow[i][j])\\n    {\\n        ans = max(ans, value(i, x,mat[i][j], nextrow, nextcol, isvis));\\n    }\\n    // return ans;\\n    for (auto & y: nextcol[j][i])\\n    {\\n        ans = max(ans, value(y, j,mat[i][j], nextrow, nextcol, isvis));\\n    }\\n    return isvis[i][j]= ans+1;\\n}\\nint maxIncreasingCells(vector<vector<int>>& ma) {\\n    n = ma.size();\\n    mat = ma;\\n    m = ma[0].size();\\n    vector<vector<vector<ll>>>nextrow(n, vector<vector<ll>>(m));\\n    vector<vector<vector<ll>>>nextcol(m, vector<vector<ll>>(n));\\n    // vector<vector<ll>>nextcol(m, vector<ll>(n,0));\\n    for(int i = 0 ; i < n ; i++)\\n    {\\n        set<ll> st;\\n        map<ll,vector<ll>>mp;\\n        for (int j = 0 ; j < m ; j++){\\n            st.insert(ma[i][j]);\\n            mp[ma[i][j]].push_back(j);\\n        }\\n        while(st.size()>1)\\n        {\\n            ll it = (*st.begin());\\n            st.erase(st.begin());\\n            for (auto &x : mp[it])\\n            {\\n                for(auto &y : mp[(*st.begin())])\\n                {\\n                    nextrow[i][x].push_back(y);\\n                }\\n            }\\n        }\\n    } \\n    for (int i = 0; i < m; ++i)\\n    {\\n        set<ll>st;\\n        map<ll,vector<ll>>mp;\\n        for (int j = 0; j < n; ++j)\\n        {\\n            st.insert(ma[j][i]);\\n            mp[ma[j][i]].push_back(j);\\n        }\\n        while(st.size()>1)\\n        {\\n            ll it = (*st.begin());\\n            st.erase(st.begin());\\n            for (auto &x: mp[it])\\n            {\\n                for (auto &y : mp[*st.begin()])\\n                {\\n                    nextcol[i][x].push_back(y);\\n                }\\n            }\\n        }\\n    }\\n    for(auto &x : nextcol[0][0])cout<<x<<\" \";\\n    // return 0;\\n    vector<vector<ll>>isvis(n, vector<ll>(m, -1));\\n    ll ans= 0 ;\\n    for (int i = 0; i < n; ++i)\\n    {\\n        for (int j = 0; j < m; ++j)\\n        {\\n            ans= max(ans, value(i, j,INT_MIN, nextrow, nextcol, isvis));\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3570483,
                "title": "dp-memoization-causing-tle-somebody-please-help",
                "content": "```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n                      int[][] dp = new int[m][n];\\n        int maxCells = 1; \\n        \\n    \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                      int cells = dfs(mat, dp, i, j, m, n);\\n                   maxCells = Math.max(maxCells, cells);\\n            }\\n        }\\n        \\n        return maxCells;\\n    }\\n    \\n    private int dfs(int[][] mat, int[][] dp, int i, int j, int m, int n) {\\n        if (dp[i][j] != 0) {\\n            return dp[i][j];\\n        }\\n        int maxCells = 1; \\n        for (int col = 0; col < n; col++) {\\n            if ( mat[i][col] > mat[i][j]) {\\n             int cells = 1 + dfs(mat, dp, i, col, m, n);\\n               maxCells = Math.max(maxCells, cells);\\n            }\\n        }\\n        for (int row = 0; row < m; row++) {\\n            if (mat[row][j] > mat[i][j]) { \\n                int cells = 1 + dfs(mat, dp, row, j, m, n);\\n                maxCells = Math.max(maxCells, cells);\\n            }\\n        }\\n\\n        return dp[i][j] = maxCells;\\n        \\n     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n                      int[][] dp = new int[m][n];\\n        int maxCells = 1; \\n        \\n    \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                      int cells = dfs(mat, dp, i, j, m, n);\\n                   maxCells = Math.max(maxCells, cells);\\n            }\\n        }\\n        \\n        return maxCells;\\n    }\\n    \\n    private int dfs(int[][] mat, int[][] dp, int i, int j, int m, int n) {\\n        if (dp[i][j] != 0) {\\n            return dp[i][j];\\n        }\\n        int maxCells = 1; \\n        for (int col = 0; col < n; col++) {\\n            if ( mat[i][col] > mat[i][j]) {\\n             int cells = 1 + dfs(mat, dp, i, col, m, n);\\n               maxCells = Math.max(maxCells, cells);\\n            }\\n        }\\n        for (int row = 0; row < m; row++) {\\n            if (mat[row][j] > mat[i][j]) { \\n                int cells = 1 + dfs(mat, dp, row, j, m, n);\\n                maxCells = Math.max(maxCells, cells);\\n            }\\n        }\\n\\n        return dp[i][j] = maxCells;\\n        \\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570322,
                "title": "dp-with-maps-clean-c",
                "content": "The idea is to process from min to max, and record the source row and col\\'s max steps.\\n\\nFor each row and col, we use a map to track the pairs when you have a value x, how many previous steps you can have.\\n\\nSince we can reach the current position by row or col, we choose the maximum of row and col steps and plus one.\\n\\nAfter that, we also update the <value, steps> pair in the memory (DP).\\n\\nThis gives a nlog(n) solution.\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> all;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                all.push_back({mat[i][j], i, j});\\n            }\\n        }\\n        sort(all.begin(), all.end());\\n        vector<map<int, int>> rm(m), cm(n);\\n        int res = 0;\\n        for(auto& ele : all){\\n            int v = ele[0];\\n            int r = ele[1];\\n            int c = ele[2];\\n            int cur = 0;\\n            auto rit = rm[r].lower_bound(v);\\n            if(rit != rm[r].begin()){\\n                cur = max(cur, prev(rit)->second);\\n            }\\n            auto cit = cm[c].lower_bound(v);\\n            if(cit != cm[c].begin()){\\n                cur = max(cur, prev(cit)->second);\\n            }\\n            cur++;\\n            rm[r][v] = max(rm[r][v], cur);\\n            cm[c][v] = max(cm[c][v], cur);\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> all;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                all.push_back({mat[i][j], i, j});\\n            }\\n        }\\n        sort(all.begin(), all.end());\\n        vector<map<int, int>> rm(m), cm(n);\\n        int res = 0;\\n        for(auto& ele : all){\\n            int v = ele[0];\\n            int r = ele[1];\\n            int c = ele[2];\\n            int cur = 0;\\n            auto rit = rm[r].lower_bound(v);\\n            if(rit != rm[r].begin()){\\n                cur = max(cur, prev(rit)->second);\\n            }\\n            auto cit = cm[c].lower_bound(v);\\n            if(cit != cm[c].begin()){\\n                cur = max(cur, prev(cit)->second);\\n            }\\n            cur++;\\n            rm[r][v] = max(rm[r][v], cur);\\n            cm[c][v] = max(cm[c][v], cur);\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571833,
                "title": "dp-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will start traversing in increasing order to ensure that we can reach all the previous elements. \\n2. Store the max number of elements reached in the row and col vector. \\n3. Find the max distance for cur element using that row and col vectors. \\n4. Update the ans by the current distance.\\n\\nNote - We have to handle the case for same elements as we can\\'t traverse from a element to another element with same value.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& a) {\\n        int n = a.size(),m=a[0].size();\\n        map<int, vector<pair<int,int>>> unique;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                unique[a[i][j]].push_back({i,j});\\n        vector<vector<int>> dp(n,vector<int>(m,1));\\n        vector<int> row(n,0),col(m,0);\\n        int ans = 0;\\n        for(auto x:unique)\\n        {\\n            //Unique elements\\n            for(auto y : x.second)\\n            {\\n                int a = y.first;\\n                int b = y.second;\\n                dp[a][b] = max(dp[a][b], max(row[a],col[b])+1);    \\n                ans = max(ans,dp[a][b]);\\n            }\\n            //Updating the row and col max\\n            for(auto y : x.second)\\n            {\\n                int a = y.first;\\n                int b = y.second;\\n                row[a] = max(row[a],dp[a][b]);\\n                col[b] = max(col[b],dp[a][b]);    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& a) {\\n        int n = a.size(),m=a[0].size();\\n        map<int, vector<pair<int,int>>> unique;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                unique[a[i][j]].push_back({i,j});\\n        vector<vector<int>> dp(n,vector<int>(m,1));\\n        vector<int> row(n,0),col(m,0);\\n        int ans = 0;\\n        for(auto x:unique)\\n        {\\n            //Unique elements\\n            for(auto y : x.second)\\n            {\\n                int a = y.first;\\n                int b = y.second;\\n                dp[a][b] = max(dp[a][b], max(row[a],col[b])+1);    \\n                ans = max(ans,dp[a][b]);\\n            }\\n            //Updating the row and col max\\n            for(auto y : x.second)\\n            {\\n                int a = y.first;\\n                int b = y.second;\\n                row[a] = max(row[a],dp[a][b]);\\n                col[b] = max(col[b],dp[a][b]);    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570545,
                "title": "a-good-comparative-study-question-1632",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem reminds me the other problem for a good comparative study.\\nif you are interested. It could use the similar techniques row max and col max to accelerate the speed.\\nhttps://leetcode.com/problems/rank-transform-of-a-matrix/\\nPlease don\\'t down vote this. This is not a solution explanation. But leetcode doesn\\'t have per problem discussion area....Thanks.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int, vector< pair<int, int> > > vals;\\n    vector< vector<int> > dp;\\n    vector<int> rowMax;\\n    vector<int> colMax;\\n    int m, n;\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        dp.assign(m, vector<int>(n, 0));\\n        rowMax.assign(m, 0);\\n        colMax.assign(n, 0);\\n        for (int r = 0; r < mat.size(); ++r)\\n            for (int c = 0; c < mat[r].size(); ++c)\\n            {\\n                vals[ mat[r][c] ].push_back( {r, c} );\\n            }\\n\\n        int res = 0;\\n        for(auto& item : vals)\\n        {\\n            for (auto& pos : item.second)\\n            {\\n                int r = pos.first;\\n                int c = pos.second;\\n                dp[r][c] = max(dp[r][c], rowMax[r] + 1);\\n                dp[r][c] = max(dp[r][c], colMax[c] + 1);\\n                res = max(res, dp[r][c]);\\n            }\\n            for (auto& pos : item.second)\\n            {\\n                int r = pos.first;\\n                int c = pos.second;\\n                rowMax[r] = max(rowMax[r], dp[r][c]);\\n                colMax[c] = max(colMax[c], dp[r][c]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, vector< pair<int, int> > > vals;\\n    vector< vector<int> > dp;\\n    vector<int> rowMax;\\n    vector<int> colMax;\\n    int m, n;\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        dp.assign(m, vector<int>(n, 0));\\n        rowMax.assign(m, 0);\\n        colMax.assign(n, 0);\\n        for (int r = 0; r < mat.size(); ++r)\\n            for (int c = 0; c < mat[r].size(); ++c)\\n            {\\n                vals[ mat[r][c] ].push_back( {r, c} );\\n            }\\n\\n        int res = 0;\\n        for(auto& item : vals)\\n        {\\n            for (auto& pos : item.second)\\n            {\\n                int r = pos.first;\\n                int c = pos.second;\\n                dp[r][c] = max(dp[r][c], rowMax[r] + 1);\\n                dp[r][c] = max(dp[r][c], colMax[c] + 1);\\n                res = max(res, dp[r][c]);\\n            }\\n            for (auto& pos : item.second)\\n            {\\n                int r = pos.first;\\n                int c = pos.second;\\n                rowMax[r] = max(rowMax[r], dp[r][c]);\\n                colMax[c] = max(colMax[c], dp[r][c]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570336,
                "title": "proirityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[] rows = new int[m], cols = new int[n];\\n        int[] rowMaxVals = new int[m], colMaxVals = new int[n];\\n        \\n        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];\\n        for(int i=0;i<m;i++) {\\n            rows[i] = Integer.MIN_VALUE;\\n        }\\n        for(int i=0;i<n;i++) {\\n            cols[i] = Integer.MIN_VALUE;\\n        }\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {\\n            return a[0] - b[0];\\n        });\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                queue.add(new int[]{mat[i][j], i, j});\\n            }\\n        }\\n        int res = 0;\\n        while(!queue.isEmpty()) {\\n            int[] arr = queue.remove();\\n            int val = arr[0], row = arr[1], col = arr[2];\\n            int cur = 1;\\n            if(val == rows[row]) {\\n                cur = Math.max(rowSubMaxVals[row] + 1, cur);\\n            } else {\\n                cur = Math.max(rowMaxVals[row] + 1, cur);\\n            }\\n            if(val == cols[col]) {\\n                cur = Math.max(colSubMaxVals[col] + 1, cur);\\n            } else {\\n                cur = Math.max(colMaxVals[col] + 1, cur);\\n            }\\n            \\n\\n            if(val > rows[row]) {\\n                rowSubMaxVals[row] = rowMaxVals[row];\\n                rows[row] = val;\\n            }\\n            if(val > cols[col]) {\\n                colSubMaxVals[col] = colMaxVals[col];\\n                cols[col] = val;\\n            }\\n            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);\\n            colMaxVals[col] = Math.max(colMaxVals[col], cur);\\n            \\n            res = Math.max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[] rows = new int[m], cols = new int[n];\\n        int[] rowMaxVals = new int[m], colMaxVals = new int[n];\\n        \\n        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];\\n        for(int i=0;i<m;i++) {\\n            rows[i] = Integer.MIN_VALUE;\\n        }\\n        for(int i=0;i<n;i++) {\\n            cols[i] = Integer.MIN_VALUE;\\n        }\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {\\n            return a[0] - b[0];\\n        });\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                queue.add(new int[]{mat[i][j], i, j});\\n            }\\n        }\\n        int res = 0;\\n        while(!queue.isEmpty()) {\\n            int[] arr = queue.remove();\\n            int val = arr[0], row = arr[1], col = arr[2];\\n            int cur = 1;\\n            if(val == rows[row]) {\\n                cur = Math.max(rowSubMaxVals[row] + 1, cur);\\n            } else {\\n                cur = Math.max(rowMaxVals[row] + 1, cur);\\n            }\\n            if(val == cols[col]) {\\n                cur = Math.max(colSubMaxVals[col] + 1, cur);\\n            } else {\\n                cur = Math.max(colMaxVals[col] + 1, cur);\\n            }\\n            \\n\\n            if(val > rows[row]) {\\n                rowSubMaxVals[row] = rowMaxVals[row];\\n                rows[row] = val;\\n            }\\n            if(val > cols[col]) {\\n                colSubMaxVals[col] = colMaxVals[col];\\n                cols[col] = val;\\n            }\\n            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);\\n            colMaxVals[col] = Math.max(colMaxVals[col], cur);\\n            \\n            res = Math.max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960087,
                "title": "c-max-element-to-min-element-traversal-on-set",
                "content": "# Intuition\\n- We know while standing at maximum element in matrix we can\\'t visit any other cells.\\n- By keeping this in mind we go from **max element --> min element**.\\n\\n\\n# Approach\\n- Create a set and store unique elements while maintaining a Hashmap for their indices.\\n- Traverse the set (from the max element to the min element) and update the state of `dp[i][j]` by taking the maximum of (`rowMax[currentRow]` and `colMax[currentColumn]`) plus one. Where:\\n> - `rowMax[currentRow]` is maximum number of cells we can visit by standing at current Row. \\n> - `colMax[currentCol]` is maximum number of cells we can visit by standing at current Column.\\n- Compare and update the `rowMax` array and `colMax` array with the current state if the current state is greater (for the next iteration).\\n- Traverse the `rowMax` and `colMax` arrays to find the maximum number of cells we can visit.\\n\\n\\n# Complexity\\n\\n- Time complexity:\\n$$O(n * m * log(n * m))$$ \\n\\n\\n- Space complexity:\\n$$O( n*m )$$ \\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int maxIncreasingCells(vector<vector<int>> &mat)\\n    {\\n        // Comparator to store values in decreasing order.\\n        auto comp = [](int a, int b)\\n        { return a > b; };\\n        set<int, decltype(comp)> s(comp);\\n\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, 0));\\n        vector<int> rowMax(n, 0), colMax(m, 0);\\n\\n        // This will help if same value exists at multiple indices.\\n        unordered_map<int, vector<pair<int, int>>> mapp; \\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                s.insert(mat[i][j]); // Store unique values in the set.\\n                mapp[mat[i][j]].push_back({i, j}); // Store their indices too.\\n            }\\n        }\\n\\n        // Start from Max Element and go till Min Element.\\n        for (auto unique : s)\\n        {\\n            for (auto index : mapp[unique])\\n            {\\n                auto [i, j] = index;\\n                dp[i][j] = max(rowMax[i], colMax[j]) + 1;\\n            }\\n\\n            // Update the maximum after processing all the indices\\n            for (auto index : mapp[unique])\\n            {\\n                auto [i, j] = index;\\n                rowMax[i] = max(rowMax[i], dp[i][j]);\\n                colMax[j] = max(colMax[j], dp[i][j]);\\n            }\\n        }\\n        int colMaxi = *max_element(colMax.begin(), colMax.end());\\n        int rowMaxi = *max_element(rowMax.begin(), rowMax.end());\\n        return max(colMaxi, rowMaxi);\\n    }\\n};\\n```\\n\\n> ## We can also traverse the set from back to front instead of using a custom comparator.\\n```\\n    for(auto it = s.rbegin(); it != s.rend(); ++it){\\n        auto unique=*it;\\n        /* Rest of Code */\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxIncreasingCells(vector<vector<int>> &mat)\\n    {\\n        // Comparator to store values in decreasing order.\\n        auto comp = [](int a, int b)\\n        { return a > b; };\\n        set<int, decltype(comp)> s(comp);\\n\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, 0));\\n        vector<int> rowMax(n, 0), colMax(m, 0);\\n\\n        // This will help if same value exists at multiple indices.\\n        unordered_map<int, vector<pair<int, int>>> mapp; \\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                s.insert(mat[i][j]); // Store unique values in the set.\\n                mapp[mat[i][j]].push_back({i, j}); // Store their indices too.\\n            }\\n        }\\n\\n        // Start from Max Element and go till Min Element.\\n        for (auto unique : s)\\n        {\\n            for (auto index : mapp[unique])\\n            {\\n                auto [i, j] = index;\\n                dp[i][j] = max(rowMax[i], colMax[j]) + 1;\\n            }\\n\\n            // Update the maximum after processing all the indices\\n            for (auto index : mapp[unique])\\n            {\\n                auto [i, j] = index;\\n                rowMax[i] = max(rowMax[i], dp[i][j]);\\n                colMax[j] = max(colMax[j], dp[i][j]);\\n            }\\n        }\\n        int colMaxi = *max_element(colMax.begin(), colMax.end());\\n        int rowMaxi = *max_element(rowMax.begin(), rowMax.end());\\n        return max(colMaxi, rowMaxi);\\n    }\\n};\\n```\n```\\n    for(auto it = s.rbegin(); it != s.rend(); ++it){\\n        auto unique=*it;\\n        /* Rest of Code */\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742380,
                "title": "python-dp-sort-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    from itertools import product\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        cache = defaultdict(list)\\n        rows, cols = len(mat), len(mat[0])\\n        for i, j in product(range(rows), range(cols)):\\n            cache[mat[i][j]].append((i, j))\\n\\n        colmax, rowmax = [0 for _ in range(cols)], [0 for _ in range(rows)]\\n        # tmp = \\n        dp = [[0]*cols for _ in range(rows)]\\n\\n        for val in sorted(cache, reverse=True):\\n            for i, j in cache[val]:\\n                dp[i][j] = 1 + max(rowmax[i], colmax[j])\\n            for i, j in cache[val]:\\n                rowmax[i] = max(rowmax[i], dp[i][j])\\n                colmax[j] = max(colmax[j], dp[i][j])\\n        \\n        return max(max(rowmax), max(colmax))\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    from itertools import product\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        cache = defaultdict(list)\\n        rows, cols = len(mat), len(mat[0])\\n        for i, j in product(range(rows), range(cols)):\\n            cache[mat[i][j]].append((i, j))\\n\\n        colmax, rowmax = [0 for _ in range(cols)], [0 for _ in range(rows)]\\n        # tmp = \\n        dp = [[0]*cols for _ in range(rows)]\\n\\n        for val in sorted(cache, reverse=True):\\n            for i, j in cache[val]:\\n                dp[i][j] = 1 + max(rowmax[i], colmax[j])\\n            for i, j in cache[val]:\\n                rowmax[i] = max(rowmax[i], dp[i][j])\\n                colmax[j] = max(colmax[j], dp[i][j])\\n        \\n        return max(max(rowmax), max(colmax))\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669286,
                "title": "dp-sortedmap-treemap-approach-java-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(m \\\\cdot n \\\\cdot \\\\log(\\\\max(m,n)))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(m \\\\cdot n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    TreeMap<Integer,List<Integer>> mpRow[];\\n    TreeMap<Integer,List<Integer>> mpCol[];\\n    int dp[][];\\n    int helper(int mat[][],int x,int y){\\n        if(dp[x][y] != -1) return dp[x][y];\\n        var ent = mpRow[x].higherEntry(mat[x][y]);\\n        int ans = 1;\\n        if(ent != null){\\n            for(var c:ent.getValue()){\\n                ans = Math.max(ans,1 + helper(mat,x,c));\\n            }\\n        }\\n        ent = mpCol[y].higherEntry(mat[x][y]);\\n        if(ent != null){\\n            for(var r:ent.getValue()){\\n                ans = Math.max(ans,1 + helper(mat,r,y));\\n            }\\n        }\\n        return dp[x][y] = ans;\\n    }\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        mpRow = new TreeMap[m];\\n        mpCol = new TreeMap[n];\\n        dp = new int[m][n];\\n        for(var a:dp) Arrays.fill(a,-1);\\n        for(int i = 0;i < m;i++){\\n            mpRow[i] = new TreeMap<>();\\n            for(int j = 0;j < n;j++){\\n                if(!mpRow[i].containsKey(mat[i][j])){\\n                    mpRow[i].put(mat[i][j],new ArrayList<>());\\n                }\\n                mpRow[i].get(mat[i][j]).add(j);\\n            }\\n        }\\n        for(int j = 0;j < n;j++){\\n            mpCol[j] = new TreeMap<>();\\n            for(int i = 0;i < m;i++){\\n                if(!mpCol[j].containsKey(mat[i][j])){\\n                    mpCol[j].put(mat[i][j],new ArrayList<>());\\n                }\\n                mpCol[j].get(mat[i][j]).add(i);\\n            }\\n        }\\n        int ans = 1;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                ans = Math.max(ans,helper(mat,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    TreeMap<Integer,List<Integer>> mpRow[];\\n    TreeMap<Integer,List<Integer>> mpCol[];\\n    int dp[][];\\n    int helper(int mat[][],int x,int y){\\n        if(dp[x][y] != -1) return dp[x][y];\\n        var ent = mpRow[x].higherEntry(mat[x][y]);\\n        int ans = 1;\\n        if(ent != null){\\n            for(var c:ent.getValue()){\\n                ans = Math.max(ans,1 + helper(mat,x,c));\\n            }\\n        }\\n        ent = mpCol[y].higherEntry(mat[x][y]);\\n        if(ent != null){\\n            for(var r:ent.getValue()){\\n                ans = Math.max(ans,1 + helper(mat,r,y));\\n            }\\n        }\\n        return dp[x][y] = ans;\\n    }\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        mpRow = new TreeMap[m];\\n        mpCol = new TreeMap[n];\\n        dp = new int[m][n];\\n        for(var a:dp) Arrays.fill(a,-1);\\n        for(int i = 0;i < m;i++){\\n            mpRow[i] = new TreeMap<>();\\n            for(int j = 0;j < n;j++){\\n                if(!mpRow[i].containsKey(mat[i][j])){\\n                    mpRow[i].put(mat[i][j],new ArrayList<>());\\n                }\\n                mpRow[i].get(mat[i][j]).add(j);\\n            }\\n        }\\n        for(int j = 0;j < n;j++){\\n            mpCol[j] = new TreeMap<>();\\n            for(int i = 0;i < m;i++){\\n                if(!mpCol[j].containsKey(mat[i][j])){\\n                    mpCol[j].put(mat[i][j],new ArrayList<>());\\n                }\\n                mpCol[j].get(mat[i][j]).add(i);\\n            }\\n        }\\n        int ans = 1;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                ans = Math.max(ans,helper(mat,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613469,
                "title": "c-set-map-with-explanation",
                "content": "The intution of this question starts with the largest cell in the matrix . From the largest cell of the matrix you can only visit the cell itself so for largest cell ans is 1. The largest value cell can be present at many positions in matrix ,so the ans is 1 for all those cells.\\nfor other cells it depends on the cells that has value greater than the current cell and is located in the same row or same column. 1+ maximum of(no of cells visited in row,no of cells that can be visted in col) gives the value for current cell.\\nLastly the maximum cell u can visit can be found by max of each row and each column.\\n\\n**Please Upvote if it helped!**\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int ans= INT_MIN;\\n        int n= mat.size();\\n        int m= mat[0].size();\\n        vector<vector<int>>temp(n,vector<int>(m,0));\\n        vector<int>row(n,0);\\n        vector<int>col(m,0);\\n        unordered_map<int,vector<pair<int,int>>>ump;\\n        set<int,greater<int>>s;\\n        set<int, greater<int> >::iterator itr;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int val= mat[i][j];\\n                ump[val].push_back({i,j});\\n                s.insert(mat[i][j]);\\n            }\\n        }\\n        for(auto x:s){\\n            int val=x;\\n            for(auto ele:ump[val]){\\n                int r= ele.first;\\n                int c= ele.second;\\n                temp[r][c]= max(row[r],col[c])+1;    \\n            }\\n            for(auto ele:ump[val]){\\n                int r= ele.first;\\n                int c= ele.second;\\n                row[r]= max(row[r],temp[r][c]);\\n                col[c]= max(col[c],temp[r][c]);\\n                \\n            }\\n        }\\n        for(int i=0;i<n; i++){\\n            ans= max(ans,row[i]);\\n            \\n        }\\n        for(int j=0; j<m; j++){\\n            ans= max(ans,col[j]);\\n        }\\n      \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int ans= INT_MIN;\\n        int n= mat.size();\\n        int m= mat[0].size();\\n        vector<vector<int>>temp(n,vector<int>(m,0));\\n        vector<int>row(n,0);\\n        vector<int>col(m,0);\\n        unordered_map<int,vector<pair<int,int>>>ump;\\n        set<int,greater<int>>s;\\n        set<int, greater<int> >::iterator itr;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int val= mat[i][j];\\n                ump[val].push_back({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 3576720,
                "title": "python-dp-binarysearch",
                "content": "**Idea:**\\n - Create matrix with sorted rows by values and keeping the original indexes. Basically it would be (A[i][j],i,j) and make another matrix just with the vaulues only (A[i][j]). Why do we need the matrix with the values only next time we are at element x we can find where to move next by binary search from the second matrix. Knowing the location of the index in the second matrix we can find new (i,j)\\n - Make the same matrices for the columns\\n - Make a DP fuction where for current index i,j we search for rows and columns the next biggest element and it\\'s indeces.\\n - We may need some hack to make it work because for the case when for example we currently on the element `5` the next biggest one is `7` and if we have more than 1 of `7` we can get into a different branch and miss the max.\\nThe while loops in the code below are made to cover the cases like that. \\n\\n```\\nx = C[i][ri][1]\\ny = C[i][ri][2]\\nZ = A[x][y]\\nwhile x < N and y < M and Z == A[x][y]:\\n\\tans = max(ans, 1 + dp(x,y))\\n\\tri += 1\\n\\tif ri == M: break\\n\\tx = C[i][ri][1]\\n\\ty = C[i][ri][2]\\n```\\n\\n```python\\nclass Solution:\\n    def maxIncreasingCells(self, A: List[List[int]]) -> int:\\n        N,M = len(A), len(A[0])\\n        C = []\\n        CT = []\\n        for i,r in enumerate(A):\\n            c = []\\n            for j in range(M):\\n                c.append((A[i][j],i,j))\\n            c.sort()\\n            C.append(c[:])\\n            CT.append([a for a,x,y in c])\\n        \\n        R = []\\n        RT = []\\n        for j in range(M):\\n            r = []\\n            for i in range(N):\\n                r.append((A[i][j],i,j))\\n            r.sort()\\n            R.append(r[:])\\n            RT.append([a for a,x,y in r])\\n        \\n        @cache\\n        def dp(i,j):\\n            ri = bisect_right(CT[i], A[i][j])\\n            \\n            ans = 1\\n            if ri < M:\\n                \\n                x = C[i][ri][1]\\n                y = C[i][ri][2]\\n                Z = A[x][y]\\n                while x < N and y < M and Z == A[x][y]:\\n                    ans = max(ans, 1 + dp(x,y))\\n                    ri += 1\\n                    if ri == M: break\\n                    x = C[i][ri][1]\\n                    y = C[i][ri][2]\\n            \\n            cj = bisect_right(RT[j], A[i][j])\\n            if cj < N:\\n                x = R[j][cj][1]\\n                y = R[j][cj][2]\\n                Z = A[x][y]\\n                while x < N and y < M and Z == A[x][y]:\\n                    ans = max(ans, 1 + dp(x,y))\\n                    cj += 1\\n                    if cj == N: break\\n                    x = R[j][cj][1]\\n                    y = R[j][cj][2]\\n            \\n            return ans\\n        \\n        ans = 1\\n        for i in range(N):\\n            for j in range(M):\\n                ans = max(ans, dp(i,j))\\n        return ans\\n```\\nTime: `O(MNlog(MN))` \\nSpace: `O(MN)`",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nx = C[i][ri][1]\\ny = C[i][ri][2]\\nZ = A[x][y]\\nwhile x < N and y < M and Z == A[x][y]:\\n\\tans = max(ans, 1 + dp(x,y))\\n\\tri += 1\\n\\tif ri == M: break\\n\\tx = C[i][ri][1]\\n\\ty = C[i][ri][2]\\n```\n```python\\nclass Solution:\\n    def maxIncreasingCells(self, A: List[List[int]]) -> int:\\n        N,M = len(A), len(A[0])\\n        C = []\\n        CT = []\\n        for i,r in enumerate(A):\\n            c = []\\n            for j in range(M):\\n                c.append((A[i][j],i,j))\\n            c.sort()\\n            C.append(c[:])\\n            CT.append([a for a,x,y in c])\\n        \\n        R = []\\n        RT = []\\n        for j in range(M):\\n            r = []\\n            for i in range(N):\\n                r.append((A[i][j],i,j))\\n            r.sort()\\n            R.append(r[:])\\n            RT.append([a for a,x,y in r])\\n        \\n        @cache\\n        def dp(i,j):\\n            ri = bisect_right(CT[i], A[i][j])\\n            \\n            ans = 1\\n            if ri < M:\\n                \\n                x = C[i][ri][1]\\n                y = C[i][ri][2]\\n                Z = A[x][y]\\n                while x < N and y < M and Z == A[x][y]:\\n                    ans = max(ans, 1 + dp(x,y))\\n                    ri += 1\\n                    if ri == M: break\\n                    x = C[i][ri][1]\\n                    y = C[i][ri][2]\\n            \\n            cj = bisect_right(RT[j], A[i][j])\\n            if cj < N:\\n                x = R[j][cj][1]\\n                y = R[j][cj][2]\\n                Z = A[x][y]\\n                while x < N and y < M and Z == A[x][y]:\\n                    ans = max(ans, 1 + dp(x,y))\\n                    cj += 1\\n                    if cj == N: break\\n                    x = R[j][cj][1]\\n                    y = R[j][cj][2]\\n            \\n            return ans\\n        \\n        ans = 1\\n        for i in range(N):\\n            for j in range(M):\\n                ans = max(ans, dp(i,j))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571090,
                "title": "java-dp-solution-detailed-explanation",
                "content": "# Approach\\n- Store all values from the grid in a tree map, with the value as map key and all its positions as map value (list of int[2] array)\\n- Use dp[i][j] to represent the maximum number of step one can take (starting anywhere) that ends at position mat[i][j]\\n- Use rowMax[i] to represent the maximum number of step one can take (starting anywhere) that ends at row i\\n- Use colMax[i] to represent the maximum number of step one can take (starting anywhere) that ends at column j\\n- Iterate through all positions of each value from smallest to biggest, and for each dp[i][j] equals to Math.max(rowMax[i],colMax[j])\\n- The previous point could be confusing, but imagine you start from a smallest value of -9, and at that point think of the whole grid to contain only the -9(s). You can only take one step into the -9 cell and can not go anyone else, so the first dp would always be 1. \\nThen say you put a second value of -8 which happens to be on the same row as -9, now you know you can take one step from the -9 over to the -8 so the max step would increment by 1\\n\\n# Complexity\\n- Time complexity:\\nO(mn)..? I feel like the TC is O(mn) but i am not sure since i see the top solutions indicating a TC of O(mnlogmn), would appreciate if anyone could explain\\n\\n- Space complexity:\\nO(mn)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {       \\n        int m = mat.length, n = mat[0].length, ans = 0;\\n        int[][] dp = new int[m][n];\\n        int[] rowMax = new int[m];\\n        int[] colMax = new int[n];\\n        Map<Integer,List<int[]>> valueMap = new TreeMap<>();\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (!valueMap.containsKey(mat[i][j])){\\n                    valueMap.put(mat[i][j],new ArrayList<>());\\n                }\\n                valueMap.get(mat[i][j]).add(new int[]{i,j});\\n            }\\n        }\\n        for (int val : valueMap.keySet()){\\n            for (int[] arr : valueMap.get(val)){\\n                // You can always take one more step from any other cell in the same row or column - \\n                // - that have max dp[][] value to arrive at the current cell -\\n                // - because the current cell is guranteed to be greater than all existing num in the same row or column\\n                dp[arr[0]][arr[1]] = Math.max(rowMax[arr[0]],colMax[arr[1]]) + 1;\\n            } \\n            for (int[] arr : valueMap.get(val)){\\n                rowMax[arr[0]] = Math.max(rowMax[arr[0]],dp[arr[0]][arr[1]]);\\n                colMax[arr[1]] = Math.max(colMax[arr[1]],dp[arr[0]][arr[1]]);\\n            } \\n        }\\n        for (int num : rowMax) ans = Math.max(ans,num);\\n        for (int num : colMax) ans = Math.max(ans,num);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {       \\n        int m = mat.length, n = mat[0].length, ans = 0;\\n        int[][] dp = new int[m][n];\\n        int[] rowMax = new int[m];\\n        int[] colMax = new int[n];\\n        Map<Integer,List<int[]>> valueMap = new TreeMap<>();\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (!valueMap.containsKey(mat[i][j])){\\n                    valueMap.put(mat[i][j],new ArrayList<>());\\n                }\\n                valueMap.get(mat[i][j]).add(new int[]{i,j});\\n            }\\n        }\\n        for (int val : valueMap.keySet()){\\n            for (int[] arr : valueMap.get(val)){\\n                // You can always take one more step from any other cell in the same row or column - \\n                // - that have max dp[][] value to arrive at the current cell -\\n                // - because the current cell is guranteed to be greater than all existing num in the same row or column\\n                dp[arr[0]][arr[1]] = Math.max(rowMax[arr[0]],colMax[arr[1]]) + 1;\\n            } \\n            for (int[] arr : valueMap.get(val)){\\n                rowMax[arr[0]] = Math.max(rowMax[arr[0]],dp[arr[0]][arr[1]]);\\n                colMax[arr[1]] = Math.max(colMax[arr[1]],dp[arr[0]][arr[1]]);\\n            } \\n        }\\n        for (int num : rowMax) ans = Math.max(ans,num);\\n        for (int num : colMax) ans = Math.max(ans,num);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570813,
                "title": "priority-queue-dfs-and-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main idea is to construct a graph with all the cells as nodes. The graph will be directed and it will have the next higher values in its row and column as neighbours.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used a priority queue to construct the graph. First will go row by row and add edges for the cell in its row. The we will do the same for columns. Finally we will do dfs from each unvisited cell and memoize the reuslts.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<int[]>[][] graph;\\n    boolean[][] visited;\\n    int[][] values;\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        graph = new List[m][n];\\n        values = new int[m][n];\\n        visited = new boolean[m][n];\\n        for(int i = 0; i < m; i++) {\\n            final int ci = i;\\n            PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> mat[ci][a] - mat[ci][b]);\\n            for(int j = 0; j < n; j++) {\\n                pq.add(j);\\n                graph[i][j] = new ArrayList<>();\\n            }\\n            List<Integer> from = new ArrayList<>();\\n                from.add(pq.remove());\\n                while(!pq.isEmpty() && mat[i][pq.peek()] == mat[i][from.get(0)]) {\\n                    from.add(pq.remove());\\n                }\\n            while(!pq.isEmpty()) {\\n                List<Integer> to = new ArrayList<>();\\n                to.add(pq.remove());\\n                while(!pq.isEmpty() && mat[i][pq.peek()] == mat[i][to.get(0)]) {\\n                    to.add(pq.remove());\\n                }\\n                for(int ii = 0; ii < from.size(); ii++) {\\n                    for(int j = 0; j < to.size(); j++) {\\n                        graph[i][from.get(ii)].add(new int[]{i, to.get(j)});\\n                    }\\n                }\\n                from = to;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            final int ci = i;\\n            PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> mat[a][ci] - mat[b][ci]);\\n            for(int j = 0; j < m; j++) {\\n                pq.add(j);\\n            }\\n            List<Integer> from = new ArrayList<>();\\n                from.add(pq.remove());\\n                while(!pq.isEmpty() && mat[pq.peek()][i] == mat[from.get(0)][i]) {\\n                    from.add(pq.remove());\\n                }\\n            while(!pq.isEmpty()) {\\n                List<Integer> to = new ArrayList<>();\\n                to.add(pq.remove());\\n                while(!pq.isEmpty() && mat[pq.peek()][i] == mat[to.get(0)][i]) {\\n                    to.add(pq.remove());\\n                }\\n                for(int ii = 0; ii < from.size(); ii++) {\\n                    for(int j = 0; j < to.size(); j++) {\\n                        graph[from.get(ii)][i].add(new int[]{to.get(j), i});\\n                    }\\n                }\\n                from = to;\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!visited[i][j]) {\\n                    result = Math.max(result, dfs(i, j));\\n                } else {\\n                    result = Math.max(result, values[i][j]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    int dfs(int r, int c) {\\n        visited[r][c] = true;\\n        int result = 1;\\n        for(int[] next : graph[r][c]) {\\n            if(!visited[next[0]][next[1]]) {\\n                result = Math.max(result, dfs(next[0], next[1])+1);\\n            } else {\\n                result = Math.max(result, values[next[0]][next[1]]+1);\\n            }\\n        }\\n        values[r][c] = result;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<int[]>[][] graph;\\n    boolean[][] visited;\\n    int[][] values;\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        graph = new List[m][n];\\n        values = new int[m][n];\\n        visited = new boolean[m][n];\\n        for(int i = 0; i < m; i++) {\\n            final int ci = i;\\n            PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> mat[ci][a] - mat[ci][b]);\\n            for(int j = 0; j < n; j++) {\\n                pq.add(j);\\n                graph[i][j] = new ArrayList<>();\\n            }\\n            List<Integer> from = new ArrayList<>();\\n                from.add(pq.remove());\\n                while(!pq.isEmpty() && mat[i][pq.peek()] == mat[i][from.get(0)]) {\\n                    from.add(pq.remove());\\n                }\\n            while(!pq.isEmpty()) {\\n                List<Integer> to = new ArrayList<>();\\n                to.add(pq.remove());\\n                while(!pq.isEmpty() && mat[i][pq.peek()] == mat[i][to.get(0)]) {\\n                    to.add(pq.remove());\\n                }\\n                for(int ii = 0; ii < from.size(); ii++) {\\n                    for(int j = 0; j < to.size(); j++) {\\n                        graph[i][from.get(ii)].add(new int[]{i, to.get(j)});\\n                    }\\n                }\\n                from = to;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            final int ci = i;\\n            PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> mat[a][ci] - mat[b][ci]);\\n            for(int j = 0; j < m; j++) {\\n                pq.add(j);\\n            }\\n            List<Integer> from = new ArrayList<>();\\n                from.add(pq.remove());\\n                while(!pq.isEmpty() && mat[pq.peek()][i] == mat[from.get(0)][i]) {\\n                    from.add(pq.remove());\\n                }\\n            while(!pq.isEmpty()) {\\n                List<Integer> to = new ArrayList<>();\\n                to.add(pq.remove());\\n                while(!pq.isEmpty() && mat[pq.peek()][i] == mat[to.get(0)][i]) {\\n                    to.add(pq.remove());\\n                }\\n                for(int ii = 0; ii < from.size(); ii++) {\\n                    for(int j = 0; j < to.size(); j++) {\\n                        graph[from.get(ii)][i].add(new int[]{to.get(j), i});\\n                    }\\n                }\\n                from = to;\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!visited[i][j]) {\\n                    result = Math.max(result, dfs(i, j));\\n                } else {\\n                    result = Math.max(result, values[i][j]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    int dfs(int r, int c) {\\n        visited[r][c] = true;\\n        int result = 1;\\n        for(int[] next : graph[r][c]) {\\n            if(!visited[next[0]][next[1]]) {\\n                result = Math.max(result, dfs(next[0], next[1])+1);\\n            } else {\\n                result = Math.max(result, values[next[0]][next[1]]+1);\\n            }\\n        }\\n        values[r][c] = result;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570759,
                "title": "c-solution-i-got-in-16-min",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        const int m = mat.size(), n = mat[0].size();\\n        vector<int> r(m), c(n);\\n        unordered_map<int, vector<vector<int>>> vmap;\\n        vector<vector<int>> temp(m, vector<int>(n));\\n        set<int> s;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vmap[-mat[i][j]].push_back({i, j});\\n                s.insert(-mat[i][j]);\\n            }\\n            \\n        }\\n        for (int x : s) {\\n            for (const auto& v : vmap[x]) {\\n                temp[v[0]][v[1]] = max(r[v[0]], c[v[1]]) + 1;\\n            }\\n            for (const auto& v : vmap[x]) {\\n                r[v[0]] = max(r[v[0]], temp[v[0]][v[1]]);\\n                c[v[1]] = max(c[v[1]], temp[v[0]][v[1]]);\\n            }   \\n        }\\n        return max(*max_element(r.begin(), r.end()), *max_element(c.begin(), c.end()));\\n        \\n    }\\n};\\n     \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        const int m = mat.size(), n = mat[0].size();\\n        vector<int> r(m), c(n);\\n        unordered_map<int, vector<vector<int>>> vmap;\\n        vector<vector<int>> temp(m, vector<int>(n));\\n        set<int> s;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vmap[-mat[i][j]].push_back({i, j});\\n                s.insert(-mat[i][j]);\\n            }\\n            \\n        }\\n        for (int x : s) {\\n            for (const auto& v : vmap[x]) {\\n                temp[v[0]][v[1]] = max(r[v[0]], c[v[1]]) + 1;\\n            }\\n            for (const auto& v : vmap[x]) {\\n                r[v[0]] = max(r[v[0]], temp[v[0]][v[1]]);\\n                c[v[1]] = max(c[v[1]], temp[v[0]][v[1]]);\\n            }   \\n        }\\n        return max(*max_element(r.begin(), r.end()), *max_element(c.begin(), c.end()));\\n        \\n    }\\n};\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570261,
                "title": "c-dp-on-values",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        n=mat.size(),m=mat[0].size();\\n        \\n        map<int,vector<pair<int,int>>> val;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                val[mat[i][j]+100000].push_back({i,j});\\n            }\\n        }\\n        int ans=0;\\n        vector<int> arow(n,0),acol(m,0);\\n        for(auto i:val){\\n            vector<pair<int,int>> row,col;\\n            for(auto p:i.second){\\n                int x=max(arow[p.first],acol[p.second])+1;\\n                ans=max(ans,x);\\n                row.push_back({p.first,x});\\n                col.push_back({p.second,x});\\n            }\\n            for(auto p:row){\\n                arow[p.first]=max(arow[p.first],p.second);\\n            }\\n            for(auto p:col){\\n                acol[p.first]=max(acol[p.first],p.second);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        n=mat.size(),m=mat[0].size();\\n        \\n        map<int,vector<pair<int,int>>> val;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                val[mat[i][j]+100000].push_back({i,j});\\n            }\\n        }\\n        int ans=0;\\n        vector<int> arow(n,0),acol(m,0);\\n        for(auto i:val){\\n            vector<pair<int,int>> row,col;\\n            for(auto p:i.second){\\n                int x=max(arow[p.first],acol[p.second])+1;\\n                ans=max(ans,x);\\n                row.push_back({p.first,x});\\n                col.push_back({p.second,x});\\n            }\\n            for(auto p:row){\\n                arow[p.first]=max(arow[p.first],p.second);\\n            }\\n            for(auto p:col){\\n                acol[p.first]=max(acol[p.first],p.second);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570198,
                "title": "optimized-longest-path-in-a-dag",
                "content": "# Intuition\\nThe problem is a longest path problem, which is usually NP-hard on an arbitrary graph.\\n\\nHowever, there is a polynomial time solution for the longest path on a DAG, so considering the longest path on a DAG seems to have potential.\\n\\nIndeed, we may notice that the graph generated by this problem is in fact a DAG. Moreover, we can topologically sort this DAG by sorting by value.\\n\\n# Approach\\nNormally, finding the longest path on a DAG results from topologically sorting vertices then looping through vertices in topological order, updating the longest path to any given vertex as we go. This is $$O(v+e)$$, where $$v$$ is the number of vertices and $$e$$ is the number of edges. While the number of vertices in this problem is $$nm$$, we could have up to $$O(nm\\\\cdot\\\\max(m, n))$$ edges, which is too slow.\\n\\nOur optimization comes from noting that we can only jump parallel to rows and columns. Thus, instead of keeping track of the longest path to each individual vertex, we can keep track of the longest path to any given row or column. When updating the longest path of a given vertex, we just need to look at the maximum longest path in the vertex\\'s row or column, which is $$O(1)$$ time compared to looping through the entire row or column, which is $O(\\\\max(m, n))$ time.\\n\\nThere is one final thing to note: we cannot simply loop through and update the vertices in topological order using the above optimization, as it may be the case that two vertices with the same value and in the same row/column add to the respective longest path of the row/column twice instead of just once. To fix this, we store any changes vertices with the same value make, then update all the vertices concurrently once we have processed all vertices of the same value.\\n\\n# Complexity\\n- Time complexity: $$O(nm\\\\log(nm))$$\\n\\n- Space complexity: $$O(nm)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        # useful constants\\n        m, n = len(mat), len(mat[0])\\n        \\n        # topological sort\\n        topological = sorted(((i, j) for i, j in product(range(m), range(n))), key=lambda p: mat[p[0]][p[1]])\\n        \\n        # stores the current longest path in the respective row/column\\n        res_r = [0] * m\\n        res_c = [0] * n\\n        \\n        i = 0\\n        while i < len(topological):\\n            # keep track of vertices of the same value to update all at once later\\n            to_update = {}\\n\\n            # process vertices of same value\\n            a, b = topological[i]\\n            longest = max(res_c[b] + 1, res_r[a] + 1)\\n            to_update[topological[i]] = longest\\n            i += 1\\n            while i < len(top) and mat[topological[i][0]][topological[i][1]] == mat[topological[i - 1][0]][topological[i - 1][1]]:\\n                a, b = topological[i]\\n                longest = max(res_c[b] + 1, res_r[a] + 1)\\n                to_update[topological[i]] = longest\\n                i += 1\\n            \\n            # update vertices of same value concurrently\\n            for vertex, longest in to_update.items():\\n                res_r[vertex[0]] = max(longest, res_r[vertex[0]])\\n                res_c[vertex[1]] = max(longest, res_c[vertex[1]])\\n\\n        return max(*res_r, *res_c)\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        # useful constants\\n        m, n = len(mat), len(mat[0])\\n        \\n        # topological sort\\n        topological = sorted(((i, j) for i, j in product(range(m), range(n))), key=lambda p: mat[p[0]][p[1]])\\n        \\n        # stores the current longest path in the respective row/column\\n        res_r = [0] * m\\n        res_c = [0] * n\\n        \\n        i = 0\\n        while i < len(topological):\\n            # keep track of vertices of the same value to update all at once later\\n            to_update = {}\\n\\n            # process vertices of same value\\n            a, b = topological[i]\\n            longest = max(res_c[b] + 1, res_r[a] + 1)\\n            to_update[topological[i]] = longest\\n            i += 1\\n            while i < len(top) and mat[topological[i][0]][topological[i][1]] == mat[topological[i - 1][0]][topological[i - 1][1]]:\\n                a, b = topological[i]\\n                longest = max(res_c[b] + 1, res_r[a] + 1)\\n                to_update[topological[i]] = longest\\n                i += 1\\n            \\n            # update vertices of same value concurrently\\n            for vertex, longest in to_update.items():\\n                res_r[vertex[0]] = max(longest, res_r[vertex[0]])\\n                res_c[vertex[1]] = max(longest, res_c[vertex[1]])\\n\\n        return max(*res_r, *res_c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046944,
                "title": "walk-backward-from-largest-value-to-smallest-keep-track-of-the-best-path",
                "content": "In this problem it is important to notice that one can jump to `any` cell in a current row or colum, as long as next cell value is larger than current. \\nThis problem can be solved walking from smaller element to every possible larger element (dfs), or backward, from larger to smaller (dp).\\n\\nThe simplest, non optimized solution for dfs would be to try picking every possible cell as initial one, and see if you can jump into any other cell in a given row or column. Once you reach dead end, memorize the answer for the cell, and return to caller. To determine wich cell is eligible, you would either have to do linear scan or assist you with a clever precomuted array that sorts all elements in each row, then separate array that sorts elements in each column and allows you to lookup position of the value in the original matrix. This way you can eliminate the need for scan.\\n\\nYou can see, dfs solution recursively reaches the largest possible value first, and then returns to the caller memorizing the depth on the way back.\\n\\nWe can use this fact to solve this problem backward. If we process all largest values in the arrays first, we can memorize their contribution in a given column and row the value located at before we move on to the second largest. In other words, at each step we move from larger value to smaller, lookup position of this smaller value in original matrix and use previous step (bigger value) to determine if there is a solution for given row and column, since we guarantee that previous value was larger and we are allowed to go there. The trick is to memorize if we can go from current value (smaller) to the previous (biggest one)\\n\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        # Note: You can jump to `any` cell in the row or column, not just adjacent\\n        M = len(mat)\\n        N = len(mat[0])\\n \\n        # build position(s) lookup of a specific values\\n        valuePositionLookup = defaultdict(deque)\\n        for r in range(M):\\n            for c in range(N):\\n                val = mat[r][c]\\n                valuePositionLookup[val].append((r,c))\\n                \\n        # We can look at this problem backwards. \\n        # What is the maximum path we can build if we start with largest element? \\n        # Just one, element itself, we can\\'t move anywhere\\n        # What about second largest number? Given postion of second largest number, we can\\n        # only move up-down or left-right to the next largest element that we already processed\\n        # in the previous step. We just need to know if there is such value in given row or column,\\n        # so we need to track this information from previous step.\\n        sortedValues = reversed(sorted(valuePositionLookup.keys()))\\n        \\n        biggerValueR = defaultdict(int)\\n        biggerValueC = defaultdict(int)\\n        for smallerValue in sortedValues:\\n            smalerValueR = defaultdict(int)\\n            smalerValueC = defaultdict(int)\\n            # retrieve locations of this value in the matrix\\n            for r, c in valuePositionLookup[smallerValue]:\\n                # since we can only move within row or column, \\n                # compute max path we can achive by jumping to the next value in a given row or col\\n                longestPath = 1 + max(\\n\\t\\t\\t\\t\\tbiggerValueR[r], # checks if bigger value from prevoius step was in the same row\\n\\t\\t\\t\\t\\tbiggerValueC[c] # similar with the column\\n\\t\\t\\t\\t)\\n                smalerValueR[r] = max(smalerValueR[r], longestPath)\\n                smalerValueC[c] = max(smalerValueC[c], longestPath)\\n\\n            # copy new result into prev value array\\n            biggerValueR.update(smalerValueR)\\n            biggerValueC.update(smalerValueC)\\n            \\n        return max(max(biggerValueR.values()), max(biggerValueC.values()))\\n\\t\\t\\n\\t\\tCredit to mdakram28 post\\n\\t\\thttps://leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/discuss/3570677\\n\\t\\t",
                "solutionTags": [],
                "code": "In this problem it is important to notice that one can jump to `any` cell in a current row or colum, as long as next cell value is larger than current. \\nThis problem can be solved walking from smaller element to every possible larger element (dfs), or backward, from larger to smaller (dp).\\n\\nThe simplest, non optimized solution for dfs would be to try picking every possible cell as initial one, and see if you can jump into any other cell in a given row or column. Once you reach dead end, memorize the answer for the cell, and return to caller. To determine wich cell is eligible, you would either have to do linear scan or assist you with a clever precomuted array that sorts all elements in each row, then separate array that sorts elements in each column and allows you to lookup position of the value in the original matrix. This way you can eliminate the need for scan.\\n\\nYou can see, dfs solution recursively reaches the largest possible value first, and then returns to the caller memorizing the depth on the way back.\\n\\nWe can use this fact to solve this problem backward. If we process all largest values in the arrays first, we can memorize their contribution in a given column and row the value located at before we move on to the second largest. In other words, at each step we move from larger value to smaller, lookup position of this smaller value in original matrix and use previous step (bigger value) to determine if there is a solution for given row and column, since we guarantee that previous value was larger and we are allowed to go there. The trick is to memorize if we can go from current value (smaller) to the previous (biggest one)\\n\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        # Note: You can jump to `any` cell in the row or column, not just adjacent\\n        M = len(mat)\\n        N = len(mat[0])\\n \\n        # build position(s) lookup of a specific values\\n        valuePositionLookup = defaultdict(deque)\\n        for r in range(M):\\n            for c in range(N):\\n                val = mat[r][c]\\n                valuePositionLookup[val].append((r,c))\\n                \\n        # We can look at this problem backwards. \\n        # What is the maximum path we can build if we start with largest element? \\n        # Just one, element itself, we can\\'t move anywhere\\n        # What about second largest number? Given postion of second largest number, we can\\n        # only move up-down or left-right to the next largest element that we already processed\\n        # in the previous step. We just need to know if there is such value in given row or column,\\n        # so we need to track this information from previous step.\\n        sortedValues = reversed(sorted(valuePositionLookup.keys()))\\n        \\n        biggerValueR = defaultdict(int)\\n        biggerValueC = defaultdict(int)\\n        for smallerValue in sortedValues:\\n            smalerValueR = defaultdict(int)\\n            smalerValueC = defaultdict(int)\\n            # retrieve locations of this value in the matrix\\n            for r, c in valuePositionLookup[smallerValue]:\\n                # since we can only move within row or column, \\n                # compute max path we can achive by jumping to the next value in a given row or col\\n                longestPath = 1 + max(\\n\\t\\t\\t\\t\\tbiggerValueR[r], # checks if bigger value from prevoius step was in the same row\\n\\t\\t\\t\\t\\tbiggerValueC[c] # similar with the column\\n\\t\\t\\t\\t)\\n                smalerValueR[r] = max(smalerValueR[r], longestPath)\\n                smalerValueC[c] = max(smalerValueC[c], longestPath)\\n\\n            # copy new result into prev value array\\n            biggerValueR.update(smalerValueR)\\n            biggerValueC.update(smalerValueC)\\n            \\n        return max(max(biggerValueR.values()), max(biggerValueC.values()))\\n\\t\\t\\n\\t\\tCredit to mdakram28 post\\n\\t\\thttps://leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/discuss/3570677\\n\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 3996184,
                "title": "java-easy-to-understand-solution-using-treemaps",
                "content": "# Intuition\\nWe just need to add smallest elements greater than current for the row and column. Since that will give us the most number of steps we can take.\\n\\nBuild a DAG by adding elements as neighbors that are the smallest numbers greater than current. Yes, \"numbers\" here was not a typo. We need to add all duplicates since any of them could be the most optimal path to maximum value.\\nI used TreeMaps to achieve logarithmic time complexity to get smallest elements greater than current for each row and column. Once the graph is built, its pretty straight forward dfs. \\n\\n# Complexity\\n- Time complexity: O(n*m*log(n*m))\\n\\n- Space complexity: O(nm)\\n\\n# Code\\n```\\nclass Node {\\n    int val, max;\\n    HashSet<Node> neighbors;\\n\\n    public Node(int val){\\n        this.val = val;\\n        this.max = 1;\\n        this.neighbors = new HashSet<>();\\n    }\\n}\\nclass Solution {\\n    Node[][] nodeMat;\\n\\n    public int maxIncreasingCells(int[][] mat) {\\n        nodeMat = new Node[mat.length][mat[0].length];\\n\\n        // build graph\\n        for(int i=0; i<mat.length; i++){\\n            buildRow(mat[i], i);\\n        }\\n        for(int i=0; i<mat[0].length; i++){\\n            buildCol(mat, i);\\n        }\\n\\n        int maxResult = 1;\\n        HashSet<Node> visited = new HashSet<>();\\n        for(Node[] row : nodeMat){\\n            for(Node n : row){\\n                maxResult = Math.max(processNode(n, visited), maxResult);\\n            }\\n        }\\n        \\n        return maxResult;\\n    }\\n\\n    // get Max traversal from node n\\n    private int processNode(Node n, HashSet<Node> visited){\\n        if(n==null) return 0;\\n        if(visited.contains(n)) return n.max;\\n        for(Node neigh : n.neighbors){\\n            n.max = Math.max(n.max, processNode(neigh, visited)+1);\\n        }\\n        visited.add(n);\\n        return n.max;\\n    }\\n\\n    // for each element in the row, add smallest element larger than current\\n    // Note: smallest element can be multiple duplicates - we would need to add all to the neighbors\\n    private void buildRow(int[] row, int r){\\n        TreeMap<Integer, Node> map = new TreeMap<>();\\n        HashMap<Integer, List<Node>> duplicates = new HashMap<>();\\n        for(int i=0; i<row.length; i++){\\n            Node n = new Node(row[i]);\\n            nodeMat[r][i] = n;\\n            if(map.containsKey(row[i])){\\n                List<Node> dupList = duplicates.getOrDefault(row[i], new ArrayList<>());\\n                dupList.add(n);\\n                duplicates.put(row[i], dupList);\\n            }\\n            else\\n                map.put(row[i], n);\\n        }\\n        for(Node curr : nodeMat[r]){\\n            addNeighbors(curr, map, duplicates);\\n        }\\n    }\\n\\n    // similar to building row but for columns\\n    private void buildCol(int[][] mat, int col){\\n        TreeMap<Integer, Node> map = new TreeMap<>();\\n        HashMap<Integer, List<Node>> duplicates = new HashMap<>();\\n        for(int i=0; i<mat.length; i++){\\n            Node n = nodeMat[i][col];\\n            if(map.containsKey(mat[i][col])){\\n                List<Node> dupList = duplicates.getOrDefault(mat[i][col], new ArrayList<>());\\n                dupList.add(n);\\n                duplicates.put(mat[i][col], dupList);\\n            }\\n            else \\n                map.put(mat[i][col], n);\\n        }\\n        for(int i=0; i<mat.length; i++){\\n            addNeighbors(nodeMat[i][col], map, duplicates);\\n        }   \\n    }\\n\\n    // helper function to add neighbors for node n given the row/col\\'s treemap and duplicates\\n    private void addNeighbors(Node n, TreeMap<Integer,Node> map,HashMap<Integer, List<Node>> duplicates) {\\n        int num = n.val;\\n        Integer higherNum  = map.ceilingKey(num+1);\\n        if(higherNum != null){\\n            n.neighbors.add(map.get(higherNum));\\n            if(duplicates.containsKey(higherNum)){\\n                for(Node neigh : duplicates.get(higherNum)){\\n                    if(n!=neigh)\\n                        n.neighbors.add(neigh);\\n                }\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node {\\n    int val, max;\\n    HashSet<Node> neighbors;\\n\\n    public Node(int val){\\n        this.val = val;\\n        this.max = 1;\\n        this.neighbors = new HashSet<>();\\n    }\\n}\\nclass Solution {\\n    Node[][] nodeMat;\\n\\n    public int maxIncreasingCells(int[][] mat) {\\n        nodeMat = new Node[mat.length][mat[0].length];\\n\\n        // build graph\\n        for(int i=0; i<mat.length; i++){\\n            buildRow(mat[i], i);\\n        }\\n        for(int i=0; i<mat[0].length; i++){\\n            buildCol(mat, i);\\n        }\\n\\n        int maxResult = 1;\\n        HashSet<Node> visited = new HashSet<>();\\n        for(Node[] row : nodeMat){\\n            for(Node n : row){\\n                maxResult = Math.max(processNode(n, visited), maxResult);\\n            }\\n        }\\n        \\n        return maxResult;\\n    }\\n\\n    // get Max traversal from node n\\n    private int processNode(Node n, HashSet<Node> visited){\\n        if(n==null) return 0;\\n        if(visited.contains(n)) return n.max;\\n        for(Node neigh : n.neighbors){\\n            n.max = Math.max(n.max, processNode(neigh, visited)+1);\\n        }\\n        visited.add(n);\\n        return n.max;\\n    }\\n\\n    // for each element in the row, add smallest element larger than current\\n    // Note: smallest element can be multiple duplicates - we would need to add all to the neighbors\\n    private void buildRow(int[] row, int r){\\n        TreeMap<Integer, Node> map = new TreeMap<>();\\n        HashMap<Integer, List<Node>> duplicates = new HashMap<>();\\n        for(int i=0; i<row.length; i++){\\n            Node n = new Node(row[i]);\\n            nodeMat[r][i] = n;\\n            if(map.containsKey(row[i])){\\n                List<Node> dupList = duplicates.getOrDefault(row[i], new ArrayList<>());\\n                dupList.add(n);\\n                duplicates.put(row[i], dupList);\\n            }\\n            else\\n                map.put(row[i], n);\\n        }\\n        for(Node curr : nodeMat[r]){\\n            addNeighbors(curr, map, duplicates);\\n        }\\n    }\\n\\n    // similar to building row but for columns\\n    private void buildCol(int[][] mat, int col){\\n        TreeMap<Integer, Node> map = new TreeMap<>();\\n        HashMap<Integer, List<Node>> duplicates = new HashMap<>();\\n        for(int i=0; i<mat.length; i++){\\n            Node n = nodeMat[i][col];\\n            if(map.containsKey(mat[i][col])){\\n                List<Node> dupList = duplicates.getOrDefault(mat[i][col], new ArrayList<>());\\n                dupList.add(n);\\n                duplicates.put(mat[i][col], dupList);\\n            }\\n            else \\n                map.put(mat[i][col], n);\\n        }\\n        for(int i=0; i<mat.length; i++){\\n            addNeighbors(nodeMat[i][col], map, duplicates);\\n        }   \\n    }\\n\\n    // helper function to add neighbors for node n given the row/col\\'s treemap and duplicates\\n    private void addNeighbors(Node n, TreeMap<Integer,Node> map,HashMap<Integer, List<Node>> duplicates) {\\n        int num = n.val;\\n        Integer higherNum  = map.ceilingKey(num+1);\\n        if(higherNum != null){\\n            n.neighbors.add(map.get(higherNum));\\n            if(duplicates.containsKey(higherNum)){\\n                for(Node neigh : duplicates.get(higherNum)){\\n                    if(n!=neigh)\\n                        n.neighbors.add(neigh);\\n                }\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986930,
                "title": "top-down-c-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(mnlog(n) + mnlog(m))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(mn)$$\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int i, int j, const vector<vector<int>>& mat, vector<vector<pair<int,int>>>& rows, vector<vector<pair<int,int>>>& cols, vector<vector<int>>& max_cells, vector<vector<bool>>& visited) {\\n        if (visited[i][j]) {\\n            return;\\n        }\\n        int ans = 1;\\n        auto row_begin = upper_bound(rows[i].begin(), rows[i].end(), pair<int,int>(mat[i][j], INT_MAX));\\n        auto col_begin = upper_bound(cols[j].begin(), cols[j].end(), pair<int,int>(mat[i][j], INT_MAX));\\n        auto row_itr = row_begin;\\n        auto col_itr = col_begin;\\n        while (row_itr != rows[i].end() && mat[i][row_itr->second] == mat[i][row_begin->second]) {\\n            dfs(i, row_itr->second, mat, rows, cols, max_cells, visited);\\n            ans = max(ans, 1 + max_cells[i][row_itr->second]);\\n            row_itr++;\\n        }\\n        while (col_itr != cols[j].end() && mat[col_itr->second][j] == mat[col_begin->second][j]) {\\n            dfs(col_itr->second, j, mat, rows, cols, max_cells, visited);\\n            ans = max(ans, 1 + max_cells[col_itr->second][j]);\\n            col_itr++;\\n        }\\n        max_cells[i][j] = ans;\\n        visited[i][j] = true;\\n    }\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> max_cells(m, vector<int>(n));\\n        vector<vector<bool>> visited(m, vector<bool>(n));\\n        vector<vector<pair<int,int>>> rows(m);\\n        vector<vector<pair<int,int>>> cols(n);\\n        int ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rows[i].push_back({mat[i][j], j});\\n                cols[j].push_back({mat[i][j], i});\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            sort(rows[i].begin(), rows[i].end());\\n        }\\n        for (int j = 0; j < n; j++) {\\n            sort(cols[j].begin(), cols[j].end());\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dfs(i, j, mat, rows, cols, max_cells, visited);\\n                ans = max(ans, max_cells[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int j, const vector<vector<int>>& mat, vector<vector<pair<int,int>>>& rows, vector<vector<pair<int,int>>>& cols, vector<vector<int>>& max_cells, vector<vector<bool>>& visited) {\\n        if (visited[i][j]) {\\n            return;\\n        }\\n        int ans = 1;\\n        auto row_begin = upper_bound(rows[i].begin(), rows[i].end(), pair<int,int>(mat[i][j], INT_MAX));\\n        auto col_begin = upper_bound(cols[j].begin(), cols[j].end(), pair<int,int>(mat[i][j], INT_MAX));\\n        auto row_itr = row_begin;\\n        auto col_itr = col_begin;\\n        while (row_itr != rows[i].end() && mat[i][row_itr->second] == mat[i][row_begin->second]) {\\n            dfs(i, row_itr->second, mat, rows, cols, max_cells, visited);\\n            ans = max(ans, 1 + max_cells[i][row_itr->second]);\\n            row_itr++;\\n        }\\n        while (col_itr != cols[j].end() && mat[col_itr->second][j] == mat[col_begin->second][j]) {\\n            dfs(col_itr->second, j, mat, rows, cols, max_cells, visited);\\n            ans = max(ans, 1 + max_cells[col_itr->second][j]);\\n            col_itr++;\\n        }\\n        max_cells[i][j] = ans;\\n        visited[i][j] = true;\\n    }\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> max_cells(m, vector<int>(n));\\n        vector<vector<bool>> visited(m, vector<bool>(n));\\n        vector<vector<pair<int,int>>> rows(m);\\n        vector<vector<pair<int,int>>> cols(n);\\n        int ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rows[i].push_back({mat[i][j], j});\\n                cols[j].push_back({mat[i][j], i});\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            sort(rows[i].begin(), rows[i].end());\\n        }\\n        for (int j = 0; j < n; j++) {\\n            sort(cols[j].begin(), cols[j].end());\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dfs(i, j, mat, rows, cols, max_cells, visited);\\n                ans = max(ans, max_cells[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982964,
                "title": "sort-binarysearch-memoize",
                "content": "```\\nclass Solution {\\n    int ROW;\\n    int COL;\\n    struct element{\\n      int val;\\n        int index;\\n        element(int v, int i) : val(v), index(i){}\\n        bool operator<(const element& other) const\\n        {\\n            return val < other.val;\\n        }\\n    };\\n    \\n    int process(int r, int c, vector<vector<element>>& rowWise, vector<vector<element>>& colWise, vector<vector<int>>& mat, vector<vector<int>>& cache)\\n    {\\n        if(cache[r][c] != -1)\\n            return cache[r][c];\\n        \\n        int value = mat[r][c];\\n        auto itr = upper_bound(rowWise[r].begin(), rowWise[r].end(), element(value, c));\\n        int ret{};\\n        while(itr != rowWise[r].end())\\n        {\\n            auto res = process(r, itr->index, rowWise, colWise, mat, cache);\\n            ret = max(ret, res);\\n            auto nItr = next(itr);\\n            if(nItr != rowWise[r].end() && nItr->val == itr->val)\\n                itr = nItr;\\n            else break;\\n        }\\n        \\n        auto itr2 = upper_bound(colWise[c].begin(), colWise[c].end(), element(value, r));\\n        while(itr2 != colWise[c].end())\\n        {\\n            auto res = process(itr2->index, c, rowWise, colWise, mat, cache);\\n            ret = max(ret, res);\\n            auto nItr = next(itr2);\\n            if(nItr != colWise[c].end() && nItr->val == itr2->val)\\n                itr2 = nItr;\\n            else break;\\n        }\\n        \\n        return cache[r][c] = ret + 1;\\n    }\\n    \\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        ROW = mat.size();\\n        COL = mat[0].size();\\n        vector<vector<int>> cache(ROW, vector<int>(COL, -1));\\n        vector<vector<element>> rowWise(ROW, vector<element>());\\n        vector<vector<element>> colWise(COL, vector<element>());\\n        for(int i=0; i<ROW; i++)\\n        {\\n            for(int j=0; j<COL; j++)\\n            {\\n                rowWise[i].push_back(element(mat[i][j], j));\\n                colWise[j].push_back(element(mat[i][j], i));\\n            }\\n            sort(rowWise[i].begin(), rowWise[i].end());\\n        }\\n        for(int i=0; i<COL; i++)\\n            sort(colWise[i].begin(), colWise[i].end());\\n        \\n        int maxCount{};\\n        for(int i=0; i<ROW; i++)\\n        {\\n            for(int j=0; j<COL; j++)\\n            {\\n                if(cache[i][j] == -1)\\n                {\\n                    process(i, j, rowWise, colWise, mat, cache);\\n                }  \\n                maxCount = max(maxCount, cache[i][j]);\\n            }\\n        }\\n        return maxCount;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ROW;\\n    int COL;\\n    struct element{\\n      int val;\\n        int index;\\n        element(int v, int i) : val(v), index(i){}\\n        bool operator<(const element& other) const\\n        {\\n            return val < other.val;\\n        }\\n    };\\n    \\n    int process(int r, int c, vector<vector<element>>& rowWise, vector<vector<element>>& colWise, vector<vector<int>>& mat, vector<vector<int>>& cache)\\n    {\\n        if(cache[r][c] != -1)\\n            return cache[r][c];\\n        \\n        int value = mat[r][c];\\n        auto itr = upper_bound(rowWise[r].begin(), rowWise[r].end(), element(value, c));\\n        int ret{};\\n        while(itr != rowWise[r].end())\\n        {\\n            auto res = process(r, itr->index, rowWise, colWise, mat, cache);\\n            ret = max(ret, res);\\n            auto nItr = next(itr);\\n            if(nItr != rowWise[r].end() && nItr->val == itr->val)\\n                itr = nItr;\\n            else break;\\n        }\\n        \\n        auto itr2 = upper_bound(colWise[c].begin(), colWise[c].end(), element(value, r));\\n        while(itr2 != colWise[c].end())\\n        {\\n            auto res = process(itr2->index, c, rowWise, colWise, mat, cache);\\n            ret = max(ret, res);\\n            auto nItr = next(itr2);\\n            if(nItr != colWise[c].end() && nItr->val == itr2->val)\\n                itr2 = nItr;\\n            else break;\\n        }\\n        \\n        return cache[r][c] = ret + 1;\\n    }\\n    \\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        ROW = mat.size();\\n        COL = mat[0].size();\\n        vector<vector<int>> cache(ROW, vector<int>(COL, -1));\\n        vector<vector<element>> rowWise(ROW, vector<element>());\\n        vector<vector<element>> colWise(COL, vector<element>());\\n        for(int i=0; i<ROW; i++)\\n        {\\n            for(int j=0; j<COL; j++)\\n            {\\n                rowWise[i].push_back(element(mat[i][j], j));\\n                colWise[j].push_back(element(mat[i][j], i));\\n            }\\n            sort(rowWise[i].begin(), rowWise[i].end());\\n        }\\n        for(int i=0; i<COL; i++)\\n            sort(colWise[i].begin(), colWise[i].end());\\n        \\n        int maxCount{};\\n        for(int i=0; i<ROW; i++)\\n        {\\n            for(int j=0; j<COL; j++)\\n            {\\n                if(cache[i][j] == -1)\\n                {\\n                    process(i, j, rowWise, colWise, mat, cache);\\n                }  \\n                maxCount = max(maxCount, cache[i][j]);\\n            }\\n        }\\n        return maxCount;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979990,
                "title": "java-easy-2-understand-treemap-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m=mat.length, n=mat[0].length;\\n        TreeMap<Integer, List<int[]>> indexMap=new TreeMap<>();\\n        int[] rowMax=new int[m];\\n        int[] colMax=new int[n];\\n        int[][] dp=new int[m][n];\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                // treemap sorts in increasing order, so negation of max is min(decreasing sorting)\\n                int val=-mat[i][j];\\n                List<int[]> coordinates=new ArrayList<>(indexMap.getOrDefault(val, new ArrayList<>()));\\n                coordinates.add(new int[]{i, j});\\n                indexMap.put(val, coordinates);\\n            }\\n        }\\n\\n        int maxPathSize=0;\\n        for(Integer val: indexMap.keySet()){\\n                for(int[] coordinate: indexMap.get(val)){\\n                    int row=coordinate[0], col=coordinate[1];\\n                    dp[row][col]=Math.max(rowMax[row], colMax[col])+1;\\n                    maxPathSize=Math.max(maxPathSize, dp[row][col]);\\n                }\\n           \\n                for(int[] coordinate: indexMap.get(val)){\\n                    int row=coordinate[0], col=coordinate[1];\\n                    rowMax[row]=Math.max(rowMax[row], dp[row][col]);\\n                    colMax[col]=Math.max(colMax[col], dp[row][col]);\\n                }\\n        }\\n        return maxPathSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m=mat.length, n=mat[0].length;\\n        TreeMap<Integer, List<int[]>> indexMap=new TreeMap<>();\\n        int[] rowMax=new int[m];\\n        int[] colMax=new int[n];\\n        int[][] dp=new int[m][n];\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                // treemap sorts in increasing order, so negation of max is min(decreasing sorting)\\n                int val=-mat[i][j];\\n                List<int[]> coordinates=new ArrayList<>(indexMap.getOrDefault(val, new ArrayList<>()));\\n                coordinates.add(new int[]{i, j});\\n                indexMap.put(val, coordinates);\\n            }\\n        }\\n\\n        int maxPathSize=0;\\n        for(Integer val: indexMap.keySet()){\\n                for(int[] coordinate: indexMap.get(val)){\\n                    int row=coordinate[0], col=coordinate[1];\\n                    dp[row][col]=Math.max(rowMax[row], colMax[col])+1;\\n                    maxPathSize=Math.max(maxPathSize, dp[row][col]);\\n                }\\n           \\n                for(int[] coordinate: indexMap.get(val)){\\n                    int row=coordinate[0], col=coordinate[1];\\n                    rowMax[row]=Math.max(rowMax[row], dp[row][col]);\\n                    colMax[col]=Math.max(colMax[col], dp[row][col]);\\n                }\\n        }\\n        return maxPathSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973823,
                "title": "typescript-sorting-binary-search-easy-to-understand-but-not-optimal",
                "content": "# Intuition\\n1) Sort the array\\'s rows (**sortedRows**) and sort the array\\'s columns (**sortedColumns**). We\\'ll create a wrapper object that goes into these arrays that will point to the original index.\\n\\n2) Build a dp[row][column] that stores the count for a cell so we don\\'t revisit the same cell.\\n\\n3) Visit every cell (This could be optimized. I think you only need to visit the smallest cell(s) in each row/column but I was to lazy to change that :/)\\n\\n4) At at each cell we need to make sure we\\'ve never visited it before, if we have haven\\'t we +1 our count for this run, and visit the next highest cell in the same row, or same column. Note, there could be duplicates hence we may need to visit more than one for each row or column. We retain the max of these visits.\\n\\n# Complexity\\n- time complexity\\nO(n*m log (n*m)\\n\\n- Space complexity:\\nn*m)\\n\\n# Code\\n```\\ninterface ValueNode {\\n    row: number;\\n    column: number;\\n    value: number;\\n}\\n\\nfunction maxIncreasingCells(mat: number[][]): number {\\n    const rows = mat.length;\\n    const columns = mat[0].length;\\n    const dp: number[][] = [];\\n    const sortedRows: ValueNode[][] = [];\\n    const sortedColumns: ValueNode[][] = [];\\n\\n    for (let i = 0; i < rows; i++) {\\n        dp.push(new Array(columns).fill(undefined));\\n        sortedRows.push([]);\\n    }\\n\\n    for (let i = 0; i < columns; i++) {\\n        sortedColumns.push([]);\\n    }\\n\\n    for (let i = 0; i < rows; i++) {\\n        const sortedRow: ValueNode[] = sortedRows[i];\\n        for (let j = 0; j < columns; j++) {\\n            const sortedColumn: ValueNode[] = sortedColumns[j];\\n            const valueNode: ValueNode = {\\n                row: i,\\n                column: j,\\n                value: mat[i][j]\\n            }\\n            sortedRow.push(valueNode);\\n            sortedColumn.push(valueNode);\\n        }\\n        sortedRow.sort((a, b) => a.value - b.value);\\n    }\\n\\n    for (let i = 0; i < columns; i++) {\\n        sortedColumns[i].sort((a, b) => a.value - b.value);\\n    }\\n\\n\\n    // Iterate over every cell. \\n    // Not optimal. We probably only need to iterate the smallest cell in each row, column (which there could be duplicate smallest values)\\n    let max = 0;\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < columns; j++) {\\n            const result = maxIncreasingCellsDP(i, j, dp, sortedRows, sortedColumns, mat);\\n            max = Math.max(max, result);\\n        }\\n    }\\n\\n    return max;\\n};\\n\\nfunction binarySearch(nums: ValueNode[], target: number): number {\\n    let left: number = 0;\\n    let right: number = nums.length - 1;\\n  \\n    while (left <= right) {\\n      const mid: number = Math.floor((left + right) / 2);\\n  \\n      if (nums[mid].value === target) return mid;\\n      if (target < nums[mid].value) right = mid - 1;\\n      else left = mid + 1;\\n    }\\n  \\n    return -1;\\n  }\\n\\n\\nfunction maxIncreasingCellsDP(row: number, column: number, dp: number[][], sortedByRow: ValueNode[][], sortedByColumn: ValueNode[][], mat: number[][]): number {\\n    if (dp[row][column] !== undefined) {\\n        return dp[row][column];\\n    }\\n\\n    const value = mat[row][column];\\n    const sortedRow = sortedByRow[row];\\n    const sortedColumn = sortedByColumn[column];\\n\\n    let result = 1;\\n\\n    let indexInSortedRow = binarySearch(sortedRow, value);\\n    while (indexInSortedRow < sortedRow.length && sortedRow[indexInSortedRow].value === value) {\\n        indexInSortedRow++;\\n    }\\n    if (indexInSortedRow < sortedRow.length) {\\n        const firstlargerNode = sortedRow[indexInSortedRow];\\n        while (indexInSortedRow < sortedRow.length && sortedRow[indexInSortedRow].value === firstlargerNode.value) {\\n            const node = sortedRow[indexInSortedRow];\\n            result = Math.max(result, 1 + maxIncreasingCellsDP(node.row, node.column, dp, sortedByRow, sortedByColumn, mat));\\n            indexInSortedRow++;\\n        }\\n    }\\n\\n    let indexInSortedColumn = binarySearch(sortedColumn, value);\\n    while (indexInSortedColumn < sortedColumn.length && sortedColumn[indexInSortedColumn].value === value) {\\n        indexInSortedColumn++;\\n    }\\n    if (indexInSortedColumn < sortedColumn.length) {\\n        const firstlargerNode = sortedColumn[indexInSortedColumn];\\n        while (indexInSortedColumn < sortedColumn.length && sortedColumn[indexInSortedColumn].value === firstlargerNode.value) {\\n            const node = sortedColumn[indexInSortedColumn];\\n            result = Math.max(result, 1 + maxIncreasingCellsDP(node.row, node.column, dp, sortedByRow, sortedByColumn, mat));\\n            indexInSortedColumn++;\\n        }\\n    }\\n\\n    dp[row][column] = result;\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ninterface ValueNode {\\n    row: number;\\n    column: number;\\n    value: number;\\n}\\n\\nfunction maxIncreasingCells(mat: number[][]): number {\\n    const rows = mat.length;\\n    const columns = mat[0].length;\\n    const dp: number[][] = [];\\n    const sortedRows: ValueNode[][] = [];\\n    const sortedColumns: ValueNode[][] = [];\\n\\n    for (let i = 0; i < rows; i++) {\\n        dp.push(new Array(columns).fill(undefined));\\n        sortedRows.push([]);\\n    }\\n\\n    for (let i = 0; i < columns; i++) {\\n        sortedColumns.push([]);\\n    }\\n\\n    for (let i = 0; i < rows; i++) {\\n        const sortedRow: ValueNode[] = sortedRows[i];\\n        for (let j = 0; j < columns; j++) {\\n            const sortedColumn: ValueNode[] = sortedColumns[j];\\n            const valueNode: ValueNode = {\\n                row: i,\\n                column: j,\\n                value: mat[i][j]\\n            }\\n            sortedRow.push(valueNode);\\n            sortedColumn.push(valueNode);\\n        }\\n        sortedRow.sort((a, b) => a.value - b.value);\\n    }\\n\\n    for (let i = 0; i < columns; i++) {\\n        sortedColumns[i].sort((a, b) => a.value - b.value);\\n    }\\n\\n\\n    // Iterate over every cell. \\n    // Not optimal. We probably only need to iterate the smallest cell in each row, column (which there could be duplicate smallest values)\\n    let max = 0;\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < columns; j++) {\\n            const result = maxIncreasingCellsDP(i, j, dp, sortedRows, sortedColumns, mat);\\n            max = Math.max(max, result);\\n        }\\n    }\\n\\n    return max;\\n};\\n\\nfunction binarySearch(nums: ValueNode[], target: number): number {\\n    let left: number = 0;\\n    let right: number = nums.length - 1;\\n  \\n    while (left <= right) {\\n      const mid: number = Math.floor((left + right) / 2);\\n  \\n      if (nums[mid].value === target) return mid;\\n      if (target < nums[mid].value) right = mid - 1;\\n      else left = mid + 1;\\n    }\\n  \\n    return -1;\\n  }\\n\\n\\nfunction maxIncreasingCellsDP(row: number, column: number, dp: number[][], sortedByRow: ValueNode[][], sortedByColumn: ValueNode[][], mat: number[][]): number {\\n    if (dp[row][column] !== undefined) {\\n        return dp[row][column];\\n    }\\n\\n    const value = mat[row][column];\\n    const sortedRow = sortedByRow[row];\\n    const sortedColumn = sortedByColumn[column];\\n\\n    let result = 1;\\n\\n    let indexInSortedRow = binarySearch(sortedRow, value);\\n    while (indexInSortedRow < sortedRow.length && sortedRow[indexInSortedRow].value === value) {\\n        indexInSortedRow++;\\n    }\\n    if (indexInSortedRow < sortedRow.length) {\\n        const firstlargerNode = sortedRow[indexInSortedRow];\\n        while (indexInSortedRow < sortedRow.length && sortedRow[indexInSortedRow].value === firstlargerNode.value) {\\n            const node = sortedRow[indexInSortedRow];\\n            result = Math.max(result, 1 + maxIncreasingCellsDP(node.row, node.column, dp, sortedByRow, sortedByColumn, mat));\\n            indexInSortedRow++;\\n        }\\n    }\\n\\n    let indexInSortedColumn = binarySearch(sortedColumn, value);\\n    while (indexInSortedColumn < sortedColumn.length && sortedColumn[indexInSortedColumn].value === value) {\\n        indexInSortedColumn++;\\n    }\\n    if (indexInSortedColumn < sortedColumn.length) {\\n        const firstlargerNode = sortedColumn[indexInSortedColumn];\\n        while (indexInSortedColumn < sortedColumn.length && sortedColumn[indexInSortedColumn].value === firstlargerNode.value) {\\n            const node = sortedColumn[indexInSortedColumn];\\n            result = Math.max(result, 1 + maxIncreasingCellsDP(node.row, node.column, dp, sortedByRow, sortedByColumn, mat));\\n            indexInSortedColumn++;\\n        }\\n    }\\n\\n    dp[row][column] = result;\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3967077,
                "title": "python-3-using-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        minHeap = []\\n\\n        for i in range(0, len(mat)):\\n            for j in range(0 ,len(mat[0])):\\n                heapq.heappush(minHeap , (mat[i][j], i , j))\\n        \\n        \\n        dp = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n\\n        rowMax = [0]*len(mat)\\n        colMax = [0]*len(mat[0])\\n\\n        while minHeap:\\n            #case for handling duplcars\\n            val , r , c = heapq.heappop(minHeap)\\n    \\n            idx = [(r, c)]\\n    \\n            while minHeap and minHeap[0][0] == val:\\n                val , r ,c = heapq.heappop(minHeap)\\n                idx.append((r, c))\\n        \\n    \\n            for i , j in idx:\\n                #update dp[i][j]\\n                dp[i][j] = max(rowMax[i] , colMax[j])+1\\n    \\n            for i , j in idx :\\n                rowMax[i] = max(dp[i][j], rowMax[i])\\n                colMax[j] = max(dp[i][j], colMax[j])\\n        \\n\\n        ans = max(rowMax)\\n        ans = max(ans, max(colMax))\\n\\n        return(ans)   \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        minHeap = []\\n\\n        for i in range(0, len(mat)):\\n            for j in range(0 ,len(mat[0])):\\n                heapq.heappush(minHeap , (mat[i][j], i , j))\\n        \\n        \\n        dp = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n\\n        rowMax = [0]*len(mat)\\n        colMax = [0]*len(mat[0])\\n\\n        while minHeap:\\n            #case for handling duplcars\\n            val , r , c = heapq.heappop(minHeap)\\n    \\n            idx = [(r, c)]\\n    \\n            while minHeap and minHeap[0][0] == val:\\n                val , r ,c = heapq.heappop(minHeap)\\n                idx.append((r, c))\\n        \\n    \\n            for i , j in idx:\\n                #update dp[i][j]\\n                dp[i][j] = max(rowMax[i] , colMax[j])+1\\n    \\n            for i , j in idx :\\n                rowMax[i] = max(dp[i][j], rowMax[i])\\n                colMax[j] = max(dp[i][j], colMax[j])\\n        \\n\\n        ans = max(rowMax)\\n        ans = max(ans, max(colMax))\\n\\n        return(ans)   \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927250,
                "title": "js-javascript-dp-with-sort-and-hash-table",
                "content": "# Intuition\\nThe code uses a sorting-based dynamic programming approach to find the maximum count of cells that can be visited within the given constraints, starting from each cell. It sorts cells in descending order of values, maintains DP dictionaries for rows and columns to track the maximum counts achievable, and iterates through cells to update and calculate maximum counts. The final result is the maximum count encountered while considering row and column movement, ensuring that cells are visited in a strictly increasing value order.\\n\\n# Approach\\n1. **Sorting and Initialization**: The code begins by sorting the matrix cells based on their values in descending order. It initializes variables to keep track of the maximum count (max) and creates arrays to store current row and column dynamic programming (DP) information (currRowDp and currColDp).\\n\\n2. **Dynamic Programming Approach**: It uses a dynamic programming approach to track the maximum number of cells that can be visited from each cell. The DP values are stored in dictionaries (rowDp and colDp) where the keys represent row and column indices.\\n\\n3. **Iterating Through Sorted Cells**: It iterates through the sorted cells one by one. When encountering a cell with a different value from the previous one, it updates the DP values (rowDp and colDp) to include the accumulated maximums from the current round of values.\\n\\n4. **Calculating Current Value**: For each cell, it calculates the current maximum value that can be achieved by considering the DP values of the current row and column.\\n\\n5. **Updating DP and Maximum Value**: The code updates the current row and column DP values and tracks the maximum value encountered (max). After iterating through all the cells, it returns the maximum value as the result.\\n\\n# Complexity\\n- Time complexity:\\n$$O(mn)$$\\n\\n- Space complexity:\\n$$O(mnlog(mn))$$\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar maxIncreasingCells = function(mat) {\\n    let max = 0;\\n\\n    const sort = [];\\n\\n    for(let i=0;i<mat.length;i++){\\n        for(let j=0;j<mat[i].length;j++){\\n            sort.push([i,j,mat[i][j]]);\\n        }\\n    }\\n\\n    sort.sort((a,b)=>b[2]-a[2]);\\n\\n    const rowDp = {}; \\n    const colDp = {}; \\n    let prevNum = -Infinity;\\n    \\n    let currRowDp = {};\\n    let currColDp = {};\\n\\n    while(sort.length>0){\\n\\n        const [i,j,num] = sort.pop();\\n        \\n        if(num !== prevNum){\\n\\n            for(let c of Object.keys(currRowDp)){\\n                rowDp[c] = currRowDp[c]\\n            }\\n            for(let c of Object.keys(currColDp)){\\n                colDp[c] = currColDp[c]\\n            }\\n            currRowDp = {};\\n            currColDp = {};\\n        }\\n\\n        let currVal = 0;\\n\\n        currVal = Math.max(currVal, rowDp[i]||0);\\n        currVal = Math.max(currVal, colDp[j]||0);\\n\\n        currVal++;\\n\\n        max = Math.max(currVal, max);\\n        \\n        currRowDp[i] = Math.max(currVal,currRowDp[i]||0);\\n        currColDp[j] = Math.max(currVal,currColDp[j]||0);\\n        prevNum = num;\\n\\n    }\\n\\n    return max;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Dynamic Programming",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar maxIncreasingCells = function(mat) {\\n    let max = 0;\\n\\n    const sort = [];\\n\\n    for(let i=0;i<mat.length;i++){\\n        for(let j=0;j<mat[i].length;j++){\\n            sort.push([i,j,mat[i][j]]);\\n        }\\n    }\\n\\n    sort.sort((a,b)=>b[2]-a[2]);\\n\\n    const rowDp = {}; \\n    const colDp = {}; \\n    let prevNum = -Infinity;\\n    \\n    let currRowDp = {};\\n    let currColDp = {};\\n\\n    while(sort.length>0){\\n\\n        const [i,j,num] = sort.pop();\\n        \\n        if(num !== prevNum){\\n\\n            for(let c of Object.keys(currRowDp)){\\n                rowDp[c] = currRowDp[c]\\n            }\\n            for(let c of Object.keys(currColDp)){\\n                colDp[c] = currColDp[c]\\n            }\\n            currRowDp = {};\\n            currColDp = {};\\n        }\\n\\n        let currVal = 0;\\n\\n        currVal = Math.max(currVal, rowDp[i]||0);\\n        currVal = Math.max(currVal, colDp[j]||0);\\n\\n        currVal++;\\n\\n        max = Math.max(currVal, max);\\n        \\n        currRowDp[i] = Math.max(currVal,currRowDp[i]||0);\\n        currColDp[j] = Math.max(currVal,currColDp[j]||0);\\n        prevNum = num;\\n\\n    }\\n\\n    return max;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915638,
                "title": "python3-o-m-n-logn-logm-memoization-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## Initial O(M * N * (M + N)) Memoization Approach TLE\\n\\n```\\nfrom functools import lru_cache\\nfrom typing import List\\n\\n\\nclass Solution:\\n    # O(n^3) time complexity\\n    # O(n^2) space complexity\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        row, col = len(mat), len(mat[0])\\n\\n        @lru_cache(maxsize=None)\\n        def longestPathLen(i: int, j: int) -> int:\\n            val = mat[i][j]\\n            result = 1\\n            for k in range(row):\\n                if k == i or mat[k][j] <= val:\\n                    continue\\n                result = max(result, 1 + longestPathLen(k, j))\\n            for k in range(col):\\n                if k == j or mat[i][k] <= val:\\n                    continue\\n                result = max(result, 1 + longestPathLen(i, k))\\n\\n            return result\\n\\n        result = 1\\n        for i in range(row):\\n            for j in range(col):\\n                result = max(result, longestPathLen(i, j))\\n\\n        return result\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(M * N * (logN + logM))$$\\n\\n- Space complexity:\\n$$O(M * N)$$\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom functools import lru_cache\\nfrom itertools import groupby\\nfrom typing import Dict, List, Set\\n\\n\\nclass Solution:\\n    # O(M * N * (logN + logM)) time complexity\\n    # O(M * N) space complexity\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        numRow, numCol = len(mat), len(mat[0])\\n\\n        querySetsByRow: List[List[Set[int]]] = []\\n        for i in range(numRow):\\n            sortedRow = sorted((mat[i][j], j) for j in range(numCol))\\n            groups = [\\n                {x[1] for x in group}\\n                for _, group in groupby(sortedRow, key=lambda x: x[0])\\n            ]\\n            querySets: List[Set[int]] = [set()] * numCol\\n            for idx in range(len(groups) - 1):\\n                group = groups[idx]\\n                nextGroup = groups[idx + 1]\\n                for j in group:\\n                    querySets[j] = nextGroup\\n\\n            for j_, querySet in enumerate(querySets):\\n                if j_ in groups[-1]:\\n                    assert not querySet\\n                else:\\n                    assert querySet\\n\\n            querySetsByRow.append(querySets)\\n\\n        querySetsByCol: List[List[Set[int]]] = []\\n        for j in range(numCol):\\n            # another way to compute querySets\\n            # may be more efficient when there are many equal values\\n            valToPositions: Dict[int, Set[int]] = defaultdict(set)\\n            for i in range(numRow):\\n                valToPositions[mat[i][j]].add(i)\\n\\n            querySets: List[Set[int]] = [set()] * numRow\\n            sortedKeys = sorted(valToPositions.keys())\\n            for idx in range(len(sortedKeys) - 1):\\n                key, nextKey = sortedKeys[idx], sortedKeys[idx + 1]\\n                for i in valToPositions[key]:\\n                    querySets[i] = valToPositions[nextKey]\\n\\n            querySetsByCol.append(querySets)\\n\\n        @lru_cache(maxsize=None)\\n        def longestPathLen(i: int, j: int) -> int:\\n            result = 1\\n            for j_ in querySetsByRow[i][j]:\\n                result = max(result, 1 + longestPathLen(i, j_))\\n            for i_ in querySetsByCol[j][i]:\\n                result = max(result, 1 + longestPathLen(i_, j))\\n            return result\\n\\n        result = 1\\n        for i in range(numRow):\\n            for j in range(numCol):\\n                result = max(result, longestPathLen(i, j))\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import lru_cache\\nfrom typing import List\\n\\n\\nclass Solution:\\n    # O(n^3) time complexity\\n    # O(n^2) space complexity\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        row, col = len(mat), len(mat[0])\\n\\n        @lru_cache(maxsize=None)\\n        def longestPathLen(i: int, j: int) -> int:\\n            val = mat[i][j]\\n            result = 1\\n            for k in range(row):\\n                if k == i or mat[k][j] <= val:\\n                    continue\\n                result = max(result, 1 + longestPathLen(k, j))\\n            for k in range(col):\\n                if k == j or mat[i][k] <= val:\\n                    continue\\n                result = max(result, 1 + longestPathLen(i, k))\\n\\n            return result\\n\\n        result = 1\\n        for i in range(row):\\n            for j in range(col):\\n                result = max(result, longestPathLen(i, j))\\n\\n        return result\\n```\n```\\nfrom collections import defaultdict\\nfrom functools import lru_cache\\nfrom itertools import groupby\\nfrom typing import Dict, List, Set\\n\\n\\nclass Solution:\\n    # O(M * N * (logN + logM)) time complexity\\n    # O(M * N) space complexity\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        numRow, numCol = len(mat), len(mat[0])\\n\\n        querySetsByRow: List[List[Set[int]]] = []\\n        for i in range(numRow):\\n            sortedRow = sorted((mat[i][j], j) for j in range(numCol))\\n            groups = [\\n                {x[1] for x in group}\\n                for _, group in groupby(sortedRow, key=lambda x: x[0])\\n            ]\\n            querySets: List[Set[int]] = [set()] * numCol\\n            for idx in range(len(groups) - 1):\\n                group = groups[idx]\\n                nextGroup = groups[idx + 1]\\n                for j in group:\\n                    querySets[j] = nextGroup\\n\\n            for j_, querySet in enumerate(querySets):\\n                if j_ in groups[-1]:\\n                    assert not querySet\\n                else:\\n                    assert querySet\\n\\n            querySetsByRow.append(querySets)\\n\\n        querySetsByCol: List[List[Set[int]]] = []\\n        for j in range(numCol):\\n            # another way to compute querySets\\n            # may be more efficient when there are many equal values\\n            valToPositions: Dict[int, Set[int]] = defaultdict(set)\\n            for i in range(numRow):\\n                valToPositions[mat[i][j]].add(i)\\n\\n            querySets: List[Set[int]] = [set()] * numRow\\n            sortedKeys = sorted(valToPositions.keys())\\n            for idx in range(len(sortedKeys) - 1):\\n                key, nextKey = sortedKeys[idx], sortedKeys[idx + 1]\\n                for i in valToPositions[key]:\\n                    querySets[i] = valToPositions[nextKey]\\n\\n            querySetsByCol.append(querySets)\\n\\n        @lru_cache(maxsize=None)\\n        def longestPathLen(i: int, j: int) -> int:\\n            result = 1\\n            for j_ in querySetsByRow[i][j]:\\n                result = max(result, 1 + longestPathLen(i, j_))\\n            for i_ in querySetsByCol[j][i]:\\n                result = max(result, 1 + longestPathLen(i_, j))\\n            return result\\n\\n        result = 1\\n        for i in range(numRow):\\n            for j in range(numCol):\\n                result = max(result, longestPathLen(i, j))\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903965,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxIncreasingCells(int[][] mat) {\\n    final int m = mat.length;\\n    final int n = mat[0].length;\\n    int[] rows = new int[m]; // rows[i] := max path length for i-th row\\n    int[] cols = new int[n]; // cols[j] := max path length for j-th col\\n    Map<Integer, ArrayList<Pair<Integer, Integer>>> valToIndices = new HashMap<>();\\n    // maxPathLength[i][j] := max path length from mat[i][j]\\n    int[][] maxPathLength = new int[m][n];\\n    // all unique values in the matrix in non-increasing order\\n    TreeSet<Integer> decreasingSet = new TreeSet<>(Comparator.reverseOrder());\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j) {\\n        final int val = mat[i][j];\\n        valToIndices.putIfAbsent(val, new ArrayList<>());\\n        valToIndices.get(val).add(new Pair<>(i, j));\\n        decreasingSet.add(val);\\n      }\\n\\n    for (final int val : decreasingSet) {\\n      for (Pair<Integer, Integer> pair : valToIndices.get(val)) {\\n        final int i = pair.getKey();\\n        final int j = pair.getValue();\\n        maxPathLength[i][j] = Math.max(rows[i], cols[j]) + 1;\\n      }\\n      for (Pair<Integer, Integer> pair : valToIndices.get(val)) {\\n        final int i = pair.getKey();\\n        final int j = pair.getValue();\\n        rows[i] = Math.max(rows[i], maxPathLength[i][j]);\\n        cols[j] = Math.max(cols[j], maxPathLength[i][j]);\\n      }\\n    }\\n\\n    return Math.max(Arrays.stream(rows).max().getAsInt(), //\\n                    Arrays.stream(cols).max().getAsInt());\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxIncreasingCells(int[][] mat) {\\n    final int m = mat.length;\\n    final int n = mat[0].length;\\n    int[] rows = new int[m]; // rows[i] := max path length for i-th row\\n    int[] cols = new int[n]; // cols[j] := max path length for j-th col\\n    Map<Integer, ArrayList<Pair<Integer, Integer>>> valToIndices = new HashMap<>();\\n    // maxPathLength[i][j] := max path length from mat[i][j]\\n    int[][] maxPathLength = new int[m][n];\\n    // all unique values in the matrix in non-increasing order\\n    TreeSet<Integer> decreasingSet = new TreeSet<>(Comparator.reverseOrder());\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j) {\\n        final int val = mat[i][j];\\n        valToIndices.putIfAbsent(val, new ArrayList<>());\\n        valToIndices.get(val).add(new Pair<>(i, j));\\n        decreasingSet.add(val);\\n      }\\n\\n    for (final int val : decreasingSet) {\\n      for (Pair<Integer, Integer> pair : valToIndices.get(val)) {\\n        final int i = pair.getKey();\\n        final int j = pair.getValue();\\n        maxPathLength[i][j] = Math.max(rows[i], cols[j]) + 1;\\n      }\\n      for (Pair<Integer, Integer> pair : valToIndices.get(val)) {\\n        final int i = pair.getKey();\\n        final int j = pair.getValue();\\n        rows[i] = Math.max(rows[i], maxPathLength[i][j]);\\n        cols[j] = Math.max(cols[j], maxPathLength[i][j]);\\n      }\\n    }\\n\\n    return Math.max(Arrays.stream(rows).max().getAsInt(), //\\n                    Arrays.stream(cols).max().getAsInt());\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888714,
                "title": "java-easy-to-understand-dp-solution",
                "content": "\\n```\\nclass Solution {\\n    // Time: O(mnlogmn)\\n    // Space: O(mn)\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        Map<Integer, List<int[]>> map = new TreeMap<>(); // increasing order\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int val = mat[i][j];\\n                if (!map.containsKey(val)) {\\n                    map.put(val, new ArrayList<int[]>());\\n                }\\n                map.get(val).add(new int[]{i, j});\\n            }\\n        }\\n\\n        // dp[i][j] means the maximum steps can go from the first cell\\n        int[][] dp = new int[m][n];\\n        // res[i] -> max step for row i\\n        // res[j+m] -> max step for col j\\n        int[] res = new int[n + m];\\n        for (int key : map.keySet()) {\\n            for (int[] pos : map.get(key)) {\\n                int i = pos[0], j = pos[1];\\n                // maximum between (max step for row i, max step for col j) + 1\\n                dp[i][j] = Math.max(res[i], res[m + j]) + 1;\\n            }\\n            for (int[] pos : map.get(key)) {\\n                int i = pos[0], j = pos[1];\\n                res[m + j] = Math.max(res[m + j], dp[i][j]);\\n                res[i] = Math.max(res[i], dp[i][j]);\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int i : res) {\\n            max = Math.max(max, i);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    // Time: O(mnlogmn)\\n    // Space: O(mn)\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        Map<Integer, List<int[]>> map = new TreeMap<>(); // increasing order\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int val = mat[i][j];\\n                if (!map.containsKey(val)) {\\n                    map.put(val, new ArrayList<int[]>());\\n                }\\n                map.get(val).add(new int[]{i, j});\\n            }\\n        }\\n\\n        // dp[i][j] means the maximum steps can go from the first cell\\n        int[][] dp = new int[m][n];\\n        // res[i] -> max step for row i\\n        // res[j+m] -> max step for col j\\n        int[] res = new int[n + m];\\n        for (int key : map.keySet()) {\\n            for (int[] pos : map.get(key)) {\\n                int i = pos[0], j = pos[1];\\n                // maximum between (max step for row i, max step for col j) + 1\\n                dp[i][j] = Math.max(res[i], res[m + j]) + 1;\\n            }\\n            for (int[] pos : map.get(key)) {\\n                int i = pos[0], j = pos[1];\\n                res[m + j] = Math.max(res[m + j], dp[i][j]);\\n                res[i] = Math.max(res[i], dp[i][j]);\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int i : res) {\\n            max = Math.max(max, i);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879307,
                "title": "rust-intuitive-dp",
                "content": "# Intuition\\n\\nFor each cell in the matrix, find out all possible next cells and recursively calculate the maximum number of increasing cells for them.\\n\\nAlso, observe how it only makes sense for us to jump to the next biggest value in current row/column.\\n\\n```rust\\n[_1_, 5, ->_2_, 3]\\n```\\nIt makes sense to jump from cell 0 to 2, but not to cell 3. Why??\\n\\n# Approach\\n\\nTop-down dynamic programming.\\n\\nTo find the next largest cell in a row/column, sorting + binary search is used.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m n \\\\log (m n))$$\\n\\n- Space complexity:\\n$$O(mn)$$\\n\\n# Code\\n```\\npub struct DP {\\n    grid: Vec<Vec<i32>>,\\n    n: usize, m: usize,\\n\\n    row_search_vec: Vec<Vec<(i32, usize)>>,\\n    col_search_vec: Vec<Vec<(i32, usize)>>,\\n\\n    memo: Vec<Vec<Option<usize>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(grid: Vec<Vec<i32>>) -> Self {\\n        let (n, m) = (grid.len(), grid[0].len());\\n        \\n        let mut row_search_vec = vec![];\\n        for row in &grid {\\n            let mut row = row.iter()\\n                .enumerate()\\n                .map(|(i, &e)| (e, i))\\n                .collect::<Vec<_>>();\\n            row.sort_unstable();\\n            row_search_vec.push(row);\\n        }\\n\\n        let mut col_search_vec = vec![];\\n        for j in 0..m {\\n            let mut col = Vec::with_capacity(n);\\n            for i in 0..n {\\n                col.push((grid[i][j], i));\\n            }\\n            col.sort_unstable();\\n            col_search_vec.push(col);\\n        }\\n\\n        let memo = vec![vec![None; m]; n];\\n\\n        Self {\\n            grid, n, m,\\n            row_search_vec,\\n            col_search_vec,\\n            memo,\\n        }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, i: usize, j: usize) -> usize {\\n        if i >= self.n { return usize::MIN; }\\n        if j >= self.m { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[i][j] {\\n            return ret;\\n        }\\n\\n        let ret = self.solve_inner(i, j);\\n        self.memo[i][j] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, i: usize, j: usize) -> usize {\\n        if i >= self.n { return usize::MIN; }\\n        if j >= self.m { return usize::MIN; }\\n\\n        let e = self.grid[i][j];\\n\\n        let mut ret = usize::MIN;\\n\\n        // search row-wise\\n        let ptr_start = self.row_search_vec[i]\\n            .partition_point(|&(e0, _)| e0 <= e);\\n        let (e_next, _) = self.row_search_vec[i]\\n            .get(ptr_start).cloned()\\n            .unwrap_or((i32::MAX, usize::MIN));\\n        let ptr_end = self.row_search_vec[i]\\n            .partition_point(|&(e0, _)| e0 <= e_next);\\n        for ptr in ptr_start..ptr_end {\\n            let (_, j_next) = self.row_search_vec[i][ptr];\\n            ret = ret.max(self.solve(i, j_next));\\n        }\\n\\n        // search col-wise\\n        let ptr_start = self.col_search_vec[j]\\n            .partition_point(|&(e0, _)| e0 <= e);\\n        let (e_next, _) = self.col_search_vec[j]\\n            .get(ptr_start).cloned()\\n            .unwrap_or((i32::MAX, usize::MIN));\\n        let ptr_end = self.col_search_vec[j]\\n            .partition_point(|&(e0, _)| e0 <= e_next);\\n        for ptr in ptr_start..ptr_end {\\n            let (_, i_next) = self.col_search_vec[j][ptr];\\n            ret = ret.max(self.solve(i_next, j));\\n        }\\n\\n        ret + 1\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn max_increasing_cells(grid: Vec<Vec<i32>>) -> i32 {\\n        let (n, m) = (grid.len(), grid[0].len());\\n\\n        let mut dp = DP::new(grid);\\n\\n        let mut ret = usize::MIN;\\n        for i in 0..n {\\n            for j in 0..m {\\n                let _ret = dp.solve(i, j);\\n                ret = ret.max(_ret);\\n            }\\n        }\\n\\n        ret as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```rust\\n[_1_, 5, ->_2_, 3]\\n```\n```\\npub struct DP {\\n    grid: Vec<Vec<i32>>,\\n    n: usize, m: usize,\\n\\n    row_search_vec: Vec<Vec<(i32, usize)>>,\\n    col_search_vec: Vec<Vec<(i32, usize)>>,\\n\\n    memo: Vec<Vec<Option<usize>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(grid: Vec<Vec<i32>>) -> Self {\\n        let (n, m) = (grid.len(), grid[0].len());\\n        \\n        let mut row_search_vec = vec![];\\n        for row in &grid {\\n            let mut row = row.iter()\\n                .enumerate()\\n                .map(|(i, &e)| (e, i))\\n                .collect::<Vec<_>>();\\n            row.sort_unstable();\\n            row_search_vec.push(row);\\n        }\\n\\n        let mut col_search_vec = vec![];\\n        for j in 0..m {\\n            let mut col = Vec::with_capacity(n);\\n            for i in 0..n {\\n                col.push((grid[i][j], i));\\n            }\\n            col.sort_unstable();\\n            col_search_vec.push(col);\\n        }\\n\\n        let memo = vec![vec![None; m]; n];\\n\\n        Self {\\n            grid, n, m,\\n            row_search_vec,\\n            col_search_vec,\\n            memo,\\n        }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, i: usize, j: usize) -> usize {\\n        if i >= self.n { return usize::MIN; }\\n        if j >= self.m { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[i][j] {\\n            return ret;\\n        }\\n\\n        let ret = self.solve_inner(i, j);\\n        self.memo[i][j] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, i: usize, j: usize) -> usize {\\n        if i >= self.n { return usize::MIN; }\\n        if j >= self.m { return usize::MIN; }\\n\\n        let e = self.grid[i][j];\\n\\n        let mut ret = usize::MIN;\\n\\n        // search row-wise\\n        let ptr_start = self.row_search_vec[i]\\n            .partition_point(|&(e0, _)| e0 <= e);\\n        let (e_next, _) = self.row_search_vec[i]\\n            .get(ptr_start).cloned()\\n            .unwrap_or((i32::MAX, usize::MIN));\\n        let ptr_end = self.row_search_vec[i]\\n            .partition_point(|&(e0, _)| e0 <= e_next);\\n        for ptr in ptr_start..ptr_end {\\n            let (_, j_next) = self.row_search_vec[i][ptr];\\n            ret = ret.max(self.solve(i, j_next));\\n        }\\n\\n        // search col-wise\\n        let ptr_start = self.col_search_vec[j]\\n            .partition_point(|&(e0, _)| e0 <= e);\\n        let (e_next, _) = self.col_search_vec[j]\\n            .get(ptr_start).cloned()\\n            .unwrap_or((i32::MAX, usize::MIN));\\n        let ptr_end = self.col_search_vec[j]\\n            .partition_point(|&(e0, _)| e0 <= e_next);\\n        for ptr in ptr_start..ptr_end {\\n            let (_, i_next) = self.col_search_vec[j][ptr];\\n            ret = ret.max(self.solve(i_next, j));\\n        }\\n\\n        ret + 1\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn max_increasing_cells(grid: Vec<Vec<i32>>) -> i32 {\\n        let (n, m) = (grid.len(), grid[0].len());\\n\\n        let mut dp = DP::new(grid);\\n\\n        let mut ret = usize::MIN;\\n        for i in 0..n {\\n            for j in 0..m {\\n                let _ret = dp.solve(i, j);\\n                ret = ret.max(_ret);\\n            }\\n        }\\n\\n        ret as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3873676,
                "title": "a-90-python-3-solution",
                "content": "Code should be self-explaned. \\n\\n# Code\\n```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        value_pos = sorted(([v, i, j] for i, row in enumerate(mat) for j, v in enumerate(row)), \\n                           key=lambda x: x[0])\\n        i, total = 0, m * n\\n        ans = 0\\n        max_rows, max_cols = [0] * m, [0] * n\\n        dp = [[0] * n for _ in range(m)]\\n        while i < total:\\n            j = i\\n            value = value_pos[i][0]\\n            while j < total and value_pos[j][0] == value:\\n                x, y = value_pos[j][1], value_pos[j][2]\\n                dp[x][y] = max(1 + max_rows[x], 1 + max_cols[y])\\n                ans = max(ans, dp[x][y])\\n                j += 1\\n            while i < j:\\n                x, y = value_pos[i][1], value_pos[i][2]\\n                max_rows[x] = max(max_rows[x], dp[x][y])\\n                max_cols[y] = max(max_cols[y], dp[x][y])\\n                i += 1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        value_pos = sorted(([v, i, j] for i, row in enumerate(mat) for j, v in enumerate(row)), \\n                           key=lambda x: x[0])\\n        i, total = 0, m * n\\n        ans = 0\\n        max_rows, max_cols = [0] * m, [0] * n\\n        dp = [[0] * n for _ in range(m)]\\n        while i < total:\\n            j = i\\n            value = value_pos[i][0]\\n            while j < total and value_pos[j][0] == value:\\n                x, y = value_pos[j][1], value_pos[j][2]\\n                dp[x][y] = max(1 + max_rows[x], 1 + max_cols[y])\\n                ans = max(ans, dp[x][y])\\n                j += 1\\n            while i < j:\\n                x, y = value_pos[i][1], value_pos[i][2]\\n                max_rows[x] = max(max_rows[x], dp[x][y])\\n                max_cols[y] = max(max_cols[y], dp[x][y])\\n                i += 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863120,
                "title": "readable-dp-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBased on this solution: https://leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/solutions/3570296/java-c-python-dp-solution/\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction maxIncreasingCells(matrix: number[][]): number {\\n    const ROWS = matrix.length;\\n    const COLS = matrix[0].length;\\n\\n    // Group cells by value\\n    const cellsByValue = new Map<number, number[][]>();\\n    for (let r = 0; r < ROWS; r++) {\\n        for (let c = 0; c < COLS; c++) {\\n            const val = matrix[r][c];\\n            if (!cellsByValue.has(val)) cellsByValue.set(val, []);\\n            cellsByValue.get(val).push([r, c]);\\n        }\\n    }\\n\\n    // Compute Longest Increasing Subsequence for each value starting from minimum values\\n    const dp = Array.from({ length: ROWS }, () => Array(COLS).fill(0));\\n    const rowMaxPathes = Array(ROWS).fill(0), colMaxPathes = Array(COLS).fill(0);\\n    const sortedCellValues = Array.from(cellsByValue.keys()).sort((a, b) => a - b);\\n    for (const val of sortedCellValues) {\\n        const cells = cellsByValue.get(val);\\n        // Compute LIS for each cell with the current value\\n        for (const [r, c] of cells) {\\n            // use longest path so far from current row or column. It works, as we\\'re going from min value to max value, so when we reach max value all other pathes are already explored.\\n            dp[r][c] = Math.max(rowMaxPathes[r], colMaxPathes[c]) + 1;\\n        }\\n        // Update rowMaxPathes and colMaxPathes with the LIS for current row and column\\n        for (const [r, c] of cells) {\\n            colMaxPathes[c] = Math.max(colMaxPathes[c], dp[r][c]);\\n            rowMaxPathes[r] = Math.max(rowMaxPathes[r], dp[r][c]);\\n        }\\n    }\\n\\n    return Math.max(...rowMaxPathes, ...colMaxPathes);\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction maxIncreasingCells(matrix: number[][]): number {\\n    const ROWS = matrix.length;\\n    const COLS = matrix[0].length;\\n\\n    // Group cells by value\\n    const cellsByValue = new Map<number, number[][]>();\\n    for (let r = 0; r < ROWS; r++) {\\n        for (let c = 0; c < COLS; c++) {\\n            const val = matrix[r][c];\\n            if (!cellsByValue.has(val)) cellsByValue.set(val, []);\\n            cellsByValue.get(val).push([r, c]);\\n        }\\n    }\\n\\n    // Compute Longest Increasing Subsequence for each value starting from minimum values\\n    const dp = Array.from({ length: ROWS }, () => Array(COLS).fill(0));\\n    const rowMaxPathes = Array(ROWS).fill(0), colMaxPathes = Array(COLS).fill(0);\\n    const sortedCellValues = Array.from(cellsByValue.keys()).sort((a, b) => a - b);\\n    for (const val of sortedCellValues) {\\n        const cells = cellsByValue.get(val);\\n        // Compute LIS for each cell with the current value\\n        for (const [r, c] of cells) {\\n            // use longest path so far from current row or column. It works, as we\\'re going from min value to max value, so when we reach max value all other pathes are already explored.\\n            dp[r][c] = Math.max(rowMaxPathes[r], colMaxPathes[c]) + 1;\\n        }\\n        // Update rowMaxPathes and colMaxPathes with the LIS for current row and column\\n        for (const [r, c] of cells) {\\n            colMaxPathes[c] = Math.max(colMaxPathes[c], dp[r][c]);\\n            rowMaxPathes[r] = Math.max(rowMaxPathes[r], dp[r][c]);\\n        }\\n    }\\n\\n    return Math.max(...rowMaxPathes, ...colMaxPathes);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855845,
                "title": "c-easy-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing a3 = array<int, 3>;\\n\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        vector<a3> data;\\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j)\\n                data.push_back({mat[i][j], i, j});\\n            \\n        sort(data.begin(), data.end());\\n\\n        vector<map<int, int>> rows(m);\\n        vector<map<int, int>> cols(n);\\n\\n        for(int i = 0; i < m; ++i)\\n            rows[i].insert({INT_MIN, 0});\\n        for(int i = 0; i < n; ++i)\\n            cols[i].insert({INT_MIN, 0});\\n\\n        int rst = 1;\\n        for(auto [val, x, y]: data){\\n            int len = 1;\\n            auto iter = rows[x].lower_bound(val);\\n            iter = prev(iter);\\n            len = max(len, iter->second + 1);\\n\\n            iter = cols[y].lower_bound(val);\\n            iter = prev(iter);\\n            len = max(len, iter->second + 1);\\n\\n            rows[x][val] = max(len, rows[x][val]);\\n            cols[y][val] = max(len, cols[y][val]);\\n\\n            rst = max(rst, len);\\n        }\\n\\n        return rst;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nusing a3 = array<int, 3>;\\n\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        vector<a3> data;\\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j)\\n                data.push_back({mat[i][j], i, j});\\n            \\n        sort(data.begin(), data.end());\\n\\n        vector<map<int, int>> rows(m);\\n        vector<map<int, int>> cols(n);\\n\\n        for(int i = 0; i < m; ++i)\\n            rows[i].insert({INT_MIN, 0});\\n        for(int i = 0; i < n; ++i)\\n            cols[i].insert({INT_MIN, 0});\\n\\n        int rst = 1;\\n        for(auto [val, x, y]: data){\\n            int len = 1;\\n            auto iter = rows[x].lower_bound(val);\\n            iter = prev(iter);\\n            len = max(len, iter->second + 1);\\n\\n            iter = cols[y].lower_bound(val);\\n            iter = prev(iter);\\n            len = max(len, iter->second + 1);\\n\\n            rows[x][val] = max(len, rows[x][val]);\\n            cols[y][val] = max(len, cols[y][val]);\\n\\n            rst = max(rst, len);\\n        }\\n\\n        return rst;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846965,
                "title": "beats-100-tc-o-n-m-log-m-n-using-multimap-dp-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<multimap<int, pair<int, int>>> rows(n), cols(m);\\n        for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)rows[i].insert({mat[i][j], {i, j}});\\n        for(int i = 0; i < m; i++)for(int j = 0; j < n; j++)cols[i].insert({mat[j][i], {j, i}}); \\n        vector<vector<int>> memo(n, vector<int>(m, -1));\\n        int res = 0;\\n        auto dp = [&](int i, int j, auto&& dp)->int\\n        {\\n            if(i < 0 || j < 0 || i >= n || j >= m)return 0;\\n            if(memo[i][j] != -1)return memo[i][j];\\n            auto iRow = rows[i].upper_bound(mat[i][j]);\\n            auto iCol = cols[j].upper_bound(mat[i][j]);\\n            int curr = 1;\\n            if(iRow != rows[i].end())\\n            {\\n                int val = (*iRow).first;\\n                while(iRow != rows[i].end() && (*iRow).first == val)\\n                {\\n                    int ni = (*iRow).second.first;\\n                    int nj = (*iRow).second.second;\\n                    curr = max(curr, 1 + dp(ni, nj, dp));\\n                    iRow++;\\n                }\\n            }\\n            if(iCol != cols[j].end())\\n            {\\n                int val = (*iCol).first;\\n                while(iCol != cols[j].end() && (*iCol).first == val)\\n                {\\n                    int ni = (*iCol).second.first;\\n                    int nj = (*iCol).second.second;\\n                    curr = max(curr, 1 + dp(ni, nj, dp));\\n                    iCol++;\\n                }\\n            }\\n\\n            return memo[i][j] = curr;\\n        };\\n        for(int i = 0; i < n; i++)for(int j = 0; j < m; j++){res = max(res, dp(i, j, dp));} \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<multimap<int, pair<int, int>>> rows(n), cols(m);\\n        for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)rows[i].insert({mat[i][j], {i, j}});\\n        for(int i = 0; i < m; i++)for(int j = 0; j < n; j++)cols[i].insert({mat[j][i], {j, i}}); \\n        vector<vector<int>> memo(n, vector<int>(m, -1));\\n        int res = 0;\\n        auto dp = [&](int i, int j, auto&& dp)->int\\n        {\\n            if(i < 0 || j < 0 || i >= n || j >= m)return 0;\\n            if(memo[i][j] != -1)return memo[i][j];\\n            auto iRow = rows[i].upper_bound(mat[i][j]);\\n            auto iCol = cols[j].upper_bound(mat[i][j]);\\n            int curr = 1;\\n            if(iRow != rows[i].end())\\n            {\\n                int val = (*iRow).first;\\n                while(iRow != rows[i].end() && (*iRow).first == val)\\n                {\\n                    int ni = (*iRow).second.first;\\n                    int nj = (*iRow).second.second;\\n                    curr = max(curr, 1 + dp(ni, nj, dp));\\n                    iRow++;\\n                }\\n            }\\n            if(iCol != cols[j].end())\\n            {\\n                int val = (*iCol).first;\\n                while(iCol != cols[j].end() && (*iCol).first == val)\\n                {\\n                    int ni = (*iCol).second.first;\\n                    int nj = (*iCol).second.second;\\n                    curr = max(curr, 1 + dp(ni, nj, dp));\\n                    iCol++;\\n                }\\n            }\\n\\n            return memo[i][j] = curr;\\n        };\\n        for(int i = 0; i < n; i++)for(int j = 0; j < m; j++){res = max(res, dp(i, j, dp));} \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845547,
                "title": "backward-dp-where-the-initial-case-are-the-biggest-node-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        vals = [(mat[i][j], i, j) for i in range(len(mat)) for j in range(len(mat[0]))]\\n        vals.sort(key=lambda x: x[0])\\n        rows_max_scores = [0 for i in range(len(mat))]\\n        cols_max_scores = [0 for j in range(len(mat[0]))]\\n\\n    \\n        while len(vals)>0:\\n            cur_val = vals[-1][0]\\n            scores = []\\n            while len(vals)>0 and (vals[-1][0]==cur_val):\\n                curr_node = vals.pop()\\n                scores.append([curr_node[1],curr_node[2],1+max(rows_max_scores[curr_node[1]], cols_max_scores[curr_node[2]])])\\n            for score_info in scores:\\n                rows_max_scores[score_info[0]] = max(rows_max_scores[score_info[0]], score_info[2])\\n                cols_max_scores[score_info[1]] = max(cols_max_scores[score_info[1]], score_info[2])\\n        \\n        return max(max(rows_max_scores), max(cols_max_scores))\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        vals = [(mat[i][j], i, j) for i in range(len(mat)) for j in range(len(mat[0]))]\\n        vals.sort(key=lambda x: x[0])\\n        rows_max_scores = [0 for i in range(len(mat))]\\n        cols_max_scores = [0 for j in range(len(mat[0]))]\\n\\n    \\n        while len(vals)>0:\\n            cur_val = vals[-1][0]\\n            scores = []\\n            while len(vals)>0 and (vals[-1][0]==cur_val):\\n                curr_node = vals.pop()\\n                scores.append([curr_node[1],curr_node[2],1+max(rows_max_scores[curr_node[1]], cols_max_scores[curr_node[2]])])\\n            for score_info in scores:\\n                rows_max_scores[score_info[0]] = max(rows_max_scores[score_info[0]], score_info[2])\\n                cols_max_scores[score_info[1]] = max(cols_max_scores[score_info[1]], score_info[2])\\n        \\n        return max(max(rows_max_scores), max(cols_max_scores))\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783111,
                "title": "c-easy-solution-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe dont care about where the previous answer comming from, just need to ensure it is comming from the same col or same row and the value smaller than the current cell, and if there really is a previous cached result, we try to update the state.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. to make sure it is from smallest to biggest, we need to store the value and its position in the map, C++\\'s map is red black tree, prefectly sorted\\n2. try to update the col and row max result\\n\\nyou can use multiset as well\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        const int n = mat.size();\\n        const int m = mat[0].size();\\n        map<int, vector<pair<int, int>>> m_;\\n        for(int i = 0; const auto& r : mat){\\n            for(int j = 0; const auto& val : r){\\n                m_[val].emplace_back(i, j);\\n                j++;\\n            }\\n            i++;\\n        }\\n        vector<int> row(n), col(m);\\n        int res = 0;\\n        for(auto &[_, pos_vec] : m_){\\n            vector<int> mx;\\n            for(auto &[i, j] : pos_vec){\\n                mx.push_back(max(row[i], col[j]) + 1);\\n                res = max(res, mx.back());\\n            }\\n            for(int x = 0; x < pos_vec.size(); x++){\\n                auto &[i, j] = pos_vec[x];\\n                row[i] = max(row[i], mx[x]);\\n                col[j] = max(col[j], mx[x]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        const int n = mat.size();\\n        const int m = mat[0].size();\\n        map<int, vector<pair<int, int>>> m_;\\n        for(int i = 0; const auto& r : mat){\\n            for(int j = 0; const auto& val : r){\\n                m_[val].emplace_back(i, j);\\n                j++;\\n            }\\n            i++;\\n        }\\n        vector<int> row(n), col(m);\\n        int res = 0;\\n        for(auto &[_, pos_vec] : m_){\\n            vector<int> mx;\\n            for(auto &[i, j] : pos_vec){\\n                mx.push_back(max(row[i], col[j]) + 1);\\n                res = max(res, mx.back());\\n            }\\n            for(int x = 0; x < pos_vec.size(); x++){\\n                auto &[i, j] = pos_vec[x];\\n                row[i] = max(row[i], mx[x]);\\n                col[j] = max(col[j], mx[x]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769954,
                "title": "easy-approach-just-traverse-in-descreasing-order",
                "content": "# Complexity\\n- Time complexity: $$O(n*m * log(nm))$$\\n\\n- Space complexity: $$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<long long>row(n,0), col(m,0);\\n\\n        vector<pair<int,pair<int,int>>>arr;\\n\\n        for( int i = 0; i<n; i++ ){\\n            for( int j = 0; j<m; j++ ){\\n                arr.push_back({ mat[i][j], { i, j } });\\n            }\\n        }\\n\\n        sort( arr.begin(), arr.end() );\\n\\n        long long ma = 100001;\\n        int i = arr.size() - 1;\\n\\n        // now traverse in reverse order\\n        while( i >=0 ){\\n            int j = i;\\n            while( j >=0 and arr[j].first == arr[i].first ){\\n                pair<int,int>p = arr[j].second;\\n        \\n                long long first = row[p.first]%ma, second = col[p.second]%ma;\\n\\n                long long curfirst = row[p.first]/ma, cursecond = col[p.second]/ma;\\n                \\n                long long ans = 1 + max( first, second );\\n                if( first < ans and curfirst < ans ) row[p.first] = first + ma * ans;\\n                if( second < ans and cursecond < ans ) col[p.second] = second + ma * ans;\\n                j--;\\n            }\\n\\n            while( i > j ){\\n                pair<int,int>p = arr[i].second;\\n                if( row[p.first] >= ma ) row[p.first] /= ma;\\n                if( col[p.second] >= ma ) col[p.second] /= ma;\\n        \\n                i--;\\n            }\\n\\n\\n        }\\n\\n        long long ans = 0;\\n        for( int i = 0; i<n; i++ ) ans = max( ans, row[i] );\\n        for( int j = 0; j<m; j++ ) ans = max( ans, col[j] );\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<long long>row(n,0), col(m,0);\\n\\n        vector<pair<int,pair<int,int>>>arr;\\n\\n        for( int i = 0; i<n; i++ ){\\n            for( int j = 0; j<m; j++ ){\\n                arr.push_back({ mat[i][j], { i, j } });\\n            }\\n        }\\n\\n        sort( arr.begin(), arr.end() );\\n\\n        long long ma = 100001;\\n        int i = arr.size() - 1;\\n\\n        // now traverse in reverse order\\n        while( i >=0 ){\\n            int j = i;\\n            while( j >=0 and arr[j].first == arr[i].first ){\\n                pair<int,int>p = arr[j].second;\\n        \\n                long long first = row[p.first]%ma, second = col[p.second]%ma;\\n\\n                long long curfirst = row[p.first]/ma, cursecond = col[p.second]/ma;\\n                \\n                long long ans = 1 + max( first, second );\\n                if( first < ans and curfirst < ans ) row[p.first] = first + ma * ans;\\n                if( second < ans and cursecond < ans ) col[p.second] = second + ma * ans;\\n                j--;\\n            }\\n\\n            while( i > j ){\\n                pair<int,int>p = arr[i].second;\\n                if( row[p.first] >= ma ) row[p.first] /= ma;\\n                if( col[p.second] >= ma ) col[p.second] /= ma;\\n        \\n                i--;\\n            }\\n\\n\\n        }\\n\\n        long long ans = 0;\\n        for( int i = 0; i<n; i++ ) ans = max( ans, row[i] );\\n        for( int j = 0; j<m; j++ ) ans = max( ans, col[j] );\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753139,
                "title": "step-by-step-intiution-explanation-dp-solution-o-m-n-log-m-n",
                "content": "So it is kind of a problem to find Longest increasing subsequence in a matrix, with constraint that from one cell [i][j] we can move to any other cell on the row [i] and col[j]. \\n\\nSo the simple solution could be using dfs on a unvisited row each time it is found unvisited.\\n\\nAlgo for this apparoach would be \\nIf mat[i][j] is unvisited, iterate throught its row[i] and col[j], to check value greater than mat[i][j], if value greater than the mat[i][j] cell is found calculate its value. and \\nthen update the mat[i][j]. \\nSee the diagram\\n\\n![image](https://assets.leetcode.com/users/images/88e44a39-2e2f-4f65-8fc6-97d951b7ca63_1689138085.2842429.png)\\n\\nSo for each cell we have to iterate throught its complete row and col,\\nroughly the time complexity woud be O(M*N *(M+N)) which will not pass.\\n\\nNow can we reduce the search on the row and col. \\n\\nKeep these points in mind.\\n\\n```\\n1. We only need to find those values on row and col which are strictly greater than the current cell value.\\n2. We need to find those cells which are greater and will give maximum output.\\n```\\n\\nSo if we iterate through cells in descending order of there values.\\n\\nso if values of cells are \\n\\n5 4 3\\n2 6 -1\\n-2 1 10\\n\\nWe will sort them in descending order and iterate higher values first.\\nThen update there corresponding row and col values with there values.\\n```\\nUnderstand it like this\\nSo the order of exeuction of above example will be \\n\\n10 6 5 4 3 2 1 -1 -2\\n\\nSo for instance when we will execute 5, all values above 5 would already be computed.\\n\\nNote: we need to be careful of cases when values are same.\\n\\n```\\n\\nClearly we need to sort the input. We can create an hashmap which will store {value,indices} pair.\\ntwo another arrays will store each row and col maximum\\nSee the Code for better understanding\\n\\n``` \\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        \\n        //variable declaration\\n        int m = mat.size(), n = mat[0].size();\\n        map<int,vector<vector<int>>> st;\\n        vector<vector<int>> dp(m,vector<int> (n,1));\\n        vector<int> row(m,0),col(n,0);\\n        priority_queue<vector<int>> pq;\\n        \\n        //algo\\n\\t\\t\\n\\t\\t// storing values in hasmap\\n        for(int i = 0; i < m;i++) \\n\\t\\t\\tfor(int j = 0;j < n;j++) \\n\\t\\t\\t\\tst[-mat[i][j]].push_back({i,j}); //storing negative values (-mat[i][j]) so that max value computed first as hashmap sort values in ascending order.\\n\\t\\t\\t\\t\\n\\t\\t\\n        int ans = 0;\\n        for(auto j : st){\\n            for(auto x : j.second) {\\n                int i = x[0], j = x[1];\\n                dp[i][j] = max(row[i],col[j]) + 1; // computing dp[i][j] as(max_value of its row and col)\\n                ans = max(ans,dp[i][j]);\\n            }\\n            for(auto x : j.second) {  // updating the row and col values this can\\'t be done in above iteration to avoid cell having same value updated.\\n                int i = x[0], j = x[1];\\n                row[i] = max(row[i],dp[i][j]);\\n                col[j] = max(col[j],dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you have any doubt you can comment on this.\\nIf you like this solution or even if you reached here please support my effort and upvote this solution.\\n\\nAll negatives point of this solution are appreciated.\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n1. We only need to find those values on row and col which are strictly greater than the current cell value.\\n2. We need to find those cells which are greater and will give maximum output.\\n```\n```\\nUnderstand it like this\\nSo the order of exeuction of above example will be \\n\\n10 6 5 4 3 2 1 -1 -2\\n\\nSo for instance when we will execute 5, all values above 5 would already be computed.\\n\\nNote: we need to be careful of cases when values are same.\\n\\n```\n``` \\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        \\n        //variable declaration\\n        int m = mat.size(), n = mat[0].size();\\n        map<int,vector<vector<int>>> st;\\n        vector<vector<int>> dp(m,vector<int> (n,1));\\n        vector<int> row(m,0),col(n,0);\\n        priority_queue<vector<int>> pq;\\n        \\n        //algo\\n\\t\\t\\n\\t\\t// storing values in hasmap\\n        for(int i = 0; i < m;i++) \\n\\t\\t\\tfor(int j = 0;j < n;j++) \\n\\t\\t\\t\\tst[-mat[i][j]].push_back({i,j}); //storing negative values (-mat[i][j]) so that max value computed first as hashmap sort values in ascending order.\\n\\t\\t\\t\\t\\n\\t\\t\\n        int ans = 0;\\n        for(auto j : st){\\n            for(auto x : j.second) {\\n                int i = x[0], j = x[1];\\n                dp[i][j] = max(row[i],col[j]) + 1; // computing dp[i][j] as(max_value of its row and col)\\n                ans = max(ans,dp[i][j]);\\n            }\\n            for(auto x : j.second) {  // updating the row and col values this can\\'t be done in above iteration to avoid cell having same value updated.\\n                int i = x[0], j = x[1];\\n                row[i] = max(row[i],dp[i][j]);\\n                col[j] = max(col[j],dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737903,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  $$O(M*N*log(M*N))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(M*N)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        \\n        int m = mat.size(), n = mat[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<int> rows_max(m, 0);\\n        vector<int> cols_max(n, 0);\\n\\n        map<int, vector<pair<int, int>>> mp;\\n        for(int i=0;i<m;i++){\\n            for(int j=0; j<n;j++){\\n                mp[mat[i][j]].push_back({i, j});\\n            }\\n        }\\n\\n        for(auto m: mp){\\n            for(auto p: m.second){\\n                int r = p.first, c = p.second;\\n                dp[r][c] = max(dp[r][c], max(rows_max[r], cols_max[c]) + 1 );\\n            }\\n            for(auto p: m.second ){\\n                int r = p.first, c = p.second;\\n                rows_max[r] = max(rows_max[r], dp[r][c]);\\n                cols_max[c] = max(cols_max[c], dp[r][c]);\\n            }\\n\\n        }\\n        int m1 = *max_element(rows_max.begin(), rows_max.end());\\n        int m2 = *max_element(cols_max.begin(), cols_max.end());\\n\\n        \\n        return max(m1, m2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        \\n        int m = mat.size(), n = mat[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<int> rows_max(m, 0);\\n        vector<int> cols_max(n, 0);\\n\\n        map<int, vector<pair<int, int>>> mp;\\n        for(int i=0;i<m;i++){\\n            for(int j=0; j<n;j++){\\n                mp[mat[i][j]].push_back({i, j});\\n            }\\n        }\\n\\n        for(auto m: mp){\\n            for(auto p: m.second){\\n                int r = p.first, c = p.second;\\n                dp[r][c] = max(dp[r][c], max(rows_max[r], cols_max[c]) + 1 );\\n            }\\n            for(auto p: m.second ){\\n                int r = p.first, c = p.second;\\n                rows_max[r] = max(rows_max[r], dp[r][c]);\\n                cols_max[c] = max(cols_max[c], dp[r][c]);\\n            }\\n\\n        }\\n        int m1 = *max_element(rows_max.begin(), rows_max.end());\\n        int m2 = *max_element(cols_max.begin(), cols_max.end());\\n\\n        \\n        return max(m1, m2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699526,
                "title": "rust-priority-queue-o-mn-log-mn",
                "content": "# Approach\\n- Travel from low value to high value. That way we can easily update new max score by taking previous max score and increase by 1\\n- Keep track of maximum score in a each row and column with 2 array `best_row` and `best_column`\\n\\n# Complexity\\n- Time complexity: $O(nm \\\\times log(nm))$\\n- Space complexity: $O(nm)$\\n\\n# Code\\n```rust\\nuse std::collections::BinaryHeap;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_increasing_cells(mat: Vec<Vec<i32>>) -> i32 {\\n        let n = mat.len();\\n        let m = mat[0].len();\\n        let mut ret = 1;\\n        let mut q = BinaryHeap::new();\\n        let mut best_row = vec![0;n];\\n        let mut best_col = vec![0;m];\\n        let mut next_best_row = vec![0;n];\\n        let mut next_best_col = vec![0;m];\\n        for i in 0..n {\\n            for j in 0..m {\\n                q.push((mat[i][j], i, j));\\n            }\\n        }\\n        let mut last_x = i32::MAX;\\n        let mut buffer = Vec::new();\\n        while let Some((x, i, j)) = q.pop() {\\n            if x != last_x {\\n                while let Some((i,j)) = buffer.pop() {\\n                    best_row[i] = next_best_row[i];\\n                    best_col[j] = next_best_col[j];\\n                }\\n            }\\n            next_best_row[i] = max(next_best_row[i], max(best_col[j]+1, best_row[i]+1));\\n            next_best_col[j] = max(next_best_col[j], max(best_row[i]+1, best_col[j]+1));\\n            ret = max(max(ret, next_best_row[i]), next_best_col[j]);\\n            last_x = x;\\n            buffer.push((i,j));\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::BinaryHeap;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_increasing_cells(mat: Vec<Vec<i32>>) -> i32 {\\n        let n = mat.len();\\n        let m = mat[0].len();\\n        let mut ret = 1;\\n        let mut q = BinaryHeap::new();\\n        let mut best_row = vec![0;n];\\n        let mut best_col = vec![0;m];\\n        let mut next_best_row = vec![0;n];\\n        let mut next_best_col = vec![0;m];\\n        for i in 0..n {\\n            for j in 0..m {\\n                q.push((mat[i][j], i, j));\\n            }\\n        }\\n        let mut last_x = i32::MAX;\\n        let mut buffer = Vec::new();\\n        while let Some((x, i, j)) = q.pop() {\\n            if x != last_x {\\n                while let Some((i,j)) = buffer.pop() {\\n                    best_row[i] = next_best_row[i];\\n                    best_col[j] = next_best_col[j];\\n                }\\n            }\\n            next_best_row[i] = max(next_best_row[i], max(best_col[j]+1, best_row[i]+1));\\n            next_best_col[j] = max(next_best_col[j], max(best_row[i]+1, best_col[j]+1));\\n            ret = max(max(ret, next_best_row[i]), next_best_col[j]);\\n            last_x = x;\\n            buffer.push((i,j));\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694101,
                "title": "cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                mp[mat[i][j]].push_back({i,j});\\n            }\\n        }\\n        vector<vector<int>> dp(mat.size(),vector<int>(mat[0].size(),0));\\n        vector<int> rowMax(mat.size(),0);\\n        vector<int> colMax(mat[0].size(),0);\\n        \\n        for(auto &[val,pos]:mp){\\n            for(auto it:pos){\\n                int i= it.first;\\n                int j= it.second;\\n                dp[i][j] = max(rowMax[i],colMax[j])+1;\\n            }\\n            for(auto it:pos){\\n                int i = it.first;\\n                int j= it.second;\\n                rowMax[i] = max(rowMax[i],dp[i][j]);\\n                colMax[j] = max(colMax[j],dp[i][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<mat[0].size();i++){\\n            ans=max(ans,colMax[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                mp[mat[i][j]].push_back({i,j});\\n            }\\n        }\\n        vector<vector<int>> dp(mat.size(),vector<int>(mat[0].size(),0));\\n        vector<int> rowMax(mat.size(),0);\\n        vector<int> colMax(mat[0].size(),0);\\n        \\n        for(auto &[val,pos]:mp){\\n            for(auto it:pos){\\n                int i= it.first;\\n                int j= it.second;\\n                dp[i][j] = max(rowMax[i],colMax[j])+1;\\n            }\\n            for(auto it:pos){\\n                int i = it.first;\\n                int j= it.second;\\n                rowMax[i] = max(rowMax[i],dp[i][j]);\\n                colMax[j] = max(colMax[j],dp[i][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<mat[0].size();i++){\\n            ans=max(ans,colMax[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664491,
                "title": "easy-java-solution-100-working",
                "content": "# Intuition\\nWhen solving the problem of finding the largest increasing cell in the matrix, the first thing that comes to my mind is:\\n\\n*  I need to cross the matrix and find the increasing cell. An incremental cell is larger than its neighbor (if any). So I need to compare each phone with its neighbors.\\n\\n* To keep track of the increasing max number of cells, I need a variable to store the current max number and update it whenever I see an increase.\\n\\n* One way is to use dynamic programming. I can create a 2D array to store the length of the ascending end of each cell. I can change this array while iterating through the matrix.\\n* While repeating the matrix, I start from each cell and check its neighbors to see if it forms an array. If so, I update the cell by increasing the length of the array based on the values \\u200B\\u200Bof its neighbors.\\n\\n* During this crawl, I followed the longest string ever found and updated it when I came across a longer string.\\n6. After matching is complete, I store the maximum incremental number of cells in a dynamic programming array.\\n\\n* Finally I will return the maximum value as the result.\\n\\n\\n# Approach\\n\\nTo solve the problem of finding the maximum number of increasing cells in a matrix, I would approach it using a dynamic programming technique\\n\\n# Complexity\\n- Time complexity:\\n\\nConstructing the TreeMap takes O(n * m * log(n * m)) time because we iterate over each element in the matrix and insert it into the TreeMap. The insertion operation in a TreeMap has a logarithmic time complexity.\\n\\n- Space complexity:\\nThe TreeMap \\'map\\' stores the positions of each value in the matrix, which requires O(n * m) space as it can contain at most all the distinct values in the matrix.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int n = mat.length; // Number of rows\\n        int m = mat[0].length; // Number of columns\\n        \\n        int[] rMax = new int[n]; // Maximum number of increasing cells in each row\\n        int[] cMax = new int[m]; // Maximum number of increasing cells in each column\\n        \\n        TreeMap<Integer, List<int[]>> map = new TreeMap<>(); // TreeMap to store positions based on values\\n        \\n        // Store positions for each value in the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int val = mat[i][j];\\n                map.putIfAbsent(val, new ArrayList<>());\\n                map.get(val).add(new int[]{i, j});\\n            }\\n        }\\n        \\n        int[][] dp = new int[n][m]; // DP array to store intermediate results\\n        \\n        // Iterate through values in increasing order\\n        for (int value : map.keySet()) {\\n            List<int[]> positions = map.get(value); // Get positions for the current value\\n            \\n            // Update the current position result\\n            for (int[] pos : positions) {\\n                int row = pos[0];\\n                int col = pos[1];\\n                dp[row][col] = Math.max(rMax[row], cMax[col]) + 1;\\n            }\\n            \\n            // Update the maximum values for rows and columns\\n            for (int[] pos : positions) {\\n                int row = pos[0];\\n                int col = pos[1];\\n                rMax[row] = Math.max(rMax[row], dp[row][col]);\\n                cMax[col] = Math.max(cMax[col], dp[row][col]);\\n            }\\n        }\\n        \\n        int maxCells = 0; // Maximum number of increasing cells\\n        \\n        // Find the maximum value in the dp array\\n        for (int[] row : dp) {\\n            for (int cells : row) {\\n                maxCells = Math.max(maxCells, cells);\\n            }\\n        }\\n        \\n        return maxCells;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int n = mat.length; // Number of rows\\n        int m = mat[0].length; // Number of columns\\n        \\n        int[] rMax = new int[n]; // Maximum number of increasing cells in each row\\n        int[] cMax = new int[m]; // Maximum number of increasing cells in each column\\n        \\n        TreeMap<Integer, List<int[]>> map = new TreeMap<>(); // TreeMap to store positions based on values\\n        \\n        // Store positions for each value in the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int val = mat[i][j];\\n                map.putIfAbsent(val, new ArrayList<>());\\n                map.get(val).add(new int[]{i, j});\\n            }\\n        }\\n        \\n        int[][] dp = new int[n][m]; // DP array to store intermediate results\\n        \\n        // Iterate through values in increasing order\\n        for (int value : map.keySet()) {\\n            List<int[]> positions = map.get(value); // Get positions for the current value\\n            \\n            // Update the current position result\\n            for (int[] pos : positions) {\\n                int row = pos[0];\\n                int col = pos[1];\\n                dp[row][col] = Math.max(rMax[row], cMax[col]) + 1;\\n            }\\n            \\n            // Update the maximum values for rows and columns\\n            for (int[] pos : positions) {\\n                int row = pos[0];\\n                int col = pos[1];\\n                rMax[row] = Math.max(rMax[row], dp[row][col]);\\n                cMax[col] = Math.max(cMax[col], dp[row][col]);\\n            }\\n        }\\n        \\n        int maxCells = 0; // Maximum number of increasing cells\\n        \\n        // Find the maximum value in the dp array\\n        for (int[] row : dp) {\\n            for (int cells : row) {\\n                maxCells = Math.max(maxCells, cells);\\n            }\\n        }\\n        \\n        return maxCells;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652183,
                "title": "rust-btreemap-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_increasing_cells(mat: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::BTreeMap;\\n        let mut cells = BTreeMap::new();\\n        let (m, n) = (mat.len(), mat[0].len());\\n        for i in 0..m {\\n            for j in 0..n {\\n                cells.entry(mat[i][j]).or_insert(vec![]).push(vec![i, j]);\\n            }\\n        }\\n        let mut max_vals = vec![0; m + n];\\n        let mut ans = 0;\\n        let mut dp = vec![vec![0; n]; m];\\n        for val in cells.keys() {\\n            for cell in &cells[val] {\\n                let (i, j) = (cell[0], cell[1]);\\n                dp[i][j] = max_vals[i].max(max_vals[j + m]) + 1;\\n                ans = ans.max(dp[i][j]);\\n            }\\n\\n            for cell in &cells[val] {\\n                let (i, j) = (cell[0], cell[1]);\\n                max_vals[i] = max_vals[i].max(dp[i][j]);\\n                max_vals[j + m] = max_vals[j + m].max(dp[i][j]);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_increasing_cells(mat: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::BTreeMap;\\n        let mut cells = BTreeMap::new();\\n        let (m, n) = (mat.len(), mat[0].len());\\n        for i in 0..m {\\n            for j in 0..n {\\n                cells.entry(mat[i][j]).or_insert(vec![]).push(vec![i, j]);\\n            }\\n        }\\n        let mut max_vals = vec![0; m + n];\\n        let mut ans = 0;\\n        let mut dp = vec![vec![0; n]; m];\\n        for val in cells.keys() {\\n            for cell in &cells[val] {\\n                let (i, j) = (cell[0], cell[1]);\\n                dp[i][j] = max_vals[i].max(max_vals[j + m]) + 1;\\n                ans = ans.max(dp[i][j]);\\n            }\\n\\n            for cell in &cells[val] {\\n                let (i, j) = (cell[0], cell[1]);\\n                max_vals[i] = max_vals[i].max(dp[i][j]);\\n                max_vals[j + m] = max_vals[j + m].max(dp[i][j]);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651399,
                "title": "cleanest-and-best-implementation-you-can-get",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nit is a basic dp problem with a little twist. You just have to think a naive top-down approach and then convert it to a bottom-up. The key factor is the implementation of the problem which is a bit tricky.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbasic top-down approach would be to traverse every possible(strictly greater cell from current in same row and column) cell from every cell of the grid and then repeat. This would take exponential time but with memoization you can take it down to O(n*m*(n+m)) but this is also not enough. You have think in reverse and build a bottom up solution. For that reverse the condition and try counting from the largest to smallest number because we know that we can\\'t go further from the largest cell. Then rather than traversing every element in the row and column. we just can take them maximum in the row and column because we know that we already have considered only the maximum number and no smaller number than the current has be chosen.\\n\\n# Complexity\\n- Time complexity: O(n*m*lognm)\\n\\n- Space complexity: O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n=mat.size(), m=mat[0].size();\\n        int ans=1;\\n        vector<int> rows(n, 0), cols(m, 0);\\n        map<int, vector<pair<int, int> > > mp;\\n        vector<vector<int> > steps(n, vector<int> (m, 0)); // store total steps\\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++)\\n        mp[-mat[i][j]].push_back({i, j}); // storing numbers in decending order since map sorts in ascending we store negative of the number\\n        for(auto it: mp)\\n        {\\n            int val=it.first;\\n            vector<pair<int, int> > v=it.second;\\n            int len=v.size();\\n            for(int i=0;i<len;i++)\\n            {\\n                int r=v[i].first;\\n                int c=v[i].second;\\n                steps[r][c]=max(rows[r], cols[c])+1;\\n            }\\n            for(int i=0;i<len;i++)\\n            {\\n                int r=v[i].first;\\n                int c=v[i].second;\\n                rows[r]=max(rows[r], steps[r][c]);\\n                cols[c]=max(cols[c], steps[r][c]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            ans=max(ans, steps[i][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n=mat.size(), m=mat[0].size();\\n        int ans=1;\\n        vector<int> rows(n, 0), cols(m, 0);\\n        map<int, vector<pair<int, int> > > mp;\\n        vector<vector<int> > steps(n, vector<int> (m, 0)); // store total steps\\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++)\\n        mp[-mat[i][j]].push_back({i, j}); // storing numbers in decending order since map sorts in ascending we store negative of the number\\n        for(auto it: mp)\\n        {\\n            int val=it.first;\\n            vector<pair<int, int> > v=it.second;\\n            int len=v.size();\\n            for(int i=0;i<len;i++)\\n            {\\n                int r=v[i].first;\\n                int c=v[i].second;\\n                steps[r][c]=max(rows[r], cols[c])+1;\\n            }\\n            for(int i=0;i<len;i++)\\n            {\\n                int r=v[i].first;\\n                int c=v[i].second;\\n                rows[r]=max(rows[r], steps[r][c]);\\n                cols[c]=max(cols[c], steps[r][c]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            ans=max(ans, steps[i][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633746,
                "title": "c-568-ms-95-33-122-2-mb-90-94-fast-and-less-memory-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst consider a case where a number $n$ with the index $(x, y)$ is given and all the maximum lengths of a path to the index $(i, j)$ with a value being less than $n$ are known. Then the maximum length of a path heading to $(x, y)$ is given as $\\\\max(\\\\max_{i}(\\\\operatorname{num}[i][y]), \\\\max_{j}(\\\\operatorname{num}[x][j])$, where $\\\\operatorname{num}[i][j]$ is the maximum length of a path heading to the index $(i, j)$. Here $num[i][j]$ is $0$ for the indices with values being equal or more than $n$.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs seen in Intuition, if a number $n$ with a coordinate is given and all the maximum lengths of paths heading to indices $(i, j)$ with values being less than $n$ are known, then the maximum length of a path for the number can be calculated. \\n\\nThus a given matrix is sorted with respect to values. We start with a component in the matrix with the smallest number.\\n\\nTo process each data in matrix by following the rule described in Intuition, only the maximum lengths of paths heading to the columns and rows are required. Those values are managed using two vectors in my code and updated in each process. Finally, the vectors contains numbers representing thr maximum length of paths to go to each column and row.\\n\\nThe answer is calculated as the maximum number of the vectors.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(mn \\\\log mn)$ for sorting.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(m+n)$ for preserving the maximum length.\\n\\n# Code\\n```\\n#include <queue>\\n#include <algorithm>\\n\\nconstexpr int INF = 10101010;\\nusing t = tuple<int, int, int>;\\n\\n\\nclass Solution {\\nprivate:\\n  queue<t> q;\\n  vector<int> h_max, w_max;\\n  vector<t> v;\\npublic:\\n    void init(const int m, const int n){\\n        h_max.assign(m, 0);\\n        w_max.assign(n, 0);\\n    }\\n\\n    void fill(){\\n        while(q.size() > 0){\\n            int x, y, value;\\n            t item = q.front();\\n            q.pop();\\n            value = get<0>(item);\\n            x = get<1>(item);\\n            y = get<2>(item);\\n            h_max[x] = max(value, h_max[x]);\\n            w_max[y] = max(value, w_max[y]);\\n        }\\n    }\\n\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m, n, prev;\\n        prev = -INF;\\n        m = mat.size();\\n        n = mat[0].size();\\n        init(m, n);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                v.emplace_back(mat[i][j], i, j);\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        for(t& item : v){\\n            int val, x, y, num;\\n            val = get<0>(item);\\n            x = get<1>(item);\\n            y = get<2>(item);\\n            if(prev != val){\\n                fill();\\n                prev = val;\\n            }\\n            num = max(h_max[x], w_max[y]) + 1;\\n            q.emplace(num, x, y);\\n        }\\n        fill();\\n        int h_max_v = *max_element(h_max.begin(), h_max.end());\\n        int w_max_v = *max_element(w_max.begin(), w_max.end());\\n        return max(h_max_v, w_max_v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <queue>\\n#include <algorithm>\\n\\nconstexpr int INF = 10101010;\\nusing t = tuple<int, int, int>;\\n\\n\\nclass Solution {\\nprivate:\\n  queue<t> q;\\n  vector<int> h_max, w_max;\\n  vector<t> v;\\npublic:\\n    void init(const int m, const int n){\\n        h_max.assign(m, 0);\\n        w_max.assign(n, 0);\\n    }\\n\\n    void fill(){\\n        while(q.size() > 0){\\n            int x, y, value;\\n            t item = q.front();\\n            q.pop();\\n            value = get<0>(item);\\n            x = get<1>(item);\\n            y = get<2>(item);\\n            h_max[x] = max(value, h_max[x]);\\n            w_max[y] = max(value, w_max[y]);\\n        }\\n    }\\n\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m, n, prev;\\n        prev = -INF;\\n        m = mat.size();\\n        n = mat[0].size();\\n        init(m, n);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                v.emplace_back(mat[i][j], i, j);\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        for(t& item : v){\\n            int val, x, y, num;\\n            val = get<0>(item);\\n            x = get<1>(item);\\n            y = get<2>(item);\\n            if(prev != val){\\n                fill();\\n                prev = val;\\n            }\\n            num = max(h_max[x], w_max[y]) + 1;\\n            q.emplace(num, x, y);\\n        }\\n        fill();\\n        int h_max_v = *max_element(h_max.begin(), h_max.end());\\n        int w_max_v = *max_element(w_max.begin(), w_max.end());\\n        return max(h_max_v, w_max_v);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3630962,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) use a *sorted* map `m` to associate each key `x = A[i][j]` with a list of cells [(i<sub>0</sub>, j<sub>0</sub>), (i<sub>1</sub>, j<sub>1</sub>), (i<sub>2</sub>, j<sub>2</sub>) ... ] as a \"bucket\" for each value `x`.\\n\\nLet `row` and `col` be the *ongoing* maximum length of a strictly increasing path within the input matrix `A` ending at each `i`<sup>th</sup> row and each `j`<sup>th</sup> column correspondingly.\\n\\nThen, in ascending order of each \"bucket\" key `x`, we use the optimal past to formulate the optimal future over and over again: the previous `best` `+1` is used to formulate the next `best`, ie. the previous `row` is used to formulate the `next_row` and the previous column `col` is used to formulate the next column `next_col`.\\n\\n* Note: we can `+1` from previous `best` to next `best` because the map `m` is *ordered* by the monotonically increasing key `x = A[i][j]`, so we go through each \"bucket\" `m[x]` in *increasing* order.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxIncreasingCells(A: Array<IntArray>): Int {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var m = mutableMapOf<Int, MutableList<Pair<Int, Int>>>()\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                if (!m.contains(A[i][j]))\\n                    m[A[i][j]] = mutableListOf<Pair<Int, Int>>()\\n                m[A[i][j]]!!.add(Pair(i, j))\\n            }\\n        }\\n        var row = IntArray(M){ 0 }; var next_row = IntArray(M){ 0 }\\n        var col = IntArray(N){ 0 }; var next_col = IntArray(N){ 0 }\\n        for (x in m.keys.sorted()) {\\n            for ((i, j) in m[x]!!) {\\n                var best = Math.max(row[i], col[j])\\n                next_row[i] = Math.max(next_row[i], 1 + best)\\n                next_col[j] = Math.max(next_col[j], 1 + best)\\n            }\\n            for ((i, j) in m[x]!!) {\\n                row[i] = next_row[i]\\n                col[j] = next_col[j]\\n            }\\n        }\\n        return row.max()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxIncreasingCells = A => {\\n    let [M, N] = [A.length, A[0].length];\\n    let m = new Map(_.flatten(_.range(0, M).map(i => _.range(0, N).map(j => [A[i][j], []]))));\\n    for (let i = 0; i < M; ++i)\\n        for (let j = 0; j < N; ++j)\\n            m.get(A[i][j]).push([i, j]);\\n    let row = Array(M).fill(0), next_row = Array(M).fill(0),\\n        col = Array(N).fill(0), next_col = Array(N).fill(0);\\n    for (let x of [...m.keys()].sort((a, b) => a - b)) {\\n        for (let [i, j] of m.get(x)) {\\n            let best = Math.max(row[i], col[j]);\\n            next_row[i] = Math.max(next_row[i], 1 + best);\\n            next_col[j] = Math.max(next_col[j], 1 + best);\\n        }\\n        for (let [i, j] of m.get(x)) {\\n            row[i] = next_row[i];\\n            col[j] = next_col[j];\\n        }\\n    }\\n    return Math.max(...row);\\n};\\n```\\n\\n*Python3*\\n```\\nfrom sortedcontainers import SortedDict\\nclass Solution:\\n    def maxIncreasingCells(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        m = SortedDict()\\n        for i in range(M):\\n            for j in range(N):\\n                if A[i][j] not in m:\\n                    m[A[i][j]] = []\\n                m[A[i][j]].append((i, j))\\n        row = [0] * M; next_row = [0] * M\\n        col = [0] * N; next_col = [0] * N\\n        for x in m.keys():\\n            for i, j in m[x]:\\n                best = max(row[i], col[j])\\n                next_row[i] = max(next_row[i], 1 + best)\\n                next_col[j] = max(next_col[j], 1 + best)\\n            for i, j in m[x]:\\n                row[i] = next_row[i]\\n                col[j] = next_col[j]\\n        return max(row)\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::max;\\nuse std::collections::BTreeMap;\\nimpl Solution {\\n    pub fn max_increasing_cells(A: Vec<Vec<i32>>) -> i32 {\\n        let (M, N) = (A.len(), A[0].len());\\n        let mut m = BTreeMap::new();\\n        for i in 0..M {\\n            for j in 0..N {\\n                m.entry(&A[i][j]).or_insert(vec![]).push((i, j));\\n            }\\n        }\\n        let mut row = vec![0; M]; let mut next_row = vec![0; M];\\n        let mut col = vec![0; N]; let mut next_col = vec![0; N];\\n        for x in m.keys() {\\n            for (i, j) in m.get(x).unwrap() {\\n                let best = max(row[*i], col[*j]);\\n                next_row[*i] = max(next_row[*i], 1 + best);\\n                next_col[*j] = max(next_col[*j], 1 + best);\\n            }\\n            for (i, j) in m.get(x).unwrap() {\\n                row[*i] = next_row[*i];\\n                col[*j] = next_col[*j];\\n            }\\n        }\\n        row.into_iter().max().unwrap()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Map = map<int, Pairs>;\\n    int maxIncreasingCells(VVI& A, Map m = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                m[A[i][j]].emplace_back(i, j);\\n        VI row(M), next_row(M),\\n           col(N), next_col(N);\\n        for (auto& [x, _]: m) {\\n            for (auto [i, j]: m[x]) {\\n                auto best = max(row[i], col[j]);\\n                next_row[i] = max(next_row[i], 1 + best);\\n                next_col[j] = max(next_col[j], 1 + best);\\n            }\\n            for (auto [i, j]: m[x]) {\\n                row[i] = next_row[i];\\n                col[j] = next_col[j];\\n            }\\n        }\\n        return *max_element(row.begin(), row.end());\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxIncreasingCells(A: Array<IntArray>): Int {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        var m = mutableMapOf<Int, MutableList<Pair<Int, Int>>>()\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                if (!m.contains(A[i][j]))\\n                    m[A[i][j]] = mutableListOf<Pair<Int, Int>>()\\n                m[A[i][j]]!!.add(Pair(i, j))\\n            }\\n        }\\n        var row = IntArray(M){ 0 }; var next_row = IntArray(M){ 0 }\\n        var col = IntArray(N){ 0 }; var next_col = IntArray(N){ 0 }\\n        for (x in m.keys.sorted()) {\\n            for ((i, j) in m[x]!!) {\\n                var best = Math.max(row[i], col[j])\\n                next_row[i] = Math.max(next_row[i], 1 + best)\\n                next_col[j] = Math.max(next_col[j], 1 + best)\\n            }\\n            for ((i, j) in m[x]!!) {\\n                row[i] = next_row[i]\\n                col[j] = next_col[j]\\n            }\\n        }\\n        return row.max()!!\\n    }\\n}\\n```\n```\\nlet maxIncreasingCells = A => {\\n    let [M, N] = [A.length, A[0].length];\\n    let m = new Map(_.flatten(_.range(0, M).map(i => _.range(0, N).map(j => [A[i][j], []]))));\\n    for (let i = 0; i < M; ++i)\\n        for (let j = 0; j < N; ++j)\\n            m.get(A[i][j]).push([i, j]);\\n    let row = Array(M).fill(0), next_row = Array(M).fill(0),\\n        col = Array(N).fill(0), next_col = Array(N).fill(0);\\n    for (let x of [...m.keys()].sort((a, b) => a - b)) {\\n        for (let [i, j] of m.get(x)) {\\n            let best = Math.max(row[i], col[j]);\\n            next_row[i] = Math.max(next_row[i], 1 + best);\\n            next_col[j] = Math.max(next_col[j], 1 + best);\\n        }\\n        for (let [i, j] of m.get(x)) {\\n            row[i] = next_row[i];\\n            col[j] = next_col[j];\\n        }\\n    }\\n    return Math.max(...row);\\n};\\n```\n```\\nfrom sortedcontainers import SortedDict\\nclass Solution:\\n    def maxIncreasingCells(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        m = SortedDict()\\n        for i in range(M):\\n            for j in range(N):\\n                if A[i][j] not in m:\\n                    m[A[i][j]] = []\\n                m[A[i][j]].append((i, j))\\n        row = [0] * M; next_row = [0] * M\\n        col = [0] * N; next_col = [0] * N\\n        for x in m.keys():\\n            for i, j in m[x]:\\n                best = max(row[i], col[j])\\n                next_row[i] = max(next_row[i], 1 + best)\\n                next_col[j] = max(next_col[j], 1 + best)\\n            for i, j in m[x]:\\n                row[i] = next_row[i]\\n                col[j] = next_col[j]\\n        return max(row)\\n```\n```\\nuse std::cmp::max;\\nuse std::collections::BTreeMap;\\nimpl Solution {\\n    pub fn max_increasing_cells(A: Vec<Vec<i32>>) -> i32 {\\n        let (M, N) = (A.len(), A[0].len());\\n        let mut m = BTreeMap::new();\\n        for i in 0..M {\\n            for j in 0..N {\\n                m.entry(&A[i][j]).or_insert(vec![]).push((i, j));\\n            }\\n        }\\n        let mut row = vec![0; M]; let mut next_row = vec![0; M];\\n        let mut col = vec![0; N]; let mut next_col = vec![0; N];\\n        for x in m.keys() {\\n            for (i, j) in m.get(x).unwrap() {\\n                let best = max(row[*i], col[*j]);\\n                next_row[*i] = max(next_row[*i], 1 + best);\\n                next_col[*j] = max(next_col[*j], 1 + best);\\n            }\\n            for (i, j) in m.get(x).unwrap() {\\n                row[*i] = next_row[*i];\\n                col[*j] = next_col[*j];\\n            }\\n        }\\n        row.into_iter().max().unwrap()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Map = map<int, Pairs>;\\n    int maxIncreasingCells(VVI& A, Map m = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                m[A[i][j]].emplace_back(i, j);\\n        VI row(M), next_row(M),\\n           col(N), next_col(N);\\n        for (auto& [x, _]: m) {\\n            for (auto [i, j]: m[x]) {\\n                auto best = max(row[i], col[j]);\\n                next_row[i] = max(next_row[i], 1 + best);\\n                next_col[j] = max(next_col[j], 1 + best);\\n            }\\n            for (auto [i, j]: m[x]) {\\n                row[i] = next_row[i];\\n                col[j] = next_col[j];\\n            }\\n        }\\n        return *max_element(row.begin(), row.end());\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621108,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        map<int,vector<pair<int,int>>>mp;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mp[mat[i][j]].push_back({i,j});\\n            }\\n        }\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        vector<int>rm(m,0);\\n        vector<int>cm(n,0);\\n        for(auto& [v,p]:mp)\\n        {\\n            for(auto it:p)\\n            {\\n                int i=it.first;\\n                int j=it.second;\\n                ans[i][j]=max(rm[i],cm[j])+1;\\n            }\\n            for(auto it:p)\\n            {\\n                int i=it.first;\\n                int j=it.second;\\n                rm[i]=max(rm[i],ans[i][j]);\\n                cm[j]=max(cm[j],ans[i][j]);\\n                \\n            }\\n        }\\n        int ms=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            ms=max(ms,rm[i]);\\n        }\\n        return ms;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        map<int,vector<pair<int,int>>>mp;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mp[mat[i][j]].push_back({i,j});\\n            }\\n        }\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        vector<int>rm(m,0);\\n        vector<int>cm(n,0);\\n        for(auto& [v,p]:mp)\\n        {\\n            for(auto it:p)\\n            {\\n                int i=it.first;\\n                int j=it.second;\\n                ans[i][j]=max(rm[i],cm[j])+1;\\n            }\\n            for(auto it:p)\\n            {\\n                int i=it.first;\\n                int j=it.second;\\n                rm[i]=max(rm[i],ans[i][j]);\\n                cm[j]=max(cm[j],ans[i][j]);\\n                \\n            }\\n        }\\n        int ms=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            ms=max(ms,rm[i]);\\n        }\\n        return ms;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620822,
                "title": "rust-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> dp\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing row and column array to track biggest value till now\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N* M* log(N*M))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*M)\\n\\n# Code\\n```\\nuse std::collections::BTreeMap;\\n\\n\\nimpl Solution {\\n    pub fn max_increasing_cells(mat: Vec<Vec<i32>>) -> i32 {\\n        \\n        let (n, m) = (mat.len(), mat[0].len());\\n        let mut mp = BTreeMap::<i32, Vec<(usize, usize)>>::new();\\n\\n        //let v: [i32, i32, i32] = Vector::new();\\n\\n        for i in 0..n{\\n            for j in 0..m{\\n                mp.entry(mat[i][j]).or_insert(Vec::new()).push((i,j));\\n            }\\n        }\\n\\n        //iterate in sorted order or values \\n\\n        //initialize dp array \\n        let mut dp = vec![vec![0; m]; n]; \\n\\n        // store the best row dp & col dp till now\\n        let (mut row, mut col) = (vec![0; n], vec![0; m]);\\n\\n        //initialize the best dp value for each row and column\\n        let mut ans = 0;\\n        // println!(\"{:?}\", dp);\\n        // println!(\"starting loop\");\\n        for (k,v) in mp{\\n            \\n            let sz = v.len();\\n\\n            // find the best dp values for current cell value\\n            for ki in 0..sz{\\n                let (i, j) = (v[ki].0, v[ki].1);\\n\\n                // println!(\"i= {} , j= {}, n={}, m={}\", i, j, n, m);\\n                // println!(\"dpij {}\",dp[i][j]);\\n                // println!(\"rowi {}\",row[i]);\\n                dp[i][j]=dp[i][j].max(row[i]+1);\\n                dp[i][j]=dp[i][j].max(col[j]+1);\\n                ans=ans.max(dp[i][j]);\\n            }\\n\\n            // update the dp values to row and col \\n            for ki in 0..sz{\\n                let (i, j) = (v[ki].0, v[ki].1);\\n                \\n                row[i]=row[i].max(dp[i][j]);\\n                col[j]=col[j].max(dp[i][j]);\\n            }\\n        }\\n\\n        // println!(\"{:?}\", dp);\\n        //return max of all dp\\'s \\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BTreeMap;\\n\\n\\nimpl Solution {\\n    pub fn max_increasing_cells(mat: Vec<Vec<i32>>) -> i32 {\\n        \\n        let (n, m) = (mat.len(), mat[0].len());\\n        let mut mp = BTreeMap::<i32, Vec<(usize, usize)>>::new();\\n\\n        //let v: [i32, i32, i32] = Vector::new();\\n\\n        for i in 0..n{\\n            for j in 0..m{\\n                mp.entry(mat[i][j]).or_insert(Vec::new()).push((i,j));\\n            }\\n        }\\n\\n        //iterate in sorted order or values \\n\\n        //initialize dp array \\n        let mut dp = vec![vec![0; m]; n]; \\n\\n        // store the best row dp & col dp till now\\n        let (mut row, mut col) = (vec![0; n], vec![0; m]);\\n\\n        //initialize the best dp value for each row and column\\n        let mut ans = 0;\\n        // println!(\"{:?}\", dp);\\n        // println!(\"starting loop\");\\n        for (k,v) in mp{\\n            \\n            let sz = v.len();\\n\\n            // find the best dp values for current cell value\\n            for ki in 0..sz{\\n                let (i, j) = (v[ki].0, v[ki].1);\\n\\n                // println!(\"i= {} , j= {}, n={}, m={}\", i, j, n, m);\\n                // println!(\"dpij {}\",dp[i][j]);\\n                // println!(\"rowi {}\",row[i]);\\n                dp[i][j]=dp[i][j].max(row[i]+1);\\n                dp[i][j]=dp[i][j].max(col[j]+1);\\n                ans=ans.max(dp[i][j]);\\n            }\\n\\n            // update the dp values to row and col \\n            for ki in 0..sz{\\n                let (i, j) = (v[ki].0, v[ki].1);\\n                \\n                row[i]=row[i].max(dp[i][j]);\\n                col[j]=col[j].max(dp[i][j]);\\n            }\\n        }\\n\\n        // println!(\"{:?}\", dp);\\n        //return max of all dp\\'s \\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616996,
                "title": "brute-force-binary-search-optimised-detailed-expalination-85-space-65-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHey ,\\nFirst of all it\\'s a very good question of Binay Search. After seeing tag i was able to solve it and awesome edge cases also.\\nSo please mark it important \\n-   Let\\'s Start \\n- So at first glance it seems like a graph +dp question \\n    How ?? => we are at (i,j) wants what are maximum cell that this (i,j) can visit.\\n    so we will check for for the whole ith row and j th col and check the valid [nr][nc] to go and check for evry combination and store the result for future .\\n### Code (DP+Graph) => TLE (FOR LAST 4 cases)\\n- Why TLE comes : We are visiting each cell ince but but in DFS we are always checking for whole ith row and jth col every time and there the TLE comes .\\n- COde has Given below for it \\n```\\nclass Solution {\\n    int DFS( vector<vector<int>>&mat , vector<vector<int>>&visited , int i , int j)\\n    {\\n        if(visited[i][j]!=-1)\\n        {\\n            return visited[i][j] ;\\n        }\\n        // Valid jumps \\n        int ans =0 ;\\n        for( int p =0 ;p<mat[0].size() ;p++)\\n        {\\n            if(p!=j && mat[i][p]>mat[i][j])\\n            {\\n                ans= max( ans , DFS(mat , visited, i ,p ));\\n            }\\n        }\\n        for( int q=0 ;q<mat.size() ;q++)\\n        {\\n            if(q!=i && mat[q][j]>mat[i][j])\\n            {\\n                ans = max(ans , DFS(mat , visited, q, j));\\n            }\\n        }\\n        return visited[i][j] = ans+1;\\n    }\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        vector<vector<int>> visited( mat.size() , vector<int>( mat[0].size() ,-1));\\n        int maxi =0 ;\\n        for( int i =0 ;i< mat.size() ;i++)\\n        {\\n            for( int j =0; j< mat[0].size() ;j++)\\n            {\\n                maxi = max(maxi , DFS(mat , visited , i , j ));\\n            }\\n        }\\n        return maxi ;\\n    }\\n};\\n```\\n\\n\\n# Code (Binary Search+ DP + DFS):\\n-   Now Question comes how we can improve the above for loops extra time .\\n- So After seeing the tag of Binary Search I have been thinking of how can i optimise those for loops of DFS .\\n- Then comes the thought of sorting the matrix row wise and col wise \\n- but if we sort row wise i should know what is its jth index so that i could further make call on that jth index .\\n- Similar with col wise sorting Ishould know ith indx to which the call will be made \\n- SO Imake row col wise sorting pair wise where second pair will contain the indx and will sort according to the first .\\n- **(i,j) => row wise sort=>(the indx where next is should go for maximmum celll visited )**\\n    **=>col wise sort =>  the indx where is should in colum for acheiving maximum .**\\n    Above operation : ** Lower bound function **\\n-   Take maximum \\n- Rest has been explained in the code .\\n\\n**Reason : Binary Search => We can get the indx in log(n) time(wher n= row|| n =col according to question )**\\n```\\nclass Solution {\\n // DFS for traveeling into teh matrix \\n    int DFS( vector<vector<pair<int,int>>>&row,  vector<vector<pair<int,int>>>&col , vector<vector<int>>& mat, int i , int j , vector<vector<int>>& visited)\\n    {\\n        // Check whether we have calculated the result previously\\n        if(visited[i][j]!=-1)\\n        {\\n            return visited[i][j] ;\\n        }\\n        // Lower bound Function Pair wise \\n        pair<int , int> p = {mat[i][j],j};\\n        auto it = lower_bound(row[i].begin() , row[i].end() ,p);\\n        int indx   = it-row[i].begin() ;\\n        // Checking whether the next element exists or not \\n        // The below function also seeing  the duplicates .\\n        while(indx!=row[i].size() && row[i][indx].first==mat[i][j])\\n        {\\n            indx++;\\n        }\\n        //indx =>where we have to go \\n        int ans=0 ;\\n        if(indx != mat[0].size())\\n        {\\n            int val = mat[i][row[i][indx].second] ;\\n            /* Below for loop for the case \\n                Example :  7  6  3 dp=>  1 2 3 \\n                          -7 -5  6       5 4 1 \\n                          -7  0 -4  =>   6 3 5 \\n                           6  6  0       2 1 4 \\n                          -8  6  0       6 1 4\\n                But for -8 the ans should be 7 (dry run it you will get it)\\n                above -7 is givinf the result so we have to s=check for all -7 from where we are getting the maximum.\\n            */\\n            while(indx!=row[i].size() && val ==mat[i][row[i][indx].second])\\n            { \\n                ans= max(ans,DFS(row, col , mat , i , row[i][indx].second, visited)) ;\\n                indx++;\\n            }\\n        }\\n        //Now for col =>same thing as above \\n        p.second= i;\\n        it = lower_bound(col[j].begin(), col[j].end() , p);\\n        indx = it-col[j].begin();\\n        while(indx!=col[j].size() && col[j][indx].first==mat[i][j])\\n        {\\n            indx++;\\n        }\\n        if(indx !=mat.size())\\n        {\\n            int val = mat[col[j][indx].second][j] ;\\n            while(indx!=col[j].size() && val == mat[col[j][indx].second][j])\\n            { \\n                ans= max(ans, DFS(row, col, mat ,col[j][indx].second ,j ,visited ));\\n                indx++;\\n            }\\n        }\\n        // Saving in our dp \\n        return visited[i][j]= ans+1 ;\\n    }\\npublic:\\n    // Having an idea with Binary Search \\n    // Trying to implement it \\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        vector<vector<pair<int,int>>> row(mat.size(),vector<pair<int,int>>(mat[0].size())) ,col(mat[0].size(),vector<pair<int,int>>(mat.size()));\\n        // Storing in row , col pair wise \\n        for( int i =0 ;i< mat.size() ;i++)\\n        {  \\n            for( int j =0 ;j<mat[0].size();j++)\\n            {\\n                row[i][j] = {mat[i][j], j};\\n            }\\n        }\\n        for( int j=0 ;j<mat[0].size() ;j++)\\n        {\\n            for( int i =0 ;i<mat.size() ;i++)\\n            {\\n                col[j][i] = {mat[i][j] ,i};\\n               // cout<<col[j][i].first<<\" \"<<col[j][i].second<<\" \";\\n            }\\n            //cout<<endl;\\n        }\\n        // Sorting so that Binary_Search can be applied  \\n        for( int i=0 ;i< mat.size() ;i++)\\n        {\\n            sort(row[i].begin() , row[i].end());\\n        }\\n        for( int j =0 ;j<mat[0].size() ;j++)\\n        {\\n            sort(col[j].begin() , col[j].end());\\n        }\\n        vector<vector<int>> visited ( mat.size() , vector<int>(mat[0].size(),-1));\\n        //Go and check teh maximum \\n        int ans =0 ;\\n        for( int i =0 ;i< mat.size() ;i++)\\n        {\\n            for( int j =0 ;j<mat[0].size();j++)\\n            {\\n                ans = max(ans , DFS(row, col, mat , i , j, visited));\\n              //  cout<<\"came\"<<endl;\\n            }\\n        }\\n        /*for( int i =0 ;i< mat.size() ;i++)\\n        {\\n            for( int j =0 ;j<mat[0].size();j++)\\n            {\\n               cout<<visited[i][j]<<\" \";\\n            }\\n            cout<<endl;\\n        }*/\\n        return  ans ;\\n    }\\n};\\n```\\n## Another way (90% time)\\n```\\nlass Solution {\\npublic:\\n    // You can view previous solution too :\\n    // This also you can think  \\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        vector<pair<int,pair<int,int>>> help ;\\n        for( int i =0; i<mat.size() ;i++)\\n        {\\n            for( int j =0 ;j< mat[0].size() ;j++)\\n            {\\n                help.push_back({mat[i][j] , {i,j}});\\n            }\\n        }\\n        sort(help.begin() , help.end());\\n        vector<deque<pair<int,int>>> row (mat.size(),{{INT_MAX,0}, {INT_MAX,0}}), col(mat[0].size(),{{INT_MAX,0}, {INT_MAX,0}});\\n        int maxi =0 ;\\n        for( int i =help.size()-1 ;i>=0 ;i--)\\n        {\\n            int val = help[i].first ;\\n            int r = help[i].second.first;\\n            int c = help[i].second.second ;\\n            pair<int,int> from_row = row[r].back() ;\\n            pair<int,int> from_col = col[c].back() ;\\n            int val_row=0 , val_col=0;\\n            if(from_row.first>val)\\n            {\\n                val_row = 1+from_row.second;\\n            } \\n            else if(from_row.first == val)\\n            {\\n                val_row =1+row[r].front().second;\\n            }\\n            if(from_col.first>val)\\n            {\\n                val_col = 1+from_col.second;\\n            } \\n            else if(from_col.first == val)\\n            {\\n                val_col =1+col[c].front().second;\\n            }\\n            int value = max(val_row , val_col);\\n            maxi = max(maxi , value );\\n            if(val == from_row.first)\\n            {\\n                if(value>from_row.second)\\n                {\\n                    from_row.second= value;\\n                    row[r].pop_back();\\n                    row[r].push_back(from_row);\\n                }\\n            }\\n            else\\n            {\\n                row[r].pop_front();\\n                row[r].push_back({val , value});\\n            }\\n            if(val == from_col.first)\\n            {\\n                if(value>from_col.second)\\n                {\\n                    from_col.second= value;\\n                    col[c].pop_back();\\n                    col[c].push_back(from_col);\\n                }\\n            }\\n            else\\n            {\\n                col[c].pop_front();\\n                col[c].push_back({val , value});\\n            }\\n            //cout<<r<<\" \"<<c<<\" \"<<value<<endl;\\n        }\\n        return maxi ;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int DFS( vector<vector<int>>&mat , vector<vector<int>>&visited , int i , int j)\\n    {\\n        if(visited[i][j]!=-1)\\n        {\\n            return visited[i][j] ;\\n        }\\n        // Valid jumps \\n        int ans =0 ;\\n        for( int p =0 ;p<mat[0].size() ;p++)\\n        {\\n            if(p!=j && mat[i][p]>mat[i][j])\\n            {\\n                ans= max( ans , DFS(mat , visited, i ,p ));\\n            }\\n        }\\n        for( int q=0 ;q<mat.size() ;q++)\\n        {\\n            if(q!=i && mat[q][j]>mat[i][j])\\n            {\\n                ans = max(ans , DFS(mat , visited, q, j));\\n            }\\n        }\\n        return visited[i][j] = ans+1;\\n    }\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        vector<vector<int>> visited( mat.size() , vector<int>( mat[0].size() ,-1));\\n        int maxi =0 ;\\n        for( int i =0 ;i< mat.size() ;i++)\\n        {\\n            for( int j =0; j< mat[0].size() ;j++)\\n            {\\n                maxi = max(maxi , DFS(mat , visited , i , j ));\\n            }\\n        }\\n        return maxi ;\\n    }\\n};\\n```\n```\\nclass Solution {\\n // DFS for traveeling into teh matrix \\n    int DFS( vector<vector<pair<int,int>>>&row,  vector<vector<pair<int,int>>>&col , vector<vector<int>>& mat, int i , int j , vector<vector<int>>& visited)\\n    {\\n        // Check whether we have calculated the result previously\\n        if(visited[i][j]!=-1)\\n        {\\n            return visited[i][j] ;\\n        }\\n        // Lower bound Function Pair wise \\n        pair<int , int> p = {mat[i][j],j};\\n        auto it = lower_bound(row[i].begin() , row[i].end() ,p);\\n        int indx   = it-row[i].begin() ;\\n        // Checking whether the next element exists or not \\n        // The below function also seeing  the duplicates .\\n        while(indx!=row[i].size() && row[i][indx].first==mat[i][j])\\n        {\\n            indx++;\\n        }\\n        //indx =>where we have to go \\n        int ans=0 ;\\n        if(indx != mat[0].size())\\n        {\\n            int val = mat[i][row[i][indx].second] ;\\n            /* Below for loop for the case \\n                Example :  7  6  3 dp=>  1 2 3 \\n                          -7 -5  6       5 4 1 \\n                          -7  0 -4  =>   6 3 5 \\n                           6  6  0       2 1 4 \\n                          -8  6  0       6 1 4\\n                But for -8 the ans should be 7 (dry run it you will get it)\\n                above -7 is givinf the result so we have to s=check for all -7 from where we are getting the maximum.\\n            */\\n            while(indx!=row[i].size() && val ==mat[i][row[i][indx].second])\\n            { \\n                ans= max(ans,DFS(row, col , mat , i , row[i][indx].second, visited)) ;\\n                indx++;\\n            }\\n        }\\n        //Now for col =>same thing as above \\n        p.second= i;\\n        it = lower_bound(col[j].begin(), col[j].end() , p);\\n        indx = it-col[j].begin();\\n        while(indx!=col[j].size() && col[j][indx].first==mat[i][j])\\n        {\\n            indx++;\\n        }\\n        if(indx !=mat.size())\\n        {\\n            int val = mat[col[j][indx].second][j] ;\\n            while(indx!=col[j].size() && val == mat[col[j][indx].second][j])\\n            { \\n                ans= max(ans, DFS(row, col, mat ,col[j][indx].second ,j ,visited ));\\n                indx++;\\n            }\\n        }\\n        // Saving in our dp \\n        return visited[i][j]= ans+1 ;\\n    }\\npublic:\\n    // Having an idea with Binary Search \\n    // Trying to implement it \\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        vector<vector<pair<int,int>>> row(mat.size(),vector<pair<int,int>>(mat[0].size())) ,col(mat[0].size(),vector<pair<int,int>>(mat.size()));\\n        // Storing in row , col pair wise \\n        for( int i =0 ;i< mat.size() ;i++)\\n        {  \\n            for( int j =0 ;j<mat[0].size();j++)\\n            {\\n                row[i][j] = {mat[i][j], j};\\n            }\\n        }\\n        for( int j=0 ;j<mat[0].size() ;j++)\\n        {\\n            for( int i =0 ;i<mat.size() ;i++)\\n            {\\n                col[j][i] = {mat[i][j] ,i};\\n               // cout<<col[j][i].first<<\" \"<<col[j][i].second<<\" \";\\n            }\\n            //cout<<endl;\\n        }\\n        // Sorting so that Binary_Search can be applied  \\n        for( int i=0 ;i< mat.size() ;i++)\\n        {\\n            sort(row[i].begin() , row[i].end());\\n        }\\n        for( int j =0 ;j<mat[0].size() ;j++)\\n        {\\n            sort(col[j].begin() , col[j].end());\\n        }\\n        vector<vector<int>> visited ( mat.size() , vector<int>(mat[0].size(),-1));\\n        //Go and check teh maximum \\n        int ans =0 ;\\n        for( int i =0 ;i< mat.size() ;i++)\\n        {\\n            for( int j =0 ;j<mat[0].size();j++)\\n            {\\n                ans = max(ans , DFS(row, col, mat , i , j, visited));\\n              //  cout<<\"came\"<<endl;\\n            }\\n        }\\n        /*for( int i =0 ;i< mat.size() ;i++)\\n        {\\n            for( int j =0 ;j<mat[0].size();j++)\\n            {\\n               cout<<visited[i][j]<<\" \";\\n            }\\n            cout<<endl;\\n        }*/\\n        return  ans ;\\n    }\\n};\\n```\n```\\nlass Solution {\\npublic:\\n    // You can view previous solution too :\\n    // This also you can think  \\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        vector<pair<int,pair<int,int>>> help ;\\n        for( int i =0; i<mat.size() ;i++)\\n        {\\n            for( int j =0 ;j< mat[0].size() ;j++)\\n            {\\n                help.push_back({mat[i][j] , {i,j}});\\n            }\\n        }\\n        sort(help.begin() , help.end());\\n        vector<deque<pair<int,int>>> row (mat.size(),{{INT_MAX,0}, {INT_MAX,0}}), col(mat[0].size(),{{INT_MAX,0}, {INT_MAX,0}});\\n        int maxi =0 ;\\n        for( int i =help.size()-1 ;i>=0 ;i--)\\n        {\\n            int val = help[i].first ;\\n            int r = help[i].second.first;\\n            int c = help[i].second.second ;\\n            pair<int,int> from_row = row[r].back() ;\\n            pair<int,int> from_col = col[c].back() ;\\n            int val_row=0 , val_col=0;\\n            if(from_row.first>val)\\n            {\\n                val_row = 1+from_row.second;\\n            } \\n            else if(from_row.first == val)\\n            {\\n                val_row =1+row[r].front().second;\\n            }\\n            if(from_col.first>val)\\n            {\\n                val_col = 1+from_col.second;\\n            } \\n            else if(from_col.first == val)\\n            {\\n                val_col =1+col[c].front().second;\\n            }\\n            int value = max(val_row , val_col);\\n            maxi = max(maxi , value );\\n            if(val == from_row.first)\\n            {\\n                if(value>from_row.second)\\n                {\\n                    from_row.second= value;\\n                    row[r].pop_back();\\n                    row[r].push_back(from_row);\\n                }\\n            }\\n            else\\n            {\\n                row[r].pop_front();\\n                row[r].push_back({val , value});\\n            }\\n            if(val == from_col.first)\\n            {\\n                if(value>from_col.second)\\n                {\\n                    from_col.second= value;\\n                    col[c].pop_back();\\n                    col[c].push_back(from_col);\\n                }\\n            }\\n            else\\n            {\\n                col[c].pop_front();\\n                col[c].push_back({val , value});\\n            }\\n            //cout<<r<<\" \"<<c<<\" \"<<value<<endl;\\n        }\\n        return maxi ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3607537,
                "title": "c-dynamic-programming-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nFist sort matrix b y value, then travse sorted matrix and find max count for rows and coloumn\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> memMin;\\n\\n    int maxIncreasingCells(vector<vector<int>>& mat)\\n    {        \\n        int m = mat.size(), n = mat[0].size();\\n        map<int, vector<pair<int, int>>> mp; // for storing sorted value\\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                mp[mat[i][j]].push_back(make_pair(i, j));\\n        vector<int> row(m, 0), col(n, 0), tmpR(m), tmpC(n);\\n        for (auto &[k, v]: mp) {\\n            for (auto &[x, y]: v) {\\n                int s = max(row[x], col[y]); // total max count for row or col\\n                tmpR[x] = max(tmpR[x], s + 1);\\n                tmpC[y] = max(tmpC[y], s + 1);\\n            }\\n            for (auto &[x, y]: v) {\\n                row[x] = tmpR[x]; // update max count\\n                col[y] = tmpC[y]; // update max count\\n            }\\n        }\\n        return *max_element(col.begin(), col.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> memMin;\\n\\n    int maxIncreasingCells(vector<vector<int>>& mat)\\n    {        \\n        int m = mat.size(), n = mat[0].size();\\n        map<int, vector<pair<int, int>>> mp; // for storing sorted value\\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                mp[mat[i][j]].push_back(make_pair(i, j));\\n        vector<int> row(m, 0), col(n, 0), tmpR(m), tmpC(n);\\n        for (auto &[k, v]: mp) {\\n            for (auto &[x, y]: v) {\\n                int s = max(row[x], col[y]); // total max count for row or col\\n                tmpR[x] = max(tmpR[x], s + 1);\\n                tmpC[y] = max(tmpC[y], s + 1);\\n            }\\n            for (auto &[x, y]: v) {\\n                row[x] = tmpR[x]; // update max count\\n                col[y] = tmpC[y]; // update max count\\n            }\\n        }\\n        return *max_element(col.begin(), col.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606905,
                "title": "python3-o-mn-dp-by-grid-values",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the longest chain that strictly increases. A naive way is to iterate over every node. DP is used here to optimize. We can iterate all values from least to most.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrdp, cdp: Every row and col longest chain length so far.\\nvals: mat positions grouped by value.\\ntr, tc: current group max chain length.\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom itertools import product\\n\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m, n, ans = len(mat), len(mat[0]), 1\\n        rdp, cdp = [0] * m, [0] * n\\n        vals = defaultdict(list)\\n        for r, c in product(range(m), range(n)): vals[mat[r][c]].append((r, c))\\n        for _, pos in sorted(vals.items()):\\n            tr, tc = defaultdict(int), defaultdict(int)\\n            for r, c in pos:\\n                v = max(rdp[r], cdp[c]) + 1\\n                tr[r] = max(tr[r], v)\\n                tc[c] = max(tc[c], v)\\n                ans = max(ans, tr[r])\\n            for r, v in tr.items(): rdp[r] = v\\n            for c, v in tc.items(): cdp[c] = v\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom itertools import product\\n\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m, n, ans = len(mat), len(mat[0]), 1\\n        rdp, cdp = [0] * m, [0] * n\\n        vals = defaultdict(list)\\n        for r, c in product(range(m), range(n)): vals[mat[r][c]].append((r, c))\\n        for _, pos in sorted(vals.items()):\\n            tr, tc = defaultdict(int), defaultdict(int)\\n            for r, c in pos:\\n                v = max(rdp[r], cdp[c]) + 1\\n                tr[r] = max(tr[r], v)\\n                tc[c] = max(tc[c], v)\\n                ans = max(ans, tr[r])\\n            for r, v in tr.items(): rdp[r] = v\\n            for c, v in tc.items(): cdp[c] = v\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601192,
                "title": "visit-in-decreasing-order-and-store-row-and-column-maximum-paths",
                "content": "```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        ps = [(i, j) for i in range(m) for j in range(n)]\\n        ps.sort(key = lambda p: -mat[p[0]][p[1]])\\n        i = 0\\n        rowmax = [0] * m\\n        colmax = [0] * n\\n        dp = [[0] * n for _ in range(m)]\\n        res = 0\\n        for j in range(m * n):\\n            while i < j and mat[ps[i][0]][ps[i][1]] > mat[ps[j][0]][ps[j][1]]:\\n                rowmax[ps[i][0]] = max(rowmax[ps[i][0]], dp[ps[i][0]][ps[i][1]])\\n                colmax[ps[i][1]] = max(colmax[ps[i][1]], dp[ps[i][0]][ps[i][1]])\\n                i += 1\\n            dp[ps[j][0]][ps[j][1]] = 1 + max(rowmax[ps[j][0]], colmax[ps[j][1]])\\n            res = max(res, dp[ps[j][0]][ps[j][1]])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        ps = [(i, j) for i in range(m) for j in range(n)]\\n        ps.sort(key = lambda p: -mat[p[0]][p[1]])\\n        i = 0\\n        rowmax = [0] * m\\n        colmax = [0] * n\\n        dp = [[0] * n for _ in range(m)]\\n        res = 0\\n        for j in range(m * n):\\n            while i < j and mat[ps[i][0]][ps[i][1]] > mat[ps[j][0]][ps[j][1]]:\\n                rowmax[ps[i][0]] = max(rowmax[ps[i][0]], dp[ps[i][0]][ps[i][1]])\\n                colmax[ps[i][1]] = max(colmax[ps[i][1]], dp[ps[i][0]][ps[i][1]])\\n                i += 1\\n            dp[ps[j][0]][ps[j][1]] = 1 + max(rowmax[ps[j][0]], colmax[ps[j][1]])\\n            res = max(res, dp[ps[j][0]][ps[j][1]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597812,
                "title": "c-dfs-only-on-next-bigger-number",
                "content": "# Intuition\\nDFS, but you need to know the order by row , and the order by col\\n\\n# Approach\\n Create ordered mats for effective search. \\n When the row and col are ordered, we can only search next bigger number.\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    int rows;\\n    int cols;\\n    int [][] rowIndex; // r*c  map from mat to row order\\n    int [][] colIndex; // c*r  map from mat to col order\\n    int [][][] rowOrder;// r*c*3\\n    int [][][] colOrder;//c*r*3\\n    public int MaxIncreasingCells(int[][] mat) {\\n         rows = mat.Length;\\n         cols = mat[0].Length;\\n        \\n        int[][] V = new int[rows][];\\n        for(int i=0;i<rows;i++)\\n        {\\n            V[i] = new int[cols];\\n        }\\n        \\n        rowOrder = new int[rows][][];\\n        colOrder = new int[cols][][];\\n        rowIndex = new int[rows][];\\n        Prep(ref rowOrder,   rowIndex,rows,cols,mat);\\n         \\n        colIndex = new int[cols][];\\n        Prep(ref colOrder,  colIndex,cols,rows,mat,false);\\n        \\n      \\n        int max = 1;   \\n         \\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                max = Math.Max(max, DFS(mat,i,j,V));\\n            } \\n        }      \\n        return max; \\n        \\n        \\n    }\\n    \\n    private void Prep(ref int[][][] rowOrder,  int[][] colIndex, int rows ,int cols,int[][] mat, bool prepareRow=true)\\n    {\\n        for(int i=0; i<rows; i++)\\n        {\\n            \\n            rowOrder[i] = new int[cols][];\\n            colIndex[i] = new int[cols];\\n           \\n            for(int j=0;j<cols;j++)\\n            {               \\n                \\n                rowOrder[i][j]    = new int[3];               \\n                rowOrder[i][j][0] = prepareRow? mat[i][j]: mat[j][i];\\n                rowOrder[i][j][1] = j;   //original cols;\\n                rowOrder[i][j][2] = -1;     //next number\\n            }\\n            \\n            rowOrder[i] = rowOrder[i].OrderBy(a=>a[0]).ToArray();\\n            \\n            int m = rowOrder[i][cols-1][0];\\n            int prev = -1;\\n            colIndex[i][rowOrder[i][cols-1][1]] = cols-1;\\n           \\n            for(int k=cols-2;k>=0;k--)\\n            {\\n                if(rowOrder[i][k][0] == m)\\n                {\\n                    rowOrder[i][k][2] = prev;\\n                }\\n                else\\n                {                    \\n                    rowOrder[i][k][2] = k+1;\\n                    m = rowOrder[i][k][0];\\n                    prev = k+1; \\n                }\\n                colIndex[i][rowOrder[i][k][1]] = k;\\n               \\n            }\\n             \\n        }\\n         \\n    }\\n    \\n     private int DFS(int[][] mat, int r, int c, int[][] Visited)\\n    {\\n        \\n        if(Visited[r][c] != 0)\\n        {\\n           \\n            return Visited[r][c];\\n        }\\n         \\n        int res = 1;\\n        int orderIndex = rowIndex[r][c];\\n        int next = rowOrder[r][orderIndex][2];\\n         \\n        if(next!=-1) \\n        {\\n             for(int i=next;i<cols;i++)\\n             {\\n                 if(rowOrder[r][i][0]==rowOrder[r][next][0])\\n                     res = Math.Max(res, 1 + DFS(mat,r,rowOrder[r][i][1],Visited));\\n                 else\\n                     break;\\n             }\\n         }\\n         orderIndex = colIndex[c][r];\\n         next = colOrder[c][orderIndex][2];\\n          \\n         if(next!=-1) \\n         {\\n             for(int i=next;i<rows;i++)\\n             {\\n                 if(colOrder[c][i][0]==colOrder[c][next][0])\\n                     res = Math.Max(res, 1 + DFS(mat,colOrder[c][i][1],c,Visited));\\n                 else\\n                     break;\\n             }\\n         }\\n         \\n        \\n         Visited[r][c] = res;       \\n         return res;        \\n            \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int rows;\\n    int cols;\\n    int [][] rowIndex; // r*c  map from mat to row order\\n    int [][] colIndex; // c*r  map from mat to col order\\n    int [][][] rowOrder;// r*c*3\\n    int [][][] colOrder;//c*r*3\\n    public int MaxIncreasingCells(int[][] mat) {\\n         rows = mat.Length;\\n         cols = mat[0].Length;\\n        \\n        int[][] V = new int[rows][];\\n        for(int i=0;i<rows;i++)\\n        {\\n            V[i] = new int[cols];\\n        }\\n        \\n        rowOrder = new int[rows][][];\\n        colOrder = new int[cols][][];\\n        rowIndex = new int[rows][];\\n        Prep(ref rowOrder,   rowIndex,rows,cols,mat);\\n         \\n        colIndex = new int[cols][];\\n        Prep(ref colOrder,  colIndex,cols,rows,mat,false);\\n        \\n      \\n        int max = 1;   \\n         \\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                max = Math.Max(max, DFS(mat,i,j,V));\\n            } \\n        }      \\n        return max; \\n        \\n        \\n    }\\n    \\n    private void Prep(ref int[][][] rowOrder,  int[][] colIndex, int rows ,int cols,int[][] mat, bool prepareRow=true)\\n    {\\n        for(int i=0; i<rows; i++)\\n        {\\n            \\n            rowOrder[i] = new int[cols][];\\n            colIndex[i] = new int[cols];\\n           \\n            for(int j=0;j<cols;j++)\\n            {               \\n                \\n                rowOrder[i][j]    = new int[3];               \\n                rowOrder[i][j][0] = prepareRow? mat[i][j]: mat[j][i];\\n                rowOrder[i][j][1] = j;   //original cols;\\n                rowOrder[i][j][2] = -1;     //next number\\n            }\\n            \\n            rowOrder[i] = rowOrder[i].OrderBy(a=>a[0]).ToArray();\\n            \\n            int m = rowOrder[i][cols-1][0];\\n            int prev = -1;\\n            colIndex[i][rowOrder[i][cols-1][1]] = cols-1;\\n           \\n            for(int k=cols-2;k>=0;k--)\\n            {\\n                if(rowOrder[i][k][0] == m)\\n                {\\n                    rowOrder[i][k][2] = prev;\\n                }\\n                else\\n                {                    \\n                    rowOrder[i][k][2] = k+1;\\n                    m = rowOrder[i][k][0];\\n                    prev = k+1; \\n                }\\n                colIndex[i][rowOrder[i][k][1]] = k;\\n               \\n            }\\n             \\n        }\\n         \\n    }\\n    \\n     private int DFS(int[][] mat, int r, int c, int[][] Visited)\\n    {\\n        \\n        if(Visited[r][c] != 0)\\n        {\\n           \\n            return Visited[r][c];\\n        }\\n         \\n        int res = 1;\\n        int orderIndex = rowIndex[r][c];\\n        int next = rowOrder[r][orderIndex][2];\\n         \\n        if(next!=-1) \\n        {\\n             for(int i=next;i<cols;i++)\\n             {\\n                 if(rowOrder[r][i][0]==rowOrder[r][next][0])\\n                     res = Math.Max(res, 1 + DFS(mat,r,rowOrder[r][i][1],Visited));\\n                 else\\n                     break;\\n             }\\n         }\\n         orderIndex = colIndex[c][r];\\n         next = colOrder[c][orderIndex][2];\\n          \\n         if(next!=-1) \\n         {\\n             for(int i=next;i<rows;i++)\\n             {\\n                 if(colOrder[c][i][0]==colOrder[c][next][0])\\n                     res = Math.Max(res, 1 + DFS(mat,colOrder[c][i][1],c,Visited));\\n                 else\\n                     break;\\n             }\\n         }\\n         \\n        \\n         Visited[r][c] = res;       \\n         return res;        \\n            \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593135,
                "title": "python-dp-clean-and-simple-20-lines-long",
                "content": "### Intuition)\\n**Step1.** Sort the values of the cells in descending order, with their coordinates.\\n**Step2.** Visit each value one by one, starting from the largest.\\n- **2.1** Update the maximum length in the visited row.\\n- **2.2** Update the maximum length in the visited column.\\n\\n\\t- Note: \"Maximum length\" refers to the length of the longest route. \\n<br>\\n\\n### Caution)\\n In a sorted list, when identical value cell exist, we cannot move relative to each other. Therefore, when updating the maximum length, the following algorithm is used:\\n**Caution1.** Within the range of identical values, update a temporary variable, \\'temp\\', first.\\n**Caution2.** Once the range of identical values ends, commit the update!\\n\\n<br>\\n\\n### Code)\\n\\n```python\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        I, J = len(mat), len(mat[0])\\n        locs = defaultdict(list)\\n        \\n        #// Step1. Sort the values of the cells in descending order, with their coordinates.\\n        for i in range(I):\\n            for j in range(J):\\n                locs[mat[i][j]].append((i, j))\\n        keys = sorted(locs.keys(), reverse=True)\\n        \\n        # Step2.1. Update the maximum length in the visited row.\\n        # Step2.2. Update the maximum length in the visited column.\\n        _is, _js = {}, {} \\n\\n        for val in keys:\\n            temp_is = {}\\n            temp_js = {}\\n            #// Caution1. Within the range of identical values, update a temporary variable, \\'temp\\', first.\\n            for (i, j) in locs[val]:\\n                max_length = max(_is.get(i,0), _js.get(j,0))\\n                temp_is[i] = max(temp_is.get(i, 0), max_length + 1) \\n                temp_js[j] = max(temp_js.get(j, 0), max_length + 1) \\n            \\n            #// Caution2. Once the range of identical values ends, commit the update!\\n            _is.update(temp_is)\\n            _js.update(temp_js)\\n        \\n        return max(max(_is.values()), max(_js.values()))\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        I, J = len(mat), len(mat[0])\\n        locs = defaultdict(list)\\n        \\n        #// Step1. Sort the values of the cells in descending order, with their coordinates.\\n        for i in range(I):\\n            for j in range(J):\\n                locs[mat[i][j]].append((i, j))\\n        keys = sorted(locs.keys(), reverse=True)\\n        \\n        # Step2.1. Update the maximum length in the visited row.\\n        # Step2.2. Update the maximum length in the visited column.\\n        _is, _js = {}, {} \\n\\n        for val in keys:\\n            temp_is = {}\\n            temp_js = {}\\n            #// Caution1. Within the range of identical values, update a temporary variable, \\'temp\\', first.\\n            for (i, j) in locs[val]:\\n                max_length = max(_is.get(i,0), _js.get(j,0))\\n                temp_is[i] = max(temp_is.get(i, 0), max_length + 1) \\n                temp_js[j] = max(temp_js.get(j, 0), max_length + 1) \\n            \\n            #// Caution2. Once the range of identical values ends, commit the update!\\n            _is.update(temp_is)\\n            _js.update(temp_js)\\n        \\n        return max(max(_is.values()), max(_js.values()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589238,
                "title": "easy-understanding-well-commented-dp-binary-search-100-accepted-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        // TAKING 2 ORDERED MAP TO STORE THE ELEMENT OF ROW AND COL WITH THEIR VALUE :\\n        // THIS IS DONE TO GET THE NEXT GREATER ELEMENT IN O(logN) TIME :\\n        // <element, {colNumber(for row) / rowNumber(for col)}> (FOR ANY DOUBT, DRAW IT)\\n        \\n        map<int, vector<int>> row[m];\\n        map<int, vector<int>> col[n];\\n        \\n        // FILLING UP THE MAPS :\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                row[i][mat[i][j]].emplace_back(j);\\n                col[j][mat[i][j]].emplace_back(i);\\n            }\\n        }\\n        \\n        // TAKING A DP :\\n        vector<vector<int>> dp(m, vector<int> (n, -1));\\n        \\n        // TAKING A VARIABLE TO STORE MAXIMUM CELLS VISITED :\\n        int ans = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                ans = max(ans, f(i, j, row, col, mat, dp));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\nprivate:\\n    int f(int i, int j, map<int, vector<int>> row[], map<int, vector<int>> col[], vector<vector<int>> &mat, vector<vector<int>> &dp) {\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int cnt = 1;\\n        \\n        // FOR ROW[i] :\\n        // GETTING THE JUST GREATER ELEMENT IN THAT ROW:\\n        auto rowItr = row[i].upper_bound(mat[i][j]);\\n        // IF FOUND, MAKE A RECURSIVE CALL ON ALL THE POSSIBILITIES:\\n        if(rowItr != row[i].end()) {\\n            vector<int> indices = rowItr->second;\\n            \\n            for(int &it : indices) {\\n                cnt = max(cnt, 1 + f(i, it, row, col, mat, dp));\\n            }\\n        }\\n        \\n        // FOR COL[j] :\\n        // GETTING THE JUST GREATER ELEMENT INT THAT COLUMN :\\n        auto colItr = col[j].upper_bound(mat[i][j]);\\n        // IF FOUND, MAKE A RECURSIVE CALL ON ALL THE POSSIBILITIES :\\n        if(colItr != col[j].end()) {\\n            vector<int> indices = colItr->second;\\n            \\n            for(int &it : indices) {\\n                cnt = max(cnt, 1 + f(it, j, row, col, mat, dp));\\n            }\\n        }\\n        \\n        return dp[i][j] = cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        // TAKING 2 ORDERED MAP TO STORE THE ELEMENT OF ROW AND COL WITH THEIR VALUE :\\n        // THIS IS DONE TO GET THE NEXT GREATER ELEMENT IN O(logN) TIME :\\n        // <element, {colNumber(for row) / rowNumber(for col)}> (FOR ANY DOUBT, DRAW IT)\\n        \\n        map<int, vector<int>> row[m];\\n        map<int, vector<int>> col[n];\\n        \\n        // FILLING UP THE MAPS :\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                row[i][mat[i][j]].emplace_back(j);\\n                col[j][mat[i][j]].emplace_back(i);\\n            }\\n        }\\n        \\n        // TAKING A DP :\\n        vector<vector<int>> dp(m, vector<int> (n, -1));\\n        \\n        // TAKING A VARIABLE TO STORE MAXIMUM CELLS VISITED :\\n        int ans = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                ans = max(ans, f(i, j, row, col, mat, dp));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\nprivate:\\n    int f(int i, int j, map<int, vector<int>> row[], map<int, vector<int>> col[], vector<vector<int>> &mat, vector<vector<int>> &dp) {\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int cnt = 1;\\n        \\n        // FOR ROW[i] :\\n        // GETTING THE JUST GREATER ELEMENT IN THAT ROW:\\n        auto rowItr = row[i].upper_bound(mat[i][j]);\\n        // IF FOUND, MAKE A RECURSIVE CALL ON ALL THE POSSIBILITIES:\\n        if(rowItr != row[i].end()) {\\n            vector<int> indices = rowItr->second;\\n            \\n            for(int &it : indices) {\\n                cnt = max(cnt, 1 + f(i, it, row, col, mat, dp));\\n            }\\n        }\\n        \\n        // FOR COL[j] :\\n        // GETTING THE JUST GREATER ELEMENT INT THAT COLUMN :\\n        auto colItr = col[j].upper_bound(mat[i][j]);\\n        // IF FOUND, MAKE A RECURSIVE CALL ON ALL THE POSSIBILITIES :\\n        if(colItr != col[j].end()) {\\n            vector<int> indices = colItr->second;\\n            \\n            for(int &it : indices) {\\n                cnt = max(cnt, 1 + f(it, j, row, col, mat, dp));\\n            }\\n        }\\n        \\n        return dp[i][j] = cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585032,
                "title": "memorization-concept",
                "content": "# Approach\\nStores the strictly increasing value in the array while traversing\\nand using it when ever it is encountered \\n\\n# Code\\n```\\nclass Solution {\\n    public int helper(int[][] arr,int[][] v,int x,int y,int count){\\n        int val = count;\\n        for(int i=0;i<arr.length;i++){ //x y -> i\\n            if(arr[i][y]>arr[x][y]){\\n                if(v[i][y]==0){\\n                    v[i][y] = helper(arr,v,i,y,1); //+count\\n                    if(val<v[i][y]+count) val = v[i][y]+count;\\n                }\\n                else if(val<count+v[i][y]) \\n                    val = count+v[i][y];\\n            }\\n        }\\n        for(int i=0;i<arr[0].length;i++){\\n            if(arr[x][i]>arr[x][y]){\\n                if(v[x][i]==0){\\n                    v[x][i] = helper(arr,v,x,i,1); //+count\\n                    if(val<v[x][i]+count) val = v[x][i]+count;\\n                }\\n                else if(val<count+v[x][i]) \\n                    val = count+v[x][i];\\n            }\\n        }\\n        return val;\\n    }\\n    public int maxIncreasingCells(int[][] mat) {\\n        int ans = 1;\\n        if(mat.length==1){\\n            HashSet<Integer> s = new HashSet<Integer>();\\n            for(int i=0;i<mat[0].length;i++)\\n                s.add(mat[0][i]);\\n            return s.size();\\n        }\\n        else if(mat[0].length==1){\\n            HashSet<Integer> s = new HashSet<Integer>();\\n            for(int i=0;i<mat.length;i++)\\n                s.add(mat[i][0]);\\n            return s.size();\\n        }\\n        int v[][] = new int[mat.length][mat[0].length];\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                if(v[i][j]==0)\\n                    v[i][j] = helper(mat,v,i,j,1);\\n                if(v[i][j]>ans)\\n                    ans = v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int helper(int[][] arr,int[][] v,int x,int y,int count){\\n        int val = count;\\n        for(int i=0;i<arr.length;i++){ //x y -> i\\n            if(arr[i][y]>arr[x][y]){\\n                if(v[i][y]==0){\\n                    v[i][y] = helper(arr,v,i,y,1); //+count\\n                    if(val<v[i][y]+count) val = v[i][y]+count;\\n                }\\n                else if(val<count+v[i][y]) \\n                    val = count+v[i][y];\\n            }\\n        }\\n        for(int i=0;i<arr[0].length;i++){\\n            if(arr[x][i]>arr[x][y]){\\n                if(v[x][i]==0){\\n                    v[x][i] = helper(arr,v,x,i,1); //+count\\n                    if(val<v[x][i]+count) val = v[x][i]+count;\\n                }\\n                else if(val<count+v[x][i]) \\n                    val = count+v[x][i];\\n            }\\n        }\\n        return val;\\n    }\\n    public int maxIncreasingCells(int[][] mat) {\\n        int ans = 1;\\n        if(mat.length==1){\\n            HashSet<Integer> s = new HashSet<Integer>();\\n            for(int i=0;i<mat[0].length;i++)\\n                s.add(mat[0][i]);\\n            return s.size();\\n        }\\n        else if(mat[0].length==1){\\n            HashSet<Integer> s = new HashSet<Integer>();\\n            for(int i=0;i<mat.length;i++)\\n                s.add(mat[i][0]);\\n            return s.size();\\n        }\\n        int v[][] = new int[mat.length][mat[0].length];\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                if(v[i][j]==0)\\n                    v[i][j] = helper(mat,v,i,j,1);\\n                if(v[i][j]>ans)\\n                    ans = v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584547,
                "title": "c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int rows = mat.size();\\n        int cols = mat[0].size();\\n\\n        map<int , vector<pair<int, int>>> m;\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++) m[mat[i][j]].push_back({i, j});\\n        }\\n\\n        //max dist from smallest ele in given row and col\\n        vector<int> maxinrow(rows, 0);\\n        vector<int> maxincol(cols, 0);\\n\\n        vector<vector<int>> dp(rows, vector<int>(cols, 0));\\n\\n        for(auto &[val, coords]: m){\\n            for(auto &coord: coords){\\n                int r = coord.first;\\n                int c = coord.second;\\n                dp[r][c] = max(maxinrow[r], maxincol[c]) + 1;\\n            }\\n            for(auto &coord: coords){\\n                int r = coord.first;\\n                int c = coord.second;\\n                maxinrow[r] = max(maxinrow[r], dp[r][c]);\\n                maxincol[c] = max(maxincol[c], dp[r][c]);\\n            }\\n        }\\n\\n        return *max_element(maxinrow.begin(), maxinrow.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int rows = mat.size();\\n        int cols = mat[0].size();\\n\\n        map<int , vector<pair<int, int>>> m;\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++) m[mat[i][j]].push_back({i, j});\\n        }\\n\\n        //max dist from smallest ele in given row and col\\n        vector<int> maxinrow(rows, 0);\\n        vector<int> maxincol(cols, 0);\\n\\n        vector<vector<int>> dp(rows, vector<int>(cols, 0));\\n\\n        for(auto &[val, coords]: m){\\n            for(auto &coord: coords){\\n                int r = coord.first;\\n                int c = coord.second;\\n                dp[r][c] = max(maxinrow[r], maxincol[c]) + 1;\\n            }\\n            for(auto &coord: coords){\\n                int r = coord.first;\\n                int c = coord.second;\\n                maxinrow[r] = max(maxinrow[r], dp[r][c]);\\n                maxincol[c] = max(maxincol[c], dp[r][c]);\\n            }\\n        }\\n\\n        return *max_element(maxinrow.begin(), maxinrow.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582328,
                "title": "c-easy-to-understand-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n= mat.size();\\n        int m= mat[0].size();\\n\\n        vector<int> r(n), c(m);\\n        unordered_map<int, vector<pair<int,int>>>mp;\\n        vector<vector<int>>dp(n, vector<int>(m,0));\\n        set<int>st;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                mp[mat[i][j]].push_back({i,j});\\n                st.insert(mat[i][j]);\\n            }\\n        }\\n\\n        for(auto &z:st){\\n            for(auto &it: mp[z]){\\n                dp[it.first][it.second]= max(r[it.first], c[it.second])+1;\\n            }\\n            for(auto &it: mp[z]){\\n                r[it.first]= max(r[it.first], dp[it.first][it.second]);\\n                c[it.second]= max(c[it.second], dp[it.first][it.second]);\\n            }\\n        }\\n        int a= *max_element(r.begin(), r.end());\\n        int b= *max_element(c.begin(), c.end());\\n\\n        return max(a,b);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n= mat.size();\\n        int m= mat[0].size();\\n\\n        vector<int> r(n), c(m);\\n        unordered_map<int, vector<pair<int,int>>>mp;\\n        vector<vector<int>>dp(n, vector<int>(m,0));\\n        set<int>st;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                mp[mat[i][j]].push_back({i,j});\\n                st.insert(mat[i][j]);\\n            }\\n        }\\n\\n        for(auto &z:st){\\n            for(auto &it: mp[z]){\\n                dp[it.first][it.second]= max(r[it.first], c[it.second])+1;\\n            }\\n            for(auto &it: mp[z]){\\n                r[it.first]= max(r[it.first], dp[it.first][it.second]);\\n                c[it.second]= max(c[it.second], dp[it.first][it.second]);\\n            }\\n        }\\n        int a= *max_element(r.begin(), r.end());\\n        int b= *max_element(c.begin(), c.end());\\n\\n        return max(a,b);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581186,
                "title": "time-optimized-well-explained-commented-code-c",
                "content": "# Intuition\\nDeciding on why Greedy would fail: Always starting from the smallest number towards greater number need not be the ans, as this path may be limited by equal values at some point. While a longer path may exist in higher values which may never be discovered.\\n\\n- Hence, need to check all the cells as the starting point.\\n- Time-Optimized using DP, and using Map to track the indices updated.\\n\\n\\n# Approach\\n- Sort the values, storing the indices with the val. Custom struct \\'Cell\\' used as the data structure.\\n- Used 2 vectors: init. mxRows(R,0) and mxCols(C,0) \\n    - mxRows[x] = maximum length of Sequence possible starting from any cell  in row x.\\n    - mxCols[y] = maximum length of Sequence possible starting from any cell in col y.\\n- In case of repeating values, can\\'t update the mxRows, and mxCols result before exhausting all the repetetive values first, storing their result in a Map, to time optimize on updating mxRows, mxCols eventually.\\n- This is because a transition can only be made to strictly increase number in a cell.\\n\\n# Complexity\\n- Time complexity:\\nSorting the vector of len $$R*C = O(R*C*log(R*C))$$\\nFor Loop:\\nO(iterating through $$R*C cells*(Iterating through$$ Unordered_Map)) $$= O(R*C*1(avg))$$\\n\\nOverall that of Sorting\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define F first\\n    #define S second\\n    struct Cell{\\n        int row, col, val;\\n        Cell(int r, int c, int x): row(r), col(c), val(x) {}\\n        \\n        //defining comparison operator for the struct\\n        //so that the compiler is able to sort without throwing err\\n        bool operator < (const Cell& C) const{\\n            return val < C.val;\\n        }\\n    };\\n\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int R=mat.size(), C=mat[0].size();\\n\\n        //res is going to be the maximum length of sequence from \\n        //all row and cols, can\\'t go greedy.\\n        //will have to recurse over all cells\\n        //time optimized with caching the res for larger values first\\n        //hence, also impt to sort the values in the matrix\\n        //storing the values, and indices reqd, done using custom struct\\n        vector<Cell> cells;\\n        for(int r=0;r<R;r++){\\n            for(int c=0;c<C;c++){\\n                cells.push_back({r,c,mat[r][c]});\\n            }\\n        }\\n        sort(cells.begin(), cells.end());\\n\\n        vector<int> mxRows(R,0);\\n        //mxLenR[r] = max length possible starting from any value in row r\\n        vector<int> mxCols(C,0);\\n        //mxLenC[c] = max length possible starting from any value in col c\\n        \\n        int res=1;\\n\\n        //for more than 1 occurence of any number\\n        //before finalizing the result for its row, col\\n        //need to find the max len seq for all occurences first\\n        //can be time optimized using a map, to track indices updated\\n        for(int i=R*C-1; i>=0;){\\n            int cur_val = cells[i].val;\\n\\n            unordered_map<int, int> curVal_mxRows;\\n            unordered_map<int, int> curVal_mxCols;\\n\\n            for(int j=i; j>=0 and cells[j].val == cur_val; j--, i--){\\n                int x = cells[j].row;\\n                int y = cells[j].col;\\n\\n                int cur_mx = 1 + max(mxRows[x], mxCols[y]);\\n                res = max(res, cur_mx);\\n\\n                curVal_mxRows[x] = max(curVal_mxRows[x], cur_mx);\\n                curVal_mxCols[y] = max(curVal_mxCols[y], cur_mx);\\n            }\\n\\n            for(auto it:curVal_mxRows) mxRows[it.F] = max(mxRows[it.F], it.S);\\n            for(auto it:curVal_mxCols) mxCols[it.F] = max(mxCols[it.F], it.S);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define F first\\n    #define S second\\n    struct Cell{\\n        int row, col, val;\\n        Cell(int r, int c, int x): row(r), col(c), val(x) {}\\n        \\n        //defining comparison operator for the struct\\n        //so that the compiler is able to sort without throwing err\\n        bool operator < (const Cell& C) const{\\n            return val < C.val;\\n        }\\n    };\\n\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int R=mat.size(), C=mat[0].size();\\n\\n        //res is going to be the maximum length of sequence from \\n        //all row and cols, can\\'t go greedy.\\n        //will have to recurse over all cells\\n        //time optimized with caching the res for larger values first\\n        //hence, also impt to sort the values in the matrix\\n        //storing the values, and indices reqd, done using custom struct\\n        vector<Cell> cells;\\n        for(int r=0;r<R;r++){\\n            for(int c=0;c<C;c++){\\n                cells.push_back({r,c,mat[r][c]});\\n            }\\n        }\\n        sort(cells.begin(), cells.end());\\n\\n        vector<int> mxRows(R,0);\\n        //mxLenR[r] = max length possible starting from any value in row r\\n        vector<int> mxCols(C,0);\\n        //mxLenC[c] = max length possible starting from any value in col c\\n        \\n        int res=1;\\n\\n        //for more than 1 occurence of any number\\n        //before finalizing the result for its row, col\\n        //need to find the max len seq for all occurences first\\n        //can be time optimized using a map, to track indices updated\\n        for(int i=R*C-1; i>=0;){\\n            int cur_val = cells[i].val;\\n\\n            unordered_map<int, int> curVal_mxRows;\\n            unordered_map<int, int> curVal_mxCols;\\n\\n            for(int j=i; j>=0 and cells[j].val == cur_val; j--, i--){\\n                int x = cells[j].row;\\n                int y = cells[j].col;\\n\\n                int cur_mx = 1 + max(mxRows[x], mxCols[y]);\\n                res = max(res, cur_mx);\\n\\n                curVal_mxRows[x] = max(curVal_mxRows[x], cur_mx);\\n                curVal_mxCols[y] = max(curVal_mxCols[y], cur_mx);\\n            }\\n\\n            for(auto it:curVal_mxRows) mxRows[it.F] = max(mxRows[it.F], it.S);\\n            for(auto it:curVal_mxCols) mxCols[it.F] = max(mxCols[it.F], it.S);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579639,
                "title": "ruby-solution-with-dp-100-100",
                "content": "# Intuition\\nGo through the numbers from smallest to largest and create the longest path up to each cell with tabulation\\n\\n# Approach\\nTranslated to Ruby from mdakram28\\'s solution:\\nhttps://leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/solutions/3570677/explained-o-m-n-log-m-n-solution-python/\\n\\n1. Find the dimensions of the matrix.\\n2. Group the cells of the matrix by value, storing their position.  (They need to be grouped because the path must be strictly increasing.)\\n3. Create hashes for the longest sequence so far in each row.\\n4. Iterate through the values of the matrix in reverse order:\\n    - For each cell, the new longest path will be either 1 more than the previous longest path for that row, or 1 more than the previous longest for that column.\\n    - Don\\'t update previous until you\\'ve gone through all cells of a given value -- this leads to issues if you have two cells with the same value in the same row/column.\\n5. Take the largest value from each prev_row or prev_col\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n * log(m*n))$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\ndef max_increasing_cells(mat)\\n    m,n = mat.length,mat[0].length\\n\\n    positions = Hash.new { |h,k| h[k] = [] }\\n\\n    (0...m).each do |i|\\n        (0...n).each do |j|\\n            positions[mat[i][j]] << [i,j]\\n        end\\n    end\\n\\n    prev_row = Hash.new(0)\\n    prev_col = Hash.new(0)\\n\\n    positions.keys.sort.reverse.each do |key|\\n        next_row = Hash.new(0)\\n        next_col = Hash.new(0)\\n\\n        positions[key].each do |pos|\\n            row,col = pos\\n            prev = [prev_row[row], prev_col[col]].max\\n\\n            next_row[row] = [next_row[row], prev + 1].max\\n            next_col[col] = [next_col[col], prev + 1].max\\n        end\\n\\n        prev_row.merge!(next_row)\\n        prev_col.merge!(next_col)\\n    end\\n\\n    prev_row.values.max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef max_increasing_cells(mat)\\n    m,n = mat.length,mat[0].length\\n\\n    positions = Hash.new { |h,k| h[k] = [] }\\n\\n    (0...m).each do |i|\\n        (0...n).each do |j|\\n            positions[mat[i][j]] << [i,j]\\n        end\\n    end\\n\\n    prev_row = Hash.new(0)\\n    prev_col = Hash.new(0)\\n\\n    positions.keys.sort.reverse.each do |key|\\n        next_row = Hash.new(0)\\n        next_col = Hash.new(0)\\n\\n        positions[key].each do |pos|\\n            row,col = pos\\n            prev = [prev_row[row], prev_col[col]].max\\n\\n            next_row[row] = [next_row[row], prev + 1].max\\n            next_col[col] = [next_col[col], prev + 1].max\\n        end\\n\\n        prev_row.merge!(next_row)\\n        prev_col.merge!(next_col)\\n    end\\n\\n    prev_row.values.max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3579268,
                "title": "very-interesting-solution-intuition-logic-graph-traversal-in-matrix-itself",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n\\n\\n        // question is - getting longest path while moving from one node with some value to another \\n        //               having value strictly greater than previous\\n        \\n        // so INTUTION ----> think of movement from one cell to another gives imagination of graphs\\n        // if we convert it into graph \\n        //example -- mat[[3 , 1 ,6 ] , [-9 , 5, 7]]\\n         \\n         //  1--->  can go to 3,6,5 ( same row and column traversal only)\\n         // -9---> can go to 3,5,7\\n         //  6----> 7\\n         //  5 ---> 7\\n         //  3 ---> 6\\n         //  7--> none\\n\\n            // LOGIC\\n         // so to traverse in this graph , from low to high , topological sort comes in mind\\n         // high indegree to low indegree\\n         // one problem in making adjacency list \\n         // that think of this  row 123456 for making adjacency in same row we move all columns and same for every other value \\n         // apply THIS GRAPH IN MATRIX ITSELF:\\n\\n         // So done by taking one row r vector and one column c vector\\n\\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        vector<int> r(n),c(m);\\n\\n        // temp vector same as mat keep record of length\\n\\n        vector<vector<int>> temp(n, vector<int> (m,0));\\n        // create set s which gives greater elememt \\n        // take greater elememt first we traverse the longest path from last\\n        set<int,greater<int>> s;\\n\\n        unordered_map<int, vector<vector<int>> > store;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                store[mat[i][j]].push_back({i,j});\\n                s.insert(mat[i][j]);\\n            }\\n        }\\n\\n        for(auto i: s)\\n        {\\n            for(auto it : store[i])\\n            {\\n                int a = it[0];\\n                int b = it[1];\\n                temp[a][b] = max(r[a],c[b])+1;\\n            }\\n            for(auto it : store[i])\\n            {\\n                int a = it[0];\\n                int b = it[1];\\n                r[a] = max(r[a],temp[a][b]);\\n                c[b] = max(c[b],temp[a][b]);\\n            }\\n\\n        }\\n        return max(*max_element(r.begin(),r.end()) , *max_element(c.begin() , c.end()));\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n\\n\\n        // question is - getting longest path while moving from one node with some value to another \\n        //               having value strictly greater than previous\\n        \\n        // so INTUTION ----> think of movement from one cell to another gives imagination of graphs\\n        // if we convert it into graph \\n        //example -- mat[[3 , 1 ,6 ] , [-9 , 5, 7]]\\n         \\n         //  1--->  can go to 3,6,5 ( same row and column traversal only)\\n         // -9---> can go to 3,5,7\\n         //  6----> 7\\n         //  5 ---> 7\\n         //  3 ---> 6\\n         //  7--> none\\n\\n            // LOGIC\\n         // so to traverse in this graph , from low to high , topological sort comes in mind\\n         // high indegree to low indegree\\n         // one problem in making adjacency list \\n         // that think of this  row 123456 for making adjacency in same row we move all columns and same for every other value \\n         // apply THIS GRAPH IN MATRIX ITSELF:\\n\\n         // So done by taking one row r vector and one column c vector\\n\\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        vector<int> r(n),c(m);\\n\\n        // temp vector same as mat keep record of length\\n\\n        vector<vector<int>> temp(n, vector<int> (m,0));\\n        // create set s which gives greater elememt \\n        // take greater elememt first we traverse the longest path from last\\n        set<int,greater<int>> s;\\n\\n        unordered_map<int, vector<vector<int>> > store;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                store[mat[i][j]].push_back({i,j});\\n                s.insert(mat[i][j]);\\n            }\\n        }\\n\\n        for(auto i: s)\\n        {\\n            for(auto it : store[i])\\n            {\\n                int a = it[0];\\n                int b = it[1];\\n                temp[a][b] = max(r[a],c[b])+1;\\n            }\\n            for(auto it : store[i])\\n            {\\n                int a = it[0];\\n                int b = it[1];\\n                r[a] = max(r[a],temp[a][b]);\\n                c[b] = max(c[b],temp[a][b]);\\n            }\\n\\n        }\\n        return max(*max_element(r.begin(),r.end()) , *max_element(c.begin() , c.end()));\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577011,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, we turn the matrix into a graph. Each matrix entry is a vertex, for a total of **mn** vertices, where m and n are the dimensions of the matrix.\\nFor each matrix entry, we find the list of entries with the next-highest value on its line and column. This relation corresponds to a **directed** edge.\\nThere are at most **mn(m+n)** edges, because from a line of length n we can get $O(n^2)$ edges.\\n\\nWe keep a list of the maximum lengths of paths ending at each vertex. We update it by going over all the entries in the matrix, **in order, from the lowest to the highest value**, and following the edges to update the maximum lengths. **We only need to go over all the vertices and all the edges once.**\\n\\nThe maximum length at the end, taking the maximum over all vertices, is the answer.\\n\\nI found this approach after considering much more complicated ideas.\\n\\n# Complexity\\n- Time complexity: $O(mn(m+n))$, because we go over each edge and vertex at most once. We also perform some sorting, which takes $O(mn\\\\log(mn))$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(mn)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        gx=[[[]]*n for _ in range(m)]\\n        gy=[[[]]*m for _ in range(n)]\\n        \\n        for i in range(m):\\n            g=gx[i]\\n            mt=mat[i]\\n            tmp=[(j, mt[j]) for j in range(n)]\\n            tmp.sort(key=lambda x:x[1])\\n            prev=tmp[0][1]\\n            tmp_lst1=[]\\n            for tm in tmp:\\n                if tm[1]!=prev:\\n                    prev=tm[1]\\n                    tmp_lst2=[]\\n                    for j in tmp_lst1:\\n                        g[j]=tmp_lst2\\n                    tmp_lst1=tmp_lst2\\n                tmp_lst1.append(tm[0])\\n        \\n        for j in range(n):\\n            g=gy[j]\\n            tmp=[(i, mat[i][j]) for i in range(m)]\\n            tmp.sort(key=lambda x:x[1])\\n            prev=tmp[0][1]\\n            tmp_lst1=[]\\n            for tm in tmp:\\n                if tm[1]!=prev:\\n                    prev=tm[1]\\n                    tmp_lst2=[]\\n                    for j in tmp_lst1:\\n                        g[j]=tmp_lst2\\n                    tmp_lst1=tmp_lst2\\n                tmp_lst1.append(tm[0])\\n\\n\\n        q=[(mat[i][j], i, j) for i in range(m) for j in range(n)]\\n        q.sort(key=lambda x:x[0])\\n\\n        a=[[1]*n for _ in range(m)]\\n\\n        for _, x, y in q:\\n            a0=a[x][y]+1\\n            for y1 in gx[x][y]:\\n                if a0>a[x][y1]:\\n                    a[x][y1]=a0\\n            for x1 in gy[y][x]:\\n                if a0>a[x1][y]:\\n                    a[x1][y]=a0\\n        \\n        return max(a[i][j] for i in range(m) for j in range(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        gx=[[[]]*n for _ in range(m)]\\n        gy=[[[]]*m for _ in range(n)]\\n        \\n        for i in range(m):\\n            g=gx[i]\\n            mt=mat[i]\\n            tmp=[(j, mt[j]) for j in range(n)]\\n            tmp.sort(key=lambda x:x[1])\\n            prev=tmp[0][1]\\n            tmp_lst1=[]\\n            for tm in tmp:\\n                if tm[1]!=prev:\\n                    prev=tm[1]\\n                    tmp_lst2=[]\\n                    for j in tmp_lst1:\\n                        g[j]=tmp_lst2\\n                    tmp_lst1=tmp_lst2\\n                tmp_lst1.append(tm[0])\\n        \\n        for j in range(n):\\n            g=gy[j]\\n            tmp=[(i, mat[i][j]) for i in range(m)]\\n            tmp.sort(key=lambda x:x[1])\\n            prev=tmp[0][1]\\n            tmp_lst1=[]\\n            for tm in tmp:\\n                if tm[1]!=prev:\\n                    prev=tm[1]\\n                    tmp_lst2=[]\\n                    for j in tmp_lst1:\\n                        g[j]=tmp_lst2\\n                    tmp_lst1=tmp_lst2\\n                tmp_lst1.append(tm[0])\\n\\n\\n        q=[(mat[i][j], i, j) for i in range(m) for j in range(n)]\\n        q.sort(key=lambda x:x[0])\\n\\n        a=[[1]*n for _ in range(m)]\\n\\n        for _, x, y in q:\\n            a0=a[x][y]+1\\n            for y1 in gx[x][y]:\\n                if a0>a[x][y1]:\\n                    a[x][y1]=a0\\n            for x1 in gy[y][x]:\\n                if a0>a[x1][y]:\\n                    a[x1][y]=a0\\n        \\n        return max(a[i][j] for i in range(m) for j in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575788,
                "title": "i-have-spent-so-much-time-to-solve-it-feel",
                "content": "# Intuition\\nDynamic programming\\n\\nbut \\n\\nnot on edges)\\n\\n\\n# Approach\\nDynamic on values in vertexes. For mx-value the only length of path is one. For smaller value the length of path is..? \\n\\n..?\\n..?\\n\\n1 + the length of path of vertexes with larger value that are on the same row or column. And that is already calculated on the previous step. And we don\\'t need to try all vertexes on the same row or column, since we need only the length of path.\\n\\nHere, term \\'dynamic programming on smth\\' is used freely.\\nHere, the path of a vertex is the one that starts from the vertex.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\cdot m\\\\cdot log(n\\\\cdot m))$$\\n\\n- Space complexity: $$O(n\\\\cdot m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& a) {\\n        int n{(int)a.size()}, m{(int)a[0].size()};\\n        vector<pair<int,int>> o;\\n        for(int i{}; i<n; ++i) for(int j{}; j<m; ++j)\\n            o.emplace_back(i,j);\\n        sort(o.begin(), o.end(), [&a](const pair<int,int>& c, const pair<int,int>& C){\\n            return a[c.first][c.second] < a[C.first][C.second]; });\\n        vector<int> mx_x(n,numeric_limits<int>::min()), mx_y(m,numeric_limits<int>::min());\\n        for(int i{n*m-1}; i>=0;){\\n            auto [x,y] {o[i]};\\n            int A{a[x][y]};\\n            vector<array<int,3>> upd;\\n            do\\n                upd.push_back({x, y, max(0,max(mx_x[x], mx_y[y])) + 1});\\n            while(--i>=0 && a[x=o[i].first][y=o[i].second]==A);\\n            for (auto[x,y,v] : upd){\\n                mx_x[x] = max(mx_x[x], v);\\n                mx_y[y] = max(mx_y[y], v);\\n            }\\n        }\\n        return max(*max_element(mx_x.begin(), mx_x.end()), *max_element(mx_y.begin(), mx_y.end()));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& a) {\\n        int n{(int)a.size()}, m{(int)a[0].size()};\\n        vector<pair<int,int>> o;\\n        for(int i{}; i<n; ++i) for(int j{}; j<m; ++j)\\n            o.emplace_back(i,j);\\n        sort(o.begin(), o.end(), [&a](const pair<int,int>& c, const pair<int,int>& C){\\n            return a[c.first][c.second] < a[C.first][C.second]; });\\n        vector<int> mx_x(n,numeric_limits<int>::min()), mx_y(m,numeric_limits<int>::min());\\n        for(int i{n*m-1}; i>=0;){\\n            auto [x,y] {o[i]};\\n            int A{a[x][y]};\\n            vector<array<int,3>> upd;\\n            do\\n                upd.push_back({x, y, max(0,max(mx_x[x], mx_y[y])) + 1});\\n            while(--i>=0 && a[x=o[i].first][y=o[i].second]==A);\\n            for (auto[x,y,v] : upd){\\n                mx_x[x] = max(mx_x[x], v);\\n                mx_y[y] = max(mx_y[y], v);\\n            }\\n        }\\n        return max(*max_element(mx_x.begin(), mx_x.end()), *max_element(mx_y.begin(), mx_y.end()));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575198,
                "title": "c-simple-and-fast-solution-dp-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nto get rid of the head ache of finding positions where a possible next jump can be made from any current cell(the cells in current row and col strictly greater) we can sort the matrix and solve the cells in decreasig order that way while solving for the current cell we konw that all the strictly greater positions where this can go are already solved.\\nNow , to avoid finding the best cell in row and col to move to we can maintain a array for every row and col which store the maximum steps that can be made from that particular row or column from any cell we would always like to jump to the cell giving us maximum further steps(can be in the same row or col) now to deal with the edge cases like when the row\\'s maximum steps has achieved from the element that is exactly equal to the current element(in that case we can not jump to that cell even if it is giving us more steps to move bcz that is not the strictly greater element), to deal with this we can maintain two best jumps in the above case same element , the second better option can be considered(which is due to the just greater elemenmt in the same row or column).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBottom Up dp + sorting\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mxnlog(mxn) + mxn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mxn)\\n<BR>\\n<BR>\\nIT TAKES A LOT OF EFFORTS\\n**PLS UPVOTE IF IT HELPED!!**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int ans=0;\\n        int ind=0;\\n        vector<vector<int>> arr(m*n);  // to store the sorted order of elements [0]->element,[1]->row index,[2]->col index\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                arr[ind++]={mat[i][j],i,j};\\n            }\\n        }\\n        sort(arr.begin(),arr.end(),[](vector<int>& a,vector<int>& b){\\n            return (a[0]>b[0]);\\n        }); //descending order of sorting\\n        vector<vector<int>> r_max(3,vector<int>(m));\\n        // to store the maximum steps , second better maximum steps , element giving the maximum  steps(to check for equality case) in row (for c_max in col)\\n        vector<vector<int>> c_max(3,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            r_max[0][i]=0;\\n            r_max[1][i]=0;\\n            r_max[2][i]=INT_MAX;\\n        }\\n        for(int j=0;j<n;j++){\\n            c_max[0][j]=0;\\n            c_max[1][j]=0;\\n            c_max[2][j]=INT_MAX;\\n        }\\n        for(int i=0;i<m*n;i++){\\n            int& ele=arr[i][0];\\n            int& r=arr[i][1];\\n            int& c=arr[i][2];\\n            int a=(ele==r_max[2][r])?r_max[1][r]:r_max[0][r];\\n            int b=(ele==c_max[2][c])?c_max[1][c]:c_max[0][c];\\n            int res=max(a,b);\\n            ans=max(ans,1+res);\\n            if(ele!=r_max[2][r]){\\n                r_max[1][r]=r_max[0][r];\\n                r_max[2][r]=ele;\\n            }\\n            r_max[0][r]=max(r_max[0][r],1+res);\\n            if(ele!=c_max[2][c]){\\n            c_max[1][c]=c_max[0][c];\\n            c_max[2][c]=ele;\\n            }\\n            c_max[0][c]=max(c_max[0][c],1+res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int ans=0;\\n        int ind=0;\\n        vector<vector<int>> arr(m*n);  // to store the sorted order of elements [0]->element,[1]->row index,[2]->col index\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                arr[ind++]={mat[i][j],i,j};\\n            }\\n        }\\n        sort(arr.begin(),arr.end(),[](vector<int>& a,vector<int>& b){\\n            return (a[0]>b[0]);\\n        }); //descending order of sorting\\n        vector<vector<int>> r_max(3,vector<int>(m));\\n        // to store the maximum steps , second better maximum steps , element giving the maximum  steps(to check for equality case) in row (for c_max in col)\\n        vector<vector<int>> c_max(3,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            r_max[0][i]=0;\\n            r_max[1][i]=0;\\n            r_max[2][i]=INT_MAX;\\n        }\\n        for(int j=0;j<n;j++){\\n            c_max[0][j]=0;\\n            c_max[1][j]=0;\\n            c_max[2][j]=INT_MAX;\\n        }\\n        for(int i=0;i<m*n;i++){\\n            int& ele=arr[i][0];\\n            int& r=arr[i][1];\\n            int& c=arr[i][2];\\n            int a=(ele==r_max[2][r])?r_max[1][r]:r_max[0][r];\\n            int b=(ele==c_max[2][c])?c_max[1][c]:c_max[0][c];\\n            int res=max(a,b);\\n            ans=max(ans,1+res);\\n            if(ele!=r_max[2][r]){\\n                r_max[1][r]=r_max[0][r];\\n                r_max[2][r]=ele;\\n            }\\n            r_max[0][r]=max(r_max[0][r],1+res);\\n            if(ele!=c_max[2][c]){\\n            c_max[1][c]=c_max[0][c];\\n            c_max[2][c]=ele;\\n            }\\n            c_max[0][c]=max(c_max[0][c],1+res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574465,
                "title": "c-just-from-small-to-big",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) \\n    {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        map<int,vector<pair<int,int>>>mp;\\n        for(int i=0;i<m;i++)for(int j=0;j<n;j++)mp[mat[i][j]].push_back({i,j});\\n        vector<int>row(m,0),col(n,0);\\n        vector<vector<int>>res(m,vector<int>(n));\\n        int ans=0;\\n        for(auto &v1:mp)\\n        {\\n            for(auto &v2:v1.second)\\n            {\\n                int x=v2.first;\\n                int y=v2.second;\\n                res[x][y]=1+max(row[x],col[y]);\\n                ans=max(ans,res[x][y]);\\n            }\\n            for(auto &v2:v1.second)\\n            {\\n                int x=v2.first;\\n                int y=v2.second;\\n                row[x]=max(row[x],res[x][y]);\\n                col[y]=max(col[y],res[x][y]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) \\n    {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        map<int,vector<pair<int,int>>>mp;\\n        for(int i=0;i<m;i++)for(int j=0;j<n;j++)mp[mat[i][j]].push_back({i,j});\\n        vector<int>row(m,0),col(n,0);\\n        vector<vector<int>>res(m,vector<int>(n));\\n        int ans=0;\\n        for(auto &v1:mp)\\n        {\\n            for(auto &v2:v1.second)\\n            {\\n                int x=v2.first;\\n                int y=v2.second;\\n                res[x][y]=1+max(row[x],col[y]);\\n                ans=max(ans,res[x][y]);\\n            }\\n            for(auto &v2:v1.second)\\n            {\\n                int x=v2.first;\\n                int y=v2.second;\\n                row[x]=max(row[x],res[x][y]);\\n                col[y]=max(col[y],res[x][y]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573634,
                "title": "simple-explanation-for-the-traversal-and-tracking-past-calculations",
                "content": "# Intuition\\nTraverse the points in order of size so all points less than (or alternatively greater than) have already been calculated. Use these previous calculations for the new point and increase length by 1.\\n\\n# Approach\\n1. Use a priority queue to order the points\\n2. Track previous longest path for each row and for each column\\n    - Beware of multiple points in a row or column having the same value (use next largest value for length)\\n3. Track overall longest path.\\n\\n# Complexity\\n- Time complexity:\\n$O(m*n log(m*n))$\\n    - $O(m*n)$ for the traversal\\n    - $O(m*n log(m*n))$ for the sorting\\n\\n- Space complexity:\\n$O(m*n)$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxIncreasingCells(int[][] mat) {\\n        int m = mat.Length;\\n        int n = mat[0].Length;\\n        PriorityQueue<(int r, int c), int> pq = MakeAndFillPriorityQueue(mat);\\n        List<int[]>[] bestRows = MakeAndFillBestLists(m, 3);\\n        List<int[]>[] bestColumns = MakeAndFillBestLists(n, 3);\\n        int best = 0; int currBest;\\n        int row; int column; int val;\\n        while (pq.Count > 0) {\\n            row = pq.Peek().r; column = pq.Peek().c; pq.Dequeue();\\n            val = mat[row][column];\\n            currBest = Math.Max(GetBest(bestRows[row], val), GetBest(bestColumns[column], val)) + 1;\\n            UpdateBest(bestRows[row], val, currBest);\\n            UpdateBest(bestColumns[column], val, currBest);\\n            best = Math.Max(best, currBest);\\n        }\\n        return best;\\n    }\\n\\n    private PriorityQueue<(int, int), int> MakeAndFillPriorityQueue(int[][] mat) {\\n        int m = mat.Length;\\n        int n = mat[0].Length;\\n        PriorityQueue<(int r, int c), int> pq = new PriorityQueue<(int, int), int>();\\n        for (int row = 0; row < m; ++row) {\\n            for (int column = 0; column < n; ++column) {\\n                pq.Enqueue((row, column), mat[row][column]);\\n            }\\n        }\\n        return pq;\\n    }\\n\\n    private List<int[]>[] MakeAndFillBestLists(int n, int size) {\\n        List<int[]>[] l = new List<int[]>[n];\\n        for (int i = 0; i < n; ++i) {\\n            l[i] = new List<int[]>(size);\\n            l[i].Add(new int[] {-999999, 0});\\n        }\\n        return l;\\n    }\\n\\n    private int GetBest(List<int[]> l, int val) {\\n        int n = l.Count - 1;\\n        if (l[n][0] == val) {\\n            return l[n - 1][1];\\n        } else {\\n            return l[n][1];\\n        }\\n    }\\n\\n    private void UpdateBest(List<int[]> l, int val, int best) {\\n        int n = l.Count - 1;\\n        if (l[n][0] == val) {\\n            l[n][1] = Math.Max(l[n][1], best);\\n        } else {\\n            l.Add(new int[] {val, best});\\n        }\\n        if (l.Count > 2) {\\n            l.RemoveAt(0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxIncreasingCells(int[][] mat) {\\n        int m = mat.Length;\\n        int n = mat[0].Length;\\n        PriorityQueue<(int r, int c), int> pq = MakeAndFillPriorityQueue(mat);\\n        List<int[]>[] bestRows = MakeAndFillBestLists(m, 3);\\n        List<int[]>[] bestColumns = MakeAndFillBestLists(n, 3);\\n        int best = 0; int currBest;\\n        int row; int column; int val;\\n        while (pq.Count > 0) {\\n            row = pq.Peek().r; column = pq.Peek().c; pq.Dequeue();\\n            val = mat[row][column];\\n            currBest = Math.Max(GetBest(bestRows[row], val), GetBest(bestColumns[column], val)) + 1;\\n            UpdateBest(bestRows[row], val, currBest);\\n            UpdateBest(bestColumns[column], val, currBest);\\n            best = Math.Max(best, currBest);\\n        }\\n        return best;\\n    }\\n\\n    private PriorityQueue<(int, int), int> MakeAndFillPriorityQueue(int[][] mat) {\\n        int m = mat.Length;\\n        int n = mat[0].Length;\\n        PriorityQueue<(int r, int c), int> pq = new PriorityQueue<(int, int), int>();\\n        for (int row = 0; row < m; ++row) {\\n            for (int column = 0; column < n; ++column) {\\n                pq.Enqueue((row, column), mat[row][column]);\\n            }\\n        }\\n        return pq;\\n    }\\n\\n    private List<int[]>[] MakeAndFillBestLists(int n, int size) {\\n        List<int[]>[] l = new List<int[]>[n];\\n        for (int i = 0; i < n; ++i) {\\n            l[i] = new List<int[]>(size);\\n            l[i].Add(new int[] {-999999, 0});\\n        }\\n        return l;\\n    }\\n\\n    private int GetBest(List<int[]> l, int val) {\\n        int n = l.Count - 1;\\n        if (l[n][0] == val) {\\n            return l[n - 1][1];\\n        } else {\\n            return l[n][1];\\n        }\\n    }\\n\\n    private void UpdateBest(List<int[]> l, int val, int best) {\\n        int n = l.Count - 1;\\n        if (l[n][0] == val) {\\n            l[n][1] = Math.Max(l[n][1], best);\\n        } else {\\n            l.Add(new int[] {val, best});\\n        }\\n        if (l.Count > 2) {\\n            l.RemoveAt(0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573389,
                "title": "python-clean-code",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxIncreasingCells(self, M: List[List[int]]) -> int:\\n        m, n = len(M), len(M[0])\\n        row = defaultdict(lambda:[0,0,float(\\'-inf\\')]) #[curmax, prevmax, curval]\\n        col = defaultdict(lambda:[0,0,float(\\'-inf\\')])\\n        res = 0\\n        for val,i,j in sorted((M[i][j],i,j) for i in range(m) for j in range(n)):\\n            cur = 1 + max(row[i][val == row[i][2]], col[j][val == col[j][2]])\\n            if col[j][2] < val: \\n                col[j] = [max(cur,col[j][0]+1), col[j][0], val]\\n            else:\\n                col[j][0] = max(cur,col[j][0])\\n            if row[i][2] < val:\\n                row[i] = [max(cur,row[i][0]+1), row[i][0], val]\\n            else:\\n                row[i][0] = max(cur,row[i][0])\\n            res = max(res, cur)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxIncreasingCells(self, M: List[List[int]]) -> int:\\n        m, n = len(M), len(M[0])\\n        row = defaultdict(lambda:[0,0,float(\\'-inf\\')]) #[curmax, prevmax, curval]\\n        col = defaultdict(lambda:[0,0,float(\\'-inf\\')])\\n        res = 0\\n        for val,i,j in sorted((M[i][j],i,j) for i in range(m) for j in range(n)):\\n            cur = 1 + max(row[i][val == row[i][2]], col[j][val == col[j][2]])\\n            if col[j][2] < val: \\n                col[j] = [max(cur,col[j][0]+1), col[j][0], val]\\n            else:\\n                col[j][0] = max(cur,col[j][0])\\n            if row[i][2] < val:\\n                row[i] = [max(cur,row[i][0]+1), row[i][0], val]\\n            else:\\n                row[i][0] = max(cur,row[i][0])\\n            res = max(res, cur)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572571,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    __attribute__((no_sanitize(\"address\")))\\n    int solve(int i, int j,vector<vector<pair<int, int>>> &vr, vector<vector<pair<int, int>>> &vc, vector<vector<int>> &dp, vector<vector<int>>& mat) {\\n        if (dp[i][j] != 0) return dp[i][j];\\n        else {\\n            int f = mat[i][j];\\n            dp[i][j] = 1;\\n            auto ix = upper_bound(vr[i].begin() , vr[i].end(), f, [](auto &p, pair<int, int> &q)-> bool {return p < q.first;});\\n            auto iy = upper_bound(vc[j].begin() , vc[j].end(), f, [](auto &p, pair<int, int> &q)-> bool {return p < q.first;});\\n\\n            for (auto it = ix; it != vr[i].end() && it->first == ix->first; it++) {\\n                dp[i][j] = max(dp[i][j], solve(i, it->second, vr, vc, dp, mat) + 1) ;\\n            }\\n            for (auto it = iy; it != vc[j].end() && it->first == iy->first; ++it) {\\n                dp[i][j] = max(dp[i][j], solve(it->second, j, vr, vc, dp, mat) + 1) ;\\n            }\\n            return dp[i][j];\\n        }\\n    }\\n\\n    __attribute__((no_sanitize(\"address\")))\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size(), ans = 0;\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<vector<pair<int, int>>> vr, vc;\\n        for (int i = 0; i < m; ++i) {\\n            vector<pair<int, int>> vii(n);\\n            for (int j = 0; j < n; ++j) {\\n                vii[j] = make_pair(mat[i][j], j);\\n            }\\n            sort(vii.begin(), vii.end());\\n            vr.push_back(vii);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            vector<pair<int, int>> vii(m);\\n            for (int j = 0; j < m; ++j) {\\n                vii[j] = make_pair(mat[j][i], j);\\n            }\\n            sort(vii.begin(), vii.end());\\n            vc.push_back(vii);\\n        }\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (dp[i][j] == 0) solve(i, j, vr, vc, dp, mat);\\n                ans = max(dp[i][j], ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    __attribute__((no_sanitize(\"address\")))\\n    int solve(int i, int j,vector<vector<pair<int, int>>> &vr, vector<vector<pair<int, int>>> &vc, vector<vector<int>> &dp, vector<vector<int>>& mat) {\\n        if (dp[i][j] != 0) return dp[i][j];\\n        else {\\n            int f = mat[i][j];\\n            dp[i][j] = 1;\\n            auto ix = upper_bound(vr[i].begin() , vr[i].end(), f, [](auto &p, pair<int, int> &q)-> bool {return p < q.first;});\\n            auto iy = upper_bound(vc[j].begin() , vc[j].end(), f, [](auto &p, pair<int, int> &q)-> bool {return p < q.first;});\\n\\n            for (auto it = ix; it != vr[i].end() && it->first == ix->first; it++) {\\n                dp[i][j] = max(dp[i][j], solve(i, it->second, vr, vc, dp, mat) + 1) ;\\n            }\\n            for (auto it = iy; it != vc[j].end() && it->first == iy->first; ++it) {\\n                dp[i][j] = max(dp[i][j], solve(it->second, j, vr, vc, dp, mat) + 1) ;\\n            }\\n            return dp[i][j];\\n        }\\n    }\\n\\n    __attribute__((no_sanitize(\"address\")))\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size(), ans = 0;\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        vector<vector<pair<int, int>>> vr, vc;\\n        for (int i = 0; i < m; ++i) {\\n            vector<pair<int, int>> vii(n);\\n            for (int j = 0; j < n; ++j) {\\n                vii[j] = make_pair(mat[i][j], j);\\n            }\\n            sort(vii.begin(), vii.end());\\n            vr.push_back(vii);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            vector<pair<int, int>> vii(m);\\n            for (int j = 0; j < m; ++j) {\\n                vii[j] = make_pair(mat[j][i], j);\\n            }\\n            sort(vii.begin(), vii.end());\\n            vc.push_back(vii);\\n        }\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (dp[i][j] == 0) solve(i, j, vr, vc, dp, mat);\\n                ans = max(dp[i][j], ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572532,
                "title": "well-commented-and-easy-to-understand-solution-in-cpp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        \\n        // calculate rows and cols\\n        int rows = mat.size() , cols = mat[0].size();\\n\\n        // create maps corresponding to every row and col\\n        vector<map<int,vector<int>>> rowMap(rows);\\n        vector<map<int,vector<int>>> colMap(cols);\\n\\n        // create dp array\\n        vector<vector<int>> dp(rows, vector<int>(cols,-1));\\n\\n        // create a mapping of rowMap\\n\\n        // in row1\\n            // 3 -> 0 (colIdx)\\n            // 1 -> 1 (colIdx)\\n\\n        // in row2 \\n            // 3 -> 0 (colIdx)\\n            // 4 -> 1 (colIdx)\\n\\n        \\n        // create a mapping of colMap\\n\\n        // in col1\\n            // 3 -> 0 , 1 (rowIdx) \\n            // 4 -> 1 (rowIdx)\\n\\n\\n        for (int row = 0 ; row < rows; row++){\\n            for (int col = 0 ; col < cols ; col++){\\n                int element = mat[row][col];\\n                rowMap[row][element].push_back(col);\\n                colMap[col][element].push_back(row);\\n            }\\n        }\\n\\n\\n        // function to calculate the maximum no of cells that can visit\\n        // starting from curr element\\n        function<int(int,int)> solve = [&](int row, int col){\\n\\n            if (dp[row][col] != -1) return dp[row][col];\\n\\n            // create ans to store the no of steps\\n            int ans = 1;\\n\\n            // find the next greater element in curr row\\n            auto nextGreaterRowEle = rowMap[row].lower_bound(mat[row][col] + 1);\\n            if (nextGreaterRowEle != rowMap[row].end()){\\n                vector<int> greaterColIdxs = (*nextGreaterRowEle).second;\\n                for (auto &colIdx : greaterColIdxs){\\n                    ans = max(ans, 1 + solve(row, colIdx));\\n                }\\n            }\\n\\n\\n            // find the next greater element in curr col\\n            auto nextGreaterColEle = colMap[col].lower_bound(mat[row][col] + 1);\\n            if (nextGreaterColEle != colMap[col].end()){\\n                vector<int> greaterRowIdxs = (*nextGreaterColEle).second;\\n                for (auto &rowIdx : greaterRowIdxs) {\\n                    ans = max(ans, 1 + solve(rowIdx, col));\\n                }\\n            }\\n\\n\\n            return dp[row][col] = ans;\\n        };\\n\\n        // traverse all the elements\\n        int ans = 0;\\n\\n        for (int row = 0 ; row < rows ; row++){\\n            for (int col = 0 ; col < cols ; col++){\\n                ans = max(solve(row, col), ans);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        \\n        // calculate rows and cols\\n        int rows = mat.size() , cols = mat[0].size();\\n\\n        // create maps corresponding to every row and col\\n        vector<map<int,vector<int>>> rowMap(rows);\\n        vector<map<int,vector<int>>> colMap(cols);\\n\\n        // create dp array\\n        vector<vector<int>> dp(rows, vector<int>(cols,-1));\\n\\n        // create a mapping of rowMap\\n\\n        // in row1\\n            // 3 -> 0 (colIdx)\\n            // 1 -> 1 (colIdx)\\n\\n        // in row2 \\n            // 3 -> 0 (colIdx)\\n            // 4 -> 1 (colIdx)\\n\\n        \\n        // create a mapping of colMap\\n\\n        // in col1\\n            // 3 -> 0 , 1 (rowIdx) \\n            // 4 -> 1 (rowIdx)\\n\\n\\n        for (int row = 0 ; row < rows; row++){\\n            for (int col = 0 ; col < cols ; col++){\\n                int element = mat[row][col];\\n                rowMap[row][element].push_back(col);\\n                colMap[col][element].push_back(row);\\n            }\\n        }\\n\\n\\n        // function to calculate the maximum no of cells that can visit\\n        // starting from curr element\\n        function<int(int,int)> solve = [&](int row, int col){\\n\\n            if (dp[row][col] != -1) return dp[row][col];\\n\\n            // create ans to store the no of steps\\n            int ans = 1;\\n\\n            // find the next greater element in curr row\\n            auto nextGreaterRowEle = rowMap[row].lower_bound(mat[row][col] + 1);\\n            if (nextGreaterRowEle != rowMap[row].end()){\\n                vector<int> greaterColIdxs = (*nextGreaterRowEle).second;\\n                for (auto &colIdx : greaterColIdxs){\\n                    ans = max(ans, 1 + solve(row, colIdx));\\n                }\\n            }\\n\\n\\n            // find the next greater element in curr col\\n            auto nextGreaterColEle = colMap[col].lower_bound(mat[row][col] + 1);\\n            if (nextGreaterColEle != colMap[col].end()){\\n                vector<int> greaterRowIdxs = (*nextGreaterColEle).second;\\n                for (auto &rowIdx : greaterRowIdxs) {\\n                    ans = max(ans, 1 + solve(rowIdx, col));\\n                }\\n            }\\n\\n\\n            return dp[row][col] = ans;\\n        };\\n\\n        // traverse all the elements\\n        int ans = 0;\\n\\n        for (int row = 0 ; row < rows ; row++){\\n            for (int col = 0 ; col < cols ; col++){\\n                ans = max(solve(row, col), ans);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572301,
                "title": "easy-c-solution-faster-that-83",
                "content": "# Explaination\\nAt first I thought of the brute force that from each cell try to move as far as possible but according to the time constraints that solution was not feasible so i thought when we are at a particular cell the value which are smaller than that value has no significance so we can just store all the values in a vector and sort them in decreasing order and iterate them, so when we are at index i let\\'s say it is xth row and yth column now we need to check at xth row and yth which is maximum cell on which I can jump from current cell i.e. x, y and then i update the value for that cell this can be simply done by creating two vectors row and col which will maximum cells that can be visited from a cell in the particular row and column. \\nHowever there is one caveat you need to handle same values because it was mentioned in the question we can jump from one cell to another only if the next cell value is strictly greater than the previous cell. \\n\\n\\n# Complexity\\n- Time complexity:\\n->matrix contains m*n elements and log(mn) to sort it so the time complexity should by O(m*n*log(m*n)) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n-> O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote my solution!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(pair<int, pair<int, int>> &a, pair<int, pair<int, int>> &b) {\\n        return a.first > b.first;\\n    }\\n     \\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        vector<int> row(n, 0), col(m, 0);\\n        \\n        vector<pair<int, pair<int, int>>> v; \\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                v.push_back({mat[i][j], {i,j}}); \\n            }\\n        }\\n        \\n        sort(v.begin(), v.end(), cmp); \\n        \\n        int ans = 1; \\n        \\n        \\n        int i = 0;\\n        while(i < v.size()) {\\n            \\n            int j = i+1;\\n//          handling similar values\\n            vector<pair<int, pair<int, int>>> temp; \\n            temp.push_back(v[i]);\\n            while(j < v.size() and v[i].first == v[j].first) {\\n                temp.push_back(v[j]);\\n                j++; \\n            }\\n            \\n            vector<int> temp2(temp.size(), 0);\\n            \\n            for(int k = 0; k < temp.size(); k++) {\\n                int val = temp[k].first;\\n                int x = temp[k].second.first;\\n                int y = temp[k].second.second; \\n                \\n                int value = 1+max(row[x], col[y]); \\n                ans = max(ans, value);\\n                temp2[k] = value; \\n            }\\n            \\n            for(int k = 0; k < temp.size(); k++) {\\n                int val = temp[k].first; \\n                int x = temp[k].second.first;\\n                int y = temp[k].second.second; \\n                \\n                row[x] = max(row[x],temp2[k]);\\n                col[y] = max(col[y],temp2[k]); \\n            }\\n            \\n            i=j;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(pair<int, pair<int, int>> &a, pair<int, pair<int, int>> &b) {\\n        return a.first > b.first;\\n    }\\n     \\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        vector<int> row(n, 0), col(m, 0);\\n        \\n        vector<pair<int, pair<int, int>>> v; \\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                v.push_back({mat[i][j], {i,j}}); \\n            }\\n        }\\n        \\n        sort(v.begin(), v.end(), cmp); \\n        \\n        int ans = 1; \\n        \\n        \\n        int i = 0;\\n        while(i < v.size()) {\\n            \\n            int j = i+1;\\n//          handling similar values\\n            vector<pair<int, pair<int, int>>> temp; \\n            temp.push_back(v[i]);\\n            while(j < v.size() and v[i].first == v[j].first) {\\n                temp.push_back(v[j]);\\n                j++; \\n            }\\n            \\n            vector<int> temp2(temp.size(), 0);\\n            \\n            for(int k = 0; k < temp.size(); k++) {\\n                int val = temp[k].first;\\n                int x = temp[k].second.first;\\n                int y = temp[k].second.second; \\n                \\n                int value = 1+max(row[x], col[y]); \\n                ans = max(ans, value);\\n                temp2[k] = value; \\n            }\\n            \\n            for(int k = 0; k < temp.size(); k++) {\\n                int val = temp[k].first; \\n                int x = temp[k].second.first;\\n                int y = temp[k].second.second; \\n                \\n                row[x] = max(row[x],temp2[k]);\\n                col[y] = max(col[y],temp2[k]); \\n            }\\n            \\n            i=j;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572295,
                "title": "java-beats-100-o-n-m-log-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart from min value to max value, for a value find max value in from row and coloumn, do this process for all value\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First prepare a `map` which contain value and index.\\n2. Take a `memo` varible with zero value.\\n3. `res` variable is used to store max value of row and coloumn from 0 to n-1 will store row max value and n to m-1 will store coloumn max value.\\n4. first sort the key from map after that process below metioned step\\n    1. vairable `pos` contain array, beacuase might be same element contain in different positon.\\n    2. Fill the `memo[i][j]` it will be one plus from max value of row and coloumn.\\n    3. update the current max value.\\n    4. after that we will modified the row and coloumn value in second loop.\\n\\n# Complexity\\n- Time complexity: O(n*m)log(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int maxIncreasingCells(int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int val = mat[i][j];\\n                if (!map.containsKey(val)) {\\n                    map.put(val, new ArrayList<int[]>());\\n                }\\n                map.get(val).add(new int[] {i, j});\\n            }\\n        }\\n        int[][] memo = new int[n][m];\\n        int[] res = new int[n+m];\\n        AtomicInteger max = new AtomicInteger();\\n        map.keySet().stream().sorted().forEach( a -> {\\n            for (int[] pos : map.get(a)) {\\n                int i = pos[0], j = pos[1];\\n                memo[i][j] = Math.max(res[i], res[n + j]) + 1;\\n                max.set(Math.max(max.get(), memo[i][j]));\\n            }\\n            for (int[] pos : map.get(a)) {\\n                int i = pos[0], j = pos[1];\\n                res[n + j] = Math.max(res[n + j], memo[i][j]);\\n                res[i] = Math.max(res[i], memo[i][j]);\\n            }\\n        });\\n        return max.get();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxIncreasingCells(int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int val = mat[i][j];\\n                if (!map.containsKey(val)) {\\n                    map.put(val, new ArrayList<int[]>());\\n                }\\n                map.get(val).add(new int[] {i, j});\\n            }\\n        }\\n        int[][] memo = new int[n][m];\\n        int[] res = new int[n+m];\\n        AtomicInteger max = new AtomicInteger();\\n        map.keySet().stream().sorted().forEach( a -> {\\n            for (int[] pos : map.get(a)) {\\n                int i = pos[0], j = pos[1];\\n                memo[i][j] = Math.max(res[i], res[n + j]) + 1;\\n                max.set(Math.max(max.get(), memo[i][j]));\\n            }\\n            for (int[] pos : map.get(a)) {\\n                int i = pos[0], j = pos[1];\\n                res[n + j] = Math.max(res[n + j], memo[i][j]);\\n                res[i] = Math.max(res[i], memo[i][j]);\\n            }\\n        });\\n        return max.get();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571943,
                "title": "dp-c",
                "content": "# Complexity\\n- Time complexity: O(n * m * log(n*m))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& grid) {\\n        map<int,vector<pair<int,int>>>v;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                v[grid[i][j]].push_back({i,j});\\n            }\\n        }\\n        vector<int>res(grid.size()+grid[0].size(),0);\\n        int dp[grid.size()][grid[0].size()];\\n        int ans=0;\\n        memset(dp,0,sizeof(dp));\\n        vector<int>row(grid[0].size(),0),col(grid.size(),0);\\n        for(auto it:v){\\n            for(auto pos:it.second){\\n                int x=pos.first,y=pos.second;\\n                dp[x][y]=1+max(res[x],res[grid.size()+y]);\\n                \\n            }\\n            for(auto pos:it.second){\\n                int x=pos.first,y=pos.second;\\n                res[x]=max(res[x],dp[x][y]);\\n                res[grid.size()+y]=max(res[grid.size()+y],dp[x][y]);\\n                ans=max(ans,res[x]);\\n                ans=max(ans,res[grid.size()+y]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& grid) {\\n        map<int,vector<pair<int,int>>>v;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                v[grid[i][j]].push_back({i,j});\\n            }\\n        }\\n        vector<int>res(grid.size()+grid[0].size(),0);\\n        int dp[grid.size()][grid[0].size()];\\n        int ans=0;\\n        memset(dp,0,sizeof(dp));\\n        vector<int>row(grid[0].size(),0),col(grid.size(),0);\\n        for(auto it:v){\\n            for(auto pos:it.second){\\n                int x=pos.first,y=pos.second;\\n                dp[x][y]=1+max(res[x],res[grid.size()+y]);\\n                \\n            }\\n            for(auto pos:it.second){\\n                int x=pos.first,y=pos.second;\\n                res[x]=max(res[x],dp[x][y]);\\n                res[grid.size()+y]=max(res[grid.size()+y],dp[x][y]);\\n                ans=max(ans,res[x]);\\n                ans=max(ans,res[grid.size()+y]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571906,
                "title": "python-dp-short-clean-with-intuition-and-explanations",
                "content": "# Intuition\\nLet\\'s try to calculate how many steps can possibly be made from some (i,j) cell.\\n\\n---\\n\\nObservatoin #0: we only care about starting cell and cells after it. It means that if we came to some cell - then our past does not matter from now on.\\nWhich brings a DP-like solution \\n```\\nf(i,j) = 1+max(\\n    f(r,j) for r in rows if grid[r][j]>grid[i][j],    #1\\n    f(i,c) for c in cols if grid[i][c]>grid[i][j]     #2\\n)\\n``` \\nBut with constraints ``1<=m,n,m*n<=10^5`` this is too much of a computation. We need to improve.\\n\\n---\\n\\n\\nObservation #1: we can travel only to **greater** elements. Which means it makes no sense calculate a cell before some other cell with greater value. This gives at least some \\'ordering\\' idea: order cells by their grid value descending.\\n\\n---\\n\\nObservation #2: we can travel only to elements within **same row/col**. So if we maintain a structure with **best f value per row** and **best f value per col** at current step (cells on previous steps had higher grid values, so all of them are eligible to connect with current cell), then we could use it improving #1 and #2 to O(1) time.\\n\\n---\\n\\n\\nSo the overall idea is next:\\n1. Traverse grid by values in descending order.\\n2. For each cell - take the current correpsonding \\'best-per-row\\' and \\'best-per-col\\' and take max from it.\\n3. Update \\'best-per-row\\' and \\'best-per-col\\'.\\n\\n# Approach\\nBasically the code itself implements ideas from intition. \\nThe only thing to take carefully - we must not update ``row,col`` before all cells with same grid value are calculated (so that we comply to **strictly greater** rule). So we just process same-value cells in a batch after we grouped them.\\n\\n\\n# Complexity\\n- Time complexity: ``O(mn*log(mn))``\\n- Space complexity: ``O(m*n)``\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        row = [0]*m\\n        col = [0]*n\\n        groups = groupby(\\n            sorted(((mat[i][j],i,j) for i,j in product(range(m),range(n))), reverse=True), \\n            key=itemgetter(0)\\n        )\\n        for _,g in groups:\\n            f = defaultdict(int)\\n            for _,i,j in g:\\n                f[i,j] = 1+max(row[i],col[j])\\n            for i,j in f:\\n                row[i] = max(row[i], f[i,j])\\n                col[j] = max(col[j], f[i,j])\\n        return max(row)                                    \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nf(i,j) = 1+max(\\n    f(r,j) for r in rows if grid[r][j]>grid[i][j],    #1\\n    f(i,c) for c in cols if grid[i][c]>grid[i][j]     #2\\n)\\n```\n```\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        row = [0]*m\\n        col = [0]*n\\n        groups = groupby(\\n            sorted(((mat[i][j],i,j) for i,j in product(range(m),range(n))), reverse=True), \\n            key=itemgetter(0)\\n        )\\n        for _,g in groups:\\n            f = defaultdict(int)\\n            for _,i,j in g:\\n                f[i,j] = 1+max(row[i],col[j])\\n            for i,j in f:\\n                row[i] = max(row[i], f[i,j])\\n                col[j] = max(col[j], f[i,j])\\n        return max(row)                                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571875,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxIncreasingCells(int[][] mat)\\n    {\\n        int n = mat.Length;\\n        int m = mat[0].Length;\\n        SortedDictionary<int, List<int[]>> ma = new SortedDictionary<int, List<int[]>>();\\n        int[] row = new int[n];\\n        int[] col = new int[m];\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                int value = mat[i][j];\\n                if (!ma.ContainsKey(value))\\n                {\\n                    ma[value] = new List<int[]>();\\n                }\\n                ma[value].Add(new int[] { i, j });\\n            }\\n        }\\n\\n        foreach (var kvp in ma)\\n        {\\n            int value = kvp.Key;\\n            List<int[]> coordinates = kvp.Value;\\n            List<int[]> trow = new List<int[]>();\\n            List<int[]> tcol = new List<int[]>();\\n\\n            foreach (int[] coordinate in coordinates)\\n            {\\n                int i = coordinate[0];\\n                int j = coordinate[1];\\n                int t = Math.Max(1, Math.Max(row[i] + 1, col[j] + 1));\\n                res = Math.Max(res, t);\\n                trow.Add(new int[] { i, t });\\n                tcol.Add(new int[] { j, t });\\n            }\\n\\n            foreach (int[] entry in trow)\\n            {\\n                int i = entry[0];\\n                int j = entry[1];\\n                row[i] = Math.Max(row[i], j);\\n            }\\n\\n            foreach (int[] entry in tcol)\\n            {\\n                int i = entry[0];\\n                int j = entry[1];\\n                col[i] = Math.Max(col[i], j);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxIncreasingCells(int[][] mat)\\n    {\\n        int n = mat.Length;\\n        int m = mat[0].Length;\\n        SortedDictionary<int, List<int[]>> ma = new SortedDictionary<int, List<int[]>>();\\n        int[] row = new int[n];\\n        int[] col = new int[m];\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                int value = mat[i][j];\\n                if (!ma.ContainsKey(value))\\n                {\\n                    ma[value] = new List<int[]>();\\n                }\\n                ma[value].Add(new int[] { i, j });\\n            }\\n        }\\n\\n        foreach (var kvp in ma)\\n        {\\n            int value = kvp.Key;\\n            List<int[]> coordinates = kvp.Value;\\n            List<int[]> trow = new List<int[]>();\\n            List<int[]> tcol = new List<int[]>();\\n\\n            foreach (int[] coordinate in coordinates)\\n            {\\n                int i = coordinate[0];\\n                int j = coordinate[1];\\n                int t = Math.Max(1, Math.Max(row[i] + 1, col[j] + 1));\\n                res = Math.Max(res, t);\\n                trow.Add(new int[] { i, t });\\n                tcol.Add(new int[] { j, t });\\n            }\\n\\n            foreach (int[] entry in trow)\\n            {\\n                int i = entry[0];\\n                int j = entry[1];\\n                row[i] = Math.Max(row[i], j);\\n            }\\n\\n            foreach (int[] entry in tcol)\\n            {\\n                int i = entry[0];\\n                int j = entry[1];\\n                col[i] = Math.Max(col[i], j);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571838,
                "title": "swift-solution-using-dp-and-sorting",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    private struct P: Hashable {\\n        let x: Int\\n        let y: Int\\n    }\\n\\n    func maxIncreasingCells(_ matrix: [[Int]]) -> Int {\\n        var map: [Int: Set<P>] = [:]\\n\\n        for y in matrix.indices {\\n            for x in matrix[0].indices {\\n                map[matrix[y][x], default: []].insert(.init(x: x, y: y))\\n            }\\n        }\\n\\n        var dp: [[Int]] = .init(repeating: .init(repeating: 1, count: matrix[0].count), count: matrix.count)\\n\\n        var rowMax: [Int] = .init(repeating: 0, count: matrix.count)\\n        var colMax: [Int] = .init(repeating: 0, count: matrix[0].count)\\n\\n        for element in map.keys.sorted() {\\n            for p in map[element, default: []] {\\n                dp[p.y][p.x] = max(rowMax[p.y], colMax[p.x]) + 1\\n            }\\n\\n            for p in map[element, default: []] {\\n                rowMax[p.y] = max(rowMax[p.y], dp[p.y][p.x])\\n                colMax[p.x] = max(colMax[p.x], dp[p.y][p.x])\\n            }\\n        }\\n\\n        return dp.flatMap{ $0 }.max()!\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    private struct P: Hashable {\\n        let x: Int\\n        let y: Int\\n    }\\n\\n    func maxIncreasingCells(_ matrix: [[Int]]) -> Int {\\n        var map: [Int: Set<P>] = [:]\\n\\n        for y in matrix.indices {\\n            for x in matrix[0].indices {\\n                map[matrix[y][x], default: []].insert(.init(x: x, y: y))\\n            }\\n        }\\n\\n        var dp: [[Int]] = .init(repeating: .init(repeating: 1, count: matrix[0].count), count: matrix.count)\\n\\n        var rowMax: [Int] = .init(repeating: 0, count: matrix.count)\\n        var colMax: [Int] = .init(repeating: 0, count: matrix[0].count)\\n\\n        for element in map.keys.sorted() {\\n            for p in map[element, default: []] {\\n                dp[p.y][p.x] = max(rowMax[p.y], colMax[p.x]) + 1\\n            }\\n\\n            for p in map[element, default: []] {\\n                rowMax[p.y] = max(rowMax[p.y], dp[p.y][p.x])\\n                colMax[p.x] = max(colMax[p.x], dp[p.y][p.x])\\n            }\\n        }\\n\\n        return dp.flatMap{ $0 }.max()!\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571385,
                "title": "c-solution-using-dp-with-maps",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m*log(m*n))$$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        // to store the indexes/position a number is present at in mat grid\\n        unordered_map<int,vector<pair<int,int>>>mp;\\n        // to store all unique numbers present in mat grid\\n        set<int>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                mp[mat[i][j]].push_back({i,j});\\n                // store in descending order as for highest number we know the path len possible from it (which is one), thus we can traverse in non increasing order \\n                st.insert(-mat[i][j]);\\n            }\\n        }\\n        // to store the max path lenght possible from a particular cell\\n        vector<vector<int>>val(n,vector<int>(m));\\n        // to store the max path possible in a row\\n        vector<int>rowPath(n);\\n        // to store the max path possible in a col\\n        vector<int>colPath(m);\\n        for(auto num:st)\\n        {\\n            num =-num;\\n            // updating the val of number num at every pos it is present at\\n            for(auto pos: mp[num])\\n            {\\n                int r=pos.first;\\n                int c=pos.second;\\n                val[r][c]=max(rowPath[r],colPath[c])+1;\\n            }\\n            // updating the max rowPath and max colPath length possible\\n            for(auto pos: mp[num])\\n            {\\n                int r=pos.first;\\n                int c=pos.second;\\n                rowPath[r]=max(rowPath[r],val[r][c]);\\n                colPath[c]=max(colPath[c],val[r][c]);\\n            }\\n           \\n\\n        }\\n         int ans=INT_MIN;\\n            for(auto len : rowPath)\\n            ans=max(ans,len);\\n            for(auto len:colPath)\\n            ans=max(ans,len);\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        // to store the indexes/position a number is present at in mat grid\\n        unordered_map<int,vector<pair<int,int>>>mp;\\n        // to store all unique numbers present in mat grid\\n        set<int>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                mp[mat[i][j]].push_back({i,j});\\n                // store in descending order as for highest number we know the path len possible from it (which is one), thus we can traverse in non increasing order \\n                st.insert(-mat[i][j]);\\n            }\\n        }\\n        // to store the max path lenght possible from a particular cell\\n        vector<vector<int>>val(n,vector<int>(m));\\n        // to store the max path possible in a row\\n        vector<int>rowPath(n);\\n        // to store the max path possible in a col\\n        vector<int>colPath(m);\\n        for(auto num:st)\\n        {\\n            num =-num;\\n            // updating the val of number num at every pos it is present at\\n            for(auto pos: mp[num])\\n            {\\n                int r=pos.first;\\n                int c=pos.second;\\n                val[r][c]=max(rowPath[r],colPath[c])+1;\\n            }\\n            // updating the max rowPath and max colPath length possible\\n            for(auto pos: mp[num])\\n            {\\n                int r=pos.first;\\n                int c=pos.second;\\n                rowPath[r]=max(rowPath[r],val[r][c]);\\n                colPath[c]=max(colPath[c],val[r][c]);\\n            }\\n           \\n\\n        }\\n         int ans=INT_MIN;\\n            for(auto len : rowPath)\\n            ans=max(ans,len);\\n            for(auto len:colPath)\\n            ans=max(ans,len);\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571345,
                "title": "c-bottom-up-dp-lazy-update-time-space-100",
                "content": "**Basic Idea**\\n1. sort the cells **mat[r,c]** with respect to the values;\\n2. Initialize two arrays **row** and **col** to memorize the longest moves of each row (M rows) and each column (N columns).\\n2. from large to small, scan each cell\\n\\t2.1 if the cell is (r, c), from this cell we can move **dp[r,c]=1+max(row[r], col[c])**;\\n\\t2.2 update the value of **row[r]** and **col[c]** with **dp[r,c]**\\n\\n**Lazy Update**\\nBe careful, we move from (r,c) to (r,c1) only when **mat[r,c] < mat[r,c1]**. As a result, we need to postpone the update of **row** and **col**.\\nWe choose to update **dp[r,c]** first and delay the update of **row[r]** and **col[c]** until time is allowed.\\n\\n**Performance**\\n```\\nRuntime: 333 ms, faster than 100.00% of C++ online submissions for Maximum Strictly Increasing Cells in a Matrix.\\nMemory Usage: 78.6 MB, less than 100.00% of C++ online submissions for Maximum Strictly Increasing Cells in a Matrix.\\n```\\n\\n**Code**\\n```\\npair<int,int> buf[100000];\\nint dp[100000];\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        div_t d;\\n        int m=mat.size(), n=mat[0].size(), ans=0;\\n        vector<int> row(m, 0);\\n        vector<int> col(n, 0);\\n        for(int i=0, j, k=0; i<m; ++i) {\\n            for(j=0; j<n; ++j, ++k) {\\n                buf[k].first=mat[i][j];\\n                buf[k].second=k;\\n            }\\n        }\\n        sort(buf, buf+m*n);\\n        for(int i=m*n-1, j=i, k, r, c; i>=0; --j) {\\n            if(j<0 || buf[j].first<buf[i].first) {\\n                for(k=i; k>j; --k) {\\n                    d=div(buf[k].second, n);\\n                    dp[k]=1+max(row[d.quot], col[d.rem]);\\n                    ans=max(ans, dp[k]);\\n                }\\n                for(; i>j; --i) {\\n                    d=div(buf[i].second, n);\\n                    row[d.quot]=max(row[d.quot], dp[i]);\\n                    col[d.rem]=max(col[d.rem], dp[i]);\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nRuntime: 333 ms, faster than 100.00% of C++ online submissions for Maximum Strictly Increasing Cells in a Matrix.\\nMemory Usage: 78.6 MB, less than 100.00% of C++ online submissions for Maximum Strictly Increasing Cells in a Matrix.\\n```\n```\\npair<int,int> buf[100000];\\nint dp[100000];\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        div_t d;\\n        int m=mat.size(), n=mat[0].size(), ans=0;\\n        vector<int> row(m, 0);\\n        vector<int> col(n, 0);\\n        for(int i=0, j, k=0; i<m; ++i) {\\n            for(j=0; j<n; ++j, ++k) {\\n                buf[k].first=mat[i][j];\\n                buf[k].second=k;\\n            }\\n        }\\n        sort(buf, buf+m*n);\\n        for(int i=m*n-1, j=i, k, r, c; i>=0; --j) {\\n            if(j<0 || buf[j].first<buf[i].first) {\\n                for(k=i; k>j; --k) {\\n                    d=div(buf[k].second, n);\\n                    dp[k]=1+max(row[d.quot], col[d.rem]);\\n                    ans=max(ans, dp[k]);\\n                }\\n                for(; i>j; --i) {\\n                    d=div(buf[i].second, n);\\n                    row[d.quot]=max(row[d.quot], dp[i]);\\n                    col[d.rem]=max(col[d.rem], dp[i]);\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571257,
                "title": "c-bottom-up-tabulation-dp",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n  int maxIncreasingCells(vector<vector<int>>& mat) {\\n    int numRows = mat.size(), numCols = mat[0].size();\\n    vector<vector<int>> dp(numRows, vector<int>(numCols, -1));\\n    auto cmp = [&mat] (pair<int, int> p1, pair<int, int> p2) {\\n      return mat[p1.first][p1.second] < mat[p2.first][p2.second];\\n    };\\n    \\n    vector<vector<pair<int, int>>> rows(numRows), cols(numCols);\\n    for (int r = 0; r < numRows; ++r) {\\n      for (int c = 0; c < numCols; ++c) {\\n        rows[r].push_back({r, c});\\n        cols[c].push_back({r, c});\\n      }\\n    }\\n    // Sort rows individually.\\n    for (int r = 0; r < numRows; ++r) {\\n      sort(rows[r].begin(), rows[r].end(), cmp);\\n    }\\n    // Sort cols individually.\\n    for (int c = 0; c < numCols; ++c) {\\n      sort(cols[c].begin(), cols[c].end(), cmp);\\n    }\\n    \\n    // Sort all cells.\\n    vector<pair<int, int>> allCells;\\n    for (int r = 0; r < numRows; ++r) {\\n      for (int c = 0; c < numCols; ++c) {\\n        allCells.push_back({r, c});\\n      }\\n    }\\n    sort(allCells.begin(), allCells.end(), cmp);\\n    \\n    // Max cells will always be 1 even in the worst case.\\n    int maxCells = 1;\\n    \\n    // Set the value for the cell with the largest value to 1.\\n    dp[allCells.back().first][allCells.back().second] = 1;\\n    for (int i = allCells.size() - 2; i >= 0; --i) {\\n      auto [r, c] = allCells[i];\\n      \\n      int maxForCell = 0;\\n      \\n      auto it = upper_bound(rows[r].begin(), rows[r].end(), allCells[i], cmp);\\n      int prevInRow = -1;\\n      while (it != rows[r].end()) {\\n        if (prevInRow != -1 && mat[it->first][it->second] != prevInRow) break;\\n        prevInRow = mat[it->first][it->second];\\n        maxForCell = max(maxForCell, dp[it->first][it->second]);\\n        ++it;\\n      }\\n      \\n      auto jt = upper_bound(cols[c].begin(), cols[c].end(), allCells[i], cmp);\\n      int prevInCol = -1;\\n      while (jt != cols[c].end()) {\\n        if (prevInCol != -1 && mat[jt->first][jt->second] != prevInCol) break;\\n        prevInCol = mat[jt->first][jt->second];\\n        maxForCell = max(maxForCell, dp[jt->first][jt->second]);\\n        ++jt;\\n      }\\n      maxForCell++;\\n      dp[r][c] = maxForCell;\\n      maxCells = max(maxCells, maxForCell);\\n    }\\n    return maxCells;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  int maxIncreasingCells(vector<vector<int>>& mat) {\\n    int numRows = mat.size(), numCols = mat[0].size();\\n    vector<vector<int>> dp(numRows, vector<int>(numCols, -1));\\n    auto cmp = [&mat] (pair<int, int> p1, pair<int, int> p2) {\\n      return mat[p1.first][p1.second] < mat[p2.first][p2.second];\\n    };\\n    \\n    vector<vector<pair<int, int>>> rows(numRows), cols(numCols);\\n    for (int r = 0; r < numRows; ++r) {\\n      for (int c = 0; c < numCols; ++c) {\\n        rows[r].push_back({r, c});\\n        cols[c].push_back({r, c});\\n      }\\n    }\\n    // Sort rows individually.\\n    for (int r = 0; r < numRows; ++r) {\\n      sort(rows[r].begin(), rows[r].end(), cmp);\\n    }\\n    // Sort cols individually.\\n    for (int c = 0; c < numCols; ++c) {\\n      sort(cols[c].begin(), cols[c].end(), cmp);\\n    }\\n    \\n    // Sort all cells.\\n    vector<pair<int, int>> allCells;\\n    for (int r = 0; r < numRows; ++r) {\\n      for (int c = 0; c < numCols; ++c) {\\n        allCells.push_back({r, c});\\n      }\\n    }\\n    sort(allCells.begin(), allCells.end(), cmp);\\n    \\n    // Max cells will always be 1 even in the worst case.\\n    int maxCells = 1;\\n    \\n    // Set the value for the cell with the largest value to 1.\\n    dp[allCells.back().first][allCells.back().second] = 1;\\n    for (int i = allCells.size() - 2; i >= 0; --i) {\\n      auto [r, c] = allCells[i];\\n      \\n      int maxForCell = 0;\\n      \\n      auto it = upper_bound(rows[r].begin(), rows[r].end(), allCells[i], cmp);\\n      int prevInRow = -1;\\n      while (it != rows[r].end()) {\\n        if (prevInRow != -1 && mat[it->first][it->second] != prevInRow) break;\\n        prevInRow = mat[it->first][it->second];\\n        maxForCell = max(maxForCell, dp[it->first][it->second]);\\n        ++it;\\n      }\\n      \\n      auto jt = upper_bound(cols[c].begin(), cols[c].end(), allCells[i], cmp);\\n      int prevInCol = -1;\\n      while (jt != cols[c].end()) {\\n        if (prevInCol != -1 && mat[jt->first][jt->second] != prevInCol) break;\\n        prevInCol = mat[jt->first][jt->second];\\n        maxForCell = max(maxForCell, dp[jt->first][jt->second]);\\n        ++jt;\\n      }\\n      maxForCell++;\\n      dp[r][c] = maxForCell;\\n      maxCells = max(maxCells, maxForCell);\\n    }\\n    return maxCells;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571085,
                "title": "i-don-t-know-what-i-have-done-but-it-got-accepted",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    vector<vector<pair<int,int>>> grid,grid1;\\n    int solve(vector<vector<int>>& mat, int i, int j, int col, int row){\\n        int n=mat.size(),m=mat[0].size();\\n        if(i==n || i<0 || j==m || j<0){\\n            return 0;\\n        }\\n        else if(dp[i*m+j]!=-1){\\n            return dp[i*m+j];\\n        }\\n        \\n        int tans=1;\\n        int tcnt1=1,c1=0;\\n        while(col+tcnt1<m && grid[i][col+tcnt1].first==grid[i][col].first){\\n            tcnt1++;\\n        }\\n        c1=tcnt1;\\n        while(col+tcnt1<m && grid[i][col+tcnt1].first==grid[i][col+c1].first){\\n            int l=0,r=n-1,pos=-1;\\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                if(grid1[grid[i][col+tcnt1].second][mid].first<grid[i][col+tcnt1].first){\\n                    l=mid+1;\\n                }\\n                else if(grid1[grid[i][col+tcnt1].second][mid].first>grid[i][col+tcnt1].first){\\n                    r=mid-1;\\n                }\\n                else{\\n                    pos=mid;\\n                    break;\\n                }\\n            }\\n            \\n            tans=max(tans,solve(mat,i,grid[i][col+tcnt1].second,col+tcnt1,pos)+1);\\n            tcnt1++;\\n        }\\n        \\n        int tcnt2=1;\\n        while(row+tcnt2<n && grid1[j][row+tcnt2].first==grid1[j][row].first){\\n            tcnt2++;\\n        }\\n        c1=tcnt2;\\n        while(row+tcnt2<n && grid1[j][row+tcnt2].first==grid1[j][row+c1].first){\\n            int l=0,r=m-1,pos=-1;\\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                if(grid[grid1[j][row+tcnt2].second][mid].first<grid1[j][row+tcnt2].first){\\n                    l=mid+1;\\n                }\\n                else if(grid[grid1[j][row+tcnt2].second][mid].first>grid1[j][row+tcnt2].first){\\n                    r=mid-1;\\n                }\\n                else{\\n                    pos=mid;\\n                    break;\\n                }\\n            }\\n            tans=max(tans,solve(mat,grid1[j][row+tcnt2].second,j,pos,row+tcnt2)+1);\\n            tcnt2++;\\n        }\\n        \\n        return dp[i*m+j]=tans;\\n    }\\n    \\n    \\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size(),ans=1;\\n        memset(dp,-1,sizeof(dp));\\n        grid.resize(n);\\n        grid1.resize(m);\\n        \\n        \\n        for(int x=0;x<n;x++){\\n            for(int y=0;y<m;y++){\\n                grid[x].push_back({mat[x][y],y});\\n                grid1[y].push_back({mat[x][y],x});\\n            }\\n        }\\n        for(int x=0;x<n;x++){\\n            sort(grid[x].begin(),grid[x].end());\\n        }\\n        for(int x=0;x<m;x++){\\n            sort(grid1[x].begin(),grid1[x].end());\\n        }\\n        \\n        \\n        for(int x=0;x<n;x++){\\n            int l=0,r=n-1,pos=-1;\\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                if(grid1[grid[x][0].second][mid].first<grid[x][0].first){\\n                    l=mid+1;\\n                }\\n                else if(grid1[grid[x][0].second][mid].first>grid[x][0].first){\\n                    r=mid-1;\\n                }\\n                else{\\n                    pos=mid;\\n                    break;\\n                }\\n            }\\n            ans=max(ans,solve(mat,x,grid[x][0].second,0,pos));\\n        }\\n        \\n        \\n        for(int x=0;x<m;x++){\\n            int l=0,r=m-1,pos=-1;\\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                if(grid[grid1[x][0].second][mid].first<grid1[x][0].first){\\n                    l=mid+1;\\n                }\\n                else if(grid[grid1[x][0].second][mid].first>grid1[x][0].first){\\n                    r=mid-1;\\n                }\\n                else{\\n                    pos=mid;\\n                    break;\\n                }\\n            }\\n            ans=max(ans,solve(mat,grid1[x][0].second,x,pos,0));\\n        }\\n        \\n        for(int x=0;x<n;x++){\\n            for(int y=0;y<m;y++){\\n                ans=max(ans,dp[x*m+y]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    vector<vector<pair<int,int>>> grid,grid1;\\n    int solve(vector<vector<int>>& mat, int i, int j, int col, int row){\\n        int n=mat.size(),m=mat[0].size();\\n        if(i==n || i<0 || j==m || j<0){\\n            return 0;\\n        }\\n        else if(dp[i*m+j]!=-1){\\n            return dp[i*m+j];\\n        }\\n        \\n        int tans=1;\\n        int tcnt1=1,c1=0;\\n        while(col+tcnt1<m && grid[i][col+tcnt1].first==grid[i][col].first){\\n            tcnt1++;\\n        }\\n        c1=tcnt1;\\n        while(col+tcnt1<m && grid[i][col+tcnt1].first==grid[i][col+c1].first){\\n            int l=0,r=n-1,pos=-1;\\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                if(grid1[grid[i][col+tcnt1].second][mid].first<grid[i][col+tcnt1].first){\\n                    l=mid+1;\\n                }\\n                else if(grid1[grid[i][col+tcnt1].second][mid].first>grid[i][col+tcnt1].first){\\n                    r=mid-1;\\n                }\\n                else{\\n                    pos=mid;\\n                    break;\\n                }\\n            }\\n            \\n            tans=max(tans,solve(mat,i,grid[i][col+tcnt1].second,col+tcnt1,pos)+1);\\n            tcnt1++;\\n        }\\n        \\n        int tcnt2=1;\\n        while(row+tcnt2<n && grid1[j][row+tcnt2].first==grid1[j][row].first){\\n            tcnt2++;\\n        }\\n        c1=tcnt2;\\n        while(row+tcnt2<n && grid1[j][row+tcnt2].first==grid1[j][row+c1].first){\\n            int l=0,r=m-1,pos=-1;\\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                if(grid[grid1[j][row+tcnt2].second][mid].first<grid1[j][row+tcnt2].first){\\n                    l=mid+1;\\n                }\\n                else if(grid[grid1[j][row+tcnt2].second][mid].first>grid1[j][row+tcnt2].first){\\n                    r=mid-1;\\n                }\\n                else{\\n                    pos=mid;\\n                    break;\\n                }\\n            }\\n            tans=max(tans,solve(mat,grid1[j][row+tcnt2].second,j,pos,row+tcnt2)+1);\\n            tcnt2++;\\n        }\\n        \\n        return dp[i*m+j]=tans;\\n    }\\n    \\n    \\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size(),ans=1;\\n        memset(dp,-1,sizeof(dp));\\n        grid.resize(n);\\n        grid1.resize(m);\\n        \\n        \\n        for(int x=0;x<n;x++){\\n            for(int y=0;y<m;y++){\\n                grid[x].push_back({mat[x][y],y});\\n                grid1[y].push_back({mat[x][y],x});\\n            }\\n        }\\n        for(int x=0;x<n;x++){\\n            sort(grid[x].begin(),grid[x].end());\\n        }\\n        for(int x=0;x<m;x++){\\n            sort(grid1[x].begin(),grid1[x].end());\\n        }\\n        \\n        \\n        for(int x=0;x<n;x++){\\n            int l=0,r=n-1,pos=-1;\\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                if(grid1[grid[x][0].second][mid].first<grid[x][0].first){\\n                    l=mid+1;\\n                }\\n                else if(grid1[grid[x][0].second][mid].first>grid[x][0].first){\\n                    r=mid-1;\\n                }\\n                else{\\n                    pos=mid;\\n                    break;\\n                }\\n            }\\n            ans=max(ans,solve(mat,x,grid[x][0].second,0,pos));\\n        }\\n        \\n        \\n        for(int x=0;x<m;x++){\\n            int l=0,r=m-1,pos=-1;\\n            while(l<=r){\\n                int mid=(l+r)/2;\\n                if(grid[grid1[x][0].second][mid].first<grid1[x][0].first){\\n                    l=mid+1;\\n                }\\n                else if(grid[grid1[x][0].second][mid].first>grid1[x][0].first){\\n                    r=mid-1;\\n                }\\n                else{\\n                    pos=mid;\\n                    break;\\n                }\\n            }\\n            ans=max(ans,solve(mat,grid1[x][0].second,x,pos,0));\\n        }\\n        \\n        for(int x=0;x<n;x++){\\n            for(int y=0;y<m;y++){\\n                ans=max(ans,dp[x*m+y]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571011,
                "title": "a-detailed-solution-and-easy-to-understand-using-sorting-beat-83-3-runtime-and-91-67-memory",
                "content": "# Approach\\n- Suppose the size of given matrix is ```m x n```\\n- We will sort cells of the given matrix and handle cells in decreasing order. With each cell, we need to find the length of longest increasing cell chain that start from it\\n- For each row, we will save the length of the current longest increasing cell chain that start from a cell in that row (store it in the ```maxR``` array). We also do similar for each column (store it in the ```maxC``` array)\\n- However, cells in our matrix can have the same value. Follow problem\\'s rule, a cell can jump to a smaller cells in the same row or column but can\\'t jump to a cell with equal value. To solve it, when handling a cell, we only update the ```maxR``` and ```maxC``` array using the information of previous cells that smaller than it. \\n- To perform our idea, we need to save cells that was handled but haven\\'t been used to update ```maxR``` and ```maxC``` yet. We will only use that information to update ```maxR``` and ```maxC``` when the current handling cell smaller than those cells.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n *log(m*n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n) $$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int maxR[m];\\n        int maxC[n];\\n        memset(maxR, 0, sizeof(maxR));\\n        memset(maxC, 0, sizeof(maxC));\\n        \\n        vector<vector<int>> tmp;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                tmp.push_back(vector<int>({mat[i][j], i, j}));\\n            }\\n        }\\n        sort(tmp.begin(), tmp.end());\\n\\n        int tmpSize = m*n;\\n        vector<int> lic(tmpSize, 1);    // longest increasing cell chain\\n        int maxi = 1; \\n        /* We use l and r to keep track cells that was handled \\n        but haven\\'t been used to update maxR and maxC */\\n        int l = tmpSize-1;\\n        int r = tmpSize-1;  \\n        lic[tmpSize-1] = 1;\\n        for (int i=tmpSize-2; i>=0; i--) {\\n            if (tmp[i][0] == tmp[i+1][0]) {\\n                l = i;\\n            } else {\\n                for (int j=l; j<=r; j++) {\\n                    maxR[tmp[j][1]] = max(maxR[tmp[j][1]], lic[j]);\\n                    maxC[tmp[j][2]] = max(maxC[tmp[j][2]], lic[j]);\\n                }\\n                l = i;\\n                r = i;\\n            }\\n            \\n            lic[i] = max(maxR[tmp[i][1]], maxC[tmp[i][2]]) + 1;\\n            maxi = max(maxi, lic[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```m x n```\n```maxR```\n```maxC```\n```maxR```\n```maxC```\n```maxR```\n```maxC```\n```maxR```\n```maxC```\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int maxR[m];\\n        int maxC[n];\\n        memset(maxR, 0, sizeof(maxR));\\n        memset(maxC, 0, sizeof(maxC));\\n        \\n        vector<vector<int>> tmp;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                tmp.push_back(vector<int>({mat[i][j], i, j}));\\n            }\\n        }\\n        sort(tmp.begin(), tmp.end());\\n\\n        int tmpSize = m*n;\\n        vector<int> lic(tmpSize, 1);    // longest increasing cell chain\\n        int maxi = 1; \\n        /* We use l and r to keep track cells that was handled \\n        but haven\\'t been used to update maxR and maxC */\\n        int l = tmpSize-1;\\n        int r = tmpSize-1;  \\n        lic[tmpSize-1] = 1;\\n        for (int i=tmpSize-2; i>=0; i--) {\\n            if (tmp[i][0] == tmp[i+1][0]) {\\n                l = i;\\n            } else {\\n                for (int j=l; j<=r; j++) {\\n                    maxR[tmp[j][1]] = max(maxR[tmp[j][1]], lic[j]);\\n                    maxC[tmp[j][2]] = max(maxC[tmp[j][2]], lic[j]);\\n                }\\n                l = i;\\n                r = i;\\n            }\\n            \\n            lic[i] = max(maxR[tmp[i][1]], maxC[tmp[i][2]]) + 1;\\n            maxi = max(maxi, lic[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570795,
                "title": "java-sort-every-columns-and-rows-then-top-down-dp-dfs-memo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse top-down dp. The dp function is\\n`dp[i][j] = max(max(all the smallest next larger dp[i][k] in the same row i), all the smallest next larger dp[l][j] in the same column j)) + 1`\\n\\nThe \"smallest next larger\" means this is a greedy approach. It\\'s correctness can be proof by contradiction.\\n\\nTo find the next larger cell in the same row/column, we need to sort every columns and rows.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter sorting each row/column, we can use a linked-list-like array to save the next larger-or-equal index in the same row/column. Every cell is pointing to the next one in the sorted order.\\n\\nnext greater or equal horizontal (ngeh):\\n`if ngeh[i][j] = k, mat[i][k] is the next smallest value in row i such that mat[i][k] >= mat[i][j]` \\n\\nSimilarly\\nnext greater or equal vertical (ngev):\\n`if ngev[i][j] = k, mat[k][j] is the next smallest value in column j such that mat[k][j] >= mat[i][j]`\\n\\nWe than use this info to do our top-down dp (dfs + memo).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(mnlog_2n + nmlog_2m)$$ = $$O(mn(log_2n + log_2m))$$ = $$O(mnlog_2mn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(mn)$$\\n# Code\\n```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, res = 0;\\n        int[][] ngeh = new int[m][n]; // next greater or equal horizontal\\n        int[][] ngev = new int[m][n]; // next greater or equal vertical\\n        int[][] dp = new int[m][n];   // memo\\n\\n        // for each row, sort the cells\\' j indexs base on the value\\n        for (int i = 0; i < m; i++) {\\n            Integer[] tmp = new Integer[n];\\n            for (int j = 0; j < n; j++) {\\n                tmp[j] = j;\\n            }\\n            final int fi = i;\\n            Arrays.sort(tmp, (a, b) -> mat[fi][a] - mat[fi][b]);\\n            // each ngeh[i][j] point to the next larger or equal cell\\'s j index in this row\\n            for (int j = 0; j < n - 1; j++) {\\n                ngeh[i][tmp[j]] = tmp[j + 1];\\n            }\\n            // last one point to -1\\n            ngeh[i][tmp[n - 1]] = -1;\\n        }\\n\\n        // for each column, sort the cells\\' i indexs base on the value\\n        for (int j = 0; j < n; i++) {\\n            Integer[] tmp = new Integer[m];\\n            for (int i = 0; i < m; i++) {\\n                tmp[i] = i;\\n            }\\n            final int fj = j;\\n            Arrays.sort(tmp, (a, b) -> mat[a][fj] - mat[b][fj]);\\n            // each ngev[i][j] point to the next larger or equal cell\\'s i index in this column\\n            for (int i = 0; i < m - 1; i++) {\\n                ngev[tmp[i]][j] = tmp[i + 1];\\n            }\\n            // last one point to -1\\n            ngev[tmp[m - 1]][j] = -1;\\n        }\\n        \\n        // top down dp with memo\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (dp[i][j] == 0) {\\n                    res = Math.max(res, helper(i, j, ngeh, ngev, dp, mat));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int helper(int i, int j, int[][] ngeh, int[][] ngev, int[][] dp, int[][] mat) {\\n        if (dp[i][j] > 0) {\\n            return dp[i][j];\\n        }\\n        int res = 0;\\n\\n        // horizontal\\n        int next = ngeh[i][j];\\n        // skip all the same value\\n        while (next != -1 && mat[i][next] == mat[i][j]) {\\n            next = ngeh[i][next];\\n        }\\n        // for all the next larger cells in the row, recursively call dp \\n        if (next != -1) {\\n            int larger = mat[i][next];\\n            while (next != -1 && mat[i][next] == larger) {\\n                res = Math.max(res, helper(i, next, ngeh, ngev, dp, mat));\\n                next = ngeh[i][next];\\n            }\\n        }\\n        \\n        // vertical\\n        next = ngev[i][j];\\n        // skip all the same value\\n        while (next != -1 && mat[next][j] == mat[i][j]) {\\n            next = ngev[next][j];\\n        }\\n        // for all the next larger cells in the column, recursively call dp \\n        if (next != -1) {\\n            int larger = mat[next][j];\\n            while (next != -1 && mat[next][j] == larger) {\\n                res = Math.max(res, helper(next, j, ngeh, ngev, dp, mat));\\n                next = ngev[next][j];\\n            }\\n        }\\n        dp[i][j] = 1 + res;\\n        return 1 + res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, res = 0;\\n        int[][] ngeh = new int[m][n]; // next greater or equal horizontal\\n        int[][] ngev = new int[m][n]; // next greater or equal vertical\\n        int[][] dp = new int[m][n];   // memo\\n\\n        // for each row, sort the cells\\' j indexs base on the value\\n        for (int i = 0; i < m; i++) {\\n            Integer[] tmp = new Integer[n];\\n            for (int j = 0; j < n; j++) {\\n                tmp[j] = j;\\n            }\\n            final int fi = i;\\n            Arrays.sort(tmp, (a, b) -> mat[fi][a] - mat[fi][b]);\\n            // each ngeh[i][j] point to the next larger or equal cell\\'s j index in this row\\n            for (int j = 0; j < n - 1; j++) {\\n                ngeh[i][tmp[j]] = tmp[j + 1];\\n            }\\n            // last one point to -1\\n            ngeh[i][tmp[n - 1]] = -1;\\n        }\\n\\n        // for each column, sort the cells\\' i indexs base on the value\\n        for (int j = 0; j < n; i++) {\\n            Integer[] tmp = new Integer[m];\\n            for (int i = 0; i < m; i++) {\\n                tmp[i] = i;\\n            }\\n            final int fj = j;\\n            Arrays.sort(tmp, (a, b) -> mat[a][fj] - mat[b][fj]);\\n            // each ngev[i][j] point to the next larger or equal cell\\'s i index in this column\\n            for (int i = 0; i < m - 1; i++) {\\n                ngev[tmp[i]][j] = tmp[i + 1];\\n            }\\n            // last one point to -1\\n            ngev[tmp[m - 1]][j] = -1;\\n        }\\n        \\n        // top down dp with memo\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (dp[i][j] == 0) {\\n                    res = Math.max(res, helper(i, j, ngeh, ngev, dp, mat));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int helper(int i, int j, int[][] ngeh, int[][] ngev, int[][] dp, int[][] mat) {\\n        if (dp[i][j] > 0) {\\n            return dp[i][j];\\n        }\\n        int res = 0;\\n\\n        // horizontal\\n        int next = ngeh[i][j];\\n        // skip all the same value\\n        while (next != -1 && mat[i][next] == mat[i][j]) {\\n            next = ngeh[i][next];\\n        }\\n        // for all the next larger cells in the row, recursively call dp \\n        if (next != -1) {\\n            int larger = mat[i][next];\\n            while (next != -1 && mat[i][next] == larger) {\\n                res = Math.max(res, helper(i, next, ngeh, ngev, dp, mat));\\n                next = ngeh[i][next];\\n            }\\n        }\\n        \\n        // vertical\\n        next = ngev[i][j];\\n        // skip all the same value\\n        while (next != -1 && mat[next][j] == mat[i][j]) {\\n            next = ngev[next][j];\\n        }\\n        // for all the next larger cells in the column, recursively call dp \\n        if (next != -1) {\\n            int larger = mat[next][j];\\n            while (next != -1 && mat[next][j] == larger) {\\n                res = Math.max(res, helper(next, j, ngeh, ngev, dp, mat));\\n                next = ngev[next][j];\\n            }\\n        }\\n        dp[i][j] = 1 + res;\\n        return 1 + res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570755,
                "title": "python-sorting-dp-solution-with-explanation-o-m-n-log-m-n",
                "content": "### Intuition :\\nFind the longest path (maximum steps/moves) in the matrix with cells in increasing order using DP\\n\\n### Approach :\\n\\nLet `rows[i]` be the maximum moves for row i\\nLet `cols[i]` be the maximum moves for col i\\nSmallest cell `mat[i][j]` will start with `cur_moves` = 1.\\n1. Sort pairs `[i, j]` by the value of `mat[i][j]`\\n2. Iterate cells in the matrix in increasing order.\\n3. For each `mat[i][j]`, find out the current maximum moves in the corresponding row `r` and col `c`.\\n\\t`cur_moves[i]` = 1 + `max` (max moves in row `r`, max moves in col `c`) \\n4. Return the maximum one among the moves for each row and each col.\\n\\t`max(rows + cols)`\\n\\n### Complexity :\\n* **Time Complexity** : O(m * n * log(m * n)\\n* **Space Complexity** : O(m * n) \\n\\n### Solution :\\n\\nPython\\n\\n```python\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        ele = defaultdict(list)\\n        \\n        # store locations of each element in the matrix\\n        for i in range(m):\\n            for j in range(n):\\n                ele[mat[i][j]].append([i,j])\\n                \\n        # store maximum cells that can be visited in a particular row and col\\n        rows = [0]*m\\n        cols = [0]*n\\n        \\n        for i,locs in sorted(ele.items()):            \\n            cur_moves = [] #dp\\n            for r,c in locs:\\n                cur_moves.append(1 + max(rows[r],cols[c]))\\n                \\n            for j in range(len(locs)):\\n                r,c = locs[j]\\n                \\n                # update rth row and cth col with current moves\\n                rows[r] = max(rows[r],cur_moves[j])\\n                cols[c] = max(cols[c],cur_moves[j])\\n        \\n        return max(rows+cols)\\n```\\n\\n### Similar Problem :\\nA problem with similar technique : https://leetcode.com/problems/rank-transform-of-a-matrix/",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        ele = defaultdict(list)\\n        \\n        # store locations of each element in the matrix\\n        for i in range(m):\\n            for j in range(n):\\n                ele[mat[i][j]].append([i,j])\\n                \\n        # store maximum cells that can be visited in a particular row and col\\n        rows = [0]*m\\n        cols = [0]*n\\n        \\n        for i,locs in sorted(ele.items()):            \\n            cur_moves = [] #dp\\n            for r,c in locs:\\n                cur_moves.append(1 + max(rows[r],cols[c]))\\n                \\n            for j in range(len(locs)):\\n                r,c = locs[j]\\n                \\n                # update rth row and cth col with current moves\\n                rows[r] = max(rows[r],cur_moves[j])\\n                cols[c] = max(cols[c],cur_moves[j])\\n        \\n        return max(rows+cols)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570697,
                "title": "c-solution-dp-o-n-m-log-n-m",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        map<int,vector<vector<int>>>mp;\\n        set<int>st;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                mp[mat[i][j]].push_back({i,j});\\n                st.insert(mat[i][j]);\\n            }\\n        }\\n\\n        vector<int>r(n,0),c(m,0);\\n\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n\\n        for(auto it : st){\\n            for(auto itt : mp[it]){\\n                int x = itt[0];\\n                int y = itt[1];\\n                dp[x][y] = max(r[x],c[y]) + 1;\\n            }\\n\\n            for(auto itt : mp[it]){\\n                int x = itt[0];\\n                int y = itt[1];\\n                r[x] = max(r[x],dp[x][y]);\\n                c[y] = max(c[y],dp[x][y]);\\n            }\\n        }\\n        return max(*max_element(r.begin(),r.end()),*max_element(c.begin(),c.end()));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        map<int,vector<vector<int>>>mp;\\n        set<int>st;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                mp[mat[i][j]].push_back({i,j});\\n                st.insert(mat[i][j]);\\n            }\\n        }\\n\\n        vector<int>r(n,0),c(m,0);\\n\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n\\n        for(auto it : st){\\n            for(auto itt : mp[it]){\\n                int x = itt[0];\\n                int y = itt[1];\\n                dp[x][y] = max(r[x],c[y]) + 1;\\n            }\\n\\n            for(auto itt : mp[it]){\\n                int x = itt[0];\\n                int y = itt[1];\\n                r[x] = max(r[x],dp[x][y]);\\n                c[y] = max(c[y],dp[x][y]);\\n            }\\n        }\\n        return max(*max_element(r.begin(),r.end()),*max_element(c.begin(),c.end()));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570626,
                "title": "my-solutions",
                "content": "**Solution `I`**\\n```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the matrix `mat`\\n *       `cols` is the number of the columns of the matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int maxIncreasingCells(const vector<vector<int>> &mat) {\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    map<int, vector<int>> value_to_indices;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        value_to_indices[mat[r][c]].emplace_back(r * cols + c);\\n      }\\n    }\\n    \\n    int max_count_on_rows[rows];\\n    memset(max_count_on_rows, 0, sizeof(max_count_on_rows));\\n    int max_count_on_cols[cols];\\n    memset(max_count_on_cols, 0, sizeof(max_count_on_cols));\\n    \\n    int ret = 0;\\n    int dp[rows][cols];\\n    for (const auto &[_, indices] : value_to_indices) {\\n      for (const int index : indices) {\\n        const int r = index / cols;\\n        const int c = index % cols;\\n        dp[r][c] = max(max_count_on_rows[r], max_count_on_cols[c]) + 1;\\n        ret = max(ret, dp[r][c]);\\n      }\\n      \\n      for (const int index : indices) {\\n        const int r = index / cols;\\n        const int c = index % cols;\\n        max_count_on_rows[r] = max(max_count_on_rows[r], dp[r][c]);\\n        max_count_on_cols[c] = max(max_count_on_cols[c], dp[r][c]);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**Solution `II`, the same idea with `I` without the space consumption for the variable `dp`**\\n```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the matrix `mat`\\n *       `cols` is the number of the columns of the matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int maxIncreasingCells(const vector<vector<int>> &mat) {\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    map<int, vector<pair<int, int>>> num_to_positions;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        num_to_positions[mat[r][c]].emplace_back(r, c);\\n      }\\n    }\\n    \\n    int max_count_on_rows[rows];\\n    memset(max_count_on_rows, 0, sizeof(max_count_on_rows));\\n    int max_count_on_cols[cols];\\n    memset(max_count_on_cols, 0, sizeof(max_count_on_cols));\\n    for (const auto &[_, positions] : num_to_positions) {\\n      const int n_positions = static_cast<int>(positions.size());\\n      int counts[n_positions];\\n      memset(counts, 0, sizeof(counts));\\n      for (int i = 0; i < n_positions; ++i) {\\n        const auto [r, c] = positions[i];\\n        counts[i] = max(max_count_on_rows[r], max_count_on_cols[c]) + 1;\\n      }\\n      \\n      for (int i = 0; i < n_positions; ++i) {\\n        const auto [r, c] = positions[i];\\n        max_count_on_rows[r] = max(max_count_on_rows[r], counts[i]);\\n        max_count_on_cols[c] = max(max_count_on_cols[c], counts[i]);\\n      }\\n    }\\n    return max(*max_element(max_count_on_rows, max_count_on_rows + rows),\\n               *max_element(max_count_on_cols, max_count_on_cols + cols));\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the matrix `mat`\\n *       `cols` is the number of the columns of the matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int maxIncreasingCells(const vector<vector<int>> &mat) {\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    map<int, vector<int>> value_to_indices;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        value_to_indices[mat[r][c]].emplace_back(r * cols + c);\\n      }\\n    }\\n    \\n    int max_count_on_rows[rows];\\n    memset(max_count_on_rows, 0, sizeof(max_count_on_rows));\\n    int max_count_on_cols[cols];\\n    memset(max_count_on_cols, 0, sizeof(max_count_on_cols));\\n    \\n    int ret = 0;\\n    int dp[rows][cols];\\n    for (const auto &[_, indices] : value_to_indices) {\\n      for (const int index : indices) {\\n        const int r = index / cols;\\n        const int c = index % cols;\\n        dp[r][c] = max(max_count_on_rows[r], max_count_on_cols[c]) + 1;\\n        ret = max(ret, dp[r][c]);\\n      }\\n      \\n      for (const int index : indices) {\\n        const int r = index / cols;\\n        const int c = index % cols;\\n        max_count_on_rows[r] = max(max_count_on_rows[r], dp[r][c]);\\n        max_count_on_cols[c] = max(max_count_on_cols[c], dp[r][c]);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the matrix `mat`\\n *       `cols` is the number of the columns of the matrix `mat`\\n */\\nclass Solution {\\n public:\\n  int maxIncreasingCells(const vector<vector<int>> &mat) {\\n    const int rows = static_cast<int>(mat.size());\\n    const int cols = static_cast<int>(mat.front().size());\\n    map<int, vector<pair<int, int>>> num_to_positions;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        num_to_positions[mat[r][c]].emplace_back(r, c);\\n      }\\n    }\\n    \\n    int max_count_on_rows[rows];\\n    memset(max_count_on_rows, 0, sizeof(max_count_on_rows));\\n    int max_count_on_cols[cols];\\n    memset(max_count_on_cols, 0, sizeof(max_count_on_cols));\\n    for (const auto &[_, positions] : num_to_positions) {\\n      const int n_positions = static_cast<int>(positions.size());\\n      int counts[n_positions];\\n      memset(counts, 0, sizeof(counts));\\n      for (int i = 0; i < n_positions; ++i) {\\n        const auto [r, c] = positions[i];\\n        counts[i] = max(max_count_on_rows[r], max_count_on_cols[c]) + 1;\\n      }\\n      \\n      for (int i = 0; i < n_positions; ++i) {\\n        const auto [r, c] = positions[i];\\n        max_count_on_rows[r] = max(max_count_on_rows[r], counts[i]);\\n        max_count_on_cols[c] = max(max_count_on_cols[c], counts[i]);\\n      }\\n    }\\n    return max(*max_element(max_count_on_rows, max_count_on_rows + rows),\\n               *max_element(max_count_on_cols, max_count_on_cols + cols));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570608,
                "title": "traverse-in-descending-order-tracking-n-m-max-values",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        // Intuition: traverse the matrix in descending order,\\n        // keeping track of the length of the longest path seen so far\\n        // on each column and on each row.\\n        \\n        // By traversing in descending order, \\n        // we can always jump to any longest path we have seen before\\n        \\n        // N x M matrix\\n        int N = mat.size(), M = mat[0].size();\\n        \\n        // longest path seen so far on each of N rows and M columns\\n        vector<int> row_mx(N), col_mx(M);\\n        vector<array<int,3>> nums(N*M);\\n        for(int r=0;r<N;++r){\\n            for(int c=0;c<M;++c){\\n                nums[r*M+c] = {mat[r][c],r,c};\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        \\n        // before really updating row_mx, col_mx, we need to\\n        // set aside row and column updates until we have seen \\n        // all cells with equal value. This is to ensure that\\n        // jumping to any path in row_mx, col_mx remains legal.\\n        \\n        map<int,int> new_row_mx, new_col_mx;\\n        int gmx = 0; // global max\\n        for(int i=N*M-1;i>=0;){\\n            int v = nums[i][0];\\n            // process all cells with value v\\n            while(i>=0 && nums[i][0]==v){\\n                auto [v,r,c] = nums[i--];\\n                // we can jump to any longest path seen so far\\n                // in row r and col c\\n                int mx = 1 + max(row_mx[r], col_mx[c]);\\n                // set aside the new max update\\n                new_row_mx[r] = max(new_row_mx[r], mx);\\n                new_col_mx[c] = max(new_col_mx[c], mx);\\n            }\\n            // execute the deferred row and col max path length updates\\n            for(auto [r, rmx]: new_row_mx){\\n                row_mx[r] = rmx;\\n                gmx = max(gmx, rmx);\\n            }\\n            for(auto [c, cmx]: new_col_mx){\\n                col_mx[c] = cmx;\\n                gmx = max(gmx, cmx);\\n            }\\n            new_row_mx.clear();\\n            new_col_mx.clear();\\n        }\\n        return gmx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        // Intuition: traverse the matrix in descending order,\\n        // keeping track of the length of the longest path seen so far\\n        // on each column and on each row.\\n        \\n        // By traversing in descending order, \\n        // we can always jump to any longest path we have seen before\\n        \\n        // N x M matrix\\n        int N = mat.size(), M = mat[0].size();\\n        \\n        // longest path seen so far on each of N rows and M columns\\n        vector<int> row_mx(N), col_mx(M);\\n        vector<array<int,3>> nums(N*M);\\n        for(int r=0;r<N;++r){\\n            for(int c=0;c<M;++c){\\n                nums[r*M+c] = {mat[r][c],r,c};\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        \\n        // before really updating row_mx, col_mx, we need to\\n        // set aside row and column updates until we have seen \\n        // all cells with equal value. This is to ensure that\\n        // jumping to any path in row_mx, col_mx remains legal.\\n        \\n        map<int,int> new_row_mx, new_col_mx;\\n        int gmx = 0; // global max\\n        for(int i=N*M-1;i>=0;){\\n            int v = nums[i][0];\\n            // process all cells with value v\\n            while(i>=0 && nums[i][0]==v){\\n                auto [v,r,c] = nums[i--];\\n                // we can jump to any longest path seen so far\\n                // in row r and col c\\n                int mx = 1 + max(row_mx[r], col_mx[c]);\\n                // set aside the new max update\\n                new_row_mx[r] = max(new_row_mx[r], mx);\\n                new_col_mx[c] = max(new_col_mx[c], mx);\\n            }\\n            // execute the deferred row and col max path length updates\\n            for(auto [r, rmx]: new_row_mx){\\n                row_mx[r] = rmx;\\n                gmx = max(gmx, rmx);\\n            }\\n            for(auto [c, cmx]: new_col_mx){\\n                col_mx[c] = cmx;\\n                gmx = max(gmx, cmx);\\n            }\\n            new_row_mx.clear();\\n            new_col_mx.clear();\\n        }\\n        return gmx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570594,
                "title": "javascript-dp-sort-1059ms",
                "content": "```\\nconst stmkey_in = (m) => new Map([...m].sort((x, y) => x[0] - y[0]));\\n\\nconst maxIncreasingCells = (g) => {\\n    let n = g.length, m = g[0].length, ma = new Map(),\\n        row = new Int32Array(n).fill(0), col = new Int32Array(m).fill(0), res = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (!ma.has(g[i][j])) ma.set(g[i][j], []);\\n            ma.get(g[i][j]).push([i, j]);\\n        }\\n    }\\n    ma = stmkey_in(ma);\\n    for (const [x, d] of ma) {\\n        let trow = [], tcol = [];\\n        for (const [i, j] of d) {\\n            let t = Math.max(1, row[i] + 1, col[j] + 1);\\n            res = Math.max(res, t);\\n            trow.push([i, t]);\\n            tcol.push([j, t]);\\n        }\\n        for (const [i, j] of trow) row[i] = Math.max(row[i], j);\\n        for (const [i, j] of tcol) col[i] = Math.max(col[i], j);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Sort",
                    "Ordered Map"
                ],
                "code": "```\\nconst stmkey_in = (m) => new Map([...m].sort((x, y) => x[0] - y[0]));\\n\\nconst maxIncreasingCells = (g) => {\\n    let n = g.length, m = g[0].length, ma = new Map(),\\n        row = new Int32Array(n).fill(0), col = new Int32Array(m).fill(0), res = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (!ma.has(g[i][j])) ma.set(g[i][j], []);\\n            ma.get(g[i][j]).push([i, j]);\\n        }\\n    }\\n    ma = stmkey_in(ma);\\n    for (const [x, d] of ma) {\\n        let trow = [], tcol = [];\\n        for (const [i, j] of d) {\\n            let t = Math.max(1, row[i] + 1, col[j] + 1);\\n            res = Math.max(res, t);\\n            trow.push([i, t]);\\n            tcol.push([j, t]);\\n        }\\n        for (const [i, j] of trow) row[i] = Math.max(row[i], j);\\n        for (const [i, j] of tcol) col[i] = Math.max(col[i], j);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570567,
                "title": "rust-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing row vector and clm vector to track the biggest sequence number of the current row & clm.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M * N * Log (M * N))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M * N)\\n# Code\\n```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution {\\n    pub fn max_increasing_cells(mat: Vec<Vec<i32>>) -> i32 {\\n        let mut mp = BTreeMap::<i32, Vec<(usize, usize)>>::new();\\n        let (m, n) = (mat.len(), mat[0].len());\\n\\n        for i in 0 .. m {\\n            for j in 0 .. n {\\n                mp.entry(mat[i][j]).or_insert(vec![]).push((i, j));\\n            }\\n        }\\n\\n        let mut ret = 1;\\n        let (mut row, mut clm) = (vec![(i32::MIN, 0); m], vec![(i32::MIN, 0); n]);\\n        \\n        for (a, v) in mp {\\n            let m = v.len();\\n            let mut val = vec![1; m];\\n\\n            for k in 0 .. m {\\n                let (i, j) = (v[k].0, v[k].1);\\n \\n                val[k] = val[k].max(row[i].1 + 1);\\n                val[k] = val[k].max(clm[j].1 + 1);\\n                \\n                ret = ret.max(val[k]);\\n            }\\n\\n            for k in 0 .. m {\\n                let (i, j) = (v[k].0, v[k].1); \\n                \\n                row[i] = (a, row[i].1.max(val[k]));\\n                clm[j] = (a, clm[j].1.max(val[k]));\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution {\\n    pub fn max_increasing_cells(mat: Vec<Vec<i32>>) -> i32 {\\n        let mut mp = BTreeMap::<i32, Vec<(usize, usize)>>::new();\\n        let (m, n) = (mat.len(), mat[0].len());\\n\\n        for i in 0 .. m {\\n            for j in 0 .. n {\\n                mp.entry(mat[i][j]).or_insert(vec![]).push((i, j));\\n            }\\n        }\\n\\n        let mut ret = 1;\\n        let (mut row, mut clm) = (vec![(i32::MIN, 0); m], vec![(i32::MIN, 0); n]);\\n        \\n        for (a, v) in mp {\\n            let m = v.len();\\n            let mut val = vec![1; m];\\n\\n            for k in 0 .. m {\\n                let (i, j) = (v[k].0, v[k].1);\\n \\n                val[k] = val[k].max(row[i].1 + 1);\\n                val[k] = val[k].max(clm[j].1 + 1);\\n                \\n                ret = ret.max(val[k]);\\n            }\\n\\n            for k in 0 .. m {\\n                let (i, j) = (v[k].0, v[k].1); \\n                \\n                row[i] = (a, row[i].1.max(val[k]));\\n                clm[j] = (a, clm[j].1.max(val[k]));\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570550,
                "title": "golang-dp",
                "content": "# Code\\n```\\nfunc maxIncreasingCells(mat [][]int) int {\\n    m, n := len(mat), len(mat[0])\\n    states := make(map[int][][]int)\\n    smallestValue := math.MaxInt32\\n    largestValue := 0\\n\\n    for r := 0; r < m; r++ {\\n        for c := 0; c <n; c++ {\\n            states[mat[r][c]] = append(states[mat[r][c]], []int{r, c})\\n            smallestValue = min(smallestValue, mat[r][c])\\n            largestValue = max(largestValue, mat[r][c])\\n        }\\n    }\\n\\n    dp := make([][]int, m)\\n    for i := range dp {\\n        dp[i] = make([]int, n)\\n    }\\n    res := make([]int, m+n)\\n    longestPath := 0\\n\\n    for i := smallestValue; i <= largestValue; i++ {\\n        for _, state := range states[i] {\\n            r, c := state[0], state[1]\\n            dp[r][c] = max(res[c+m], res[r]) + 1\\n            longestPath = max(longestPath, dp[r][c])\\n        }\\n        for _, state := range states[i] {\\n            r, c := state[0], state[1]\\n            res[r] = max(res[r], dp[r][c])\\n            res[c+m] = max(res[c+m], dp[r][c])\\n        }\\n    }\\n    return longestPath\\n}\\n\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxIncreasingCells(mat [][]int) int {\\n    m, n := len(mat), len(mat[0])\\n    states := make(map[int][][]int)\\n    smallestValue := math.MaxInt32\\n    largestValue := 0\\n\\n    for r := 0; r < m; r++ {\\n        for c := 0; c <n; c++ {\\n            states[mat[r][c]] = append(states[mat[r][c]], []int{r, c})\\n            smallestValue = min(smallestValue, mat[r][c])\\n            largestValue = max(largestValue, mat[r][c])\\n        }\\n    }\\n\\n    dp := make([][]int, m)\\n    for i := range dp {\\n        dp[i] = make([]int, n)\\n    }\\n    res := make([]int, m+n)\\n    longestPath := 0\\n\\n    for i := smallestValue; i <= largestValue; i++ {\\n        for _, state := range states[i] {\\n            r, c := state[0], state[1]\\n            dp[r][c] = max(res[c+m], res[r]) + 1\\n            longestPath = max(longestPath, dp[r][c])\\n        }\\n        for _, state := range states[i] {\\n            r, c := state[0], state[1]\\n            res[r] = max(res[r], dp[r][c])\\n            res[c+m] = max(res[c+m], dp[r][c])\\n        }\\n    }\\n    return longestPath\\n}\\n\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570546,
                "title": "maximum-increasing-cells-in-a-matrix-using-c",
                "content": "# Intuition\\nThe problem requires finding the length of the longest increasing path in a matrix. To solve this, we can use dynamic programming to track the length of increasing paths starting from each cell. By iteratively updating the maximum path length for each cell, we can find the overall maximum length.\\n\\n# Approach\\n1. Initialize variables: n and m as the number of rows and columns in the matrix, rowMax and colMax as vectors of size n and m respectively to track the maximum path length for each row and column, and pos as a map to store the cells of each value in descending order.\\n1. Iterate through the matrix and store the cells of each value in the pos map.\\n1. Initialize ans as 0, which will store the maximum path length.\\n1. Iterate over the pos map in descending order.\\n1. For each value num and its corresponding cells:\\n- Get the number of cells k for the current value.\\n- Create a vector next of size k to store the next values for each cell.\\n- Iterate over the cells and calculate the next path length for each cell:\\n\\u2022 Get the row and column indices of the current cell.\\n\\u2022 Calculate the maximum of the row max and column max for the current cell and store it in next[i].\\n\\u2022 Update ans if next[i] is greater.\\n- Update the row max and column max for each cell using the next vector.\\n6. Return ans as the maximum path length.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nm*log(nm))$$\\n\\n- Space complexity:\\n$$O(nm)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> rowMax(n), colMax(m);\\n\\n        // Create a map to store the cells of each value.\\n        // The map is sorted by value in descending order.\\n        map<int, vector<pair<int, int>>> pos;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                pos[mat[i][j]].push_back({i, j});\\n            }\\n        }\\n\\n        // Initialize the answer to 0.\\n        int ans = 0;\\n\\n        // Iterate over the map.\\n        for (auto& [num, cells]: pos) {\\n            // Get the number of cells in the current value.\\n            int k = cells.size();\\n\\n            // Create a vector to store the next values for each cell.\\n            vector<int> next(k);\\n\\n            // Iterate over the cells.\\n            for (int i = 0; i < k; ++i) {\\n                // Get the row and column indices of the current cell.\\n                int r = cells[i].first, c = cells[i].second;\\n\\n                // Get the maximum of the row max and column max for the current cell.\\n                next[i] = max(rowMax[r], colMax[c]) + 1;\\n\\n                // Update the answer.\\n                ans = max(ans, next[i]);\\n            }\\n\\n            // Update the row max and column max for each cell.\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                rowMax[r] = max(rowMax[r], next[i]);\\n                colMax[c] = max(colMax[c], next[i]);\\n            }\\n        }\\n\\n        // Return the answer.\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> rowMax(n), colMax(m);\\n\\n        // Create a map to store the cells of each value.\\n        // The map is sorted by value in descending order.\\n        map<int, vector<pair<int, int>>> pos;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                pos[mat[i][j]].push_back({i, j});\\n            }\\n        }\\n\\n        // Initialize the answer to 0.\\n        int ans = 0;\\n\\n        // Iterate over the map.\\n        for (auto& [num, cells]: pos) {\\n            // Get the number of cells in the current value.\\n            int k = cells.size();\\n\\n            // Create a vector to store the next values for each cell.\\n            vector<int> next(k);\\n\\n            // Iterate over the cells.\\n            for (int i = 0; i < k; ++i) {\\n                // Get the row and column indices of the current cell.\\n                int r = cells[i].first, c = cells[i].second;\\n\\n                // Get the maximum of the row max and column max for the current cell.\\n                next[i] = max(rowMax[r], colMax[c]) + 1;\\n\\n                // Update the answer.\\n                ans = max(ans, next[i]);\\n            }\\n\\n            // Update the row max and column max for each cell.\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                rowMax[r] = max(rowMax[r], next[i]);\\n                colMax[c] = max(colMax[c], next[i]);\\n            }\\n        }\\n\\n        // Return the answer.\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570526,
                "title": "priority-queue-solution",
                "content": "Didn\\'t check possibility of O(mn) solution(as I think that might not be possible). But a O((mn)log(mn)) is very intutive. You take the largest element and assign it 1 and then keep assigning the smaller elements successively.\\nAlthough implementation can be bug-prone.\\nThis might not be the best soln as I see some complexity reduction might be possible to get O((mn)log(max(n, m)) solution but it is going to suck out your soul in debugging if you get stuck. (already faced issues debugging this one before AC during the contest, and I didn\\'t get time to complete 2 other problems, because of this one).\\n\\nNote that **O((mn)log(mn)) = O((mn)log(max(n, m))**, but it just that constants would be bad, so much so that if you take (mn)log(max(m,n)) instead of mn while evaluating values using priority queue method, it will give TLE.\\nHowever, you can take (mn)log(max(m,n)) time if you do not use priority queue or sort entire matrix(instead do row-wise and column-wise sorting separately) using dp like solution, and it will take less time(TC will still be same). Alternatively you can even use 2 pointers then. That would further reduce the time.\\n\\nI used the priority queue method.\\nHere, I am keeping 4 elements in each row and col entry.\\n1st element : a value that is currenty smallest(and current value may be equal to that, or less)\\n2nd element: maximum ans from currently smallest value.\\n3rd element: a value that is larger than currently smallest(or 0 to rep infinity)(and current value is definetly smaller than that.)\\n4th element: maximum ans from a value that is larger than currently smallest.\\n(3rd element is redudandant and we don\\'t need to store that. It has no use).\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        vector<vector<int> > row(mat.size(), vector<int>(4, 0));\\n        vector<vector<int> > col(mat[0].size(), vector<int>(4, 0));\\n        priority_queue<vector<int> > pq;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j < mat[0].size(); j++)\\n                pq.push({mat[i][j], i, j});\\n        }\\n        int ans = 0;\\n        int x, y, v;\\n        int d;\\n        while(!pq.empty()){\\n            v = pq.top()[0];\\n            x = pq.top()[1];\\n            y = pq.top()[2];\\n            pq.pop();\\n            if(v < row[x][0]){\\n                d = row[x][1] + 1;\\n            }\\n            else d = row[x][3] + 1;\\n            if(v < col[y][0]){\\n                d = max(d, col[y][1] + 1);\\n            }\\n            else d = max(d, col[y][3] + 1);\\n            \\n            if(v < row[x][0]){\\n                row[x][2] = row[x][0];\\n                row[x][3] = row[x][1];\\n                row[x][0] = v;\\n                row[x][1] = d;\\n            }\\n            else{\\n                row[x][0] = v;\\n                row[x][1] = max(row[x][1], d);\\n            }\\n            if(v < col[y][0]){\\n                col[y][2] = col[y][0];\\n                col[y][3] = col[y][1];\\n                col[y][0] = v;\\n                col[y][1] = d;\\n            }\\n            else{\\n                col[y][0] = v;\\n                col[y][1] = max(col[y][1], d);\\n            }\\n            ans = max(ans, d);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        vector<vector<int> > row(mat.size(), vector<int>(4, 0));\\n        vector<vector<int> > col(mat[0].size(), vector<int>(4, 0));\\n        priority_queue<vector<int> > pq;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j < mat[0].size(); j++)\\n                pq.push({mat[i][j], i, j});\\n        }\\n        int ans = 0;\\n        int x, y, v;\\n        int d;\\n        while(!pq.empty()){\\n            v = pq.top()[0];\\n            x = pq.top()[1];\\n            y = pq.top()[2];\\n            pq.pop();\\n            if(v < row[x][0]){\\n                d = row[x][1] + 1;\\n            }\\n            else d = row[x][3] + 1;\\n            if(v < col[y][0]){\\n                d = max(d, col[y][1] + 1);\\n            }\\n            else d = max(d, col[y][3] + 1);\\n            \\n            if(v < row[x][0]){\\n                row[x][2] = row[x][0];\\n                row[x][3] = row[x][1];\\n                row[x][0] = v;\\n                row[x][1] = d;\\n            }\\n            else{\\n                row[x][0] = v;\\n                row[x][1] = max(row[x][1], d);\\n            }\\n            if(v < col[y][0]){\\n                col[y][2] = col[y][0];\\n                col[y][3] = col[y][1];\\n                col[y][0] = v;\\n                col[y][1] = d;\\n            }\\n            else{\\n                col[y][0] = v;\\n                col[y][1] = max(col[y][1], d);\\n            }\\n            ans = max(ans, d);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570503,
                "title": "c-dp-traverse-in-strictly-increasing-order-ordered-map-commented-code",
                "content": "### Do UPVOTE if it adds value !\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n\\n        //mapping each grid value to its positions\\n        // each position[i,j] is stored as single integer val=i*m+j\\n        //we need get i and j as :\\n        //   i= val/m;\\n        //   j= val%m;\\n        map<int,vector<int>> mp;\\n        for(int i=0 ; i<n;  i++){\\n            for(int j=0 ; j<m ; j++){\\n                mp[mat[i][j]].push_back(m*i+j);\\n            }\\n        }\\n\\n        //dp[i][j] will store possible max path length till i,j\\n        //res_r and res_c will store max path possible from current row or column respectively.\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        vector<int> res_r(n,0),res_c(m,0);\\n\\n        //traversing values in strictly increasing order(stored in map)\\n        for(auto &[ele , pos] : mp){\\n            //finding max possible path for possible row column pair having value ele .\\n            for(int p : pos){\\n                int r=p/m;\\n                int c=p%m;\\n                dp[r][c]=max(res_r[r],res_c[c])+1;\\n            }\\n\\n            //updating res_r,res_c for next iteration \\n            for(int p : pos){\\n                int r=p/m;\\n                int c=p%m;\\n                res_r[r]=max(res_r[r],dp[r][c]);\\n                res_c[c]=max(res_c[c],dp[r][c]);\\n            }\\n        }\\n\\n        //evaluating ans\\n        int ans=0;\\n        for(int i=0 ; i<n ; i++){\\n            ans=max(ans,res_r[i]);\\n        }\\n        for(int i=0 ; i<m ; i++){\\n            ans=max(ans,res_c[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n\\n        //mapping each grid value to its positions\\n        // each position[i,j] is stored as single integer val=i*m+j\\n        //we need get i and j as :\\n        //   i= val/m;\\n        //   j= val%m;\\n        map<int,vector<int>> mp;\\n        for(int i=0 ; i<n;  i++){\\n            for(int j=0 ; j<m ; j++){\\n                mp[mat[i][j]].push_back(m*i+j);\\n            }\\n        }\\n\\n        //dp[i][j] will store possible max path length till i,j\\n        //res_r and res_c will store max path possible from current row or column respectively.\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        vector<int> res_r(n,0),res_c(m,0);\\n\\n        //traversing values in strictly increasing order(stored in map)\\n        for(auto &[ele , pos] : mp){\\n            //finding max possible path for possible row column pair having value ele .\\n            for(int p : pos){\\n                int r=p/m;\\n                int c=p%m;\\n                dp[r][c]=max(res_r[r],res_c[c])+1;\\n            }\\n\\n            //updating res_r,res_c for next iteration \\n            for(int p : pos){\\n                int r=p/m;\\n                int c=p%m;\\n                res_r[r]=max(res_r[r],dp[r][c]);\\n                res_c[c]=max(res_c[c],dp[r][c]);\\n            }\\n        }\\n\\n        //evaluating ans\\n        int ans=0;\\n        for(int i=0 ; i<n ; i++){\\n            ans=max(ans,res_r[i]);\\n        }\\n        for(int i=0 ; i<m ; i++){\\n            ans=max(ans,res_c[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570477,
                "title": "c-build-digraph-and-dfs-with-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& grid) {\\n        const int num_rows = grid.size(), num_cols = grid.front().size();\\n        const int num_items = num_rows * num_cols;\\n        \\n        struct Record {\\n            int val;\\n            int key;\\n            bool operator<(const Record &rhs) const {\\n                return val < rhs.val;\\n            }\\n        };\\n        \\n        std::vector<std::vector<int>> tbl_neighbors(num_items);\\n        {\\n            std::vector<int> inds(num_rows);\\n            std::iota(inds.begin(), inds.end(), 0);\\n            std::vector<Record> vals(num_rows);\\n            for (int col = 0; col < num_cols; ++col) {\\n                for (int row = 0; row < num_rows; ++row) {\\n                    vals[row] = Record {.val = grid[row][col], .key = row * num_cols + col};\\n                }\\n                std::sort(vals.begin(), vals.end());\\n                for (int i = 0; i < num_rows; ++i) {\\n                    int j = i;\\n                    for (; j < num_rows; ++j) {\\n                        if (vals[j].val > vals[i].val) {\\n                            break;\\n                        }\\n                    }\\n                    for (int t = j; t < num_rows; ++t) { \\n                        if (vals[t].val != vals[j].val) {\\n                            break;\\n                        }\\n                        tbl_neighbors[vals[i].key].push_back(vals[t].key);\\n                    }\\n                }\\n            }\\n        }\\n        {\\n            std::vector<int> inds(num_cols);\\n            std::iota(inds.begin(), inds.end(), 0);\\n            std::vector<Record> vals(num_cols);\\n            for (int row = 0; row < num_rows; ++row) {\\n                for (int col = 0; col < num_cols; ++col) {\\n                    vals[col] = Record {.val = grid[row][col], .key = row * num_cols + col};\\n                }\\n                std::sort(vals.begin(), vals.end());\\n                for (int i = 0; i < num_cols; ++i) {\\n                    int j = i;\\n                    for (; j < num_cols; ++j) {\\n                        if (vals[j].val > vals[i].val) {\\n                            break;\\n                        }\\n                    }\\n                    for (int t = j; t < num_cols; ++t) { \\n                        if (vals[t].val != vals[j].val) {\\n                            break;\\n                        }\\n                        tbl_neighbors[vals[i].key].push_back(vals[t].key);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        std::vector<std::optional<int>> cache(num_items);\\n        Context ctx {.tbl_neighbors = tbl_neighbors, .cache = cache};\\n        int max_visited = 0;\\n        for (int row = 0; row < num_rows; ++row) {\\n            for (int col = 0; col < num_cols; ++col) {\\n                const int key = row * num_cols + col;\\n                max_visited = std::max(find_dfs(ctx, key), max_visited);\\n            }\\n        }\\n        return max_visited;\\n    }\\nprivate:\\n    struct Context {\\n        const std::vector<std::vector<int>> &tbl_neighbors;\\n        std::vector<std::optional<int>> &cache;\\n    };\\n    \\n    int find_dfs(Context &ctx, const int key_init) {\\n        if (auto ref = ctx.cache[key_init]) {\\n            return *ref;\\n        }\\n        int max_visited = 1;\\n        for (const int key : ctx.tbl_neighbors[key_init]) {\\n            max_visited = std::max(1 + find_dfs(ctx, key), max_visited);\\n        }\\n        ctx.cache[key_init] = max_visited;\\n        return max_visited;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& grid) {\\n        const int num_rows = grid.size(), num_cols = grid.front().size();\\n        const int num_items = num_rows * num_cols;\\n        \\n        struct Record {\\n            int val;\\n            int key;\\n            bool operator<(const Record &rhs) const {\\n                return val < rhs.val;\\n            }\\n        };\\n        \\n        std::vector<std::vector<int>> tbl_neighbors(num_items);\\n        {\\n            std::vector<int> inds(num_rows);\\n            std::iota(inds.begin(), inds.end(), 0);\\n            std::vector<Record> vals(num_rows);\\n            for (int col = 0; col < num_cols; ++col) {\\n                for (int row = 0; row < num_rows; ++row) {\\n                    vals[row] = Record {.val = grid[row][col], .key = row * num_cols + col};\\n                }\\n                std::sort(vals.begin(), vals.end());\\n                for (int i = 0; i < num_rows; ++i) {\\n                    int j = i;\\n                    for (; j < num_rows; ++j) {\\n                        if (vals[j].val > vals[i].val) {\\n                            break;\\n                        }\\n                    }\\n                    for (int t = j; t < num_rows; ++t) { \\n                        if (vals[t].val != vals[j].val) {\\n                            break;\\n                        }\\n                        tbl_neighbors[vals[i].key].push_back(vals[t].key);\\n                    }\\n                }\\n            }\\n        }\\n        {\\n            std::vector<int> inds(num_cols);\\n            std::iota(inds.begin(), inds.end(), 0);\\n            std::vector<Record> vals(num_cols);\\n            for (int row = 0; row < num_rows; ++row) {\\n                for (int col = 0; col < num_cols; ++col) {\\n                    vals[col] = Record {.val = grid[row][col], .key = row * num_cols + col};\\n                }\\n                std::sort(vals.begin(), vals.end());\\n                for (int i = 0; i < num_cols; ++i) {\\n                    int j = i;\\n                    for (; j < num_cols; ++j) {\\n                        if (vals[j].val > vals[i].val) {\\n                            break;\\n                        }\\n                    }\\n                    for (int t = j; t < num_cols; ++t) { \\n                        if (vals[t].val != vals[j].val) {\\n                            break;\\n                        }\\n                        tbl_neighbors[vals[i].key].push_back(vals[t].key);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        std::vector<std::optional<int>> cache(num_items);\\n        Context ctx {.tbl_neighbors = tbl_neighbors, .cache = cache};\\n        int max_visited = 0;\\n        for (int row = 0; row < num_rows; ++row) {\\n            for (int col = 0; col < num_cols; ++col) {\\n                const int key = row * num_cols + col;\\n                max_visited = std::max(find_dfs(ctx, key), max_visited);\\n            }\\n        }\\n        return max_visited;\\n    }\\nprivate:\\n    struct Context {\\n        const std::vector<std::vector<int>> &tbl_neighbors;\\n        std::vector<std::optional<int>> &cache;\\n    };\\n    \\n    int find_dfs(Context &ctx, const int key_init) {\\n        if (auto ref = ctx.cache[key_init]) {\\n            return *ref;\\n        }\\n        int max_visited = 1;\\n        for (const int key : ctx.tbl_neighbors[key_init]) {\\n            max_visited = std::max(1 + find_dfs(ctx, key), max_visited);\\n        }\\n        ctx.cache[key_init] = max_visited;\\n        return max_visited;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570407,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\nThe intuition behind the solution is as follows:\\n\\nInitialize the Maxr and Maxc arrays with zeros, which will store the maximum number of increasing cells for each row and column, respectively.\\n\\nCreate a map m to store cells with their corresponding values. Each cell is represented by a pair of row and column indices. This map will help in processing the cells in ascending order of values.\\n\\nIterate over the matrix and populate the map m with the cells and their values.\\n\\nProcess the cells in the map m in ascending order of values. For each value, calculate the maximum number of increasing cells for each corresponding cell. This is done by taking the maximum value between the maximum number of increasing cells in the row (Maxr) and the maximum number of increasing cells in the column (Maxc) of the current cell, and adding 1 to it.\\n\\nUpdate the Maxr, Maxc, and ans variables based on the calculated maximum values for each cell. Update the maximum number of increasing cells for the row and column of each cell, and keep track of the maximum value found so far (ans).\\n\\nFinally, return the value of ans, which represents the maximum number of increasing cells in the matrix.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach uses dynamic programming to build up the maximum number of increasing cells for each cell in the matrix. By processing the cells in ascending order of values, the solution ensures that the maximum number of increasing cells for a cell is calculated based on the previously processed cells with lower values. This helps in finding the overall maximum number of increasing cells in the matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code can be analyzed as follows:\\nThe code initializes the Maxr and Maxc arrays with zeros, which takes O(n + m) time, where n is the number of rows and m is the number of columns.\\nPopulating the map m requires iterating over each cell in the matrix, which takes O(n * m) time.\\nProcessing the cells in the map m involves iterating over the cells in ascending order of values and calculating the maximum number of increasing cells for each cell. This step also takes O(n * m) time since each cell is processed once.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is primarily determined by the additional data structures used. Here are the main contributors to the space complexity:\\nThe Maxr array has a size of 100,005, which is proportional to the number of rows in the matrix. Therefore, its space complexity is O(n), where n is the number of rows.\\nThe Maxc array has a size of 100,005, which is proportional to the number of columns in the matrix. Therefore, its space complexity is O(m), where m is the number of columns.\\nThe m map stores cells with their corresponding values. The number of cells in the map can be at most the total number of cells in the matrix, which is n * m. Therefore, the space complexity of the map is O(n * m).\\nThe val vector is used to store the maximum values for each cell with the current value. Its size can be at most the number of cells with the current value, which is bounded by n * m. Therefore, the space complexity of the val vector is O(n * m).\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int Maxr[100005], Maxc[100005];\\n    \\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        // Initialize Maxr and Maxc arrays with 0\\n        fill(Maxr, Maxr + mat.size(), 0);\\n        fill(Maxc, Maxc + mat[0].size(), 0);\\n        \\n        // Create a map to store cells with their corresponding values\\n        map<int, vector<pair<int, int>>> m;\\n        \\n        // Iterate over the matrix and populate the map\\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                m[mat[i][j]].push_back(make_pair(i, j));\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        // Process the cells in the map in ascending order of values\\n        for (auto it : m) {\\n            vector<int> val;\\n            \\n            // Calculate the maximum value for each cell with the current value\\n            for (auto it2 : it.second) {\\n                val.push_back(max(Maxr[it2.first], Maxc[it2.second]) + 1);\\n            }\\n            \\n            // Update Maxr, Maxc, and ans with the maximum values\\n            for (int i = 0; i < val.size(); i++) {\\n                int x = it.second[i].first;\\n                int y = it.second[i].second;\\n                Maxr[x] = max(val[i], Maxr[x]);\\n                Maxc[y] = max(val[i], Maxc[y]);\\n                ans = max(ans, val[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int Maxr[100005], Maxc[100005];\\n    \\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        // Initialize Maxr and Maxc arrays with 0\\n        fill(Maxr, Maxr + mat.size(), 0);\\n        fill(Maxc, Maxc + mat[0].size(), 0);\\n        \\n        // Create a map to store cells with their corresponding values\\n        map<int, vector<pair<int, int>>> m;\\n        \\n        // Iterate over the matrix and populate the map\\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                m[mat[i][j]].push_back(make_pair(i, j));\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        // Process the cells in the map in ascending order of values\\n        for (auto it : m) {\\n            vector<int> val;\\n            \\n            // Calculate the maximum value for each cell with the current value\\n            for (auto it2 : it.second) {\\n                val.push_back(max(Maxr[it2.first], Maxc[it2.second]) + 1);\\n            }\\n            \\n            // Update Maxr, Maxc, and ans with the maximum values\\n            for (int i = 0; i < val.size(); i++) {\\n                int x = it.second[i].first;\\n                int y = it.second[i].second;\\n                Maxr[x] = max(val[i], Maxr[x]);\\n                Maxc[y] = max(val[i], Maxc[y]);\\n                ans = max(ans, val[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570377,
                "title": "tc-o-n-m-log-max-n-m-sorting-binary-search-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGo to just greater of the row or just greater of the col. because from there you can move to the element which is more greater. Also, if there are multiple just greater elements then traverse to all of them.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m*log(max(n,m)))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bs(vector<pair<int,int>> &vec,int ele){\\n        int l=0,r=vec.size()-1,mid,ans=-1;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            if(vec[mid].first>ele){ans=mid;r=mid-1;}\\n            else{l=mid+1;}\\n        }\\n        return ans;\\n    }\\n    int dp(vector<vector<int>> &vec,int in,int jn,vector<vector<int>>& mat,vector<vector<pair<int,int>>> &rows,vector<vector<pair<int,int>>> &cols){\\n        // cout<<in<<\" \"<<jn<<endl;\\n        if(vec[in][jn]!=-1){return vec[in][jn];}\\n        \\n        vector<pair<int,int>> trav;\\n        int r=bs(rows[in],mat[in][jn]),c=bs(cols[jn],mat[in][jn]);\\n        // cout<<r<<\" \"<<c<<endl;\\n        if(r!=-1){\\n            // cout<<\"rrrr\"<<\" \"<<in<<\" \"<<r<<endl;\\n            int cl=r;\\n            \\n            while(cl<rows[in].size()&&mat[in][rows[in][cl].second]==mat[in][rows[in][r].second]){trav.push_back({in,rows[in][cl].second});cl++;}\\n        }\\n        if(c!=-1){\\n            \\n            int rw=c;\\n            // cout<<\"cccc\"<<\" \"<<c<<\" \"<<jn<<endl;\\n            while(rw<cols[jn].size()&&mat[cols[jn][rw].second][jn]==mat[cols[jn][c].second][jn]){trav.push_back({cols[jn][rw].second,jn});rw++;}\\n        }\\n        int maxi=1;\\n        for(auto i:trav){\\n            maxi=max(maxi,dp(vec,i.first,i.second,mat,rows,cols)+1);\\n        }\\n        return vec[in][jn]=maxi;\\n    }\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        vector<vector<int>> vec(mat.size(),vector<int>(mat[0].size(),-1));\\n        vector<vector<pair<int,int>>> rows(mat.size()),cols(mat[0].size());\\n        int maxi=INT_MIN;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                rows[i].push_back({mat[i][j],j});\\n                cols[j].push_back({mat[i][j],i});\\n                // maxi=max(maxi,dp(vec,i,j,mat));\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            sort(rows[i].begin(),rows[i].end());\\n        }  \\n        for(int i=0;i<mat[0].size();i++)\\n        {\\n            sort(cols[i].begin(),cols[i].end());\\n        }        \\n         for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                // cout<<i<<\" yy\"<<j<<endl;\\n                maxi=max(maxi,dp(vec,i,j,mat,rows,cols));\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bs(vector<pair<int,int>> &vec,int ele){\\n        int l=0,r=vec.size()-1,mid,ans=-1;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            if(vec[mid].first>ele){ans=mid;r=mid-1;}\\n            else{l=mid+1;}\\n        }\\n        return ans;\\n    }\\n    int dp(vector<vector<int>> &vec,int in,int jn,vector<vector<int>>& mat,vector<vector<pair<int,int>>> &rows,vector<vector<pair<int,int>>> &cols){\\n        // cout<<in<<\" \"<<jn<<endl;\\n        if(vec[in][jn]!=-1){return vec[in][jn];}\\n        \\n        vector<pair<int,int>> trav;\\n        int r=bs(rows[in],mat[in][jn]),c=bs(cols[jn],mat[in][jn]);\\n        // cout<<r<<\" \"<<c<<endl;\\n        if(r!=-1){\\n            // cout<<\"rrrr\"<<\" \"<<in<<\" \"<<r<<endl;\\n            int cl=r;\\n            \\n            while(cl<rows[in].size()&&mat[in][rows[in][cl].second]==mat[in][rows[in][r].second]){trav.push_back({in,rows[in][cl].second});cl++;}\\n        }\\n        if(c!=-1){\\n            \\n            int rw=c;\\n            // cout<<\"cccc\"<<\" \"<<c<<\" \"<<jn<<endl;\\n            while(rw<cols[jn].size()&&mat[cols[jn][rw].second][jn]==mat[cols[jn][c].second][jn]){trav.push_back({cols[jn][rw].second,jn});rw++;}\\n        }\\n        int maxi=1;\\n        for(auto i:trav){\\n            maxi=max(maxi,dp(vec,i.first,i.second,mat,rows,cols)+1);\\n        }\\n        return vec[in][jn]=maxi;\\n    }\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        vector<vector<int>> vec(mat.size(),vector<int>(mat[0].size(),-1));\\n        vector<vector<pair<int,int>>> rows(mat.size()),cols(mat[0].size());\\n        int maxi=INT_MIN;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                rows[i].push_back({mat[i][j],j});\\n                cols[j].push_back({mat[i][j],i});\\n                // maxi=max(maxi,dp(vec,i,j,mat));\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            sort(rows[i].begin(),rows[i].end());\\n        }  \\n        for(int i=0;i<mat[0].size();i++)\\n        {\\n            sort(cols[i].begin(),cols[i].end());\\n        }        \\n         for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                // cout<<i<<\" yy\"<<j<<endl;\\n                maxi=max(maxi,dp(vec,i,j,mat,rows,cols));\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3570352,
                "title": "easiest-python-sol-fkrs",
                "content": "\\n# Code\\n```\\nfrom bisect import bisect_right as br\\n\\nclass Solution:\\n    def maxIncreasingCells(self, mat) -> int:\\n        n,m=len(mat),len(mat[0])\\n        dp=[[-1]*m for i in range(n) ]\\n        sr=defaultdict(list)\\n        for i in range(n):\\n            al=list(zip(mat[i],range(m)))\\n            al.sort()\\n            sr[i]=al\\n        sc=defaultdict(list)\\n        for c in range(m):\\n            l=[]\\n            for r in range(n):\\n                l.append((mat[r][c],r))\\n            l.sort()\\n            sc[c]=l\\n       \\n        def rec(i,j):\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            rr=br(sr[i],(mat[i][j],float(\"inf\")))\\n            ans=0\\n            # for ind in range(rr,len(sr[i])):\\n\\n            if rr<len(sr[i]):\\n                cr=rr\\n                while cr<len(sr[i]) and sr[i][cr][0]==sr[i][rr][0]:\\n                    ans=max(ans,1+rec(i,sr[i][cr][-1]))\\n                    cr+=1\\n            rr=br(sc[j],(mat[i][j],float(\"inf\")))\\n\\n            # for ind in range(rr,len(sc[i])):\\n            if rr<len(sc[j]):\\n                cr=rr\\n                while cr<len(sc[j]) and sc[j][cr][0]==sc[j][rr][0]:\\n                    ans=max(ans,1+rec(sc[j][cr][-1],j))\\n                    cr+=1\\n\\n            dp[i][j]=ans\\n            return ans\\n        tans=0\\n        for i in range(n):\\n            for j in  range(m):\\n                x=rec(i,j)+1\\n                tans=max(tans,x)\\n\\n            \\n        return tans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_right as br\\n\\nclass Solution:\\n    def maxIncreasingCells(self, mat) -> int:\\n        n,m=len(mat),len(mat[0])\\n        dp=[[-1]*m for i in range(n) ]\\n        sr=defaultdict(list)\\n        for i in range(n):\\n            al=list(zip(mat[i],range(m)))\\n            al.sort()\\n            sr[i]=al\\n        sc=defaultdict(list)\\n        for c in range(m):\\n            l=[]\\n            for r in range(n):\\n                l.append((mat[r][c],r))\\n            l.sort()\\n            sc[c]=l\\n       \\n        def rec(i,j):\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            rr=br(sr[i],(mat[i][j],float(\"inf\")))\\n            ans=0\\n            # for ind in range(rr,len(sr[i])):\\n\\n            if rr<len(sr[i]):\\n                cr=rr\\n                while cr<len(sr[i]) and sr[i][cr][0]==sr[i][rr][0]:\\n                    ans=max(ans,1+rec(i,sr[i][cr][-1]))\\n                    cr+=1\\n            rr=br(sc[j],(mat[i][j],float(\"inf\")))\\n\\n            # for ind in range(rr,len(sc[i])):\\n            if rr<len(sc[j]):\\n                cr=rr\\n                while cr<len(sc[j]) and sc[j][cr][0]==sc[j][rr][0]:\\n                    ans=max(ans,1+rec(sc[j][cr][-1],j))\\n                    cr+=1\\n\\n            dp[i][j]=ans\\n            return ans\\n        tans=0\\n        for i in range(n):\\n            for j in  range(m):\\n                x=rec(i,j)+1\\n                tans=max(tans,x)\\n\\n            \\n        return tans\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1908255,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1937573,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1920329,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1908227,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 2024694,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1917645,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1914922,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 2064734,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1917774,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1917376,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1908255,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1937573,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1920329,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1908227,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 2024694,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1917645,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1914922,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 2064734,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1917774,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            },
            {
                "id": 1917376,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "This is such a good question. Sometimes i feel problem setters must get extra coins."
                    },
                    {
                        "username": "tejasX",
                        "content": "Dope Question!! Hardest one i ever encountered."
                    },
                    {
                        "username": "palak-agg",
                        "content": "Hints for folks:\\n1) Try to look at the constraints if you are stuck where to begin from . The constrains  with n<=10^5 are usually solved in O(N) or O(NLOGN)\\n2)Try to find the max no of steps from each cell\\n3) For finding steps from each cell , you will either need to find the steps from larger/smaller elements. For that you will have to start visiting cells in increasing/decreasing order. Think of a way to do that !"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "ayo thought it was dfs"
                    },
                    {
                        "username": "simmimourya1",
                        "content": "If you iterate the matrix in unsorted order, you\\'ll might to do dfs."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "after reading ur comment also i\\'m still thinking its dfs :)"
                    },
                    {
                        "username": "noobcoderr",
                        "content": "bruh i thought it was fast fourier transform"
                    },
                    {
                        "username": "Tianwen",
                        "content": "This is a great q, however I would 99% fail during interview if not seen before."
                    },
                    {
                        "username": "jje-",
                        "content": "I just thought it can be solve by Topological Sort, but I failed on solving same values. How can I identify the problem can be solved by DP, not Topological Sort?"
                    },
                    {
                        "username": "jje-",
                        "content": "[@tifv](/tifv) You mean that connecting related values in the same line is expensive since we have to connect all values that can be reached, right? Thanks for your explanation. I\\'d try with DP when I fail next time."
                    },
                    {
                        "username": "tifv",
                        "content": "This is a good question! I think I had a similar failure in this problem.\n\nI guess it depends on how expensive (or complicated) it is to iterate though all edges of every vertex? Topological sort needs to do this somehow, and this is why it can become infeasible.\n\nIn this problem, if you navely define an edge as any pair of two cells in the same line (row or column) with different values, there can be some $O(m^2 n + m n^2)$ edges, which for the given constraints on $m$ and $n$ can become tens of millions. (And a more efficient definition may require a complicated way to enumerate the edges.)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "TLE for python but same logic worked for Cpp, is it due to implementation of map, SortedDict?"
                    },
                    {
                        "username": "mjmanav4",
                        "content": " `class Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n\\n\\n     if(mat.length == 0){\\n         return 0;\\n     }   \\n\\n\\n    int[][] dp = new int[mat.length][mat[0].length];\\n    for(int i=0;i<dp.length;i++){\\n        for(int j=0;j<dp[0].length;j++){\\n            dp[i][j]=-1;\\n        }\\n    }\\n     int maxLen = 1;\\n     for(int i=0;i<mat.length;i++){\\n         for(int j=0;j<mat[i].length;j++){\\n            int len = solve(i,j, mat[i][j],mat,dp);\\n            maxLen = Math.max(maxLen, len);\\n         }\\n     }\\n\\n     return maxLen;\\n\\n\\n    }\\n\\n    int solve(int row, int col, int lastValue, int[][] mat, int[][] dp){\\n\\n\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n\\n         int maxAns = 1;\\n\\n\\n\\n        // // traverse row\\n        // //  travel all possible col values except from the main\\n        for(int i=0;i<mat[0].length;i++){\\n\\n\\n            if(i==col){\\n                continue;\\n            }\\n\\n            if(mat[row][i] > lastValue){\\n                maxAns = Math.max(1+solve(row, i, mat[row][i], mat,dp), maxAns);\\n            }\\n\\n        }\\n\\n        // // travel all col \\n        // // col is conts\\n        for(int i=0;i<mat.length;i++){\\n            if(i==row){\\n                continue;\\n            }\\n            if(mat[i][col]>lastValue){\\n                maxAns =Math.max(1+solve(i,col, mat[i][col], mat,dp), maxAns);\\n            }\\n        }\\n\\n       \\n\\n\\n        dp[row][col]= maxAns;\\n        return maxAns;\\n\\n\\n\\n    }\\n}`\\n\\nThis Gives TLE"
                    },
                    {
                        "username": "nenthity",
                        "content": "for example 3, it says \"It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. \"\\nbut can\\'t we start from cell with value 1, and we can go 1->3->6->7?"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes, we can, and we will visit 4 cells in this way. It does not improve the answer."
                    },
                    {
                        "username": "anya509",
                        "content": "Is there a test case with duplicates (preferably short so that I could dry run)?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Longest Semi-Repetitive Substring",
        "question_content": "<p>You are given a <strong>0-indexed</strong> string <code>s</code> that consists of digits from <code>0</code> to <code>9</code>.</p>\n\n<p>A string <code>t</code> is called a <strong>semi-repetitive</strong> if there is at most one consecutive pair of the same digits inside <code>t</code>. For example, <code>0010</code>, <code>002020</code>, <code>0123</code>, <code>2002</code>, and <code>54944</code> are semi-repetitive while&nbsp;<code>00101022</code>, and <code>1101234883</code> are not.</p>\n\n<p>Return <em>the length of the longest semi-repetitive substring inside</em> <code>s</code>.</p>\n\n<p>A <b>substring</b> is a contiguous <strong>non-empty</strong> sequence of characters within a string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;52233&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest semi-repetitive substring is &quot;5223&quot;, which starts at i = 0 and ends at j = 3. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;5494&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> s is a semi-reptitive string, so the answer is 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1111111&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The longest semi-repetitive substring is &quot;11&quot;, which starts at i = 0 and ends at j = 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50</code></li>\n\t<li><code>&#39;0&#39; &lt;= s[i] &lt;= &#39;9&#39;</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3622348,
                "title": "two-pointer-very-simple-and-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution</b>\\n# Approach \\nNeed to consider two pointer i(backward) & j(forward). Also strore the index of the char where there is a duplicay of pair( in last variable).\\nSo when j encountered a pair then i will be shifted to \"last\" and \"last\" will be shifted to j. Same will contiue till end. Keep tracking the max diff between i & j.\\n\\ns = 02345118932236544\\n......^.............^.........^\\n......i.............last.....j\\n\\n# Code\\n```\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans = 1, i = 0, j = 1, last = 0;\\n        while(j < s.size()){\\n            if(s[j] == s[j-1]) {\\n                if(last) i = last; //This is needed only for the first duplicate found, as we don\\'t want to update the value of i for the first duplicate. As one duplicate is allowed.\\n                last = j;\\n            }\\n            ans = max(ans, j - i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n```\\n<b> Here is an article of my recent interview experience at Amazon, you may like :\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans = 1, i = 0, j = 1, last = 0;\\n        while(j < s.size()){\\n            if(s[j] == s[j-1]) {\\n                if(last) i = last; //This is needed only for the first duplicate found, as we don\\'t want to update the value of i for the first duplicate. As one duplicate is allowed.\\n                last = j;\\n            }\\n            ans = max(ans, j - i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3629621,
                "title": "java-c-python-sliding-window",
                "content": "# **Explanation**\\nClassic sliding window problem:\\nFind the longest sliding window,\\nwhere have at most one `s[i] == s[i + 1]` pair.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int i = 0, cur = 0, n = s.length();\\n        for (int j = 1; j < n; ++j) {\\n            cur += s.charAt(j) == s.charAt(j - 1) ? 1 : 0;\\n            if (cur > 1) {\\n                cur -= s.charAt(++i) == s.charAt(i - 1) ? 1 : 0;\\n            }\\n        }\\n        return n - i;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i = 0, cur = 0, n = s.length();\\n        for (int j = 1; j < n; ++j)\\n            if ((cur += s[j] == s[j - 1]) > 1)\\n                cur -= s[++i] == s[i - 1];\\n        return n - i;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        i = cur = 0\\n        for j in range(1, len(s)):\\n            cur += s[j] == s[j - 1]\\n            if cur > 1:\\n                i += 1\\n                cur -= s[i] == s[i - 1]\\n        return len(s) - i\\n```\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations and discussion.\\nGood luck and have fun.\\n\\n- 2555. [Maximize Win From Two Segments](https://leetcode.com/problems/maximize-win-from-two-segments/discuss/3141449/JavaC%2B%2BPython-DP-%2B-Sliding-Segment-O(n))\\n- 2537. [Count the Number of Good Subarrays](https://leetcode.com/problems/count-the-number-of-good-subarrays/discuss/3052559/C%2B%2BPython-Sliding-Window)\\n- 2401. [Longest Nice Subarray](https://leetcode.com/problems/longest-nice-subarray/discuss/2527496/Python-Sliding-Window)\\n- 2398. [Maximum Number of Robots Within Budget](https://leetcode.com/problems/maximum-number-of-robots-within-budget/discuss/2524838/Python-Sliding-Window-O(n))\\n- 1838. [Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175090/JavaC%2B%2BPython-Sliding-Window)\\n- 1493. [Longest Subarray of 1\\'s After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/708112/JavaC%2B%2BPython-Sliding-Window-at-most-one-0)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/JavaC%2B%2BPython-Sliding-Window)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int i = 0, cur = 0, n = s.length();\\n        for (int j = 1; j < n; ++j) {\\n            cur += s.charAt(j) == s.charAt(j - 1) ? 1 : 0;\\n            if (cur > 1) {\\n                cur -= s.charAt(++i) == s.charAt(i - 1) ? 1 : 0;\\n            }\\n        }\\n        return n - i;\\n    }\\n```\n```cpp\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i = 0, cur = 0, n = s.length();\\n        for (int j = 1; j < n; ++j)\\n            if ((cur += s[j] == s[j - 1]) > 1)\\n                cur -= s[++i] == s[i - 1];\\n        return n - i;\\n    }\\n```\n```py\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        i = cur = 0\\n        for j in range(1, len(s)):\\n            cur += s[j] == s[j - 1]\\n            if cur > 1:\\n                i += 1\\n                cur -= s[i] == s[i - 1]\\n        return len(s) - i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3622357,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem asks us to find the length of the longest semi-repetitive substring in a given string. A semi-repetitive substring is defined as a substring that contains at most one consecutive pair of the same digits.\\n\\n\\n# Approach\\nTo solve this problem, we can iterate through the string and keep track of the lengths of consecutive substrings with the same digits. We use a dynamic programming approach to store the lengths in the \\'tab\\' array.\\n\\nWe initialize the \\'tab\\' array with the length of the first digit in the string. Then, for each subsequent digit, we check if it is the same as the previous one. If it is, we increment the length of the current substring. Otherwise, we start a new substring by appending a length of 1 to the \\'tab\\' array.\\n\\nAfter populating the \\'tab\\' array, we iterate through it to find the maximum length of a semi-repetitive substring. To do this, we compare the sum of the current element and the previous element in the \\'tab\\' array. We keep track of the maximum length encountered so far in the \\'res\\' variable. Finally, we return the maximum length of a semi-repetitive substring, which is the maximum between \\'res\\' and the first element in the \\'tab\\' array.\\n# Complexity\\n- Time complexity:\\nTime complexity: The algorithm iterates through the input string once, resulting in a linear time complexity of O(n), where n is the length of the input string.\\n\\n\\n- Space complexity:\\nSpace complexity: The algorithm uses additional space to store the \\'tab\\' array, which has a length equal to the number of substrings with different digits in the input string. In the worst case, where all digits are unique, the \\'tab\\' array would have a length of n, resulting in a space complexity of O(n).\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        res=0\\n        tab=[1]\\n        for i in range(1,len(s)):\\n            if ( s[i]==s[i-1]):\\n                tab.append(1)\\n            else:\\n                tab[-1]=tab[-1]+1\\n        for j in range(1,len(tab)):\\n            res=max(res,tab[j]+tab[j-1])\\n        \\n        return max(res,tab[0])\\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        res=0\\n        tab=[1]\\n        for i in range(1,len(s)):\\n            if ( s[i]==s[i-1]):\\n                tab.append(1)\\n            else:\\n                tab[-1]=tab[-1]+1\\n        for j in range(1,len(tab)):\\n            res=max(res,tab[j]+tab[j-1])\\n        \\n        return max(res,tab[0])\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624142,
                "title": "c-easy-substring-easy-with-explanation",
                "content": "Since the constraints are low its better to use brute force solution. First we generate all the substring starting from index i and and for each substring we check if the string is valid.\\nWe create a simple isvalid function which counts the consecutive character in a string. If the count of consecutive character is 1 or less than 1 we see that the string is valid. We update the count if it is greater than the previous count of length of string.\\n\\n**Please Upvote If it helped!**\\n\\n````\\nclass Solution {\\npublic:\\n    bool isvalid(string s){\\n        int n= s.size();\\n        int cnt=0;\\n        for(int i=1; i<n; i++){\\n            if(s[i]==s[i-1]) cnt++;\\n            \\n        }\\n        if(cnt<=1) return true;\\n        return false;\\n    }\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n= s.size();\\n        int len=0;\\n        for(int i=0; i<n; i++){\\n            string ans=\"\";\\n            for(int j=i; j<n; j++){\\n                ans+=s[j];\\n                if(isvalid(ans)){\\n                    len= max(len,j-i+1);\\n                }\\n                \\n                \\n            }\\n        }\\n        return len;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool isvalid(string s){\\n        int n= s.size();\\n        int cnt=0;\\n        for(int i=1; i<n; i++){\\n            if(s[i]==s[i-1]) cnt++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3622273,
                "title": "clean-and-easy-solution-beginner-friendly",
                "content": "\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        sets = set()\\n        \\n        for i in range(len(s)-1):\\n            if s[i] == s[i+1]:\\n                sets.add( (i,i+1))\\n        pairs = 0\\n        for i ,j in sets:\\n            i -= 1\\n            j += 1\\n            counter = 0\\n            while i >= 0 and s[i] != s[i+1] :\\n                i -= 1\\n                counter += 1\\n                \\n            while j < len(s) and s[j] != s[j-1]:\\n                j += 1\\n                counter += 1\\n            pairs = max(pairs ,2+counter)\\n        return pairs if  pairs else len(s)\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        sets = set()\\n        \\n        for i in range(len(s)-1):\\n            if s[i] == s[i+1]:\\n                sets.add( (i,i+1))\\n        pairs = 0\\n        for i ,j in sets:\\n            i -= 1\\n            j += 1\\n            counter = 0\\n            while i >= 0 and s[i] != s[i+1] :\\n                i -= 1\\n                counter += 1\\n                \\n            while j < len(s) and s[j] != s[j-1]:\\n                j += 1\\n                counter += 1\\n            pairs = max(pairs ,2+counter)\\n        return pairs if  pairs else len(s)\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3847294,
                "title": "c-o-n-sliding-window",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int pairs_cnt=0;\\n        char pairs_val;\\n        \\n        int i=0, j=0, n=s.length();\\n        \\n        int ans=0;\\n        while(j<n){\\n            \\n            if(j>0 && s[j]==s[j-1]) pairs_cnt++;\\n            \\n            // keeping track of 1st pair\\n            if(pairs_cnt == 1 && s[j]==s[j-1]) pairs_val=s[j];\\n            \\n            if(pairs_cnt > 1){\\n                while(i<=j && pairs_cnt > 1){\\n                    if(s[i]==s[i+1] && s[i]==pairs_val) pairs_cnt--;\\n                    \\n                    i++;\\n                }\\n                \\n                pairs_val=s[j]; // updating latest pair value\\n            }\\n            \\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps:)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int pairs_cnt=0;\\n        char pairs_val;\\n        \\n        int i=0, j=0, n=s.length();\\n        \\n        int ans=0;\\n        while(j<n){\\n            \\n            if(j>0 && s[j]==s[j-1]) pairs_cnt++;\\n            \\n            // keeping track of 1st pair\\n            if(pairs_cnt == 1 && s[j]==s[j-1]) pairs_val=s[j];\\n            \\n            if(pairs_cnt > 1){\\n                while(i<=j && pairs_cnt > 1){\\n                    if(s[i]==s[i+1] && s[i]==pairs_val) pairs_cnt--;\\n                    \\n                    i++;\\n                }\\n                \\n                pairs_val=s[j]; // updating latest pair value\\n            }\\n            \\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641652,
                "title": "c-sliding-window-2-pointers-no-extra-space-easy-to-understand",
                "content": "# Intuition\\nThe constraints specify that the maximum length of string can only be 50, hence, we can do an - O(n ^ 2) approach by checking for all the possible substrings and check for exactly one pair of consecutive numbers(repeated twice) in each of them and keep track of the longest substring meeting with the conditions.\\n\\nThis solution will be accepted with no TLE.\\n\\nWe can do the same problem in - O(n) time by sliding window approach.\\n# Approach\\nFor sliding window approach, we will start by keeping the left pointer at index 0 and move the right pointer until we find a pair of two consecutive repeated numbers, and note its length.\\nWhen such pair is found, we still keep moving forward until next pair is found because 11 is valid and so is 11234 , the second one however has maximum length and that will be counted.\\nAs soon as the next such pair is found, we stop and start a new window - i.e move our left pointer forward, such that the number of pairs of repeated numbers in the window is only one.\\n\\nRepeat this till we reach the end of the string and keep finding the maximum window(substring) satisfying the condition.\\n\\n# Complexity\\n- Time complexity:\\nThe entire string of length N is traversed hence, the time Time Complexity is - O(N).\\n\\n- Space complexity:\\nSince, no extra space is used the Space Complexity is constant - O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int n = s.size();\\n\\n        int idx = 0, jdx = 0;\\n\\n        //this will keep track of the maximum length of the window\\n        int ans = INT_MIN;\\n\\n        //this will keep track of the number of pairs with same repeated\\n        //digits.\\n        int temp = 0; \\n\\n        while(jdx < n)\\n        {\\n            //check whether the previous number is same as the current number\\n            //if yes, we increase the value of temp\\n            if(jdx != 0)\\n            {\\n                if(s[jdx] == s[jdx - 1]) temp++;\\n            }\\n\\n            //as soon as one such pair is recorded we move forward till\\n            //another pair is found. and while moving forward with every\\n            //step we also note the maximum length of the window\\n            while(jdx < n and temp == 1)\\n            {\\n                ans = max(ans, jdx - idx + 1);\\n\\n                jdx++;\\n                if(s[jdx] == s[jdx - 1]) temp++;\\n            }\\n            \\n            //now since there are two pairs in the substring we need\\n            //to remove one, we will do this by increasing the left\\n            //pointer, and at each step we check if that number is \\n            //equal to its forward number(they form a pair), if yes,\\n            //we decrease the value of temp and keep moving forward\\n            while(idx < jdx and temp > 1)\\n            {\\n                if(s[idx] == s[idx + 1]) temp--;\\n\\n                idx++;\\n            }\\n            \\n            //moving the right pointer forward\\n            jdx++;\\n        }    \\n\\n        //if ans still has its intiialized value it means the pair was \\n        //found at the end or there is no consecutive repeated same digits\\n        //so we return the length of the string\\n        if(ans == INT_MIN) return n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int n = s.size();\\n\\n        int idx = 0, jdx = 0;\\n\\n        //this will keep track of the maximum length of the window\\n        int ans = INT_MIN;\\n\\n        //this will keep track of the number of pairs with same repeated\\n        //digits.\\n        int temp = 0; \\n\\n        while(jdx < n)\\n        {\\n            //check whether the previous number is same as the current number\\n            //if yes, we increase the value of temp\\n            if(jdx != 0)\\n            {\\n                if(s[jdx] == s[jdx - 1]) temp++;\\n            }\\n\\n            //as soon as one such pair is recorded we move forward till\\n            //another pair is found. and while moving forward with every\\n            //step we also note the maximum length of the window\\n            while(jdx < n and temp == 1)\\n            {\\n                ans = max(ans, jdx - idx + 1);\\n\\n                jdx++;\\n                if(s[jdx] == s[jdx - 1]) temp++;\\n            }\\n            \\n            //now since there are two pairs in the substring we need\\n            //to remove one, we will do this by increasing the left\\n            //pointer, and at each step we check if that number is \\n            //equal to its forward number(they form a pair), if yes,\\n            //we decrease the value of temp and keep moving forward\\n            while(idx < jdx and temp > 1)\\n            {\\n                if(s[idx] == s[idx + 1]) temp--;\\n\\n                idx++;\\n            }\\n            \\n            //moving the right pointer forward\\n            jdx++;\\n        }    \\n\\n        //if ans still has its intiialized value it means the pair was \\n        //found at the end or there is no consecutive repeated same digits\\n        //so we return the length of the string\\n        if(ans == INT_MIN) return n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623588,
                "title": "python-3-3-lines-w-explanation-and-example-t-m-95-12",
                "content": "Here\\'s the plan:\\n- We repeat the first and last characters of`s`.\\n- We accumulate the first indices of repeated characters in`s`into`arr`.\\n- We compute the differences of alternating elements of`arr`; the maximum difference is the answer.\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n\\n                                                                #    s = \\'52233\\'\\n        s = s[0] + s + s[-1]                                    #    s = \\'5522333\\'\\n\\n        arr = [i for i in range(len(s)-1) if s[i] == s[i+1]]    #  ans = [0, 2, 4, 5]\\n        \\n        return max ((y - x for x,y in zip(arr, arr[2:])),       # return max(4-0, 5-2) = 4\\n                                         default = len(s)-2)\\n```\\n[https://leetcode.com/problems/find-the-longest-semi-repetitive-substring/submissions/968435054/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*) in which *N* ~`len(s)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n\\n                                                                #    s = \\'52233\\'\\n        s = s[0] + s + s[-1]                                    #    s = \\'5522333\\'\\n\\n        arr = [i for i in range(len(s)-1) if s[i] == s[i+1]]    #  ans = [0, 2, 4, 5]\\n        \\n        return max ((y - x for x,y in zip(arr, arr[2:])),       # return max(4-0, 5-2) = 4\\n                                         default = len(s)-2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622784,
                "title": "stack-easy-java-with-explanation",
                "content": "\\n       class Solution {\\n          public int longestSemiRepetitiveSubstring(String s) {\\n          int ans = 0, c = 0;\\n          Stack<Character> st = new Stack<>();\\n          for(int i = 0; i < s.length(); i++) {\\n            if(st.size() == 0) {\\n                st.push(s.charAt(i));\\n            }\\n            else{\\n                if(st.peek() == s.charAt(i)) {   // When Semi-R Occurence Found\\n                    if(c == 1) {      // count 1 means already one occurence is exist in stack\\n                         ans = Math.max(ans,  st.size());\\n                         int remove = st.remove(0);\\n                         while(st.get(0) != remove) {   // So remove the elements from left side to remove previous occurence and put the current index character which makes one occurence again\\n                              remove = st.remove(0);     }\\n                             st.push(s.charAt(i));\\n                    }\\n                    else if(c == 0) {  // when first occurence encountered which makes count as 1\\n                       c = 1;\\n                       st.push(s.charAt(i));\\n                       ans = Math.max(ans, st.size());\\n                    }\\n                }\\n                else{    // until no occurence found take max length\\n                    st.push(s.charAt(i));\\n                    ans = Math.max(ans, st.size());     }    }\\n        }\\n        ans = Math.max(ans,  st.size());\\n        return ans;\\n     }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n          public int longestSemiRepetitiveSubstring(String s) {\\n          int ans = 0, c = 0;\\n          Stack<Character> st = new Stack<>();\\n          for(int i = 0; i < s.length(); i++) {\\n            if(st.size() == 0) {\\n                st.push(s.charAt(i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3622770,
                "title": "simple-easy-to-understand-nieve-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to check for all possible continues substrings which follow the pattern and Constraints is n=50 so answer can be accepted by brute force using 2 loop.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwhen ever we visit a element we update the curr_max which tell us the largest string possible which follow the rule and we check this for all the index of the string and when ever a larger curr_max is encounter we update our answer.\\n\\nFor check all the possible value we iterate starting from the first index and then move to the last using 2 loops\\n\\nThe special case is that we are only allowed a same pair once if we see again then we have to end our search and move ahead so we have to see if we have no more than 1 same consecutive same pairs.\\n\\nTo do so we first make a logic for no same pair is allowed i.e the element adjacent to the element cannot be same now to make the exception once that is to allow the only one time we use a flag which will be true intially but as the exception has occur it is made false so that no such pair can come again.\\n\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int flag=true;  //for all starting cases we need the flag to be true\\n            int curr_max=0; \\n            for(int j=i;j<n;j++){\\n                if(j!=i and s[j]==s[j-1]){  //here j!=i because we have an problem in the start as j-1 will go beyond are string which we want.\\n                    if(flag){   //example i=0 hence j=0 so j-1 is -1 which is a false index hence to skip the first comparsion we added this\\n                        flag=false;\\n                    }\\n                    else{\\n                        break;  when ever we see 2 pairs with same value we break the loop as no need to see ahead\\n                    }\\n                }\\n               curr_max++;\\n            }\\n            ans=max(ans,curr_max);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**HOPE YOU WERE ABLE TO UNDERSTAND IT FEEL FREE TO ASK ANYTHING\\nIF YOU LIKED IT PLEASE DO UPVOTE :)**",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int flag=true;  //for all starting cases we need the flag to be true\\n            int curr_max=0; \\n            for(int j=i;j<n;j++){\\n                if(j!=i and s[j]==s[j-1]){  //here j!=i because we have an problem in the start as j-1 will go beyond are string which we want.\\n                    if(flag){   //example i=0 hence j=0 so j-1 is -1 which is a false index hence to skip the first comparsion we added this\\n                        flag=false;\\n                    }\\n                    else{\\n                        break;  when ever we see 2 pairs with same value we break the loop as no need to see ahead\\n                    }\\n                }\\n               curr_max++;\\n            }\\n            ans=max(ans,curr_max);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622317,
                "title": "slidingwindow-easy-implementation-java",
                "content": "\\n```\\nclass Solution \\n{\\n    public int longestSemiRepetitiveSubstring(String s)\\n    {\\n       \\n        int n = s.length();\\n        int i = 0,j=0;\\n        int len =0;\\n        while( j < n )\\n        {\\n            if(check(s.substring(i,j+1)) == true)          // window is valid\\n            {\\n               len = Math.max(len,j-i+1);\\n                j++;\\n            }\\n            else         // if invalid \\n            {\\n                i++;\\n            }\\n        }\\n        return len;\\n    }\\n    // Function to check weather the string is semi-repetitive or not\\n    public boolean check ( String str)\\n    {\\n        int cnt =0;\\n        for(int i = 0; i < str.length()-1;i++)\\n        {\\n            if(str.charAt(i) == str.charAt(i+1)) cnt++;\\n        }\\n        if(cnt <= 1) return true;\\n        else return false;\\n        \\n    }\\n}\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int longestSemiRepetitiveSubstring(String s)\\n    {\\n       \\n        int n = s.length();\\n        int i = 0,j=0;\\n        int len =0;\\n        while( j < n )\\n        {\\n            if(check(s.substring(i,j+1)) == true)          // window is valid\\n            {\\n               len = Math.max(len,j-i+1);\\n                j++;\\n            }\\n            else         // if invalid \\n            {\\n                i++;\\n            }\\n        }\\n        return len;\\n    }\\n    // Function to check weather the string is semi-repetitive or not\\n    public boolean check ( String str)\\n    {\\n        int cnt =0;\\n        for(int i = 0; i < str.length()-1;i++)\\n        {\\n            if(str.charAt(i) == str.charAt(i+1)) cnt++;\\n        }\\n        if(cnt <= 1) return true;\\n        else return false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623631,
                "title": "two-pointers-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i = 0, j = 0, n = s.length(),ans=0,x=0;\\n        vector<int> v(10,0);\\n        while(i<n){\\n            v[s[i]-\\'0\\']++;\\n            if(i && s[i]==s[i-1]){\\n                x++;\\n            }\\n            while(x>1){\\n                x -= (s[j]==s[j+1]);\\n                v[s[j]-\\'0\\']--;\\n                j++;\\n            }\\n            ans = max(ans,i-j+1);\\n            i++;\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i = 0, j = 0, n = s.length(),ans=0,x=0;\\n        vector<int> v(10,0);\\n        while(i<n){\\n            v[s[i]-\\'0\\']++;\\n            if(i && s[i]==s[i-1]){\\n                x++;\\n            }\\n            while(x>1){\\n                x -= (s[j]==s[j+1]);\\n                v[s[j]-\\'0\\']--;\\n                j++;\\n            }\\n            ans = max(ans,i-j+1);\\n            i++;\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622843,
                "title": "java-sliding-window-approach-easy-to-understand",
                "content": "### Intuition:\\nThe code aims to find the length of the longest semi-repetitive substring in a given string `s`. A semi-repetitive substring is a substring that contains at most one character that repeats consecutively more than once. The code iterates through the string and keeps track of the longest semi-repetitive substring found so far.\\n\\n### Approach:\\n1. Initialize variables `l` and `r` to 0. `l` represents the left pointer, and `r` represents the right pointer.\\n2. Initialize `count` and `ans` to 0. `count` keeps track of the number of consecutive repeating characters encountered so far, and `ans` stores the length of the longest semi-repetitive substring.\\n3. Start a loop that continues until `r` reaches the second last index of the string or until `l` becomes greater than `r`.\\n4. Increment `r` by 1, indicating the extension of the current substring.\\n5. Check if the character at index `r` is the same as the character at index `r-1`. If they are equal, increment `count` by 1, indicating the presence of a consecutive repeating character.\\n6. Enter a nested loop while `count` is greater than or equal to 2. This loop helps in maintaining the condition of at most one character repeating consecutively more than once.\\n7. Increment `l` by 1, moving the left pointer forward and reducing the length of the substring.\\n8. Check if the character at index `l` is the same as the character at index `l-1`. If they are equal, decrement `count` by 1, as the repeated character is no longer part of the substring.\\n9. Calculate the length of the current substring by subtracting `l` from `r` and adding 1. Update `ans` with the maximum length found so far using the `Math.max()` function.\\n10. Return the value of `ans` as the length of the longest semi-repetitive substring.\\n\\n### Complexity:\\n- The time complexity of this code is O(n), where n is the length of the input string `s`. The code iterates through the string once using the `while` loop.\\n- The space complexity is O(1) since the code only uses a constant amount of additional space to store the variables `l`, `r`, `count`, and `ans`. No extra data structures are used.\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int l=0,r=0;\\n        int count=0;\\n        int ans=1;\\n        while(r<s.length()-1 && l<=r){\\n            r++;\\n            if(s.charAt(r)==s.charAt(r-1)) count++;\\n            while(count>=2){\\n                l++;\\n                if(s.charAt(l)==s.charAt(l-1)) count--;\\n            }\\n            ans=Math.max(ans,r-l+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int l=0,r=0;\\n        int count=0;\\n        int ans=1;\\n        while(r<s.length()-1 && l<=r){\\n            r++;\\n            if(s.charAt(r)==s.charAt(r-1)) count++;\\n            while(count>=2){\\n                l++;\\n                if(s.charAt(l)==s.charAt(l-1)) count--;\\n            }\\n            ans=Math.max(ans,r-l+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622703,
                "title": "java-sliding-window-concise",
                "content": "``` java []\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int i=0, j=0, max=0, c=0;\\n        while(j<s.length()-1){\\n            if(s.charAt(j)==s.charAt(j+1)){\\n                c++;\\n            }\\n            while(c>=2){\\n                max=Math.max(max,j-i+1);\\n                if(s.charAt(i)==s.charAt(i+1)){\\n                    c--;   \\n                } \\n                i++;\\n            }\\n            j++;\\n        }\\n        return Math.max(max,j-i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int i=0, j=0, max=0, c=0;\\n        while(j<s.length()-1){\\n            if(s.charAt(j)==s.charAt(j+1)){\\n                c++;\\n            }\\n            while(c>=2){\\n                max=Math.max(max,j-i+1);\\n                if(s.charAt(i)==s.charAt(i+1)){\\n                    c--;   \\n                } \\n                i++;\\n            }\\n            j++;\\n        }\\n        return Math.max(max,j-i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622304,
                "title": "easy-two-pointer-with-explanation",
                "content": "We scan through the input string s, keeping track of the count of consecutive repetitions (count) and the left pointer (left). We eliminate extra repetitions using the inside while loop and update the maximum length of the semi-repetitive substring (maxLen) whenever a longer semi-repetitive substring is found. Finally, we return the final value of maxLength, which represents the length of the longest semi-repetitive substring in the input string s.\\n\\n# Complexity\\n- Time complexity:\\nO(N);\\n\\n- Space complexity:\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int maxLen = 1;  // Stores the length of the longest semi-repetitive substring\\n        int count = 0;  // Counts the number of consecutive repeated digits\\n        int left = 0;  // Points to the left end of the current substring\\n\\n        for (int right = 0; right < s.length(); right++) {\\n            // Check if the current digit is the same as the previous one\\n            if (right > 0 && s.charAt(right - 1) == s.charAt(right)) {\\n                count++;\\n            }\\n\\n            while (count > 1) {\\n                // Check if the digit at the left pointer is the same as the next one\\n                if (right > left && s.charAt(left) == s.charAt(left + 1)) {\\n                    count--;\\n                }\\n                left++;\\n            }\\n\\n            // Update the maximum length of the semi-repetitive substring\\n            maxLen = Math.max(maxLen, right - left + 1);\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int maxLen = 1;  // Stores the length of the longest semi-repetitive substring\\n        int count = 0;  // Counts the number of consecutive repeated digits\\n        int left = 0;  // Points to the left end of the current substring\\n\\n        for (int right = 0; right < s.length(); right++) {\\n            // Check if the current digit is the same as the previous one\\n            if (right > 0 && s.charAt(right - 1) == s.charAt(right)) {\\n                count++;\\n            }\\n\\n            while (count > 1) {\\n                // Check if the digit at the left pointer is the same as the next one\\n                if (right > left && s.charAt(left) == s.charAt(left + 1)) {\\n                    count--;\\n                }\\n                left++;\\n            }\\n\\n            // Update the maximum length of the semi-repetitive substring\\n            maxLen = Math.max(maxLen, right - left + 1);\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623050,
                "title": "java-beats-100-simple-explaination",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep track of no of pairs found, if pairs are 0, then keep increasing local maximum, until find one pair.\\nStore the index of the pair found.\\nwhen found second pair, reset the local max by using the last pair found and start again.\\nstore max of local max and maxlen every time we find two pairs.\\nreturn max of local max and maxlen.\\n# Complexity\\n- Time complexity: O{n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: only 4 variables to keep track.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int i = 1, len = s.length(), maxLen = 1, localMax = 1, pairs = 0, lastPairIndex = -1;\\n        while(i < len) {\\n            if(pairs == 0) {\\n                if(s.charAt(i) == s.charAt(i - 1)){\\n                    pairs = 1;\\n                    lastPairIndex = i;\\n                }\\n                localMax++;\\n            }\\n            else {\\n                if(s.charAt(i) == s.charAt(i - 1)) {\\n                    pairs = 1;\\n                    maxLen = Math.max(maxLen, localMax);\\n                    localMax = i - lastPairIndex + 1;\\n                    lastPairIndex = i;\\n                }\\n                else localMax++;\\n            }\\n            i++;\\n        }\\n        return Math.max(maxLen, localMax);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int i = 1, len = s.length(), maxLen = 1, localMax = 1, pairs = 0, lastPairIndex = -1;\\n        while(i < len) {\\n            if(pairs == 0) {\\n                if(s.charAt(i) == s.charAt(i - 1)){\\n                    pairs = 1;\\n                    lastPairIndex = i;\\n                }\\n                localMax++;\\n            }\\n            else {\\n                if(s.charAt(i) == s.charAt(i - 1)) {\\n                    pairs = 1;\\n                    maxLen = Math.max(maxLen, localMax);\\n                    localMax = i - lastPairIndex + 1;\\n                    lastPairIndex = i;\\n                }\\n                else localMax++;\\n            }\\n            i++;\\n        }\\n        return Math.max(maxLen, localMax);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622867,
                "title": "brute-force",
                "content": "**Approach**\\nSince the constrains are low, we can generate all the substrings and check each substring if it is semi repetetive and maximize our answer.\\n```\\nclass Solution\\n{\\n    public:\\n        int longestSemiRepetitiveSubstring(string s)\\n        {\\n            int n = s.size(), ans = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = i; j < n; j++)\\n                {\\n                    string t = s.substr(i, j - i + 1);\\n                    int cnt = 0;\\n\\n                    for (int k = 1; k < t.size(); k++)\\n                    {\\n                        if (t[k] == t[k - 1])\\n                        {\\n                            cnt++;\\n                        }\\n                    }\\n                    if (cnt <= 1)\\n                        ans = max(ans, j - i + 1);\\n                }\\n            }\\n\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int longestSemiRepetitiveSubstring(string s)\\n        {\\n            int n = s.size(), ans = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = i; j < n; j++)\\n                {\\n                    string t = s.substr(i, j - i + 1);\\n                    int cnt = 0;\\n\\n                    for (int k = 1; k < t.size(); k++)\\n                    {\\n                        if (t[k] == t[k - 1])\\n                        {\\n                            cnt++;\\n                        }\\n                    }\\n                    if (cnt <= 1)\\n                        ans = max(ans, j - i + 1);\\n                }\\n            }\\n\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622565,
                "title": "java-sliding-window-approach-w-detailed-explanation",
                "content": "##### Intuition:\\nThe intuition is primarily based on the idea of maintaining a \"sliding window\" on the string and constantly updating this window to ensure that it contains at most one consecutive pair of the same digits.\\n\\n##### Algorithm:\\nMy solution follows the Sliding Window methodology. Below are the main steps:\\n\\n* Initialization: Initialize three variables: `left` to mark the start of the window, `countPair` to count the number of consecutive character pairs, and `res` to store the length of the longest semi-repetitive substring.\\n\\n* Traverse the string from left to right. The variable `right` represents the end of the window:\\n    - Check for consecutive pairs: Inside the loop, check if the current character `s[right]` is the same as the previous one `s[right - 1]`. If they are, increment `countPair`.\\n        - If `countPair` is more than `1`, it means the substring is not semi-repetitive, so we need to move the left boundary of the window. Increment left and if the character at the new left position is the same as its previous character, decrement countPair.\\n* Update the result: Calculate the current length of the substring `right - left + 1` and update res if it\\'s bigger than the current res.\\n\\n##### Complexity Analysis:\\n* Time complexity: `O(n)`, where `n` is the length of the string, since it involves a single pass through the string. \\n* Space complexity: `O(1)`, as it only uses a fixed amount of space to store the variables.\\n\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int left = 0, countPair = 0, res = 1;\\n        for (int right = 0; right < s.length(); right++) {\\n            if (right > 0 && s.charAt(right) == s.charAt(right - 1))\\n                countPair++;\\n            while (countPair > 1) {\\n                left++;\\n                if (s.charAt(left) == s.charAt(left - 1))\\n                    countPair--;\\n            }\\n            res = Math.max(res, right - left + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int left = 0, countPair = 0, res = 1;\\n        for (int right = 0; right < s.length(); right++) {\\n            if (right > 0 && s.charAt(right) == s.charAt(right - 1))\\n                countPair++;\\n            while (countPair > 1) {\\n                left++;\\n                if (s.charAt(left) == s.charAt(left - 1))\\n                    countPair--;\\n            }\\n            res = Math.max(res, right - left + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622404,
                "title": "c-explained-two-pointers-easy-solution",
                "content": "# Approach\\n- Iterate through each character in the input string s.\\n- For each character, it checks for the longest semi-repetitive substring starting from that character by counting the number of consecutive pairs of the same digits.\\n- The maximum length found so far is updated in the variable ans, and finally returned as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n    int ans = 1;\\n    for (int i = 0; i < s.size(); i++) {\\n        int length = 1; // Current substring length\\n        int j = i; // Starting index of the current substring\\n        int count = 0; // Count of consecutive pairs of the same digits\\n        \\n        // Iterate through the string until a second consecutive pair is found or the end of the string is reached\\n        while (j + 1 < s.size() && count <= 1) {\\n            if (s[j] == s[j + 1]) {\\n                count++;\\n            }\\n            j++;\\n            \\n            // If two consecutive pairs are found, decrement \\'j\\' to ignore the second pair\\n            if (count == 2) {\\n                j--;\\n            }\\n        }\\n        \\n        ans = max(ans, j - i + 1); // Update the maximum length if the current substring is longer\\n    }\\n    \\n    return ans;\\n}\\n\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n    int ans = 1;\\n    for (int i = 0; i < s.size(); i++) {\\n        int length = 1; // Current substring length\\n        int j = i; // Starting index of the current substring\\n        int count = 0; // Count of consecutive pairs of the same digits\\n        \\n        // Iterate through the string until a second consecutive pair is found or the end of the string is reached\\n        while (j + 1 < s.size() && count <= 1) {\\n            if (s[j] == s[j + 1]) {\\n                count++;\\n            }\\n            j++;\\n            \\n            // If two consecutive pairs are found, decrement \\'j\\' to ignore the second pair\\n            if (count == 2) {\\n                j--;\\n            }\\n        }\\n        \\n        ans = max(ans, j - i + 1); // Update the maximum length if the current substring is longer\\n    }\\n    \\n    return ans;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622343,
                "title": "simple-o-n-3-approach-by-generating-all-substrings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int len = 1; len<=n-i; len++)\\n            {\\n                string str = s.substr(i, len);\\n                int cnt = 0;\\n                bool check = true;\\n                \\n                for(int k = 0; k<str.size()-1; k++)\\n                {\\n                    if(str[k]==str[k+1])\\n                        cnt++;\\n                }\\n                \\n                \\n                int size = str.size();\\n                if(cnt<=1 && check)\\n                    ans = max(ans, size);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int len = 1; len<=n-i; len++)\\n            {\\n                string str = s.substr(i, len);\\n                int cnt = 0;\\n                bool check = true;\\n                \\n                for(int k = 0; k<str.size()-1; k++)\\n                {\\n                    if(str[k]==str[k+1])\\n                        cnt++;\\n                }\\n                \\n                \\n                int size = str.size();\\n                if(cnt<=1 && check)\\n                    ans = max(ans, size);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016984,
                "title": "sliding-window-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncount the number of consecutive pairs that have the same element for each window and return the maximum window that has count<=1.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size(),count = 0;\\n        int i = 0,j = 0,ans = 0;\\n\\n        while(j<n)\\n        {\\n            if(j>0 && s[j]==s[j-1]) count++; \\n            while(count>1 && i<j)\\n            {\\n                if(i<n-1 && s[i]==s[i+1]) count--;  \\n                i++;\\n            }\\n            ans = max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size(),count = 0;\\n        int i = 0,j = 0,ans = 0;\\n\\n        while(j<n)\\n        {\\n            if(j>0 && s[j]==s[j-1]) count++; \\n            while(count>1 && i<j)\\n            {\\n                if(i<n-1 && s[i]==s[i+1]) count--;  \\n                i++;\\n            }\\n            ans = max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949457,
                "title": "easiest-intuitive-cleanest-code-tc-o-n-sc-o-1",
                "content": "# Intuition : \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor any i move j towards the farthest right which can satisfy the given condition.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- start i form 0 , while we move i to next iteration make sure to decrease cnt if i contributed to cnt initially.\\n- Start j from 0 and move it until the cnt of consecutive equal characters become 2.\\n- maximise answer if j-i > ans.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n\\n        //================ TWO POINTERS ===================\\n        int ans = 1;\\n        int j = 0;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(i > 0 && s.at(i) == s.at(i-1))\\n                cnt--;\\n            \\n            while(j < s.size() && cnt < 2)\\n            {\\n                if(j < s.size()-1 && s.at(j) == s.at(j+1))\\n                    cnt++;\\n                \\n                j++;\\n            }\\n            \\n            ans = max(j-i, ans);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n\\n        //================ TWO POINTERS ===================\\n        int ans = 1;\\n        int j = 0;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(i > 0 && s.at(i) == s.at(i-1))\\n                cnt--;\\n            \\n            while(j < s.size() && cnt < 2)\\n            {\\n                if(j < s.size()-1 && s.at(j) == s.at(j+1))\\n                    cnt++;\\n                \\n                j++;\\n            }\\n            \\n            ans = max(j-i, ans);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775109,
                "title": "c-killer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int i=0,j,ans=0,n=s.length();\\n        int sum=0;\\n        for( j=1;j<n;j++)\\n        {\\n            if((sum += s[j] == s[j - 1]) > 1)\\n            sum-=s[++i]==s[i-1];\\n        }\\n        return j-i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int i=0,j,ans=0,n=s.length();\\n        int sum=0;\\n        for( j=1;j<n;j++)\\n        {\\n            if((sum += s[j] == s[j - 1]) > 1)\\n            sum-=s[++i]==s[i-1];\\n        }\\n        return j-i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717229,
                "title": "python3-straightforward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe method used is simple and direct. \\n\\nWe go through the string and keep track of the index of the last repeated symbol encountered. \\nThis helps us determine the maximum distance between repeated pairs. \\nIf we come across another repeated pair while there is already one present, we split our substring and begin calculating the distance from the last repeated symbol.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        starting_point = 0\\n        last_repetetive = 0\\n        current_max = 0\\n        previous_symb = s[0]\\n        for i, current_symb in enumerate(s):\\n            if previous_symb == current_symb:\\n                if last_repetetive:\\n                    starting_point = last_repetetive\\n                last_repetetive = i\\n            current_max = max(i - starting_point + 1, current_max)\\n            previous_symb = current_symb\\n        return current_max\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        starting_point = 0\\n        last_repetetive = 0\\n        current_max = 0\\n        previous_symb = s[0]\\n        for i, current_symb in enumerate(s):\\n            if previous_symb == current_symb:\\n                if last_repetetive:\\n                    starting_point = last_repetetive\\n                last_repetetive = i\\n            current_max = max(i - starting_point + 1, current_max)\\n            previous_symb = current_symb\\n        return current_max\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685084,
                "title": "beginner-friendly-c-solution-with-approach",
                "content": "# Intuition\\nWe can simply apply two pointers.\\n# Approach\\nWe can use flag that will tell us when we encounter consecutive elements for the second time and a variable that will help us to keep track of left pointer which we can update when we reach the endpoint.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        bool condition =  true; \\n        if(s.length()==1) return 1;\\n        unordered_map<char,int> mp; \\n        mp[s[0]]++;\\n        int left=0, right=1, res=INT_MIN, len=1, temp=-1;\\n\\n        while(right<s.size()){\\n            if(s[right]==s[right-1] && condition){\\n                temp=right;\\n                len++;\\n                right++;\\n                res=max(res,len);\\n                condition=!condition;\\n            }\\n            else if(s[right]==s[right-1] && !condition){\\n                len=1;\\n                left=temp;\\n                right=temp+1;\\n                condition=true;\\n            }\\n            else{\\n                len++;\\n                res=max(res,len);\\n                right++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        bool condition =  true; \\n        if(s.length()==1) return 1;\\n        unordered_map<char,int> mp; \\n        mp[s[0]]++;\\n        int left=0, right=1, res=INT_MIN, len=1, temp=-1;\\n\\n        while(right<s.size()){\\n            if(s[right]==s[right-1] && condition){\\n                temp=right;\\n                len++;\\n                right++;\\n                res=max(res,len);\\n                condition=!condition;\\n            }\\n            else if(s[right]==s[right-1] && !condition){\\n                len=1;\\n                left=temp;\\n                right=temp+1;\\n                condition=true;\\n            }\\n            else{\\n                len++;\\n                res=max(res,len);\\n                right++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651603,
                "title": "highly-readable-code-comments-0-n-0-1-one-time-watch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- maximize length by using condition ( one cons. pair acceptable)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- taking care of cons. pair in my selected length and traverse string , maximize by selected length \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n          int n = s.size(); \\n          if( n==1) { return 1; }\\n          int start = 0 , end =1;\\n          int  prev =0 ,ans = 0 ;\\n\\n    while( end<n){\\n         if(  s[end]== s[end-1]){  \\n             start = prev ; \\n               prev = end ; \\n         }\\n          ans = max( ans , end-start+1);\\n          end++;\\n    }\\n    return ans ;\\n    }\\n//---------------------------------Remember----------------------//\\n/*\\n-> don\\'t try to use s[end] ==s[end+1] because in that you will take a fail for some testcase\\nlike \\n4 4 1 1 7 9 4 \\nif you use that your answer come \\n4 4 [1 1 7 9 4] \\nbut actual answer \\n4 [4 1 1 7 9 4 ]\\nwhy this happen :- \\n1-> you can make many pointer and manage this thing( i tried but fail)\\n\\nReason\\n2-> if  you use s[i] ==s[i+1]  mean you actually include pair that pair  in your length or  go for next pair  \\n\\n//-------------------------------------------------//\\nwhy use s[i-1] == s[i]\\n to avoid including  pair but still  maximize the length ( mean for  (4 ,4..... ) start next length  with  ( 4,[4...       ) \\nhelp to aviod that pair and maximize the length )\\n*/\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n          int n = s.size(); \\n          if( n==1) { return 1; }\\n          int start = 0 , end =1;\\n          int  prev =0 ,ans = 0 ;\\n\\n    while( end<n){\\n         if(  s[end]== s[end-1]){  \\n             start = prev ; \\n               prev = end ; \\n         }\\n          ans = max( ans , end-start+1);\\n          end++;\\n    }\\n    return ans ;\\n    }\\n//---------------------------------Remember----------------------//\\n/*\\n-> don\\'t try to use s[end] ==s[end+1] because in that you will take a fail for some testcase\\nlike \\n4 4 1 1 7 9 4 \\nif you use that your answer come \\n4 4 [1 1 7 9 4] \\nbut actual answer \\n4 [4 1 1 7 9 4 ]\\nwhy this happen :- \\n1-> you can make many pointer and manage this thing( i tried but fail)\\n\\nReason\\n2-> if  you use s[i] ==s[i+1]  mean you actually include pair that pair  in your length or  go for next pair  \\n\\n//-------------------------------------------------//\\nwhy use s[i-1] == s[i]\\n to avoid including  pair but still  maximize the length ( mean for  (4 ,4..... ) start next length  with  ( 4,[4...       ) \\nhelp to aviod that pair and maximize the length )\\n*/\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629770,
                "title": "easy-and-simple-c-solution",
                "content": "\\n\\n# Approach\\nFirst Traverse all the character of string one by one and check from that index if a repetitive consecutive character found then make a flag value true (because we need atmost one consecutive pair) or if next repetitive consecutive character occurs then it breaks the loop and then store that length in count variable and store it in mx variable to get length of longest semi repetitive substring.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2) where n is Legth of given string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string a) {\\n\\n        int n=a.size(),mx=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int count=1;\\n            bool flag=false;\\n            char ch=a[i];\\n\\n            for(int j=i+1;j<n;j++){\\n\\n                if(ch==a[j]){\\n                   if(flag==false){\\n                       flag=true;\\n                   }else break;\\n                  flag=1;\\n                  ch=a[j];\\n                }\\n\\n                count++;\\n                ch=a[j];\\n            }\\n\\n            mx=max(mx,count);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string a) {\\n\\n        int n=a.size(),mx=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int count=1;\\n            bool flag=false;\\n            char ch=a[i];\\n\\n            for(int j=i+1;j<n;j++){\\n\\n                if(ch==a[j]){\\n                   if(flag==false){\\n                       flag=true;\\n                   }else break;\\n                  flag=1;\\n                  ch=a[j];\\n                }\\n\\n                count++;\\n                ch=a[j];\\n            }\\n\\n            mx=max(mx,count);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625835,
                "title": "sliding-window-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans = 1, cnt = 0, i = 0, n = s.size();\\n        for(int j=1; j<n; j++) {\\n            if(s[j - 1] == s[j]) cnt++;\\n            while(i < j && cnt >= 2) {\\n                if(s[i + 1] == s[i]) cnt--;\\n                i++;\\n            }\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans = 1, cnt = 0, i = 0, n = s.size();\\n        for(int j=1; j<n; j++) {\\n            if(s[j - 1] == s[j]) cnt++;\\n            while(i < j && cnt >= 2) {\\n                if(s[i + 1] == s[i]) cnt--;\\n                i++;\\n            }\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624097,
                "title": "not-bad",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        res,c=0,1\\n        for i in range(len(s)-1):\\n            if s[i]==s[i+1]:\\n                count=0\\n                post_ind,post_state=i+2,s[i+1]\\n                pre_ind,pre_state=i-1,s[i]\\n                while pre_ind>=0:\\n                    if s[pre_ind]!=pre_state:\\n                        pre_state=s[pre_ind]\\n                        count+=1 \\n                    else:break\\n                    pre_ind-=1\\n                while post_ind<len(s):\\n                    if s[post_ind]!=post_state:\\n                        post_state=s[post_ind]\\n                        count+=1   \\n                    else:break\\n                    post_ind+=1\\n                res=max(res,count)\\n            else:c+=1\\n        if c==len(s):return c\\n        return res+2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        res,c=0,1\\n        for i in range(len(s)-1):\\n            if s[i]==s[i+1]:\\n                count=0\\n                post_ind,post_state=i+2,s[i+1]\\n                pre_ind,pre_state=i-1,s[i]\\n                while pre_ind>=0:\\n                    if s[pre_ind]!=pre_state:\\n                        pre_state=s[pre_ind]\\n                        count+=1 \\n                    else:break\\n                    pre_ind-=1\\n                while post_ind<len(s):\\n                    if s[post_ind]!=post_state:\\n                        post_state=s[post_ind]\\n                        count+=1   \\n                    else:break\\n                    post_ind+=1\\n                res=max(res,count)\\n            else:c+=1\\n        if c==len(s):return c\\n        return res+2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623531,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s):\\n        n, max_len = len(s), 0\\n\\n        for i in range(n):\\n            val = False\\n            for j in range(i,n):\\n                if j > i and s[j] == s[j-1]:\\n                    if val:\\n                        break\\n                    val = True\\n                max_len = max(max_len,j-i+1)\\n\\n        return max_len\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s):\\n        n, max_len = len(s), 0\\n\\n        for i in range(n):\\n            val = False\\n            for j in range(i,n):\\n                if j > i and s[j] == s[j-1]:\\n                    if val:\\n                        break\\n                    val = True\\n                max_len = max(max_len,j-i+1)\\n\\n        return max_len\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623346,
                "title": "simple-two-pointer-o-n-2",
                "content": "Just loop through, since n is small we don\\'t mind O(n^2).\\nStart at `i` then let `j` go from `i+1` to the end.\\nOne optimization is that if we reach the end for any `i`, we can stop because nothing with a larger `i` will create a larger substring. \\n\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        ret = 0\\n        for i in range(len(s)):\\n            dup=0\\n            j=i+1\\n            while j<len(s):\\n                if s[j]==s[j-1]:\\n                    dup+=1\\n                if dup==2:\\n                    break\\n                j+=1\\n            ret = max(ret,j-i)\\n            if j==len(s): return ret\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        ret = 0\\n        for i in range(len(s)):\\n            dup=0\\n            j=i+1\\n            while j<len(s):\\n                if s[j]==s[j-1]:\\n                    dup+=1\\n                if dup==2:\\n                    break\\n                j+=1\\n            ret = max(ret,j-i)\\n            if j==len(s): return ret\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623193,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int lP = 0,rP = 0,count = 0,ans = 1;\\n        while(rP<s.length()-1 && lP<=rP){\\n            rP++;\\n            if(s.charAt(rP) == s.charAt(rP-1))count++;\\n            while(count>=2){\\n                lP++;\\n                if(s.charAt(lP) == s.charAt(lP-1))count--;\\n            }\\n            ans = Math.max(ans,rP-lP+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int lP = 0,rP = 0,count = 0,ans = 1;\\n        while(rP<s.length()-1 && lP<=rP){\\n            rP++;\\n            if(s.charAt(rP) == s.charAt(rP-1))count++;\\n            while(count>=2){\\n                lP++;\\n                if(s.charAt(lP) == s.charAt(lP-1))count--;\\n            }\\n            ans = Math.max(ans,rP-lP+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623189,
                "title": "c-5-lines-two-pointers",
                "content": "```c++\\nint longestSemiRepetitiveSubstring(string s, int res = 1) {\\n    for (int l = -1, m = -1, r = 1; r < s.size(); r++) {\\n        if (s[r] == s[r - 1]) {\\n            if (m != -1) l = m;\\n            m = r - 1;\\n        }\\n        res = max(res, r - l);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nint longestSemiRepetitiveSubstring(string s, int res = 1) {\\n    for (int l = -1, m = -1, r = 1; r < s.size(); r++) {\\n        if (s[r] == s[r - 1]) {\\n            if (m != -1) l = m;\\n            m = r - 1;\\n        }\\n        res = max(res, r - l);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623085,
                "title": "dope-c-code-with-approach-two-pointers",
                "content": "# Approach\\n\"index\" describes the consecutive repeated part of the array that appears on cnt=1 => the only one repetitive numbers allowed. (as cnt gets = 2, we check the \"ans\" and make cnt=2 back again at that very index!)\\nAfter that we slide our window for next check as we make i=index and j=i+1, and continue further!\\n\\nalos if flag remains \"false\", that means (one or no) repetitive element was found and hence whole number is the answer!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nThis code has a constant space complexity!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int n = s.size();\\n        int cnt=0;\\n        int i=0, j=1, ans=-1e9; int index=0;\\n        bool flag=false; int sum=0;\\n        \\n        while(j<n){\\n            \\n            if(s[j]==s[j-1]){\\n                cnt++;\\n                if(cnt==1) index=j;\\n            }\\n            \\n            if(cnt<=2){\\n                \\n                if(cnt!=2){\\n                    sum=j-i+1;\\n                    ans = max(ans,sum);\\n                }\\n                \\n                else{\\n                    sum = j-i;\\n                    ans = max(ans,sum);\\n                    flag=true;\\n                    cnt=0;\\n                    i=index;\\n                    j=i;\\n                }\\n            }\\n            j++;\\n        }\\n        \\n        if((cnt==0 || cnt==1) && flag==false  ) return n;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int n = s.size();\\n        int cnt=0;\\n        int i=0, j=1, ans=-1e9; int index=0;\\n        bool flag=false; int sum=0;\\n        \\n        while(j<n){\\n            \\n            if(s[j]==s[j-1]){\\n                cnt++;\\n                if(cnt==1) index=j;\\n            }\\n            \\n            if(cnt<=2){\\n                \\n                if(cnt!=2){\\n                    sum=j-i+1;\\n                    ans = max(ans,sum);\\n                }\\n                \\n                else{\\n                    sum = j-i;\\n                    ans = max(ans,sum);\\n                    flag=true;\\n                    cnt=0;\\n                    i=index;\\n                    j=i;\\n                }\\n            }\\n            j++;\\n        }\\n        \\n        if((cnt==0 || cnt==1) && flag==false  ) return n;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622842,
                "title": "easy-c-solution-o-1-space-o-n-2-time-100-fast",
                "content": "# Intuition\\nSeeing the constraints we can understand that accepted compelxity can be $$O(n^2)$$ or more so just tried some logic and it got excepted after 1WA.\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n> Try hard and don\\'t giveup\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            int count = 0;\\n            bool flag = false;\\n            for(int j = i+1 ; j < n ; j++){\\n                if(flag and s[j-1] == s[j]) break;\\n                if(s[j] == s[j-1])\\n                    flag = true;\\n                count++;\\n            }\\n            ans = max(ans,count+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            int count = 0;\\n            bool flag = false;\\n            for(int j = i+1 ; j < n ; j++){\\n                if(flag and s[j-1] == s[j]) break;\\n                if(s[j] == s[j-1])\\n                    flag = true;\\n                count++;\\n            }\\n            ans = max(ans,count+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622717,
                "title": "check-every-string",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=1;\\n            int f=0;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(s[j-1]==s[j])\\n                {\\n                    if(f>0)\\n                        break;\\n                    f++;\\n                    \\n                }\\n                l++;\\n                \\n            }\\n            ans=max(ans,l);\\n        }\\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=1;\\n            int f=0;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(s[j-1]==s[j])\\n                {\\n                    if(f>0)\\n                        break;\\n                    f++;\\n                    \\n                }\\n                l++;\\n                \\n            }\\n            ans=max(ans,l);\\n        }\\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622715,
                "title": "simple-easy-to-understand-o-n-solution-two-pointers",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int idx = -1;\\n        bool flag = false;\\n        int n = s.size();\\n        int ans = 1;\\n        int cnt = 1; \\n        for(int i = 1; i < n; i++) {\\n            if(s[i] != s[i-1]) {\\n                cnt++; \\n            } else {\\n                if(not flag) {\\n                    flag = true; \\n                    idx = i;\\n                    cnt++; \\n                } else {\\n                    ans = max(ans, cnt); \\n                    cnt = i-idx+1; \\n                    idx = i;\\n                }\\n            }\\n        }\\n        \\n        ans = max(ans, cnt);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int idx = -1;\\n        bool flag = false;\\n        int n = s.size();\\n        int ans = 1;\\n        int cnt = 1; \\n        for(int i = 1; i < n; i++) {\\n            if(s[i] != s[i-1]) {\\n                cnt++; \\n            } else {\\n                if(not flag) {\\n                    flag = true; \\n                    idx = i;\\n                    cnt++; \\n                } else {\\n                    ans = max(ans, cnt); \\n                    cnt = i-idx+1; \\n                    idx = i;\\n                }\\n            }\\n        }\\n        \\n        ans = max(ans, cnt);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622687,
                "title": "scala-recursion",
                "content": "# Code\\n```\\nobject Solution {\\n  def longestSemiRepetitiveSubstring(s: String): Int =\\n    go(s.head, s.toList.tail, 1, 1, 0)\\n\\n  def go(c: Char, chars: List[Char], notRepeated: Int, repeated: Int, max: Int): Int = {\\n    chars match {\\n      case Nil => math.max(max, repeated)\\n      case h :: tail =>\\n        if (c == h) go(h, tail, 1, notRepeated + 1, math.max(max, repeated))\\n        else go(h, tail, notRepeated + 1, repeated + 1, max)\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def longestSemiRepetitiveSubstring(s: String): Int =\\n    go(s.head, s.toList.tail, 1, 1, 0)\\n\\n  def go(c: Char, chars: List[Char], notRepeated: Int, repeated: Int, max: Int): Int = {\\n    chars match {\\n      case Nil => math.max(max, repeated)\\n      case h :: tail =>\\n        if (c == h) go(h, tail, 1, notRepeated + 1, math.max(max, repeated))\\n        else go(h, tail, notRepeated + 1, repeated + 1, max)\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3622602,
                "title": "sliding-window-simple-solution",
                "content": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n         int i = 0;\\n         int count = 0;\\n         int max = 1;\\n         for(int j = 0; j < s.length(); j++){\\n             if(j != 0 && s.charAt(j) == s.charAt(j - 1)){\\n                 count++;\\n             }\\n\\t\\t\\t // removing the char from the front if count exceeds\\n             while(count > 1){\\n                 if(s.charAt(i) == s.charAt(i + 1)){\\n                     count--;\\n                 }\\n                 i++;\\n             }\\n             max = Math.max(max,j - i + 1);\\n         }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n         int i = 0;\\n         int count = 0;\\n         int max = 1;\\n         for(int j = 0; j < s.length(); j++){\\n             if(j != 0 && s.charAt(j) == s.charAt(j - 1)){\\n                 count++;\\n             }\\n\\t\\t\\t // removing the char from the front if count exceeds\\n             while(count > 1){\\n                 if(s.charAt(i) == s.charAt(i + 1)){\\n                     count--;\\n                 }\\n                 i++;\\n             }\\n             max = Math.max(max,j - i + 1);\\n         }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622538,
                "title": "easy-approach-using-2-loops-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int n = s.length();\\n        int maxi = 1;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=i+1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    count++;\\n                }\\n                if(count<=1){\\n                    maxi=max(maxi, j-i+1);\\n                }\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```\\n**Please upvote if you find this helpful**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int n = s.length();\\n        int maxi = 1;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=i+1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    count++;\\n                }\\n                if(count<=1){\\n                    maxi=max(maxi, j-i+1);\\n                }\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622462,
                "title": "harnessing-the-force-of-python-to-find-the-longest-semi-repetitive-substring",
                "content": "\"In a galaxy far, far away, Python warriors constantly seek innovative solutions to complex challenges. One such puzzle, quite popular amongst the programming Jedi, is determining the length of the longest semi-repetitive substring in a given string of digits, where semi-repetitive signifies that there is at most one consecutive pair of the same digits in the substring.\"\\n\\nTo best understand the provided solution, one must first master the concept of substrings and the implications of semi-repetitive conditions. A substring is a contiguous non-empty sequence of characters within a given string. On the other hand, a semi-repetitive string has at most one consecutive pair of the same digits.\\n\\nUsing Python, we can traverse the string in a manner akin to how Luke Skywalker traversed the Death Star\\'s corridors, examining every element (or in our context, character) and its relation to those around it.\\n\\n```python\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        max_length = 1\\n        previous_char_position = 0\\n        next_duplicate_char_position = 0\\n        for current_position, current_char in enumerate(s):\\n            if current_position == 0:\\n                continue\\n            if current_char == s[current_position - 1]:\\n                previous_char_position = next_duplicate_char_position\\n                next_duplicate_char_position = current_position\\n            max_length = max(max_length, current_position - previous_char_position + 1)\\n        return max_length\\n```\\n\\nMuch like the Skywalker saga, this function has a beginning, a middle, and an end. \\n\\nThe beginning sets the stage: `max_length` is the length of the longest substring found so far, initialized to 1 since any character by itself is a semi-repetitive substring. `previous_char_position` keeps track of the position where the previous different character is in the string. `next_duplicate_char_position` prepares us for the position of the next duplicate character.\\n\\nThe middle, like the epic battles of Star Wars, is where the action happens. We traverse our string (`s`), symbolizing our path to the Dark Side. For each character (`current_char`), if it is the same as the previous one, we need to update our positions (`previous_char_position` and `next_duplicate_char_position`). \\n\\nThe end of each iteration is like the aftermath of a battle. The Jedi re-evaluates the situation, i.e., we compare the `max_length` with the length of the new potential substring, and update `max_length` if the new one is longer.\\n\\nIn terms of time complexity, like a Jedi\\'s use of the Force, this algorithm exhibits impressive efficiency. The time complexity is O(n), where n is the length of the input string `s`. This linear complexity is due to the fact that we only need to traverse the string once, making it as fast as the Millennium Falcon on a Kessel Run. \\n\\nIn conclusion, understanding this solution allows you to harness the true power of the Python Force, masterfully handling strings, and confidently navigating the realm of semi-repetitive substrings. \\n\\nRemember, as Yoda would say, \"Patience you must have, my young Padawan.\" Coding, like mastering the Force, requires patience, practice, and a willingness to learn. May the Force be with you!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        max_length = 1\\n        previous_char_position = 0\\n        next_duplicate_char_position = 0\\n        for current_position, current_char in enumerate(s):\\n            if current_position == 0:\\n                continue\\n            if current_char == s[current_position - 1]:\\n                previous_char_position = next_duplicate_char_position\\n                next_duplicate_char_position = current_position\\n            max_length = max(max_length, current_position - previous_char_position + 1)\\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622409,
                "title": "easy-o-n-2-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     \\n    // read question carefully \\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.length();\\n        int maxi = 1;\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for(int j = i + 1; j < n; j++) {\\n                if(s[j - 1] == s[j]) {\\n                    cnt++;\\n                }\\n                if(cnt <= 1) {\\n                    maxi = max(maxi, j - i + 1);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    // read question carefully \\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.length();\\n        int maxi = 1;\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for(int j = i + 1; j < n; j++) {\\n                if(s[j - 1] == s[j]) {\\n                    cnt++;\\n                }\\n                if(cnt <= 1) {\\n                    maxi = max(maxi, j - i + 1);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622390,
                "title": "simple-c-solution-best-approach-tc-o-n-sc-o-1",
                "content": "\\n# Approach\\nSliding Window approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b)\\n            return a;\\n        return b;\\n    }\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int start = 0;\\n        int maxlen = 0;\\n        int cnt = 0;\\n        int position = 0;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]==s[i-1] && cnt==1)\\n            {\\n                maxlen = max(maxlen,i-start);\\n                start = position;\\n                position = i;\\n            }\\n            else if(s[i]==s[i-1]){\\n                position = i;\\n                cnt++;\\n            }\\n        }\\n        maxlen = max(maxlen,s.length()-start);\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max(int a,int b){\\n        if(a>b)\\n            return a;\\n        return b;\\n    }\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int start = 0;\\n        int maxlen = 0;\\n        int cnt = 0;\\n        int position = 0;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]==s[i-1] && cnt==1)\\n            {\\n                maxlen = max(maxlen,i-start);\\n                start = position;\\n                position = i;\\n            }\\n            else if(s[i]==s[i-1]){\\n                position = i;\\n                cnt++;\\n            }\\n        }\\n        maxlen = max(maxlen,s.length()-start);\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622389,
                "title": "simple-solution-sliding-window-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int i=1;    \\n        int res=0;\\n        int flag=0;    //to check whether a pair exists\\n        int index=-1;   //location of pair\\n        int j=0;        //start index\\n        while(i<s.length()){\\n            if(s.charAt(i-1)==s.charAt(i)){\\n                if(flag==0){\\n                    index=i;\\n                    flag=1;\\n                    res=Math.max(res,i-j+1);\\n                    i++;\\n                }\\n                else{\\n                    j=index;\\n                    flag=0;\\n                }\\n            }\\n            else{\\n                if(flag==1){\\n                    res=Math.max(res,i-j+1);\\n                }\\n                i++;\\n            }\\n        }\\n        if(res==0){\\n            return s.length();\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int i=1;    \\n        int res=0;\\n        int flag=0;    //to check whether a pair exists\\n        int index=-1;   //location of pair\\n        int j=0;        //start index\\n        while(i<s.length()){\\n            if(s.charAt(i-1)==s.charAt(i)){\\n                if(flag==0){\\n                    index=i;\\n                    flag=1;\\n                    res=Math.max(res,i-j+1);\\n                    i++;\\n                }\\n                else{\\n                    j=index;\\n                    flag=0;\\n                }\\n            }\\n            else{\\n                if(flag==1){\\n                    res=Math.max(res,i-j+1);\\n                }\\n                i++;\\n            }\\n        }\\n        if(res==0){\\n            return s.length();\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622382,
                "title": "easy-c-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically use sliding window to find the longest substring and update the max length.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s a breakdown of how the code works:\\n\\nIt first initializes some variables: \\'n\\' to store the size of the string \\'s\\', \\'i\\' and \\'j\\' as pointers to traverse the string, \\'cnt\\' to count the number of consecutive repeated characters, and \\'maxi\\' to store the maximum length of a semi-repetitive substring found so far.\\n\\nIf the size of the string is 1, it means the whole string is the longest semi-repetitive substring, so it returns 1.\\n\\nIt enters a while loop that iterates through the string from index 1 to \\'n-1\\'.\\n\\nInside the loop, it checks if the current character is equal to the previous character. If they are equal, it increments the \\'cnt\\' variable to keep track of the consecutive repeated characters.\\n\\nIf the \\'cnt\\' becomes greater than 1, it means we have found a semi-repetitive substring.\\n\\nIt updates the \\'maxi\\' variable to store the maximum length of a semi-repetitive substring found so far (if the current substring is longer than the previous maximum).\\n\\nIt then moves the \\'i\\' pointer one step forward and enters another loop. This loop continues until the characters at indices \\'i\\' and \\'i-1\\' are not equal or until \\'i\\' reaches the end of the string.\\n\\nInside the second loop, it increments the \\'i\\' pointer until it reaches a character that is not equal to the previous character.\\n\\nIt decrements the \\'cnt\\' variable to account for the removal of the consecutive repeated characters.\\n\\nFinally, the \\'j\\' pointer is moved one step forward to continue the traversal of the string.\\n\\nAfter the traversal is complete, the code updates the \\'maxi\\' variable again (in case the longest semi-repetitive substring ends at the last character of the string).\\n\\nThe function returns the value of \\'maxi\\', which represents the length of the longest semi-repetitive substring in the given string \\'s\\'.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int n=s.size();\\n        if(n==1)return 1;\\n        int i=0;\\n        int j=1;\\n        int cnt=0;\\n        int maxi=0;\\n        while(j<n)\\n        {\\n            if(s[j]==s[j-1])cnt++;\\n         \\n            if(cnt>1)\\n            {\\n                maxi=max(maxi,j-i);\\n             \\n                i++;\\n                while(s[i]!=s[i-1]&&i<n)i++;\\n                \\n                cnt--;\\n                \\n            }\\n            j++;\\n          \\n        }\\n \\n        maxi=max(maxi,j-i);\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int n=s.size();\\n        if(n==1)return 1;\\n        int i=0;\\n        int j=1;\\n        int cnt=0;\\n        int maxi=0;\\n        while(j<n)\\n        {\\n            if(s[j]==s[j-1])cnt++;\\n         \\n            if(cnt>1)\\n            {\\n                maxi=max(maxi,j-i);\\n             \\n                i++;\\n                while(s[i]!=s[i-1]&&i<n)i++;\\n                \\n                cnt--;\\n                \\n            }\\n            j++;\\n          \\n        }\\n \\n        maxi=max(maxi,j-i);\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622381,
                "title": "explained-simple-and-clear-c-code-t-c-o-n-s-c-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\n The code aims to find the length of the longest semi-repetitive substring in the string \\'s\\'.\\n    It uses a sliding window approach with two pointers, \\'i\\' and \\'j\\', to iterate through the string.\\n    The \\'count\\' variable keeps track of the number of non-distinct characters in the current substring.\\n    If the count is less than or equal to 1, it means the current substring is semi-repetitive, so the result is updated if a longer substring is found.\\n    If the count is greater than 1, extra non-distinct characters are present, so the \\'j\\' pointer moves forward until the count becomes less than or equal to 1.\\n    This process continues until the end of the string, and the maximum length found is returned as the result.\\n\\nIn short, the code iterates through the string, maintaining a count of non-distinct characters. It finds and updates the longest semi-repetitive substring length while handling cases with extra non-distinct characters.\\n# Approach\\nThe given code aims to find the length of the longest semi-repetitive substring in a given string \\'s\\'. A semi-repetitive substring is defined as a substring that contains at most one non-distinct character.\\n\\nThe code uses a sliding window approach to iterate through the string. It maintains two pointers, \\'i\\' and \\'j\\', which represent the start and end indices of the current substring being considered. The variable \\'count\\' keeps track of the number of non-distinct characters encountered so far in the current substring.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.length();\\n        int result = 0;\\n        for (int i = 0, j = 0, count = 0; i < n; i++) {\\n            if (i > 0 && s[i - 1] == s[i]) {\\n                count++;\\n            }\\n            if (count <= 1) {\\n                result = max(result, i - j + 1);\\n            } else {\\n                while (count > 1) {\\n                    if (s[j] == s[j + 1]) {\\n                        count--;\\n                    }\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.length();\\n        int result = 0;\\n        for (int i = 0, j = 0, count = 0; i < n; i++) {\\n            if (i > 0 && s[i - 1] == s[i]) {\\n                count++;\\n            }\\n            if (count <= 1) {\\n                result = max(result, i - j + 1);\\n            } else {\\n                while (count > 1) {\\n                    if (s[j] == s[j + 1]) {\\n                        count--;\\n                    }\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622377,
                "title": "typescript-solution-beginner-friendly-approach-simple-o-n-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApproach by generating all sub-strings.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nfunction longestSemiRepetitiveSubstring(s: string): number {\\n    let max: number = 0;\\n    for(let i = 0;i<s.length; i++){\\n        for(let j = i; j < s.length;j++ ){\\n            let m = s.slice(i, j+1)\\n            let ct =  0;\\n            for(let k = 0; k< (m.length)-1 ; k++){\\n               ( Number(m[k]) ^ Number(m[k+1])) === 0 ? ct = ct + 1: ct = ct;\\n            }\\n            if(ct<=1 && m.length > max) {\\n                max= m.length\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction longestSemiRepetitiveSubstring(s: string): number {\\n    let max: number = 0;\\n    for(let i = 0;i<s.length; i++){\\n        for(let j = i; j < s.length;j++ ){\\n            let m = s.slice(i, j+1)\\n            let ct =  0;\\n            for(let k = 0; k< (m.length)-1 ; k++){\\n               ( Number(m[k]) ^ Number(m[k+1])) === 0 ? ct = ct + 1: ct = ct;\\n            }\\n            if(ct<=1 && m.length > max) {\\n                max= m.length\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3622346,
                "title": "sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        ans, cur = 1, 1\\n        prevEndIdx = -1\\n        for i in range(1, len(s)):\\n            if s[i] == s[i - 1]:\\n                if prevEndIdx != -1:\\n                    cur = i - prevEndIdx - 1\\n                prevEndIdx = i - 1\\n            cur += 1\\n            ans = max(cur, ans)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        ans, cur = 1, 1\\n        prevEndIdx = -1\\n        for i in range(1, len(s)):\\n            if s[i] == s[i - 1]:\\n                if prevEndIdx != -1:\\n                    cur = i - prevEndIdx - 1\\n                prevEndIdx = i - 1\\n            cur += 1\\n            ans = max(cur, ans)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622316,
                "title": "very-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans=0;\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            for(int j=i;j<s.size()-1;j++){\\n                if(s[j]==s[j+1]){\\n                    cnt++;\\n                }\\n                if(cnt<=1){\\n                    ans=max(ans,j-i+1);\\n                }\\n                if(cnt>1){\\n                    cnt=0;\\n                    break;\\n                }\\n            }\\n        }\\n       return ans+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans=0;\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            for(int j=i;j<s.size()-1;j++){\\n                if(s[j]==s[j+1]){\\n                    cnt++;\\n                }\\n                if(cnt<=1){\\n                    ans=max(ans,j-i+1);\\n                }\\n                if(cnt>1){\\n                    cnt=0;\\n                    break;\\n                }\\n            }\\n        }\\n       return ans+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038368,
                "title": "cpp-solution-using-sliding-window",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n       \\n        int ans = 1, count = 0, n = s.length(), i = 0;\\n\\n        for(int j = 1; j < n; j++)\\n        {\\n            if(s[j] == s[j - 1])\\n                count++;\\n\\n            while(i < j && count >= 2)\\n            {\\n                if(s[i + 1] == s[i])\\n                    count--;\\n                i++;\\n            }\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```\\nHope you understand the code.",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n       \\n        int ans = 1, count = 0, n = s.length(), i = 0;\\n\\n        for(int j = 1; j < n; j++)\\n        {\\n            if(s[j] == s[j - 1])\\n                count++;\\n\\n            while(i < j && count >= 2)\\n            {\\n                if(s[i + 1] == s[i])\\n                    count--;\\n                i++;\\n            }\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025484,
                "title": "beginner-friendly-easy-recursive-approach-not-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursion + Sliding Window\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^4)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        return recursiveSemi(s,n);\\n    }\\n\\n    int recursiveSemi(string S,int n)\\n    {\\n        //return full size if not a semi repetitive string\\n        if(n == 0)\\n        {\\n            return S.size();\\n        }\\n\\n        //get all the possible strings of size n using sliding window\\n        for(int i = 0;i<S.size() - (n - 1);i++)\\n        {\\n            string sub = S.substr(i,n);\\n            bool b = checkSemi(sub);\\n            if(b == true)\\n            return n;\\n        }\\n\\n        //if Semi return else recursive call for n-1\\n        n -= 1;\\n        return recursiveSemi(S,n);\\n    }\\n\\n    bool checkSemi(string S)\\n    {\\n        //Can not be a repititive string if it\\'s length is 1\\n        if(S.size() == 1)\\n        return false;\\n\\n        //variable to count the number of matching characters\\n        int c = 0;\\n        for(int i = 0;i<S.size();i++)\\n        {\\n            if(i+1 >= S.size())\\n            continue;\\n            if(S[i+1] == S[i])\\n            {\\n                c++;\\n            }\\n        }\\n        //if more than one then it is not a semi repititive string\\n        if(c==1)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        return recursiveSemi(s,n);\\n    }\\n\\n    int recursiveSemi(string S,int n)\\n    {\\n        //return full size if not a semi repetitive string\\n        if(n == 0)\\n        {\\n            return S.size();\\n        }\\n\\n        //get all the possible strings of size n using sliding window\\n        for(int i = 0;i<S.size() - (n - 1);i++)\\n        {\\n            string sub = S.substr(i,n);\\n            bool b = checkSemi(sub);\\n            if(b == true)\\n            return n;\\n        }\\n\\n        //if Semi return else recursive call for n-1\\n        n -= 1;\\n        return recursiveSemi(S,n);\\n    }\\n\\n    bool checkSemi(string S)\\n    {\\n        //Can not be a repititive string if it\\'s length is 1\\n        if(S.size() == 1)\\n        return false;\\n\\n        //variable to count the number of matching characters\\n        int c = 0;\\n        for(int i = 0;i<S.size();i++)\\n        {\\n            if(i+1 >= S.size())\\n            continue;\\n            if(S[i+1] == S[i])\\n            {\\n                c++;\\n            }\\n        }\\n        //if more than one then it is not a semi repititive string\\n        if(c==1)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018519,
                "title": "c-two-pointer-method",
                "content": "# Intuition\\nIt is two pointer solution. we will move left pointer to first instance of repetion when second instance of repetion is encountered in string parsing. \\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N) -> N= length of s\\n\\n- Space complexity:\\nO(1) -> Constant storage irrespective of size of s\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        vector<int> m(10,-1);\\n        int start=-1,d=0,ans=1,digitRepeatedAtIndex=-1;\\n        for (int i=0;i<s.size();i++){\\n            d=s[i]-\\'0\\';\\n            if (i-1<=start || s[i-1]!=s[i]){\\n                m[d]=i;\\n            }\\n            else if (digitRepeatedAtIndex==-1){\\n                digitRepeatedAtIndex = m[d];\\n                m[d] = i;\\n            }\\n            else{\\n                start = digitRepeatedAtIndex;\\n                digitRepeatedAtIndex = m[d];\\n                m[d]=i;\\n            }\\n\\n            ans = max(ans,i-start);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        vector<int> m(10,-1);\\n        int start=-1,d=0,ans=1,digitRepeatedAtIndex=-1;\\n        for (int i=0;i<s.size();i++){\\n            d=s[i]-\\'0\\';\\n            if (i-1<=start || s[i-1]!=s[i]){\\n                m[d]=i;\\n            }\\n            else if (digitRepeatedAtIndex==-1){\\n                digitRepeatedAtIndex = m[d];\\n                m[d] = i;\\n            }\\n            else{\\n                start = digitRepeatedAtIndex;\\n                digitRepeatedAtIndex = m[d];\\n                m[d]=i;\\n            }\\n\\n            ans = max(ans,i-start);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014356,
                "title": "85-faster-easy-2-approach-list-stl-and-then-optimized-with-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas we are asked to find substring and we can think of it as window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust maintain a window having only one pair of consecutively similar elements and slide till there is another pair in the window .then we decrease the window untill it becomes valid again .e\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i=0,j=0,f=0;  \\n        int n=s.length();\\n        int res=0;\\n        while(j<s.length()){\\n             if(j!=0 and s[j-1]==s[j]){f++;}  \\n\\n             if(f<=1){res=max(res,j-i+1); }\\n\\n             if(f<1){j++;}\\n             else if(f==1){res=max(res,j-i+1);j++;}\\n             else{\\n                 while(f>1){\\n                    if(i+1<n and s[i]==s[i+1]){f--;}\\n                     i++;\\n                    if(f==1){res=max(res,j-i+1);}\\n                 }\\n                j++;\\n             }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i=0,j=0,f=0;  \\n        int n=s.length();\\n        int res=0;\\n        while(j<s.length()){\\n             if(j!=0 and s[j-1]==s[j]){f++;}  \\n\\n             if(f<=1){res=max(res,j-i+1); }\\n\\n             if(f<1){j++;}\\n             else if(f==1){res=max(res,j-i+1);j++;}\\n             else{\\n                 while(f>1){\\n                    if(i+1<n and s[i]==s[i+1]){f--;}\\n                     i++;\\n                    if(f==1){res=max(res,j-i+1);}\\n                 }\\n                j++;\\n             }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987801,
                "title": "i-need-to-stop-using-dp",
                "content": "# Intuition\\nWhenever substring or any sequence question comes I automatically start thinking DP solution!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][2];\\n    int helper(int i,int f,string& s,int first){\\n        if(i==s.length())return 0;\\n        if(dp[i][f]!=-1)return dp[i][f];\\n        \\n        int t = 0;\\n        if(i==first){\\n            t = 1 + helper(i+1,f,s,first);\\n        } \\n        else if(s[i-1]!=s[i]){\\n            t = 1 + helper(i+1,f,s,first);\\n        }\\n        else if(s[i-1]==s[i] && !f){\\n            t = 1 + helper(i+1,1,s,first);\\n        }\\n        \\n        return dp[i][f] = t;\\n    }\\n    int longestSemiRepetitiveSubstring(string s) {\\n       \\n        int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n             memset(dp,-1,sizeof(dp));\\n            ans = max(ans,helper(i,0,s,i));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][2];\\n    int helper(int i,int f,string& s,int first){\\n        if(i==s.length())return 0;\\n        if(dp[i][f]!=-1)return dp[i][f];\\n        \\n        int t = 0;\\n        if(i==first){\\n            t = 1 + helper(i+1,f,s,first);\\n        } \\n        else if(s[i-1]!=s[i]){\\n            t = 1 + helper(i+1,f,s,first);\\n        }\\n        else if(s[i-1]==s[i] && !f){\\n            t = 1 + helper(i+1,1,s,first);\\n        }\\n        \\n        return dp[i][f] = t;\\n    }\\n    int longestSemiRepetitiveSubstring(string s) {\\n       \\n        int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n             memset(dp,-1,sizeof(dp));\\n            ans = max(ans,helper(i,0,s,i));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972286,
                "title": "sliding-window-approach-easiest-solution-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int p=0,ans=1,c=0;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i-1]==s[i]){\\n                c++;\\n            }\\n            while(c>1){\\n                if(s[p]==s[p+1]){\\n                    //p=p+1;\\n                    c--;\\n                }\\n                p++;\\n                \\n            }    \\n            ans=max(ans,i-p+1);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int p=0,ans=1,c=0;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i-1]==s[i]){\\n                c++;\\n            }\\n            while(c>1){\\n                if(s[p]==s[p+1]){\\n                    //p=p+1;\\n                    c--;\\n                }\\n                p++;\\n                \\n            }    \\n            ans=max(ans,i-p+1);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952804,
                "title": "c-solution-with-t-c-o-n-and-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size(),i = 0,j = 1,ct = 0,mxLen = 1;\\n        while(j < n){\\n            if(s[j-1] == s[j]) ct++;\\n            while(ct > 1){\\n                if(i < n-1 && s[i] == s[i+1]) ct--;\\n                i++;\\n            }\\n            mxLen = max(mxLen,(j++) -i+1);\\n        }\\n        return mxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size(),i = 0,j = 1,ct = 0,mxLen = 1;\\n        while(j < n){\\n            if(s[j-1] == s[j]) ct++;\\n            while(ct > 1){\\n                if(i < n-1 && s[i] == s[i+1]) ct--;\\n                i++;\\n            }\\n            mxLen = max(mxLen,(j++) -i+1);\\n        }\\n        return mxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952553,
                "title": "sliding-window-c",
                "content": "# Intuition\\nA variable sliding window is applicable here and the result is the size of the maximum window size.\\n\\n# Approach\\n1. Iterate through the string:\\n\\n2. Check for repeating characters:\\nIf adjacent characters are the same, increment the rep counter.\\n\\n3. Handle cases with too many repeating characters:\\nEnter a while loop if rep becomes greater than or equal to 2. This is done to ensure that the substring doesn\\'t have more than one repeating character consecutively. Inside the loop, check if the characters at index i and i+1 are the same. If they are, decrement the rep counter and move the i index one step forward. Repeat this process as long as rep is still greater than or equal to 2.\\n\\n4. Update the result:\\nCalculate the length of the current substring (j - i + 1) and update the res variable if the calculated length is greater than the previous maximum.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size(),\\n        i = 0,\\n        rep = 0,\\n        res = 1;\\n        \\n        for(int j=1; j<n; j++)\\n        {\\n            if (s[j] == s[j-1])\\n            rep++;\\n\\n            while(rep >= 2)\\n            {\\n                if (s[i] == s[i+1])\\n                rep--;\\n                i++;\\n            }\\n            res = max(res, j-i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size(),\\n        i = 0,\\n        rep = 0,\\n        res = 1;\\n        \\n        for(int j=1; j<n; j++)\\n        {\\n            if (s[j] == s[j-1])\\n            rep++;\\n\\n            while(rep >= 2)\\n            {\\n                if (s[i] == s[i+1])\\n                rep--;\\n                i++;\\n            }\\n            res = max(res, j-i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952220,
                "title": "python3-beats-99-run-time-variable-sliding-window-two-pointer",
                "content": "# Intuition\\nKeep track of previous and current value, keep updating when duplication happens more than two. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfrom collections import defaultdict \\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        count,i,max_len= 0,0,0\\n        prev = None\\n\\n        for j in range(len(s)):\\n            if prev:\\n                if prev == s[j] :\\n                    count += 1 \\n            prev = s[j]\\n\\n            if count >= 2 :\\n                max_len = max(max_len,j-i)\\n                while(count>= 2 and i < j):\\n                    if s[i] == s[i+1]:\\n                        count -= 1\\n                    i += 1\\n        max_len = max(max_len,j-i+1)\\n        return max_len\\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import defaultdict \\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        count,i,max_len= 0,0,0\\n        prev = None\\n\\n        for j in range(len(s)):\\n            if prev:\\n                if prev == s[j] :\\n                    count += 1 \\n            prev = s[j]\\n\\n            if count >= 2 :\\n                max_len = max(max_len,j-i)\\n                while(count>= 2 and i < j):\\n                    if s[i] == s[i+1]:\\n                        count -= 1\\n                    i += 1\\n        max_len = max(max_len,j-i+1)\\n        return max_len\\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942540,
                "title": "python-cute-2-pointers-summer-edition-simpler-than-ruining-your-gpa-at-college",
                "content": "# Approach\\nSimple idea of 2 pointers and maintain the valid condition within the window. \\n\\nWe keep track the number consecutive pair of same digits in variable `cnt`. To check if there exists a pair at position `i` by comparing `s[i] == s[i - 1]`. \\n\\nTo make sure the window only have at most 1 pair, we have to advance the pointer `j` forward until we found a pair in the window to remove. \\n\\n# Complexity:\\n\\nTime complexity: $$O(n)$$\\nSpace complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        n = len(s)\\n        j = res = cnt = 0\\n        if n == 1: return 1\\n        \\n        for i in range(1, n):\\n            if s[i] == s[i - 1]: cnt += 1\\n\\n            while cnt > 1:\\n                if s[j] == s[j + 1]: cnt -= 1\\n                j += 1\\n\\n            res = max(i - j + 1, res)\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        n = len(s)\\n        j = res = cnt = 0\\n        if n == 1: return 1\\n        \\n        for i in range(1, n):\\n            if s[i] == s[i - 1]: cnt += 1\\n\\n            while cnt > 1:\\n                if s[j] == s[j + 1]: cnt -= 1\\n                j += 1\\n\\n            res = max(i - j + 1, res)\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920345,
                "title": "amazing-solution-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        rep_inds = []\\n        for i in range(len(s)-1):\\n            if s[i]==s[i+1]:\\n                rep_inds.append(i)\\n        \\n        if len(rep_inds)==0:\\n            return len(s)\\n        max_len = 0\\n        for i in range(len(rep_inds)):\\n            left_ind = 0\\n            if i>0:\\n                left_ind = rep_inds[i-1]+1\\n            right_ind = len(s)-1\\n            if i<len(rep_inds)-1:\\n                right_ind = rep_inds[i+1]\\n            max_len = max(max_len, right_ind-left_ind+1)\\n        return max_len\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        rep_inds = []\\n        for i in range(len(s)-1):\\n            if s[i]==s[i+1]:\\n                rep_inds.append(i)\\n        \\n        if len(rep_inds)==0:\\n            return len(s)\\n        max_len = 0\\n        for i in range(len(rep_inds)):\\n            left_ind = 0\\n            if i>0:\\n                left_ind = rep_inds[i-1]+1\\n            right_ind = len(s)-1\\n            if i<len(rep_inds)-1:\\n                right_ind = rep_inds[i+1]\\n            max_len = max(max_len, right_ind-left_ind+1)\\n        return max_len\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920344,
                "title": "amazing-solution-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        rep_inds = []\\n        for i in range(len(s)-1):\\n            if s[i]==s[i+1]:\\n                rep_inds.append(i)\\n        \\n        if len(rep_inds)==0:\\n            return len(s)\\n        max_len = 0\\n        for i in range(len(rep_inds)):\\n            left_ind = 0\\n            if i>0:\\n                left_ind = rep_inds[i-1]+1\\n            right_ind = len(s)-1\\n            if i<len(rep_inds)-1:\\n                right_ind = rep_inds[i+1]\\n            max_len = max(max_len, right_ind-left_ind+1)\\n        return max_len\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        rep_inds = []\\n        for i in range(len(s)-1):\\n            if s[i]==s[i+1]:\\n                rep_inds.append(i)\\n        \\n        if len(rep_inds)==0:\\n            return len(s)\\n        max_len = 0\\n        for i in range(len(rep_inds)):\\n            left_ind = 0\\n            if i>0:\\n                left_ind = rep_inds[i-1]+1\\n            right_ind = len(s)-1\\n            if i<len(rep_inds)-1:\\n                right_ind = rep_inds[i+1]\\n            max_len = max(max_len, right_ind-left_ind+1)\\n        return max_len\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904428,
                "title": "typescript-sliding-window-solution",
                "content": "\\n```\\nfunction longestSemiRepetitiveSubstring(s: string): number {\\n  if (s.length <= 1) {\\n    return s.length;\\n  }\\n\\n  let res = 0;\\n\\n  let left = 0;\\n  let right = 1;\\n  let prevDupIndex = 0;\\n\\n  while (right < s.length) {\\n    if (s[right - 1] == s[right]) {\\n      const count = right - 1 - left + 1;\\n      res = Math.max(res, count);\\n      left = prevDupIndex;\\n      prevDupIndex = right;\\n    }\\n\\n    right += 1;\\n  }\\n\\n  res = Math.max(res, right - 1 - left + 1);\\n\\n  return res;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction longestSemiRepetitiveSubstring(s: string): number {\\n  if (s.length <= 1) {\\n    return s.length;\\n  }\\n\\n  let res = 0;\\n\\n  let left = 0;\\n  let right = 1;\\n  let prevDupIndex = 0;\\n\\n  while (right < s.length) {\\n    if (s[right - 1] == s[right]) {\\n      const count = right - 1 - left + 1;\\n      res = Math.max(res, count);\\n      left = prevDupIndex;\\n      prevDupIndex = right;\\n    }\\n\\n    right += 1;\\n  }\\n\\n  res = Math.max(res, right - 1 - left + 1);\\n\\n  return res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895962,
                "title": "golang-o-n-100-solution",
                "content": "# Code\\n```go\\nfunc longestSemiRepetitiveSubstring(s string) int {\\n\\tdupIndexes := make([]int, 0, 16)\\n\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\tif s[i] == s[i+1] {\\n\\t\\t\\tdupIndexes = append(dupIndexes, i)\\n\\t\\t}\\n\\t}\\n\\tif len(dupIndexes) <= 1 {\\n\\t\\treturn len(s)\\n\\t}\\n\\tlongest := dupIndexes[1] + 1\\n\\tif last := len(s) - dupIndexes[len(dupIndexes)-2] - 1; last > longest {\\n\\t\\tlongest = last\\n\\t}\\n\\t// 112233 dupIndexes=[0, 2, 4]\\n\\tfor i := 2; i < len(dupIndexes); i++ {\\n\\t\\tcurrent := dupIndexes[i] - dupIndexes[i-2]\\n\\t\\tif current > longest {\\n\\t\\t\\tlongest = current\\n\\t\\t}\\n\\t}\\n\\treturn longest\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc longestSemiRepetitiveSubstring(s string) int {\\n\\tdupIndexes := make([]int, 0, 16)\\n\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\tif s[i] == s[i+1] {\\n\\t\\t\\tdupIndexes = append(dupIndexes, i)\\n\\t\\t}\\n\\t}\\n\\tif len(dupIndexes) <= 1 {\\n\\t\\treturn len(s)\\n\\t}\\n\\tlongest := dupIndexes[1] + 1\\n\\tif last := len(s) - dupIndexes[len(dupIndexes)-2] - 1; last > longest {\\n\\t\\tlongest = last\\n\\t}\\n\\t// 112233 dupIndexes=[0, 2, 4]\\n\\tfor i := 2; i < len(dupIndexes); i++ {\\n\\t\\tcurrent := dupIndexes[i] - dupIndexes[i-2]\\n\\t\\tif current > longest {\\n\\t\\t\\tlongest = current\\n\\t\\t}\\n\\t}\\n\\treturn longest\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3883424,
                "title": "sliding-window-java-solution-complete-explanation-of-approach-and-intuition-o-n-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can have no or only one repeated consecutive character in our substring. Sliding Window with variable length will be best suited here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will start increment our end of window till we meet another(second) element with consecutive value as that of previously visited element.\\nand also we will keep track of index of consecutive repeated value.\\n we will now calculate the ans length as it will be one of the possibilities here. Now we will start decrementing our start of window( shrinking the window) till we reach that index which we kept track of. we will again update our ans length and then change the index of repeated consec element. \\n\\nnote- what if no consecutive repeated element are found? \\nwe should update ans even when we havent found such elements i.e. we\\'ll update ans while incrementing window size.\\n\\nbase case- if the string has length 1 or 2 then ans will always be equal to string length.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) because of one while loop for string traversal\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as the space occupied by the variables is constant.\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        if(s.length()==1 || s.length()==2) return s.length();\\n        \\nint repval=-1; int ans=0;\\n        int i=0; int j=-1;\\n        while(i<s.length()-1)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1))\\n            {\\n              i++; ans=Math.max(ans,i-j); \\n            }\\n            else {\\n                if(repval==-1) {repval=i; i++; ans=Math.max(ans,i-j); }\\n                else{\\n                    ans=Math.max(ans,i-j);j++;\\n                    j=repval;\\n                    ans=Math.max(ans,i-j);\\n                    repval=i;\\n                    i++;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        if(s.length()==1 || s.length()==2) return s.length();\\n        \\nint repval=-1; int ans=0;\\n        int i=0; int j=-1;\\n        while(i<s.length()-1)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1))\\n            {\\n              i++; ans=Math.max(ans,i-j); \\n            }\\n            else {\\n                if(repval==-1) {repval=i; i++; ans=Math.max(ans,i-j); }\\n                else{\\n                    ans=Math.max(ans,i-j);j++;\\n                    j=repval;\\n                    ans=Math.max(ans,i-j);\\n                    repval=i;\\n                    i++;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835334,
                "title": "beats-99-simple-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        int ans=0;\\n        int j=0,k=0 ,f=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n             if(s[i]==s[i+1])\\n             {\\n                 if(f)\\n                 {\\n                     ans=max(ans,i-j+1);\\n                     j=k;\\n                 }\\n                 f=1;\\n                 k=i+1;\\n             }\\n             //ans=max(ans,i-j+1);\\n\\n        }\\n        k=s.size();\\n        ans=max(ans,k-j);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        int ans=0;\\n        int j=0,k=0 ,f=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n             if(s[i]==s[i+1])\\n             {\\n                 if(f)\\n                 {\\n                     ans=max(ans,i-j+1);\\n                     j=k;\\n                 }\\n                 f=1;\\n                 k=i+1;\\n             }\\n             //ans=max(ans,i-j+1);\\n\\n        }\\n        k=s.size();\\n        ans=max(ans,k-j);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804039,
                "title": "simple-solution-in-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int longest = -1;\\n        for(int i=1; i<s.length(); i++)\\n        {\\n            int count = 2;\\n            for(int j=i; j<s.length(); j++)\\n            {\\n                if(s.charAt(j-1) == s.charAt(j))\\n                {\\n                    count--;\\n                    int temp = j-i+1;\\n                    if(temp>= longest)\\n                    {\\n                        longest = temp;\\n                    }\\n                }\\n                if(count == 0)\\n                {\\n                    break;\\n                }\\n                \\n            }\\n            if(count != 0)\\n            {\\n                int temp = s.length()-i+1;\\n                if(temp>= longest)\\n                {\\n                    longest = temp;\\n                }\\n            }\\n            \\n        }\\n        if(longest == -1)\\n        {\\n            longest = s.length();\\n        }\\n        return longest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int longest = -1;\\n        for(int i=1; i<s.length(); i++)\\n        {\\n            int count = 2;\\n            for(int j=i; j<s.length(); j++)\\n            {\\n                if(s.charAt(j-1) == s.charAt(j))\\n                {\\n                    count--;\\n                    int temp = j-i+1;\\n                    if(temp>= longest)\\n                    {\\n                        longest = temp;\\n                    }\\n                }\\n                if(count == 0)\\n                {\\n                    break;\\n                }\\n                \\n            }\\n            if(count != 0)\\n            {\\n                int temp = s.length()-i+1;\\n                if(temp>= longest)\\n                {\\n                    longest = temp;\\n                }\\n            }\\n            \\n        }\\n        if(longest == -1)\\n        {\\n            longest = s.length();\\n        }\\n        return longest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797524,
                "title": "two-pointer-approach-very-simple-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        if(n==1) return n;\\n        int i=0,j=1,prev=-1,ans=0;\\n        \\n        while(j<n){\\n            if(s[j]==s[j-1]){\\n                if(prev!=-1) i=prev;\\n                prev=j;\\n            }\\n            ans=max(j-i+1,ans);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        if(n==1) return n;\\n        int i=0,j=1,prev=-1,ans=0;\\n        \\n        while(j<n){\\n            if(s[j]==s[j-1]){\\n                if(prev!=-1) i=prev;\\n                prev=j;\\n            }\\n            ans=max(j-i+1,ans);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782219,
                "title": "python-two-pointer-easy-to-understand-o-n-time-complexity-o-1-space-complexity",
                "content": "# Approach\\nTwo pointers that represent the beginning and ending of the subarray, the left pointer changes whenever we find a new pain on the right pointer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        if len(s) < 3:\\n            return len(s)\\n\\n        pair_found = False\\n        pair_index = None\\n\\n        res = 0\\n        l, r = 0, 1\\n        while l <= r and r < len(s):\\n            if s[r] == s[r-1]:\\n                if pair_found:\\n                    l = pair_index + 1\\n                    pair_index = r-1\\n                else:\\n                    pair_found = True\\n                    pair_index = r-1\\n            res = max(res, r - l + 1)\\n\\n            r += 1\\n        \\n        return res if res else len(s)\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        if len(s) < 3:\\n            return len(s)\\n\\n        pair_found = False\\n        pair_index = None\\n\\n        res = 0\\n        l, r = 0, 1\\n        while l <= r and r < len(s):\\n            if s[r] == s[r-1]:\\n                if pair_found:\\n                    l = pair_index + 1\\n                    pair_index = r-1\\n                else:\\n                    pair_found = True\\n                    pair_index = r-1\\n            res = max(res, r - l + 1)\\n\\n            r += 1\\n        \\n        return res if res else len(s)\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777476,
                "title": "easy-c-solution-2-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans=1;\\n        int i=0;\\n        int j=1;\\n        int n=s.size();\\n        bool found=false;\\n        int ind=-1;\\n        while(j<n){\\n            if(s[j]==s[j-1]){\\n                if(!found){\\n                    found=true;\\n                    ind=j;\\n                 }\\n                else{\\n                    i=ind;\\n                   ind=j;   \\n           }           \\n    }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans=1;\\n        int i=0;\\n        int j=1;\\n        int n=s.size();\\n        bool found=false;\\n        int ind=-1;\\n        while(j<n){\\n            if(s[j]==s[j-1]){\\n                if(!found){\\n                    found=true;\\n                    ind=j;\\n                 }\\n                else{\\n                    i=ind;\\n                   ind=j;   \\n           }           \\n    }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773843,
                "title": "easy-cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string str) {\\n        if(str.size()==1)return 1;\\n        int maxLen = 0;\\n        int i=0;\\n        int j=i+1;\\n        int cnt = 0;\\n        while(i<=j && j<str.size()){\\n            if(str[j]==str[j-1]){\\n                cnt++;\\n                if(cnt>1){\\n                    i++;\\n                    while(str[i]!=str[i-1]){\\n                        i++;\\n                    }\\n                    cnt--;\\n                    maxLen = max(maxLen,j-i+1);\\n                    j++;\\n                }\\n                else{\\n                    maxLen = max(maxLen,j-i+1);\\n                    j++;\\n                }\\n                \\n            }\\n            else{\\n                maxLen = max(maxLen,j-i+1);\\n                j++;\\n            }   \\n        }\\n        return maxLen;\\n    }\\n};\\n\\n/*\\n\"52233\"\\n\"5494\"\\n\"1111111\"\\n\"00101022\"\\n\"1101234883\"\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string str) {\\n        if(str.size()==1)return 1;\\n        int maxLen = 0;\\n        int i=0;\\n        int j=i+1;\\n        int cnt = 0;\\n        while(i<=j && j<str.size()){\\n            if(str[j]==str[j-1]){\\n                cnt++;\\n                if(cnt>1){\\n                    i++;\\n                    while(str[i]!=str[i-1]){\\n                        i++;\\n                    }\\n                    cnt--;\\n                    maxLen = max(maxLen,j-i+1);\\n                    j++;\\n                }\\n                else{\\n                    maxLen = max(maxLen,j-i+1);\\n                    j++;\\n                }\\n                \\n            }\\n            else{\\n                maxLen = max(maxLen,j-i+1);\\n                j++;\\n            }   \\n        }\\n        return maxLen;\\n    }\\n};\\n\\n/*\\n\"52233\"\\n\"5494\"\\n\"1111111\"\\n\"00101022\"\\n\"1101234883\"\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747658,
                "title": "c-sliding-window",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int res = 1, l = 0, n = s.size(), prev = -1;\\n        bool contain = false;\\n        for (int i = 1; i < n; ++ i) {\\n            if (s[i] == s[i - 1]) {\\n                if (contain) {\\n                    res = max(res, i - l);\\n                    if (prev == -1 || (prev + 1 == i - 1 && s[prev] == s[i - 1])) {\\n                        l = prev + 1;\\n                    } else l = prev;\\n                }\\n                prev = i;\\n                contain = true;\\n            }\\n        }\\n        res = max(res, n - l);\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int res = 1, l = 0, n = s.size(), prev = -1;\\n        bool contain = false;\\n        for (int i = 1; i < n; ++ i) {\\n            if (s[i] == s[i - 1]) {\\n                if (contain) {\\n                    res = max(res, i - l);\\n                    if (prev == -1 || (prev + 1 == i - 1 && s[prev] == s[i - 1])) {\\n                        l = prev + 1;\\n                    } else l = prev;\\n                }\\n                prev = i;\\n                contain = true;\\n            }\\n        }\\n        res = max(res, n - l);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738008,
                "title": "easy-c-answer-100-passing-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n=s.size();\\n        if(n==1) return 1;\\n        int j=1;\\n        int i=0;\\n        int ans=0;\\n        bool t=false;\\n        while(j<n){\\n            if(s[j]!=s[j-1]) j++;\\n            else{\\n                if(t==true){\\n                    while(s[i]!=s[i+1]) i++;\\n                    i++;\\n                    j++;\\n                }\\n                else{\\n                    t=true;\\n                    j++;\\n                }\\n            }\\n            ans=max(ans,j-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n=s.size();\\n        if(n==1) return 1;\\n        int j=1;\\n        int i=0;\\n        int ans=0;\\n        bool t=false;\\n        while(j<n){\\n            if(s[j]!=s[j-1]) j++;\\n            else{\\n                if(t==true){\\n                    while(s[i]!=s[i+1]) i++;\\n                    i++;\\n                    j++;\\n                }\\n                else{\\n                    t=true;\\n                    j++;\\n                }\\n            }\\n            ans=max(ans,j-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734748,
                "title": "c-detailed-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n=s.size();\\n        int a=0;\\n        int b=1;\\n        int sum=0;\\n        int ans=0;\\n        while(b<n){\\n            if(s[b]==s[b-1]){\\n                sum++;\\n            }\\n            if(sum>1){\\n                ans=max(ans,b-a);\\n                while(a<n-1&&s[a]!=s[a+1]){\\n                    a++;\\n                }\\n                a=a+1;\\n                sum=1;\\n                \\n            }\\n            ans=max(ans,b-a);\\n            b++;\\n           \\n\\n        }\\n        ans=max(ans,b-a);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n=s.size();\\n        int a=0;\\n        int b=1;\\n        int sum=0;\\n        int ans=0;\\n        while(b<n){\\n            if(s[b]==s[b-1]){\\n                sum++;\\n            }\\n            if(sum>1){\\n                ans=max(ans,b-a);\\n                while(a<n-1&&s[a]!=s[a+1]){\\n                    a++;\\n                }\\n                a=a+1;\\n                sum=1;\\n                \\n            }\\n            ans=max(ans,b-a);\\n            b++;\\n           \\n\\n        }\\n        ans=max(ans,b-a);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733790,
                "title": "sliding-window-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        l = 0\\n        res = 0\\n        dic = defaultdict(int)\\n        count = set()\\n        for r,v in enumerate(s):\\n            dic[v] += 1\\n            if r > 0 and s[r] == s[r - 1]:\\n                count.add((r-1,r))\\n            while len(count) > 1 and l < r:\\n                if dic[s[l]] >= 2:\\n                    count.discard((l,l + 1))\\n                dic[s[l]] -= 1\\n                if not dic[s[l]]:\\n                    del dic[s[l]]\\n                l += 1\\n            res = max(res,r - l + 1)\\n            \\n        return res\\n\\t\\t\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        l = 0\\n        res = 0\\n        dic = defaultdict(int)\\n        count = set()\\n        for r,v in enumerate(s):\\n            dic[v] += 1\\n            if r > 0 and s[r] == s[r - 1]:\\n                count.add((r-1,r))\\n            while len(count) > 1 and l < r:\\n                if dic[s[l]] >= 2:\\n                    count.discard((l,l + 1))\\n                dic[s[l]] -= 1\\n                if not dic[s[l]]:\\n                    del dic[s[l]]\\n                l += 1\\n            res = max(res,r - l + 1)\\n            \\n        return res\\n\\t\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3731182,
                "title": "c-sliding-window-easy-approach-o-n",
                "content": "# Approach\\nThis problem is quite similar to [Longest Subarray of 1\\'s After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/). The approch was simple as it follow the concept of sliding window in which we are maintaining the track of all the consecutive pair of the same digits using the variable `db`.\\nIf there are more than 1 consecutive pair occuring i.e. `db > 1` then we increament the variable `ti` which keeps the track of the beginning of window, until, the consicutive pairs are removed from the window.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ti = 0;\\n        int db = 0;\\n        int mx = 1;\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i] == s[i - 1]) db++;\\n            if (db > 1) {\\n                while  (db > 1 && ti < i) {\\n                    if (s[ti] == s[ti + 1]) db--;\\n                    ti++;\\n                }\\n            }\\n            mx = max(i - ti + 1, mx);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ti = 0;\\n        int db = 0;\\n        int mx = 1;\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i] == s[i - 1]) db++;\\n            if (db > 1) {\\n                while  (db > 1 && ti < i) {\\n                    if (s[ti] == s[ti + 1]) db--;\\n                    ti++;\\n                }\\n            }\\n            mx = max(i - ti + 1, mx);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730108,
                "title": "c-sliding-window-two-pointers-simple-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int left=0;\\n        int right=1;\\n        int ans=INT_MIN;\\n        int count=0;\\n        while(right<s.size()){\\n            if(s[right]==s[right-1]){\\n                count++;\\n            }\\n            if(count==2){\\n                while(count!=1&&left<=right-1){\\n                    if(s[left]==s[left+1]){\\n                        count--;\\n                    }\\n                    left++;\\n                }\\n            }\\n            ans=max(ans,right-left+1);\\n            right++;\\n        }\\n        return ans==INT_MIN?1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int left=0;\\n        int right=1;\\n        int ans=INT_MIN;\\n        int count=0;\\n        while(right<s.size()){\\n            if(s[right]==s[right-1]){\\n                count++;\\n            }\\n            if(count==2){\\n                while(count!=1&&left<=right-1){\\n                    if(s[left]==s[left+1]){\\n                        count--;\\n                    }\\n                    left++;\\n                }\\n            }\\n            ans=max(ans,right-left+1);\\n            right++;\\n        }\\n        return ans==INT_MIN?1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718082,
                "title": "using-ryan-s-approach-simple-c-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2) in worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n\\n        int size = s.length() ;\\n\\n        int i = 0 ;\\n        int j = 1 ;\\n\\n        int ans = 0 , count = 0 ;\\n        int repeat = - 1 ;\\n        int flag = 0 ;\\n\\n        if( size <= 2 )\\n          return size ;\\n\\n        while( j < size){\\n\\n            if( s[ j ] == s[ j - 1 ]  ){\\n\\n                if( flag == 0 ){\\n\\n                   repeat = j - 1 ;\\n                   flag = 1 ;\\n                }\\n                \\n                count++ ;\\n            }\\n\\n            if( count <= 1 ){\\n\\n                ans = max( ans , j - i + 1) ;\\n                j++ ;\\n            }\\n\\n            else if( count > 1 ){\\n\\n                while( count > 1 ){\\n\\n                    if(  i  == repeat ){\\n\\n                       count-- ;\\n                       flag = 0 ;     \\n\\n                       if( s[ j ] == s[ j -1 ]){\\n\\n                           repeat = j -1 ;\\n                           flag = 1 ;\\n                       }                    \\n                    }              \\n\\n                    i++ ;\\n                }\\n\\n                j++ ;\\n            }\\n        }    \\n\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n\\n        int size = s.length() ;\\n\\n        int i = 0 ;\\n        int j = 1 ;\\n\\n        int ans = 0 , count = 0 ;\\n        int repeat = - 1 ;\\n        int flag = 0 ;\\n\\n        if( size <= 2 )\\n          return size ;\\n\\n        while( j < size){\\n\\n            if( s[ j ] == s[ j - 1 ]  ){\\n\\n                if( flag == 0 ){\\n\\n                   repeat = j - 1 ;\\n                   flag = 1 ;\\n                }\\n                \\n                count++ ;\\n            }\\n\\n            if( count <= 1 ){\\n\\n                ans = max( ans , j - i + 1) ;\\n                j++ ;\\n            }\\n\\n            else if( count > 1 ){\\n\\n                while( count > 1 ){\\n\\n                    if(  i  == repeat ){\\n\\n                       count-- ;\\n                       flag = 0 ;     \\n\\n                       if( s[ j ] == s[ j -1 ]){\\n\\n                           repeat = j -1 ;\\n                           flag = 1 ;\\n                       }                    \\n                    }              \\n\\n                    i++ ;\\n                }\\n\\n                j++ ;\\n            }\\n        }    \\n\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712170,
                "title": "python-greedy-o-n",
                "content": "1. Assume that `s` is of the form `...aa...bb...cc...`, then there are 3 possible substrings:\\n`...aa...b`, `a...bb...c`, `b...cc...`.\\n2. Use `idx_1`, `idx_2` to save the indices of the previous 2 pairs of same digits.\\nIn the example above, when we touch the second `c`, at that moment `idx_1` = index of the second `a`, and `idx_2` = index of the second `b`.\\n3. `...aa...b` --> `i - idx_2 + 1`\\n`a...bb...c` --> `i - 1 - idx_1 + 1`\\n`b...cc...` --> `i - idx_1 + 1`\\nWe iterate through the string and compare the length with the final answer `ans` during the iteration.\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        idx_1, idx_2 = 0, 0\\n        ans = 1\\n        for i, c in enumerate(s[1:], start=1):\\n            if c == s[i-1]:\\n                ans = max(ans, i-idx_2+1, i-idx_1)\\n                idx_1, idx_2 = idx_2, i\\n            else:\\n                ans = max(ans, i-idx_1+1)\\n        return ans if idx_2 else len(s)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Assume that `s` is of the form `...aa...bb...cc...`, then there are 3 possible substrings:\\n`...aa...b`, `a...bb...c`, `b...cc...`.\\n2. Use `idx_1`, `idx_2` to save the indices of the previous 2 pairs of same digits.\\nIn the example above, when we touch the second `c`, at that moment `idx_1` = index of the second `a`, and `idx_2` = index of the second `b`.\\n3. `...aa...b` --> `i - idx_2 + 1`\\n`a...bb...c` --> `i - 1 - idx_1 + 1`\\n`b...cc...` --> `i - idx_1 + 1`\\nWe iterate through the string and compare the length with the final answer `ans` during the iteration.\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        idx_1, idx_2 = 0, 0\\n        ans = 1\\n        for i, c in enumerate(s[1:], start=1):\\n            if c == s[i-1]:\\n                ans = max(ans, i-idx_2+1, i-idx_1)\\n                idx_1, idx_2 = idx_2, i\\n            else:\\n                ans = max(ans, i-idx_1+1)\\n        return ans if idx_2 else len(s)",
                "codeTag": "Java"
            },
            {
                "id": 3706164,
                "title": "simple-approach-of-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy see in the question that I had to find a **substring** in which atmost one consecutive same character are present,the idea is come in my mind is variable sliding window.\\n--> I take a variable name flag which is used to count no. of consecutive same characters are present in substring.\\n--> count variable that store the max length substring that satisfy the condition. \\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i =0;\\n        \\n        int n = s.size();\\n        \\n        int j = 1;\\n        \\n        char c = s[0];\\n        \\n        int flag =0;\\n        \\n        int count = 1;\\n        \\n        while(j < n){\\n            if(s[j] != c && flag <= 1){\\n                count = max(count,j-i+1);\\n            }\\n            else if(s[j] == c && flag == 0){\\n                flag++;\\n                count = max(count,j-i+1);\\n            }\\n            \\n            else if(s[j] == c && flag == 1){\\n                while(i < n && s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                if(i == n){\\n                    return count;\\n                }\\n                i = i+1;\\n                \\n                count = max(count,j-i+1); \\n            }\\n            \\n            c = s[j];\\n            j++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i =0;\\n        \\n        int n = s.size();\\n        \\n        int j = 1;\\n        \\n        char c = s[0];\\n        \\n        int flag =0;\\n        \\n        int count = 1;\\n        \\n        while(j < n){\\n            if(s[j] != c && flag <= 1){\\n                count = max(count,j-i+1);\\n            }\\n            else if(s[j] == c && flag == 0){\\n                flag++;\\n                count = max(count,j-i+1);\\n            }\\n            \\n            else if(s[j] == c && flag == 1){\\n                while(i < n && s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                if(i == n){\\n                    return count;\\n                }\\n                i = i+1;\\n                \\n                count = max(count,j-i+1); \\n            }\\n            \\n            c = s[j];\\n            j++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702444,
                "title": "easy-simple-and-fastest-way-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)  // n = size of string\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int repeat = 0;\\n        int repeatIdx = 0;\\n        int start=0, end=1;\\n        int res = 0;\\n        while(end<s.size()) {\\n            if(s[end] == s[end-1] && repeat == 0){\\n                repeat = 1;\\n                repeatIdx = end;\\n            }\\n            else if(s[end] == s[end-1] && repeat == 1){\\n                start = repeatIdx;\\n                repeatIdx = end;\\n            }\\n            res = max(res, end-start+1);\\n            end++;\\n        }\\n\\n        if(repeat == 0) res = end;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int repeat = 0;\\n        int repeatIdx = 0;\\n        int start=0, end=1;\\n        int res = 0;\\n        while(end<s.size()) {\\n            if(s[end] == s[end-1] && repeat == 0){\\n                repeat = 1;\\n                repeatIdx = end;\\n            }\\n            else if(s[end] == s[end-1] && repeat == 1){\\n                start = repeatIdx;\\n                repeatIdx = end;\\n            }\\n            res = max(res, end-start+1);\\n            end++;\\n        }\\n\\n        if(repeat == 0) res = end;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702237,
                "title": "rust-recording-last-two-repeating-positions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn longest_semi_repetitive_substring(s: String) -> i32 {\\n        let s = s.chars().into_iter().collect::<Vec<char>>();\\n        let n = s.len();\\n        let (mut k1, mut k2, mut ret) = (0, 0, 1);\\n\\n        for i in 0 .. n {\\n            if i + 1 < n && s[i] != s[i + 1] { continue }\\n            \\n            ret = ret.max(i as i32 - k1 as i32 + 1);\\n            k1 = k2;\\n            k2 = i + 1;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_semi_repetitive_substring(s: String) -> i32 {\\n        let s = s.chars().into_iter().collect::<Vec<char>>();\\n        let n = s.len();\\n        let (mut k1, mut k2, mut ret) = (0, 0, 1);\\n\\n        for i in 0 .. n {\\n            if i + 1 < n && s[i] != s[i + 1] { continue }\\n            \\n            ret = ret.max(i as i32 - k1 as i32 + 1);\\n            k1 = k2;\\n            k2 = i + 1;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3701606,
                "title": "python-simple-9-liner-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe traverse through the string with a for-loop where `left` is the start of the substring and the current index (`right`) is the end of the substring.\\n\\nSince there can only be one pair in the substring, when we traverse the string and encounter another pair, we know that the substring is no longer valid. So, to validate it again, we move the start of the substring to index of the last seen pair `left = last_pair` and set the index of the last seen pair to be the end of the substring `last_pair = right`.\\n\\nNote: a pair in the problem is defined as a consecutive string where `s[i - 1] == s[i]`.\\n\\nSince, `left` and `right` define where the substring starts and ends, the length of the substring is `right - left + 1`. We keep track of the longest substring by assigning `longest` to `max(longest, right - left, 1)`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```py\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        left = last_pair = 0\\n        longest = 1\\n        for right in range(1, len(s)):\\n            if s[right - 1] == s[right]:\\n                left, last_pair = last_pair, right\\n            longest = max(longest, right - left + 1)\\n        return longest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        left = last_pair = 0\\n        longest = 1\\n        for right in range(1, len(s)):\\n            if s[right - 1] == s[right]:\\n                left, last_pair = last_pair, right\\n            longest = max(longest, right - left + 1)\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699999,
                "title": "sliding-window-c",
                "content": "sliding window concept \\nmaintain two pointer l and r such that max number of such pairs are less than or equal to one otherwise update l \\n\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int l=0;\\n        int r=0;\\n        int co=0;\\n        char prev=\\'!\\';\\n        int n=s.size();\\n        int ans=0;\\n        while(r<n)\\n        {\\n          \\n            if(prev!=\\'!\\' && prev==s[r]) co++;  // increment counter\\n            \\n            while(co>1) // move l pointer \\n            {\\n                if(l+1<r && s[l]==s[l+1]) co--;\\n                l++;\\n            }\\n            \\n            ans= max(ans, r-l+1);\\n            prev=s[r];\\n            r++;\\n        }\\n        \\n        return ans;\\n         \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int l=0;\\n        int r=0;\\n        int co=0;\\n        char prev=\\'!\\';\\n        int n=s.size();\\n        int ans=0;\\n        while(r<n)\\n        {\\n          \\n            if(prev!=\\'!\\' && prev==s[r]) co++;  // increment counter\\n            \\n            while(co>1) // move l pointer \\n            {\\n                if(l+1<r && s[l]==s[l+1]) co--;\\n                l++;\\n            }\\n            \\n            ans= max(ans, r-l+1);\\n            prev=s[r];\\n            r++;\\n        }\\n        \\n        return ans;\\n         \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698389,
                "title": "easy-to-understand-stack-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to add chars to a stack until we run into the second occurance of Semi-R, and in the meantime the size of the stack needs to be checked if it\\'s bigger than recorded max. \\nOnce we run into the second occurence of Semi-R, we need to remove elements from bottom of the stack until we hit the first Semi-R occurence, and remove one of its elements too. \\n\\n# Complexity\\n- Time complexity: O(n) - we only go through the string once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) - there is an extra stack created\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        Stack<Character> st = new Stack<>();\\n        st.push(s.charAt(0)); // put first element into the stack\\n        int ans = 1; // since there is already one element in the stack, ans at least 1\\n        boolean alreadyOccurence = false;\\n\\n        for(int i = 1; i < s.length(); i++) {\\n            char curr = s.charAt(i);\\n            if (st.peek() == curr) { // When Semi-R Occurence Found\\n                if (alreadyOccurence) { // already one occurence exists in stack\\n                    char remove = st.remove(0);\\n                    while(st.get(0) != remove) { // remove the elements from left side to remove previous occurence and put the current index character which makes one occurence again\\n                        remove = st.remove(0);\\n                    }\\n                } else { // first occurence detected\\n                    alreadyOccurence = true;\\n                }\\n            }\\n\\n            st.push(curr);\\n            ans = Math.max(ans, st.size());\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        Stack<Character> st = new Stack<>();\\n        st.push(s.charAt(0)); // put first element into the stack\\n        int ans = 1; // since there is already one element in the stack, ans at least 1\\n        boolean alreadyOccurence = false;\\n\\n        for(int i = 1; i < s.length(); i++) {\\n            char curr = s.charAt(i);\\n            if (st.peek() == curr) { // When Semi-R Occurence Found\\n                if (alreadyOccurence) { // already one occurence exists in stack\\n                    char remove = st.remove(0);\\n                    while(st.get(0) != remove) { // remove the elements from left side to remove previous occurence and put the current index character which makes one occurence again\\n                        remove = st.remove(0);\\n                    }\\n                } else { // first occurence detected\\n                    alreadyOccurence = true;\\n                }\\n            }\\n\\n            st.push(curr);\\n            ans = Math.max(ans, st.size());\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696171,
                "title": "c-sollution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int res=0, n=s.size(),cnt=0;\\n        for(int i=0,j=0;i<n;i++){\\n            if((s.substr(i,2))[0]==(s.substr(i,2))[1]){\\n               cnt++;\\n            }\\n            res=max(res,i-j+1);\\n            while(cnt>1){\\n                if(j<n-1 and (s.substr(j,2))[0]==(s.substr(j,2))[1]){\\n                    cnt--;\\n                }\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int res=0, n=s.size(),cnt=0;\\n        for(int i=0,j=0;i<n;i++){\\n            if((s.substr(i,2))[0]==(s.substr(i,2))[1]){\\n               cnt++;\\n            }\\n            res=max(res,i-j+1);\\n            while(cnt>1){\\n                if(j<n-1 and (s.substr(j,2))[0]==(s.substr(j,2))[1]){\\n                    cnt--;\\n                }\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693109,
                "title": "python-solution-based-on-hints-given",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    max_dist=-1\\n    def longestSemiRepetitiveSubstring(self, nums: str) -> int: \\n        if len(nums)<=2:\\n            return len(nums)\\n        def calcLen(nums):\\n            count=0\\n            begin=0\\n            for i in range(1,len(nums)):\\n                if nums[i-1]==nums[i]:\\n                    count+=1\\n                    if count==1:\\n                        begin=i\\n                if count!=2:\\n                    self.max_dist=max(self.max_dist,len(nums[:i])+1)\\n                if count==2: \\n                    calcLen(nums[begin:])\\n                    break       \\n        calcLen(nums)    \\n        return self.max_dist\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    max_dist=-1\\n    def longestSemiRepetitiveSubstring(self, nums: str) -> int: \\n        if len(nums)<=2:\\n            return len(nums)\\n        def calcLen(nums):\\n            count=0\\n            begin=0\\n            for i in range(1,len(nums)):\\n                if nums[i-1]==nums[i]:\\n                    count+=1\\n                    if count==1:\\n                        begin=i\\n                if count!=2:\\n                    self.max_dist=max(self.max_dist,len(nums[:i])+1)\\n                if count==2: \\n                    calcLen(nums[begin:])\\n                    break       \\n        calcLen(nums)    \\n        return self.max_dist\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689421,
                "title": "c-o-n-solution-using-sliding-window-and-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i = 0, j = 1;\\n\\n        int pairs = 0;\\n        int result = 0;\\n\\n        int first_pair_init = -1;\\n\\n        while (j < s.length()) {\\n            if (s[j] == s[j - 1]) {\\n                pairs++;\\n\\n                if (pairs == 1) {\\n                    first_pair_init = j - 1;\\n                }\\n\\n                if (pairs > 1) {\\n                    result = max(result, j - i);\\n                    i = first_pair_init + 1;\\n                    pairs = 1;\\n                    first_pair_init = j - 1;\\n                }\\n            }\\n            j++;\\n        }\\n\\n        result = max(result, j - i);\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i = 0, j = 1;\\n\\n        int pairs = 0;\\n        int result = 0;\\n\\n        int first_pair_init = -1;\\n\\n        while (j < s.length()) {\\n            if (s[j] == s[j - 1]) {\\n                pairs++;\\n\\n                if (pairs == 1) {\\n                    first_pair_init = j - 1;\\n                }\\n\\n                if (pairs > 1) {\\n                    result = max(result, j - i);\\n                    i = first_pair_init + 1;\\n                    pairs = 1;\\n                    first_pair_init = j - 1;\\n                }\\n            }\\n            j++;\\n        }\\n\\n        result = max(result, j - i);\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681556,
                "title": "2730-find-the-longest-semi-repetitive-substring-using-two-pointer",
                "content": "# Intuition\\ncheck string for substring till second pair of duplicate elements is found and compare it with already stored max length;\\n\\n# Approach\\ncheck string for longest substring from every element using j for loop and checking for substring from that index to last of array using i loop when suitable substring found compare its size with maxlen for maximum length using max function.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int maxlen=INT_MIN;\\n        for(int j=0;j<s.length();j++)\\n        {\\n            int flag=0;\\n            for(int i=j;i<s.length();i++)\\n                {\\n                if(s[i]==s[i+1]&&flag==0)\\n                {\\n                    flag=1;\\n                }\\n                else if(s[i]==s[i+1]&&flag==1)\\n                {\\n                    maxlen=max(maxlen,i-j+1);\\n                    break;\\n                }\\n                maxlen=max(maxlen,i-j+1);\\n            }\\n        }\\n        return maxlen;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int maxlen=INT_MIN;\\n        for(int j=0;j<s.length();j++)\\n        {\\n            int flag=0;\\n            for(int i=j;i<s.length();i++)\\n                {\\n                if(s[i]==s[i+1]&&flag==0)\\n                {\\n                    flag=1;\\n                }\\n                else if(s[i]==s[i+1]&&flag==1)\\n                {\\n                    maxlen=max(maxlen,i-j+1);\\n                    break;\\n                }\\n                maxlen=max(maxlen,i-j+1);\\n            }\\n        }\\n        return maxlen;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678306,
                "title": "simple-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        if(s.length()<3)\\n            return s.length();\\n        int ans=0,cnt=0,p=0;\\n        for(int l=0,i=1;i<s.length();++i){\\n            if(s[i]==s[i-1]){\\n                ++cnt;\\n                l=p;\\n                p=i;\\n            }\\n            ans=max(ans,i-l+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        if(s.length()<3)\\n            return s.length();\\n        int ans=0,cnt=0,p=0;\\n        for(int l=0,i=1;i<s.length();++i){\\n            if(s[i]==s[i-1]){\\n                ++cnt;\\n                l=p;\\n                p=i;\\n            }\\n            ans=max(ans,i-l+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671431,
                "title": "simply-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->We start by initializing an empty set, sets, which will store pairs of indices where consecutive characters are the same.\\n\\nWe iterate over the string s using the index i up to the second-to-last character. If s[i] is equal to s[i+1], it means we have found a pair of consecutive characters that are the same. We add this pair of indices (i, i+1) to the sets set.\\n\\nWe initialize a variable pairs to 0, which will store the length of the longest semi-repetitive substring found.\\n\\nFor each pair of indices (i, j) in sets, we expand the substring to the left and right to find the longest semi-repetitive substring centered at this pair.\\n\\nWe decrement i and increment j to expand the substring. While i is greater than or equal to 0 and s[i] is different from s[i+1], we continue expanding to the left by decrementing i and incrementing the counter variable.\\n\\nSimilarly, while j is less than the length of s and s[j] is different from s[j-1], we continue expanding to the right by incrementing j and incrementing the counter variable.\\n\\nAfter expanding the substring, we update pairs to be the maximum value between pairs and 2 + counter, which represents the length of the semi-repetitive substring centered at the current pair.\\n\\nFinally, we return pairs if it is not zero (indicating a semi-repetitive substring was found), otherwise, we return the length of the input string s.\\n\\nThis approach finds all pairs of consecutive characters that are the same and expands around them to find the longest semi-repetitive substring. It has a time complexity of O(n), where n is the length of the input string s.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s):\\n        sets = set()\\n\\n        for i in range(len(s) - 1):\\n            if s[i] == s[i + 1]:\\n                sets.add((i, i + 1))\\n        pairs = 0\\n        for i, j in sets:\\n            i -= 1\\n            j += 1\\n            counter = 0\\n            while i >= 0 and s[i] != s[i + 1]:\\n                i -= 1\\n                counter += 1\\n\\n            while j < len(s) and s[j] != s[j - 1]:\\n                j += 1\\n                counter += 1\\n            pairs = max(pairs, 2 + counter)\\n        return pairs if pairs else len(s)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s):\\n        sets = set()\\n\\n        for i in range(len(s) - 1):\\n            if s[i] == s[i + 1]:\\n                sets.add((i, i + 1))\\n        pairs = 0\\n        for i, j in sets:\\n            i -= 1\\n            j += 1\\n            counter = 0\\n            while i >= 0 and s[i] != s[i + 1]:\\n                i -= 1\\n                counter += 1\\n\\n            while j < len(s) and s[j] != s[j - 1]:\\n                j += 1\\n                counter += 1\\n            pairs = max(pairs, 2 + counter)\\n        return pairs if pairs else len(s)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667279,
                "title": "c-2pointer-greedy-solution-98-time-8ms-75-space-6-3mb",
                "content": "Handbook case for using two pointers here: we will proceed advancing a first pointer and adding character in a greedy way to our interval until we get more than one duplicated character; after that, we will advance the second pointer until we have removed one duplicate and so on, up to the end of the string.\\n\\nTo do so, we will start declaring a few support variables:\\n* `res` is our usual accumulator variable, storing the largest result found so far - initially set to `0`;\\n* `i` and `j` are going to be our pointers, initially set to point at the first (index `0`) and second (index `1`) element;\\n* `len` will store the lenght of our input;\\n* `dups` will count how many duplicates we found, initially set to be `0`.\\n\\nWe will then keep parsing `s` `while` `j < len` and:\\n* whenver we find a duplicated character (ie: `s[j - 1] == s[j]`), we will increase `dups` by `1`;\\n* `while` we have `2` `dups`, we will:\\n    * decrease `dups` by `1` whenver we found a duplicated character with `i` (ie: `s[i - 1] == s[i]`);\\n    * advance `i` by `1`;\\n* advance `j` by `1` (so that it will be on the cell right after the last one we parsed);\\n* update `res` to the the maximum between its curreny value and the size of the interval we are considering, whose size is `j - i`.\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity:. $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        // support variables\\n        int res = 1, i = 0, j = 1, len = s.size(), dups = 0;\\n        // parsing s\\n        while (j < len) {\\n            // duplicate found\\n            if (s[j - 1] == s[j]) dups++;\\n            // advancing i when we have 2 dups\\n            while (dups > 1) {\\n                if (s[i] == s[i + 1]) dups--;\\n                i++;\\n            }\\n            // updating res and preparing for a new loop\\n            res = max(res, ++j - i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAlternative version replacing `dups` with a boolean flag (`hasDups`), just for fun:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        // support variables\\n        int res = 1, i = 0, j = 1, len = s.size();\\n        bool hasDups = false;\\n        // parsing s\\n        while (j < len) {\\n            // duplicate found\\n            if (s[j - 1] == s[j]) {\\n                // advancing i to remove any possible previous duplicate\\n                while (hasDups) {\\n                    if (s[i] == s[i + 1]) hasDups = false;\\n                    i++;\\n                }\\n                hasDups = true;\\n            }\\n            // updating res and preparing for a new loop\\n            res = max(res, ++j - i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        // support variables\\n        int res = 1, i = 0, j = 1, len = s.size(), dups = 0;\\n        // parsing s\\n        while (j < len) {\\n            // duplicate found\\n            if (s[j - 1] == s[j]) dups++;\\n            // advancing i when we have 2 dups\\n            while (dups > 1) {\\n                if (s[i] == s[i + 1]) dups--;\\n                i++;\\n            }\\n            // updating res and preparing for a new loop\\n            res = max(res, ++j - i);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        // support variables\\n        int res = 1, i = 0, j = 1, len = s.size();\\n        bool hasDups = false;\\n        // parsing s\\n        while (j < len) {\\n            // duplicate found\\n            if (s[j - 1] == s[j]) {\\n                // advancing i to remove any possible previous duplicate\\n                while (hasDups) {\\n                    if (s[i] == s[i + 1]) hasDups = false;\\n                    i++;\\n                }\\n                hasDups = true;\\n            }\\n            // updating res and preparing for a new loop\\n            res = max(res, ++j - i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666924,
                "title": "beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        n = len(s)\\n        if n < 3:\\n            return n\\n\\n        start = 0\\n        end = 1\\n        prev = s[0]\\n        res = 0\\n        last = -1\\n        while end < n:\\n            curr = s[end]\\n            if curr == prev:\\n                if last != -1:\\n                    length = end - start\\n                    res = max(res, length)\\n                    start = last\\n                last = end\\n            prev = curr\\n            end += 1\\n        res = max(res, end - start)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        n = len(s)\\n        if n < 3:\\n            return n\\n\\n        start = 0\\n        end = 1\\n        prev = s[0]\\n        res = 0\\n        last = -1\\n        while end < n:\\n            curr = s[end]\\n            if curr == prev:\\n                if last != -1:\\n                    length = end - start\\n                    res = max(res, length)\\n                    start = last\\n                last = end\\n            prev = curr\\n            end += 1\\n        res = max(res, end - start)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666136,
                "title": "sliding-window-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        if(n<3)\\n            return n;\\n        int i = 0;\\n        int j = 0;\\n        int c = 0;\\n        int maxi = 0;\\n        while(j<n-1){\\n            if(s[j]==s[j+1]){\\n                c++;\\n            }\\n            if(c<=1){\\n                maxi = max(maxi,j-i+2);\\n            }\\n            else if(c>1){\\n                while(c>1){\\n                    if(s[i]==s[i+1])\\n                        c--;\\n                    i++;\\n                }\\n                if(c<=1)\\n                    maxi = max(maxi,j-i+2);\\n            }\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        if(n<3)\\n            return n;\\n        int i = 0;\\n        int j = 0;\\n        int c = 0;\\n        int maxi = 0;\\n        while(j<n-1){\\n            if(s[j]==s[j+1]){\\n                c++;\\n            }\\n            if(c<=1){\\n                maxi = max(maxi,j-i+2);\\n            }\\n            else if(c>1){\\n                while(c>1){\\n                    if(s[i]==s[i+1])\\n                        c--;\\n                    i++;\\n                }\\n                if(c<=1)\\n                    maxi = max(maxi,j-i+2);\\n            }\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664887,
                "title": "simple-hindi-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsuppose karo ki tumhare paas ek string h \"522334567\"\\nab i=0 mano aur j ko i+1 mano\\nek variable k rakho pichla smae pair track karne ke liye\\nab jab maine 22 le liya aur 33 lene gaya to 22 aur 33 ek hi string mei nhi aa sakte\\n22 se left wali string se ab humara nata khatam\\n22 mei ek right wala 2 rakh lo aur baaki saari string discard kar do\\nab mereko sirf 2334567 se lena dena h\\nab isme wapis se wahi algo lagao\\nek boolean hoga jo batayega ki ek same pair aaya h ya nahi\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        if(s.length()==1)\\n        return 1;\\n        int i = 0;\\n        int j=1;\\n        int k;\\n        bool flag = false;\\n        int ans = INT_MIN;\\n        while(j<s.length())\\n        {\\n            if(s[j]!=s[j-1])\\n            {\\n                j++;\\n            }\\n            else if(s[j]==s[j-1] && flag==false)\\n            {\\n                flag = true;\\n                k = j;\\n                j++;\\n            }\\n            else if(s[j]==s[j-1] && flag==true)\\n            {\\n                ans = max(ans,j-i);\\n                i = k;\\n                j = i+1;\\n                flag = false;\\n            }\\n\\n        }\\n        ans = max(ans,j-i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        if(s.length()==1)\\n        return 1;\\n        int i = 0;\\n        int j=1;\\n        int k;\\n        bool flag = false;\\n        int ans = INT_MIN;\\n        while(j<s.length())\\n        {\\n            if(s[j]!=s[j-1])\\n            {\\n                j++;\\n            }\\n            else if(s[j]==s[j-1] && flag==false)\\n            {\\n                flag = true;\\n                k = j;\\n                j++;\\n            }\\n            else if(s[j]==s[j-1] && flag==true)\\n            {\\n                ans = max(ans,j-i);\\n                i = k;\\n                j = i+1;\\n                flag = false;\\n            }\\n\\n        }\\n        ans = max(ans,j-i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660972,
                "title": "c-brute-force-two-pointer-better-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the constraints is small, we can solve it by brute-force appraoch on `N^2`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- `Outer loop i` Iterate over each character. It\\'s a beginning of substring from which we get `max` susbstring with only at most 1 duplicate pairs. \\n- `Inner loop j` Go forward from `i` to `j` and count duplicate pairs. if it\\'s equal `2` just stop count for current `i...j` substring\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s) {\\n        int max = 1;\\n\\n        for (int i = 0; i < s.Length; i++) {\\n            int cnt = 0;\\n            for (int j = i + 1; j < s.Length; j++) {\\n                if (s[j] == s[j - 1]) cnt++;\\n                if (cnt == 2) break;\\n\\n                max = Math.Max(max, j - i + 1);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n```\\n\\n# Approach #2, Two pointer\\nIdea is the same for `i`, `j` and `cnt`, but better time complexity as we iterate at most `2*N`. \\n`i, j` as are window, increase `i, j` by the `count` state\\n```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s) {\\n        int max = 1;\\n        int i = 0, j = i + 1;\\n        int cnt = 0;\\n\\n        while (j < s.Length) {\\n            if (s[j] == s[j - 1]) {\\n                cnt++;\\n            }\\n\\n            if (cnt == 2) {\\n                while (i + 1 < s.Length && s[i] != s[i + 1]) {\\n                    i++;\\n                }\\n                i++;\\n                cnt--;\\n            }\\n\\n            max = Math.Max(max, j - i + 1);\\n            j++;\\n        }\\n\\n        return max;\\n    }\\n}\\n```\\n\\n# Approach #3, Two pointer from @kreakEmp solution\\n`i, j` as substring window length.\\n`last` - used to store the last equal position `(s[j] == s[j - 1])`. And update `i` to previous `last` after one duplication skipped\\n\\n```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s) {\\n        int max = 1;\\n        int i = 0, j = i + 1;\\n        int last = 0;\\n\\n        while (j < s.Length) {\\n            if (s[j] == s[j - 1]) {\\n                if (last > 0) i = last;\\n                last = j;\\n            }\\n\\n            max = Math.Max(max, j - i + 1);\\n            j++;\\n        }\\n\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s) {\\n        int max = 1;\\n\\n        for (int i = 0; i < s.Length; i++) {\\n            int cnt = 0;\\n            for (int j = i + 1; j < s.Length; j++) {\\n                if (s[j] == s[j - 1]) cnt++;\\n                if (cnt == 2) break;\\n\\n                max = Math.Max(max, j - i + 1);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s) {\\n        int max = 1;\\n        int i = 0, j = i + 1;\\n        int cnt = 0;\\n\\n        while (j < s.Length) {\\n            if (s[j] == s[j - 1]) {\\n                cnt++;\\n            }\\n\\n            if (cnt == 2) {\\n                while (i + 1 < s.Length && s[i] != s[i + 1]) {\\n                    i++;\\n                }\\n                i++;\\n                cnt--;\\n            }\\n\\n            max = Math.Max(max, j - i + 1);\\n            j++;\\n        }\\n\\n        return max;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s) {\\n        int max = 1;\\n        int i = 0, j = i + 1;\\n        int last = 0;\\n\\n        while (j < s.Length) {\\n            if (s[j] == s[j - 1]) {\\n                if (last > 0) i = last;\\n                last = j;\\n            }\\n\\n            max = Math.Max(max, j - i + 1);\\n            j++;\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649161,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int LongestSemiRepetitiveSubstring(string s)\\n    {\\n        int start = 0, maxLen = 1;\\n        bool pairExist = false;\\n        for(int i = 1; i < s.Length; i++)\\n        {\\n            if(s[i]==s[i-1])\\n            {\\n                if(pairExist)\\n                {\\n                    //remove first pair\\n                    while(s[start]!=s[start+1])\\n                        start++;\\n                    start++;\\n                    \\n                    continue;\\n                }\\n                pairExist = true;\\n            }\\n            int len = i-start+1;\\n            if(len > maxLen)\\n                maxLen = len;\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int LongestSemiRepetitiveSubstring(string s)\\n    {\\n        int start = 0, maxLen = 1;\\n        bool pairExist = false;\\n        for(int i = 1; i < s.Length; i++)\\n        {\\n            if(s[i]==s[i-1])\\n            {\\n                if(pairExist)\\n                {\\n                    //remove first pair\\n                    while(s[start]!=s[start+1])\\n                        start++;\\n                    start++;\\n                    \\n                    continue;\\n                }\\n                pairExist = true;\\n            }\\n            int len = i-start+1;\\n            if(len > maxLen)\\n                maxLen = len;\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648046,
                "title": "easy-understanding-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n      int left = 0;\\n        int count = 0;\\n        int maxLen = 1;\\n\\n        for(int right=0; right<s.length(); right++){\\n            if(right>0 && s.charAt(right-1)==s.charAt(right)){\\n                count++;\\n            }\\n\\n            while(count>1){\\n                if(right>left && s.charAt(left)==s.charAt(left+1)){\\n                    count--;\\n                }\\n                left++;\\n            }\\n            maxLen=Math.max(maxLen,right-left+1);\\n        }\\n        return maxLen;\\n}\\n}\\n```\"UPVOTE IF YOU LIKE THIS SOLUTION!!!\"",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n      int left = 0;\\n        int count = 0;\\n        int maxLen = 1;\\n\\n        for(int right=0; right<s.length(); right++){\\n            if(right>0 && s.charAt(right-1)==s.charAt(right)){\\n                count++;\\n            }\\n\\n            while(count>1){\\n                if(right>left && s.charAt(left)==s.charAt(left+1)){\\n                    count--;\\n                }\\n                left++;\\n            }\\n            maxLen=Math.max(maxLen,right-left+1);\\n        }\\n        return maxLen;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646198,
                "title": "just-3-easy-conditions-if-else",
                "content": "# Intuition \\nUnderstanding the question was tricky, you would have to do multiple tc run in order to get it.\\n# Approach\\nBased on 3 conditions only.\\n\\n# Complexity\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0; i<s.length(); i++){\\n            boolean getOut = false;\\n            char p1= \\' \\';\\n            for(int j=i; j<s.length(); j++){\\n                char ch = s.charAt(j);\\n                if(j!=i && !getOut &&  ch == s.charAt(j-1)){ //tries to create a pair\\n                    p1= ch;\\n                    getOut=true;\\n                }else if(getOut && ch == p1 && ch == s.charAt(j-1)){// checks if we have found same character 3 times in a row. \\nbreak;\\n}\\n                if(getOut && ch != p1 && ch == s.charAt(j-1)) break; // checks if we have found another pair or not in order to terminate immediately\\n\\n\\n                max = Math.max(max, j-i+1);\\n            }\\n\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0; i<s.length(); i++){\\n            boolean getOut = false;\\n            char p1= \\' \\';\\n            for(int j=i; j<s.length(); j++){\\n                char ch = s.charAt(j);\\n                if(j!=i && !getOut &&  ch == s.charAt(j-1)){ //tries to create a pair\\n                    p1= ch;\\n                    getOut=true;\\n                }else if(getOut && ch == p1 && ch == s.charAt(j-1)){// checks if we have found same character 3 times in a row. \\nbreak;\\n}\\n                if(getOut && ch != p1 && ch == s.charAt(j-1)) break; // checks if we have found another pair or not in order to terminate immediately\\n\\n\\n                max = Math.max(max, j-i+1);\\n            }\\n\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643598,
                "title": "c-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i=0,j=1,n=size(s),pv=-1,mx=1;\\n        while(j<n){\\n            if(s[j]==s[j-1]){\\n                if(pv!=-1)i=pv;\\n                pv=j;\\n            }\\n            mx=max(mx,j-i+1);\\n            ++j;\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i=0,j=1,n=size(s),pv=-1,mx=1;\\n        while(j<n){\\n            if(s[j]==s[j-1]){\\n                if(pv!=-1)i=pv;\\n                pv=j;\\n            }\\n            mx=max(mx,j-i+1);\\n            ++j;\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642966,
                "title": "sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int maxi = 0;\\n        int n = s.size();\\n        bool found = false;\\n        int l = 0;\\n        if(n<=2) return n;\\n        for(int i = 1;i<n;i++)\\n        {\\n            if(!found&&(s[i-1]==s[i]))\\n            {\\n                found = true;\\n                maxi = max(maxi,i-l+1);\\n            }\\n            else if(found&&s[i-1]==s[i])\\n            {\\n                maxi = max(maxi,i-l);\\n                while(l<n)\\n                {\\n                    if(s[l]==s[l+1])\\n                    {\\n                        l++;\\n                        break;\\n                    }\\n                    l++;\\n                }\\n            }\\n            else\\n            {\\n            maxi = max(maxi,i-l+1);\\n            }\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int maxi = 0;\\n        int n = s.size();\\n        bool found = false;\\n        int l = 0;\\n        if(n<=2) return n;\\n        for(int i = 1;i<n;i++)\\n        {\\n            if(!found&&(s[i-1]==s[i]))\\n            {\\n                found = true;\\n                maxi = max(maxi,i-l+1);\\n            }\\n            else if(found&&s[i-1]==s[i])\\n            {\\n                maxi = max(maxi,i-l);\\n                while(l<n)\\n                {\\n                    if(s[l]==s[l+1])\\n                    {\\n                        l++;\\n                        break;\\n                    }\\n                    l++;\\n                }\\n            }\\n            else\\n            {\\n            maxi = max(maxi,i-l+1);\\n            }\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642248,
                "title": "intuitive-approach-beats-96",
                "content": "# Intuition\\n1. Scan the string and find all the pairs, keep the indexes in a list\\n2. Scan the indexes list and compute the length\\n\\nIf you like it please vote!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        n = len(s)\\n        if n < 3:\\n            return n\\n        pairs_idx = []\\n        for i in range(n-1):\\n            if s[i] == s[i+1]:\\n                pairs_idx.append(i)\\n        m = len(pairs_idx)\\n        if m < 2:\\n            return n\\n        r = pairs_idx[1] + 1\\n        for i in range(m):\\n            if i + 2 < m:\\n                d = pairs_idx[i+2] - pairs_idx[i]\\n                r = max(d, r)\\n        r = max(r, n - pairs_idx[-2] -1)\\n        return r\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        n = len(s)\\n        if n < 3:\\n            return n\\n        pairs_idx = []\\n        for i in range(n-1):\\n            if s[i] == s[i+1]:\\n                pairs_idx.append(i)\\n        m = len(pairs_idx)\\n        if m < 2:\\n            return n\\n        r = pairs_idx[1] + 1\\n        for i in range(m):\\n            if i + 2 < m:\\n                d = pairs_idx[i+2] - pairs_idx[i]\\n                r = max(d, r)\\n        r = max(r, n - pairs_idx[-2] -1)\\n        return r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642231,
                "title": "easy-python-code-better-understanding",
                "content": "# Intuition \\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        res=0\\n        tab=[1]\\n        for i in range(1,len(s)):\\n            if ( s[i]==s[i-1]):\\n                tab.append(1)\\n            else:\\n                tab[-1]=tab[-1]+1\\n        for j in range(1,len(tab)):\\n            res=max(res,tab[j]+tab[j-1])\\n        \\n        return max(res,tab[0])\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        res=0\\n        tab=[1]\\n        for i in range(1,len(s)):\\n            if ( s[i]==s[i-1]):\\n                tab.append(1)\\n            else:\\n                tab[-1]=tab[-1]+1\\n        for j in range(1,len(tab)):\\n            res=max(res,tab[j]+tab[j-1])\\n        \\n        return max(res,tab[0])\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640301,
                "title": "easy-cpp-solution-using-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string arr) {\\n        int ans=0;\\n        int i=0,j=0;\\n        int n=arr.size();\\n        int count=0;\\n        while(j<n-1){\\n            if(arr[j]==arr[j+1]){\\n                count++;\\n            }\\n            j++;\\n            if(count<=1){\\n                ans=max(ans,j-i+1);\\n            }else{\\n                while(i<j and count>1){\\n                    if(arr[i]==arr[i+1]){\\n                        count--;  \\n                    }\\n                    i++;\\n                }\\n            }\\n        }\\n        if(ans==0)return n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string arr) {\\n        int ans=0;\\n        int i=0,j=0;\\n        int n=arr.size();\\n        int count=0;\\n        while(j<n-1){\\n            if(arr[j]==arr[j+1]){\\n                count++;\\n            }\\n            j++;\\n            if(count<=1){\\n                ans=max(ans,j-i+1);\\n            }else{\\n                while(i<j and count>1){\\n                    if(arr[i]==arr[i+1]){\\n                        count--;  \\n                    }\\n                    i++;\\n                }\\n            }\\n        }\\n        if(ans==0)return n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636985,
                "title": "sliding-window-concept-100-memory-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int max(int a, int b)\\n    {\\n        if(a>b)return a;\\n        return b;\\n    }\\n\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int start = 0;  //starting of sliding window//\\n        int ans = 0;     // that is length of the window maximum length//\\n\\n        int cnt = 0;     // will count pairs  if( cnt == 1) that means we already have one pair and we dont need another one so we will update ans, start,ans pos//\\n        \\n        int pos = 0;     // end of sliding window //\\n        for(int i = 1; i <  s.size() ;i++)\\n        {\\n            if(s[i] == s[i-1] && cnt == 1)\\n            {\\n                ans = max(ans,i - start);\\n                start = pos;\\n                pos = i;\\n            }\\n            else if(s[i] == s[i-1])\\n            {\\n                pos = i;\\n                cnt++;\\n            }\\n        }\\n        ans = max(ans,s.size() - start);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int max(int a, int b)\\n    {\\n        if(a>b)return a;\\n        return b;\\n    }\\n\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int start = 0;  //starting of sliding window//\\n        int ans = 0;     // that is length of the window maximum length//\\n\\n        int cnt = 0;     // will count pairs  if( cnt == 1) that means we already have one pair and we dont need another one so we will update ans, start,ans pos//\\n        \\n        int pos = 0;     // end of sliding window //\\n        for(int i = 1; i <  s.size() ;i++)\\n        {\\n            if(s[i] == s[i-1] && cnt == 1)\\n            {\\n                ans = max(ans,i - start);\\n                start = pos;\\n                pos = i;\\n            }\\n            else if(s[i] == s[i-1])\\n            {\\n                pos = i;\\n                cnt++;\\n            }\\n        }\\n        ans = max(ans,s.size() - start);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636231,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int i = 0, j = 1, len = 1, prev = 0;\\n        while(j < n) {\\n            if(s[j] == s[j - 1]) {\\n                if(prev != 0) i = prev; //prev is prev occurence of pair\\n                prev = j;\\n            }\\n            len = max(len, j - i + 1);\\n            j++;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int i = 0, j = 1, len = 1, prev = 0;\\n        while(j < n) {\\n            if(s[j] == s[j - 1]) {\\n                if(prev != 0) i = prev; //prev is prev occurence of pair\\n                prev = j;\\n            }\\n            len = max(len, j - i + 1);\\n            j++;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635995,
                "title": "simple-java-solution-brute-force-approach",
                "content": "# Intuition\\n\\nthere can be max one consecutive pair so if pairs are more than 1 in our current window return false\\n\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean fun(int i,int j,String str)\\n    {\\n        int pair=0;\\n        for(;i<j;i++)\\n        {\\n            if(str.charAt(i)==str.charAt(i+1))  pair++;\\n        }\\n        if(pair>1)  return false;\\n        return true;\\n    }\\n    public int longestSemiRepetitiveSubstring(String s) \\n    {\\n        if(s.length()==1)  return 1;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            for(int j=i+1;j<s.length();j++)\\n            {\\n                if(fun(i,j,s))\\n                {\\n                    ans=Math.max(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean fun(int i,int j,String str)\\n    {\\n        int pair=0;\\n        for(;i<j;i++)\\n        {\\n            if(str.charAt(i)==str.charAt(i+1))  pair++;\\n        }\\n        if(pair>1)  return false;\\n        return true;\\n    }\\n    public int longestSemiRepetitiveSubstring(String s) \\n    {\\n        if(s.length()==1)  return 1;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            for(int j=i+1;j<s.length();j++)\\n            {\\n                if(fun(i,j,s))\\n                {\\n                    ans=Math.max(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635958,
                "title": "easy-two-pointer-o-n",
                "content": "# Approach\\nWe use a two pointer approach with some modifications to solve this probelm.\\nTraverse the string, apart from the two pointers \\'i\\' and \\'j\\' additionally  keep two variables, one as a flag to check the one allowed consecutive repetitive number and the other variable idx to store the index of the second element out of the two consecutive same numbers. This index will help us to reset the first pointer i.e. \\'i\\' of our sliding window, everytime we find more than 1 consecutive repeated element.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        if(s.size() == 1) return 1;\\n        int i = 0, j = 0, flag = 0, idx = -1;\\n        int res = 0;\\n        while(j < s.size() - 1){\\n            if(s[j] != s[j + 1]){\\n                j++;\\n                res = max(res, j - i + 1);\\n            }\\n            else{\\n                if(flag == 0){\\n                    j++;\\n                    res = max(res, j - i + 1);\\n                    flag = 1;\\n                    idx = j;\\n                }\\n                else{\\n                    i = j = idx;\\n                    flag = 0;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        if(s.size() == 1) return 1;\\n        int i = 0, j = 0, flag = 0, idx = -1;\\n        int res = 0;\\n        while(j < s.size() - 1){\\n            if(s[j] != s[j + 1]){\\n                j++;\\n                res = max(res, j - i + 1);\\n            }\\n            else{\\n                if(flag == 0){\\n                    j++;\\n                    res = max(res, j - i + 1);\\n                    flag = 1;\\n                    idx = j;\\n                }\\n                else{\\n                    i = j = idx;\\n                    flag = 0;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634872,
                "title": "rust-python-linear-solution-with-explanation-also-it-can-be-linear-for-any-number-of-semi-repeat",
                "content": "# Intuition\\nThis is a linear problem and the constrains are ridiculously low. They are low even for cubic solution.\\n\\n\\nLets look at a string:\\n\\n```\\nvalues    : 1  2  1  1  3  2  1  1  1  4  2  2  1  3  7  2  1  1  6  7\\npositions : 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19\\n```\\n\\nLets look at what positions do we have repeats. It is easy to find them as `s[i] == s[i - 1]`. Those positions are: `2, 6, 7, 10, 16`.\\n\\nFor each of those positions you need to find the position of element which causes a duplicate, one duplicate before. So all you need is to store the positions of the previous duplicates.\\n\\nHere as we need only 2 previous, you can do it only with 3 numbers and rotate them. But this can be done for any of numbers by having a double ended queue which will be the size of maximum `k`, where `k` is the number of previous elements.\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn longest_semi_repetitive_substring(s: String) -> i32 {\\n    let (mut v1, mut v2, mut v3) = (-1, -1, -1);\\n    let mut res = 0;\\n    let s = s.into_bytes();\\n\\n    for i in 1 .. s.len() {\\n      if s[i - 1] == s[i] {\\n        // If any Rust gury knows how to do this nicer (in 1-2 lines), please write a comment.\\n        let (tmp1, tmp2, tmp3) = (v2, v3, i as i32 - 1);\\n        v1 = tmp1;\\n        v2 = tmp2;\\n        v3 = tmp3;\\n        res = res.max(v3 - v1);\\n      }\\n    }\\n\\n    res = res.max(s.len() as i32 - v2 - 1);\\n    return res;\\n\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n    v1, v2, v3, res = -1, -1, -1, 0\\n    for i in range(1, len(s)):\\n      if s[i - 1] == s[i]:\\n        v1, v2, v3 = v2, v3, i - 1\\n        res = max(res, v3 - v1)\\n\\n    res = max(res, (len(s) - v2 - 1))\\n    return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```\\nvalues    : 1  2  1  1  3  2  1  1  1  4  2  2  1  3  7  2  1  1  6  7\\npositions : 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19\\n```\n```Rust []\\nimpl Solution {\\n  pub fn longest_semi_repetitive_substring(s: String) -> i32 {\\n    let (mut v1, mut v2, mut v3) = (-1, -1, -1);\\n    let mut res = 0;\\n    let s = s.into_bytes();\\n\\n    for i in 1 .. s.len() {\\n      if s[i - 1] == s[i] {\\n        // If any Rust gury knows how to do this nicer (in 1-2 lines), please write a comment.\\n        let (tmp1, tmp2, tmp3) = (v2, v3, i as i32 - 1);\\n        v1 = tmp1;\\n        v2 = tmp2;\\n        v3 = tmp3;\\n        res = res.max(v3 - v1);\\n      }\\n    }\\n\\n    res = res.max(s.len() as i32 - v2 - 1);\\n    return res;\\n\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n    v1, v2, v3, res = -1, -1, -1, 0\\n    for i in range(1, len(s)):\\n      if s[i - 1] == s[i]:\\n        v1, v2, v3 = v2, v3, i - 1\\n        res = max(res, v3 - v1)\\n\\n    res = max(res, (len(s) - v2 - 1))\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631191,
                "title": "lsr-substring-solution",
                "content": "# Approach 1: Brute Force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Algorithm\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExamine every substring in `s`. Check if a substring is semi-repetitive by iterating over every character. If a substring is semi-repetitive, update the length of the longest semi-repetitive substring found thus far.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(const string& s) {\\n        int longest = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            for (int k = 1; k <= s.length() - i; k++) {\\n                if (semiRepetitive(s.substr(i, k))) {\\n                    longest = max(longest, k);\\n                }\\n            }\\n        }\\n            \\n        return longest;\\n    }\\n\\n    bool semiRepetitive(const string& s) {\\n        bool doubleLetters = false;\\n\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s[i] == s[i-1]) {\\n                if (doubleLetters) {\\n                    return false;\\n                }\\n                else {\\n                    doubleLetters = true;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int longest = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = i + 1; j <= s.length(); j++) {\\n                if (semiRepetitive(s.substring(i, j))) {\\n                    longest = Math.max(longest, j - i);\\n                }\\n            }\\n        }\\n            \\n        return longest;\\n    }\\n\\n    public boolean semiRepetitive(String s) {\\n        boolean doubleLetters = false;\\n\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == s.charAt(i-1)) {\\n                if (doubleLetters) {\\n                    return false;\\n                }\\n                else {\\n                    doubleLetters = true;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        longest = 0\\n        \\n        for i in range(len(s)):\\n            for j in range(i+1, len(s)+1):\\n                if self.semiRepetitive(s[i:j]):\\n                    longest = max(longest, j - i)\\n            \\n        return longest\\n\\n    def semiRepetitive(self, s: str) -> bool:\\n        doubleLetters = False\\n\\n        for i in range(1, len(s)):\\n            if s[i] == s[i-1]:\\n                if doubleLetters:\\n                    return False\\n                else:\\n                    doubleLetters = True\\n\\n        return True\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n    - For a string of length $$n$$, there are $$\\\\frac{n(n+1)}{2}=O(n^2)$$ substrings to check\\n    - the semiRepetitive function iterates over $$n$$ characters at most, so it\\'s $$O(n)$$\\n    - Overall, the time is $$O(n^2)*O(n)=O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n    - All the primitive variables take up constant space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Approach 2: Sliding Window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Intuition\\nNote that a semi-repetitive substring can be extended one character to the right if the new substring doesn\\'t gain a second pair of identical consecutive characters. This leads to a solution in which a substring is stretched rightward as far as possible. When the substring encounters another pair of identical consecutive characters, it is rebuilt from the right half of the previous pair of identical consecutive characters.\\n\\n# Algorithm\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Let `l` store the index of the leftmost character in the current sem-repetitive substring \\n- Let `p` store the index of the pair of identical consecutive letters within current substring, if it exists \\n- Iterate over every character in `s`. If `s[i-1] = s[i]`:\\n    - If `p` has been assigned an index, a second pair of identical consecutive characters has been found. Record the length of substring `s[l-i]` if it\\'s the longest one thus far, and set `l = p` and `p = i`  \\n    - If `p` hasn\\'t been assigned an index, just set `p=i`\\n- Output the length of the longest semi-repetitive substring found \\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(const string& s) {\\n        int left = 0;\\n        int longest = 1;\\n        int pairIndex = -1;\\n        \\n        for (int i = 1; i < s.length(); i++) {\\n            if (s[i-1] == s[i]) {\\n                if (pairIndex != -1) {\\n                    left = pairIndex; \\n                }\\n                pairIndex = i;\\n            }\\n            longest = max(longest, i - left + 1);\\n        }\\n\\n        return longest;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int left = 0;\\n        int longest = 1;\\n        int pairIndex = -1;\\n        \\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i-1) == s.charAt(i)) {\\n                if (pairIndex != -1) {\\n                    left = pairIndex; \\n                }\\n                pairIndex = i;\\n            }\\n            longest = Math.max(longest, i - left + 1);\\n        }\\n\\n        return longest;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        left = 0\\n        longest = 1\\n        pairIndex = -1\\n        \\n        for i in range(1, len(s)):\\n            if s[i-1] == s[i]:\\n                if pairIndex != -1:\\n                    left = pairIndex \\n                    \\n                pairIndex = i\\n        \\n            longest = max(longest, i - left + 1)\\n            \\n        return longest\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n    - The procedure does one pass through all $$n$$ elements of the string, thus $$O(n)$$ time\\n   \\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n    - All the primitive variables take up constant space\\n   \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(const string& s) {\\n        int longest = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            for (int k = 1; k <= s.length() - i; k++) {\\n                if (semiRepetitive(s.substr(i, k))) {\\n                    longest = max(longest, k);\\n                }\\n            }\\n        }\\n            \\n        return longest;\\n    }\\n\\n    bool semiRepetitive(const string& s) {\\n        bool doubleLetters = false;\\n\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s[i] == s[i-1]) {\\n                if (doubleLetters) {\\n                    return false;\\n                }\\n                else {\\n                    doubleLetters = true;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int longest = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = i + 1; j <= s.length(); j++) {\\n                if (semiRepetitive(s.substring(i, j))) {\\n                    longest = Math.max(longest, j - i);\\n                }\\n            }\\n        }\\n            \\n        return longest;\\n    }\\n\\n    public boolean semiRepetitive(String s) {\\n        boolean doubleLetters = false;\\n\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == s.charAt(i-1)) {\\n                if (doubleLetters) {\\n                    return false;\\n                }\\n                else {\\n                    doubleLetters = true;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        longest = 0\\n        \\n        for i in range(len(s)):\\n            for j in range(i+1, len(s)+1):\\n                if self.semiRepetitive(s[i:j]):\\n                    longest = max(longest, j - i)\\n            \\n        return longest\\n\\n    def semiRepetitive(self, s: str) -> bool:\\n        doubleLetters = False\\n\\n        for i in range(1, len(s)):\\n            if s[i] == s[i-1]:\\n                if doubleLetters:\\n                    return False\\n                else:\\n                    doubleLetters = True\\n\\n        return True\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(const string& s) {\\n        int left = 0;\\n        int longest = 1;\\n        int pairIndex = -1;\\n        \\n        for (int i = 1; i < s.length(); i++) {\\n            if (s[i-1] == s[i]) {\\n                if (pairIndex != -1) {\\n                    left = pairIndex; \\n                }\\n                pairIndex = i;\\n            }\\n            longest = max(longest, i - left + 1);\\n        }\\n\\n        return longest;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int left = 0;\\n        int longest = 1;\\n        int pairIndex = -1;\\n        \\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i-1) == s.charAt(i)) {\\n                if (pairIndex != -1) {\\n                    left = pairIndex; \\n                }\\n                pairIndex = i;\\n            }\\n            longest = Math.max(longest, i - left + 1);\\n        }\\n\\n        return longest;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        left = 0\\n        longest = 1\\n        pairIndex = -1\\n        \\n        for i in range(1, len(s)):\\n            if s[i-1] == s[i]:\\n                if pairIndex != -1:\\n                    left = pairIndex \\n                    \\n                pairIndex = i\\n        \\n            longest = max(longest, i - left + 1)\\n            \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630479,
                "title": "sliding-window-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)^2.... (Now take reference from here and write the optimize code by yourself .. Hint : using Two pointer or Stack);\\n\\n- Space complexity:\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int n = s.length();\\n        if(n == 1) return 1;\\n        int i = 0;\\n        int len = 0;\\n        while(i < n-1){\\n           int j = i + 1,repeat = 0,track = 0;\\n            while(j < n){\\n                if(s.charAt(j) == s.charAt(j-1)){\\n                    if(repeat == 1){\\n                        break;}\\n                    else {track = j - i + 1;\\n                    repeat++;\\n                    }\\n                }\\n                else{\\n                    track = j - i + 1;\\n                }\\n                  j++;\\n            }\\n            len = Math.max(len,track);\\n            i++;\\n        }\\n        return len;\\n         }\\n     }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int n = s.length();\\n        if(n == 1) return 1;\\n        int i = 0;\\n        int len = 0;\\n        while(i < n-1){\\n           int j = i + 1,repeat = 0,track = 0;\\n            while(j < n){\\n                if(s.charAt(j) == s.charAt(j-1)){\\n                    if(repeat == 1){\\n                        break;}\\n                    else {track = j - i + 1;\\n                    repeat++;\\n                    }\\n                }\\n                else{\\n                    track = j - i + 1;\\n                }\\n                  j++;\\n            }\\n            len = Math.max(len,track);\\n            i++;\\n        }\\n        return len;\\n         }\\n     }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630358,
                "title": "o-n-time-complexity-easy-elegant-solution-specially-designed-for-beginner-s",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        // simple sliding window technique;\\n        int j=0;\\n        int count=0;\\n        int ans=1;\\n        // 52233\\n        for(int i=1;i<n;i++){\\n            if(s[i]==s[i-1]){\\n                count++;\\n                while(count>1){\\n                    if(j<i){\\n                        if(s[j]==s[j+1])\\n                            count--;\\n                        j++;\\n                    }\\n                }\\n                \\n            }\\n            ans=max(ans,i-j+1);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n// 1114345413\\n    \\n// zbzjkbska111ernejnrklnr // we can start using the two pointer approach here;\\n// 52233\\n\\n  // 11wdwdwd22\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        // simple sliding window technique;\\n        int j=0;\\n        int count=0;\\n        int ans=1;\\n        // 52233\\n        for(int i=1;i<n;i++){\\n            if(s[i]==s[i-1]){\\n                count++;\\n                while(count>1){\\n                    if(j<i){\\n                        if(s[j]==s[j+1])\\n                            count--;\\n                        j++;\\n                    }\\n                }\\n                \\n            }\\n            ans=max(ans,i-j+1);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n// 1114345413\\n    \\n// zbzjkbska111ernejnrklnr // we can start using the two pointer approach here;\\n// 52233\\n\\n  // 11wdwdwd22\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629189,
                "title": "simple-easy-to-understand-two-pointer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple **Two pointer solution** ptr1 and ptr2.\\n\\nWe keep traversing the string with ptr2 and check when we encounter a consecutive pair of the same digits. When we enounter it first time we just save the current index in a variable. If we encounter a consecutive pair of same digits further we move the ptr1 to the index we saved before where we encountered the a consecutive pair before. We do this since we could have at most one consecutive pair of same digits. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Two pointer Pattern\\n2. Keep moving ptr2 with every iteration\\n3. Ignore first time encounter of a consecutive pair of same digits with a flag variable.\\n4. For all subsequent encounter save the current index.\\n5. Keep Tracking max variable.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```python []\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        if len(s) == 1:\\n            return 1\\n        ptr1 = 0\\n        ptr2 = 1\\n        firstTime = True\\n        lastrep = -1\\n        mxl = 0\\n\\n        while ptr2 < len(s):\\n            if firstTime and s[ptr2] == s[ptr2-1]:\\n                firstTime = False\\n                lastrep = ptr2\\n            elif s[ptr2] == s[ptr2-1]:\\n                ptr1 = lastrep\\n                lastrep = ptr2\\n            mxl = max(mxl, ptr2 - ptr1 + 1)\\n            ptr2 += 1\\n        \\n        return mxl\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        if (s.length() == 1) {\\n            return 1;\\n        }\\n        \\n        int ptr1 = 0;\\n        int ptr2 = 1;\\n        bool firstTime = true;\\n        int lastrep = -1;\\n        int mxl = 0;\\n        \\n        while (ptr2 < s.length()) {\\n            if (firstTime && s[ptr2] == s[ptr2 - 1]) {\\n                firstTime = false;\\n                lastrep = ptr2;\\n            }\\n            else if (s[ptr2] == s[ptr2 - 1]) {\\n                ptr1 = lastrep;\\n                lastrep = ptr2;\\n            }\\n            \\n            mxl = max(mxl, ptr2 - ptr1 + 1);\\n            ptr2++;\\n        }\\n        \\n        return mxl;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```python []\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        if len(s) == 1:\\n            return 1\\n        ptr1 = 0\\n        ptr2 = 1\\n        firstTime = True\\n        lastrep = -1\\n        mxl = 0\\n\\n        while ptr2 < len(s):\\n            if firstTime and s[ptr2] == s[ptr2-1]:\\n                firstTime = False\\n                lastrep = ptr2\\n            elif s[ptr2] == s[ptr2-1]:\\n                ptr1 = lastrep\\n                lastrep = ptr2\\n            mxl = max(mxl, ptr2 - ptr1 + 1)\\n            ptr2 += 1\\n        \\n        return mxl\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        if (s.length() == 1) {\\n            return 1;\\n        }\\n        \\n        int ptr1 = 0;\\n        int ptr2 = 1;\\n        bool firstTime = true;\\n        int lastrep = -1;\\n        int mxl = 0;\\n        \\n        while (ptr2 < s.length()) {\\n            if (firstTime && s[ptr2] == s[ptr2 - 1]) {\\n                firstTime = false;\\n                lastrep = ptr2;\\n            }\\n            else if (s[ptr2] == s[ptr2 - 1]) {\\n                ptr1 = lastrep;\\n                lastrep = ptr2;\\n            }\\n            \\n            mxl = max(mxl, ptr2 - ptr1 + 1);\\n            ptr2++;\\n        }\\n        \\n        return mxl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629113,
                "title": "easy-cpp-solution-sliding-window-full-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->The code aims to find the length of the longest semi-repetitive substring in a given string s. A semi-repetitive substring is defined as a substring that contains at most one repeating character. The code iterates through the string and keeps track of the longest semi-repetitive substring encountered so far.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The code uses two pointers, i and j, to maintain a sliding window over the string s. The window spans from i to j (both inclusive) and represents the current substring being analyzed. The variable ans stores the length of the longest semi-repetitive substring found.\\n\\nThe code starts by checking if the length of s is less than 3. If so, the entire string is a semi-repetitive substring, and the function returns the length of s.\\n\\nInside the while loop, the code examines the characters at indices j and j-1. The variable a is used to keep track of whether a repeating character has been encountered within the current substring.\\n\\nIf a is false, it means no repeating character has been encountered yet. So, the code checks if the current character (s[j]) is the same as the previous character (s[j-1]). If they are the same, a is set to true, indicating the presence of a repeating character.\\n\\nIf a is true, it means a repeating character has been encountered. The code enters a nested while loop that increments i until it reaches the position just before the next non-repeating character. This is done by comparing s[i] with s[i+1]. Once the next non-repeating character is found, the loop breaks.\\n\\nAfter updating i, the code calculates the length of the current substring (j-i+1) and updates ans if the length is greater than the previous longest semi-repetitive substring.\\n\\nFinally, j is incremented to move the sliding window one step ahead, and the process continues until j reaches the end of the string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The code iterates through the string using two pointers, i and j, and performs comparisons and calculations at each step. The time complexity is O(n), where n is the length of the input string s. This is because each character is visited exactly once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The code uses a constant amount of extra space to store variables i, j, ans, and a. Therefore, the space complexity is O(1), indicating that the space used does not depend on the size of the input string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        if(s.size()<3) return s.size();\\n        int i=0; int j=1;\\n        int ans=INT_MIN;\\n        bool a=false;\\n        while(j<s.size()){\\n            if(!a){\\n                if(s[j]==s[j-1]){\\n                    a=true;\\n                }\\n            }\\n            else if(a){\\n                if(s[j]==s[j-1]){\\n                    while(true){\\n                        if(s[i]==s[i+1]){\\n                            i++;\\n                                break;\\n                        }\\n                        i++;\\n                    }\\n                }\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        if(s.size()<3) return s.size();\\n        int i=0; int j=1;\\n        int ans=INT_MIN;\\n        bool a=false;\\n        while(j<s.size()){\\n            if(!a){\\n                if(s[j]==s[j-1]){\\n                    a=true;\\n                }\\n            }\\n            else if(a){\\n                if(s[j]==s[j-1]){\\n                    while(true){\\n                        if(s[i]==s[i+1]){\\n                            i++;\\n                                break;\\n                        }\\n                        i++;\\n                    }\\n                }\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628938,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s) {\\n        int res = 0;\\n        int maxRes = 0;\\n        List<int> te = new List<int>();\\n        char pr = s[0];\\n        for (int i = 1; i < s.Length; i++)\\n        {\\n            if (pr == s[i])\\n            {\\n                te.Add(i);\\n            }\\n            pr = s[i];            \\n        }\\n        if(te.Count<2)\\n        {\\n            return s.Length;\\n        }\\n        else\\n        {\\n            int prev = te[0];\\n            int pos = 0;\\n            foreach(int fg in te.Skip(1))\\n            {\\n                res = fg - pos;\\n                if(res>maxRes)\\n                {\\n                    maxRes = res;\\n                }\\n                pos = prev;\\n                prev = fg;\\n            }\\n\\n            res = s.Length - te[te.Count - 2];\\n            if (res > maxRes)\\n            {\\n                maxRes = res;\\n            }\\n        }\\n        return maxRes;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s) {\\n        int res = 0;\\n        int maxRes = 0;\\n        List<int> te = new List<int>();\\n        char pr = s[0];\\n        for (int i = 1; i < s.Length; i++)\\n        {\\n            if (pr == s[i])\\n            {\\n                te.Add(i);\\n            }\\n            pr = s[i];            \\n        }\\n        if(te.Count<2)\\n        {\\n            return s.Length;\\n        }\\n        else\\n        {\\n            int prev = te[0];\\n            int pos = 0;\\n            foreach(int fg in te.Skip(1))\\n            {\\n                res = fg - pos;\\n                if(res>maxRes)\\n                {\\n                    maxRes = res;\\n                }\\n                pos = prev;\\n                prev = fg;\\n            }\\n\\n            res = s.Length - te[te.Count - 2];\\n            if (res > maxRes)\\n            {\\n                maxRes = res;\\n            }\\n        }\\n        return maxRes;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628695,
                "title": "python-logical-solution-with-very-basic-programming-time-complexity-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Semi-repetitive substring contains at most one consecutive pair.\\nSo I try to **BREAK DOWN TO SUBSTRING LIST WITHOUT PAIR** first.\\ne.g. \"5223354941111\" --> [\"52\", \"23\", \"354941\", \"1\", \"1\", \"1\"]\\n\\n2) In the substring looping,\\nIf previous digit == current digit --> current substring is appended to the list.\\nIf previous digit <> current digit --> current digit is added to substring.\\nFinally, **GET THE MAXIMUM LENGTH SUM FOR EVERY 2 ADJACENT SUBSTRINGS**.\\n\\n3) Then, we can just **MARK THE CHAR COUNT OF SUBSTRING** instead.\\ne.g. [\"52\", \"23\", \"354941\", \"1\", \"1\", \"1\"] --> [2, 2, 6, 1, 1, 1]\\nNow, The logic become:\\nIf previous digit == current digit --> current count is appended to the list.\\nIf previous digit <> current digit --> current count + 1.\\nFinally, **GET THE COUNT SUM FOR EVERY 2 ADJACENT SUBSTRINGS**.\\n\\n4) For better space complexity, list is not necessary. We **CREATE \"previous_count\" VARIABLE INSTEAD OF SUBSTRING LIST**.\\nNow, The logic become:\\nIf previous digit == current digit \\n--> **(count + previous_count) IS COMPARED WITH STORED OUTPUT, LARGER VALUE IS MARKED**.\\n--> pass current count to previous_count.\\nIf previous digit <> current digit --> current count + 1.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def longestSemiRepetitiveSubstring(self, s):\\n        if len(s) == 1:\\n            return 1\\n\\n        last, count = s[0], 1\\n        output, previous_count = 0, 0\\n\\n        for i in s[1:]:\\n            if last == i:\\n                if count + previous_count > output:\\n                    output = count + previous_count\\n                previous_count = count\\n                count = 1\\n            else:\\n                count += 1\\n            last = i\\n\\n        if count + previous_count > output:\\n            output = count + previous_count\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestSemiRepetitiveSubstring(self, s):\\n        if len(s) == 1:\\n            return 1\\n\\n        last, count = s[0], 1\\n        output, previous_count = 0, 0\\n\\n        for i in s[1:]:\\n            if last == i:\\n                if count + previous_count > output:\\n                    output = count + previous_count\\n                previous_count = count\\n                count = 1\\n            else:\\n                count += 1\\n            last = i\\n\\n        if count + previous_count > output:\\n            output = count + previous_count\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627955,
                "title": "find-the-longest-semi-repetitive-substring",
                "content": "//ye question nahi kar payega to kya coder banega re tu\\n//ye le sabase brute force solution sambhal bhaiyo aur bahano\\n\\nclass Solution {\\npublic:\\n       bool checkisvalid(string str)\\n        {\\n            int n=str.size();\\n            int count=0;\\n         for(int i=1;i<n;i++)\\n           {\\n             if(str[i]==str[i-1])\\n                 count++;\\n           }\\n           if(count<=1)\\n               return true;\\n           return false;\\n        }\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int maxi=0;\\n        string ans;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=\"\";\\n         for(int j=i;j<n;j++)\\n         {\\n          ans+=s[j];\\n          if(checkisvalid(ans))\\n            maxi=max(maxi,j-i+1);\\n         }\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n       bool checkisvalid(string str)\\n        {\\n            int n=str.size();\\n            int count=0;\\n         for(int i=1;i<n;i++)\\n           {\\n             if(str[i]==str[i-1])\\n                 count++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3627883,
                "title": "find-the-longest-semi-repetitive-substring-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n=s.length();\\n        vector<int> ans;\\n        int len=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int len=1,count=0;\\n            char back=s[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(count==2)\\n                {\\n                    break;\\n                }\\n                if(s[j]!=back)\\n                {\\n                    back=s[j];\\n                    len++;\\n                }\\n                else\\n                {\\n                    if(count<1)\\n                    {\\n                        count++;\\n                        len++;\\n                        back=s[j];\\n                    }\\n                    else\\n                    {\\n                        ans.push_back(len);\\n                        \\n                        count=2;\\n                        back=s[j];\\n                    }\\n                }\\n            }\\n            ans.push_back(len);\\n        }\\n       ans.push_back(len);\\n        sort(ans.begin(),ans.end());\\n        reverse(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n=s.length();\\n        vector<int> ans;\\n        int len=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int len=1,count=0;\\n            char back=s[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(count==2)\\n                {\\n                    break;\\n                }\\n                if(s[j]!=back)\\n                {\\n                    back=s[j];\\n                    len++;\\n                }\\n                else\\n                {\\n                    if(count<1)\\n                    {\\n                        count++;\\n                        len++;\\n                        back=s[j];\\n                    }\\n                    else\\n                    {\\n                        ans.push_back(len);\\n                        \\n                        count=2;\\n                        back=s[j];\\n                    }\\n                }\\n            }\\n            ans.push_back(len);\\n        }\\n       ans.push_back(len);\\n        sort(ans.begin(),ans.end());\\n        reverse(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627785,
                "title": "simple-and-clear-python3-code-better-than-100-sliding-window-technique",
                "content": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        \\n        if len(s)==1:\\n            return 1\\n        i=0;j=1;m=defaultdict(list);ans=0\\n        while j<len(s):\\n            \\n            if s[j-1]==s[j]:\\n                if s[j] in m:\\n                    ans=max(ans,j-i)\\n                    i=m[s[j]][1]\\n                    while m[s[j]]:\\n                        m[s[j]].pop()\\n                    m[s[j]].extend([j-1,j])\\n                    j+=1\\n                    continue\\n                else:\\n                    m[s[j]].extend([j-1,j])\\n    \\n            if len(m)<=1:\\n                ans=max(ans,j-i+1)\\n                j+=1\\n                \\n            else:\\n                while len(m)>1:\\n                    if s[i] in m and i==m[s[i]][0]:\\n                        i=m[s[i]][1]\\n                        del m[s[i]]\\n                        break\\n                    i+=1\\n    \\n                ans=max(ans,j-i+1)\\n                j+=1\\n            \\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/39e19778-e756-49e1-a4fb-b91c311968d4_1686547233.1721923.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        \\n        if len(s)==1:\\n            return 1\\n        i=0;j=1;m=defaultdict(list);ans=0\\n        while j<len(s):\\n            \\n            if s[j-1]==s[j]:\\n                if s[j] in m:\\n                    ans=max(ans,j-i)\\n                    i=m[s[j]][1]\\n                    while m[s[j]]:\\n                        m[s[j]].pop()\\n                    m[s[j]].extend([j-1,j])\\n                    j+=1\\n                    continue\\n                else:\\n                    m[s[j]].extend([j-1,j])\\n    \\n            if len(m)<=1:\\n                ans=max(ans,j-i+1)\\n                j+=1\\n                \\n            else:\\n                while len(m)>1:\\n                    if s[i] in m and i==m[s[i]][0]:\\n                        i=m[s[i]][1]\\n                        del m[s[i]]\\n                        break\\n                    i+=1\\n    \\n                ans=max(ans,j-i+1)\\n                j+=1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627705,
                "title": "brute-force-solution-for-beginners-c",
                "content": "# Approach\\ncheck for every substring whether it is semi-Repetitive or not ?\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool valid(string &s){\\n        int cnt=0;\\n\\n        for(int i=1; i<s.length(); i++){\\n            if(s[i]==s[i-1]) cnt++;\\n        }\\n\\n        return cnt==1;\\n    }    \\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int maxi=-1;\\n\\n        for(int i=0; i<s.length(); i++){\\n            string str=\"\";\\n            for(int j=i; j<s.length(); j++){\\n                str += s[j];\\n                if(str.length()>1 && valid(str)){\\n                    int n = str.length();\\n                    maxi=max(maxi,n);\\n                }\\n            }\\n        }\\n\\n        return (maxi==-1)? s.length(): maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool valid(string &s){\\n        int cnt=0;\\n\\n        for(int i=1; i<s.length(); i++){\\n            if(s[i]==s[i-1]) cnt++;\\n        }\\n\\n        return cnt==1;\\n    }    \\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int maxi=-1;\\n\\n        for(int i=0; i<s.length(); i++){\\n            string str=\"\";\\n            for(int j=i; j<s.length(); j++){\\n                str += s[j];\\n                if(str.length()>1 && valid(str)){\\n                    int n = str.length();\\n                    maxi=max(maxi,n);\\n                }\\n            }\\n        }\\n\\n        return (maxi==-1)? s.length(): maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627221,
                "title": "c-python3-3-pointers",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int ans = 0;\\n\\n        for (int i = 0, j = 0, k = -1; j < s.size(); ++j)\\n        {\\n            if (j > 0 && s[j] == s[j - 1])\\n            {\\n                if (k > 0)\\n                {\\n                    ans = max(ans, j - 1 - i + 1);\\n                    i = k;\\n                }\\n\\n                k = j ;\\n            }\\n\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        i, k, ans = 0, -1, 0\\n        for j in range(len(s)):\\n            if j > 0 and s[j] == s[j - 1]:\\n                if k > 0:\\n                    ans = max(ans, j - 1 - i + 1)\\n                    i = k\\n                k = j\\n            ans = max(ans, j - i + 1)\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int ans = 0;\\n\\n        for (int i = 0, j = 0, k = -1; j < s.size(); ++j)\\n        {\\n            if (j > 0 && s[j] == s[j - 1])\\n            {\\n                if (k > 0)\\n                {\\n                    ans = max(ans, j - 1 - i + 1);\\n                    i = k;\\n                }\\n\\n                k = j ;\\n            }\\n\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        i, k, ans = 0, -1, 0\\n        for j in range(len(s)):\\n            if j > 0 and s[j] == s[j - 1]:\\n                if k > 0:\\n                    ans = max(ans, j - 1 - i + 1)\\n                    i = k\\n                k = j\\n            ans = max(ans, j - i + 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627201,
                "title": "python-o-n-time-and-o-1-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou just have to find the distance between every alternative occurance of the repetative number and find the max distace. \\n\\nSo if there are 1st, 2nd, 3rd, 4th, 5th occurances of the repetative numbers then find the distance between 3rd and 1st, 4th and 2nd, 5th and 3rd occurances. Then find the max distance. \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n\\n        prev = now = 0\\n        result = 1\\n\\n        for i in range(1,len(s)):\\n            if s[i] == s[i-1]:\\n                prev, now = now, i\\n            result = max(result, i - prev + 1)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n\\n        prev = now = 0\\n        result = 1\\n\\n        for i in range(1,len(s)):\\n            if s[i] == s[i-1]:\\n                prev, now = now, i\\n            result = max(result, i - prev + 1)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626916,
                "title": "python-two-pointers-no-while-loop-83ms-16mb",
                "content": "# Intuition\\nif dp[j] == 1, it means s[j] is now forming a pair with other char in substring window (j,i). We add 1 to restriction k when we move pointer j to the right.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        dp = [0] * len(s)\\n        j, k = 0, 1\\n        for i in range(0, len(s)):\\n            if i - 1 >= 0 and s[i] == s[i-1]:\\n                k -=1\\n                dp[i - 1] = 1\\n            if k < 0:\\n                k += dp[j]                \\n                j += 1\\n        return i - j + 1\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        dp = [0] * len(s)\\n        j, k = 0, 1\\n        for i in range(0, len(s)):\\n            if i - 1 >= 0 and s[i] == s[i-1]:\\n                k -=1\\n                dp[i - 1] = 1\\n            if k < 0:\\n                k += dp[j]                \\n                j += 1\\n        return i - j + 1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626796,
                "title": "python-find-the-index-boundary-of-each-pair",
                "content": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        len_s = len(s)\\n        if len_s <= 2:\\n            return len_s\\n        \\n        # step 1, find the start and end index of the consecutive same digits\\n        boundary_index = []\\n        check_digit = False\\n        idx = 1\\n        while idx < len_s:\\n            if s[idx - 1] == s[idx]:\\n                if not check_digit:\\n                    check_digit = True\\n                    boundary_index.append(idx - 1)\\n            else:\\n                if check_digit:\\n                    check_digit = False\\n                    boundary_index.append(idx - 1)\\n            idx += 1\\n        if check_digit:\\n            boundary_index.append(idx - 1)\\n        \\n        # step 2, find the longest string base on the boundary index list\\n        ans = len_s\\n        if len(boundary_index):\\n            # string from 0 to the first pair\\n            ans = boundary_index[0] + 2\\n            \\n            # string in the middle of the pair list\\n            prev_start, idx = 0, 1\\n            while idx < len(boundary_index):\\n                if boundary_index[idx] > boundary_index[idx - 1] + 1:\\n                    ans = max(ans, boundary_index[idx - 1] - prev_start + 2)\\n                else:\\n                    if idx == len(boundary_index) - 1:\\n                        ans = max(ans, len_s - prev_start)\\n                    else:\\n                        ans = max(ans, boundary_index[idx + 1] + 1 - prev_start)\\n                prev_start = boundary_index[idx]\\n                idx += 2\\n            \\n            # string from the last pair to the last char\\n            ans = max(ans, len_s - boundary_index[idx - 2] + 1)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        len_s = len(s)\\n        if len_s <= 2:\\n            return len_s\\n        \\n        # step 1, find the start and end index of the consecutive same digits\\n        boundary_index = []\\n        check_digit = False\\n        idx = 1\\n        while idx < len_s:\\n            if s[idx - 1] == s[idx]:\\n                if not check_digit:\\n                    check_digit = True\\n                    boundary_index.append(idx - 1)\\n            else:\\n                if check_digit:\\n                    check_digit = False\\n                    boundary_index.append(idx - 1)\\n            idx += 1\\n        if check_digit:\\n            boundary_index.append(idx - 1)\\n        \\n        # step 2, find the longest string base on the boundary index list\\n        ans = len_s\\n        if len(boundary_index):\\n            # string from 0 to the first pair\\n            ans = boundary_index[0] + 2\\n            \\n            # string in the middle of the pair list\\n            prev_start, idx = 0, 1\\n            while idx < len(boundary_index):\\n                if boundary_index[idx] > boundary_index[idx - 1] + 1:\\n                    ans = max(ans, boundary_index[idx - 1] - prev_start + 2)\\n                else:\\n                    if idx == len(boundary_index) - 1:\\n                        ans = max(ans, len_s - prev_start)\\n                    else:\\n                        ans = max(ans, boundary_index[idx + 1] + 1 - prev_start)\\n                prev_start = boundary_index[idx]\\n                idx += 2\\n            \\n            # string from the last pair to the last char\\n            ans = max(ans, len_s - boundary_index[idx - 2] + 1)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626725,
                "title": "unique-approach-simple-brute-force-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int n = s.length(), maxAns = 0;\\n        for(int i=0; i<n-1; i++){\\n            int sum = 0, count = 0, count2 = 0;\\n            if(s.charAt(i) == s.charAt(i+1)){\\n                for(int k=i; k>=1; k--){\\n                    if(s.charAt(k) != s.charAt(k-1)){\\n                        count++;\\n                    }else {\\n                        break;\\n                    }\\n                }\\n                for(int k=i+1; k<n-1; k++){\\n                    if(s.charAt(k) != s.charAt(k+1)){\\n                        count2++;\\n                    }else {\\n                        break;\\n                    }\\n                }\\n                sum = sum + count + count2 + 2;\\n            }\\n            maxAns = Math.max(sum, maxAns);\\n        }\\n        return maxAns == 0?s.length():maxAns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int n = s.length(), maxAns = 0;\\n        for(int i=0; i<n-1; i++){\\n            int sum = 0, count = 0, count2 = 0;\\n            if(s.charAt(i) == s.charAt(i+1)){\\n                for(int k=i; k>=1; k--){\\n                    if(s.charAt(k) != s.charAt(k-1)){\\n                        count++;\\n                    }else {\\n                        break;\\n                    }\\n                }\\n                for(int k=i+1; k<n-1; k++){\\n                    if(s.charAt(k) != s.charAt(k+1)){\\n                        count2++;\\n                    }else {\\n                        break;\\n                    }\\n                }\\n                sum = sum + count + count2 + 2;\\n            }\\n            maxAns = Math.max(sum, maxAns);\\n        }\\n        return maxAns == 0?s.length():maxAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626659,
                "title": "simple-nested-for-loops-approach-window-sliding-and-brute-force",
                "content": "# Intuition\\nWe can use a simple window sliding approach here by which we begin at outer( 0 initially ) index and constantly expand our subString until some break condition is met, once that is met , we increment our outer index to +1 thus making subArray begin from new position\\n\\n# Approach\\nThis is a brute force approach, we achieve it by using nested loops, one for outer index and another for incremental sub arrays\\n\\nOur break condition would be when we found 2 pairs of consecutive digits in same sub array, we calculate length of substring in each iteration, since initial index starts from 0, we add 1 to get actual length like j-i+1 between j and i\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar longestSemiRepetitiveSubstring = function(s) {\\n  let length = 0;\\n  let repeatedDigits;\\n\\n  for(let i = 0;i<s.length;i++){\\n    repeatedDigits = false;\\n      for(let j=i;j<s.length;j++){\\n        if(j>i && s[j]===s[j-1]){\\n          if(repeatedDigits){\\n            break;\\n          }\\n          repeatedDigits = true;\\n        }\\n        length = Math.max(length,j-i+1)\\n      }\\n  }\\n\\n    return length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar longestSemiRepetitiveSubstring = function(s) {\\n  let length = 0;\\n  let repeatedDigits;\\n\\n  for(let i = 0;i<s.length;i++){\\n    repeatedDigits = false;\\n      for(let j=i;j<s.length;j++){\\n        if(j>i && s[j]===s[j-1]){\\n          if(repeatedDigits){\\n            break;\\n          }\\n          repeatedDigits = true;\\n        }\\n        length = Math.max(length,j-i+1)\\n      }\\n  }\\n\\n    return length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3626623,
                "title": "python3-o-n-solution-with-two-anchor-points",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        anchor1 = -1\\n        anchor2 = -1\\n        res = 0\\n        flag = False\\n        for i in range(1, len(s)):\\n            if s[i] == s[i-1]:\\n                if flag:\\n                    res = max(res, i - 1 - anchor1)\\n                    anchor1 = anchor2\\n                    anchor2 = i - 1\\n                else:\\n                    anchor2 = i - 1\\n                    flag = True\\n        return max(res, len(s)- 1 - anchor1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        anchor1 = -1\\n        anchor2 = -1\\n        res = 0\\n        flag = False\\n        for i in range(1, len(s)):\\n            if s[i] == s[i-1]:\\n                if flag:\\n                    res = max(res, i - 1 - anchor1)\\n                    anchor1 = anchor2\\n                    anchor2 = i - 1\\n                else:\\n                    anchor2 = i - 1\\n                    flag = True\\n        return max(res, len(s)- 1 - anchor1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625988,
                "title": "9ms-java-solution-using-sliding-window",
                "content": "Keep track of the index where the last repetition ended ,now slide the window to start from that index.\\n```\\n public int longestSemiRepetitiveSubstring(String s) {\\n        \\n        int ind=0,i=0,j=0,ans=1;\\n        char[] num=s.toCharArray();\\n        \\n        for(j=1;j<s.length();j++)\\n        {\\n            \\n            if(num[j]==num[j-1])\\n            {\\n                i=ind;\\n                ind=j;\\n            }\\n            ans=Math.max(ans,j-i+1);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n public int longestSemiRepetitiveSubstring(String s) {\\n        \\n        int ind=0,i=0,j=0,ans=1;\\n        char[] num=s.toCharArray();\\n        \\n        for(j=1;j<s.length();j++)\\n        {\\n            \\n            if(num[j]==num[j-1])\\n            {\\n                i=ind;\\n                ind=j;\\n            }\\n            ans=Math.max(ans,j-i+1);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3625925,
                "title": "binary-search-sliding-window",
                "content": "# Intuition\\nBinary Search + Sliding window\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool pos(int mid,string s)\\n    {\\n        int p=0;\\n        int h=0;\\n        for(h=1;h<mid;h++){\\n            if(s[h]==s[h-1]){\\n                p++;\\n            }\\n        }\\n        h--;\\n        int l=0;\\n        int n=s.size();\\n        while(h<n-1){\\n            if(p>1){\\n                if(s[l]==s[l+1]){\\n                    p--;\\n                }\\n                if(s[h+1]==s[h]){\\n                    p++;\\n                }\\n            }\\n            else{\\n                return true;\\n            }\\n            h++;\\n            l++;\\n            \\n        }\\n        if(p<=1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n=s.size();\\n        int l=1;\\n        int h=n;\\n        int ans=0;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(pos(mid,s)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool pos(int mid,string s)\\n    {\\n        int p=0;\\n        int h=0;\\n        for(h=1;h<mid;h++){\\n            if(s[h]==s[h-1]){\\n                p++;\\n            }\\n        }\\n        h--;\\n        int l=0;\\n        int n=s.size();\\n        while(h<n-1){\\n            if(p>1){\\n                if(s[l]==s[l+1]){\\n                    p--;\\n                }\\n                if(s[h+1]==s[h]){\\n                    p++;\\n                }\\n            }\\n            else{\\n                return true;\\n            }\\n            h++;\\n            l++;\\n            \\n        }\\n        if(p<=1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n=s.size();\\n        int l=1;\\n        int h=n;\\n        int ans=0;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(pos(mid,s)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625862,
                "title": "unique-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string &s){\\n        \\n        int c = 0;\\n        \\n        int i = 0;\\n        while(i<s.size()-1){\\n            \\n            if(s[i]==s[i+1]){\\n                \\n                c++;\\n               \\n            }\\n            \\n            i++;\\n\\n        }\\n        \\n        if(c<=1)return 1;\\n        return 0;\\n        \\n        \\n        \\n    }\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int res = -1e9;\\n        \\n        for(int i = 0;i<s.size();i++){\\n            string st = \"\";\\n            int n = 0;\\n          \\n            \\n            for(int j = i;j<s.size();j++){\\n                st.push_back(s[j]);\\n                \\n                \\n             \\n                \\n                if(check(st)){\\n                    int n = st.size();\\n                    \\n                    res = max(res,n);\\n                }\\n                \\n               \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string &s){\\n        \\n        int c = 0;\\n        \\n        int i = 0;\\n        while(i<s.size()-1){\\n            \\n            if(s[i]==s[i+1]){\\n                \\n                c++;\\n               \\n            }\\n            \\n            i++;\\n\\n        }\\n        \\n        if(c<=1)return 1;\\n        return 0;\\n        \\n        \\n        \\n    }\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int res = -1e9;\\n        \\n        for(int i = 0;i<s.size();i++){\\n            string st = \"\";\\n            int n = 0;\\n          \\n            \\n            for(int j = i;j<s.size();j++){\\n                st.push_back(s[j]);\\n                \\n                \\n             \\n                \\n                if(check(st)){\\n                    int n = st.size();\\n                    \\n                    res = max(res,n);\\n                }\\n                \\n               \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625707,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s) {\\n        int i=0;\\n        int max=0;\\n        int n = s.Length;\\n        if(n < 2)\\n            return n;    \\n        bool found = false;\\n        bool foundAny = false;\\n        while(i < n-1){\\n            int j=i;\\n            //Console.WriteLine(\"start\"+j);\\n            found = false;\\n            while(j < n-1){\\n                if(!found && s[j] == s[j+1]){\\n                    found=true;\\n                    foundAny=true;\\n                    max=Math.Max(max, j+2-i);\\n                    j++;\\n                    continue;\\n                }\\n                \\n                if(s[j] == s[j+1])\\n                {\\n                    //Console.WriteLine(j+1-i);\\n                    max=Math.Max(max, j+1-i);\\n                    break;\\n                }\\n                else{\\n                    //Console.WriteLine(j+2-i);\\n                    max=Math.Max(max, j+2-i);\\n                }\\n                j++;\\n            }\\n            i++;\\n        }\\n        \\n        if(foundAny)\\n            return max;\\n        \\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s) {\\n        int i=0;\\n        int max=0;\\n        int n = s.Length;\\n        if(n < 2)\\n            return n;    \\n        bool found = false;\\n        bool foundAny = false;\\n        while(i < n-1){\\n            int j=i;\\n            //Console.WriteLine(\"start\"+j);\\n            found = false;\\n            while(j < n-1){\\n                if(!found && s[j] == s[j+1]){\\n                    found=true;\\n                    foundAny=true;\\n                    max=Math.Max(max, j+2-i);\\n                    j++;\\n                    continue;\\n                }\\n                \\n                if(s[j] == s[j+1])\\n                {\\n                    //Console.WriteLine(j+1-i);\\n                    max=Math.Max(max, j+1-i);\\n                    break;\\n                }\\n                else{\\n                    //Console.WriteLine(j+2-i);\\n                    max=Math.Max(max, j+2-i);\\n                }\\n                j++;\\n            }\\n            i++;\\n        }\\n        \\n        if(foundAny)\\n            return max;\\n        \\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625492,
                "title": "java-two-pointer-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int max=0;\\n        for(int i=0;i<s.length();i++){\\n            int start=i;\\n            int end=i+1;\\n            int len=0;\\n            int count=0;\\n            int f=0;\\n            while(end<s.length()){\\n                if(s.charAt(start)==s.charAt(end)){\\n                    count++;\\n                }\\n                if(count>=2){\\n                    f=1;\\n                    len=start-i+1;\\n                    break;\\n                }\\n                start++;\\n                end++;\\n            }\\n            if(f==0){\\n                len=end-i;\\n                 max=Math.max(max,len);\\n                break;\\n            }\\n            max=Math.max(max,len);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        int max=0;\\n        for(int i=0;i<s.length();i++){\\n            int start=i;\\n            int end=i+1;\\n            int len=0;\\n            int count=0;\\n            int f=0;\\n            while(end<s.length()){\\n                if(s.charAt(start)==s.charAt(end)){\\n                    count++;\\n                }\\n                if(count>=2){\\n                    f=1;\\n                    len=start-i+1;\\n                    break;\\n                }\\n                start++;\\n                end++;\\n            }\\n            if(f==0){\\n                len=end-i;\\n                 max=Math.max(max,len);\\n                break;\\n            }\\n            max=Math.max(max,len);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625118,
                "title": "kotlin-simple-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\n    fun longestSemiRepetitiveSubstring(s: String): Int {\\n        var left = 0\\n        var max = 1\\n        var last = -1\\n        \\n        for ((right, c) in s.withIndex()){ \\n            if (right > 0 && c == s[right - 1]) {\\n                if (last != -1)\\n                    left = last\\n                last = right\\n            }\\n            \\n            max = maxOf(max, right - left + 1)\\n        }\\n        \\n        return max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun longestSemiRepetitiveSubstring(s: String): Int {\\n        var left = 0\\n        var max = 1\\n        var last = -1\\n        \\n        for ((right, c) in s.withIndex()){ \\n            if (right > 0 && c == s[right - 1]) {\\n                if (last != -1)\\n                    left = last\\n                last = right\\n            }\\n            \\n            max = maxOf(max, right - left + 1)\\n        }\\n        \\n        return max\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624987,
                "title": "python3-clear-code-with-smart-explanation",
                "content": "# Intuition\\nThere is single repetitive character pair in substring at the same time.\\nWe need to reset the start position of current substring to end of previous pair when meet second repetitive character pair.\\n\\n# Complexity\\n\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        substring_start = 0\\n        previous_repetitive_end = -1\\n        result = 1\\n        for index in range(1, len(s)):\\n            if s[index] == s[index - 1]:\\n                if previous_repetitive_end > 0:\\n                    substring_start = previous_repetitive_end\\n                previous_repetitive_end = index\\n            result = max(result, index - substring_start + 1)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        substring_start = 0\\n        previous_repetitive_end = -1\\n        result = 1\\n        for index in range(1, len(s)):\\n            if s[index] == s[index - 1]:\\n                if previous_repetitive_end > 0:\\n                    substring_start = previous_repetitive_end\\n                previous_repetitive_end = index\\n            result = max(result, index - substring_start + 1)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624937,
                "title": "10-lines-of-code-sliding-window-technique-the-simplest-solution-o-n",
                "content": "# Intuition\\nTo be honest this I didn\\'t came up with this solution. Other people solved it in different programming languages during the biweekly contest.\\n\\nThe problem is we need to basically find the longest range in a string such that no more than 2 consuctive same characters are allowed to be present.\\n\\n# Approach\\nWe could usue a brute force approch $$O(n^2)$$ where we try all possible $$i,j$$ but that isn\\'t needed. Because let\\'s assume that the longest semi-reptetive substring from $$i,j$$ is $$x$$ then the longest semi-reptetive substring from $$i,j+1$$ is either 1 meaning we already have more than 2 consequtive repeating characters or it\\'s the longest semi-reptetive substring from $$i,j$$ +1. \\n\\nFrom above we can notice that we are looking to the string through a window that expand from the right or shrink from the left depending on the number of consequtive repeating characters so far.\\n\\n# Complexity\\n- Time complexity:\\nBecause we only visit each character only once the time complexity is $$O(n)$$\\n\\n- Space complexity:\\nBecause we do not store any \"memoization table\" or any hashmap or anything else the space complexity here is only the size of the string without any additinoal memory $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s)\\n    {\\n        int left = 0, ans = 0, reptitves = 0;\\n\\n        for(int right = 0;right < s.Length; right++)\\n        {\\n            if (right > 0 && s[right] == s[right - 1])\\n            {\\n                reptitves++;\\n            }\\n\\n            while(reptitves > 1)\\n            {\\n                if (s[left] == s[left+1])\\n                {\\n                    reptitves--;\\n                }\\n\\n                left++;\\n            }\\n\\n            ans = Math.Max(ans, right - left + 1);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestSemiRepetitiveSubstring(string s)\\n    {\\n        int left = 0, ans = 0, reptitves = 0;\\n\\n        for(int right = 0;right < s.Length; right++)\\n        {\\n            if (right > 0 && s[right] == s[right - 1])\\n            {\\n                reptitves++;\\n            }\\n\\n            while(reptitves > 1)\\n            {\\n                if (s[left] == s[left+1])\\n                {\\n                    reptitves--;\\n                }\\n\\n                left++;\\n            }\\n\\n            ans = Math.Max(ans, right - left + 1);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624885,
                "title": "two-approaches-sliding-window-track-start",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int longestSemi2(string s) {\\n        int ans = 1;\\n        // the previous index such that s[i - 1] == s[i]\\n        int last = 0;\\n        // start of valid substring\\n        int left = 0;\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i - 1] == s[i]) {\\n                if (last) {\\n                    left = last;\\n                }\\n\\n                last = i;\\n            }\\n\\n            ans = max(ans, i - left + 1);\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        return longestSemi2(s);\\n\\n        int ans = 0;\\n        int pairs = 0;\\n        for (int i = 0, j = 0; j < s.size(); j++) {\\n            if (j > 0 && s[j - 1] == s[j]) {\\n                pairs++;\\n            }\\n\\n            while (pairs > 1) {\\n                if (s[i] == s[i + 1]) {\\n                    pairs--;\\n                }\\n\\n                i++;\\n            }\\n\\n            // i <= j - 1\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int longestSemi2(string s) {\\n        int ans = 1;\\n        // the previous index such that s[i - 1] == s[i]\\n        int last = 0;\\n        // start of valid substring\\n        int left = 0;\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i - 1] == s[i]) {\\n                if (last) {\\n                    left = last;\\n                }\\n\\n                last = i;\\n            }\\n\\n            ans = max(ans, i - left + 1);\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        return longestSemi2(s);\\n\\n        int ans = 0;\\n        int pairs = 0;\\n        for (int i = 0, j = 0; j < s.size(); j++) {\\n            if (j > 0 && s[j - 1] == s[j]) {\\n                pairs++;\\n            }\\n\\n            while (pairs > 1) {\\n                if (s[i] == s[i + 1]) {\\n                    pairs--;\\n                }\\n\\n                i++;\\n            }\\n\\n            // i <= j - 1\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624862,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        unordered_map<int,int> m;\\n        int j=0;int count=0;int ans=0;int i;int k=0;\\n        if(s.size()==1)\\n            return 1;\\n        for(i=1;i<s.size();i++)\\n        {\\n            \\n            \\n             if(s[i]==s[i-1])\\n            {\\n           count++;\\n                  if(count>1)\\n            {\\n             \\n                ans=max(ans,i-j);\\n                j=k;\\n                      k=i;\\n                count=1;\\n            }\\n                 else\\n                 {\\n                     k=i;\\n                 }\\n                \\n            }\\n            \\n          \\n            \\n        }\\n          return max(ans,i-j);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        unordered_map<int,int> m;\\n        int j=0;int count=0;int ans=0;int i;int k=0;\\n        if(s.size()==1)\\n            return 1;\\n        for(i=1;i<s.size();i++)\\n        {\\n            \\n            \\n             if(s[i]==s[i-1])\\n            {\\n           count++;\\n                  if(count>1)\\n            {\\n             \\n                ans=max(ans,i-j);\\n                j=k;\\n                      k=i;\\n                count=1;\\n            }\\n                 else\\n                 {\\n                     k=i;\\n                 }\\n                \\n            }\\n            \\n          \\n            \\n        }\\n          return max(ans,i-j);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624765,
                "title": "sliding-window-two-pointers-explained",
                "content": "# Brute\\n\\nDuring Contest, we could just use brute force approach as constraints were very less.\\n\\nFollowing is the brute force solution\\n\\n```\\nclass Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        bool ans =true;\\n        int temp=0;\\n        for(int i =0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])temp++;\\n            if(temp==2) return false;\\n        }\\n        return true;\\n    }\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int n=s.size();\\n        for(int i =n;i>=0;i--)\\n        {\\n            for(int j=0;j<=n-i;j++)\\n            {\\n                string temp=s.substr(j,i);\\n                if(check(temp)) return i;\\n            }\\n                \\n        }\\n        return 2;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $O(n^4)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n^4)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Optimized\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use sliding window and for that we need two pointers\\nAt particular instance\\nl --> starting of desired substring\\nr --> ending of desired substring\\nst --> tells the index of first occurrence of the repetetive elements\\ntemp--> Which tells us how many consecutive elements we got.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate over the string\\nIf two elements are not same, we update our end pointer\\nIf two elements are same, We increase the temp \\niF TEMP>=2, we know we got recurrence, so we update the l to st +1\\nAnd update st with i. As it the next recurrence happening.\\nIf temp<2. We just update the st\\n\\n\\n\\n# Complexity\\n- Time complexity:$O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int l=0;\\n        int r=0;\\n        int st =l;\\n        int temp=0;\\n        int ans=r-l+1;\\n        for(int i =0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                temp++;\\n                if(temp>=2)\\n                {\\n                    temp--;\\n                    l = st+1;\\n                }\\n                st=i;    \\n            }\\n            r++;\\n            ans=max(ans,r-l+1);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        bool ans =true;\\n        int temp=0;\\n        for(int i =0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])temp++;\\n            if(temp==2) return false;\\n        }\\n        return true;\\n    }\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        int n=s.size();\\n        for(int i =n;i>=0;i--)\\n        {\\n            for(int j=0;j<=n-i;j++)\\n            {\\n                string temp=s.substr(j,i);\\n                if(check(temp)) return i;\\n            }\\n                \\n        }\\n        return 2;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int l=0;\\n        int r=0;\\n        int st =l;\\n        int temp=0;\\n        int ans=r-l+1;\\n        for(int i =0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                temp++;\\n                if(temp>=2)\\n                {\\n                    temp--;\\n                    l = st+1;\\n                }\\n                st=i;    \\n            }\\n            r++;\\n            ans=max(ans,r-l+1);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3624764,
                "title": "sliding-window-easy-understanding-most-optimal-solution-o-n-time",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int i=0, j=0, ans=0, cnt=0;\\n\\n        while(j<s.size()){\\n\\n            if(j>0 and s[j] == s[j-1])\\n            cnt++;\\n\\n            if(cnt<=1)\\n            ans = max(ans, j-i+1);\\n\\n            else{\\n\\n                while(cnt>1){\\n\\n                    if(s[i] == s[i+1])\\n                    cnt--;\\n\\n                    i++;\\n\\n                }\\n\\n                if(i<=j)\\n                ans = max(ans, j-i+1);\\n\\n            }\\n\\n            j++;\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n        int i=0, j=0, ans=0, cnt=0;\\n\\n        while(j<s.size()){\\n\\n            if(j>0 and s[j] == s[j-1])\\n            cnt++;\\n\\n            if(cnt<=1)\\n            ans = max(ans, j-i+1);\\n\\n            else{\\n\\n                while(cnt>1){\\n\\n                    if(s[i] == s[i+1])\\n                    cnt--;\\n\\n                    i++;\\n\\n                }\\n\\n                if(i<=j)\\n                ans = max(ans, j-i+1);\\n\\n            }\\n\\n            j++;\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624631,
                "title": "java-easy-two-pointers-100-faster",
                "content": "# Intuition\\nIt is simple use of 3 pointer:\\n      1.left 2.repeat ,3.right\\n\\n Shift each when a pair is repeat.\\n \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTake 1021123522 \\n---->l_____k_____r        \\n\\n\\nk=repeat\\n\\nmake l=k and k=r after each reapeat in loop.So that we can maintain length of substring with only at most a consecutive pair.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        if(s.length()==1 || s.length()==2)return s.length();\\n        int l=0,r=1;\\n        int ans=0;\\n        int repeat=0;\\n        while(r<s.length()){\\n            if(s.charAt(r-1)==s.charAt(r)){\\n               l=repeat;\\n               repeat=r;    \\n            }\\n            ans=Math.max(ans,r-l+1);\\n            r++;\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```\\nPlease like if u understand it.",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSemiRepetitiveSubstring(String s) {\\n        if(s.length()==1 || s.length()==2)return s.length();\\n        int l=0,r=1;\\n        int ans=0;\\n        int repeat=0;\\n        while(r<s.length()){\\n            if(s.charAt(r-1)==s.charAt(r)){\\n               l=repeat;\\n               repeat=r;    \\n            }\\n            ans=Math.max(ans,r-l+1);\\n            r++;\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624628,
                "title": "sliding-window",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans=1;\\n        int same=0;\\n        int i=0,j=1;\\n        int lastDupInd=0;\\n        while(j<(int)s.length()){\\n            if(s[j]==s[j-1]){\\n                if(lastDupInd){\\n                  i=lastDupInd;  \\n                }\\n                lastDupInd=j;\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int ans=1;\\n        int same=0;\\n        int i=0,j=1;\\n        int lastDupInd=0;\\n        while(j<(int)s.length()){\\n            if(s[j]==s[j-1]){\\n                if(lastDupInd){\\n                  i=lastDupInd;  \\n                }\\n                lastDupInd=j;\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624607,
                "title": "find-the-longest-semi-repetitive-substring",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        if len(s)==1:\\n            return 1\\n        else:\\n            l = 0\\n            r = 1\\n            a = 0\\n            count = 0\\n            p = []\\n            while l<len(s)-1:\\n                if s[l]!=s[r] and r!= len(s)-1:\\n                    l+=1\\n                    r+=1\\n                elif s[l]!=s[r] and r== len(s)-1:\\n                    p.append(len(s[a:r+1]))\\n                    break\\n                    \\n                elif s[l]==s[r]:\\n                    count+=1\\n                    if count==1 and r==len(s)-1:\\n                        p.append(len(s[a:r+1]))\\n                        break\\n                    elif count==1:\\n                        d = r\\n                        l+=1\\n                        r+=1\\n                    elif count==2:\\n                        p.append(len(s[a:r]))\\n                        a = d\\n                        count = 0\\n            return(max(p))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        if len(s)==1:\\n            return 1\\n        else:\\n            l = 0\\n            r = 1\\n            a = 0\\n            count = 0\\n            p = []\\n            while l<len(s)-1:\\n                if s[l]!=s[r] and r!= len(s)-1:\\n                    l+=1\\n                    r+=1\\n                elif s[l]!=s[r] and r== len(s)-1:\\n                    p.append(len(s[a:r+1]))\\n                    break\\n                    \\n                elif s[l]==s[r]:\\n                    count+=1\\n                    if count==1 and r==len(s)-1:\\n                        p.append(len(s[a:r+1]))\\n                        break\\n                    elif count==1:\\n                        d = r\\n                        l+=1\\n                        r+=1\\n                    elif count==2:\\n                        p.append(len(s[a:r]))\\n                        a = d\\n                        count = 0\\n            return(max(p))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624540,
                "title": "sliding-window-simple-solution-80-faster-0-n-time-and-0-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsliding window simple approach\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        if(s.size()==1)return 1;\\n        int count=0,i=0,j=0,mx=0;\\n        int temp;\\n        while(j<s.size()-1)\\n        {\\n           if(s[j]==s[j+1] && count==0)\\n            {\\n               temp=j;\\n                count++;\\n            }\\n            else if(s[j]==s[j+1] && count==1)\\n            {\\n            while(i!=temp)\\n            {\\n                i++;\\n            }\\n            i++;\\n            temp=j;\\n            }\\n            j++;\\n             mx=max(mx,j-i+1);\\n            \\n        }\\n        return mx;\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        if(s.size()==1)return 1;\\n        int count=0,i=0,j=0,mx=0;\\n        int temp;\\n        while(j<s.size()-1)\\n        {\\n           if(s[j]==s[j+1] && count==0)\\n            {\\n               temp=j;\\n                count++;\\n            }\\n            else if(s[j]==s[j+1] && count==1)\\n            {\\n            while(i!=temp)\\n            {\\n                i++;\\n            }\\n            i++;\\n            temp=j;\\n            }\\n            j++;\\n             mx=max(mx,j-i+1);\\n            \\n        }\\n        return mx;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624454,
                "title": "python3-multiple-solutions-brute-force-and-sliding-window-0-1-space",
                "content": "BRUTE FORCE:\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        def isValid(newStr):\\n            consecutiveCount=0\\n            for i in range(1,len(newStr)):\\n                if newStr[i]==newStr[i-1]:\\n                    consecutiveCount+=1\\n                if consecutiveCount>1:\\n                    return False\\n            return True\\n        ans=0\\n        for i in range(len(s)):\\n            for j in range(i,len(s)):\\n                if j-i+1>ans and isValid(s[i:j+1]): \\n                    ans=j-i+1\\n        return ans\\n```\\nSLIDING WINDOW:\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        ans=consecutiveCount=l=0\\n        for r in range(len(s)):\\n            if r>0 and s[r]==s[r-1]:\\n                consecutiveCount+=1\\n            while l<r and consecutiveCount>1:\\n                if l+1<len(s) and s[l]==s[l+1]:\\n                    consecutiveCount-=1\\n                l+=1\\n            ans=max(ans,r-l+1)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        def isValid(newStr):\\n            consecutiveCount=0\\n            for i in range(1,len(newStr)):\\n                if newStr[i]==newStr[i-1]:\\n                    consecutiveCount+=1\\n                if consecutiveCount>1:\\n                    return False\\n            return True\\n        ans=0\\n        for i in range(len(s)):\\n            for j in range(i,len(s)):\\n                if j-i+1>ans and isValid(s[i:j+1]): \\n                    ans=j-i+1\\n        return ans\\n```\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        ans=consecutiveCount=l=0\\n        for r in range(len(s)):\\n            if r>0 and s[r]==s[r-1]:\\n                consecutiveCount+=1\\n            while l<r and consecutiveCount>1:\\n                if l+1<len(s) and s[l]==s[l+1]:\\n                    consecutiveCount-=1\\n                l+=1\\n            ans=max(ans,r-l+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624241,
                "title": "simple-o-n-solution-please-upvote-if-you-like-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int j=0;\\n        int t=0;\\n        int maxi=1;\\n        int ind=0;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i-1]==s[i] )\\n            {\\n                t=1;\\n                j=ind;\\n                maxi=max(maxi,i-j+1);\\n                ind=i;\\n            }\\n            else\\n                  maxi=max(maxi,i-j+1);\\n        }\\n        if(t==0)\\n            return s.size();\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int j=0;\\n        int t=0;\\n        int maxi=1;\\n        int ind=0;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i-1]==s[i] )\\n            {\\n                t=1;\\n                j=ind;\\n                maxi=max(maxi,i-j+1);\\n                ind=i;\\n            }\\n            else\\n                  maxi=max(maxi,i-j+1);\\n        }\\n        if(t==0)\\n            return s.size();\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624228,
                "title": "python-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def longestSemiRepetitiveSubstring(self, s):\\n        substrings = []\\n        for i in range(0,len(s)+1):\\n            for j in range(i+1,len(s)+1):\\n                substrings.append(s[i:j])\\n\\n        # print(substrings)\\n        semi = []\\n        for i in range(0,len(substrings)):\\n            count =0\\n            k = substrings[i]\\n            for j in range(0,len(k)-1):\\n                if k[j]==k[j+1]:\\n                    count+=1\\n\\n            if count<=1:\\n                semi.append(k)\\n\\n        max_length = len(semi[0])\\n        for i in range(0,len(semi)):\\n            if len(semi[i])>max_length:\\n                max_length= len(semi[i])\\n\\n        return max_length\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestSemiRepetitiveSubstring(self, s):\\n        substrings = []\\n        for i in range(0,len(s)+1):\\n            for j in range(i+1,len(s)+1):\\n                substrings.append(s[i:j])\\n\\n        # print(substrings)\\n        semi = []\\n        for i in range(0,len(substrings)):\\n            count =0\\n            k = substrings[i]\\n            for j in range(0,len(k)-1):\\n                if k[j]==k[j+1]:\\n                    count+=1\\n\\n            if count<=1:\\n                semi.append(k)\\n\\n        max_length = len(semi[0])\\n        for i in range(0,len(semi)):\\n            if len(semi[i])>max_length:\\n                max_length= len(semi[i])\\n\\n        return max_length\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624166,
                "title": "golang-100-fast-sliding-window",
                "content": "```\\nfunc longestSemiRepetitiveSubstring(s string) int {\\n    c := [10][]int{}\\n    l := 0\\n    r := 0\\n    m := 0\\n    ns := make([]int, len(s))\\n    for i := range s { ns[i] = int(s[i] - byte(48)) }\\n    ch := func(l int) bool {\\n        v := 0\\n        for i := range c {\\n            for j := 1; j < len(c[i]); j++ {\\n                if c[i][j-1]<l { continue }\\n                if c[i][j]-c[i][j-1] == 1 { v++ }\\n            }\\n        }\\n        return v <= 1\\n    }\\n    \\n    for r < len(s) {\\n        c[ns[r]] = append(c[ns[r]], r)\\n        for !ch(l) { l++ }\\n        k := r-l+1\\n        if k > m { m = k }\\n        r++\\n    }\\n    \\n   return m\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestSemiRepetitiveSubstring(s string) int {\\n    c := [10][]int{}\\n    l := 0\\n    r := 0\\n    m := 0\\n    ns := make([]int, len(s))\\n    for i := range s { ns[i] = int(s[i] - byte(48)) }\\n    ch := func(l int) bool {\\n        v := 0\\n        for i := range c {\\n            for j := 1; j < len(c[i]); j++ {\\n                if c[i][j-1]<l { continue }\\n                if c[i][j]-c[i][j-1] == 1 { v++ }\\n            }\\n        }\\n        return v <= 1\\n    }\\n    \\n    for r < len(s) {\\n        c[ns[r]] = append(c[ns[r]], r)\\n        for !ch(l) { l++ }\\n        k := r-l+1\\n        if k > m { m = k }\\n        r++\\n    }\\n    \\n   return m\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3624066,
                "title": "two-pointer-very-simple-and-easy-to-understand-solution",
                "content": "Intution\\n1. We just have to keep track of index of second element of occurence , so we store in queue.\\n2. Once we found new pair of element we will shift i to queue front.\\n\\nExplaination\\n   i\\n   5 2 2 4 3 3\\n   j\\n// queue={};\\n\\n i\\n5  2  2 4 3 3 \\n         j\\n// queue={2} ......index of second occurence of two\\n\\ni\\n5  2  2  4  3  3\\n                    j\\n\\t\\t\\t\\t\\t\\n// queue={2,5}\\n// size of queue must me less then equal to 1.\\nso , i=queue.front(); // i=2;\\nqueue={5};\\n\\nand so on.......\\n\\n\\t\\t\\t\\t\\t\\n\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n       int maxLength=1;\\n       queue<int>q;\\n       int i=0;\\n       for(int j=1;j<s.length();j++){\\n           \\n           if(s[j]==s[j-1])q.push(j);\\n           if(q.size()>=2){\\n                i=q.front();\\n               q.pop();\\n           }\\n          maxLength=max(maxLength,j-i+1);\\n       }\\n            \\n        \\n     return maxLength;   \\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        \\n       int maxLength=1;\\n       queue<int>q;\\n       int i=0;\\n       for(int j=1;j<s.length();j++){\\n           \\n           if(s[j]==s[j-1])q.push(j);\\n           if(q.size()>=2){\\n                i=q.front();\\n               q.pop();\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3623957,
                "title": "python-3-simple-two-pointer-and-dictionary-approach-o-n-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/04af7b4a-8182-45a5-b90c-d344a84beb4a_1686456877.880312.png)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfrom collections import defaultdict,deque\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        d = defaultdict(int)\\n        maxi , i , flag , q = 0 , 0 , 0 , deque()\\n        for j,c in enumerate(s):\\n            \\n            if c in d:\\n                \\n                if s[j-1] == c:\\n                    flag += 1\\n                    if flag == 2:\\n                        flag -= 1\\n                        maxi = max(maxi , j-i)\\n                        i = q.popleft()\\n                        q.append(j)\\n                        d = defaultdict(int)\\n                        \\n                    \\n                    else:\\n                        q.append(j)\\n\\n            d[c] += 1\\n        \\n        return max(maxi , (j-i+1))\\n\\n                        \\n                    \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nfrom collections import defaultdict,deque\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        d = defaultdict(int)\\n        maxi , i , flag , q = 0 , 0 , 0 , deque()\\n        for j,c in enumerate(s):\\n            \\n            if c in d:\\n                \\n                if s[j-1] == c:\\n                    flag += 1\\n                    if flag == 2:\\n                        flag -= 1\\n                        maxi = max(maxi , j-i)\\n                        i = q.popleft()\\n                        q.append(j)\\n                        d = defaultdict(int)\\n                        \\n                    \\n                    else:\\n                        q.append(j)\\n\\n            d[c] += 1\\n        \\n        return max(maxi , (j-i+1))\\n\\n                        \\n                    \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623931,
                "title": "c-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i = 0 , j = 0; \\n        int res = 0;\\n        int n=s.size(); \\n        int tmp = 1; \\n        if(n<=2 ) return n; \\n        for(j=1;j<n;j++) \\n        { \\n            tmp++; \\n            if(s[j]==s[j-1]){ \\n                tmp = j-i+1; \\n                i = j; \\n            } \\n      if(res<tmp)\\n       {res = tmp;\\n       }    \\n        } \\n        return res; \\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int i = 0 , j = 0; \\n        int res = 0;\\n        int n=s.size(); \\n        int tmp = 1; \\n        if(n<=2 ) return n; \\n        for(j=1;j<n;j++) \\n        { \\n            tmp++; \\n            if(s[j]==s[j-1]){ \\n                tmp = j-i+1; \\n                i = j; \\n            } \\n      if(res<tmp)\\n       {res = tmp;\\n       }    \\n        } \\n        return res; \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623767,
                "title": "c-100-100-beats-sliding-window-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\nTwo pointer Approach \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        //conventional approach of sliding window\\n\\n        int start=0, end=1, count=0, ans=1;\\n        while(end<s.length())\\n        {\\n            if(s[end]==s[end-1])\\n            {\\n                count++;\\n                if(count==2)\\n                {\\n                    while(count!=1)\\n                    {\\n                        if(s[start]==s[start+1])\\n                            count--;\\n                        \\n                        start++;\\n                    }\\n                }\\n            }\\n            ans = max(ans, end-start+1);\\n            end++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) \\n    {\\n        //conventional approach of sliding window\\n\\n        int start=0, end=1, count=0, ans=1;\\n        while(end<s.length())\\n        {\\n            if(s[end]==s[end-1])\\n            {\\n                count++;\\n                if(count==2)\\n                {\\n                    while(count!=1)\\n                    {\\n                        if(s[start]==s[start+1])\\n                            count--;\\n                        \\n                        start++;\\n                    }\\n                }\\n            }\\n            ans = max(ans, end-start+1);\\n            end++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1923761,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1923965,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1923770,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1923834,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1926205,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1925859,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1924482,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1927566,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2038499,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1997718,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1923761,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1923965,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1923770,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1923834,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1926205,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1925859,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1924482,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1927566,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2038499,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1997718,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "What do we exactly mean by \"Consecutive pair of same digits\"?"
                    },
                    {
                        "username": "Qlipoth",
                        "content": "[@guptatanish145](/guptatanish145) the clearest explanation!"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@looooooooooooooooooooool](/looooooooooooooooooooool) I was super-confuse while solving this question in contest, but I understood the question properly when contest ended \\uD83D\\uDE05"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thanks! Got it."
                    },
                    {
                        "username": "looooooooooooooooooooool",
                        "content": "Same question I had, I ended up complicating the solution too much and failed to solve the problem during the contest. But let\\'s be honest, from the problem statement the examples are very clear. \"For example, 0010, 002020, 0123, 2002, and 54944 are semi-repetitive while 00101022, and 1101234883 are not.\"\\nBut I totally agree. The must have made the problem statement more clear."
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Just to add more clarity for \"Consecutive part\" : pair( Ai, Bj ) -> abs(i - j) == 1. Rest you can refer to other comments."
                    },
                    {
                        "username": "guptatanish145",
                        "content": "consider an example \"122433\"\\nif we take a substring from index 0 to 3 we have a one consecutive pair which is \"22\" but it if we take a substring from 0 to 5 we have two consecutive pair which is \"22\" and \"33\". According to the question you have to find the longest length substring which has at most one consecutive pairs. Hope it helps ."
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "back to back same digits like 1111.... but pair is also mentioned here so consecutive digits of length only 2."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "who set the test case for consecutive zero ,please contact with me I need that stuff what you taken in times of set this leading zero test cases."
                    },
                    {
                        "username": "victCh",
                        "content": "Why for \"1111111\" expected 2, but for \"0001\" expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "Welcome:) Try to solve this problem now you can do it!!!"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) Thanks, finally understand"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "0 0\nyou picked this much\nthen you try to pick next 0 which you can't as only 2 same digit consecutive elements are allowed.\nSo to pick this new 0 you drop first 0\nearlier \n0 0\n_  0  0 now\n _  0  0  1 which is length 3.Thus, answer"
                    },
                    {
                        "username": "victCh",
                        "content": "[@Ryuga8150](/Ryuga8150) but what about 0001, why expected 3?"
                    },
                    {
                        "username": "Ryuga8150",
                        "content": "its consecutive pair meaning in your current window only consecutive numbers (length of only 2 elements) can exist.\\n\\nex\\n1 1\\n   1  1 to pick this new one old 1 have to be dropped\\nSimilarly for next\\n"
                    },
                    {
                        "username": "asthakul17",
                        "content": "in this \"5494\" there is nothing consecutive? so how output is 4?explain"
                    },
                    {
                        "username": "Luci831",
                        "content": "There should be atmost 1 consecutive pair. So as you pointed out correctly there are zero consecutive digits hence we should consider the entire string it breaks only when there are more than 1 consecutive digits found . Hope this helps."
                    },
                    {
                        "username": "Sudhanshu_Prasad",
                        "content": "It is asking for at most 1 pair means if there are no pairs or one pair both are valid therefore the output is is 4. "
                    },
                    {
                        "username": "iota_codes",
                        "content": "statement says atmost one, there may not be any\\n"
                    },
                    {
                        "username": "sunilpanchal",
                        "content": "I am still not able to understand what I need to do in this question? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rslay",
                        "content": "You should really rename this question and problem statement from \"semi-repetitive\" to \"basic\" or something like that. It\\'s confusing because semi-repetitive is a misnomer; `0123` is not semi-repetitive in any way! Yet it falls under the classification of \"semi-repetitive\" because it has less than two repeating digit pairs."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "These sample Examples were added after contest \\uD83E\\uDD74\\uD83E\\uDD74\\uD83D\\uDE20 and I suffered in contest  to understand what is semi-repetitive and got a hell lot of WA."
                    },
                    {
                        "username": "LesterEvSe",
                        "content": "What is a line without repetition? A string where there is not a single repetition, such as **123478** or **0593**, etc.\nHowever, it is possible to repeat characters in this assignment.\nFor example, **5989** or **123123**.\n\nThe restriction is that there must not be more than one repeating pair of digits.\nFor example **12001233** is not allowed because we have **> 1** repeating pair of digits **(that is 00 and 33)**."
                    },
                    {
                        "username": "yashsaini8438",
                        "content": "For s = \"24489929009\", answer expected is given to be 7, my solution produces 6 as answer, which i find to be the correct answer because longest semi-repetitive sub-string will be 929009 which is of length 6, \\n\\nCAN ANYBODY EXPLAIN, IS SOMETHING WRONG WITH THE TESTCASE OR IS IT MY OUTPUT?"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Share 2 different common sliding window methods:\\n\\npivot left, right keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = 0;\\n\\n        int j = 0;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (j < n && (count + (j > i && s[j] == s[j - 1]) < 2)) {\\n                count += (j > i && s[j] == s[j - 1]);\\n                j++;\\n            }\\n\\n            res = max(res, j - i);\\n\\n            if (i + 1 < n && s[i + 1] == s[i]) count--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\npivot right, left keep moving forward\\n```\\nclass Solution {\\npublic:\\n    int longestSemiRepetitiveSubstring(string s) {\\n        int n = s.size();\\n        int res = INT_MIN;\\n\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n\\n        for (; right < n; right++) {\\n            if (right > 0 && s[right] == s[right - 1]) count++;\\n\\n            while (count > 1) {\\n                res = max(res, right - left);\\n                if (left + 1 < n && left < right && s[left] == s[left + 1]) count--;\\n                left++;\\n            }\\n        }\\n\\n\\n        if (res == INT_MIN || count <= 1) {\\n            if (left == 0) res = n;\\n            if (left != 0) res = max(res, right-left);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Value of the Partition",
        "question_content": "<p>You are given a <strong>positive</strong> integer array <code>nums</code>.</p>\n\n<p>Partition <code>nums</code> into two arrays,&nbsp;<code>nums1</code> and <code>nums2</code>, such that:</p>\n\n<ul>\n\t<li>Each element of the array <code>nums</code> belongs to either the array <code>nums1</code> or the array <code>nums2</code>.</li>\n\t<li>Both arrays are <strong>non-empty</strong>.</li>\n\t<li>The value of the partition is <strong>minimized</strong>.</li>\n</ul>\n\n<p>The value of the partition is <code>|max(nums1) - min(nums2)|</code>.</p>\n\n<p>Here, <code>max(nums1)</code> denotes the maximum element of the array <code>nums1</code>, and <code>min(nums2)</code> denotes the minimum element of the array <code>nums2</code>.</p>\n\n<p>Return <em>the integer denoting the value of such partition</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,2,4]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We can partition the array nums into nums1 = [1,2] and nums2 = [3,4].\n- The maximum element of the array nums1 is equal to 2.\n- The minimum element of the array nums2 is equal to 3.\nThe value of the partition is |2 - 3| = 1. \nIt can be proven that 1 is the minimum value out of all partitions.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [100,1,10]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> We can partition the array nums into nums1 = [10] and nums2 = [100,1].\n- The maximum element of the array nums1 is equal to 10.\n- The minimum element of the array nums2 is equal to 1.\nThe value of the partition is |10 - 1| = 9.\nIt can be proven that 9 is the minimum value out of all partitions.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3650777,
                "title": "min-consecutive-value-very-simple-and-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution</b>\\n\\n# Approach\\n- Sort the array\\n- Now we can split the array in to part from the point where the two consicutive elemnts have min difference. So the lower side array have max value and the next element is the min of the next upper side array section.\\n- so keep iterating to get the min diff betteen two consicutive elements.\\n\\n# Code\\n```\\nint findValueOfPartition(vector<int>& nums) {\\n    int ans = INT_MAX;\\n    sort(nums.begin(), nums.end());\\n    for(int i = 1; i < nums.size(); ++i) ans = min(ans, nums[i] - nums[i-1]);\\n    return ans;\\n}\\n```\\n<b>Here is an article of my recent interview experience at Amazon, you may like :\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint findValueOfPartition(vector<int>& nums) {\\n    int ans = INT_MAX;\\n    sort(nums.begin(), nums.end());\\n    for(int i = 1; i < nums.size(); ++i) ans = min(ans, nums[i] - nums[i-1]);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650441,
                "title": "java-c-python-sort",
                "content": "# **Explanation**\\nSort the input `A`\\nThe result must be the minimum difference of 2 adjacent elements.\\n\\nWe put `A[0] ... A[i - 1]` in array `nums1`\\nWe put `A[i] ... A[n - 1]` in array `nums2`\\n\\nso `|max(nums1) - min(nums2)| = A[i] - A[i - 1]`,\\nonly need to find out `min(A[i] - A[i - 1])`\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int findValueOfPartition(int[] A) {\\n        Arrays.sort(A);\\n        int res = A[1] - A[0], n = A.length;\\n        for (int i = 2; i < n; i++)\\n            res = Math.min(res, A[i] - A[i - 1]);\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int findValueOfPartition(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = A[1] - A[0], n = A.size();\\n        for (int i = 2; i < n; i++)\\n            res = min(res, A[i] - A[i - 1]);\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def findValueOfPartition(self, A: List[int]) -> int:\\n        A.sort()\\n        return min(A[i] - A[i - 1] for i in range(1, len(A)))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int findValueOfPartition(int[] A) {\\n        Arrays.sort(A);\\n        int res = A[1] - A[0], n = A.length;\\n        for (int i = 2; i < n; i++)\\n            res = Math.min(res, A[i] - A[i - 1]);\\n        return res;\\n    }\\n```\n```cpp\\n    int findValueOfPartition(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = A[1] - A[0], n = A.size();\\n        for (int i = 2; i < n; i++)\\n            res = min(res, A[i] - A[i - 1]);\\n        return res;\\n    }\\n```\n```py\\n    def findValueOfPartition(self, A: List[int]) -> int:\\n        A.sort()\\n        return min(A[i] - A[i - 1] for i in range(1, len(A)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3650464,
                "title": "very-simple-and-beginner-friendly-with-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to partition `nums` in such a `max(nums1)` - `min(nums2)` id minimum.\\nWe know that in an `Sorted Array` the minimum difference between any two pairs `(i, j)` of the array would be minimum difference between `(i, i + 1)`.\\nEx: `1,2,3,4,5` diff between `1 & 2` is always less than `1,3` & `1, 4` & `1,5`. Similarly for all adjacent pairs.\\n\\nAssume a Sorted array `....a,b,c,d.....` if we choose `c` to be minium of `nums2` and `b` to be maximum of `nums1`.\\nWe can do this by partitioning `.....ab` & `cd.....`.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPartition at each index and find minimum.\\n`....a` & `bcd...` (b - a)\\n`....ab` & `cd...` (c - b)\\n`....abc` & `d...` (d - c)\\n\\n# Complexity\\n- Time complexity:`O(N * Log(N))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int ans = 1e9;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 1; i < nums.size(); i++){\\n            ans = min(ans, nums[i] - nums[i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int ans = 1e9;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 1; i < nums.size(); i++){\\n            ans = min(ans, nums[i] - nums[i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650429,
                "title": "c-sort-and-get-adjacent-minimum",
                "content": "# if this code helps you, please upvote solution. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int ans = nums[n-1];\\n        for(int i = 1; i < n; i++){\\n            ans = min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int ans = nums[n-1];\\n        for(int i = 1; i < n; i++){\\n            ans = min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650594,
                "title": "adjacent-minimum",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(b - a for a, b in zip(nums, nums[1:]))   \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(b - a for a, b in zip(nums, nums[1:]))   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670874,
                "title": "very-easy-c-3-liner-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        // there\\'s no problem with the order of the elements\\n        // so sort them first\\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n        int res = nums[1]-nums[0];\\n\\t\\t\\n        for(int i = 1 ; i < nums.size() ; i++) res = min(res, nums[i]-nums[i-1]);\\n\\t\\t\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        // there\\'s no problem with the order of the elements\\n        // so sort them first\\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n        int res = nums[1]-nums[0];\\n\\t\\t\\n        for(int i = 1 ; i < nums.size() ; i++) res = min(res, nums[i]-nums[i-1]);\\n\\t\\t\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651210,
                "title": "python-3-2-lines-w-explanation-t-m-79-100",
                "content": "Here\\'s an explanation of the code:\\n\\n- Sorting the array allows us to find the minimum difference between adjacent elements efficiently.\\n- The method then calculates the minimum difference between adjacent elements in the sorted nums array using a generator expression: `nums[i] - nums[i-1]` for i in `range(1,len(nums))`, which gives us the differences between adjacent elements.\\n- The `min` function is used to find the smallest difference among all the calculated differences. This represents the minimum absolute difference between the maximum element of `nums1 `and the minimum element of `nums2`.\\n- The code returns that minimum difference.  *--ChatGPT*\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n\\n        return min(nums[i] - nums[i-1] for i in range(1,len(nums)))\\n```\\n[https://leetcode.com/problems/find-the-value-of-the-partition/submissions/973850230/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(1), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n\\n        return min(nums[i] - nums[i-1] for i in range(1,len(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650566,
                "title": "c-o-nlogn",
                "content": "take the minimum between two adjacent after sorting\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int ans=INT_MAX;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ans=min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Brainteaser",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int ans=INT_MAX;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ans=min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650430,
                "title": "java-sorting-5-lines-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$ used by the sorting algorithm\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int findValueOfPartition(int[] nums) {\\n    int n = nums.length, ans = Integer.MAX_VALUE;\\n    Arrays.sort(nums);\\n    \\n    for (var i=0; i < n-1; i++)\\n      ans = Math.min(ans, nums[i+1] - nums[i]);\\n    \\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n  public int findValueOfPartition(int[] nums) {\\n    int n = nums.length, ans = Integer.MAX_VALUE;\\n    Arrays.sort(nums);\\n    \\n    for (var i=0; i < n-1; i++)\\n      ans = Math.min(ans, nums[i+1] - nums[i]);\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650468,
                "title": "easy-short-efficient-clean-code",
                "content": "The partitions are actually subsequences. Lets say we partition arr into :\\npa = [x1, x2, .. xm]\\npb = [y1, y2, .. yn]\\nThe answer is abs(xm-y1);\\nThe only choices that matter are those of xm and y1 ; rest do not.\\nThus we need to check for every possible xi, the closest yj to form (xm, y1) = (xi, yj).\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>&v) {\\n        int n=v.size();\\n        sort(begin(v), end(v), greater<int>());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;++i){\\n            ans=min(ans, v[i]-v[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>&v) {\\n        int n=v.size();\\n        sort(begin(v), end(v), greater<int>());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;++i){\\n            ans=min(ans, v[i]-v[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650453,
                "title": "simple-java-o-nlogn-solution-using-sorting",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i=nums.length-1; i>0; i--) {\\n            int diff = nums[i] - nums[i-1];\\n            minDiff = Math.min(diff, minDiff);\\n        }\\n        \\n        return minDiff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i=nums.length-1; i>0; i--) {\\n            int diff = nums[i] - nums[i-1];\\n            minDiff = Math.min(diff, minDiff);\\n        }\\n        \\n        return minDiff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650447,
                "title": "simple-short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;\\n        for(int i=1; i<nums.length; i++){\\n            min = Math.min(min,Math.abs(nums[i]-nums[i-1]));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;\\n        for(int i=1; i<nums.length; i++){\\n            min = Math.min(min,Math.abs(nums[i]-nums[i-1]));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784187,
                "title": "java-easy-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution must be the  minimum difference between two adjacent elements after sorting the array `nums`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter sorting the array `nums` check for the minimum difference between adjacent elements and return the minimum difference\\n\\n# Complexity\\n- Time complexity: O(nlogn) *for sorting*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn) *used by sorting algorithm*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n     Arrays.sort(nums);\\n     int res = nums[1] - nums[0];\\n     for(int i = 2; i < nums.length; i ++) \\n         res = Math.min(res, nums[i] - nums[i - 1]);\\n     return res;  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n     Arrays.sort(nums);\\n     int res = nums[1] - nums[0];\\n     for(int i = 2; i < nums.length; i ++) \\n         res = Math.min(res, nums[i] - nums[i - 1]);\\n     return res;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690255,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        m=nums[-1]\\n        for i in range(len(nums)-1):\\n            m=min(m, abs(nums[i]-nums[i+1]))\\n        return m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        m=nums[-1]\\n        for i in range(len(nums)-1):\\n            m=min(m, abs(nums[i]-nums[i+1]))\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656710,
                "title": "python-elegant-short-one-line-pairwise-sort",
                "content": "# Complexity\\n- Time complexity: $$O(n * \\\\log_2 {n})$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        return min(y - x for x, y in pairwise(sorted(nums)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        return min(y - x for x, y in pairwise(sorted(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655437,
                "title": "easy-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res=1000000008\\n        for i in range(len(nums)):\\n            if res>nums[i]-nums[i-1]:\\n                res=abs(nums[i]-nums[i-1])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res=1000000008\\n        for i in range(len(nums)):\\n            if res>nums[i]-nums[i-1]:\\n                res=abs(nums[i]-nums[i-1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653012,
                "title": "java-sort",
                "content": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int res = nums[1] - nums[0];\\n        for (int i = 2; i < nums.length; i++)\\n            res = Math.min(res, nums[i] - nums[i - 1]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int res = nums[1] - nums[0];\\n        for (int i = 2; i < nums.length; i++)\\n            res = Math.min(res, nums[i] - nums[i - 1]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652072,
                "title": "c-sort-easy-with-explanation",
                "content": "Since we have to minimise the difference between max element of first array and min element of second array we have to find two consecutive element with least difference. when we find these two element it will always be possible to make nums1 and nums2 as the elements less than max element can be placed in nums1 and element greater than min of nums2 can be placed in nums2.\\nSo sort array and find min difference.\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        int mini= INT_MAX;\\n        for(int i=1; i<n; i++){\\n            mini= min(nums[i]-nums[i-1],mini);\\n        }\\n        return mini;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        int mini= INT_MAX;\\n        for(int i=1; i<n; i++){\\n            mini= min(nums[i]-nums[i-1],mini);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3651674,
                "title": "easy-o-n-solution-begginer-friendly",
                "content": "# Intuition\\nJust use the max occuring diff and check if any less is present or not.\\n\\n# Approach\\nSort the array and take the max difference and check while iterating over the loop.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int dif=nums[n-1]-nums[n-2];\\n        for(int i=1;i<n;i++){\\n            dif=min(dif,nums[i]-nums[i-1]);\\n        }\\n        return dif;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int dif=nums[n-1]-nums[n-2];\\n        for(int i=1;i<n;i++){\\n            dif=min(dif,nums[i]-nums[i-1]);\\n        }\\n        return dif;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650858,
                "title": "java-simple-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-1; i++){\\n            if(nums[i+1] - nums[i] < min) min = nums[i+1] - nums[i];\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-1; i++){\\n            if(nums[i+1] - nums[i] < min) min = nums[i+1] - nums[i];\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657504,
                "title": "adjacent-minimum",
                "content": "# Approach\\nSort the array and return the minimum of difference of adjancents.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int ans = 1e9;\\n        int n = nums.size();\\n        sort(begin(nums),end(nums));\\n        for(int i=0;i<n-1;i++){\\n            int val = nums[i+1] - nums[i];\\n            ans = min(ans,val);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int ans = 1e9;\\n        int n = nums.size();\\n        sort(begin(nums),end(nums));\\n        for(int i=0;i<n-1;i++){\\n            int val = nums[i+1] - nums[i];\\n            ans = min(ans,val);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656268,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans=INT_MAX;\\n        for(int i=1;i<nums.size();i++){\\n            ans= min(ans, nums[i]-nums[i-1]);\\n}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans=INT_MAX;\\n        for(int i=1;i<nums.size();i++){\\n            ans= min(ans, nums[i]-nums[i-1]);\\n}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655091,
                "title": "python-sorting-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        minVal=max(nums)\\n        for i in range(len(nums)-1):\\n            minVal=min(minVal,abs(nums[i]-nums[i+1]))\\n        return minVal\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        minVal=max(nums)\\n        for i in range(len(nums)-1):\\n            minVal=min(minVal,abs(nums[i]-nums[i+1]))\\n        return minVal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653669,
                "title": "easy-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        int mini = INT_MAX;\\n        for(int i=0; i<nums.size()-1; i++){\\n            mini = min(mini,nums[i+1]-nums[i]);\\n        }\\n\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        int mini = INT_MAX;\\n        for(int i=0; i<nums.size()-1; i++){\\n            mini = min(mini,nums[i+1]-nums[i]);\\n        }\\n\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653544,
                "title": "python3-easy-explained-nlogn-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The problem tells us that we must make a partition where nums1 and nums2 are non empty. \\n\\n2. If we sort the array, we can make a partition between each pair of adajacent elements where the left element would always be the max of nums1 and the right element in the pair will always be the min of nums2.\\n3. In this way, we can check all possible partitions, save the min as we go, and return it once were through every pair\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. initialize a min variable to save the min partition value\\n2. sort nums\\n3. iterate over nums array from 1->len(nums)\\n4. compare each adajacent pair with the calculation given in the problem: abs(nums[i] - nums[i-1])\\n5. return the min diff\\n\\n~If this was helpful please upvote! \\n~Thanks for reading :)\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe sort nums and then iterate over nums which is bounded by nlogn for sorting.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOur only additional space comes from min_diff\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n           \\n        nums.sort()\\n        min_diff = float(\\'inf\\')\\n        \\n        for i in range(1,len(nums)):\\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\\n            \\n        return min_diff\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n           \\n        nums.sort()\\n        min_diff = float(\\'inf\\')\\n        \\n        for i in range(1,len(nums)):\\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\\n            \\n        return min_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652709,
                "title": "easy-java-c",
                "content": "Java O(N)  Solution\\n```\\nclass Solution {\\n public static int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            ans=Math.min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nC++ O(N) Solution\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=INT_MAX;\\n        for(int i=1;i<nums.size();i++){\\n            res=min(res,nums[i]-nums[i-1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n public static int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            ans=Math.min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=INT_MAX;\\n        for(int i=1;i<nums.size();i++){\\n            res=min(res,nums[i]-nums[i-1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651490,
                "title": "short-and-easy-c-solution-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mn = INT_MAX;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] != nums[i-1]);\\n            mn = min(mn, nums[i] - nums[i-1]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mn = INT_MAX;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] != nums[i-1]);\\n            mn = min(mn, nums[i] - nums[i-1]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651072,
                "title": "java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int val = Integer.MAX_VALUE;\\n        for(int i=0 ; i<nums.length-1 ; i++){\\n            val=Math.min(val,(nums[i+1]-nums[i]));\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int val = Integer.MAX_VALUE;\\n        for(int i=0 ; i<nums.length-1 ; i++){\\n            val=Math.min(val,(nums[i+1]-nums[i]));\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650928,
                "title": "easy-4-line-c-code",
                "content": "\\n\\n\\n# Approach\\nFirst sort the array in accending order and then take the minimum of adjecent elements\\n\\nThe mininum is the answer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- $$O(nlog(n))$$\\n\\n- Space complexity:\\n- As we are not using any additional space therefore $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int mn = INT_MAX; \\n        for(int i = 0; i < nums.size()-1; i++)\\n        {\\n            mn = min(mn, nums[i+1] - nums[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int mn = INT_MAX; \\n        for(int i = 0; i < nums.size()-1; i++)\\n        {\\n            mn = min(mn, nums[i+1] - nums[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650844,
                "title": "sorting-solution-for-c-explanation-complexity",
                "content": "\\n# Approach\\n  \\xA0 The partition will be minimized when the two consecutive elements in the source array have the minimum difference. This division will result in the first sub-array having the maximum value, and the following element will be the minimum of the next sub-array.\\n\\xA0 To apply this approach, we need to sort the source array first and then successively check two elements to find the minimum difference.\\n\\n# Complexity\\n- Time complexity: O(n * log(n))\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinPartitionValue(int[] nums)\\n    {\\n        System.Array.Sort(nums);\\n\\n        var minValue = int.MaxValue;\\n\\n        for (var i = 1; i < nums.Length; i++)\\n        {\\n            minValue = Math.Min(nums[i] - nums[i - 1], minValue);\\n        }\\n\\n        return minValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinPartitionValue(int[] nums)\\n    {\\n        System.Array.Sort(nums);\\n\\n        var minValue = int.MaxValue;\\n\\n        for (var i = 1; i < nums.Length; i++)\\n        {\\n            minValue = Math.Min(nums[i] - nums[i - 1], minValue);\\n        }\\n\\n        return minValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650822,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[i+1]-nums[i] for i in range(len(nums)-1))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[i+1]-nums[i] for i in range(len(nums)-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650744,
                "title": "5-lines-python-code-simple-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        m=nums[-1]\\n        for i in range(n-1):\\n            m = min(nums[i+1]-nums[i],m)\\n        return m\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        m=nums[-1]\\n        for i in range(n-1):\\n            m = min(nums[i+1]-nums[i],m)\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650699,
                "title": "c-adjacent-minimum",
                "content": "# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        const int n = nums.size();\\n        int ans = INT_MAX;\\n        for(int i=1;i<n;++i){\\n            ans = min(ans,abs(nums[i]-nums[i-1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        const int n = nums.size();\\n        int ans = INT_MAX;\\n        for(int i=1;i<n;++i){\\n            ans = min(ans,abs(nums[i]-nums[i-1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650621,
                "title": "c-simple-and-crisp-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        for(int i=1;i<nums.size();i++){\\n            ans=min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        for(int i=1;i<nums.size();i++){\\n            ans=min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650585,
                "title": "simple-js-solution-o-n-log-n",
                "content": "# Intuition\\nTo get the best result min value of first array should be as close as possible to max value of second array.\\n\\nSince we are free to adjust the order, it\\'s safe to assume that any number can be made either max of one array or min of another.\\n\\nKnowing that, we can check any possible pair.\\n\\nOut of all possible pairs, the most suitable ones are adjacent numbers of sorterd array.\\n\\n# Approach\\nSort the array\\nGet the smallest absolute difference between two adjacent numbers.\\n\\n# Complexity\\n- Time complexity: O(n log(n))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nvar findValueOfPartition = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    let res = Infinity\\n    \\n    for (let i=0; i<nums.length-1; i++) {\\n        const diff = Math.abs(nums[i] - nums[i+1])\\n        if (diff < res) {\\n            res = diff\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar findValueOfPartition = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    let res = Infinity\\n    \\n    for (let i=0; i<nums.length-1; i++) {\\n        const diff = Math.abs(nums[i] - nums[i+1])\\n        if (diff < res) {\\n            res = diff\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650506,
                "title": "c-easy-solution-sorting-and-finding-the-minimum-difference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSorting\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        \\n        int ans=INT_MAX;\\n        \\n       for(int i=0;i<nums.size()-1;i++){\\n           if(abs(nums[i] - nums[i+1]) < ans ){\\n               ans=abs(nums[i] - nums[i+1]);\\n           }\\n       }\\n        \\n     \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        \\n        int ans=INT_MAX;\\n        \\n       for(int i=0;i<nums.size()-1;i++){\\n           if(abs(nums[i] - nums[i+1]) < ans ){\\n               ans=abs(nums[i] - nums[i+1]);\\n           }\\n       }\\n        \\n     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650487,
                "title": "image-representation-well-explained-java-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven in the question, we need to partition the array into 2 sub arrays such that the absolute difference between the max element of first array and min element of second array.\\n\\nLet\\'s think can we solve this by using Brute force approach as per given constraints?\\nThe answer is no, absolutely it will be a TLE.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHow about using the sorting property as when the elements are in a particular order then their adjacent difference will be less right.\\nIf we choose any inbetween index, the max element will be at leftmost of first array and min element will be at rightmost of second array.\\nSo, by finding the adjacency difference between the elements, we can partition the array into two subarrays.\\nSteps : \\n1. Sort the array.\\n2. Find the min adjacency difference between the elements.\\n\\nBelow example picture will give you the clear understanding.\\n\\n\\n![leetcode_june_18.jpg](https://assets.leetcode.com/users/images/48b495ca-8f09-4198-ba04-09a88104ab5e_1687059909.3547559.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Amortized $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/cdfc2b6b-cf9a-4eac-a7f0-e055f86d1237_1687060624.0958745.jpeg)\\n\\n\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        Arrays.sort(nums); //step-1\\n        \\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if( (nums[i]-nums[i-1])<min ) //step-2\\n            {\\n                min=(nums[i]-nums[i-1]);\\n            }\\n            \\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```java []\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        Arrays.sort(nums); //step-1\\n        \\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if( (nums[i]-nums[i-1])<min ) //step-2\\n            {\\n                min=(nums[i]-nums[i-1]);\\n            }\\n            \\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650455,
                "title": "sort-minimum-gap-direct",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int mini=INT_MAX,n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++){\\n            mini=min(mini,abs(nums[i]-nums[i-1]));\\n        }\\n        return mini;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int mini=INT_MAX,n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++){\\n            mini=min(mini,abs(nums[i]-nums[i-1]));\\n        }\\n        return mini;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063567,
                "title": "very-easy-approach-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(nlogn)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n      int ans=INT_MAX;\\n      int maxi=INT_MIN;\\n      int mini=INT_MAX;\\n      sort(nums.begin(),nums.end());\\n      for(int i=0; i<nums.size()-1 ; i++){\\n          maxi=max(maxi,nums[i]);\\n          mini=min(mini,nums[i+1]);\\n          ans=min(ans,abs(maxi-mini));\\n          mini=INT_MAX;\\n\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n      int ans=INT_MAX;\\n      int maxi=INT_MIN;\\n      int mini=INT_MAX;\\n      sort(nums.begin(),nums.end());\\n      for(int i=0; i<nums.size()-1 ; i++){\\n          maxi=max(maxi,nums[i]);\\n          mini=min(mini,nums[i+1]);\\n          ans=min(ans,abs(maxi-mini));\\n          mini=INT_MAX;\\n\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030250,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=999999999;\\n        for(int i=0;i<nums.size()-1;i++){\\n            ans=min(abs(nums[i]-nums[i+1]),ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=999999999;\\n        for(int i=0;i<nums.size()-1;i++){\\n            ans=min(abs(nums[i]-nums[i+1]),ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021201,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        \\n        int ans = INT_MAX;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for ( int i=0; i<nums.size()-1; i++ ) {\\n            ans = min(ans,nums[i+1]-nums[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        \\n        int ans = INT_MAX;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for ( int i=0; i<nums.size()-1; i++ ) {\\n            ans = min(ans,nums[i+1]-nums[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012557,
                "title": "java-sort",
                "content": "\\n\\n# Complexity\\n- Time complexity: Nlog(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        \\n        Arrays.sort( nums);\\n        int res = Integer.MAX_VALUE;\\n        for( int i  = 1 ; i< nums.length ;i++){\\n            res = Math.min(res  ,nums[i] - nums[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        \\n        Arrays.sort( nums);\\n        int res = Integer.MAX_VALUE;\\n        for( int i  = 1 ; i< nums.length ;i++){\\n            res = Math.min(res  ,nums[i] - nums[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001654,
                "title": "simple-o-n-solution-c",
                "content": "# Intuition\\nIf we make partition we will make it in such a way to minimize the difference between maximum of one and minimum of one. So for that we can simply see the difference between consecutive pairs and try to minimize it.\\n\\n# Approach\\nWe simply see the minimum difference of all the consecutive pairs of the elements in array.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int mini = INT_MAX;\\n        for(int i=1; i<nums.size(); i++){\\n            int p = nums[i]-nums[i-1];\\n            mini = min(mini, p);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int mini = INT_MAX;\\n        for(int i=1; i<nums.size(); i++){\\n            int p = nums[i]-nums[i-1];\\n            mini = min(mini, p);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995297,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int partition=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            partition=Math.min(partition,Math.abs((nums[i]-nums[i+1])));\\n        }\\n        return partition;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int partition=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            partition=Math.min(partition,Math.abs((nums[i]-nums[i+1])));\\n        }\\n        return partition;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973890,
                "title": "c-solution-73-84-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0,j = 1 ;\\n        int min = INT_MAX;\\n        while(j<nums.size()){\\n            if(nums[j] - nums[i] < min){\\n                min = nums[j] - nums[i];\\n            }\\n            i++;\\n            j++;\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0,j = 1 ;\\n        int min = INT_MAX;\\n        while(j<nums.size()){\\n            if(nums[j] - nums[i] < min){\\n                min = nums[j] - nums[i];\\n            }\\n            i++;\\n            j++;\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973889,
                "title": "java-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0,j = 1 ;\\n        int min = Integer.MAX_VALUE;\\n        while(j<nums.length){\\n            if(nums[j] - nums[i] < min){\\n                min = nums[j] - nums[i];\\n            }\\n            i++;\\n            j++;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0,j = 1 ;\\n        int min = Integer.MAX_VALUE;\\n        while(j<nums.length){\\n            if(nums[j] - nums[i] < min){\\n                min = nums[j] - nums[i];\\n            }\\n            i++;\\n            j++;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973438,
                "title": "c-too-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint findValueOfPartition(vector<int>& a) {\\n    int n=a.size();\\n    int r=INT_MAX;\\n    sort(a.begin(),a.end());\\n    for(int i=1;i<n;i++)\\n    r=min(r,a[i]-a[i-1]);\\n\\n    return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint findValueOfPartition(vector<int>& a) {\\n    int n=a.size();\\n    int r=INT_MAX;\\n    sort(a.begin(),a.end());\\n    for(int i=1;i<n;i++)\\n    r=min(r,a[i]-a[i-1]);\\n\\n    return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959490,
                "title": "simple-java-and-easy-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int min=Integer.MAX_VALUE;\\n        for(int i=1;i<n;i++){\\n            int ans = nums[i] - nums[i-1];\\n            min = Math.min(min, ans);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int min=Integer.MAX_VALUE;\\n        for(int i=1;i<n;i++){\\n            int ans = nums[i] - nums[i-1];\\n            min = Math.min(min, ans);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958879,
                "title": "c-simple-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=1e9;\\n        for(int i=1;i<nums.size();i++)\\n         {\\n           int diff=abs(nums[i]-nums[i-1]);\\n           res=min(res,diff);\\n         }\\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=1e9;\\n        for(int i=1;i<nums.size();i++)\\n         {\\n           int diff=abs(nums[i]-nums[i-1]);\\n           res=min(res,diff);\\n         }\\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950052,
                "title": "php-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function findValueOfPartition($nums) {\\n         sort($nums);\\n        $result = $nums[count($nums)-1];\\n        \\n        for($i=count($nums)-1;$i>0;$i--){\\n            $result = min($result,$nums[$i]-$nums[$i-1]);\\n        }\\n        \\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function findValueOfPartition($nums) {\\n         sort($nums);\\n        $result = $nums[count($nums)-1];\\n        \\n        for($i=count($nums)-1;$i>0;$i--){\\n            $result = min($result,$nums[$i]-$nums[$i-1]);\\n        }\\n        \\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933475,
                "title": "c-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = INT_MAX;\\n        for(int i = 1; i < nums.size(); i++) { \\n            ans = min(ans, nums[i] - nums[i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = INT_MAX;\\n        for(int i = 1; i < nums.size(); i++) { \\n            ans = min(ans, nums[i] - nums[i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927738,
                "title": "javascript-short-97-runtime",
                "content": "```javascript\\nconst findValueOfPartition = (nums) => {\\n  nums.sort((a, b) => a - b);\\n\\n  let min = Infinity;\\n  for (let i = 1; i < nums.length; i++) {\\n    min = Math.min(min, nums[i] - nums[i - 1]);\\n  }\\n  return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst findValueOfPartition = (nums) => {\\n  nums.sort((a, b) => a - b);\\n\\n  let min = Infinity;\\n  for (let i = 1; i < nums.length; i++) {\\n    min = Math.min(min, nums[i] - nums[i - 1]);\\n  }\\n  return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3922395,
                "title": "solution-for-find-the-value-of-the-partition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbasically I thought we have to find minimum value from the array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially I sorted the array and I find the minimum value between the array elements\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI used inbuild javascript sort method so basically time complexity of javascript sort method is O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findValueOfPartition = function(nums) {\\nlet min=9999999999999 ;\\n  nums.sort((n1,n2)=>{\\n      return n1-n2;\\n  })  \\nfor(let k=0;k<nums.length-1;k++){\\n    if((nums[k+1]-nums[k])<min){\\n        min=nums[k+1]-nums[k];\\n    }\\n}\\nreturn min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findValueOfPartition = function(nums) {\\nlet min=9999999999999 ;\\n  nums.sort((n1,n2)=>{\\n      return n1-n2;\\n  })  \\nfor(let k=0;k<nums.length-1;k++){\\n    if((nums[k+1]-nums[k])<min){\\n        min=nums[k+1]-nums[k];\\n    }\\n}\\nreturn min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921935,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        int ans;\\n        ans=INT_MAX;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            ans=min(ans,nums[i+1]-nums[i]);\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        int ans;\\n        ans=INT_MAX;\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            ans=min(ans,nums[i+1]-nums[i]);\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912076,
                "title": "c-easy-solution-sorting-approach-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=INT_MAX;\\n        for(int i=0;i<nums.size()-1;i++){\\n            res=min(res, abs(nums[i]-nums[i+1]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=INT_MAX;\\n        for(int i=0;i<nums.size()-1;i++){\\n            res=min(res, abs(nums[i]-nums[i+1]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894698,
                "title": "juss-sortinn-simplest-method-among-all",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int minI = INT_MAX;\\n        for(int i=0; i<nums.size()-1 ; i++){\\n            minI = min(minI , nums[i+1]- nums[i]);\\n        }\\n        return minI;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int minI = INT_MAX;\\n        for(int i=0; i<nums.size()-1 ; i++){\\n            minI = min(minI , nums[i+1]- nums[i]);\\n        }\\n        return minI;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888619,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int findValueOfPartition(List<int> nums) {\\n      nums.sort();\\n      var mini = 10000000000;\\n      for (int i = 1; i < nums.length; i++) {\\n          var diff = (nums[i] - nums[i - 1]).abs();\\n          if (diff < mini) {\\n              mini = diff;\\n          }\\n      }\\n\\n      return mini;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int findValueOfPartition(List<int> nums) {\\n      nums.sort();\\n      var mini = 10000000000;\\n      for (int i = 1; i < nums.length; i++) {\\n          var diff = (nums[i] - nums[i - 1]).abs();\\n          if (diff < mini) {\\n              mini = diff;\\n          }\\n      }\\n\\n      return mini;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868977,
                "title": "easy-and-100-efficiant-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=INT_MAX;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            ans=min(ans,abs(nums[i+1]-nums[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ans=INT_MAX;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            ans=min(ans,abs(nums[i+1]-nums[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856535,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int ans=nums[1]-nums[0];\\n        for (int i=2;i<nums.size();i++)\\n        {\\n            ans=min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int ans=nums[1]-nums[0];\\n        for (int i=2;i<nums.size();i++)\\n        {\\n            ans=min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852573,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_value_of_partition(mut nums: Vec<i32>) -> i32 {\\n        nums.sort();\\n        let mut ans = i32::MAX;\\n        for i in (1..nums.len()).rev() {\\n            ans = ans.min((nums[i - 1] - nums[i]).abs());\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_value_of_partition(mut nums: Vec<i32>) -> i32 {\\n        nums.sort();\\n        let mut ans = i32::MAX;\\n        for i in (1..nums.len()).rev() {\\n            ans = ans.min((nums[i - 1] - nums[i]).abs());\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3842771,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(nlogn)$$\\n- Space complexity:O(1)\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int mid=n/2,res=Integer.MAX_VALUE;\\n        for(int i=0;i+1<n;i++){\\n            res=Math.min(res,Math.abs(nums[i]-nums[i+1]));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int mid=n/2,res=Integer.MAX_VALUE;\\n        for(int i=0;i+1<n;i++){\\n            res=Math.min(res,Math.abs(nums[i]-nums[i+1]));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841114,
                "title": "java-solution-for-beginners-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\u2B55(n * log(n)), where n = nums.length;\\n\\n- Space complexity:\\n\\u2B55(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int minDist = Integer.MAX_VALUE;\\n        for (int i = 0; i < n - 1; i++) {\\n            int diff = nums[ i + 1] - nums[i];\\n            if (diff == 0) {\\n                return 0;\\n            } else if (diff < minDist) {\\n                minDist = diff;\\n            } \\n        }\\n        return minDist;\\n    }\\n}\\n//[59,76,2,26,49]  ans = 10\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int minDist = Integer.MAX_VALUE;\\n        for (int i = 0; i < n - 1; i++) {\\n            int diff = nums[ i + 1] - nums[i];\\n            if (diff == 0) {\\n                return 0;\\n            } else if (diff < minDist) {\\n                minDist = diff;\\n            } \\n        }\\n        return minDist;\\n    }\\n}\\n//[59,76,2,26,49]  ans = 10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838825,
                "title": "c-find-value-of-partition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int partition=INT_MAX;\\n        for(int i=1;i<n;i++){\\n            partition=min(partition,nums[i]-nums[i-1]);\\n        }\\n        return partition;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int partition=INT_MAX;\\n        for(int i=1;i<n;i++){\\n            partition=min(partition,nums[i]-nums[i-1]);\\n        }\\n        return partition;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829902,
                "title": "heap-beats-100-python-detailed-explaination",
                "content": "# Intuition - Min Heap\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We do not need to divide the elements of the array to two arrays. All we need to do is to find the difference between ith and (i + 1)th element.\\n- To do that we need to first sort the array.\\n- Put the difference inside the heap\\n- Finally just pop the min heap, the first element would be the minimum difference present between to elements in the sorted array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort Nums\\n- Iterate over the list of nums form 1 to len(nums). we start from 1 because we need to find the difference nums[i] - nums[i-1]. For i = 1, the initial iteration - nums[1] - nums[i-1]\\n- we add each difference in the min heap\\n- finally we will return just the first element we pop from the heap. As it is a minimum heap, it gaurantees that the first element we pop from the heap would be the minimum among all the differences.\\n\\n# Complexity\\n- Time complexity: O(nlogn + logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> for sorting the nums and then adding elements to the heap\\n\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        heap = [] # Min heap\\n        nums.sort()\\n        for i in range(1, len(nums)):\\n            heapq.heappush(heap, nums[i] - nums[i-1]) #Add difference of elements to the heap\\n        return heapq.heappop(heap) #pop just the first difference in the min heap\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        heap = [] # Min heap\\n        nums.sort()\\n        for i in range(1, len(nums)):\\n            heapq.heappush(heap, nums[i] - nums[i-1]) #Add difference of elements to the heap\\n        return heapq.heappop(heap) #pop just the first difference in the min heap\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808531,
                "title": "find-the-value-of-the-partition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min=Integer.MAX_VALUE;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n           min = Math.min(min,nums[i]-nums[i-1]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min=Integer.MAX_VALUE;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n           min = Math.min(min,nums[i]-nums[i-1]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808151,
                "title": "java-solution-100-runtime",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;\\n        int len = nums.length;\\n        for (int i = 0; i < len - 1; i++) {\\n            int temp = Math.abs(nums[i] - nums[i + 1]);\\n            if(temp < min){\\n                min = temp;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;\\n        int len = nums.length;\\n        for (int i = 0; i < len - 1; i++) {\\n            int temp = Math.abs(nums[i] - nums[i + 1]);\\n            if(temp < min){\\n                min = temp;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796996,
                "title": "easy-solution-java-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n# <!-- Add your time complexity here, **Bold**e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n**![LEETCODE AVATAR.png](https://assets.leetcode.com/users/images/d66d58f3-309b-459e-a492-6ae343b63b6f_1689945039.9295158.png)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\nint ans= Integer.MAX_VALUE;\\n        for(int i =0;i<nums.length-1;i++){\\n            ans= Math.min(ans,nums[i+1]-nums[i]);\\n        }\\n        return ans;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\nint ans= Integer.MAX_VALUE;\\n        for(int i =0;i<nums.length-1;i++){\\n            ans= Math.min(ans,nums[i+1]-nums[i]);\\n        }\\n        return ans;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785995,
                "title": "simple-c-solution",
                "content": "# Intuition\\nwe just have to return the minimum difference amongst the elements.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini=INT_MAX;\\n        int k;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            k=(nums[i]-nums[i-1]);\\n            mini=min(mini, k);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini=INT_MAX;\\n        int k;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            k=(nums[i]-nums[i-1]);\\n            mini=min(mini, k);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783173,
                "title": "c-sort-find-min-difference",
                "content": "# Approach\\nFind the smallest difference between two adjacent elements in sorted vector\\n\\n# Complexity\\n- Time complexity:\\nNlogN -> N=number of elements in nums\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=nums.back()-nums[0];\\n        for (int i=1;i<nums.size();i++){\\n            ans = min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=nums.back()-nums[0];\\n        for (int i=1;i<nums.size();i++){\\n            ans = min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782778,
                "title": "simple-answer-using-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int dif = nums[1]-nums[0];\\n        for(int i=2;i<nums.length;i++){\\n            int n = nums[i]-nums[i-1];\\n            dif = Math.min(n,dif);\\n        }\\n        return dif;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int dif = nums[1]-nums[0];\\n        for(int i=2;i<nums.length;i++){\\n            int n = nums[i]-nums[i-1];\\n            dif = Math.min(n,dif);\\n        }\\n        return dif;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781957,
                "title": "java-beats-99-91-very-easy-solution",
                "content": "# Complexity\\n- Time complexity:- O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 1;i < nums.length;i++)\\n            ans = Math.min(ans,nums[i] - nums[i-1]);\\n        return ans;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 1;i < nums.length;i++)\\n            ans = Math.min(ans,nums[i] - nums[i-1]);\\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772720,
                "title": "easy-cpp-solution",
                "content": "If you find it helpful, please upvote !\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int minVal = INT_MAX;\\n        for(int i=1;i<nums.size();i++){\\n            minVal = min(minVal,nums[i]-nums[i-1]);\\n        }\\n        return minVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int minVal = INT_MAX;\\n        for(int i=1;i<nums.size();i++){\\n            minVal = min(minVal,nums[i]-nums[i-1]);\\n        }\\n        return minVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771758,
                "title": "easy-peasy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<n-1;i++){\\n            ans = Math.min(ans,nums[i+1] - nums[i]);\\n        }\\n        return ans;\\n\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<n-1;i++){\\n            ans = Math.min(ans,nums[i+1] - nums[i]);\\n        }\\n        return ans;\\n\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766771,
                "title": "easy-just-sort-and-check-technique",
                "content": "# Intuition\\nconsecutive elements in a sorted array will fetch the minimum difference\\n\\n# Approach\\nsort the array and check the minimum consecutive difference\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nno extra space taken\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=1e9+7;\\n        for(int i=0;i<nums.size()-1;i++){\\n            ans=min(ans,nums[i+1]-nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=1e9+7;\\n        for(int i=0;i<nums.size()-1;i++){\\n            ans=min(ans,nums[i+1]-nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766356,
                "title": "c-sorting",
                "content": "class Solution {\\npublic:\\n\\n    int findValueOfPartition(vector<int>& nums) {\\n        \\n        int sum = INT_MAX;\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=1; i<n; i++) { \\n            sum = min(sum, nums[i]-nums[i-1]);\\n        }\\n        \\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int findValueOfPartition(vector<int>& nums) {\\n        \\n        int sum = INT_MAX;\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=1; i<n; i++) { \\n            sum = min(sum, nums[i]-nums[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3759003,
                "title": "java-easy-solution-beats-99-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n            Arrays.sort(nums);\\n\\n        int minimum = Integer.MAX_VALUE;\\n        for (int i = 1; i < nums.length; i++) {\\n\\n            minimum = Math.min(minimum,Math.abs(nums[i]-nums[i-1]));\\n            \\n        }\\n        return minimum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n            Arrays.sort(nums);\\n\\n        int minimum = Integer.MAX_VALUE;\\n        for (int i = 1; i < nums.length; i++) {\\n\\n            minimum = Math.min(minimum,Math.abs(nums[i]-nums[i-1]));\\n            \\n        }\\n        return minimum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746920,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min=Integer.MAX_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            min=Math.min(min, nums[i]-nums[i-1]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min=Integer.MAX_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            min=Math.min(min, nums[i]-nums[i-1]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740119,
                "title": "java-o-n-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n\\n\\n        // the optimal way is to sort the array after that try for every partition\\n        // at every index after 0 as both the arrays cannot be empty.\\n        // max value of nums1 should lie at i - 1 index as the array is sorted\\n        // min of nums2 should lie at i , the reason is same, array is sorted.\\n\\n        Arrays.sort(nums);\\n\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 1 ; i < nums.length ; i++){\\n\\n            min = Math.min(Math.abs(nums[i - 1] - nums[i]) , min);\\n\\n        }\\n\\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n\\n\\n        // the optimal way is to sort the array after that try for every partition\\n        // at every index after 0 as both the arrays cannot be empty.\\n        // max value of nums1 should lie at i - 1 index as the array is sorted\\n        // min of nums2 should lie at i , the reason is same, array is sorted.\\n\\n        Arrays.sort(nums);\\n\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 1 ; i < nums.length ; i++){\\n\\n            min = Math.min(Math.abs(nums[i - 1] - nums[i]) , min);\\n\\n        }\\n\\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739632,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ans=min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ans=min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739302,
                "title": "very-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int hny=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<size(nums)-1;i++){\\n            int dif=nums[i+1]-nums[i];\\n            if(dif<hny){\\n                hny=dif;\\n            }\\n        }\\n        return hny;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int hny=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<size(nums)-1;i++){\\n            int dif=nums[i+1]-nums[i];\\n            if(dif<hny){\\n                hny=dif;\\n            }\\n        }\\n        return hny;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738305,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans=INT_MAX;\\n        sort(begin(nums), end(nums));\\n        for(int i = 1; i<n; i++) \\n        {\\n            ans=min(ans,nums[i] - nums [i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans=INT_MAX;\\n        sort(begin(nums), end(nums));\\n        for(int i = 1; i<n; i++) \\n        {\\n            ans=min(ans,nums[i] - nums [i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738152,
                "title": "java-98-98-faster-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*logn) for sorting\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) \\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n\\n// checking if the last element is equals to second last element or not\\n// if it is the we can put the last element alone in the nums2 \\n// and the rest on nums1 \\n// max(nums1) - min(nums2) => max - max == 0 \\n\\n        if(nums[n-1] == nums[n-2]){\\n            return 0;\\n        }\\n\\n// else \\n        for(int i = 1 ; i < n ; i++){\\n            ans = Math.min(ans , nums[i] - nums[i-1]);\\n        }\\n\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n\\n// checking if the last element is equals to second last element or not\\n// if it is the we can put the last element alone in the nums2 \\n// and the rest on nums1 \\n// max(nums1) - min(nums2) => max - max == 0 \\n\\n        if(nums[n-1] == nums[n-2]){\\n            return 0;\\n        }\\n\\n// else \\n        for(int i = 1 ; i < n ; i++){\\n            ans = Math.min(ans , nums[i] - nums[i-1]);\\n        }\\n\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736446,
                "title": "beats-70-runtime-and-90-memory",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n\\n    @staticmethod\\n    def findValueOfPartition(nums):\\n        nums.sort()\\n        min_diff = abs(nums[0] - nums[1])\\n\\n        for i in range(1, len(nums)-1):\\n            if abs(nums[i] - nums[i+1]) < min_diff:\\n                min_diff = abs(nums[i] - nums[i+1])\\n        \\n        return min_diff\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n\\n    @staticmethod\\n    def findValueOfPartition(nums):\\n        nums.sort()\\n        min_diff = abs(nums[0] - nums[1])\\n\\n        for i in range(1, len(nums)-1):\\n            if abs(nums[i] - nums[i+1]) < min_diff:\\n                min_diff = abs(nums[i] - nums[i+1])\\n        \\n        return min_diff\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736409,
                "title": "explained-code-in-c-sorting-loop-easy-and-neat-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n      //step 1 sort in ascending order \\n      sort(nums.begin(),nums.end());\\n      \\n      int diff=INT_MAX;\\n      //check the minimum in consecutive pairs \\n      //note the loop must stop at nums.size()-1(excluding)\\n      // otherwise this will give error at last position \\n      for(int i =0;i<nums.size()-1;i++){\\n          int ans=nums[i+1]-nums[i];\\n          if(ans <diff ){\\n              diff=ans;\\n          }\\n      }\\n     return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n      //step 1 sort in ascending order \\n      sort(nums.begin(),nums.end());\\n      \\n      int diff=INT_MAX;\\n      //check the minimum in consecutive pairs \\n      //note the loop must stop at nums.size()-1(excluding)\\n      // otherwise this will give error at last position \\n      for(int i =0;i<nums.size()-1;i++){\\n          int ans=nums[i+1]-nums[i];\\n          if(ans <diff ){\\n              diff=ans;\\n          }\\n      }\\n     return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732491,
                "title": "one-line-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$.\\n\\n- Space complexity: $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        return (nums:=tuple(sorted(nums)), min(nums[i+1] - nums[i] for i in range(len(nums)-1)))[1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        return (nums:=tuple(sorted(nums)), min(nums[i+1] - nums[i] for i in range(len(nums)-1)))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727061,
                "title": "c-easy-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n            int ans = INT_MAX;\\n            sort(nums.begin(), nums.end());\\n            for(int i=1; i<nums.size(); i++){\\n                    ans = min(ans, nums[i]-nums[i-1]);\\n                    \\n           }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n            int ans = INT_MAX;\\n            sort(nums.begin(), nums.end());\\n            for(int i=1; i<nums.size(); i++){\\n                    ans = min(ans, nums[i]-nums[i-1]);\\n                    \\n           }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724573,
                "title": "easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        int mini = INT_MAX;\\n        for(int i=0; i<nums.size()-1; i++){\\n            mini = min((nums[i+1]-nums[i]), mini);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        int mini = INT_MAX;\\n        for(int i=0; i<nums.size()-1; i++){\\n            mini = min((nums[i+1]-nums[i]), mini);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722287,
                "title": "simple-clear-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = nums[1]-nums[0];\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(min > (nums[i+1] - nums[i])) min = nums[i+1] - nums[i];\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = nums[1]-nums[0];\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(min > (nums[i+1] - nums[i])) min = nums[i+1] - nums[i];\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716313,
                "title": "very-easy-solution-using-sorting-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(begin(nums),end(nums));\\n        int ans=nums[n-1];\\n        for(int i=1;i<n;i++){\\n            ans=min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote if found usefull**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(begin(nums),end(nums));\\n        int ans=nums[n-1];\\n        for(int i=1;i<n;i++){\\n            ans=min(ans,nums[i]-nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711868,
                "title": "c-sort-get-adjacent-minimum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            ans=min(ans,nums[i+1]-nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            ans=min(ans,nums[i+1]-nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710792,
                "title": "java-solution-100-faster-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i < nums.length-1; i++)\\n            min = Math.min(nums[i+1]-nums[i], min);\\n\\n        return min;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i < nums.length-1; i++)\\n            min = Math.min(nums[i+1]-nums[i], min);\\n\\n        return min;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706375,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(begin(nums) , end(nums));\\n        int res = INT_MAX;\\n        for(int i = 1; i < nums.size(); i++){\\n            res = min(nums[i] - nums[i - 1] , res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(begin(nums) , end(nums));\\n        int res = INT_MAX;\\n        for(int i = 1; i < nums.size(); i++){\\n            res = min(nums[i] - nums[i - 1] , res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704501,
                "title": "easy-approach-sorting-compare-minimum-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mini=INT_MAX;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            mini=min(mini,nums[i]-nums[i-1]);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mini=INT_MAX;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            mini=min(mini,nums[i]-nums[i-1]);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701193,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n        \\n        res_min= float(\\'inf\\')\\n        \\n        for i in range(1,len(nums)):\\n            res_min=min(nums[i]-nums[i-1],res_min)\\n        return res_min\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n        \\n        res_min= float(\\'inf\\')\\n        \\n        for i in range(1,len(nums)):\\n            res_min=min(nums[i]-nums[i-1],res_min)\\n        return res_min\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699078,
                "title": "python3-2-liner-very-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[i] - nums[i - 1] for i in range(1, len(nums)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return min(nums[i] - nums[i - 1] for i in range(1, len(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696976,
                "title": "solution-using-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length-1;i++)\\n            ans=Math.min(ans,(nums[i+1]-nums[i]));\\n\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=Integer.MAX_VALUE;\\n\\n        for(int i=0;i<nums.length-1;i++)\\n            ans=Math.min(ans,(nums[i+1]-nums[i]));\\n\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696216,
                "title": "c-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ct = INT_MAX;\\n        int n = nums.size();\\n        for(int i = 0; i < n-1; i++) ct = min(ct, nums[i+1]-nums[i]);\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ct = INT_MAX;\\n        int n = nums.size();\\n        for(int i = 0; i < n-1; i++) ct = min(ct, nums[i+1]-nums[i]);\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691006,
                "title": "easy-c-code-beats-99-o-n-log-n-complexity",
                "content": "# Complexity\\n- Time complexity:$$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstatic const auto init = []\\n{\\n    ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return false;\\n}();\\nclass Solution {\\npublic:\\n    inline int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n-1; i++)\\n        {\\n            ans = min(ans,abs(nums[i]-nums[i+1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic const auto init = []\\n{\\n    ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return false;\\n}();\\nclass Solution {\\npublic:\\n    inline int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n-1; i++)\\n        {\\n            ans = min(ans,abs(nums[i]-nums[i+1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683974,
                "title": "easy-sorting-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++) \\n             mn=min(mn,nums[i]-nums[i+1]);\\n         \\n\\n         return mn;\\n    }\\n};\\n\\n\\n//please upvote \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++) \\n             mn=min(mn,nums[i]-nums[i+1]);\\n         \\n\\n         return mn;\\n    }\\n};\\n\\n\\n//please upvote \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683706,
                "title": "python-easy-solution-finding-value-of-partition-in-a-sorted-list-of-integers",
                "content": "# Intuition:\\nThe `findValueOfPartition` function aims to find the value of the partition in a sorted list of integers. Let\\'s analyze the given code to understand the logic.\\n\\n# Approach:\\n1. The function begins by sorting the input list of integers, `nums`, in ascending order using the `sorted` function. The sorted list is assigned back to `nums`.\\n2. It initializes a variable `val` with the maximum value from the sorted list `nums` using the `max` function.\\n3. It iterates through the sorted list using a for loop and the range function. The loop variable `i` represents the index of the current element.\\n4. Within the loop, it checks if the difference between the next element (`nums[i+1]`) and the current element (`nums[i]`) is less than the current value of `val`.\\n   - If the condition is satisfied, it updates `val` to the new smaller difference value.\\n5. After iterating through the entire list, it returns the final value of `val`, which represents the value of the smallest partition in the sorted list.\\n\\n# Complexity:\\n**- Time complexity:** The given code has a time complexity of O(n log n), where n is the length of the input list `nums`. This is because the initial sorting step takes O(n log n) time, and the subsequent loop has a complexity of O(n) as it iterates through the list once.\\n**- Space complexity:** The code has a space complexity of O(n) due to the sorting operation, which creates a new sorted list that occupies additional space in memory.\\n\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        val=max(nums)\\n        for i in range(len(nums)-1):\\n            if nums[i+1]-nums[i]<val:\\n                val=nums[i+1]-nums[i]\\n        return val\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        val=max(nums)\\n        for i in range(len(nums)-1):\\n            if nums[i+1]-nums[i]<val:\\n                val=nums[i+1]-nums[i]\\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680814,
                "title": "javascript-2740-find-the-value-of-the-partition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar findValueOfPartition = function (a) {\\n  a.sort((a, b) => a - b)\\n\\n  let p;\\n  let min = Infinity\\n  for (let e of a) {\\n    if (p) {\\n      min = Math.min(min, e - p)\\n    }\\n    p = e\\n  }\\n\\n  return min\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findValueOfPartition = function (a) {\\n  a.sort((a, b) => a - b)\\n\\n  let p;\\n  let min = Infinity\\n  for (let e of a) {\\n    if (p) {\\n      min = Math.min(min, e - p)\\n    }\\n    p = e\\n  }\\n\\n  return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677848,
                "title": "c-easy-solution-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = INT_MAX;\\n        for(int i = 1 ; i<nums.size();i++){\\n            ans = min(ans,(nums[i]-nums[i-1]));\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = INT_MAX;\\n        for(int i = 1 ; i<nums.size();i++){\\n            ans = min(ans,(nums[i]-nums[i-1]));\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677016,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst Sort the array.\\nthen find the difference between two consecutive elements.\\nTake the minimum difference.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end()); \\n        int n=nums.size();\\n        int mini=INT_MAX;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]-nums[i-1]<mini)\\n            mini=nums[i]-nums[i-1];\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end()); \\n        int n=nums.size();\\n        int mini=INT_MAX;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]-nums[i-1]<mini)\\n            mini=nums[i]-nums[i-1];\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676703,
                "title": "easy-to-understand-c-consecutive-terms",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int mini=INT_MAX;\\n        for(int i=1;i<nums.size();i++){\\n            mini=min(nums[i]-nums[i-1],mini);\\n        }\\n        return mini;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int mini=INT_MAX;\\n        for(int i=1;i<nums.size();i++){\\n            mini=min(nums[i]-nums[i-1],mini);\\n        }\\n        return mini;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674862,
                "title": "java-easy-soln",
                "content": "\\n\\n# Approach\\nJust iterate each consecutive pair.\\n\\n# Complexity\\n- Time complexity:\\n The overall time complexity of the code is O(n log n) because the sorting step dominates the time complexity.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n      Arrays.sort(nums);\\n      int ans=0,min=Integer.MAX_VALUE;\\n      for(int i=0;i<nums.length-1;i++)\\n      {\\n          ans=nums[i+1]-nums[i];\\n          min=Math.min(min,ans);\\n      }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n      Arrays.sort(nums);\\n      int ans=0,min=Integer.MAX_VALUE;\\n      for(int i=0;i<nums.length-1;i++)\\n      {\\n          ans=nums[i+1]-nums[i];\\n          min=Math.min(min,ans);\\n      }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673962,
                "title": "solution-using-sorting",
                "content": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        Arrays.sort(nums);\\n        for(int i=1; i<nums.length; i++){\\n            min = Math.min(min,Math.abs(nums[i]-nums[i-1]));\\n        }\\n        return min;\\n    }\\n}\\n\\n    \\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        Arrays.sort(nums);\\n        for(int i=1; i<nums.length; i++){\\n            min = Math.min(min,Math.abs(nums[i]-nums[i-1]));\\n        }\\n        return min;\\n    }\\n}\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671957,
                "title": "sort-find-minimal-absolute-adjacent-difference",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe goal is minimal(max(nums1) - min(nums2)). The question don\\'t have any group rules, hence, only need to find the minimal adjacent difference of the nums. \\n\\n1. Sort the input array nums.\\n2. Find the minimal the absolute adjacent difference of nums. \\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 1; i < nums.length; i++) {\\n            res = Math.min(Math.abs(nums[i] - nums[i - 1]), res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 1; i < nums.length; i++) {\\n            res = Math.min(Math.abs(nums[i] - nums[i - 1]), res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671804,
                "title": "simple-solution-using-sorting-in-java",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int minValue = Integer.MAX_VALUE;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            int maxV = nums[i];\\n            int minV = nums[i+1];\\n            minValue = Math.min(minValue,Math.abs(maxV-minV));\\n        }\\n        return minValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int minValue = Integer.MAX_VALUE;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            int maxV = nums[i];\\n            int minV = nums[i+1];\\n            minValue = Math.min(minValue,Math.abs(maxV-minV));\\n        }\\n        return minValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671043,
                "title": "python-video-walkthrough-time-o-nlogn-space-o-1-three-lines",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/WOuNnIhTxww)\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        res, _ = float(\\'inf\\'), nums.sort()\\n        for i in range(0,len(nums)-1): res = min(res, nums[i+1] - nums[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        res, _ = float(\\'inf\\'), nums.sort()\\n        for i in range(0,len(nums)-1): res = min(res, nums[i+1] - nums[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670417,
                "title": "concise-100-beats-tc-easy-peasy-lemon-squeezy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int min=Integer.MAX_VALUE;\\n        \\n        for(int i=1;i<n;i++){\\n            min=Math.min(min,nums[i]-nums[i-1]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int min=Integer.MAX_VALUE;\\n        \\n        for(int i=1;i<n;i++){\\n            min=Math.min(min,nums[i]-nums[i-1]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669385,
                "title": "find-the-value-of-the-partition",
                "content": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        min_val = max(nums)\\n        for i in range(0,len(nums)-1):\\n            if (nums[i+1]-nums[i]) < min_val:\\n                min_val = (nums[i+1]-nums[i])\\n        return(min_val)\\n```\\nAny doubts feel free to comment",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        min_val = max(nums)\\n        for i in range(0,len(nums)-1):\\n            if (nums[i+1]-nums[i]) < min_val:\\n                min_val = (nums[i+1]-nums[i])\\n        return(min_val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668960,
                "title": "python-sorting-simple-easy-to-understand-clear-explanation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO ( n log n )\\n\\n- Space complexity:\\nO ( 1 )\\n\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()     # sort the array\\n        l=len(nums)     # find the length\\n        min_diff=abs(nums[0]-nums[1])    # initially,let minimum difference will be absolute difference between first two elements\\n        for i in range(1,l-1):    # run the loops from index 1 to index l-1\\n            diff=abs(nums[i]-nums[i+1])    # finding the absolute difference\\n            if diff<min_diff:           # if diff less than min_diff , then assign diff value to the min_diff\\n                min_diff=diff\\n        return min_diff   # return the min_diff value\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()     # sort the array\\n        l=len(nums)     # find the length\\n        min_diff=abs(nums[0]-nums[1])    # initially,let minimum difference will be absolute difference between first two elements\\n        for i in range(1,l-1):    # run the loops from index 1 to index l-1\\n            diff=abs(nums[i]-nums[i+1])    # finding the absolute difference\\n            if diff<min_diff:           # if diff less than min_diff , then assign diff value to the min_diff\\n                min_diff=diff\\n        return min_diff   # return the min_diff value\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668716,
                "title": "sliding-window-approch-easy-beginner-friendly",
                "content": "# Intuition\\nKadanes algorithm:simply check the diff between eack  iteration\\n\\n# Approach\\ncompare the elements store the min diff \\n\\n\\n# Complexity\\n- Time complexity:\\nNlogN\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            diff = abs(nums[i]-nums[i-1])\\n            res = min(res,diff)\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            diff = abs(nums[i]-nums[i-1])\\n            res = min(res,diff)\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667120,
                "title": "easiest-c-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int mini = INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        for(int i=1 ; i<nums.size(); i++){\\n            mini = min(mini , nums[i] - nums[i-1]);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int mini = INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        for(int i=1 ; i<nums.size(); i++){\\n            mini = min(mini , nums[i] - nums[i-1]);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665434,
                "title": "c-beginner-friendly-o-n",
                "content": "# Complexity\\n- Time complexity : **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public:\\n        int findValueOfPartition(vector<int>& nums) \\n        {\\n            sort(nums.begin(), nums.end());\\n            \\n            int N = nums.size();\\n            int partition = INT_MAX;\\n            \\n            for(int i=1; i<N; ++i) partition = min(partition, nums[i]-nums[i-1]);\\n            \\n            return partition;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n        int findValueOfPartition(vector<int>& nums) \\n        {\\n            sort(nums.begin(), nums.end());\\n            \\n            int N = nums.size();\\n            int partition = INT_MAX;\\n            \\n            for(int i=1; i<N; ++i) partition = min(partition, nums[i]-nums[i-1]);\\n            \\n            return partition;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664156,
                "title": "very-easy-solution-array-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou are given an array and you have to partition it in such a way that absolute difference between max element of one array and min element of other array is minimum. The very first solution that can come in mind would be through recursion? But recursion would be expensive in terms of time and space both. We can solve this in a better way.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe want to minimize difference between max element of array1 and min element of array2 that we get from original array. If we want to find difference between every pair of elements in the array and store the minimum then it would cost us $$O(n^2)$$ in terms of time. But we can bring this down to $$O(nlogn)$$ by sorting the array.\\n\\nThe core concept here is, if you have a **sorted** array then minimum difference for each element will only be the difference between the element and it\\'s adjacent neighbours i.e. minimum difference for $$arr[i]$$ would be either $$|arr[i]-arr[i-1]|$$ or $$|arr[i]-arr[i+1]|$$ as all other differences with $$arr[i]$$ like $$|arr[i]-arr[i+2]|$$, $$|arr[i]-arr[i-2]|$$, etc. would be greater in a sorted array. So, we compute minimum difference between all adjacent neighbours and that\\'s the answer as we will split the array around the minimum difference adjacent elements. \\n\\nAlso, as we are splitting it in a sorted array, then won\\'t have to worry about the max-min condition in the question. For Example, if I have a **sorted** array, $$[1, 2, 3, 4, 5, 6]$$ and I split it into two arrays around index 2, then I get two arrays $$[1, 2, 3]$$ & $$[4, 5, 6]$$. You can observe that first element around the split, i.e. 3 is max of first array and second element i.e. 4 is min of second array as the array is sorted. So this condition is also satisfied.\\n\\nYou can also imagine this as a number line. $$|2-3| < |2-4|$$, $$|2-3| < |2-5|$$ and so on.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int minDiff = INT_MAX;\\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            minDiff = min(minDiff, abs(nums[i]-nums[i-1]));\\n        }\\n        \\n        return minDiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int minDiff = INT_MAX;\\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            minDiff = min(minDiff, abs(nums[i]-nums[i-1]));\\n        }\\n        \\n        return minDiff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663489,
                "title": "why-sorting-works",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findValueOfPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n\\n        sort \\n\\n        1 2 3 4 5 6 7 8 9\\n\\n        smallest abs diff is the elements next to each other \\n\\n        how do we make those two elemts the max and min of the two arrays say 5 and 6?\\n\\n        swap 5 and 6\\n\\n        [1 2 3 4 6] [5 7 8 9]\\n        now 6 is the max of one array and 5 is the min of the other\\n\\n        so for a sorted array we can make any two elements the min and max\\n        so we just find the min diff between two and thatll be our ans\\n\\n        \"\"\"\\n\\n\\n        nums = sorted(nums)\\n        \\n        ans = 10**9+7\\n        for i in range(len(nums)-1):\\n            ans= min(ans,abs(nums[i]-nums[i+1]))\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findValueOfPartition(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n\\n        sort \\n\\n        1 2 3 4 5 6 7 8 9\\n\\n        smallest abs diff is the elements next to each other \\n\\n        how do we make those two elemts the max and min of the two arrays say 5 and 6?\\n\\n        swap 5 and 6\\n\\n        [1 2 3 4 6] [5 7 8 9]\\n        now 6 is the max of one array and 5 is the min of the other\\n\\n        so for a sorted array we can make any two elements the min and max\\n        so we just find the min diff between two and thatll be our ans\\n\\n        \"\"\"\\n\\n\\n        nums = sorted(nums)\\n        \\n        ans = 10**9+7\\n        for i in range(len(nums)-1):\\n            ans= min(ans,abs(nums[i]-nums[i+1]))\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662571,
                "title": "4-liner-solution-commented",
                "content": "# Intuition\\nWe will sort the array first\\nwe want to minimize the difference between maximum and min element of both array \\nWe will consider every element (index>0) to be the largest element of te first array and element (index+1) to be smallest of next array \\nIn this way we will calculate the min of all possibilities\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        int res = INT_MAX; \\n        sort(nums.begin(),nums.end());\\n        for(int i =1; i<nums.size();i++)\\n        res = min(res,nums[i]-nums[i-1]);\\n\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        int res = INT_MAX; \\n        sort(nums.begin(),nums.end());\\n        for(int i =1; i<nums.size();i++)\\n        res = min(res,nums[i]-nums[i-1]);\\n\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662115,
                "title": "easy-c-solution-o-n-log-n-for-beginners",
                "content": "# Intuition\\n\\n\\n# Approach\\nsince we have to find two numbers such that diffrence between the numbers is minimum and we have sorted the array. Take current variable and check at every step that whether it is minimum or not.\\nfinally return the minimum value of curr stored in ans. \\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) since we have used sort stl function\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i,curr;\\n        int n=nums.size();\\n        int ans=INT_MAX;\\n        for(i=0;i<n-1;i++)\\n        {\\n            curr=abs(nums[i+1]-nums[i]);\\n            ans=min(ans,curr);\\n            if(ans==0)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i,curr;\\n        int n=nums.size();\\n        int ans=INT_MAX;\\n        for(i=0;i<n-1;i++)\\n        {\\n            curr=abs(nums[i+1]-nums[i]);\\n            ans=min(ans,curr);\\n            if(ans==0)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662072,
                "title": "sort",
                "content": "**time: `O(NlogN)`; space: `O(1)`**\\n```\\nint findValueOfPartition(vector<int>& n)\\n{\\n\\tsort(begin(n), end(n));\\n\\tint out{INT_MAX};\\n\\tfor(int i{1}; i<size(n); ++i)\\n\\t\\tout = min(out, n[i]-n[i-1]);\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findValueOfPartition(vector<int>& n)\\n{\\n\\tsort(begin(n), end(n));\\n\\tint out{INT_MAX};\\n\\tfor(int i{1}; i<size(n); ++i)\\n\\t\\tout = min(out, n[i]-n[i-1]);\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3660803,
                "title": "minimize-the-distance-through-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        //we need to minimize the constraint |max(nums1) - min(nums2)|. \\n        sort(nums.begin(),nums.end());\\n        int idx = 0;\\n        int diff = INT_MAX;\\n        while(idx < (nums.size()-1))\\n        {\\n             diff = min(diff, abs(nums[idx] - nums[idx+1]));\\n             idx++;\\n        }\\n        return diff;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        //we need to minimize the constraint |max(nums1) - min(nums2)|. \\n        sort(nums.begin(),nums.end());\\n        int idx = 0;\\n        int diff = INT_MAX;\\n        while(idx < (nums.size()-1))\\n        {\\n             diff = min(diff, abs(nums[idx] - nums[idx+1]));\\n             idx++;\\n        }\\n        return diff;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659839,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxi=INT_MAX;int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            maxi=min(maxi,abs(nums[i+1]-nums[i]));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxi=INT_MAX;int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            maxi=min(maxi,abs(nums[i+1]-nums[i]));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659530,
                "title": "partition-value-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet `x` and `y` be two different elements of `nums` where `x >= y`. No matter which `x` and `y` are chosen, it will always be possible to create a partition such that `x = max(nums1), y = min(nums2)`. Simply have  `nums1[i] <= x` and  `nums2[j] > x` with the exception of element `y`. Because every pair of elements has some partition that allows them to become the parameters of `|max(nums1) - min(nums2)|`, **this problem reduces to finding the minimum absolute difference between all pairs of elements**.\\n\\n# Approach 1 - Brute Force\\n<!-- Describe your approach to solving the problem. -->\\nOne way to find the minimum absolute difference between all pairs of elements is to simply test them all.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int findValueOfPartition(const vector<int>& nums) {\\n        int minDiff = abs(nums[1] - nums[0]);\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                minDiff = min(minDiff, abs(nums[j] - nums[i]));\\n            }\\n        }\\n\\n        return minDiff;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int minDiff = Math.abs(nums[1] - nums[0]);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                minDiff = Math.min(minDiff, Math.abs(nums[j] - nums[i]));\\n            }\\n        }\\n\\n        return minDiff;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        minDiff = abs(nums[1] - nums[0])\\n\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                minDiff = min(minDiff, abs(nums[j] - nums[i]))\\n\\n        return minDiff\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n    - For an array with $$n$$ elements, there are $$\\\\frac{n(n-1)}{2} = O(n^2)$$ pairs to check\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n    - All the primitive variables take up constant space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Approach 2 - Sorting\\n<!-- Describe your approach to solving the problem. -->\\nThe minimum absolute difference will occur between some pair of consecutive elements in sorted order. Sort `nums`, then find `min(nums[i+1] - nums[i])` for all pairs of consecutive indices.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int minDiff = nums[1] - nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            minDiff = min(minDiff, nums[i] - nums[i-1]);\\n        }\\n        \\n        return minDiff;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int minDiff = nums[1] - nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            minDiff = Math.min(minDiff, nums[i] - nums[i-1]);\\n        }\\n        \\n        return minDiff;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        minDiff = nums[1] - nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            minDiff = min(minDiff, nums[i] - nums[i-1])\\n        \\n        return minDiff\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log{n})$$\\n    - It takes $$O(n\\\\log{n})$$ time to sort an array with $$n$$ elements\\n    - The loop that finds the difference between consecutive elements makes one pass through the array, so $$O(n)$$ time\\n    - Overall time is $$O(n\\\\log{n}) + O(n) = O(n\\\\log{n})$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n    - All the primitive variables take up constant space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sorting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findValueOfPartition(const vector<int>& nums) {\\n        int minDiff = abs(nums[1] - nums[0]);\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                minDiff = min(minDiff, abs(nums[j] - nums[i]));\\n            }\\n        }\\n\\n        return minDiff;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        int minDiff = Math.abs(nums[1] - nums[0]);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                minDiff = Math.min(minDiff, Math.abs(nums[j] - nums[i]));\\n            }\\n        }\\n\\n        return minDiff;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        minDiff = abs(nums[1] - nums[0])\\n\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                minDiff = min(minDiff, abs(nums[j] - nums[i]))\\n\\n        return minDiff\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int minDiff = nums[1] - nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            minDiff = min(minDiff, nums[i] - nums[i-1]);\\n        }\\n        \\n        return minDiff;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int minDiff = nums[1] - nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            minDiff = Math.min(minDiff, nums[i] - nums[i-1]);\\n        }\\n        \\n        return minDiff;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n        nums.sort()\\n        minDiff = nums[1] - nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            minDiff = min(minDiff, nums[i] - nums[i-1])\\n        \\n        return minDiff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658664,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math as mt\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n\\n        nums.sort()\\n        minDiff = mt.inf\\n        for i in range(len(nums)-1):\\n            if nums[i+1] - nums[i] < minDiff:\\n                minDiff = nums[i+1] - nums[i]\\n            \\n\\n        return minDiff\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math as mt\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n\\n        nums.sort()\\n        minDiff = mt.inf\\n        for i in range(len(nums)-1):\\n            if nums[i+1] - nums[i] < minDiff:\\n                minDiff = nums[i+1] - nums[i]\\n            \\n\\n        return minDiff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658592,
                "title": "minimum-consecutive-distance-between-sorted-array-easy-peasy-c-medium-question-made-easy",
                "content": "# Approach\\n1. **Sort** the array\\n2. Now we can split the array in to part from the point where the two **consecutive elemnts** have **min difference**. So the lower side array have max value and the next element is the min of the next upper side array section.\\n3. so **keep iterating** to get the **min diff** betteen two consicutive elements.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int> nums) {\\n        int ans=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++){\\n            ans=min(ans,abs(nums[i]-nums[i-1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int> nums) {\\n        int ans=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++){\\n            ans=min(ans,abs(nums[i]-nums[i-1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658181,
                "title": "java-solution",
                "content": "\\n```\\nclass Solution {\\n\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums); \\n        int n = nums.length;\\n        int min = Integer.MAX_VALUE;\\n        // now find that point where nums[i+1] - nums[i] is min\\n        // ------Left part--- | ----right part ----\\n        //     max from this     min from this\\n        for (int i = 0; i < n - 1; i++) {\\n            min = Math.min(min, nums[i + 1] - nums[i]);\\n        }\\n        return min;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums); \\n        int n = nums.length;\\n        int min = Integer.MAX_VALUE;\\n        // now find that point where nums[i+1] - nums[i] is min\\n        // ------Left part--- | ----right part ----\\n        //     max from this     min from this\\n        for (int i = 0; i < n - 1; i++) {\\n            min = Math.min(min, nums[i + 1] - nums[i]);\\n        }\\n        return min;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658000,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++){\\n            mn=min(mn,nums[i]-nums[i-1]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++){\\n            mn=min(mn,nums[i]-nums[i-1]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657636,
                "title": "don-t-judge-a-question-by-it-s-label",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe partitioned arrays can be of unequal length and what if we found successive elements across two arrays. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsort in ascending order and then find minimum difference between adjacent elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nnlogn  - for sorting only\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length, diff=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<n-1;i++){\\n            diff=Math.min(diff,nums[i+1] - nums[i]);\\n        }\\n        \\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length, diff=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<n-1;i++){\\n            diff=Math.min(diff,nums[i+1] - nums[i]);\\n        }\\n        \\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657539,
                "title": "4-lines-easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] n) {\\n        Arrays.sort(n);\\n        int min=Integer.MAX_VALUE;\\n        for(int i=1;i<n.length;i++)min=Math.min(min,n[i]-n[i-1]);\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] n) {\\n        Arrays.sort(n);\\n        int min=Integer.MAX_VALUE;\\n        for(int i=1;i<n.length;i++)min=Math.min(min,n[i]-n[i-1]);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657516,
                "title": "kotlin",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    fun findValueOfPartition(nums: IntArray): Int = nums\\n        .sortedDescending()\\n        .zipWithNext(Int::minus)\\n        .min()!!\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findValueOfPartition(nums: IntArray): Int = nums\\n        .sortedDescending()\\n        .zipWithNext(Int::minus)\\n        .min()!!\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657515,
                "title": "kotlin",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    fun findValueOfPartition(nums: IntArray): Int = nums\\n        .sortedDescending()\\n        .zipWithNext(Int::minus)\\n        .min()!!\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findValueOfPartition(nums: IntArray): Int = nums\\n        .sortedDescending()\\n        .zipWithNext(Int::minus)\\n        .min()!!\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657514,
                "title": "java-o-nlogn-4-lines-100-faster-sort-find-min-difference",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 1; i < nums.length; i++) min = Math.min(nums[i] - nums[i - 1], min);\\n        return min;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 1; i < nums.length; i++) min = Math.min(nums[i] - nums[i - 1], min);\\n        return min;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657481,
                "title": "a-few-solutions",
                "content": "Return the minimum adjacent difference between elements of the *sorted* input array `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findValueOfPartition(A: IntArray): Int {\\n        A.sort()\\n        return A.mapIndexed{ i, _ -> if (0 < i) A[i] - A[i - 1] else 1234567890 }.min()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findValueOfPartition = A => Math.min(...A.sort((a, b) => a - b).map((_, i) => i ? A[i] - A[i - 1] : Infinity));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    findValueOfPartition = lambda self, A: A.sort() or min(A[i] - A[i - 1] for i in range(1, len(A)))\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn find_value_of_partition(mut A: Vec<i32>) -> i32 {\\n        A.sort();\\n        A.iter().enumerate().map(|(i, _)| if 0 < i { A[i] - A[i - 1] } else { 1234567890 }).min().unwrap()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findValueOfPartition(VI& A, int best = 1e9 + 7) {\\n        sort(A.begin(), A.end());\\n        for (auto i{ 1 }; i < A.size(); ++i)\\n            best = min(best, A[i] - A[i - 1]);\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findValueOfPartition(A: IntArray): Int {\\n        A.sort()\\n        return A.mapIndexed{ i, _ -> if (0 < i) A[i] - A[i - 1] else 1234567890 }.min()!!\\n    }\\n}\\n```\n```\\nlet findValueOfPartition = A => Math.min(...A.sort((a, b) => a - b).map((_, i) => i ? A[i] - A[i - 1] : Infinity));\\n```\n```\\nclass Solution:\\n    findValueOfPartition = lambda self, A: A.sort() or min(A[i] - A[i - 1] for i in range(1, len(A)))\\n```\n```\\nimpl Solution {\\n    pub fn find_value_of_partition(mut A: Vec<i32>) -> i32 {\\n        A.sort();\\n        A.iter().enumerate().map(|(i, _)| if 0 < i { A[i] - A[i - 1] } else { 1234567890 }).min().unwrap()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findValueOfPartition(VI& A, int best = 1e9 + 7) {\\n        sort(A.begin(), A.end());\\n        for (auto i{ 1 }; i < A.size(); ++i)\\n            best = min(best, A[i] - A[i - 1]);\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656875,
                "title": "c-sort-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        // in sorted array we find elements\\n        // with indices i and i + 1 so that their\\n        // difference is minimal.\\n        // then we can put elements 0..i to array 1\\n        // and elements i+1..nums.size() - 1 to array 2\\n        sort(nums.begin(), nums.end());\\n        int ans = INT_MAX;\\n        const auto N = nums.size();\\n        for(size_t i = 1U; i < N; ++i) {\\n            ans = min(ans, nums[i] - nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        // in sorted array we find elements\\n        // with indices i and i + 1 so that their\\n        // difference is minimal.\\n        // then we can put elements 0..i to array 1\\n        // and elements i+1..nums.size() - 1 to array 2\\n        sort(nums.begin(), nums.end());\\n        int ans = INT_MAX;\\n        const auto N = nums.size();\\n        for(size_t i = 1U; i < N; ++i) {\\n            ans = min(ans, nums[i] - nums[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656720,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func findValueOfPartition(_ nums: [Int]) -> Int {\\n\\n        let nums = nums.sorted()\\n        var res = Int.max\\n\\n        for i in 1..<nums.count {\\n            res = min(res, nums[i] - nums[i - 1])\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findValueOfPartition(_ nums: [Int]) -> Int {\\n\\n        let nums = nums.sorted()\\n        var res = Int.max\\n\\n        for i in 1..<nums.count {\\n            res = min(res, nums[i] - nums[i - 1])\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656226,
                "title": "o-n-simple-solution-approach-code-java",
                "content": "<!--# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the array.\\n- Check the least min difference between adjacent elements.\\n- Because we have to find the value of the partition i.e. \\n    |max(nums1) - min(nums2)|\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length, min=Integer.MAX_VALUE;\\n        for(int i=1; i<n; i++){\\n            int diff = nums[i]-nums[i-1];\\n            if(diff<min) min=diff;\\n        }\\n        return Math.abs(min);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length, min=Integer.MAX_VALUE;\\n        for(int i=1; i<n; i++){\\n            int diff = nums[i]-nums[i-1];\\n            if(diff<min) min=diff;\\n        }\\n        return Math.abs(min);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655860,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min= nums[nums.length-1];\\n        for(int i =0;i<nums.length-1;i++){\\n            min=Math.min(min,(nums[i+1]-nums[i]));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValueOfPartition(int[] nums) {\\n        Arrays.sort(nums);\\n        int min= nums[nums.length-1];\\n        for(int i =0;i<nums.length-1;i++){\\n            min=Math.min(min,(nums[i+1]-nums[i]));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655526,
                "title": "c-sort-easy-solution-with-explanation",
                "content": "**We want to patition the array in such a way that first set max and second set min difference should be minimum**\\n1. Sort the given array\\n2. Traverse from 1 to n and check the minimum difference between arr[i] and arr[i-1] (if we partition the array at position i the maximum element in first set will be arr[i-1] and minimum element in second set will be arr[i]) \\n3. return the minimum differnce abtained from above action\\n\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            long long diff=abs((long long)nums[i]-(long long)nums[i-1]);\\n            if(ans>diff)\\n            {\\n                ans=diff;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            long long diff=abs((long long)nums[i]-(long long)nums[i-1]);\\n            if(ans>diff)\\n            {\\n                ans=diff;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655383,
                "title": "java-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int findValueOfPartition(int[] nums) {\\n    Arrays.sort(nums);\\n    int ans = nums[1] - nums[0];\\n    for(int i = 2; i != nums.length; ++i)\\n      ans = Math.min(ans, nums[i] - nums[i-1]);\\n    return ans;      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int findValueOfPartition(int[] nums) {\\n    Arrays.sort(nums);\\n    int ans = nums[1] - nums[0];\\n    for(int i = 2; i != nums.length; ++i)\\n      ans = Math.min(ans, nums[i] - nums[i-1]);\\n    return ans;      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654775,
                "title": "easiest-soln-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());int mn=INT_MAX;\\n        for(int i=0;i<nums.size()-1;i++){\\n            mn=min(mn,nums[i+1]-nums[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());int mn=INT_MAX;\\n        for(int i=0;i<nums.size()-1;i++){\\n            mn=min(mn,nums[i+1]-nums[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654741,
                "title": "c-simplest-solution-using-sorting",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n\\n        sort(nums.begin(), nums.end());\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0; i<nums.size()-1; i++) {\\n            int temp = nums[i+1] - nums[i];\\n            ans = min(ans, temp);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n\\n        sort(nums.begin(), nums.end());\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0; i<nums.size()-1; i++) {\\n            int temp = nums[i+1] - nums[i];\\n            ans = min(ans, temp);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654440,
                "title": "simple-c-solution-explained-approach",
                "content": "# Intuition\\nThe intuition behind this code is to first sort the array, and then find the minimum absolute difference between any two adjacent elements in the array. This is the minimum value of a partition.\\n# Approach\\nThe approach used by this code is as follows:\\n1. Sort the array.\\n2. Iterate through the array, and for each pair of adjacent elements, find the minimum absolute difference between them.\\n3. Return the minimum absolute difference found in step 2.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is **O(n log n)**, where n is the size of the array. This is because the sorting step takes O(n log n) time, and the rest of the code takes O(n) time.\\n\\n\\n- Space complexity:\\nThe space complexity of this code is **O(1)**. This is because the only extra space used by the code is a variable to store the minimum absolute difference.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int sz = nums.size();\\n        int minn = INT_MAX;\\n        for(int i = 0; i<sz-1; i++){\\n            minn = min(abs(nums[i] - nums[i+1]), minn);\\n        }\\n        return minn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int sz = nums.size();\\n        int minn = INT_MAX;\\n        for(int i = 0; i<sz-1; i++){\\n            minn = min(abs(nums[i] - nums[i+1]), minn);\\n        }\\n        return minn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654419,
                "title": "java-100-faster",
                "content": "# Approach\\nWe sort the array, and then find the point where the difference between adjacent elements is minimum. The element on the left will be the maxima of the left array and the element on the right will be minima of the right array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int findValueOfPartition(int[] nums)\\n    {\\n        Arrays.sort(nums);\\n        int d = Integer.MAX_VALUE;\\n\\n        for(int i=1; i<nums.length && d>0; i++)\\n            d = Math.min(d,nums[i]-nums[i-1]);\\n\\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int findValueOfPartition(int[] nums)\\n    {\\n        Arrays.sort(nums);\\n        int d = Integer.MAX_VALUE;\\n\\n        for(int i=1; i<nums.length && d>0; i++)\\n            d = Math.min(d,nums[i]-nums[i-1]);\\n\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654346,
                "title": "c-sort",
                "content": "# C++\\n\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n        int ans = INT_MAX;\\n        for (int i = 1; i < nums.size(); ++i)\\n        {\\n            ans = min(ans, abs(nums[i] - nums[i - 1]));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n        int ans = INT_MAX;\\n        for (int i = 1; i < nums.size(); ++i)\\n        {\\n            ans = min(ans, abs(nums[i] - nums[i - 1]));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654235,
                "title": "swift-simple-traversal-after-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Just find the min diff for the consecutive elements in sorted arr\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findValueOfPartition(_ nums: [Int]) -> Int {\\n        var ans = Int.max\\n        var nums = nums.sorted()\\n        for i in 0 ..< nums.count - 1 {\\n            ans = min(ans, nums[i + 1] - nums[i])\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findValueOfPartition(_ nums: [Int]) -> Int {\\n        var ans = Int.max\\n        var nums = nums.sorted()\\n        for i in 0 ..< nums.count - 1 {\\n            ans = min(ans, nums[i + 1] - nums[i])\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654171,
                "title": "rust-two-lines",
                "content": "Sort the array.\\n\\nFind the distance between each number and return the minimum.\\n\\n```\\nimpl Solution {\\n    pub fn find_value_of_partition(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable();\\n        nums.windows(2).map(|w| w[1] - w[0]).min().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_value_of_partition(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable();\\n        nums.windows(2).map(|w| w[1] - w[0]).min().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3654087,
                "title": "short-ruby-solution-with-explanation-100-100",
                "content": "# Intuition\\nThe smallest difference will be from the two closest numbers.  Sort the array and find those.\\n\\n# Approach\\n1. Sort nums.\\n2. Initialize min as infinity.\\n3. Find the difference between each pair of consecutive numbers and compare it with min.\\n4. Return min.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ndef find_value_of_partition(nums)\\n    nums.sort!\\n    min = Float::INFINITY\\n    (1...nums.length).each { |i| min = [nums[i] - nums[i-1], min].min }\\n    min\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef find_value_of_partition(nums)\\n    nums.sort!\\n    min = Float::INFINITY\\n    (1...nums.length).each { |i| min = [nums[i] - nums[i-1], min].min }\\n    min\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3653841,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++){\\n            ans=min(ans,nums[i+1]-nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++){\\n            ans=min(ans,nums[i+1]-nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653679,
                "title": "easy-4-line-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mn=INT_MAX;\\n        for (int i=0; i<nums.size()-1; i++)\\n        {\\n            mn = min(mn,nums[i+1]-nums[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mn=INT_MAX;\\n        for (int i=0; i<nums.size()-1; i++)\\n        {\\n            mn = min(mn,nums[i+1]-nums[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653548,
                "title": "easy-c",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int n  = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ans = INT_MAX;\\n        for(int i = 0; i < n-1; i++) {\\n            ans = min(ans, abs(nums[i+1] - nums[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValueOfPartition(vector<int>& nums) {\\n        int n  = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ans = INT_MAX;\\n        for(int i = 0; i < n-1; i++) {\\n            ans = min(ans, abs(nums[i+1] - nums[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1935042,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Think about how you can **maximize the minimum and minimize the maximum** to get the smaller result"
                    },
                    {
                        "username": "Ved07",
                        "content": "Hint: Sort"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "i was stuck thinking that array might have duplicate element "
                    },
                    {
                        "username": "yoo_hoo",
                        "content": "In that case 0 is answer."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "yes broo  \\uD83D\\uDE4B\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Nams21",
                        "content": "easiest medium question on leetcode"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I do not understand this problem how i solve this"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "[@SahilNikam](/SahilNikam) Thanks Sahil \\nafter read your comment I solve this problem within 2-3 minute"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "--> just sort the array and find minimum difference between any two element that\\'s it. And that\\'s the answer.\\n\\n--> Let [1,6,4,3] is the array after sorting it will become [1,3,4,6] and minimum difference between any two elements is 1 and for 3,4 pair so we can make [1,3] and [4,6] two different array.\\n\\n--> no need to actually make two arrays and put elements into it. We just want difference. \\n\\nUpvote if you have understood it and let me know if you have any doubts :)"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "What made you assume that nums element are unique...??\\nDuplicacy of element may be there.....because its not specified....\\nhow the hell can we solve it by sorting??\\nplease help!!!!!!!!\\n"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "[@SahilNikam](/SahilNikam) thanks man!!! I thought ki  duplicate element needs to belong to either of the partititon..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "eg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it should be easy problem."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "just sort the array and find minimum difference between any two element that\\'s it.no need to make two arrays and put elements into it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@cosmic_saurabh](/cosmic_saurabh) \\neg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "//what if there is duplicate elements??"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to get Intuition and approach with image representation ,check out my solution post.\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/find-the-value-of-the-partition/solutions/3650487/image-representation-well-explained-java-sorting/"
                    }
                ]
            },
            {
                "id": 1935032,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Think about how you can **maximize the minimum and minimize the maximum** to get the smaller result"
                    },
                    {
                        "username": "Ved07",
                        "content": "Hint: Sort"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "i was stuck thinking that array might have duplicate element "
                    },
                    {
                        "username": "yoo_hoo",
                        "content": "In that case 0 is answer."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "yes broo  \\uD83D\\uDE4B\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Nams21",
                        "content": "easiest medium question on leetcode"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I do not understand this problem how i solve this"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "[@SahilNikam](/SahilNikam) Thanks Sahil \\nafter read your comment I solve this problem within 2-3 minute"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "--> just sort the array and find minimum difference between any two element that\\'s it. And that\\'s the answer.\\n\\n--> Let [1,6,4,3] is the array after sorting it will become [1,3,4,6] and minimum difference between any two elements is 1 and for 3,4 pair so we can make [1,3] and [4,6] two different array.\\n\\n--> no need to actually make two arrays and put elements into it. We just want difference. \\n\\nUpvote if you have understood it and let me know if you have any doubts :)"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "What made you assume that nums element are unique...??\\nDuplicacy of element may be there.....because its not specified....\\nhow the hell can we solve it by sorting??\\nplease help!!!!!!!!\\n"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "[@SahilNikam](/SahilNikam) thanks man!!! I thought ki  duplicate element needs to belong to either of the partititon..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "eg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it should be easy problem."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "just sort the array and find minimum difference between any two element that\\'s it.no need to make two arrays and put elements into it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@cosmic_saurabh](/cosmic_saurabh) \\neg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "//what if there is duplicate elements??"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to get Intuition and approach with image representation ,check out my solution post.\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/find-the-value-of-the-partition/solutions/3650487/image-representation-well-explained-java-sorting/"
                    }
                ]
            },
            {
                "id": 1933853,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Think about how you can **maximize the minimum and minimize the maximum** to get the smaller result"
                    },
                    {
                        "username": "Ved07",
                        "content": "Hint: Sort"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "i was stuck thinking that array might have duplicate element "
                    },
                    {
                        "username": "yoo_hoo",
                        "content": "In that case 0 is answer."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "yes broo  \\uD83D\\uDE4B\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Nams21",
                        "content": "easiest medium question on leetcode"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I do not understand this problem how i solve this"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "[@SahilNikam](/SahilNikam) Thanks Sahil \\nafter read your comment I solve this problem within 2-3 minute"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "--> just sort the array and find minimum difference between any two element that\\'s it. And that\\'s the answer.\\n\\n--> Let [1,6,4,3] is the array after sorting it will become [1,3,4,6] and minimum difference between any two elements is 1 and for 3,4 pair so we can make [1,3] and [4,6] two different array.\\n\\n--> no need to actually make two arrays and put elements into it. We just want difference. \\n\\nUpvote if you have understood it and let me know if you have any doubts :)"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "What made you assume that nums element are unique...??\\nDuplicacy of element may be there.....because its not specified....\\nhow the hell can we solve it by sorting??\\nplease help!!!!!!!!\\n"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "[@SahilNikam](/SahilNikam) thanks man!!! I thought ki  duplicate element needs to belong to either of the partititon..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "eg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it should be easy problem."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "just sort the array and find minimum difference between any two element that\\'s it.no need to make two arrays and put elements into it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@cosmic_saurabh](/cosmic_saurabh) \\neg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "//what if there is duplicate elements??"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to get Intuition and approach with image representation ,check out my solution post.\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/find-the-value-of-the-partition/solutions/3650487/image-representation-well-explained-java-sorting/"
                    }
                ]
            },
            {
                "id": 2018279,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Think about how you can **maximize the minimum and minimize the maximum** to get the smaller result"
                    },
                    {
                        "username": "Ved07",
                        "content": "Hint: Sort"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "i was stuck thinking that array might have duplicate element "
                    },
                    {
                        "username": "yoo_hoo",
                        "content": "In that case 0 is answer."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "yes broo  \\uD83D\\uDE4B\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Nams21",
                        "content": "easiest medium question on leetcode"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I do not understand this problem how i solve this"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "[@SahilNikam](/SahilNikam) Thanks Sahil \\nafter read your comment I solve this problem within 2-3 minute"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "--> just sort the array and find minimum difference between any two element that\\'s it. And that\\'s the answer.\\n\\n--> Let [1,6,4,3] is the array after sorting it will become [1,3,4,6] and minimum difference between any two elements is 1 and for 3,4 pair so we can make [1,3] and [4,6] two different array.\\n\\n--> no need to actually make two arrays and put elements into it. We just want difference. \\n\\nUpvote if you have understood it and let me know if you have any doubts :)"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "What made you assume that nums element are unique...??\\nDuplicacy of element may be there.....because its not specified....\\nhow the hell can we solve it by sorting??\\nplease help!!!!!!!!\\n"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "[@SahilNikam](/SahilNikam) thanks man!!! I thought ki  duplicate element needs to belong to either of the partititon..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "eg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it should be easy problem."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "just sort the array and find minimum difference between any two element that\\'s it.no need to make two arrays and put elements into it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@cosmic_saurabh](/cosmic_saurabh) \\neg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "//what if there is duplicate elements??"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to get Intuition and approach with image representation ,check out my solution post.\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/find-the-value-of-the-partition/solutions/3650487/image-representation-well-explained-java-sorting/"
                    }
                ]
            },
            {
                "id": 1946933,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Think about how you can **maximize the minimum and minimize the maximum** to get the smaller result"
                    },
                    {
                        "username": "Ved07",
                        "content": "Hint: Sort"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "i was stuck thinking that array might have duplicate element "
                    },
                    {
                        "username": "yoo_hoo",
                        "content": "In that case 0 is answer."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "yes broo  \\uD83D\\uDE4B\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Nams21",
                        "content": "easiest medium question on leetcode"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I do not understand this problem how i solve this"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "[@SahilNikam](/SahilNikam) Thanks Sahil \\nafter read your comment I solve this problem within 2-3 minute"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "--> just sort the array and find minimum difference between any two element that\\'s it. And that\\'s the answer.\\n\\n--> Let [1,6,4,3] is the array after sorting it will become [1,3,4,6] and minimum difference between any two elements is 1 and for 3,4 pair so we can make [1,3] and [4,6] two different array.\\n\\n--> no need to actually make two arrays and put elements into it. We just want difference. \\n\\nUpvote if you have understood it and let me know if you have any doubts :)"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "What made you assume that nums element are unique...??\\nDuplicacy of element may be there.....because its not specified....\\nhow the hell can we solve it by sorting??\\nplease help!!!!!!!!\\n"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "[@SahilNikam](/SahilNikam) thanks man!!! I thought ki  duplicate element needs to belong to either of the partititon..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "eg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it should be easy problem."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "just sort the array and find minimum difference between any two element that\\'s it.no need to make two arrays and put elements into it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@cosmic_saurabh](/cosmic_saurabh) \\neg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "//what if there is duplicate elements??"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to get Intuition and approach with image representation ,check out my solution post.\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/find-the-value-of-the-partition/solutions/3650487/image-representation-well-explained-java-sorting/"
                    }
                ]
            },
            {
                "id": 1937428,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Think about how you can **maximize the minimum and minimize the maximum** to get the smaller result"
                    },
                    {
                        "username": "Ved07",
                        "content": "Hint: Sort"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "i was stuck thinking that array might have duplicate element "
                    },
                    {
                        "username": "yoo_hoo",
                        "content": "In that case 0 is answer."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "yes broo  \\uD83D\\uDE4B\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Nams21",
                        "content": "easiest medium question on leetcode"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I do not understand this problem how i solve this"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "[@SahilNikam](/SahilNikam) Thanks Sahil \\nafter read your comment I solve this problem within 2-3 minute"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "--> just sort the array and find minimum difference between any two element that\\'s it. And that\\'s the answer.\\n\\n--> Let [1,6,4,3] is the array after sorting it will become [1,3,4,6] and minimum difference between any two elements is 1 and for 3,4 pair so we can make [1,3] and [4,6] two different array.\\n\\n--> no need to actually make two arrays and put elements into it. We just want difference. \\n\\nUpvote if you have understood it and let me know if you have any doubts :)"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "What made you assume that nums element are unique...??\\nDuplicacy of element may be there.....because its not specified....\\nhow the hell can we solve it by sorting??\\nplease help!!!!!!!!\\n"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "[@SahilNikam](/SahilNikam) thanks man!!! I thought ki  duplicate element needs to belong to either of the partititon..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "eg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it should be easy problem."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "just sort the array and find minimum difference between any two element that\\'s it.no need to make two arrays and put elements into it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@cosmic_saurabh](/cosmic_saurabh) \\neg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "//what if there is duplicate elements??"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to get Intuition and approach with image representation ,check out my solution post.\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/find-the-value-of-the-partition/solutions/3650487/image-representation-well-explained-java-sorting/"
                    }
                ]
            },
            {
                "id": 1937168,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Think about how you can **maximize the minimum and minimize the maximum** to get the smaller result"
                    },
                    {
                        "username": "Ved07",
                        "content": "Hint: Sort"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "i was stuck thinking that array might have duplicate element "
                    },
                    {
                        "username": "yoo_hoo",
                        "content": "In that case 0 is answer."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "yes broo  \\uD83D\\uDE4B\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Nams21",
                        "content": "easiest medium question on leetcode"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I do not understand this problem how i solve this"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "[@SahilNikam](/SahilNikam) Thanks Sahil \\nafter read your comment I solve this problem within 2-3 minute"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "--> just sort the array and find minimum difference between any two element that\\'s it. And that\\'s the answer.\\n\\n--> Let [1,6,4,3] is the array after sorting it will become [1,3,4,6] and minimum difference between any two elements is 1 and for 3,4 pair so we can make [1,3] and [4,6] two different array.\\n\\n--> no need to actually make two arrays and put elements into it. We just want difference. \\n\\nUpvote if you have understood it and let me know if you have any doubts :)"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "What made you assume that nums element are unique...??\\nDuplicacy of element may be there.....because its not specified....\\nhow the hell can we solve it by sorting??\\nplease help!!!!!!!!\\n"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "[@SahilNikam](/SahilNikam) thanks man!!! I thought ki  duplicate element needs to belong to either of the partititon..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "eg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it should be easy problem."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "just sort the array and find minimum difference between any two element that\\'s it.no need to make two arrays and put elements into it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@cosmic_saurabh](/cosmic_saurabh) \\neg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "//what if there is duplicate elements??"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to get Intuition and approach with image representation ,check out my solution post.\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/find-the-value-of-the-partition/solutions/3650487/image-representation-well-explained-java-sorting/"
                    }
                ]
            },
            {
                "id": 1937166,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Think about how you can **maximize the minimum and minimize the maximum** to get the smaller result"
                    },
                    {
                        "username": "Ved07",
                        "content": "Hint: Sort"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "i was stuck thinking that array might have duplicate element "
                    },
                    {
                        "username": "yoo_hoo",
                        "content": "In that case 0 is answer."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "yes broo  \\uD83D\\uDE4B\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Nams21",
                        "content": "easiest medium question on leetcode"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I do not understand this problem how i solve this"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "[@SahilNikam](/SahilNikam) Thanks Sahil \\nafter read your comment I solve this problem within 2-3 minute"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "--> just sort the array and find minimum difference between any two element that\\'s it. And that\\'s the answer.\\n\\n--> Let [1,6,4,3] is the array after sorting it will become [1,3,4,6] and minimum difference between any two elements is 1 and for 3,4 pair so we can make [1,3] and [4,6] two different array.\\n\\n--> no need to actually make two arrays and put elements into it. We just want difference. \\n\\nUpvote if you have understood it and let me know if you have any doubts :)"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "What made you assume that nums element are unique...??\\nDuplicacy of element may be there.....because its not specified....\\nhow the hell can we solve it by sorting??\\nplease help!!!!!!!!\\n"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "[@SahilNikam](/SahilNikam) thanks man!!! I thought ki  duplicate element needs to belong to either of the partititon..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "eg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it should be easy problem."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "just sort the array and find minimum difference between any two element that\\'s it.no need to make two arrays and put elements into it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@cosmic_saurabh](/cosmic_saurabh) \\neg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "//what if there is duplicate elements??"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to get Intuition and approach with image representation ,check out my solution post.\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/find-the-value-of-the-partition/solutions/3650487/image-representation-well-explained-java-sorting/"
                    }
                ]
            },
            {
                "id": 1933885,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Think about how you can **maximize the minimum and minimize the maximum** to get the smaller result"
                    },
                    {
                        "username": "Ved07",
                        "content": "Hint: Sort"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "i was stuck thinking that array might have duplicate element "
                    },
                    {
                        "username": "yoo_hoo",
                        "content": "In that case 0 is answer."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "yes broo  \\uD83D\\uDE4B\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "Nams21",
                        "content": "easiest medium question on leetcode"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "I do not understand this problem how i solve this"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "[@SahilNikam](/SahilNikam) Thanks Sahil \\nafter read your comment I solve this problem within 2-3 minute"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "--> just sort the array and find minimum difference between any two element that\\'s it. And that\\'s the answer.\\n\\n--> Let [1,6,4,3] is the array after sorting it will become [1,3,4,6] and minimum difference between any two elements is 1 and for 3,4 pair so we can make [1,3] and [4,6] two different array.\\n\\n--> no need to actually make two arrays and put elements into it. We just want difference. \\n\\nUpvote if you have understood it and let me know if you have any doubts :)"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "What made you assume that nums element are unique...??\\nDuplicacy of element may be there.....because its not specified....\\nhow the hell can we solve it by sorting??\\nplease help!!!!!!!!\\n"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "[@SahilNikam](/SahilNikam) thanks man!!! I thought ki  duplicate element needs to belong to either of the partititon..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "eg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it should be easy problem."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "just sort the array and find minimum difference between any two element that\\'s it.no need to make two arrays and put elements into it."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@cosmic_saurabh](/cosmic_saurabh) \\neg, [1.3.3.2.4]\\nhere 3 is repeated so after sorting it becomes [1,2,3,3,4]\\nminimum difference between two elements is 0 and we can make partition like[1,2,3] and[3,4] here 3 is maximum in first array and minimum in second array.\\nplease upvote if you\\'ve understood it."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "//what if there is duplicate elements??"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to get Intuition and approach with image representation ,check out my solution post.\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/find-the-value-of-the-partition/solutions/3650487/image-representation-well-explained-java-sorting/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Customers with Maximum Number of Transactions on Consecutive Days",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 2012263,
                "content": [
                    {
                        "username": "leo66six",
                        "content": "No \"distinct\" for the final answer. The output from testcase include duplicated id."
                    }
                ]
            }
        ]
    }
]