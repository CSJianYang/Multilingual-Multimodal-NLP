[
    {
        "title": "Most Profit Assigning Work",
        "question_content": "You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\n\n\tdifficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\n\tworker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).\n\nEvery worker can be assigned at most one job, but one job can be completed multiple times.\n\n\tFor example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\n&nbsp;\nExample 1:\n\nInput: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100\nExplanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.\n\nExample 2:\n\nInput: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\tn == difficulty.length\n\tn == profit.length\n\tm == worker.length\n\t1 <= n, m <= 104\n\t1 <= difficulty[i], profit[i], worker[i] <= 105",
        "solutions": [
            {
                "id": 127031,
                "title": "c-java-python-sort-and-two-pointer",
                "content": "# Solution 1\\n1. zip `difficulty` and `profit` as jobs.\\n2. sort `jobs` and sort \\'worker\\'.\\n3. Use 2 pointers. For each worker, find his maximum profit `best` he can make under his ability.\\n<br>\\n\\nBecause we have sorted `jobs` and `worker`,\\nwe will go through two lists only once.\\nthis will be only `O(D + W)`.\\n`O(DlogD + WlogW)`, as we sort jobs.\\n<br>\\n\\n**C++**\\n```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> jobs;\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.push_back(make_pair(difficulty[j], profit[j]));\\n        sort(jobs.begin(), jobs.end());\\n        sort(worker.begin(), worker.end());\\n        for (int & ability : worker) {\\n            while (i < N && ability >= jobs[i].first)\\n                best = max(jobs[i++].second, best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair<Integer, Integer>> jobs = new ArrayList<>();\\n        int N = profit.length, res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.add(new Pair<Integer, Integer>(difficulty[j], profit[j]));\\n        Collections.sort(jobs, Comparator.comparing(Pair::getKey));\\n        Arrays.sort(worker);\\n        for (int ability : worker) {\\n            while (i < N && ability >= jobs.get(i).getKey())\\n                best = Math.max(jobs.get(i++).getValue(), best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        jobs = sorted(zip(difficulty, profit))\\n        res = i = best = 0\\n        for ability in sorted(worker):\\n            while i < len(jobs) and ability >= jobs[i][0]:\\n                best = max(jobs[i][1], best)\\n                i += 1\\n            res += best\\n        return res\\n\\n```\\n<br>\\n\\n# Solution 2\\n1. Use a treemap<difficulty, profit>\\n2. Go through the treemap once, find the max profit `best` for each difficulty.\\nTime `O(DlogD + WlogD)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        map.put(0, 0);\\n        for (int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i], 0)));\\n        }\\n        int best = 0, res = 0;\\n        for (Integer key : map.keySet()) {\\n            best = Math.max(map.get(key), best);\\n            map.put(key, best);\\n        }\\n        for (int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        map<int, int> jobs;\\n        jobs[0] = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs[difficulty[j]] = max(jobs[difficulty[j]], profit[j]);\\n        for (auto &it: jobs)\\n            it.second = best = max(best, it.second);\\n        for (int & ability : worker)\\n            res += (--jobs.upper_bound(ability))->second;\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> jobs;\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.push_back(make_pair(difficulty[j], profit[j]));\\n        sort(jobs.begin(), jobs.end());\\n        sort(worker.begin(), worker.end());\\n        for (int & ability : worker) {\\n            while (i < N && ability >= jobs[i].first)\\n                best = max(jobs[i++].second, best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair<Integer, Integer>> jobs = new ArrayList<>();\\n        int N = profit.length, res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.add(new Pair<Integer, Integer>(difficulty[j], profit[j]));\\n        Collections.sort(jobs, Comparator.comparing(Pair::getKey));\\n        Arrays.sort(worker);\\n        for (int ability : worker) {\\n            while (i < N && ability >= jobs.get(i).getKey())\\n                best = Math.max(jobs.get(i++).getValue(), best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        jobs = sorted(zip(difficulty, profit))\\n        res = i = best = 0\\n        for ability in sorted(worker):\\n            while i < len(jobs) and ability >= jobs[i][0]:\\n                best = max(jobs[i][1], best)\\n                i += 1\\n            res += best\\n        return res\\n\\n```\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        map.put(0, 0);\\n        for (int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i], 0)));\\n        }\\n        int best = 0, res = 0;\\n        for (Integer key : map.keySet()) {\\n            best = Math.max(map.get(key), best);\\n            map.put(key, best);\\n        }\\n        for (int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        map<int, int> jobs;\\n        jobs[0] = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs[difficulty[j]] = max(jobs[difficulty[j]], profit[j]);\\n        for (auto &it: jobs)\\n            it.second = best = max(best, it.second);\\n        for (int & ability : worker)\\n            res += (--jobs.upper_bound(ability))->second;\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 127133,
                "title": "java-solution-with-treemap",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       \\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        // in case two jobs have same difficulty but different profit, we want to count\\n        // the higher profit\\n        for (int i = 0; i < difficulty.length; i++) {\\n            tmap.put(difficulty[i], Math.max(profit[i], tmap.getOrDefault(difficulty[i], 0)));\\n        }\\n\\n        int max = 0, res = 0;\\n        // maximum profit at this difficulty or below in case\\n        // lower difficulty job offers higher profit\\n        for (Integer key : tmap.keySet()) {\\n            max = Math.max(tmap.get(key), max);\\n            tmap.put(key, max);\\n        }\\n        \\n        Map.Entry<Integer, Integer> entry = null;\\n        for (int i = 0; i < worker.length; i++) {\\n            if (tmap.containsKey(worker[i])) {\\n                res += tmap.get(worker[i]);\\n            } else {\\n                entry = tmap.floorEntry(worker[i]);            \\n                if (entry != null) {\\n                    res += entry.getValue();\\n                }\\n            }  \\n        }\\n        return res;  \\n}",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       \\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        // in case two jobs have same difficulty but different profit, we want to count\\n        // the higher profit\\n        for (int i = 0; i < difficulty.length; i++) {\\n            tmap.put(difficulty[i], Math.max(profit[i], tmap.getOrDefault(difficulty[i], 0)));\\n        }\\n\\n        int max = 0, res = 0;\\n        // maximum profit at this difficulty or below in case\\n        // lower difficulty job offers higher profit\\n        for (Integer key : tmap.keySet()) {\\n            max = Math.max(tmap.get(key), max);\\n            tmap.put(key, max);\\n        }\\n        \\n        Map.Entry<Integer, Integer> entry = null;\\n        for (int i = 0; i < worker.length; i++) {\\n            if (tmap.containsKey(worker[i])) {\\n                res += tmap.get(worker[i]);\\n            } else {\\n                entry = tmap.floorEntry(worker[i]);            \\n                if (entry != null) {\\n                    res += entry.getValue();\\n                }\\n            }  \\n        }\\n        return res;  \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 175676,
                "title": "java-memorization-without-sort-beat-99-85",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126964,
                "title": "c-4-lines-sort-bucket-sort-and-bucked-sort-with-two-pointers",
                "content": "This solution sorts levels and assigns the maximum profit among all jobs with equal or lower level:\\n\\n1. Load levels and profits into a sorted map.\\n2. Update the map so that each level has the maximum possible profit. Practically, if the previous level has higher profit, we assign that profit to the current level.\\n3. For each worker, search the map to get the maximum profit for the worker\\'s level.\\n\\nThe complexity is O((n + m) log n), where n and m is the number of jobs and workers respectfully.\\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  map<int, int> m = { { 0, 0 } };\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto it = next(m.begin()); it != m.end(); ++it) it->second = max(it->second, prev(it)->second);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) {return s + prev(m.upper_bound(w))->second;});\\n}\\n```\\nAs a bonus, below is the solution that uses bucket sort. It requires, however, additional memory but the runtime complexity is O(N + m), where N is the number of levels (100,000 in our case). The second solution is only slightly faster in OJ (100 vs. 110 ms), probably because n is signifficantly smaller than N in the test cases.\\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {};\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto i = 1; i < 100001; ++i) m[i] = max(m[i], m[i - 1]);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) { return s + m[w]; });\\n}\\n```\\nI also checked the sort and two-pointer solution by @lee215. That solution requires two sorts, that\\'s why my preference was to sort once and fix profits in the linear time. Anyway, I adopted the two-pointer solution to use the bucket sort. Note that I store the number of workers with a given level in the second array.\\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {}, w[100001] = {}, p = 0, max_p = 0;\\n  for (auto i = 0; i < lv.size(); ++w[worker[i++]]) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  return accumulate(begin(w), end(w), 0, [&](int s, int w) { max_p = max(max_p, m[p++]); return s + max_p * w; });\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  map<int, int> m = { { 0, 0 } };\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto it = next(m.begin()); it != m.end(); ++it) it->second = max(it->second, prev(it)->second);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) {return s + prev(m.upper_bound(w))->second;});\\n}\\n```\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {};\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto i = 1; i < 100001; ++i) m[i] = max(m[i], m[i - 1]);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) { return s + m[w]; });\\n}\\n```\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {}, w[100001] = {}, p = 0, max_p = 0;\\n  for (auto i = 0; i < lv.size(); ++w[worker[i++]]) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  return accumulate(begin(w), end(w), 0, [&](int s, int w) { max_p = max(max_p, m[p++]); return s + max_p * w; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 438559,
                "title": "short-simple-binary-search-java",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = difficulty.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i=0;i<n;i++) {\\n            list.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        list.sort((a,b)->(a[0]-b[0]!=0?a[0]-b[0]:b[1]-a[1]));\\n        int[] max = new int[n];\\n        max[0]=list.get(0)[1];// Maximum Value till a given index.\\n        for (int i=1;i<n;i++) {\\n            max[i]=Math.max(list.get(i)[1],max[i-1]); \\n        }\\n        int ans=0;\\n        for(int w: worker) {\\n            int res = bs(w,list);\\n            ans+=res==-1?0:max[res];\\n        }\\n        return ans;\\n    }\\n\\t// Smallest index which is less than or equal to the given target.\\n    private int bs(int target,List<int[]> list) {\\n        int lo = 0;\\n        int hi = list.size()-1;\\n        if(target>=list.get(hi)[0]) {\\n            return hi;\\n        }\\n        int ans = -1;\\n        while (lo<hi) {\\n            int mid = (lo)+(hi-lo)/2;\\n            int val = list.get(mid)[0];\\n            if(target>=val) {\\n                ans=mid;\\n                lo=mid+1;\\n            } else {\\n                hi=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = difficulty.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i=0;i<n;i++) {\\n            list.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        list.sort((a,b)->(a[0]-b[0]!=0?a[0]-b[0]:b[1]-a[1]));\\n        int[] max = new int[n];\\n        max[0]=list.get(0)[1];// Maximum Value till a given index.\\n        for (int i=1;i<n;i++) {\\n            max[i]=Math.max(list.get(i)[1],max[i-1]); \\n        }\\n        int ans=0;\\n        for(int w: worker) {\\n            int res = bs(w,list);\\n            ans+=res==-1?0:max[res];\\n        }\\n        return ans;\\n    }\\n\\t// Smallest index which is less than or equal to the given target.\\n    private int bs(int target,List<int[]> list) {\\n        int lo = 0;\\n        int hi = list.size()-1;\\n        if(target>=list.get(hi)[0]) {\\n            return hi;\\n        }\\n        int ans = -1;\\n        while (lo<hi) {\\n            int mid = (lo)+(hi-lo)/2;\\n            int val = list.get(mid)[0];\\n            if(target>=val) {\\n                ans=mid;\\n                lo=mid+1;\\n            } else {\\n                hi=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126994,
                "title": "concise-c-solution-using-map-as-a-bst",
                "content": "```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    map<int, int> m{{0,0}};\\n    for (int i = 0; i < difficulty.size(); i++) // create the difficulty-maximum-profit BST\\n        m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n    int mx = 0, res = 0;\\n    for (auto &p : m) // update the BST to reflect the maximum profit for a job\\n        mx = p.second = max(p.second, mx);\\n    for (int w : worker) // look up the BST to find the maximum profit for each worker\\n        res += prev(m.upper_bound(w))->second;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    map<int, int> m{{0,0}};\\n    for (int i = 0; i < difficulty.size(); i++) // create the difficulty-maximum-profit BST\\n        m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n    int mx = 0, res = 0;\\n    for (auto &p : m) // update the BST to reflect the maximum profit for a job\\n        mx = p.second = max(p.second, mx);\\n    for (int w : worker) // look up the BST to find the maximum profit for each worker\\n        res += prev(m.upper_bound(w))->second;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1288704,
                "title": "simple-java-solution",
                "content": "**Approach** : \\n1. bind profit & difficulty array together using a simple 2d-array \\'pair\\'.\\n2.  sort pair array on basis of difficulty column.\\n3.  sort worker array.\\n3.  for each worker, find his maximum profit best he can make under his ability.\\n\\n**Doubt** :\\nWhat is the need to sort worker[ ] ???\\n**Reason** :\\nIf current worker has more capacity than his previous ones, then his minimum bestPay should be equal to, maximum bestPaySoFar of workers with less capacity.\\nIf he\\'s able to do more-tougher-job, but less-tougher-job pays more, then he\\'s automatically entitled to benefits of that less-tougher-job.\\nNow because he has more ability as compared to previous workers, he can explore more tougher-high-paying-jobs.\\n\\nDue to this, we need to traverse pair[ ] only once.\\nthough we have nested for-while loop, but complexity will become o[worker.length] + o[pair.length].\\n\\nOverall time complexity:\\ndue to sorting of both worker & pair : O(PlogP + WlogW).\\n\\n**Java**:\\n```\\npublic int maxProfitAssignment(int[] diff, int[] profit, int[] worker) {`\\n\\n\\tint pair[][] = new int[diff.length][2];\\n\\tfor(int i = 0; i < diff.length; i++){\\n\\t\\tpair[i][0] = diff[i];\\n\\t\\tpair[i][1] = profit[i];\\n\\t}\\n\\t// sorting 2d array on basis of difficulty colmn\\n\\tArrays.sort(pair, new Comparator<int[]>() {\\n\\t\\t@Override\\n\\t\\tpublic int compare(int o1[], int o2[]){\\n\\t\\t\\treturn Integer.valueOf(o1[0]).compareTo(o2[0]);\\n\\t\\t}\\n\\t});\\n\\n\\tint totalProfit = 0;\\n\\n\\t//MAGIC begins HERE\\n\\tArrays.sort(worker);\\n\\tint bestPaySoFar = 0;\\n\\tint i = 0;      // declaring globally creates MAGIC!!\\n\\n\\tfor(int k = 0; k < worker.length; k++){\\n\\t\\tint ability = worker[k];\\n\\n\\t\\twhile(i < pair.length && ability >= pair[i][0]){\\n\\t\\t\\tif(bestPaySoFar < pair[i][1])\\n\\t\\t\\t\\tbestPaySoFar = pair[i][1];\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\ttotalProfit += bestPaySoFar;\\n\\t}\\n\\n\\treturn totalProfit;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic int maxProfitAssignment(int[] diff, int[] profit, int[] worker) {`\\n\\n\\tint pair[][] = new int[diff.length][2];\\n\\tfor(int i = 0; i < diff.length; i++){\\n\\t\\tpair[i][0] = diff[i];\\n\\t\\tpair[i][1] = profit[i];\\n\\t}\\n\\t// sorting 2d array on basis of difficulty colmn\\n\\tArrays.sort(pair, new Comparator<int[]>() {\\n\\t\\t@Override\\n\\t\\tpublic int compare(int o1[], int o2[]){\\n\\t\\t\\treturn Integer.valueOf(o1[0]).compareTo(o2[0]);\\n\\t\\t}\\n\\t});\\n\\n\\tint totalProfit = 0;\\n\\n\\t//MAGIC begins HERE\\n\\tArrays.sort(worker);\\n\\tint bestPaySoFar = 0;\\n\\tint i = 0;      // declaring globally creates MAGIC!!\\n\\n\\tfor(int k = 0; k < worker.length; k++){\\n\\t\\tint ability = worker[k];\\n\\n\\t\\twhile(i < pair.length && ability >= pair[i][0]){\\n\\t\\t\\tif(bestPaySoFar < pair[i][1])\\n\\t\\t\\t\\tbestPaySoFar = pair[i][1];\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\ttotalProfit += bestPaySoFar;\\n\\t}\\n\\n\\treturn totalProfit;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126932,
                "title": "python-sort-based",
                "content": "The idea is to sort the profits and difficulty,  based on difficulty.\\nAlso the profits array can be modified to store the max_profits till that index.\\n\\nAfter that, its just a matter of finding the correct position for each worker in the difficulty array and adding the max_profit from the profit array.\\n\\n```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        max_profit = -math.inf\\n        profit = list(profit)\\n        for i in range(len(profit)):\\n            if max_profit < profit[i]:\\n                max_profit = profit[i]\\n            else:\\n                profit[i] = max_profit\\n        res = 0\\n        for w in worker:\\n            i = bisect_right(difficulty, w)\\n            if i != 0: res += profit[i-1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        max_profit = -math.inf\\n        profit = list(profit)\\n        for i in range(len(profit)):\\n            if max_profit < profit[i]:\\n                max_profit = profit[i]\\n            else:\\n                profit[i] = max_profit\\n        res = 0\\n        for w in worker:\\n            i = bisect_right(difficulty, w)\\n            if i != 0: res += profit[i-1]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 510197,
                "title": "c-very-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> diff_pro(100001,0);\\n        int res=0;\\n        for(int i=0;i<difficulty.size();i++){\\n            diff_pro[difficulty[i]]=max(diff_pro[difficulty[i]],profit[i]);\\n        }\\n        for(int i=1;i<100001;i++){\\n            diff_pro[i]=max(diff_pro[i],diff_pro[i-1]);\\n        }\\n        for(int i=0;i<worker.size();i++){\\n            res+=diff_pro[worker[i]];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> diff_pro(100001,0);\\n        int res=0;\\n        for(int i=0;i<difficulty.size();i++){\\n            diff_pro[difficulty[i]]=max(diff_pro[difficulty[i]],profit[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 126977,
                "title": "java-ac-sort-and-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int d;\\n        int p;\\n        public Pair(int d, int p) {\\n            this.d = d;\\n            this.p = p;\\n        }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair> list = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            list.add(new Pair(difficulty[i], profit[i]));\\n        }\\n\\n        // sort d from small to large and if d is the same, put smaller p in the front\\n        Collections.sort(list, (a, b) -> (a.d == b.d) ? a.p - b.p : a.d - b.d);\\n\\n        for (int i = 1; i < list.size(); i++) {\\n            // assign the max profit from 0 to current location\\n            list.get(i).p = Math.max(list.get(i).p, list.get(i - 1).p);\\n        }\\n\\n        int count = 0;\\n        for (int w : worker) {\\n            count += binarySearch(list, w);\\n        }\\n\\n        return count;\\n    }\\n\\n    // find the last number <= w in list.d, and return that index\\'s profit, if not available return 0.\\n    private int binarySearch(List<Pair> list, int w) {\\n        int start = 0;\\n        int end = list.size() - 1;\\n        while (start + 1 < end) {\\n            int mid = (end - start) / 2 + start;\\n            if (list.get(mid).d <= w) {\\n                start = mid;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n\\n        if (list.get(end).d <= w) {\\n            return list.get(end).p;\\n        }\\n        if (list.get(start).d <= w) {\\n            return list.get(start).p;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int d;\\n        int p;\\n        public Pair(int d, int p) {\\n            this.d = d;\\n            this.p = p;\\n        }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair> list = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            list.add(new Pair(difficulty[i], profit[i]));\\n        }\\n\\n        // sort d from small to large and if d is the same, put smaller p in the front\\n        Collections.sort(list, (a, b) -> (a.d == b.d) ? a.p - b.p : a.d - b.d);\\n\\n        for (int i = 1; i < list.size(); i++) {\\n            // assign the max profit from 0 to current location\\n            list.get(i).p = Math.max(list.get(i).p, list.get(i - 1).p);\\n        }\\n\\n        int count = 0;\\n        for (int w : worker) {\\n            count += binarySearch(list, w);\\n        }\\n\\n        return count;\\n    }\\n\\n    // find the last number <= w in list.d, and return that index\\'s profit, if not available return 0.\\n    private int binarySearch(List<Pair> list, int w) {\\n        int start = 0;\\n        int end = list.size() - 1;\\n        while (start + 1 < end) {\\n            int mid = (end - start) / 2 + start;\\n            if (list.get(mid).d <= w) {\\n                start = mid;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n\\n        if (list.get(end).d <= w) {\\n            return list.get(end).p;\\n        }\\n        if (list.get(start).d <= w) {\\n            return list.get(start).p;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861065,
                "title": "c-sorting-solution-o-wlogw-dlogd-dp-solution-o-w-d",
                "content": "**Sorting Solution: O(WLogW + DLogD)**\\n\\nRuntime: 172 ms, faster than 83.27% of C++ online submissions for Most Profit Assigning Work.\\nMemory Usage: 38 MB, less than 47.43% of C++ online submissions for Most Profit Assigning Work.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        // Make difficult and profit pair vector jobs\\n        vector<pair<int,int>>jobs;\\n        \\n        int d_size = difficulty.size();\\n        for(int i=0;i<d_size;i++)\\n            jobs.push_back(make_pair(difficulty[i],profit[i]));\\n        \\n        // sort jobs difficulty => O ( DLogD )\\n        sort(jobs.begin(),jobs.end());\\n        \\n        // sort workers array difficulty => O ( WLogW ) \\n        sort(worker.begin(),worker.end());\\n        \\n        int w_size = worker.size();\\n        int maxProfit = 0;\\n        int cprofit = 0;\\n        int cjob = 0;\\n        \\n        // Loop through workers array to find profit for each worker => O ( W + D )\\n        for(int i=0;i<w_size;i++)\\n        {\\n            // find max profit for worker[i] which is cprofit\\n            // As jobs and workers are sorted, cprofit is always max for any difficulty range\\n            while(cjob<d_size && jobs[cjob].first<=worker[i])\\n            {\\n                cprofit = max(cprofit,jobs[cjob].second);\\n                cjob++;\\n            }\\n            \\n            // update total max profit\\n            maxProfit+= cprofit;\\n        }\\n        \\n        return maxProfit;\\n    }\\n};\\n```\\n.\\n.\\n.\\n**DP Solution: O( W + D )**\\n\\nRuntime: 140 ms, faster than 97.43% of C++ online submissions for Most Profit Assigning Work.\\nMemory Usage: 35.7 MB, less than 97.24% of C++ online submissions for Most Profit Assigning Work.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int dp[100001] = {};\\n        int p_size = profit.size();\\n        \\n        for(int i=0;i<p_size;i++)\\n            dp[difficulty[i]] = max(profit[i],dp[difficulty[i]]);\\n        \\n        for(int i=1;i<=100000;i++)\\n            dp[i] = max(dp[i],dp[i-1]);\\n        \\n        int maxProfit = 0;\\n        int w_size = worker.size();\\n        \\n        for(int i=0;i<w_size;i++)\\n            maxProfit+=dp[worker[i]];\\n        \\n        return maxProfit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        // Make difficult and profit pair vector jobs\\n        vector<pair<int,int>>jobs;\\n        \\n        int d_size = difficulty.size();\\n        for(int i=0;i<d_size;i++)\\n            jobs.push_back(make_pair(difficulty[i],profit[i]));\\n        \\n        // sort jobs difficulty => O ( DLogD )\\n        sort(jobs.begin(),jobs.end());\\n        \\n        // sort workers array difficulty => O ( WLogW ) \\n        sort(worker.begin(),worker.end());\\n        \\n        int w_size = worker.size();\\n        int maxProfit = 0;\\n        int cprofit = 0;\\n        int cjob = 0;\\n        \\n        // Loop through workers array to find profit for each worker => O ( W + D )\\n        for(int i=0;i<w_size;i++)\\n        {\\n            // find max profit for worker[i] which is cprofit\\n            // As jobs and workers are sorted, cprofit is always max for any difficulty range\\n            while(cjob<d_size && jobs[cjob].first<=worker[i])\\n            {\\n                cprofit = max(cprofit,jobs[cjob].second);\\n                cjob++;\\n            }\\n            \\n            // update total max profit\\n            maxProfit+= cprofit;\\n        }\\n        \\n        return maxProfit;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int dp[100001] = {};\\n        int p_size = profit.size();\\n        \\n        for(int i=0;i<p_size;i++)\\n            dp[difficulty[i]] = max(profit[i],dp[difficulty[i]]);\\n        \\n        for(int i=1;i<=100000;i++)\\n            dp[i] = max(dp[i],dp[i-1]);\\n        \\n        int maxProfit = 0;\\n        int w_size = worker.size();\\n        \\n        for(int i=0;i<w_size;i++)\\n            maxProfit+=dp[worker[i]];\\n        \\n        return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126955,
                "title": "extremely-simple-using-priority-queue",
                "content": "Sort the class Work in ascending order of difficulty. If difficulty is the same, sort according to descending order of profit. Sort the worker as per ascending order of their ability. \\n\\nNow you just need to match the work with the worker and store the max profit seen until now and add it to the total profit. \\n\\n```\\npublic class Solution {\\n    class Work{\\n        int d; \\n        int p; \\n        Work(int d, int p){\\n            this.d = d; \\n            this.p = p; \\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<Work> pq = new PriorityQueue<Work>((a, b)->(a.d==b.d)?b.p-a.p:a.d-b.d);\\n        for(int i = 0; i < profit.length; ++i){\\n            pq.offer(new Work(difficulty[i], profit[i])); \\n        }\\n        Arrays.sort(worker); \\n        int i = 0; \\n        int cprofit = 0; \\n        int max = 0; \\n        while(!pq.isEmpty() && i < worker.length){\\n            Work w = pq.poll(); \\n            if(w.d <= worker[i]){\\n                max = Math.max(max, w.p); \\n            }else{\\n                i++; \\n                cprofit+=max; \\n                pq.offer(w); \\n            }\\n        }\\n        while(i < worker.length){\\n            cprofit+=max; \\n            i++; \\n        }\\n        return cprofit; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    class Work{\\n        int d; \\n        int p; \\n        Work(int d, int p){\\n            this.d = d; \\n            this.p = p; \\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<Work> pq = new PriorityQueue<Work>((a, b)->(a.d==b.d)?b.p-a.p:a.d-b.d);\\n        for(int i = 0; i < profit.length; ++i){\\n            pq.offer(new Work(difficulty[i], profit[i])); \\n        }\\n        Arrays.sort(worker); \\n        int i = 0; \\n        int cprofit = 0; \\n        int max = 0; \\n        while(!pq.isEmpty() && i < worker.length){\\n            Work w = pq.poll(); \\n            if(w.d <= worker[i]){\\n                max = Math.max(max, w.p); \\n            }else{\\n                i++; \\n                cprofit+=max; \\n                pq.offer(w); \\n            }\\n        }\\n        while(i < worker.length){\\n            cprofit+=max; \\n            i++; \\n        }\\n        return cprofit; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471974,
                "title": "much-intuitive-binary-search-greedy-simple-and-easy-to-understand-c-solution",
                "content": "# Intuition\\nWe Can Sort The Difficulty - Profit Pair And Use Binary Search For Assigning Jobs TO Workers\\n# Approach\\nWhy Sorting Based ON Difficulty but Not on Profit, Because In The Given Problem Workers Difficulty Level  Capability Is Provided Based On these Data We Should Assign The Jobs To Workers.\\nNow After Sorting Difficulty And Profit Pair , we Should Observe ONE Important Point Here\\nConsider The Example\\n Difficulty : [68,35,52,47,86]\\n Profit:[67,17,1,81,3]\\nWorkers :[92,10,85,84,82]\\nIf We Sort Difficulty And Profit Pair We Get \\nDifficulty :[35,47,52,68,86]\\nProfit : [17,81,1,67,3]\\n**Important Observation\\nIf A Worker Can Do A Job At difficulty Level X then he can do all Jobs With difficulty level less than or Equal to X**\\nNow if X=52 , What is The Maximum Profit ,we Can Get it is 81 .\\nAt difficulty level 81 we have maxprofit 81.\\nSo we should Update The Profit Values With Maximum Values From Previous Ones \\nie; \\nat i=1 profit[i]=max(profit[i],profit[i-1])=(81,17)=81\\n    at i=2 profit[i]=max(profit[i],profit[i-1])=(1,81)=81\\n    at i=3 profit[i]=max(profit[i],profit[i-1])=(67,81)=81\\n    at i=4 profit[i]=max(profit[i],profit[i-1])=(3,81)=81\\nThe Profit Array Becomes [17,81,81,81,81]\\nNow We Can Apply Binary Search (Upper Bound) For Every Worker Individually And Assign Jobs Finally Get The Max Profit.\\n\\n**PLEASE UPVOTE IF UNDERSTAND THE SOLUTION**\\n\\n\\n# Complexity\\n- Time complexity:\\nO(NLOGN+MLOGN)\\n- Space complexity:\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>arr;\\n         int n=difficulty.size();\\n     \\n         for(int i=0;i<n;i++)\\n         {\\n             arr.push_back({difficulty[i],profit[i]});\\n         }       \\n           sort(arr.begin(),arr.end());\\n\\n             for(int i=1;i<n;i++) arr[i].second=max(arr[i].second,arr[i-1].second);\\n         long long maxprofit=0;\\n         int low,high,mid,temprofit;\\n         for(auto i:worker)\\n         {\\n             low=0,high=n-1,temprofit=0;\\n             while(low<=high)\\n             {\\n                 mid=(low+high)/2;\\n                 if(arr[mid].first<=i)        low=mid+1;\\n                 else high=mid-1;\\n             }\\n          if(high>=0)   maxprofit=(long long)maxprofit+arr[high].second;\\n         }\\n         return maxprofit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>arr;\\n         int n=difficulty.size();\\n     \\n         for(int i=0;i<n;i++)\\n         {\\n             arr.push_back({difficulty[i],profit[i]});\\n         }       \\n           sort(arr.begin(),arr.end());\\n\\n             for(int i=1;i<n;i++) arr[i].second=max(arr[i].second,arr[i-1].second);\\n         long long maxprofit=0;\\n         int low,high,mid,temprofit;\\n         for(auto i:worker)\\n         {\\n             low=0,high=n-1,temprofit=0;\\n             while(low<=high)\\n             {\\n                 mid=(low+high)/2;\\n                 if(arr[mid].first<=i)        low=mid+1;\\n                 else high=mid-1;\\n             }\\n          if(high>=0)   maxprofit=(long long)maxprofit+arr[high].second;\\n         }\\n         return maxprofit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222137,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++){\\n            v.push_back({d[i],p[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int n=d.size();\\n        vector<int>dp(n+1);\\n        dp[0]=v[0].second;\\n        for(int i=1;i<n;i++){\\n            dp[i]=max(dp[i-1],v[i].second);\\n        }\\n        sort(d.begin(),d.end());\\n        int s=0;\\n        for(int i=0;i<w.size();i++){\\n           int in=upper_bound(d.begin(),d.end(),w[i])-d.begin();\\n           if(in!=0){\\n               in--;\\n               s+=dp[in];\\n           }\\n        }\\n        return s;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/44d7abb5-b520-4d81-b589-567c12aa2091_1677164915.7858884.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++){\\n            v.push_back({d[i],p[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int n=d.size();\\n        vector<int>dp(n+1);\\n        dp[0]=v[0].second;\\n        for(int i=1;i<n;i++){\\n            dp[i]=max(dp[i-1],v[i].second);\\n        }\\n        sort(d.begin(),d.end());\\n        int s=0;\\n        for(int i=0;i<w.size();i++){\\n           int in=upper_bound(d.begin(),d.end(),w[i])-d.begin();\\n           if(in!=0){\\n               in--;\\n               s+=dp[in];\\n           }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603913,
                "title": "python3-solved-using-binary-search-w-sorting-o-n-m-logn-runtime-solution",
                "content": "```\\nclass Solution:\\n    #Time-Complexity: O(n + nlogn + n + mlog(n)) -> O((n+m) *logn)\\n    #Space-Complexity: O(n)\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        #Approach: First of all, linearly traverse each and every corresponding index\\n        #position of first two input arrays: difficulty and profit to group each\\n        #item by 1-d array and put it in separate 2-d array. Then, sort the 2-d array\\n        #by increasing difficulty of the job! Then, for each worker, perform binary\\n        #search and consistently update the max profit the current worker can work and\\n        #earn! Add this value to answer variable, which is cumulative for all workers!\\n        #this will be the result returned at the end!\\n        arr = []\\n        for i in range(len(difficulty)):\\n            arr.append([difficulty[i], profit[i]])\\n        #sort by difficulty!\\n        arr.sort(key = lambda x: x[0])\\n        #then, I need to update the maximum profit up to each and every item!\\n        maximum = float(-inf)\\n        for j in range(len(arr)):\\n            maximum = max(maximum, arr[j][1])\\n            arr[j][1] = maximum\\n        ans = 0\\n        #iterate through each and every worker!\\n        for w in worker:\\n            bestProfit = 0\\n            #define search space to perform binary search!\\n            L, R = 0, len(arr) - 1\\n            #as long as search space has at least one element to consider or one job,\\n            #continue iterations of binary search!\\n            while L <= R:\\n                mid = (L + R) // 2\\n                mid_e = arr[mid]\\n                #check if current job has difficulty that is manageable!\\n                if(mid_e[0] <= w):\\n                    bestProfit = max(bestProfit, mid_e[1])\\n                    #we still need to search right and try higher difficulty\\n                    #jobs that might yield higher profit!\\n                    L = mid + 1\\n                    continue\\n                else:\\n                    R = mid - 1\\n                    continue\\n            #once we break from while loop and end binary search, we should have\\n            #found bestProfit for current worker performing task that is manageable!\\n            ans += bestProfit\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    #Time-Complexity: O(n + nlogn + n + mlog(n)) -> O((n+m) *logn)\\n    #Space-Complexity: O(n)\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        #Approach: First of all, linearly traverse each and every corresponding index\\n        #position of first two input arrays: difficulty and profit to group each\\n        #item by 1-d array and put it in separate 2-d array. Then, sort the 2-d array\\n        #by increasing difficulty of the job! Then, for each worker, perform binary\\n        #search and consistently update the max profit the current worker can work and\\n        #earn! Add this value to answer variable, which is cumulative for all workers!\\n        #this will be the result returned at the end!\\n        arr = []\\n        for i in range(len(difficulty)):\\n            arr.append([difficulty[i], profit[i]])\\n        #sort by difficulty!\\n        arr.sort(key = lambda x: x[0])\\n        #then, I need to update the maximum profit up to each and every item!\\n        maximum = float(-inf)\\n        for j in range(len(arr)):\\n            maximum = max(maximum, arr[j][1])\\n            arr[j][1] = maximum\\n        ans = 0\\n        #iterate through each and every worker!\\n        for w in worker:\\n            bestProfit = 0\\n            #define search space to perform binary search!\\n            L, R = 0, len(arr) - 1\\n            #as long as search space has at least one element to consider or one job,\\n            #continue iterations of binary search!\\n            while L <= R:\\n                mid = (L + R) // 2\\n                mid_e = arr[mid]\\n                #check if current job has difficulty that is manageable!\\n                if(mid_e[0] <= w):\\n                    bestProfit = max(bestProfit, mid_e[1])\\n                    #we still need to search right and try higher difficulty\\n                    #jobs that might yield higher profit!\\n                    L = mid + 1\\n                    continue\\n                else:\\n                    R = mid - 1\\n                    continue\\n            #once we break from while loop and end binary search, we should have\\n            #found bestProfit for current worker performing task that is manageable!\\n            ans += bestProfit\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1228765,
                "title": "easiest-c-soln-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pr, vector<int>& wo) {\\n        int n=dif.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({dif[i],pr[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxpro=v[0].second;\\n        for(int i=1;i<v.size();i++){\\n            maxpro=max(maxpro,v[i].second);\\n            v[i].second=maxpro;\\n        }\\n        int ans=0;\\n        for(auto &w:wo){\\n            int tmp=0;\\n            int i=0,j=n-1;\\n            while(i<=j){\\n                int m=(i+j)>>1;\\n                if(v[m].first<=w){\\n                    tmp=max(tmp,v[m].second);\\n                    i=m+1;\\n                }\\n                else j=m-1;\\n            }\\n            ans+=tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pr, vector<int>& wo) {\\n        int n=dif.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({dif[i],pr[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxpro=v[0].second;\\n        for(int i=1;i<v.size();i++){\\n            maxpro=max(maxpro,v[i].second);\\n            v[i].second=maxpro;\\n        }\\n        int ans=0;\\n        for(auto &w:wo){\\n            int tmp=0;\\n            int i=0,j=n-1;\\n            while(i<=j){\\n                int m=(i+j)>>1;\\n                if(v[m].first<=w){\\n                    tmp=max(tmp,v[m].second);\\n                    i=m+1;\\n                }\\n                else j=m-1;\\n            }\\n            ans+=tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055712,
                "title": "beat-99-71-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        int mp[100001] = {0}, res = 0;\\n        for(int i = 0; i < d.size(); i++)\\n            mp[d[i]] = max(mp[d[i]], p[i]);\\n        for(int i = 1; i < 100001; i++)\\n            mp[i] = max(mp[i], mp[i - 1]);\\n        for(auto n : w)\\n            res += mp[n];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        int mp[100001] = {0}, res = 0;\\n        for(int i = 0; i < d.size(); i++)\\n            mp[d[i]] = max(mp[d[i]], p[i]);\\n        for(int i = 1; i < 100001; i++)\\n            mp[i] = max(mp[i], mp[i - 1]);\\n        for(auto n : w)\\n            res += mp[n];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388263,
                "title": "java-hashmap-two-pointer-sort",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        if (difficulty == null || profit == null || worker == null) {\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        Map<Integer, Integer> dict = new HashMap<>();\\n        for (int i = 0; i < difficulty.length; i++) {\\n            // duplicate difficulty may have different profits\\n            dict.put(difficulty[i], Math.max(dict.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        Arrays.sort(difficulty);\\n        Arrays.sort(worker);\\n        \\n        int j = 0;\\n        int max = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            while (j < difficulty.length && worker[i] >= difficulty[j]) {\\n                max = Math.max(max, dict.get(difficulty[j]));\\n                j++;\\n            }\\n            res += max;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        if (difficulty == null || profit == null || worker == null) {\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        Map<Integer, Integer> dict = new HashMap<>();\\n        for (int i = 0; i < difficulty.length; i++) {\\n            // duplicate difficulty may have different profits\\n            dict.put(difficulty[i], Math.max(dict.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        Arrays.sort(difficulty);\\n        Arrays.sort(worker);\\n        \\n        int j = 0;\\n        int max = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            while (j < difficulty.length && worker[i] >= difficulty[j]) {\\n                max = Math.max(max, dict.get(difficulty[j]));\\n                j++;\\n            }\\n            res += max;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612171,
                "title": "greedy-c-simple-approach",
                "content": "# **if it Helps You, Please Upvote Me......!**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nApproach is simple, just try to understand the following conditions:-\\n\\n**worker 5 can get all the jobs with difficulty 5,4,3,2,1  but in all of the Jobs worker will choose the job with Maximum Profit.**\\n\\nby using this approach we can easily solve this problem let\\'s take an Example:-\\n**Difficulty: [1,5,4] ,Profit: [5,3,7] ,  worker [4,6]**\\n\\n**for 1st worker(4):- this worker can get the job 1,4 but he will choose the job that has maximum profit( that is 7)**\\n\\n**for 2nd worker(6):- this worker can get all the job 1,4,5 but he will choose the job that has maximum profit( that is 7)**\\n\\n**in this way the answer will be 7+7 = 14**\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/2729c740-f688-4f96-980e-3cb24d75cdfa_1686205157.029114.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440958,
                "title": "binary-search-approach-c-intuition-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObviously, for ith worker we\\'ll try to maximize the profit. So whatever tasks that can be done by this worker we\\'ll choose the max profit.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf a worker can do tasks with difficulty i then he can do every task having difficulty <=i so if I somehow know the max profit among all such tasks that\\'ll be the ans for that worker. This leads us to the binary search approach. Suppose I sort the tasks wrt to their difficulty and I know the max profit I can get from tasks having <=i diffculty that\\'ll be the answer. Make a vector pair of {difficulty,profit}\\ndo binary search on difficulty and take maximum of profit till that index which can be maintained by prefix maximum;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n + mlog(n));\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& profit, vector<int>& worker) {\\n        \\n        vector<pair<int,int>> a;\\n        int n = dif.size();\\n        for(int i = 0; i < n; i++) {\\n            a.push_back( { dif[i], profit[i] } );\\n        }\\n        \\n        sort(a.begin(), a.end());\\n        vector<int> preMax(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            preMax[i] = (i-1>=0) ? max(preMax[i-1],a[i].second) : a[i].second;\\n\\n        }\\n        \\n        int ans = 0;\\n        int m = worker.size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            pair<int,int> se = {worker[i],1e9};\\n            int ind = upper_bound(a.begin(),a.end(),se) - a.begin();\\n            if(ind==0) continue;\\n            --ind;\\n            \\n            ans += preMax[ind];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& profit, vector<int>& worker) {\\n        \\n        vector<pair<int,int>> a;\\n        int n = dif.size();\\n        for(int i = 0; i < n; i++) {\\n            a.push_back( { dif[i], profit[i] } );\\n        }\\n        \\n        sort(a.begin(), a.end());\\n        vector<int> preMax(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            preMax[i] = (i-1>=0) ? max(preMax[i-1],a[i].second) : a[i].second;\\n\\n        }\\n        \\n        int ans = 0;\\n        int m = worker.size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            pair<int,int> se = {worker[i],1e9};\\n            int ind = upper_bound(a.begin(),a.end(),se) - a.begin();\\n            if(ind==0) continue;\\n            --ind;\\n            \\n            ans += preMax[ind];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371795,
                "title": "c-easy-to-understand-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. make **vector{profit,difficulty}** and sort it \\n2. sort worker array \\n3. keep index at last of sorted vector{profit,difficulty}\\n4. **start from last of sorted worker array** and check for worker[i]>=difficulty of sorted array{profit,difficulty} \\n4,1. If not greater, do index-- till greater found and add that profit to final ans **because profits beyond that cannot be acquired by other workers futher in iteration** \\n4,2. Else add vector{profit,difficulty}[index] to finalAns\\n5. Return final Answer\\n \\n\\n\\n# Complexity\\nlength of difficulty array=n\\nlength of worker array=m\\n- Time complexity:O(nlogn+mlogm+n+m) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        int n=difficulty.size();\\n        vector<pair<int,int>> nums;\\n\\n        for(int i=0;i<n;i++){\\n            nums.push_back({profit[i],difficulty[i]});\\n        }\\n        sort(nums.begin(),nums.end());\\n        int index=n-1;\\n        int ans=0;\\n        sort(worker.begin(),worker.end());\\n        \\n        for(int i=worker.size()-1;i>=0;i--){\\n            while(index>=0 && nums[index].second>worker[i]) index--;\\n            if(index==-1) continue;\\n            ans+=nums[index].first;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        int n=difficulty.size();\\n        vector<pair<int,int>> nums;\\n\\n        for(int i=0;i<n;i++){\\n            nums.push_back({profit[i],difficulty[i]});\\n        }\\n        sort(nums.begin(),nums.end());\\n        int index=n-1;\\n        int ans=0;\\n        sort(worker.begin(),worker.end());\\n        \\n        for(int i=worker.size()-1;i>=0;i--){\\n            while(index>=0 && nums[index].second>worker[i]) index--;\\n            if(index==-1) continue;\\n            ans+=nums[index].first;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242537,
                "title": "for-rust-geeks",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n) + mlog(m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m + n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn max_profit_assignment(difficulty: Vec<i32>, profit: Vec<i32>, mut worker: Vec<i32>) -> i32 {\\n        let (n, m) = (profit.len(), worker.len());\\n        worker.sort_unstable();\\n\\n        let mut pos = (0..n).collect::<Vec<usize>>();\\n        pos.sort_unstable_by(|&a, &b| difficulty[a].cmp(&difficulty[b]));\\n\\n        let (mut i, mut j) = (0, 0);\\n        let mut ans = 0;\\n        let mut max = 0;\\n\\n        while j < m {\\n            while i < n && difficulty[pos[i]] <= worker[j] {\\n                max = i32::max(max, profit[pos[i]]);\\n                i += 1;\\n            }\\n\\n            ans += max;\\n            j += 1;\\n        }\\n\\n        ans   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_profit_assignment(difficulty: Vec<i32>, profit: Vec<i32>, mut worker: Vec<i32>) -> i32 {\\n        let (n, m) = (profit.len(), worker.len());\\n        worker.sort_unstable();\\n\\n        let mut pos = (0..n).collect::<Vec<usize>>();\\n        pos.sort_unstable_by(|&a, &b| difficulty[a].cmp(&difficulty[b]));\\n\\n        let (mut i, mut j) = (0, 0);\\n        let mut ans = 0;\\n        let mut max = 0;\\n\\n        while j < m {\\n            while i < n && difficulty[pos[i]] <= worker[j] {\\n                max = i32::max(max, profit[pos[i]]);\\n                i += 1;\\n            }\\n\\n            ans += max;\\n            j += 1;\\n        }\\n\\n        ans   \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141689,
                "title": "beats-100-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085557,
                "title": "simple-solution-using-heap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<vector<int>>p;\\n        priority_queue<int>q(worker.begin(),worker.end());\\n\\n        for(int i=0;i<profit.size();i++){\\n            p.push({profit[i],difficulty[i]});\\n        }\\n        int val=0;\\n        while(!p.empty() && !q.empty()){\\n            if(p.top()[1]>q.top())p.pop();\\n            else{\\n                val+=p.top()[0];\\n                q.pop();\\n            }\\n        }\\n        return val;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<vector<int>>p;\\n        priority_queue<int>q(worker.begin(),worker.end());\\n\\n        for(int i=0;i<profit.size();i++){\\n            p.push({profit[i],difficulty[i]});\\n        }\\n        int val=0;\\n        while(!p.empty() && !q.empty()){\\n            if(p.top()[1]>q.top())p.pop();\\n            else{\\n                val+=p.top()[0];\\n                q.pop();\\n            }\\n        }\\n        return val;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857961,
                "title": "python-sorting-bisect",
                "content": "# Intuition\\nThe main idea is to get maximum profit for current worker ability.\\nFirst of all we need to mix together difficulty and profit, sort them and initialize dp variable with maximum value with at least current difficulty. \\n\\n# Complexity\\n- Time complexity:\\nO(N*LogN) for sorting and bisect\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nimport bisect\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        difficultyProfit = list(zip(difficulty, profit))\\n        difficultyProfit.sort()\\n\\n        difficulty, profit = zip(*difficultyProfit)\\n\\n        n = len(profit)\\n        dp = [0] * n\\n        for i in range(n):\\n            dp[i] = max(profit[i], dp[i - 1])\\n\\n        result = 0\\n        for w in worker:\\n            index = bisect.bisect_right(difficulty, w) - 1\\n            if index < 0:\\n                continue\\n            \\n            result += dp[index]\\n        \\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        difficultyProfit = list(zip(difficulty, profit))\\n        difficultyProfit.sort()\\n\\n        difficulty, profit = zip(*difficultyProfit)\\n\\n        n = len(profit)\\n        dp = [0] * n\\n        for i in range(n):\\n            dp[i] = max(profit[i], dp[i - 1])\\n\\n        result = 0\\n        for w in worker:\\n            index = bisect.bisect_right(difficulty, w) - 1\\n            if index < 0:\\n                continue\\n            \\n            result += dp[index]\\n        \\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397464,
                "title": "o-nlogn-lower-bound-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        unordered_map<int,int>mp;  \\n        int m=0,ans=0;\\n        vector<vector<int>>v;\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            mp[v[i][0]]=m=max(m,v[i][1]);\\n        \\n        sort(difficulty.begin(),difficulty.end());\\n        \\n        for(int a:worker){\\n            int j=lower_bound(difficulty.begin(),difficulty.end(),a)-difficulty.begin();\\n            \\n            if(difficulty[j]>a || j==difficulty.size())\\n                j--;\\n            if(j>=0)\\n                ans+=mp[difficulty[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        unordered_map<int,int>mp;  \\n        int m=0,ans=0;\\n        vector<vector<int>>v;\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            mp[v[i][0]]=m=max(m,v[i][1]);\\n        \\n        sort(difficulty.begin(),difficulty.end());\\n        \\n        for(int a:worker){\\n            int j=lower_bound(difficulty.begin(),difficulty.end(),a)-difficulty.begin();\\n            \\n            if(difficulty[j]>a || j==difficulty.size())\\n                j--;\\n            if(j>=0)\\n                ans+=mp[difficulty[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168333,
                "title": "java-sol-beats-100-submission",
                "content": "``` \\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max1 = 0, max2 = 0, maxDp = 0;\\n        int maxProfit = 0;\\n        for (int i = 0 ; i < worker.length ; i++) {\\n           max1 = Math.max(worker[i], max1); \\n        }\\n        \\n        for (int j = 0 ; j < difficulty.length ; j++) {\\n           max2 = Math.max(difficulty[j], max2); \\n        }\\n        \\n        maxDp = Math.max(max1 + 1, max2 +1) ;\\n        \\n        int[] dp = new int[maxDp];\\n        \\n        for (int i = 0 ; i < difficulty.length ; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        \\n        for (int i = 1 ; i < dp.length ; i++) {\\n            dp[i] = Math.max(dp[i], dp[i-1]);\\n        }\\n        \\n        for (int work: worker) {\\n            maxProfit += dp[work];\\n        }\\n        \\n        return maxProfit;\\n    }",
                "solutionTags": [],
                "code": "``` \\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max1 = 0, max2 = 0, maxDp = 0;\\n        int maxProfit = 0;\\n        for (int i = 0 ; i < worker.length ; i++) {\\n           max1 = Math.max(worker[i], max1); \\n        }\\n        \\n        for (int j = 0 ; j < difficulty.length ; j++) {\\n           max2 = Math.max(difficulty[j], max2); \\n        }\\n        \\n        maxDp = Math.max(max1 + 1, max2 +1) ;\\n        \\n        int[] dp = new int[maxDp];\\n        \\n        for (int i = 0 ; i < difficulty.length ; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        \\n        for (int i = 1 ; i < dp.length ; i++) {\\n            dp[i] = Math.max(dp[i], dp[i-1]);\\n        }\\n        \\n        for (int work: worker) {\\n            maxProfit += dp[work];\\n        }\\n        \\n        return maxProfit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1156464,
                "title": "c-faster-than-94-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> vc;\\n        for(int i = 0; i < difficulty.size(); i++) vc.push_back(make_pair(difficulty[i], profit[i]));   \\n        sort(vc.begin(), vc.end());\\n        for(int i = 1; i < vc.size(); i++) vc[i].second=max(vc[i].second, vc[i-1].second);\\n         \\n        sort(worker.begin(), worker.end());\\n        int  x = 0, ans=0;\\n        for(int i = 0; i < worker.size(); i++){\\n            while(vc[x].first<=worker[i] && vc.size()>x){\\n                x++;\\n            }\\n            ans+=x==0?0:vc[x-1].second;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> vc;\\n        for(int i = 0; i < difficulty.size(); i++) vc.push_back(make_pair(difficulty[i], profit[i]));   \\n        sort(vc.begin(), vc.end());\\n        for(int i = 1; i < vc.size(); i++) vc[i].second=max(vc[i].second, vc[i-1].second);\\n         \\n        sort(worker.begin(), worker.end());\\n        int  x = 0, ans=0;\\n        for(int i = 0; i < worker.size(); i++){\\n            while(vc[x].first<=worker[i] && vc.size()>x){\\n                x++;\\n            }\\n            ans+=x==0?0:vc[x-1].second;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769072,
                "title": "python3-solution-using-dp-o-max-n-max-difficulty",
                "content": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        n=len(profit)\\n        maxm=max(difficulty)\\n        dp=[0]*(1+maxm)\\n        for i in range(n):\\n            dp[difficulty[i]]=max(dp[difficulty[i]],profit[i])\\n        for i in range(1,maxm+1):\\n            dp[i]=max(dp[i],dp[i-1])\\n        res=0\\n\\n        for x in worker:\\n            if x>maxm:\\n                res+=dp[maxm]\\n            else:\\n                res+=dp[x]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        n=len(profit)\\n        maxm=max(difficulty)\\n        dp=[0]*(1+maxm)\\n        for i in range(n):\\n            dp[difficulty[i]]=max(dp[difficulty[i]],profit[i])\\n        for i in range(1,maxm+1):\\n            dp[i]=max(dp[i],dp[i-1])\\n        res=0\\n\\n        for x in worker:\\n            if x>maxm:\\n                res+=dp[maxm]\\n            else:\\n                res+=dp[x]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227554,
                "title": "js-solution-beats-100-with-156-ms-where-existing-solution-takes-at-least-1088ms",
                "content": "```js\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const meta = profit.map((p, i) => ({ profit: p, difficulty: difficulty[i] })).sort((m1, m2) => m2.profit - m1.profit);\\n    const sortedWorker = worker.slice().sort((a, b) => b - a);\\n    let result = 0;\\n    let j = 0;\\n    for (let i = 0; i < meta.length; i++) {\\n        while (sortedWorker[j] >= meta[i].difficulty) {\\n            result += meta[i].profit;\\n            j++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const meta = profit.map((p, i) => ({ profit: p, difficulty: difficulty[i] })).sort((m1, m2) => m2.profit - m1.profit);\\n    const sortedWorker = worker.slice().sort((a, b) => b - a);\\n    let result = 0;\\n    let j = 0;\\n    for (let i = 0; i < meta.length; i++) {\\n        while (sortedWorker[j] >= meta[i].difficulty) {\\n            result += meta[i].profit;\\n            j++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659167,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\nThe workers have to perform the task with the maximum profit under the given difficulty. So 2 cases arise:- either difficulty of the task is greater than the worker\\'s ability or it is less than or equal to worker\\'s ability.The worker should always perform the most profitable task under the given difficulty range.\\n# Approach\\nFirst the worker\\'s ability is sorted in ascending order.The `difficulty` and `profit` arrays are directly related and difficulty should be in an ascending order. So a pair is formed and the maximum profit that could be achieved upto that difficulty level is calculated.Now iteration is performed using 2 pointers. If the `worker` array\\'s pointer reaches end first, it means all workers have been traversed. Otherwise some workers remain for whom maximum profitable task was being searched. But now we have to assign all of them the maximum profitable task we have obtained so far. In the end we return the result. \\n\\n# Complexity\\n- Time complexity:\\nO(M+N) `N`:- size of difficulty array, `M` :- size of worker array\\n- Space complexity:\\nO(M+N) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int profits = 0;\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> v;\\n        for(int i = 0; i < n; i++){\\n            v.push_back({difficulty[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxm = INT_MIN,prev = 0;\\n        auto it = v.begin();\\n        int j = 0;\\n        while(it != v.end() && j < m){\\n            maxm = max(maxm,it->second);\\n            if(it->first <= worker[j]){\\n                it++;\\n                prev = maxm;\\n            }\\n            else{\\n                profits+=prev;\\n                j++;\\n            }\\n        }\\n        while(j != m){\\n            profits+= prev;\\n            j++;\\n        }\\n        return profits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int profits = 0;\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> v;\\n        for(int i = 0; i < n; i++){\\n            v.push_back({difficulty[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxm = INT_MIN,prev = 0;\\n        auto it = v.begin();\\n        int j = 0;\\n        while(it != v.end() && j < m){\\n            maxm = max(maxm,it->second);\\n            if(it->first <= worker[j]){\\n                it++;\\n                prev = maxm;\\n            }\\n            else{\\n                profits+=prev;\\n                j++;\\n            }\\n        }\\n        while(j != m){\\n            profits+= prev;\\n            j++;\\n        }\\n        return profits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551451,
                "title": "all-kind-of-solution-with-explanation",
                "content": "### All These Solutions except the very last one are inspired by @lee215 and @votrubac\\n## Solution 1\\n```\\n1.Create a vector where each element is a pair comprised difficulty[i] and profit[i] for each i.\\n2.Sort it and it will be sorted by difficulty[i] by default.\\n3.Also sort the \\'worker\\', now for each worker[i] traverse \\'jobs\\' till jobs[j].first <= worker[i].\\n   We don\\'t need to traverse \\'j always from the beginning as \\n   \"one job can be completed multiple times\" means \\n   \\n   10 20 10 5   - profit     \\n   4  5  7  9   - difficulty \\n   2  4  8  10  - worker\\n\\n   for worker[2] = 8, I can do difficulty : 4,5,7 but 5 pay me highest(20) so I\\'ll take 5\\n   because I can do any job which difficulty level <= my difficulty level.\\n   So using max() we can easily find high paid level as we have \"sorted jobs\". \\n   \\n   Of course in pair difficult[i] is the first one cause we need to compare worker[i] with \\n   difficulty[i] and both denotes \\'difficulty level\\'.\\n```\\n\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> jobs;\\n        for(int i=0; i<difficulty.size(); i++)\\n            jobs.push_back({difficulty[i],profit[i]});\\n\\n        sort(begin(jobs),end(jobs));\\n        sort(begin(worker),end(worker));\\n\\n        int j = 0, best = 0, sum = 0;\\n        for(int & it : worker)\\n        {\\n            while(j<jobs.size() && jobs[j].first<=it)\\n                best = max(best, jobs[j].second), j++;\\n            sum += best;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit))\\n        j = best = ans = 0\\n        for ability in sorted(worker):\\n            while j < len(jobs) and jobs[j][0] <= ability:\\n                best = max(best, jobs[j][1])\\n                j += 1\\n            ans += best\\n        \\n        return ans\\n```\\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(n)\\n```\\n## Solution 2 :\\n```\\nmax(m[difficulty[i]], profit[i]) had done because there can be duplicate in \\'difficulty\\'.\\n\\nDifficulty      Profit                                     Profit\\n----------     --------         ___________               --------\\n    4             20           |            |                20\\n    6             10    ---->  |    Second  |  ----->        20\\n    8             30           |    For     |                30\\n    10            20           |    Loop    |                30\\n\\nreturn accumulate(begin(worker), end(worker), 0, [m](int sum, int value)...\\n                                              |\\n              sum = -------------------------\\n              and value = each value in worker\\n          \\n              1 2 4 5 8 9\\n              upper_bound(5) = 8 \\n              lower_bound(5) = 5 but\\n              1 2 4 8 9\\n              lower_bound(5) = 8. Upper_bound = 1 variation where lower_bound = 2 variation.\\nThat\\'s why upper_bound chosen. prev(upper_bound(iterator)) is the iterator we need here always.\\n```\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        map<int, int> m;\\n        for(int i=0; i<difficulty.size(); i++)\\n            m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n        \\n        for(auto it = next(m.begin()); it!= m.end(); it++)\\n            it->second = max(prev(it)->second, it->second);\\n        \\n        return accumulate(begin(worker), end(worker), 0, [m](int sum, int value){ return sum + prev(m.upper_bound(value))->second; });\\n    }\\n};\\n```\\n```\\nTime  Complexity : O(nlogn) as we took map.\\nSpace Complexity : O(n)\\n```\\n## Solution 3 :\\n```\\nHere difficulty[i] = index and profit[i] = value of the \" counting sort \\'jobs\\' \"\\n\\ndifficulty = [2,4,6,8,10], profit = [20,10,15,40,30], worker = [4,5,6,7]\\n\\n0  0  20  0   10  0   15  0   40  0   50 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n                  \\n                    * After the second for loop *\\n                     \\n0  0  20  20  20  20  20  20  40  40  40 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n\\nIn the map solution when we \"accumulate\"d for each worker[i] say for 5 we had to go for \\nprev(upper_bound) = prev(5) =  4 here, but here in counting sort we have 5 to access directly, \\n\\n                          \\'   20 (profit)\\n                            5  (difficulty)   \\'\\n\\nwe don\\'t need any upper bound or traversing the array to get the value. So this solution is fast.\\n```\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int jobs[100001] = {0};\\n        for(int i=0; i<difficulty.size(); i++)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<100001; i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\\n```\\nYou can also optimize it by below. We only need the maximum element of \\'worker\\'.\\n                2 4 6 8 9 10 (difficulty)\\n                2 3 5 7      (worker)\\nas we need till \\'7\\', so we don\\'t care values > 7 in \\'difficulty\\'. \\nMake sure the value in \\'difficulty\\' is <= the maximum in \\'worker\\'.\\n```\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int m = *max_element(begin(worker), end(worker)) + 1;\\n        vector<int> jobs(m, 0);\\n        for(int i=0; i<difficulty.size(); i++)\\n            if(difficulty[i] < m)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<m ;i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\\n```\\nTime  Complexity : O(n + m)\\nSpace Complexity : O(m)\\n```\\n## If the post was helpful an upvote will really make me happy:)",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\n1.Create a vector where each element is a pair comprised difficulty[i] and profit[i] for each i.\\n2.Sort it and it will be sorted by difficulty[i] by default.\\n3.Also sort the \\'worker\\', now for each worker[i] traverse \\'jobs\\' till jobs[j].first <= worker[i].\\n   We don\\'t need to traverse \\'j always from the beginning as \\n   \"one job can be completed multiple times\" means \\n   \\n   10 20 10 5   - profit     \\n   4  5  7  9   - difficulty \\n   2  4  8  10  - worker\\n\\n   for worker[2] = 8, I can do difficulty : 4,5,7 but 5 pay me highest(20) so I\\'ll take 5\\n   because I can do any job which difficulty level <= my difficulty level.\\n   So using max() we can easily find high paid level as we have \"sorted jobs\". \\n   \\n   Of course in pair difficult[i] is the first one cause we need to compare worker[i] with \\n   difficulty[i] and both denotes \\'difficulty level\\'.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> jobs;\\n        for(int i=0; i<difficulty.size(); i++)\\n            jobs.push_back({difficulty[i],profit[i]});\\n\\n        sort(begin(jobs),end(jobs));\\n        sort(begin(worker),end(worker));\\n\\n        int j = 0, best = 0, sum = 0;\\n        for(int & it : worker)\\n        {\\n            while(j<jobs.size() && jobs[j].first<=it)\\n                best = max(best, jobs[j].second), j++;\\n            sum += best;\\n        }\\n        return sum;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit))\\n        j = best = ans = 0\\n        for ability in sorted(worker):\\n            while j < len(jobs) and jobs[j][0] <= ability:\\n                best = max(best, jobs[j][1])\\n                j += 1\\n            ans += best\\n        \\n        return ans\\n```\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(n)\\n```\n```\\nmax(m[difficulty[i]], profit[i]) had done because there can be duplicate in \\'difficulty\\'.\\n\\nDifficulty      Profit                                     Profit\\n----------     --------         ___________               --------\\n    4             20           |            |                20\\n    6             10    ---->  |    Second  |  ----->        20\\n    8             30           |    For     |                30\\n    10            20           |    Loop    |                30\\n\\nreturn accumulate(begin(worker), end(worker), 0, [m](int sum, int value)...\\n                                              |\\n              sum = -------------------------\\n              and value = each value in worker\\n          \\n              1 2 4 5 8 9\\n              upper_bound(5) = 8 \\n              lower_bound(5) = 5 but\\n              1 2 4 8 9\\n              lower_bound(5) = 8. Upper_bound = 1 variation where lower_bound = 2 variation.\\nThat\\'s why upper_bound chosen. prev(upper_bound(iterator)) is the iterator we need here always.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        map<int, int> m;\\n        for(int i=0; i<difficulty.size(); i++)\\n            m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n        \\n        for(auto it = next(m.begin()); it!= m.end(); it++)\\n            it->second = max(prev(it)->second, it->second);\\n        \\n        return accumulate(begin(worker), end(worker), 0, [m](int sum, int value){ return sum + prev(m.upper_bound(value))->second; });\\n    }\\n};\\n```\n```\\nTime  Complexity : O(nlogn) as we took map.\\nSpace Complexity : O(n)\\n```\n```\\nHere difficulty[i] = index and profit[i] = value of the \" counting sort \\'jobs\\' \"\\n\\ndifficulty = [2,4,6,8,10], profit = [20,10,15,40,30], worker = [4,5,6,7]\\n\\n0  0  20  0   10  0   15  0   40  0   50 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n                  \\n                    * After the second for loop *\\n                     \\n0  0  20  20  20  20  20  20  40  40  40 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n\\nIn the map solution when we \"accumulate\"d for each worker[i] say for 5 we had to go for \\nprev(upper_bound) = prev(5) =  4 here, but here in counting sort we have 5 to access directly, \\n\\n                          \\'   20 (profit)\\n                            5  (difficulty)   \\'\\n\\nwe don\\'t need any upper bound or traversing the array to get the value. So this solution is fast.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int jobs[100001] = {0};\\n        for(int i=0; i<difficulty.size(); i++)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<100001; i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\n```\\nYou can also optimize it by below. We only need the maximum element of \\'worker\\'.\\n                2 4 6 8 9 10 (difficulty)\\n                2 3 5 7      (worker)\\nas we need till \\'7\\', so we don\\'t care values > 7 in \\'difficulty\\'. \\nMake sure the value in \\'difficulty\\' is <= the maximum in \\'worker\\'.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int m = *max_element(begin(worker), end(worker)) + 1;\\n        vector<int> jobs(m, 0);\\n        for(int i=0; i<difficulty.size(); i++)\\n            if(difficulty[i] < m)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<m ;i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\n```\\nTime  Complexity : O(n + m)\\nSpace Complexity : O(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372099,
                "title": "simple-priority-queue-east-to-understand-and-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we want to maximize the profit then we will try to assign the work having maximum profit to maximum workers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We use a priority queue to store the profits alongwith the difficulty level corresponding to the profit.\\n2. Now we sort the worker array, so that we can start traversing from larget element i.e worker having the greatest ability.\\n3. We keep popping from the heap if the difficulty level of the job is greater than the ability of the worker.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>> pq;\\n        \\n        for(int i=0;i<profit.size();i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        int i=worker.size()-1;\\n        int ans=0;\\n        while(i>=0 && !pq.empty()){\\n             if(worker[i]>=pq.top().second){\\n                    ans+=pq.top().first;\\n                    i--;\\n             } \\n             else{\\n                 pq.pop();\\n             }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>> pq;\\n        \\n        for(int i=0;i<profit.size();i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        int i=worker.size()-1;\\n        int ans=0;\\n        while(i>=0 && !pq.empty()){\\n             if(worker[i]>=pq.top().second){\\n                    ans+=pq.top().first;\\n                    i--;\\n             } \\n             else{\\n                 pq.pop();\\n             }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054184,
                "title": "c-fastest-priority-queue",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < profit.size(); i++){\\n            pq.push({profit[i], difficulty[i]});\\n        }\\n        int ans = 0;\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        while(!pq.empty() && i >= 0){\\n            pair<int, int> p = pq.top();\\n            if(worker[i] >= p.second){\\n                ans += p.first;\\n                i--;\\n            }\\n            else pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < profit.size(); i++){\\n            pq.push({profit[i], difficulty[i]});\\n        }\\n        int ans = 0;\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        while(!pq.empty() && i >= 0){\\n            pair<int, int> p = pq.top();\\n            if(worker[i] >= p.second){\\n                ans += p.first;\\n                i--;\\n            }\\n            else pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917295,
                "title": "sort-binary-search-prefix-array-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), ans = 0, mx = INT_MIN;\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end());\\n        \\n        vector<int> pre;\\n        for(auto i : v) pre.push_back(mx = max(i.second, mx));\\n\\n        for(int w : worker) {\\n            int s = 0, e = n - 1, val = 0;\\n            while(s <= e) {\\n                int m = (s + e) / 2;\\n                if(v[m].first <= w) val = max(val, pre[m]), s = m + 1;\\n                else e = m - 1;\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n/*\\n((2, 10), (4, 20), (6, 30), (8, 40), (10, 50))\\n10       20        30        40       50\\n\\n20 + 20 + 30 + 30 = 100\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), ans = 0, mx = INT_MIN;\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end());\\n        \\n        vector<int> pre;\\n        for(auto i : v) pre.push_back(mx = max(i.second, mx));\\n\\n        for(int w : worker) {\\n            int s = 0, e = n - 1, val = 0;\\n            while(s <= e) {\\n                int m = (s + e) / 2;\\n                if(v[m].first <= w) val = max(val, pre[m]), s = m + 1;\\n                else e = m - 1;\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n/*\\n((2, 10), (4, 20), (6, 30), (8, 40), (10, 50))\\n10       20        30        40       50\\n\\n20 + 20 + 30 + 30 = 100\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762294,
                "title": "python-o-n-2-o-nlogn-explained",
                "content": "## **1. BRUTE FORCE - O(N^2)**\\n\\nIn the Brute Force approach, for every worker, we go through every difficulty and if the worker can do that job, we check if it can give him a profit greater than previous job. If yes, update the maximum profit for that worker.\\n\\nIn the end, we add this maximum profit to the final output that we have to return.\\n\\nThe issue is that the arrays can be of up to 10^4 length. So, an O(N^2) solution will fail for large inputs and will show TLE.\\n\\nBut from this solution, we can start thinking about the Optimized Approach.\\n\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        maxProfit = 0\\n        \\n        m = len(worker)\\n        n = len(difficulty)\\n        \\n        # For every worker, find the maximum profit that he can get (if possible)\\n        for j in range (m):\\n            maxWorkerProfit = 0\\n            # Go through each job difficulty\\n            for i in range(n):\\n                # And if we find a difficulty <= ability of worker\\n                # Then we need to update the profit \\n                # if this job gives a higher profit than previous job\\n                if difficulty[i] <= worker[j]:\\n                    maxWorkerProfit = max(maxWorkerProfit, profit[i])\\n            \\n            # And when we found the maximum profit for this worker, just add it to the output that we need to return\\n            maxProfit += maxWorkerProfit\\n        \\n        \\n        return maxProfit\\n\\t\\t\\n## **2. BINARY SEARCH APPROACH - O(NLogN)**\\n\\nThe reason of O(N^2) complexity in Brute Force approach is that inner loop. For every worker, we have to iterate from the beginning to the end to find the maximum profit. \\n\\n\\tBut what if the difficulties were in sorted order already?\\n\\nIn that case, if a worker is able to do any job with difficulty[i], then we can say that he can also do any job that has a lower difficulty right? In other words, in that case, we don\\'t worry about the difficulties on left side as they will all be valid as the array is sorted. And that\\'s the idea of Binary Search. \\n\\nSo using Binary Search, all we have to do is find the rightmost valid difficulty out of the sorted difficulty list. Once we can find that, then all we need to find is what is the maximum profit that we can get in the [0, rightmost valid difficulty index] range. And to avoid calculating this for every worker, we can precomute this before we even apply Binary Search. \\n\\nBut there is one issue with this approach and I was stuck at this for almost half an hour before I realised that I made a dumb mistake.\\n\\nNotice that \"difficulty\" and \"profit\" are in sync. That means, ith difficulty has profit[i] profit. So if we only sort difficulty list, the profit list remains unchanged and that will not give us correct result. We cannot sort these two lists separately as well. Because profit of a job with a higher difficulty might be less than profit of a job with lower difficulty. So sorting them separately will also give wrong results.\\n\\nAnd so, we want a way such that when we sort the \"difficulty\" list, the \"profit\" list is still in sync. And for that, we can make a new list in which at every index, we have a pair of (difficulty, profit). So now, even if we sort this new list based on difficulty value, the profit value will always stay with its correct corresponding difficulty, just as it was initially in the input lists.\\n\\n*You will find a lot of questions that have a similar pattern and they might differ in only the way we precompute max value. For some problems, you have to find maximum on right side whereas for some you have to find maximum on left side of each index. That depends on the problem statement. For example here, we know that if one difficulty is valid, all difficulties less than it are also valid. Hence we precomputed the maximum value on left side of each index.*\\n\\n```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        maxProfit = 0\\n        \\n        m = len(worker)\\n        n = len(difficulty)\\n        \\n        # We cannot just sort difficulty array\\n        # We also need to make sure profit array is in same order as difficulty array\\n        # So what we can do is at each index, we can keep what is the difficulty of a job and what is its profit\\n        jobs = []\\n        for i in range(n): jobs.append((difficulty[i], profit[i]))\\n            \\n        # Now we can sort this new list we made and since difficulty is the first value in each tuple\\n        # this list will be sorted based on difficulty\\n        jobs.sort()\\n        \\n        # Precompute maximum profit on left for each index\\n        maxProfitSoFar = [0] * n\\n        \\n        # For first index, maximum profit on left will be profit at its index only\\n        maxProfitSoFar[0] = jobs[0][1]\\n        for i in range(1, n): maxProfitSoFar[i] = max(maxProfitSoFar[i - 1], jobs[i][1])           \\n\\n        # For every worker, find the maximum profit that he can get (if possible)\\n        for j in range(m):\\n            maxWorkerProfit = 0\\n            \\n            # Instead of linear search, we can now apply Binary Search here\\n            # As we have sorted the difficulty\\n            # Since difficulty is sorted, all we want to find is the rightmost valid index in difficulty array\\n            # That is the rightmost index at which difficulty is <= ability of the worker\\n            \\n            start = 0\\n            end = n - 1\\n            rightmostIndex = -1\\n            \\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # If job at mid can be done by worker\\n                # Then this is one possible solution\\n                # But we want rightmost valid difficulty\\n                # So we keep searching on right side of mid\\n                if jobs[mid][0] <= worker[j]:\\n                    rightmostIndex = mid\\n                    start = mid + 1 \\n                # If job at mid cannot be done by the worker\\n                # That means, no job after mid can be done as well\\n                # Since array is now sorted\\n                else: end = mid - 1\\n            \\n            # Now, as we have precomputed maximum profit till each index already\\n            # We can find the maximum profit till rightmostIndex in O(1) time\\n            if rightmostIndex != -1: maxWorkerProfit = maxProfitSoFar[rightmostIndex]\\n                \\n            # And append that to the final output that we need to return\\n            maxProfit += maxWorkerProfit\\n            \\n        \\n        return maxProfit\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        maxProfit = 0\\n        \\n        m = len(worker)\\n        n = len(difficulty)\\n        \\n        # We cannot just sort difficulty array\\n        # We also need to make sure profit array is in same order as difficulty array\\n        # So what we can do is at each index, we can keep what is the difficulty of a job and what is its profit\\n        jobs = []\\n        for i in range(n): jobs.append((difficulty[i], profit[i]))\\n            \\n        # Now we can sort this new list we made and since difficulty is the first value in each tuple\\n        # this list will be sorted based on difficulty\\n        jobs.sort()\\n        \\n        # Precompute maximum profit on left for each index\\n        maxProfitSoFar = [0] * n\\n        \\n        # For first index, maximum profit on left will be profit at its index only\\n        maxProfitSoFar[0] = jobs[0][1]\\n        for i in range(1, n): maxProfitSoFar[i] = max(maxProfitSoFar[i - 1], jobs[i][1])           \\n\\n        # For every worker, find the maximum profit that he can get (if possible)\\n        for j in range(m):\\n            maxWorkerProfit = 0\\n            \\n            # Instead of linear search, we can now apply Binary Search here\\n            # As we have sorted the difficulty\\n            # Since difficulty is sorted, all we want to find is the rightmost valid index in difficulty array\\n            # That is the rightmost index at which difficulty is <= ability of the worker\\n            \\n            start = 0\\n            end = n - 1\\n            rightmostIndex = -1\\n            \\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # If job at mid can be done by worker\\n                # Then this is one possible solution\\n                # But we want rightmost valid difficulty\\n                # So we keep searching on right side of mid\\n                if jobs[mid][0] <= worker[j]:\\n                    rightmostIndex = mid\\n                    start = mid + 1 \\n                # If job at mid cannot be done by the worker\\n                # That means, no job after mid can be done as well\\n                # Since array is now sorted\\n                else: end = mid - 1\\n            \\n            # Now, as we have precomputed maximum profit till each index already\\n            # We can find the maximum profit till rightmostIndex in O(1) time\\n            if rightmostIndex != -1: maxWorkerProfit = maxProfitSoFar[rightmostIndex]\\n                \\n            # And append that to the final output that we need to return\\n            maxProfit += maxWorkerProfit\\n            \\n        \\n        return maxProfit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2566859,
                "title": "cpp-easy-two-pointer",
                "content": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        vector<pair<int,int>> v;\\n        int n=profit.size(),m=worker.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({profit[i],difficulty[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int ans=0;\\n        \\n        int j=n-1,i=m-1;\\n        while(j>=0 and i>=0)\\n        {\\n            int p=v[j].first;\\n            int d=v[j].second;\\n            int k=j;\\n            while(k>0 and worker[k]<d)\\n            {\\n                k--;\\n                d=v[k].second;\\n            }\\n            if(k>=0 and worker[k]>=d)\\n            {\\n                i--;\\n                ans+=profit[k];\\n            }\\n            else\\n                j--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        vector<pair<int,int>> v;\\n        int n=profit.size(),m=worker.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({profit[i],difficulty[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2478003,
                "title": "python-commented-code-greedy",
                "content": "\\tclass Solution:\\n\\t\\tdef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\t\\t\\tjobs=[]\\n\\t\\t\\tfor dif,pro in zip(difficulty, profit):\\n\\t\\t\\t\\tjobs.append([dif,pro])\\n\\t\\t\\tjobs = sorted(jobs, key=lambda x:x[0]) #sort it based on the difficulty level\\n\\t\\t\\tans = i = best = 0\\n\\t\\t\\tfor skill in sorted(worker):\\n\\t\\t\\t\\twhile i < len(jobs) and skill >= jobs[i][0]:\\n\\t\\t\\t\\t\\tbest = max(best, jobs[i][1]) #doing this because even a low difficulty task can have a higher profit than a high difficulty task                                              \\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tans += best\\n\\t\\t\\treturn ans\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\t\\t\\tjobs=[]\\n\\t\\t\\tfor dif,pro in zip(difficulty, profit):\\n\\t\\t\\t\\tjobs.append([dif,pro])\\n\\t\\t\\tjobs = sorted(jobs, key=lambda x:x[0]) #sort it based on the difficulty level\\n\\t\\t\\tans = i = best = 0\\n\\t\\t\\tfor skill in sorted(worker):\\n\\t\\t\\t\\twhile i < len(jobs) and skill >= jobs[i][0]:\\n\\t\\t\\t\\t\\tbest = max(best, jobs[i][1]) #doing this because even a low difficulty task can have a higher profit than a high difficulty task                                              \\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tans += best\\n\\t\\t\\treturn ans\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2444367,
                "title": "my-c-solution-easy-approach-by-using-priority-queue",
                "content": "****Please upvote if you like****\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        int n=profit.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        int ans=0;\\n        sort(worker.rbegin(),worker.rend());\\n        for(auto u:worker)\\n        {\\n            while(!pq.empty()){\\n                if(pq.top().second>u)\\n                    pq.pop();\\n                else{\\n                    ans+=pq.top().first;\\n                    break;\\n                }\\n            }\\n            if(pq.empty())\\n                break;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```\\n****If you have any trouble to understand my code then please comment billow I will reply very soon****",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        int n=profit.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        int ans=0;\\n        sort(worker.rbegin(),worker.rend());\\n        for(auto u:worker)\\n        {\\n            while(!pq.empty()){\\n                if(pq.top().second>u)\\n                    pq.pop();\\n                else{\\n                    ans+=pq.top().first;\\n                    break;\\n                }\\n            }\\n            if(pq.empty())\\n                break;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163409,
                "title": "most-profit-assigning-work",
                "content": "# **Brute force gives TLE\\n**\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        if min(difficulty) > max(worker):\\n            return 0\\n        \\n        max_profit = 0\\n        work_assigned = 0\\n        \\n        for i in range(len(worker)):\\n            max_money = 0\\n            for j in range(len(difficulty)):\\n                if profit[j] >= max_money:\\n                    if worker[i]>=difficulty[j]: \\n                        max_money = max(max_money,profit[j])\\n                        work_assigned = difficulty[j]\\n            max_profit += max_money\\n        return max_profit\\n\\t\\t\\n# \\t\\tTwo pointers\\n\\t\\t\\n\\t\\tclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        jobs = sorted(zip(difficulty,profit))\\n        n = len(jobs)\\n        \\n        res = i = best = 0\\n        \\n        for ability in sorted(worker):\\n            while i < n and ability >= jobs[i][0]:\\n                best = max(best,jobs[i][1])\\n                i+=1\\n            res+=best\\n        \\n        return res\\n\\t\\t\\n# \\t\\tBinary search and Map\\n\\t\\t\\n\\t\\tclass Solution:\\n    def search_ceil(self,arr,k):\\n        low = 0\\n        high = len(arr) - 1\\n        res = -1                        #binary search\\n\\n        while low <= high:\\n            mid = low + (high - low)//2\\n\\n            if arr[mid] <= k:\\n                res = mid\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        if res != -1:\\n            return arr[res]\\n        else:\\n            return -1\\n        \\n    def make_a_map_as_per_max_profit(self,difficulty, profit):\\n        dp = sorted(zip(difficulty,profit))     #nested list\\n\\n        map = {}\\n\\n        max_p = dp[0][1]\\n        map[dp[0][0]] = dp[0][1]   \\n\\n        for i in range(1,len(dp)):\\n            if dp[i][1] < max_p:\\n                   map[dp[i][0]] = max_p         #hash_map\\n            else:\\n                max_p = max(max_p,dp[i][1])\\n                map[dp[i][0]] = max_p\\n        return map\\n        \\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        map = self.make_a_map_as_per_max_profit(difficulty, profit)\\n        max_profit = 0\\n        difficulty.sort()\\n        for i in worker:\\n            if self.search_ceil(difficulty,i) > 0:\\n                max_profit += map[self.search_ceil(difficulty,i)]        #calculate prfit\\n        return max_profit\\n\\t\\t",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        if min(difficulty) > max(worker):\\n            return 0\\n        \\n        max_profit = 0\\n        work_assigned = 0\\n        \\n        for i in range(len(worker)):\\n            max_money = 0\\n            for j in range(len(difficulty)):\\n                if profit[j] >= max_money:\\n                    if worker[i]>=difficulty[j]: \\n                        max_money = max(max_money,profit[j])\\n                        work_assigned = difficulty[j]\\n            max_profit += max_money\\n        return max_profit\\n\\t\\t\\n# \\t\\tTwo pointers\\n\\t\\t\\n\\t\\tclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        jobs = sorted(zip(difficulty,profit))\\n        n = len(jobs)\\n        \\n        res = i = best = 0\\n        \\n        for ability in sorted(worker):\\n            while i < n and ability >= jobs[i][0]:\\n                best = max(best,jobs[i][1])\\n                i+=1\\n            res+=best\\n        \\n        return res\\n\\t\\t\\n# \\t\\tBinary search and Map\\n\\t\\t\\n\\t\\tclass Solution:\\n    def search_ceil(self,arr,k):\\n        low = 0\\n        high = len(arr) - 1\\n        res = -1                        #binary search\\n\\n        while low <= high:\\n            mid = low + (high - low)//2\\n\\n            if arr[mid] <= k:\\n                res = mid\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        if res != -1:\\n            return arr[res]\\n        else:\\n            return -1\\n        \\n    def make_a_map_as_per_max_profit(self,difficulty, profit):\\n        dp = sorted(zip(difficulty,profit))     #nested list\\n\\n        map = {}",
                "codeTag": "Java"
            },
            {
                "id": 2010143,
                "title": "python3-sort-binary-search-prefix-sum",
                "content": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tn = len(difficulty)\\n\\tarr = [(difficulty[i], profit[i]) for i in range(n)]\\n\\tarr.sort()\\n\\tmax_profit = [n[1] for n in arr]\\n\\tcur = 0\\n\\tfor i in range(n):\\n\\t\\tcur = max(max_profit[i], cur)\\n\\t\\tmax_profit[i] = cur\\n\\tprofit = 0\\n\\n\\tfor diff in worker:\\n\\t\\tl, r = 0, n - 1\\n\\t\\twhile l < r:\\n\\t\\t\\tm = (l + r + 1) >> 1\\n\\t\\t\\tif arr[m][0] <= diff:\\n\\t\\t\\t\\tl = m\\n\\t\\t\\telse:\\n\\t\\t\\t\\tr = m - 1\\n\\t\\tprofit += max_profit[l] if arr[l][0] <= diff else 0\\n\\treturn profit\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tn = len(difficulty)\\n\\tarr = [(difficulty[i], profit[i]) for i in range(n)]\\n\\tarr.sort()\\n\\tmax_profit = [n[1] for n in arr]\\n\\tcur = 0\\n\\tfor i in range(n):\\n\\t\\tcur = max(max_profit[i], cur)\\n\\t\\tmax_profit[i] = cur\\n\\tprofit = 0\\n\\n\\tfor diff in worker:\\n\\t\\tl, r = 0, n - 1\\n\\t\\twhile l < r:\\n\\t\\t\\tm = (l + r + 1) >> 1\\n\\t\\t\\tif arr[m][0] <= diff:\\n\\t\\t\\t\\tl = m\\n\\t\\t\\telse:\\n\\t\\t\\t\\tr = m - 1\\n\\t\\tprofit += max_profit[l] if arr[l][0] <= diff else 0\\n\\treturn profit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1947836,
                "title": "javascript-subproblems-and-preprocessing",
                "content": "Sort the difficulties and workers, then get the maximum profit you can get at that difficulty (which includes any lower difficulties).\\nUse i,j counter to find the maximum difficulty each worker can take on. Since each difficulty is already pre-calculated to be the maximum profit, then just adding the profit should give you the total profit.\\n\\n```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const profitD = [];\\n    \\n    // create difficulty and profit array\\n    for (let i = 0; i < difficulty.length; i++) {\\n        profitD.push({d: difficulty[i], p: profit[i]});\\n    }\\n    \\n    // sort on difficulty\\n    profitD.sort((a, b) => a.d - b.d);\\n    // sort worker\\n    worker.sort((a, b) => a - b);\\n    \\n    \\n    // process to the array to get maxProfit So Far\\n    let maxSoFar = -Infinity;\\n    for (let i = 0; i < profitD.length; i++) {\\n        maxSoFar = Math.max(profitD[i].p, maxSoFar);\\n        profitD[i].p = maxSoFar;\\n    }\\n    \\n    \\n    let i = 0;\\n    let j = 0;\\n    let total = 0;\\n    while (i <= profitD.length && j < worker.length) {\\n        // use the last profit and assign it to all the remaining workers\\n        // can do this in another for loop\\n        if (i === profitD.length) {\\n            total += profitD[i - 1].p;\\n            j++;\\n            continue;\\n        }\\n          \\n        const {p, d} = profitD[i];\\n        // increment i if too difficult\\n        if (d <= worker[j]) {\\n            i++;\\n        } else {\\n            if (i - 1 >= 0) {\\n                total += profitD[i - 1].p;\\n            }\\n            j++;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const profitD = [];\\n    \\n    // create difficulty and profit array\\n    for (let i = 0; i < difficulty.length; i++) {\\n        profitD.push({d: difficulty[i], p: profit[i]});\\n    }\\n    \\n    // sort on difficulty\\n    profitD.sort((a, b) => a.d - b.d);\\n    // sort worker\\n    worker.sort((a, b) => a - b);\\n    \\n    \\n    // process to the array to get maxProfit So Far\\n    let maxSoFar = -Infinity;\\n    for (let i = 0; i < profitD.length; i++) {\\n        maxSoFar = Math.max(profitD[i].p, maxSoFar);\\n        profitD[i].p = maxSoFar;\\n    }\\n    \\n    \\n    let i = 0;\\n    let j = 0;\\n    let total = 0;\\n    while (i <= profitD.length && j < worker.length) {\\n        // use the last profit and assign it to all the remaining workers\\n        // can do this in another for loop\\n        if (i === profitD.length) {\\n            total += profitD[i - 1].p;\\n            j++;\\n            continue;\\n        }\\n          \\n        const {p, d} = profitD[i];\\n        // increment i if too difficult\\n        if (d <= worker[j]) {\\n            i++;\\n        } else {\\n            if (i - 1 >= 0) {\\n                total += profitD[i - 1].p;\\n            }\\n            j++;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795402,
                "title": "priorityqueue-treemap",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        PriorityQueue<Job> pq = new PriorityQueue<>((a, b) -> {\\n            \\n            if (a.profit == b.profit) {\\n                return a.difficulty - b.difficulty;\\n            } else {\\n                return b.profit - a.profit;\\n            }\\n        });\\n        \\n        int n = difficulty.length;\\n        for (int i = 0; i < n; i++) {\\n            pq.add(new Job(difficulty[i], profit[i]));\\n        }\\n        \\n        TreeMap<Integer, List<Integer>> treeMap = new TreeMap<>();\\n        for (int i = 0; i < worker.length; i++) {\\n            treeMap.computeIfAbsent(worker[i], v -> new ArrayList<>()).add(i);\\n        }\\n        \\n        int ret = 0;\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        while (!pq.isEmpty() && visited.size() != worker.length) {\\n            \\n            Job cur = pq.poll();\\n            int d = cur.difficulty;\\n            \\n            Map.Entry<Integer, List<Integer>> e = treeMap.ceilingEntry(d);\\n            if (e != null) {\\n                \\n                for (int w : e.getValue()) {\\n                    visited.add(w);\\n                }\\n                \\n                ret += e.getValue().size() * cur.profit;\\n                \\n                treeMap.remove(e.getKey());\\n                pq.add(cur);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    class Job {\\n        \\n        int difficulty;\\n        int profit;\\n        \\n        public Job(int difficulty, int profit) {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        PriorityQueue<Job> pq = new PriorityQueue<>((a, b) -> {\\n            \\n            if (a.profit == b.profit) {\\n                return a.difficulty - b.difficulty;\\n            } else {\\n                return b.profit - a.profit;\\n            }\\n        });\\n        \\n        int n = difficulty.length;\\n        for (int i = 0; i < n; i++) {\\n            pq.add(new Job(difficulty[i], profit[i]));\\n        }\\n        \\n        TreeMap<Integer, List<Integer>> treeMap = new TreeMap<>();\\n        for (int i = 0; i < worker.length; i++) {\\n            treeMap.computeIfAbsent(worker[i], v -> new ArrayList<>()).add(i);\\n        }\\n        \\n        int ret = 0;\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        while (!pq.isEmpty() && visited.size() != worker.length) {\\n            \\n            Job cur = pq.poll();\\n            int d = cur.difficulty;\\n            \\n            Map.Entry<Integer, List<Integer>> e = treeMap.ceilingEntry(d);\\n            if (e != null) {\\n                \\n                for (int w : e.getValue()) {\\n                    visited.add(w);\\n                }\\n                \\n                ret += e.getValue().size() * cur.profit;\\n                \\n                treeMap.remove(e.getKey());\\n                pq.add(cur);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    class Job {\\n        \\n        int difficulty;\\n        int profit;\\n        \\n        public Job(int difficulty, int profit) {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622126,
                "title": "java-solutions-with-optimization-steps-explained",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + n))\\n        // sort job by difficulty \\n        // binary search for index of max difficulty worker[i] can afford\\n        // loop from 0 to that index, checking one by one to find max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job);\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job);\\n            int max = 0;\\n            for (int j = 0; j<=idx; j++) {\\n                max = Math.max(job[j].profit, max);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```\\nWay 2: Optimize maximum finding using segment tree, without loops\\n```\\nclass Solution {\\n    int MM = (int)1e5;\\n    int seg[] = new int[3*MM];\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + log n)) or can be simplified to O(n log n)\\n        // sort job by difficulty \\n\\t\\t// build segment tree\\n        // binary search for index of max difficulty worker[i] can afford\\n        // query seg tree for the range [0, index] to find the max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job); // Sort requires O(n log n) \\n        build(0, m-1, 1, job); // Build tree requires O(n)\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job); // binary search takes O(log n)\\n            int max = queryMax(0, m-1, 0, idx, 1); // query takes O(log n)\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public void build(int l, int r, int idx, work[] jobs) {\\n        if (l == r) {\\n            seg[idx] = jobs[l].profit;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        build(l , m, idx*2, jobs); build(m+1, r, idx*2+1, jobs);\\n        seg[idx] = Math.max(seg[2*idx], seg[2*idx+1]);\\n    }\\n    public int queryMax(int l, int r, int ql, int qr, int idx) {\\n        if (ql>qr) return 0; \\n        if (l == ql && r == qr)return seg[idx];\\n        int m = (l+r)/2;\\n        if (ql > m) return queryMax(m+1, r, ql, qr, 2*idx+1);\\n        else if (qr<=m) return queryMax(l, m, ql, qr, 2*idx);\\n        else return Math.max(queryMax(l, m, ql, m, 2*idx), queryMax(m+1, r, m+1, qr, 2*idx+1));\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + n))\\n        // sort job by difficulty \\n        // binary search for index of max difficulty worker[i] can afford\\n        // loop from 0 to that index, checking one by one to find max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job);\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job);\\n            int max = 0;\\n            for (int j = 0; j<=idx; j++) {\\n                max = Math.max(job[j].profit, max);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int MM = (int)1e5;\\n    int seg[] = new int[3*MM];\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + log n)) or can be simplified to O(n log n)\\n        // sort job by difficulty \\n\\t\\t// build segment tree\\n        // binary search for index of max difficulty worker[i] can afford\\n        // query seg tree for the range [0, index] to find the max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job); // Sort requires O(n log n) \\n        build(0, m-1, 1, job); // Build tree requires O(n)\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job); // binary search takes O(log n)\\n            int max = queryMax(0, m-1, 0, idx, 1); // query takes O(log n)\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public void build(int l, int r, int idx, work[] jobs) {\\n        if (l == r) {\\n            seg[idx] = jobs[l].profit;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        build(l , m, idx*2, jobs); build(m+1, r, idx*2+1, jobs);\\n        seg[idx] = Math.max(seg[2*idx], seg[2*idx+1]);\\n    }\\n    public int queryMax(int l, int r, int ql, int qr, int idx) {\\n        if (ql>qr) return 0; \\n        if (l == ql && r == qr)return seg[idx];\\n        int m = (l+r)/2;\\n        if (ql > m) return queryMax(m+1, r, ql, qr, 2*idx+1);\\n        else if (qr<=m) return queryMax(l, m, ql, qr, 2*idx);\\n        else return Math.max(queryMax(l, m, ql, m, 2*idx), queryMax(m+1, r, m+1, qr, 2*idx+1));\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324179,
                "title": "with-explaination-faster-than-98-dp-java-easy-to-understand",
                "content": "Basically we have to find what maximum profit a worker could earn knowing that he is only able to do work of certain level of difficulty. For this we are creating a dp array and in that we are storing the max profit for each level.\\nFirst we are assigning values in dp from the profit array.After that maximum profit for any difficulty is the MAX profit of difficulty from level 0 difficulty to that level of difficulty.So value of that difficulty will be\\ndp[i]=Math.max(dp[0],dp[1],dp[2].......dp[i])\\nWe are doing this because a person can earn money by doing work of any difficulty level below tham it\\'s level.\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=-1;\\n        for(int val:difficulty)\\n            max=Math.max(val,max);\\n        int [] dp=new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++){\\n            dp[difficulty[i]]=Math.max(dp[difficulty[i]],profit[i]);\\n        }\\n        for(int i=1;i<dp.length;i++){\\n            dp[i]=Math.max(dp[i],dp[i-1]);\\n        }\\n        int ans=0;\\n        for(int val:worker){\\n            if(val<dp.length)\\n                ans+=dp[val];\\n            else\\n                ans+=dp[dp.length-1];\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=-1;\\n        for(int val:difficulty)\\n            max=Math.max(val,max);\\n        int [] dp=new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++){\\n            dp[difficulty[i]]=Math.max(dp[difficulty[i]],profit[i]);\\n        }\\n        for(int i=1;i<dp.length;i++){\\n            dp[i]=Math.max(dp[i],dp[i-1]);\\n        }\\n        int ans=0;\\n        for(int val:worker){\\n            if(val<dp.length)\\n                ans+=dp[val];\\n            else\\n                ans+=dp[dp.length-1];\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018819,
                "title": "c-sort-then-greedy-beats-100-time-72-89-space",
                "content": "Greedy\\nSort profit array\\nAssign as many of the highest paying jobs to workers as you can.\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        vector<pair<int,int>> jobs;\\n        for(int i = 0; i < profit.size(); i++) jobs.push_back({profit[i], difficulty[i]});\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        int j = profit.size()-1;\\n        for(; i >= 0; i--) {\\n            while(j >= 0 && jobs[j].second > worker[i]) j--;\\n            if(j < 0) break;\\n            ans += jobs[j].first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        vector<pair<int,int>> jobs;\\n        for(int i = 0; i < profit.size(); i++) jobs.push_back({profit[i], difficulty[i]});\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        int j = profit.size()-1;\\n        for(; i >= 0; i--) {\\n            while(j >= 0 && jobs[j].second > worker[i]) j--;\\n            if(j < 0) break;\\n            ans += jobs[j].first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776586,
                "title": "java-sorting-and-two-pointer-approach-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] diff, int[] pro, int[] work) {\\n        int maxProfit=0;\\n        Map<Integer,Integer> map=new HashMap<>(); \\n        for(int i=0;i<pro.length;i++){\\n            if(map.get(pro[i])!=null && map.get(pro[i])<diff[i]){\\n                continue;\\n            }\\n            map.put(pro[i],diff[i]);\\n        }\\n        Arrays.sort(pro);\\n        Arrays.sort(work);\\n        int w=work.length-1;\\n        int p=pro.length-1;\\n        while(w>=0 && p>=0) {\\n            if(map.get(pro[p])<=work[w]){\\n                maxProfit+=pro[p];\\n                w--;\\n            } else{\\n                p--;\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] diff, int[] pro, int[] work) {\\n        int maxProfit=0;\\n        Map<Integer,Integer> map=new HashMap<>(); \\n        for(int i=0;i<pro.length;i++){\\n            if(map.get(pro[i])!=null && map.get(pro[i])<diff[i]){\\n                continue;\\n            }\\n            map.put(pro[i],diff[i]);\\n        }\\n        Arrays.sort(pro);\\n        Arrays.sort(work);\\n        int w=work.length-1;\\n        int p=pro.length-1;\\n        while(w>=0 && p>=0) {\\n            if(map.get(pro[p])<=work[w]){\\n                maxProfit+=pro[p];\\n                w--;\\n            } else{\\n                p--;\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756765,
                "title": "python-sort-and-binary-search",
                "content": "Code is very descriptive, just read up.\\n\\n```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tdif_profit_hm = defaultdict(int)\\n\\tn = len(difficulty)\\n\\n\\t# Create a hash map to remember original values order\\n\\tfor dif, profit in zip(difficulty, profit):\\n\\t\\tdif_profit_hm[dif] = max(dif_profit_hm[dif], profit)\\n\\n\\t# Sorting to work with binary search\\n\\tsorted_dif = sorted(difficulty)\\n\\n\\t# dp that knows maximum for every index worker can have\\n\\tmax_profit_per_diff = [0] * n\\n\\tmax_profit_per_diff[0] = dif_profit_hm[sorted_dif[0]]\\n\\n\\tfor i in range(1, len(sorted_dif)):\\n\\t\\tval = sorted_dif[i]\\n\\t\\tmax_profit_per_diff[i] = max(dif_profit_hm[val], max_profit_per_diff[i - 1])\\n\\n\\tdef find_worker_index(worker_dif):\\n\\t\\tindex = bisect_right(sorted_dif, worker_dif)\\n\\t\\tif index == n: return n -1 # we are bigger than all indexes\\n\\t\\tif sorted_dif[index] == worker_dif:\\n\\t\\t\\treturn index\\n\\t\\treturn index - 1\\n\\n\\tmax_profit = 0\\n\\tfor w in worker:\\n\\t\\tworker_max_index = find_worker_index(w)\\n\\t\\tif worker_max_index == -1: continue\\n\\t\\tmax_profit += max_profit_per_diff[worker_max_index]\\n\\n\\treturn max_profit\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tdif_profit_hm = defaultdict(int)\\n\\tn = len(difficulty)\\n\\n\\t# Create a hash map to remember original values order\\n\\tfor dif, profit in zip(difficulty, profit):\\n\\t\\tdif_profit_hm[dif] = max(dif_profit_hm[dif], profit)\\n\\n\\t# Sorting to work with binary search\\n\\tsorted_dif = sorted(difficulty)\\n\\n\\t# dp that knows maximum for every index worker can have\\n\\tmax_profit_per_diff = [0] * n\\n\\tmax_profit_per_diff[0] = dif_profit_hm[sorted_dif[0]]\\n\\n\\tfor i in range(1, len(sorted_dif)):\\n\\t\\tval = sorted_dif[i]\\n\\t\\tmax_profit_per_diff[i] = max(dif_profit_hm[val], max_profit_per_diff[i - 1])\\n\\n\\tdef find_worker_index(worker_dif):\\n\\t\\tindex = bisect_right(sorted_dif, worker_dif)\\n\\t\\tif index == n: return n -1 # we are bigger than all indexes\\n\\t\\tif sorted_dif[index] == worker_dif:\\n\\t\\t\\treturn index\\n\\t\\treturn index - 1\\n\\n\\tmax_profit = 0\\n\\tfor w in worker:\\n\\t\\tworker_max_index = find_worker_index(w)\\n\\t\\tif worker_max_index == -1: continue\\n\\t\\tmax_profit += max_profit_per_diff[worker_max_index]\\n\\n\\treturn max_profit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 641854,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for (int i=0; i<profit.size(); i++){\\n            pq.push(make_pair(profit[i], difficulty[i]));\\n        }\\n        sort(worker.begin(), worker.end());\\n        int total = 0;\\n        for (int i=worker.size()-1; i>=0; i--){\\n            while (!pq.empty() && pq.top().second > worker[i]){\\n                pq.pop();\\n            }\\n            if (!pq.empty()){\\n                total += pq.top().first;\\n            }else{\\n                break;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for (int i=0; i<profit.size(); i++){\\n            pq.push(make_pair(profit[i], difficulty[i]));\\n        }\\n        sort(worker.begin(), worker.end());\\n        int total = 0;\\n        for (int i=worker.size()-1; i>=0; i--){\\n            while (!pq.empty() && pq.top().second > worker[i]){\\n                pq.pop();\\n            }\\n            if (!pq.empty()){\\n                total += pq.top().first;\\n            }else{\\n                break;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548935,
                "title": "python-o-n-log-n-sort-and-binary-search",
                "content": "Simple idea: sort the jobs by difficulty, then find the most profit that can be made up to each difficulty level. For each worker, do a binary search to determine the most difficult job they can complete, and hence the most profit.\\n\\n```python\\nclass Solution:\\n    \\n    def maxProfitAssignment(self, difficulties, profits, workers):\\n        \\n        # Sort difficulties and profits, with difficulties as the key:\\n        difficulties, profits = zip(*sorted(zip(difficulties, profits)))\\n        \\n        # Find the corresponding maximum profit for each difficulty level:\\n        max_profits = list(itertools.accumulate(profits, max))\\n        \\n        min_difficulty = min(difficulties)\\n        \\n        def max_profit(worker):\\n            if worker < min_difficulty:\\n                return 0\\n            return max_profits[bisect.bisect(difficulties, worker) - 1]\\n        \\n        return sum(map(max_profit, workers))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    \\n    def maxProfitAssignment(self, difficulties, profits, workers):\\n        \\n        # Sort difficulties and profits, with difficulties as the key:\\n        difficulties, profits = zip(*sorted(zip(difficulties, profits)))\\n        \\n        # Find the corresponding maximum profit for each difficulty level:\\n        max_profits = list(itertools.accumulate(profits, max))\\n        \\n        min_difficulty = min(difficulties)\\n        \\n        def max_profit(worker):\\n            if worker < min_difficulty:\\n                return 0\\n            return max_profits[bisect.bisect(difficulties, worker) - 1]\\n        \\n        return sum(map(max_profit, workers))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347627,
                "title": "python-2-pointer-greedy",
                "content": "Run time O(NlogN + KlogK + N)\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        for i in range(len(difficulty)):\\n            difficulty[i] = (difficulty[i], profit[i])\\n        difficulty.sort(key = lambda x:x[0]) # O(NlogN)\\n        i, L = 0, len(difficulty)\\n        ans, most = 0, 0\\n        for wker in sorted(worker):\\n            while i < L and difficulty[i][0] <= wker:\\n                most = max(most, difficulty[i][1])\\n                i += 1\\n            ans += most\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        for i in range(len(difficulty)):\\n            difficulty[i] = (difficulty[i], profit[i])\\n        difficulty.sort(key = lambda x:x[0]) # O(NlogN)\\n        i, L = 0, len(difficulty)\\n        ans, most = 0, 0\\n        for wker in sorted(worker):\\n            while i < L and difficulty[i][0] <= wker:\\n                most = max(most, difficulty[i][1])\\n                i += 1\\n            ans += most\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251244,
                "title": "why-does-my-solution-fail-the-last-testcase",
                "content": "I used Nlog(N) sort + binary search solution:\\nIt fails on this testcase:\\n[66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n[66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n[61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]\\noutput should be:  1392\\nbut i am getting: 1324\\n\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        dif_to_profit_map = {difficulty[i]:profit[i] for i in range(len(difficulty))}\\n        difficulty = sorted(difficulty)\\n        max_ = 0\\n        for i in difficulty:\\n            max_ = max(max_, dif_to_profit_map[i])\\n            dif_to_profit_map[i] = max_\\n\\n        def bs(arr, s, e, t):\\n            if s > e:\\n                return -1\\n            \\n            mid = (s + e) // 2\\n            \\n            if arr[mid] > t:\\n                return bs(arr, s, mid-1, t)\\n            \\n            elif arr[mid] <= t:\\n                if mid == len(arr)-1: return mid\\n                \\n                elif arr[mid+1] > t: return mid\\n                \\n                else: return bs(arr, mid+1, e, t) \\n                \\n        sol = 0\\n        for i in worker:\\n            ind = bs(difficulty, 0, len(difficulty), i)\\n            if ind != -1:\\n                sol += dif_to_profit_map[difficulty[ind]]\\n        \\n        return sol\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        dif_to_profit_map = {difficulty[i]:profit[i] for i in range(len(difficulty))}",
                "codeTag": "Java"
            },
            {
                "id": 4013864,
                "title": "c-solution-using-sorting",
                "content": "# Intuition\\n- Here a worker can perform any task whose difficulty is less than or equal to the ability of our worker\\n- So we need to sort the array and find the max profit that we can get for a worker with ability worker[i]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> nums(n);\\n        for(int i=0;i<n;i++){\\n            nums[i] = {difficulty[i],profit[i]};\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        int maxProfit = 0;\\n        int tempprofit = 0;\\n        for( int i = 0 , j = 0 ; i < n ; i++ ){\\n            while(j<n && nums[j].first <= worker[i]){\\n                tempprofit = max(nums[j].second,tempprofit);    // stores max profit for all tasks having dificilty <= worker[i]\\n                j++;\\n            }\\n            if(j>0 && nums[j-1].first<=worker[i])\\n                maxProfit += tempprofit;\\n        }\\n\\n        return maxProfit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> nums(n);\\n        for(int i=0;i<n;i++){\\n            nums[i] = {difficulty[i],profit[i]};\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        int maxProfit = 0;\\n        int tempprofit = 0;\\n        for( int i = 0 , j = 0 ; i < n ; i++ ){\\n            while(j<n && nums[j].first <= worker[i]){\\n                tempprofit = max(nums[j].second,tempprofit);    // stores max profit for all tasks having dificilty <= worker[i]\\n                j++;\\n            }\\n            if(j>0 && nums[j-1].first<=worker[i])\\n                maxProfit += tempprofit;\\n        }\\n\\n        return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918050,
                "title": "java-17ms-execution-time-beats-80-in-time-and-97-in-space-taken",
                "content": "# Intuition\\n- sorting\\n- binary search for getting max difficult work\\n\\n# Approach\\n- sort according to difficulty level of work\\n- get index what maximum difficulty level work user can do using binary search\\n- maintain maxProfit possible at a difficulty level(cover less difficult level profit as well because less difficult work can also have more profilt compare to higher difficulties)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static class Pair implements Comparable<Pair> {\\n            int dif;\\n            int pro;\\n            Pair (int dif, int pro) //constructor \\n            {\\n                this.dif = dif;\\n                this.pro = pro;\\n            }\\n            public int compareTo(Pair other) //making it only compare dif values\\n            {\\n                return this.dif - other.dif;\\n            }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int len = difficulty.length;\\n        Pair[] pairs = new Pair[len];\\n        for (int i=0; i< len; i++){\\n            pairs[i] = new Pair(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(pairs);\\n        \\n        int maxProfit = 0;\\n        //get max profit from possible difficulty work\\n        int maxSoFar[] = new int[len];\\n        maxSoFar[0] = pairs[0].pro;\\n        for(int i = 1; i < len; i++) {\\n            if (pairs[i].pro > maxSoFar[i-1]) {\\n                maxSoFar[i] = pairs[i].pro;\\n            } else {\\n                maxSoFar[i] = maxSoFar[i-1];\\n            }\\n        }\\n\\n        //System.out.println(\"checking workers cap now....\");\\n\\n        for(int i = 0; i<worker.length; i++) {\\n            int index = getIndex(worker[i], pairs, len);\\n            //System.out.println(\"index: \" + index + \" for item: \" + worker[i]);\\n\\n            if(index != -1) {\\n                 maxProfit += maxSoFar[index];;\\n            }\\n           \\n        }\\n        return maxProfit;\\n    }\\n\\n    private int getIndex(int cap, Pair []pair, int len) {\\n        int low = 0;\\n        int high = len-1;\\n        while (low <= high) {\\n            int mid = (high+low)/2;\\n            if (pair[mid].dif == cap ) {\\n                //Check for same items\\n                while(mid < high && pair[mid+1].dif == cap) mid ++;\\n                return mid;\\n            } else if (pair[mid].dif < cap) {\\n                low = mid+1 ;\\n            } else if (pair[mid].dif > cap) {\\n                high = mid-1 ;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static class Pair implements Comparable<Pair> {\\n            int dif;\\n            int pro;\\n            Pair (int dif, int pro) //constructor \\n            {\\n                this.dif = dif;\\n                this.pro = pro;\\n            }\\n            public int compareTo(Pair other) //making it only compare dif values\\n            {\\n                return this.dif - other.dif;\\n            }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int len = difficulty.length;\\n        Pair[] pairs = new Pair[len];\\n        for (int i=0; i< len; i++){\\n            pairs[i] = new Pair(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(pairs);\\n        \\n        int maxProfit = 0;\\n        //get max profit from possible difficulty work\\n        int maxSoFar[] = new int[len];\\n        maxSoFar[0] = pairs[0].pro;\\n        for(int i = 1; i < len; i++) {\\n            if (pairs[i].pro > maxSoFar[i-1]) {\\n                maxSoFar[i] = pairs[i].pro;\\n            } else {\\n                maxSoFar[i] = maxSoFar[i-1];\\n            }\\n        }\\n\\n        //System.out.println(\"checking workers cap now....\");\\n\\n        for(int i = 0; i<worker.length; i++) {\\n            int index = getIndex(worker[i], pairs, len);\\n            //System.out.println(\"index: \" + index + \" for item: \" + worker[i]);\\n\\n            if(index != -1) {\\n                 maxProfit += maxSoFar[index];;\\n            }\\n           \\n        }\\n        return maxProfit;\\n    }\\n\\n    private int getIndex(int cap, Pair []pair, int len) {\\n        int low = 0;\\n        int high = len-1;\\n        while (low <= high) {\\n            int mid = (high+low)/2;\\n            if (pair[mid].dif == cap ) {\\n                //Check for same items\\n                while(mid < high && pair[mid+1].dif == cap) mid ++;\\n                return mid;\\n            } else if (pair[mid].dif < cap) {\\n                low = mid+1 ;\\n            } else if (pair[mid].dif > cap) {\\n                high = mid-1 ;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581906,
                "title": "java-javascript-c-c-solution",
                "content": "**Java**\\n```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n\\n    private record Job(int difficulty, int profit) {}\\n\\n    public int maxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker) {\\n        int totalJobs = jobDifficulty.length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Arrays.sort(jobs, (x, y) -> x.difficulty - y.difficulty);\\n        Arrays.sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (int difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} jobDifficulty\\n * @param {number[]} jobProfit\\n * @param {number[]} maxDifficultyPerWorker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function (jobDifficulty, jobProfit, maxDifficultyPerWorker) {\\n    const totalJobs = jobDifficulty.length;\\n    const jobs = new Array(totalJobs);\\n    for (let i = 0; i < totalJobs; ++i) {\\n        jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n    }\\n\\n    jobs.sort((x, y) => x.difficulty - y.difficulty);\\n    maxDifficultyPerWorker.sort((x, y) => x - y);\\n\\n    let index = 0;\\n    let totalMaxProfit = 0;\\n    let currentMaxProfit = 0;\\n\\n    for (let difficulty of maxDifficultyPerWorker) {\\n        while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n            currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n            ++index;\\n        }\\n        totalMaxProfit += currentMaxProfit;\\n    }\\n\\n    return totalMaxProfit;\\n};\\n\\nfunction Job(difficulty, profit) {\\n    this.difficulty = difficulty;\\n    this.profit = profit;\\n}\\n```\\n**C++**\\n```\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Job {\\n        int difficulty;\\n        int profit;\\n        Job() = default;\\n        Job(int difficulty, int profit) : difficulty {difficulty}, profit {profit}{}\\n    };\\n\\npublic:\\n    int maxProfitAssignment(vector<int>& jobDifficulty, vector<int>& jobProfit, vector<int>& maxDifficultyPerWorker) const {\\n        int totalJobs = jobDifficulty.size();\\n        vector<Job>jobs(totalJobs);\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i].difficulty = jobDifficulty[i];\\n            jobs[i].profit = jobProfit[i];\\n        }\\n        const auto compare = [](const Job& first, const Job& second) {return first.difficulty < second.difficulty;};\\n        //C++20: std::ranages::sort(jobs, compare) \\n        //       std::ranages::sort(maxDifficultyPerWorker)  \\n        sort(jobs.begin(), jobs.end(), compare);\\n        sort(maxDifficultyPerWorker.begin(), maxDifficultyPerWorker.end());\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (const auto& difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n};\\n```\\n**C#**\\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    private struct Job\\n    {\\n        public int difficulty;\\n        public int profit;\\n        public Job(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n    public int MaxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker)\\n    {\\n        int totalJobs = jobDifficulty.Length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i)\\n        {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Array.Sort(jobs, (x, y) => x.difficulty - y.difficulty);\\n        Array.Sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        foreach (var difficulty in maxDifficultyPerWorker)\\n        {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty)\\n            {\\n                currentMaxProfit = Math.Max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n\\n    private record Job(int difficulty, int profit) {}\\n\\n    public int maxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker) {\\n        int totalJobs = jobDifficulty.length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Arrays.sort(jobs, (x, y) -> x.difficulty - y.difficulty);\\n        Arrays.sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (int difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} jobDifficulty\\n * @param {number[]} jobProfit\\n * @param {number[]} maxDifficultyPerWorker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function (jobDifficulty, jobProfit, maxDifficultyPerWorker) {\\n    const totalJobs = jobDifficulty.length;\\n    const jobs = new Array(totalJobs);\\n    for (let i = 0; i < totalJobs; ++i) {\\n        jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n    }\\n\\n    jobs.sort((x, y) => x.difficulty - y.difficulty);\\n    maxDifficultyPerWorker.sort((x, y) => x - y);\\n\\n    let index = 0;\\n    let totalMaxProfit = 0;\\n    let currentMaxProfit = 0;\\n\\n    for (let difficulty of maxDifficultyPerWorker) {\\n        while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n            currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n            ++index;\\n        }\\n        totalMaxProfit += currentMaxProfit;\\n    }\\n\\n    return totalMaxProfit;\\n};\\n\\nfunction Job(difficulty, profit) {\\n    this.difficulty = difficulty;\\n    this.profit = profit;\\n}\\n```\n```\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Job {\\n        int difficulty;\\n        int profit;\\n        Job() = default;\\n        Job(int difficulty, int profit) : difficulty {difficulty}, profit {profit}{}\\n    };\\n\\npublic:\\n    int maxProfitAssignment(vector<int>& jobDifficulty, vector<int>& jobProfit, vector<int>& maxDifficultyPerWorker) const {\\n        int totalJobs = jobDifficulty.size();\\n        vector<Job>jobs(totalJobs);\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i].difficulty = jobDifficulty[i];\\n            jobs[i].profit = jobProfit[i];\\n        }\\n        const auto compare = [](const Job& first, const Job& second) {return first.difficulty < second.difficulty;};\\n        //C++20: std::ranages::sort(jobs, compare) \\n        //       std::ranages::sort(maxDifficultyPerWorker)  \\n        sort(jobs.begin(), jobs.end(), compare);\\n        sort(maxDifficultyPerWorker.begin(), maxDifficultyPerWorker.end());\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (const auto& difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n};\\n```\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    private struct Job\\n    {\\n        public int difficulty;\\n        public int profit;\\n        public Job(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n    public int MaxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker)\\n    {\\n        int totalJobs = jobDifficulty.Length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i)\\n        {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Array.Sort(jobs, (x, y) => x.difficulty - y.difficulty);\\n        Array.Sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        foreach (var difficulty in maxDifficultyPerWorker)\\n        {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty)\\n            {\\n                currentMaxProfit = Math.Max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3481572,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, l = 0, p = 0;\\n        vector<pair<int, int>> pairs;\\n        for(int i = 0; i < n; i++) pairs.emplace_back(difficulty[i], profit[i]);\\n        sort(pairs.begin(), pairs.end());\\n        sort(worker.begin(), worker.end());\\n        for(int &w: worker){\\n            while(l < n && w >= pairs[l].first){\\n                p = max(p, pairs[l++].second);\\n            }\\n            res += p;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(profit, difficulty), reverse=True)\\n        worker.sort()\\n        total_profit = 0\\n\\n        for prof, diff in jobs:\\n            while worker and diff <= worker[-1]:\\n                total_profit += prof\\n                worker.pop()\\n            if not worker:\\n                break\\n\\n        return total_profit\\n```\\n\\n```Java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=0;\\n        for(int d:difficulty)\\n            max = Math.max(max, d);\\n        int[] dp = new int[max+1];\\n        for(int i=0;i<difficulty.length;i++) \\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        for(int i=1;i<=max;i++)\\n            dp[i] = Math.max(dp[i-1], dp[i]);\\n        int ans=0;\\n        for(int w:worker)\\n        {\\n            if(w>max) ans+=dp[max];\\n            else ans+=dp[w];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, l = 0, p = 0;\\n        vector<pair<int, int>> pairs;\\n        for(int i = 0; i < n; i++) pairs.emplace_back(difficulty[i], profit[i]);\\n        sort(pairs.begin(), pairs.end());\\n        sort(worker.begin(), worker.end());\\n        for(int &w: worker){\\n            while(l < n && w >= pairs[l].first){\\n                p = max(p, pairs[l++].second);\\n            }\\n            res += p;\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(profit, difficulty), reverse=True)\\n        worker.sort()\\n        total_profit = 0\\n\\n        for prof, diff in jobs:\\n            while worker and diff <= worker[-1]:\\n                total_profit += prof\\n                worker.pop()\\n            if not worker:\\n                break\\n\\n        return total_profit\\n```\n```Java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=0;\\n        for(int d:difficulty)\\n            max = Math.max(max, d);\\n        int[] dp = new int[max+1];\\n        for(int i=0;i<difficulty.length;i++) \\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        for(int i=1;i<=max;i++)\\n            dp[i] = Math.max(dp[i-1], dp[i]);\\n        int ans=0;\\n        for(int w:worker)\\n        {\\n            if(w>max) ans+=dp[max];\\n            else ans+=dp[w];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481270,
                "title": "no-binary-search-python-3-explainedd",
                "content": "Sort the array on the basis of profit (desc order) instead of difficulty after zipping them togther\\nAlso sort the worker array in descending order\\nNow if a task difficulty > worker[i] -> this task cant be done by any other worker too so j + 1\\nif difficulty < worker[i] => this task can be done i + 1.\\n`why not j + 1 here?` Because one task can be done by multiple workers\\n# Code\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, d: List[int], p: List[int], w: List[int]) -> int:\\n        task = list(zip(d, p))\\n        t = sorted(task, key=lambda x:-x[1])\\n        w.sort(reverse=True)\\n        profit = 0\\n        i = 0\\n        j = 0\\n        while i < len(w) and j < len(t):\\n            if w[i] < t[j][0]:\\n                j += 1\\n            else:\\n                profit += t[j][1]\\n                i += 1 \\n        return profit\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, d: List[int], p: List[int], w: List[int]) -> int:\\n        task = list(zip(d, p))\\n        t = sorted(task, key=lambda x:-x[1])\\n        w.sort(reverse=True)\\n        profit = 0\\n        i = 0\\n        j = 0\\n        while i < len(w) and j < len(t):\\n            if w[i] < t[j][0]:\\n                j += 1\\n            else:\\n                profit += t[j][1]\\n                i += 1 \\n        return profit\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370476,
                "title": "sort-binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size() , m = worker.size();\\n        vector<pair<int,int>> arr(n);   \\n        for(int i=0;i<n;i++) {\\n            arr[i] = {difficulty[i] , profit[i]};\\n        }\\n        sort(arr.begin() , arr.end());\\n        int ans = 0;\\n        // for(auto &i : arr) {\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        for(int i=0;i<m;i++) {\\n            int low = 0, high = n-1;\\n            int res = -1;\\n            while(low <= high) {\\n                int mid = low + (high-low) / 2;\\n                if(arr[mid].first <= worker[i]) {\\n                    res = mid;\\n                    low = mid+1;\\n                }\\n                else high = mid - 1;\\n            }\\n            if(res != -1) {\\n                int mx = 0;\\n                for(int i=0;i<=res;i++) {\\n                    mx = max(mx,arr[i].second);\\n                }\\n                ans += mx;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size() , m = worker.size();\\n        vector<pair<int,int>> arr(n);   \\n        for(int i=0;i<n;i++) {\\n            arr[i] = {difficulty[i] , profit[i]};\\n        }\\n        sort(arr.begin() , arr.end());\\n        int ans = 0;\\n        // for(auto &i : arr) {\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        for(int i=0;i<m;i++) {\\n            int low = 0, high = n-1;\\n            int res = -1;\\n            while(low <= high) {\\n                int mid = low + (high-low) / 2;\\n                if(arr[mid].first <= worker[i]) {\\n                    res = mid;\\n                    low = mid+1;\\n                }\\n                else high = mid - 1;\\n            }\\n            if(res != -1) {\\n                int mx = 0;\\n                for(int i=0;i<=res;i++) {\\n                    mx = max(mx,arr[i].second);\\n                }\\n                ans += mx;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3369923,
                "title": "python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        d = {}\\n        # mapping the difficulty with the corresponding profit and then storing it in the dictionary\\n        for x in range(len(difficulty)) :\\n            if difficulty[x] in d :\\n                d[difficulty[x]] = max( d[difficulty[x]] , profit[x])  # overwriting with highest value\\n            else:\\n                d[difficulty[x]] = profit[x]\\n\\n        # sorting the dictionary with respect to key\\n        dic = dict(sorted(d.items()))\\n        # sorting the difficulty also\\n        difficulty.sort()\\n    \\n        # now reassigning the profit with the max profit so far after sorting \\n        maxi = 0\\n        for x in dic.keys():\\n            maxi = max(maxi , dic[x] )\\n            dic[x] = maxi\\n            \\n        # calculating the total profit\\n        tot = 0\\n        for i in range(len(worker)) : \\n            # calculate the right position for the difficulty level of the workers\\n            r = bisect.bisect_left(difficulty,worker[i]) \\n            # if the position is at 0 then add the 0th profit only if the difficulty is equal \\n            if r==0: \\n                if difficulty[r] == worker[i] :\\n                    tot += dic[difficulty[r]]\\n                else:\\n                    tot += 0\\n            # if the difficulty is equal then add that profit \\n            elif r<len(difficulty) and difficulty[r] == worker[i] :\\n                tot += dic[difficulty[r]]\\n            # if the difficulty is not equal then add the previous profit \\n            else:\\n                tot += dic[difficulty[r-1]]\\n        return tot\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        d = {}\\n        # mapping the difficulty with the corresponding profit and then storing it in the dictionary\\n        for x in range(len(difficulty)) :\\n            if difficulty[x] in d :\\n                d[difficulty[x]] = max( d[difficulty[x]] , profit[x])  # overwriting with highest value\\n            else:\\n                d[difficulty[x]] = profit[x]\\n\\n        # sorting the dictionary with respect to key\\n        dic = dict(sorted(d.items()))\\n        # sorting the difficulty also\\n        difficulty.sort()\\n    \\n        # now reassigning the profit with the max profit so far after sorting \\n        maxi = 0\\n        for x in dic.keys():\\n            maxi = max(maxi , dic[x] )\\n            dic[x] = maxi\\n            \\n        # calculating the total profit\\n        tot = 0\\n        for i in range(len(worker)) : \\n            # calculate the right position for the difficulty level of the workers\\n            r = bisect.bisect_left(difficulty,worker[i]) \\n            # if the position is at 0 then add the 0th profit only if the difficulty is equal \\n            if r==0: \\n                if difficulty[r] == worker[i] :\\n                    tot += dic[difficulty[r]]\\n                else:\\n                    tot += 0\\n            # if the difficulty is equal then add that profit \\n            elif r<len(difficulty) and difficulty[r] == worker[i] :\\n                tot += dic[difficulty[r]]\\n            # if the difficulty is not equal then add the previous profit \\n            else:\\n                tot += dic[difficulty[r-1]]\\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316606,
                "title": "binary-search-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int>prefix;\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = diff.size();\\n        vector<pair<int,int>>v;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int difficulty = diff[i];\\n            int prof = profit[i];\\n            v.push_back(make_pair(difficulty,prof));\\n        }\\n        sort(v.begin(),v.end());\\n\\n        prefix.push_back(v[0].second);\\n        for(int i=1;i<v.size();i++)\\n        {\\n            int val = max(prefix[i-1],v[i].second);\\n            prefix.push_back(val);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int target = worker[i];\\n            binary_search_(v,0,v.size()-1,target,ans);\\n        }\\n        return ans;\\n    }\\n    void binary_search_(vector<pair<int,int>>&v,int start,int end,int targetdiff,int &ans)\\n    {\\n        int val = 0;\\n        while(start<=end)\\n        {\\n            int mid = (start + ((end - start)/2));\\n\\n            if(targetdiff == v[mid].first)\\n            {\\n               val = max(val,prefix[mid]);\\n               start = mid+1;        \\n            }\\n            else if(targetdiff > v[mid].first)\\n            {\\n                val = max(val,prefix[mid]);\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(start>=0 and start<v.size() and v[start].first <= targetdiff)\\n        val = max(val,prefix[start]);\\n\\n        if(end>=0 and end<v.size() and v[end].first <= targetdiff)\\n        val = max(val,prefix[end]);\\n\\n        ans = ans + val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int>prefix;\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = diff.size();\\n        vector<pair<int,int>>v;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int difficulty = diff[i];\\n            int prof = profit[i];\\n            v.push_back(make_pair(difficulty,prof));\\n        }\\n        sort(v.begin(),v.end());\\n\\n        prefix.push_back(v[0].second);\\n        for(int i=1;i<v.size();i++)\\n        {\\n            int val = max(prefix[i-1],v[i].second);\\n            prefix.push_back(val);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int target = worker[i];\\n            binary_search_(v,0,v.size()-1,target,ans);\\n        }\\n        return ans;\\n    }\\n    void binary_search_(vector<pair<int,int>>&v,int start,int end,int targetdiff,int &ans)\\n    {\\n        int val = 0;\\n        while(start<=end)\\n        {\\n            int mid = (start + ((end - start)/2));\\n\\n            if(targetdiff == v[mid].first)\\n            {\\n               val = max(val,prefix[mid]);\\n               start = mid+1;        \\n            }\\n            else if(targetdiff > v[mid].first)\\n            {\\n                val = max(val,prefix[mid]);\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(start>=0 and start<v.size() and v[start].first <= targetdiff)\\n        val = max(val,prefix[start]);\\n\\n        if(end>=0 and end<v.size() and v[end].first <= targetdiff)\\n        val = max(val,prefix[end]);\\n\\n        ans = ans + val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955918,
                "title": "easy-and-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs per question we have to maximize the profit \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo just make a pair of profit and it\\'s difficulty arrange the pair in ascending order take an iterator and put it in the last index of the pair and do the same thing for worker apply the condition as I have applied in my solution and you will get the required output, If you like this kindly Upvote.     \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)+O(mlogm)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        int n=difficulty.size(),m=worker.size();\\n        vector<pair<int,int>>jobs(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs[i].first=profit[i];\\n            jobs[i].second=difficulty[i];\\n        }\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(),worker.end());\\n        int j=m-1,i=n-1,sum=0;\\n        while(j>=0&&i>=0)\\n        {\\n          if(worker[j]>=jobs[i].second)\\n          {\\n              sum+=jobs[i].first;\\n              j--;\\n          }\\n          else\\n          {\\n              i--;\\n          }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        int n=difficulty.size(),m=worker.size();\\n        vector<pair<int,int>>jobs(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs[i].first=profit[i];\\n            jobs[i].second=difficulty[i];\\n        }\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(),worker.end());\\n        int j=m-1,i=n-1,sum=0;\\n        while(j>=0&&i>=0)\\n        {\\n          if(worker[j]>=jobs[i].second)\\n          {\\n              sum+=jobs[i].first;\\n              j--;\\n          }\\n          else\\n          {\\n              i--;\\n          }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761062,
                "title": "python-binary-search-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \"\"\"\\n        idea: \\n        - zip difficulty and profit\\n        -   sort by difficulty \\n        \\n        - iterate through each worker\\'s ability (worker)\\n        - find the greatest difficulty using binary search , returning the high (bisect right)\\n        -    max_profit += profit_of_worker[index found with binary search]\\n        \"\"\"\\n        diff_prof = [list(i) for i in zip(difficulty, profit)]\\n        diff_prof.sort(key = lambda x: x[0])\\n\\t\\t\\n        # need to make profit be the max up to i\\n        prev = diff_prof[0][1]\\n        for i in range(len(diff_prof)):\\n            diff_prof[i][1] = max(diff_prof[i][1], prev)\\n            prev = diff_prof[i][1]\\n\\n        max_profit = 0\\n        for ability in worker:\\n            index = self.binary_search(diff_prof, ability)\\n            if index >= 0 and index < len(diff_prof):\\n                max_profit += diff_prof[index][1]\\n        return max_profit\\n                \\n            \\n    def binary_search(self, diff_prof: List, ability: int) -> int:\\n        lo, hi = 0 , len(diff_prof) - 1\\n        index = -1\\n        while lo <= hi:\\n            mid = (lo + (hi - lo)//2)\\n            #mid = (hi + lo) // 2\\n            if diff_prof[mid][0] <= ability:\\n                # save index of what a worker can do up to\\n                index = mid \\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return index\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \"\"\"\\n        idea: \\n        - zip difficulty and profit\\n        -   sort by difficulty \\n        \\n        - iterate through each worker\\'s ability (worker)\\n        - find the greatest difficulty using binary search , returning the high (bisect right)\\n        -    max_profit += profit_of_worker[index found with binary search]\\n        \"\"\"\\n        diff_prof = [list(i) for i in zip(difficulty, profit)]\\n        diff_prof.sort(key = lambda x: x[0])\\n\\t\\t\\n        # need to make profit be the max up to i\\n        prev = diff_prof[0][1]\\n        for i in range(len(diff_prof)):\\n            diff_prof[i][1] = max(diff_prof[i][1], prev)\\n            prev = diff_prof[i][1]\\n\\n        max_profit = 0\\n        for ability in worker:\\n            index = self.binary_search(diff_prof, ability)\\n            if index >= 0 and index < len(diff_prof):\\n                max_profit += diff_prof[index][1]\\n        return max_profit\\n                \\n            \\n    def binary_search(self, diff_prof: List, ability: int) -> int:\\n        lo, hi = 0 , len(diff_prof) - 1\\n        index = -1\\n        while lo <= hi:\\n            mid = (lo + (hi - lo)//2)\\n            #mid = (hi + lo) // 2\\n            if diff_prof[mid][0] <= ability:\\n                # save index of what a worker can do up to\\n                index = mid \\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758748,
                "title": "c-prefixsum-sorting-binarysearch-tc-o-m-n-logn-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> v;\\n        int n = profit.size();\\n        int m = worker.size();\\n        for(int i = 0; i<n; i++) {\\n            v.push_back({difficulty[i], profit[i]});\\n        }\\n        // Sort the arrays according to lowest difficulty\\n        sort(v.begin(), v.end());\\n       // Now, we will find the job max difficulty which each worker can perform.\\n\\t   // Lets say, in this sortedArray, it comes out to be index 5.\\n\\t   // Since, we do not have the array sorted by profit, we cannot know what is the maxProfit achievable from job with atmost this difficulty.\\n\\t  // Hence, we find the max of Profits at this point. Kind of like how we maintain the prefix Sum.\\n\\t   vector<int> maxProfit(n);\\n        maxProfit[0] = v[0].second;\\n        for(int i = 1; i<n; i++)\\n            maxProfit[i] = max(maxProfit[i-1], v[i].second);\\n       \\n        int output = 0;\\n        \\n        for(int i = 0; i<m; i++) {\\n            int lo = 0, hi = n;\\n\\t\\t\\t// Finding the max index which has difficulty less than equal to worker\\'s calibre.\\\\\\n\\t\\t\\t// Classical maximisation problem of Binary Search.\\n            while(hi - lo > 1) {\\n                int mid = lo + (hi-lo)/2;\\n                if(v[mid].first <= worker[i]) {\\n                    lo = mid;\\n                } else {\\n                    hi = mid;\\n                }\\n            }\\n            int idx = hi-1;\\n            if(v[idx].first <= worker[i])\\n                output += maxProfit[idx];\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> v;\\n        int n = profit.size();\\n        int m = worker.size();\\n        for(int i = 0; i<n; i++) {\\n            v.push_back({difficulty[i], profit[i]});\\n        }\\n        // Sort the arrays according to lowest difficulty\\n        sort(v.begin(), v.end());\\n       // Now, we will find the job max difficulty which each worker can perform.\\n\\t   // Lets say, in this sortedArray, it comes out to be index 5.\\n\\t   // Since, we do not have the array sorted by profit, we cannot know what is the maxProfit achievable from job with atmost this difficulty.\\n\\t  // Hence, we find the max of Profits at this point. Kind of like how we maintain the prefix Sum.\\n\\t   vector<int> maxProfit(n);\\n        maxProfit[0] = v[0].second;\\n        for(int i = 1; i<n; i++)\\n            maxProfit[i] = max(maxProfit[i-1], v[i].second);\\n       \\n        int output = 0;\\n        \\n        for(int i = 0; i<m; i++) {\\n            int lo = 0, hi = n;\\n\\t\\t\\t// Finding the max index which has difficulty less than equal to worker\\'s calibre.\\\\\\n\\t\\t\\t// Classical maximisation problem of Binary Search.\\n            while(hi - lo > 1) {\\n                int mid = lo + (hi-lo)/2;\\n                if(v[mid].first <= worker[i]) {\\n                    lo = mid;\\n                } else {\\n                    hi = mid;\\n                }\\n            }\\n            int idx = hi-1;\\n            if(v[idx].first <= worker[i])\\n                output += maxProfit[idx];\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634281,
                "title": "java-solution-95-faster-method-1-prefix-sum-counting-sort-method-2-treemap",
                "content": "### **Method 1 - Counting-Sort & Prefix-Sum (Faster than 95percent)**\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max=0;\\n        for(int x:difficulty)\\n        {\\n            if(x>max)\\n                max=x;\\n        }\\n        \\n        int[] a = new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(a[difficulty[i]]<profit[i])\\n            a[difficulty[i]] = profit[i];\\n        }\\n        \\n        max=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]>max)\\n                max=a[i];\\n            else\\n                a[i]=max;\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            if(x>=a.length)\\n                x=a.length-1;\\n            sum+=a[x];\\n        }\\n        return sum;\\n    }\\n}\\n```\\n###  **Method 2 - Binary Search using TreeMap**\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Map<Integer,Integer> map  = new TreeMap<>();\\n       \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(map.get(difficulty[i])==null || map.get(difficulty[i])<profit[i])\\n            map.put(difficulty[i],profit[i]);\\n        }\\n        \\n        ArrayList<Integer> keys = new ArrayList<>(map.keySet());\\n        \\n        int max=0;\\n        for(var entry: map.entrySet())\\n        {\\n            int key = entry.getKey();\\n            int value = entry.getValue();\\n            \\n            if(value>max)\\n            {\\n                max = value;\\n            }\\n            else{\\n                map.put(key,max);\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            int idx = Collections.binarySearch(keys,x);\\n            if(idx<0)\\n            {\\n                idx = -1*(idx+1);\\n                idx--;\\n            }\\n            if(idx>=0)\\n            sum+=map.get(keys.get(idx));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max=0;\\n        for(int x:difficulty)\\n        {\\n            if(x>max)\\n                max=x;\\n        }\\n        \\n        int[] a = new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(a[difficulty[i]]<profit[i])\\n            a[difficulty[i]] = profit[i];\\n        }\\n        \\n        max=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]>max)\\n                max=a[i];\\n            else\\n                a[i]=max;\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            if(x>=a.length)\\n                x=a.length-1;\\n            sum+=a[x];\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Map<Integer,Integer> map  = new TreeMap<>();\\n       \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(map.get(difficulty[i])==null || map.get(difficulty[i])<profit[i])\\n            map.put(difficulty[i],profit[i]);\\n        }\\n        \\n        ArrayList<Integer> keys = new ArrayList<>(map.keySet());\\n        \\n        int max=0;\\n        for(var entry: map.entrySet())\\n        {\\n            int key = entry.getKey();\\n            int value = entry.getValue();\\n            \\n            if(value>max)\\n            {\\n                max = value;\\n            }\\n            else{\\n                map.put(key,max);\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            int idx = Collections.binarySearch(keys,x);\\n            if(idx<0)\\n            {\\n                idx = -1*(idx+1);\\n                idx--;\\n            }\\n            if(idx>=0)\\n            sum+=map.get(keys.get(idx));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497557,
                "title": "cpp-binary-search-lowerbound-greedy",
                "content": "```\\n//time complexity-mlogn\\n//first we wiil sort the array according to difficulty and store max profit according to diificulty\\n//find the lowerbound of capacity of current worker and add max profit to the answer\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    \\n        int n=profit.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++) v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        vector<int> mx(n);\\n        mx[0]=(v[0].second);\\n        //storin max profit at ith index\\n        for(int i=1;i<n;i++)\\n            mx[i]=max(mx[i-1],v[i].second);\\n        \\n        int m=worker.size();\\n        int ans(0);\\n        for(int i=0;i<m;i++){\\n            int key=worker[i];\\n            int l(0),h(n-1),mid;\\n            while(h-l>1){\\n                mid=l+(h-l)/2;\\n                if(v[mid].first<key) l=mid+1;\\n                else h=mid;\\n            }\\n            int ind=-1;\\n            if(v[l].first>=key) ind=l;\\n            else if(v[h].first>=key) ind=h;\\n            \\n            //if there is no lowerbound then worker can work at any capacity then we will take maximum profit\\n            if(ind==-1) ans+=mx[n-1];\\n            else if(v[ind].first==key){\\n                while(ind<n && v[ind].first==key) ind++;\\n                ans+=mx[ind-1];\\n            } \\n            else if(v[ind].first>key) ans+=(ind-1>=0)?mx[ind-1]:0;\\n        }\\n        return ans;\\n    }\\n};\\nif you like the solution please upvote and like it.\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\n//time complexity-mlogn\\n//first we wiil sort the array according to difficulty and store max profit according to diificulty\\n//find the lowerbound of capacity of current worker and add max profit to the answer\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    \\n        int n=profit.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++) v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        vector<int> mx(n);\\n        mx[0]=(v[0].second);\\n        //storin max profit at ith index\\n        for(int i=1;i<n;i++)\\n            mx[i]=max(mx[i-1],v[i].second);\\n        \\n        int m=worker.size();\\n        int ans(0);\\n        for(int i=0;i<m;i++){\\n            int key=worker[i];\\n            int l(0),h(n-1),mid;\\n            while(h-l>1){\\n                mid=l+(h-l)/2;\\n                if(v[mid].first<key) l=mid+1;\\n                else h=mid;\\n            }\\n            int ind=-1;\\n            if(v[l].first>=key) ind=l;\\n            else if(v[h].first>=key) ind=h;\\n            \\n            //if there is no lowerbound then worker can work at any capacity then we will take maximum profit\\n            if(ind==-1) ans+=mx[n-1];\\n            else if(v[ind].first==key){\\n                while(ind<n && v[ind].first==key) ind++;\\n                ans+=mx[ind-1];\\n            } \\n            else if(v[ind].first>key) ans+=(ind-1>=0)?mx[ind-1]:0;\\n        }\\n        return ans;\\n    }\\n};\\nif you like the solution please upvote and like it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328533,
                "title": "segment-tree-c-solution",
                "content": "**Prerequisite -> Segment trees theory.** \\n[**This**](https://www.youtube.com/watch?v=2FShdqn-Oz8&t=2355s) video greatly helped me understand segment trees. Errichto is awesome :)\\n\\n**C++**\\n```\\nclass Solution {\\n    vector<int> tree;\\n    int getMax(int i, int l, int r, int ql, int qr){\\n        if(ql<=l && r<=qr) return tree[i];\\n        if(qr<l || ql>r) return -1;\\n        int midl=l+((r-l)>>1);\\n        return max(getMax(i<<1, l, midl, ql, qr), getMax((i<<1)+1, midl+1, r, ql, qr));\\n    }\\n    inline int countOnes(int n){ //count total set bits in an integer\\n        int c=0;\\n        while(n) c+=1, n=n&(n-1);\\n        return c;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size(), cost=0;\\n        vector<pair<int, int>> p;\\n        for(int i=0; i<n; i++)\\n            p.push_back({difficulty[i], profit[i]});\\n        sort(p.begin(), p.end());\\n        while(countOnes(n)!=1){ //while n is not a power of 2 (we are basically padding the vector p with zeroes to have a size thats a power of 2).\\n            p.push_back({(int)1000000, 0});\\n            n++;\\n        }\\n        tree=vector<int>(n<<1); //n<<1 means n*2\\n        for(int i=0; i<n; i++) tree[i+n]=p[i].second;\\n        for(int i=n-1; i>=1; i--) tree[i]=max(tree[i<<1],tree[(i<<1)+1]);\\n        for(auto &i: worker) if(i>=p[0].first){\\n            int a=0, b=n-1;\\n            while(a<b){\\n                int mid=b+(a-b)/2;\\n                p[mid].first>i?\\n                    b=mid-1:\\n                    a=mid;\\n            }\\n            cost+=getMax(1, 0, n-1, 0, a); //getMax() will give max values in the range [0,a].\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> tree;\\n    int getMax(int i, int l, int r, int ql, int qr){\\n        if(ql<=l && r<=qr) return tree[i];\\n        if(qr<l || ql>r) return -1;\\n        int midl=l+((r-l)>>1);\\n        return max(getMax(i<<1, l, midl, ql, qr), getMax((i<<1)+1, midl+1, r, ql, qr));\\n    }\\n    inline int countOnes(int n){ //count total set bits in an integer\\n        int c=0;\\n        while(n) c+=1, n=n&(n-1);\\n        return c;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size(), cost=0;\\n        vector<pair<int, int>> p;\\n        for(int i=0; i<n; i++)\\n            p.push_back({difficulty[i], profit[i]});\\n        sort(p.begin(), p.end());\\n        while(countOnes(n)!=1){ //while n is not a power of 2 (we are basically padding the vector p with zeroes to have a size thats a power of 2).\\n            p.push_back({(int)1000000, 0});\\n            n++;\\n        }\\n        tree=vector<int>(n<<1); //n<<1 means n*2\\n        for(int i=0; i<n; i++) tree[i+n]=p[i].second;\\n        for(int i=n-1; i>=1; i--) tree[i]=max(tree[i<<1],tree[(i<<1)+1]);\\n        for(auto &i: worker) if(i>=p[0].first){\\n            int a=0, b=n-1;\\n            while(a<b){\\n                int mid=b+(a-b)/2;\\n                p[mid].first>i?\\n                    b=mid-1:\\n                    a=mid;\\n            }\\n            cost+=getMax(1, 0, n-1, 0, a); //getMax() will give max values in the range [0,a].\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272936,
                "title": "java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(b[1]-a[1]));\\n        for(int i=0;i<profit.length;i++)\\n        {\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        Arrays.sort(worker);\\n        int p=0;\\n        for(int i=worker.length-1;i>=0 && !pq.isEmpty();i--)\\n        {\\n            if(worker[i]>=pq.peek()[0])\\n                p=p+pq.peek()[1];\\n            else\\n            {\\n                while(!pq.isEmpty() && worker[i]<pq.peek()[0])\\n                    pq.poll();\\n                if(!pq.isEmpty())\\n                  p=p+pq.peek()[1];\\n            }\\n        }\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(b[1]-a[1]));\\n        for(int i=0;i<profit.length;i++)\\n        {\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        Arrays.sort(worker);\\n        int p=0;\\n        for(int i=worker.length-1;i>=0 && !pq.isEmpty();i--)\\n        {\\n            if(worker[i]>=pq.peek()[0])\\n                p=p+pq.peek()[1];\\n            else\\n            {\\n                while(!pq.isEmpty() && worker[i]<pq.peek()[0])\\n                    pq.poll();\\n                if(!pq.isEmpty())\\n                  p=p+pq.peek()[1];\\n            }\\n        }\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203850,
                "title": "c-binary-search-sorting-approach",
                "content": "```\\n// This is the Simple Binary Search Solution.\\n// First I am Sort Difficulty Vector and then after sorting I need to take Care of the Respective values.\\n// And For that I need map to store the corresponding values of profit vector.\\n// Now After Storing Values I just need to perform the upper bound for each value of worker vector and then ind-- \\n// I did because I need less than aur equal to value but upper bound does opposite.\\n// and then From beginning upto that index i am searching maximum value present in profit vector adding that to my ans will give me Result.\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        map<int,int>seen;\\n        int m = profit.size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            seen[difficulty[i]] = max(seen[difficulty[i]],profit[i]);\\n        }\\n        sort(difficulty.begin(),difficulty.end());\\n        int i = 0;\\n        for(auto it : difficulty)\\n        {\\n            profit[i] = seen[it];\\n            i++;\\n        }\\n        int n = worker.size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int ind = upper_bound(difficulty.begin(),difficulty.end(),worker[i]) - difficulty.begin();\\n            ind--;\\n            if(ind<0)\\n                continue;\\n            int max1 = *max_element(profit.begin(),profit.begin()+ind+1);\\n            ans+=max1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote If you Like The Solution......**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n// This is the Simple Binary Search Solution.\\n// First I am Sort Difficulty Vector and then after sorting I need to take Care of the Respective values.\\n// And For that I need map to store the corresponding values of profit vector.\\n// Now After Storing Values I just need to perform the upper bound for each value of worker vector and then ind-- \\n// I did because I need less than aur equal to value but upper bound does opposite.\\n// and then From beginning upto that index i am searching maximum value present in profit vector adding that to my ans will give me Result.\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        map<int,int>seen;\\n        int m = profit.size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            seen[difficulty[i]] = max(seen[difficulty[i]],profit[i]);\\n        }\\n        sort(difficulty.begin(),difficulty.end());\\n        int i = 0;\\n        for(auto it : difficulty)\\n        {\\n            profit[i] = seen[it];\\n            i++;\\n        }\\n        int n = worker.size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int ind = upper_bound(difficulty.begin(),difficulty.end(),worker[i]) - difficulty.begin();\\n            ind--;\\n            if(ind<0)\\n                continue;\\n            int max1 = *max_element(profit.begin(),profit.begin()+ind+1);\\n            ans+=max1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186392,
                "title": "c-code-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int x,vector<int> &diff,vector<int> &pro,vector<int> &worker){\\n        int i;\\n        int curr=0;\\n        \\n        for (i=0; i<worker.size(); i++){\\n            auto it=upper_bound(diff.begin(),diff.end(),worker[i]);\\n            \\n            if (it!=diff.end() && it!=diff.begin()){\\n                int idx=it-diff.begin()-1;\\n                curr+=pro[idx];\\n            }\\n            if (it==diff.end()){\\n                curr+=pro.back();\\n            }\\n        }\\n        \\n     return curr>=x;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker) {\\n        int l=0;\\n        int r=1e9+5;\\n        \\n        int i;\\n        vector<pair<int,int>> v;\\n        \\n        for (i=0; i<pro.size(); i++){\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for (i=1; i<v.size(); i++){\\n            v[i].second=max(v[i].second,v[i-1].second);\\n        }\\n        for (i=0; i<v.size(); i++){\\n            diff[i]=v[i].first;\\n            pro[i]=v[i].second;\\n        }\\n        \\n        while (r-l>1){\\n            int mid=l+(r-l)/2;\\n            if (check(mid,diff,pro,worker)){\\n                l=mid;\\n            }\\n            else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        if (check(r,diff,pro,worker)){\\n            return r;\\n        }\\n        else{\\n            return l;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int x,vector<int> &diff,vector<int> &pro,vector<int> &worker){\\n        int i;\\n        int curr=0;\\n        \\n        for (i=0; i<worker.size(); i++){\\n            auto it=upper_bound(diff.begin(),diff.end(),worker[i]);\\n            \\n            if (it!=diff.end() && it!=diff.begin()){\\n                int idx=it-diff.begin()-1;\\n                curr+=pro[idx];\\n            }\\n            if (it==diff.end()){\\n                curr+=pro.back();\\n            }\\n        }\\n        \\n     return curr>=x;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker) {\\n        int l=0;\\n        int r=1e9+5;\\n        \\n        int i;\\n        vector<pair<int,int>> v;\\n        \\n        for (i=0; i<pro.size(); i++){\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for (i=1; i<v.size(); i++){\\n            v[i].second=max(v[i].second,v[i-1].second);\\n        }\\n        for (i=0; i<v.size(); i++){\\n            diff[i]=v[i].first;\\n            pro[i]=v[i].second;\\n        }\\n        \\n        while (r-l>1){\\n            int mid=l+(r-l)/2;\\n            if (check(mid,diff,pro,worker)){\\n                l=mid;\\n            }\\n            else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        if (check(r,diff,pro,worker)){\\n            return r;\\n        }\\n        else{\\n            return l;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166941,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size();\\n        vector<pair<int,int>> vec(n);\\n        for(int i=0;i<n;i++) vec[i]={difficulty[i],profit[i]};\\n        sort(vec.begin(),vec.end());\\n        for(int i=1;i<n;i++) vec[i].second=max(vec[i].second,vec[i-1].second);\\n        int cost=0;\\n        for(auto it:worker){\\n            int low=0,high=n-1;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(vec[mid].first<=it) low=mid+1;\\n                else high=mid-1;\\n            }\\n            if(high>=0) cost+=vec[low-1].second;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size();\\n        vector<pair<int,int>> vec(n);\\n        for(int i=0;i<n;i++) vec[i]={difficulty[i],profit[i]};\\n        sort(vec.begin(),vec.end());\\n        for(int i=1;i<n;i++) vec[i].second=max(vec[i].second,vec[i-1].second);\\n        int cost=0;\\n        for(auto it:worker){\\n            int low=0,high=n-1;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(vec[mid].first<=it) low=mid+1;\\n                else high=mid-1;\\n            }\\n            if(high>=0) cost+=vec[low-1].second;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166157,
                "title": "golang-sorting",
                "content": "Pretty much the same answer as the one in the solution section.\\n\\n```\\n\\ntype job struct {\\n\\tdifficulty int\\n\\tprofit     int\\n}\\n\\nfunc maxProfitAssignment(difficulty []int, profit []int, worker []int) int {\\n\\tjobs := []job{}\\n\\n\\tfor i := 0; i < len(difficulty); i++ {\\n\\t\\ttemp := job{difficulty[i], profit[i]}\\n\\t\\tjobs = append(jobs, temp)\\n\\t}\\n\\n\\tsort.Slice(jobs, func(i int, j int) bool {\\n\\t\\treturn jobs[i].difficulty < jobs[j].difficulty\\n\\t})\\n\\n\\tsort.Sort(sort.IntSlice(worker))\\n\\n\\tans, i, best := 0, 0, 0\\n\\n\\tfor _, single_worker := range worker {\\n\\n\\t\\tfor i < len(worker) && single_worker >= jobs[i].difficulty {\\n\\t\\t\\tbest = int(math.Max(float64(best), float64(jobs[i].profit)))\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\tans += best\\n\\t}\\n\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n\\ntype job struct {\\n\\tdifficulty int\\n\\tprofit     int\\n}\\n\\nfunc maxProfitAssignment(difficulty []int, profit []int, worker []int) int {\\n\\tjobs := []job{}\\n\\n\\tfor i := 0; i < len(difficulty); i++ {\\n\\t\\ttemp := job{difficulty[i], profit[i]}\\n\\t\\tjobs = append(jobs, temp)\\n\\t}\\n\\n\\tsort.Slice(jobs, func(i int, j int) bool {\\n\\t\\treturn jobs[i].difficulty < jobs[j].difficulty\\n\\t})\\n\\n\\tsort.Sort(sort.IntSlice(worker))\\n\\n\\tans, i, best := 0, 0, 0\\n\\n\\tfor _, single_worker := range worker {\\n\\n\\t\\tfor i < len(worker) && single_worker >= jobs[i].difficulty {\\n\\t\\t\\tbest = int(math.Max(float64(best), float64(jobs[i].profit)))\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\tans += best\\n\\t}\\n\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151309,
                "title": "c-sort-and-binary-search",
                "content": "```\\nusing pii=pair<int,int>;\\n    int solve(int x,vector<pii> &v){\\n        int l=0,r=size(v)-1,ans=-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(v[m].first<=x) ans=m,l=m+1; //finding largest difficulty that is lesser than or equal to ability of worker\\n            else r=m-1;\\n        }\\n        if(ans==-1) return 0;\\n        return v[ans].second;\\n    }\\n    int maxProfitAssignment(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        vector<pii> v;\\n        int n=size(a),maxi=INT_MIN;\\n        for(int i=0;i<n;i++) v.push_back({a[i],b[i]});\\n        sort(begin(v),end(v));\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second); // for perticular difficulty maximum possible profit\\n            v[i].second=maxi;\\n        }\\n        int res=0;\\n        for(auto &x:c) res+=solve(x,v);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nusing pii=pair<int,int>;\\n    int solve(int x,vector<pii> &v){\\n        int l=0,r=size(v)-1,ans=-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(v[m].first<=x) ans=m,l=m+1; //finding largest difficulty that is lesser than or equal to ability of worker\\n            else r=m-1;\\n        }\\n        if(ans==-1) return 0;\\n        return v[ans].second;\\n    }\\n    int maxProfitAssignment(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        vector<pii> v;\\n        int n=size(a),maxi=INT_MIN;\\n        for(int i=0;i<n;i++) v.push_back({a[i],b[i]});\\n        sort(begin(v),end(v));\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second); // for perticular difficulty maximum possible profit\\n            v[i].second=maxi;\\n        }\\n        int res=0;\\n        for(auto &x:c) res+=solve(x,v);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2142170,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sorting && Binary Search***\\n\\n* ***Time Complexity : O(NlogN)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = difficulty.size();\\n        \\n        int m = worker.size();\\n        \\n        // make pair of difficulty[i] and profit[i]\\n        \\n        vector<pair<int, int>> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = {difficulty[i], profit[i]};\\n        }\\n        \\n        // sort the array\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        sort(difficulty.begin(), difficulty.end());\\n        \\n        // update the profit with maximum profit till ith index\\n        \\n        // so that we can choose a work with maximum profit in constant time\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            maxi = max(maxi, arr[i].second);\\n            \\n            arr[i].second = maxi;\\n        }\\n        \\n        // find the max_profit\\n        \\n        int max_profit = 0;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int idx = upper_bound(difficulty.begin(), difficulty.end(), worker[i]) - difficulty.begin();\\n            \\n            idx--;\\n    \\n            if(idx >= 0)\\n            {\\n                max_profit += arr[idx].second;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = difficulty.size();\\n        \\n        int m = worker.size();\\n        \\n        // make pair of difficulty[i] and profit[i]\\n        \\n        vector<pair<int, int>> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = {difficulty[i], profit[i]};\\n        }\\n        \\n        // sort the array\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        sort(difficulty.begin(), difficulty.end());\\n        \\n        // update the profit with maximum profit till ith index\\n        \\n        // so that we can choose a work with maximum profit in constant time\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            maxi = max(maxi, arr[i].second);\\n            \\n            arr[i].second = maxi;\\n        }\\n        \\n        // find the max_profit\\n        \\n        int max_profit = 0;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int idx = upper_bound(difficulty.begin(), difficulty.end(), worker[i]) - difficulty.begin();\\n            \\n            idx--;\\n    \\n            if(idx >= 0)\\n            {\\n                max_profit += arr[idx].second;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010515,
                "title": "easy-sorting-solution-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int ans = 0;\\n        vector<pair<int,int>> jobs;\\n        \\n        for(int i = 0; i < profit.size(); i++) \\n        {\\n            jobs.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(), worker.end());\\n        //sorting both arrays\\n        int j = profit.size()-1;\\n        for(int worker.size()-1; i >= 0; i--) {\\n            while(j >= 0 && jobs[j].second > worker[i]) {\\n                j--;\\n            }\\n            if(j < 0) break;\\n            ans = ans+jobs[j].first;\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976691,
                "title": "c-easy-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v;//make pair on difficulty and profit\\n        sort(worker.begin(),worker.end());//sort worker, later will depend on it to avoid more difficult than worker\\'s ability put in the vector\\n        for(int i=0;i<difficulty.size();i++)\\n        {\\n            if(difficulty[i]>worker[worker.size()-1])//if difficulty is more then worker\\'s ability\\n                continue;\\n            v.push_back({difficulty[i],profit[i]});//make pair on difficulty and profit\\n        }\\n        sort(v.begin(),v.end());//sort, later will use to make boundary\\n        \\n        int res=0;\\n        int lower=0;//the lower boundary(last worker\\'s most profit)\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int mmax=0;\\n            for(int j=lower;j<v.size();j++)//start with lower boundary\\n            {\\n                if(v[j].first>worker[i])//if now is more difficult than worker\\'s ability\\n                    break;\\n                if(mmax<v[j].second)//record the most profit\\n                {\\n                    lower=j;//the next worker\\'s lower boundary is here\\n                    mmax=v[j].second;\\n                }\\n            }\\n            res+=mmax;\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v;//make pair on difficulty and profit\\n        sort(worker.begin(),worker.end());//sort worker, later will depend on it to avoid more difficult than worker\\'s ability put in the vector\\n        for(int i=0;i<difficulty.size();i++)\\n        {\\n            if(difficulty[i]>worker[worker.size()-1])//if difficulty is more then worker\\'s ability\\n                continue;\\n            v.push_back({difficulty[i],profit[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1945986,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v{};\\n        int n=diff.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({diff[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxi=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second);\\n            profit[i] = maxi;\\n            diff[i] = v[i].first;\\n        }\\n        for(auto w:worker){\\n            int ub = upper_bound(diff.begin(),diff.end(),w)-diff.begin()-1;\\n            if(ub>=0) ans+=profit[ub];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v{};\\n        int n=diff.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({diff[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxi=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second);\\n            profit[i] = maxi;\\n            diff[i] = v[i].first;\\n        }\\n        for(auto w:worker){\\n            int ub = upper_bound(diff.begin(),diff.end(),w)-diff.begin()-1;\\n            if(ub>=0) ans+=profit[ub];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926631,
                "title": "c-binary-search-map-sort-three-simple-solution-with-explanation",
                "content": "# Solution 1 (R)\\n\\nWe construct `idx[i]` and sort `idx` based on `difficulty`. Also, use `maxv[idx[i]]` as best profit we have from `idx[0]`  to `idx[i]`. This is the best value that is based on sorted `difficulty`.\\n\\nThen for each value `w` in `worker`, use binary search to get the index of largest value that is \\u2264 `w` using `idx` and `difficulty` , `res += maxv[idx[right]]` .\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> idx;\\n        int n = profit.size();\\n        for (int i = 0; i < n; ++i) {\\n            idx.push_back(i);\\n        }\\n        sort(idx.begin(), idx.end(), [&difficulty](const int &a, const int &b){\\n            return difficulty[a] < difficulty[b];\\n        });\\n        vector<int> maxv;\\n        int m = 0;\\n        for (int i = 0; i < n; ++i) {\\n            m = max(m, profit[idx[i]]);\\n            maxv.push_back(m);\\n        }\\n        int res = 0;\\n        for (auto &w: worker) {\\n            int left = 0, right = n-1;\\n            while (left <= right) {\\n                int mid = left + (right-left)/2;\\n                if (difficulty[idx[mid]] <= w) {\\n                    left = mid+1;\\n                } else {\\n                    right = mid-1;\\n                }\\n            }\\n            if (right >= 0) {\\n                res += maxv[right];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n`n` : size of `difficulty` , `m` : size of `worker`\\n\\n**Time:** `O(nlogn + mlogn)` \\n**Space:** `O(n)` \\n\\n# Solution 2 (R)\\n\\nWe can also sort `data` , which is constructed by `difficulty` and `profit` , as well as `worker` .\\n\\nThen for each worker that is sorted, we maintain `best` as best profit we have until now and try to traverse `data` until its difficulty > the effort of the worker and update `best` at the same time.\\n\\nAfter that, `res += best` .\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size();\\n        vector<array<int,2>> data;\\n        for (int i = 0; i < n; ++i) {\\n            data.push_back({difficulty[i], profit[i]});\\n        }\\n        sort(worker.begin(), worker.end());\\n        sort(data.begin(), data.end());\\n        int i = 0, res = 0, best = 0;\\n        for (auto &w: worker) {\\n            while (i < n && data[i][0] <= w) {\\n                best = max(best, data[i++][1]);\\n            }\\n            res += best;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n`n` : size of `difficulty` , `m` : size of `worker`\\n\\n**Time:** `O(nlogn + mlogm)`   \\n**Space:** `O(n)`  \\n\\n# Solution 3 (R)\\n\\nWe use `map` to sort `difficulty` and since there might be multiple profit for same difficulty, need to pick max value.\\n\\nAfter that, traverse `map` again to fill each value with best value we have until now.\\n\\nLast, traverse `worker` and use upper_bound to get last largest value \\u2264 `worker` and find its value.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, best = 0;\\n        map<int,int> data;\\n        for (int i = 0; i < n; ++i) {\\n            data[difficulty[i]] = max(data[difficulty[i]], profit[i]);\\n        }\\n        for (auto &[d, p]: data) {\\n            best = max(best, p);\\n            p = best;\\n        }\\n        for (auto &w: worker) {\\n            res += prev(data.upper_bound(w))->second;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n`n` : size of `difficulty` , `m` : size of `worker`\\n\\n**Time:** `O(nlogn + mlogn)`   \\n**Space:** `O(n)`",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> idx;\\n        int n = profit.size();\\n        for (int i = 0; i < n; ++i) {\\n            idx.push_back(i);\\n        }\\n        sort(idx.begin(), idx.end(), [&difficulty](const int &a, const int &b){\\n            return difficulty[a] < difficulty[b];\\n        });\\n        vector<int> maxv;\\n        int m = 0;\\n        for (int i = 0; i < n; ++i) {\\n            m = max(m, profit[idx[i]]);\\n            maxv.push_back(m);\\n        }\\n        int res = 0;\\n        for (auto &w: worker) {\\n            int left = 0, right = n-1;\\n            while (left <= right) {\\n                int mid = left + (right-left)/2;\\n                if (difficulty[idx[mid]] <= w) {\\n                    left = mid+1;\\n                } else {\\n                    right = mid-1;\\n                }\\n            }\\n            if (right >= 0) {\\n                res += maxv[right];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size();\\n        vector<array<int,2>> data;\\n        for (int i = 0; i < n; ++i) {\\n            data.push_back({difficulty[i], profit[i]});\\n        }\\n        sort(worker.begin(), worker.end());\\n        sort(data.begin(), data.end());\\n        int i = 0, res = 0, best = 0;\\n        for (auto &w: worker) {\\n            while (i < n && data[i][0] <= w) {\\n                best = max(best, data[i++][1]);\\n            }\\n            res += best;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, best = 0;\\n        map<int,int> data;\\n        for (int i = 0; i < n; ++i) {\\n            data[difficulty[i]] = max(data[difficulty[i]], profit[i]);\\n        }\\n        for (auto &[d, p]: data) {\\n            best = max(best, p);\\n            p = best;\\n        }\\n        for (auto &w: worker) {\\n            res += prev(data.upper_bound(w))->second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871898,
                "title": "java-simple-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> task = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        \\n        for(int i=0; i<profit.length; i++)\\n            task.offer(new int[]{difficulty[i], profit[i]});\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i: worker)\\n            pq.offer(i);\\n        \\n        int sum = 0;\\n        \\n        while(!pq.isEmpty() && !task.isEmpty()){\\n            if(pq.peek() >= task.peek()[0]){\\n                while(!pq.isEmpty() && task.peek()[0] <= pq.peek()){\\n                    sum += task.peek()[1];\\n                    pq.poll();\\n                }\\n            }\\n            else{\\n                while(!task.isEmpty() && task.peek()[0] > pq.peek())\\n                    task.poll();\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> task = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        \\n        for(int i=0; i<profit.length; i++)\\n            task.offer(new int[]{difficulty[i], profit[i]});\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i: worker)\\n            pq.offer(i);\\n        \\n        int sum = 0;\\n        \\n        while(!pq.isEmpty() && !task.isEmpty()){\\n            if(pq.peek() >= task.peek()[0]){\\n                while(!pq.isEmpty() && task.peek()[0] <= pq.peek()){\\n                    sum += task.peek()[1];\\n                    pq.poll();\\n                }\\n            }\\n            else{\\n                while(!task.isEmpty() && task.peek()[0] > pq.peek())\\n                    task.poll();\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843630,
                "title": "java-with-treemap-neatly-bubbling-up-maximum",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Job> jobs = new ArrayList<>();\\n        int n = difficulty.length;\\n        for(int i=0; i<n; i++){\\n            jobs.add(new Job(difficulty[i], profit[i]));\\n        }\\n\\t\\t// sort based on difficulty (max profit in case of same difficulty)\\n        Collections.sort(jobs, new Comparator<>(){\\n            public int compare(Job j1, Job j2){\\n                if(j1.d == j2.d){\\n                    return j2.p - j1.p;\\n                }\\n                return j1.d - j2.d;\\n            }\\n        });\\n        int maxProfitSoFar = 0;\\n\\t\\t// bubble up the max profit seen so far from left to right \\n        for(Job j : jobs){\\n            maxProfitSoFar = Math.max(maxProfitSoFar, j.p);\\n            j.p = maxProfitSoFar;\\n        }\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(Job j : jobs){\\n            map.put(j.d, j.p);\\n        }\\n        \\n        int res = 0;\\n        for(int m : worker){\\n            Integer difficultyKey = map.floorKey(m);\\n            if(difficultyKey != null){\\n                res += map.get(difficultyKey);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Job {\\n    int d;\\n    int p;\\n    Job(int _d, int _p){\\n        d = _d;\\n        p = _p;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Job> jobs = new ArrayList<>();\\n        int n = difficulty.length;\\n        for(int i=0; i<n; i++){\\n            jobs.add(new Job(difficulty[i], profit[i]));\\n        }\\n\\t\\t// sort based on difficulty (max profit in case of same difficulty)\\n        Collections.sort(jobs, new Comparator<>(){\\n            public int compare(Job j1, Job j2){\\n                if(j1.d == j2.d){\\n                    return j2.p - j1.p;\\n                }\\n                return j1.d - j2.d;\\n            }\\n        });\\n        int maxProfitSoFar = 0;\\n\\t\\t// bubble up the max profit seen so far from left to right \\n        for(Job j : jobs){\\n            maxProfitSoFar = Math.max(maxProfitSoFar, j.p);\\n            j.p = maxProfitSoFar;\\n        }\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(Job j : jobs){\\n            map.put(j.d, j.p);\\n        }\\n        \\n        int res = 0;\\n        for(int m : worker){\\n            Integer difficultyKey = map.floorKey(m);\\n            if(difficultyKey != null){\\n                res += map.get(difficultyKey);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Job {\\n    int d;\\n    int p;\\n    Job(int _d, int _p){\\n        d = _d;\\n        p = _p;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836385,
                "title": "most-profit-assigning-work",
                "content": "```\\n  make difficulty and profit pair that will give you help in finding workers profit according to their strength.\\n  sort worker and difficulty\\n  search worker[i]\\'s floor in difficulty\\n```\\nclass Solution \\n{\\n public:\\n    //Searching worker strength in difficulty\\n    int binary(vector<int>&nums,int k)\\n    {\\n      int n = nums.size()-1;\\n      int l= 0;\\n      //speacial case if worker is not even able to do a least difficult task  \\n      if(nums[0]>k)\\n        return -1;\\n      //searching floor element\\n      int ans=0;\\n      while(l<=n)\\n      {\\n          int mid = (l+n)/2;\\n          if(nums[mid]<=k)\\n          {\\n            ans=mid;\\n            l=mid+1;\\n          }\\n          else\\n            n=mid -1 ;\\n        }\\n       return ans;\\n    }\\n    int maxProfitAssignment(vector<int>& d, vector<int>& pr, vector<int>& w) \\n    {\\n        int n = d.size();\\n        vector<pair<int,int>> p(n);\\n        for(int i=0;i<n;i++)\\n             p[i] = {d[i],pr[i]};\\n        // sorting in difficulty it will help to find the index easily \\n        sort(d.begin(),d.end());\\n         //sort it in difficulty and profit pairs it will give us workers difficulty strength and profit accordingly\\n        sort(p.begin(),p.end());\\n        for(int i=1;i<n;i++)\\n            p[i].second = max(p[i].second,p[i-1].second);\\n        int res =0;\\n        for(int i =0;i<w.size();i++)\\n        {\\n           int it = binary(d,w[i]);\\n           if(it>=0)\\n             res += p[it].second;\\n        }\\n       return res;\\n    }\\n};``",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n  make difficulty and profit pair that will give you help in finding workers profit according to their strength.\\n  sort worker and difficulty\\n  search worker[i]\\'s floor in difficulty\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803075,
                "title": "binary-search-cpp-simple-solution",
                "content": "int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n      \\n        vector<vector<int>>ds;\\n        \\n        for(int i=0; i<difficulty.size(); i++)\\n        {\\n            vector<int>arr;\\n            arr.push_back(difficulty[i]);\\n            arr.push_back(profit[i]);\\n            ds.push_back(arr);\\n        }\\n        \\n        // sortint by difficulty level\\n        sort(ds.begin(), ds.end());\\n        \\n        for(int i=1; i<ds.size(); i++)\\n        {\\n            ds[i][1] = max(ds[i-1][1], ds[i][1]);\\n\\t\\t\\n        }\\n        int sum = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int start = 0;\\n            int end = ds.size()-1;\\n            int target = worker[i];\\n            int ind  = -1;\\n            \\n            while(start <= end)\\n            {\\n                int mid = start + (end-start)/2;\\n                int midval = ds[mid][0];\\n                \\n                if(target>= midval)\\n                {\\n                    ind = mid;\\n                    start = mid + 1;\\n                }\\n                else{\\n                    end = mid -1;\\n                }\\n            }\\n            \\n            sum += ind>-1 ? ds[ind][1] : 0;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n      \\n        vector<vector<int>>ds;\\n        \\n        for(int i=0; i<difficulty.size(); i++)\\n        {\\n            vector<int>arr;\\n            arr.push_back(difficulty[i]);\\n            arr.push_back(profit[i]);\\n            ds.push_back(arr);\\n        }\\n        \\n        // sortint by difficulty level\\n        sort(ds.begin(), ds.end());\\n        \\n        for(int i=1; i<ds.size(); i++)\\n        {\\n            ds[i][1] = max(ds[i-1][1], ds[i][1]);\\n\\t\\t\\n        }\\n        int sum = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int start = 0;\\n            int end = ds.size()-1;\\n            int target = worker[i];\\n            int ind  = -1;\\n            \\n            while(start <= end)\\n            {\\n                int mid = start + (end-start)/2;\\n                int midval = ds[mid][0];\\n                \\n                if(target>= midval)\\n                {\\n                    ind = mid;\\n                    start = mid + 1;\\n                }\\n                else{\\n                    end = mid -1;\\n                }\\n            }\\n            \\n            sum += ind>-1 ? ds[ind][1] : 0;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1721292,
                "title": "easy-to-understand-java-29ms",
                "content": "```\\nclass Pair{\\n    public int first,second;\\n    Pair(int first,int second){\\n        this.first = first; this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> lst = new ArrayList<Pair>();\\n        for(int i=0;i<profit.length;i++){\\n            lst.add(new Pair(difficulty[i],profit[i]));\\n        }\\n        Collections.sort(lst,(Pair p1,Pair p2)->{\\n            return (p1.first==p2.first)?(p1.second-p2.second):(p1.first-p2.first);\\n        });\\n        Arrays.sort(worker);\\n        int res = 0,j = 0,temp = 0;\\n        for(int i=0;i<worker.length;i++){\\n            for(;j<lst.size();j++){\\n                if(lst.get(j).first>worker[i]){\\n                    break;\\n                }\\n                temp = Math.max(temp,lst.get(j).second);\\n            }res+=temp;\\n        }return res;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Pair{\\n    public int first,second;\\n    Pair(int first,int second){\\n        this.first = first; this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> lst = new ArrayList<Pair>();\\n        for(int i=0;i<profit.length;i++){\\n            lst.add(new Pair(difficulty[i],profit[i]));\\n        }\\n        Collections.sort(lst,(Pair p1,Pair p2)->{\\n            return (p1.first==p2.first)?(p1.second-p2.second):(p1.first-p2.first);\\n        });\\n        Arrays.sort(worker);\\n        int res = 0,j = 0,temp = 0;\\n        for(int i=0;i<worker.length;i++){\\n            for(;j<lst.size();j++){\\n                if(lst.get(j).first>worker[i]){\\n                    break;\\n                }\\n                temp = Math.max(temp,lst.get(j).second);\\n            }res+=temp;\\n        }return res;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594681,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxProfitAssignment(self, D: List[int], P: List[int], W: List[int]) -> int:\\n        n = len(D)\\n        \\n        # will be used to get sorted profits. sorted as per elements of difficulty\\n        indexes = sorted(range(n), key=lambda x:D[x])\\n        D.sort()\\n        \\n        # max prefix array\\n        max_profit = []\\n        mx = 0\\n        for i in range(n):\\n            mx = max(mx, P[indexes[i]])\\n            max_profit.append(mx)\\n            \\n        res = 0\\n        for w in W:\\n            idx = bisect.bisect(D, w) - 1\\n            if idx < 0:   continue\\n            res += max_profit[idx]\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, D: List[int], P: List[int], W: List[int]) -> int:\\n        n = len(D)\\n        \\n        # will be used to get sorted profits. sorted as per elements of difficulty\\n        indexes = sorted(range(n), key=lambda x:D[x])\\n        D.sort()\\n        \\n        # max prefix array\\n        max_profit = []\\n        mx = 0\\n        for i in range(n):\\n            mx = max(mx, P[indexes[i]])\\n            max_profit.append(mx)\\n            \\n        res = 0\\n        for w in W:\\n            idx = bisect.bisect(D, w) - 1\\n            if idx < 0:   continue\\n            res += max_profit[idx]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524028,
                "title": "python-3-solution-using-sort-hashmap-binary-search",
                "content": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tpd = defaultdict(int)\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(0, l):\\n\\t\\t#there might be different profit for same difficulty level\\n\\t\\t#so we pick the maximum one\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], profit[i])\\n\\n\\tdifficulty = sorted(set(difficulty))\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(1, l):\\n\\t\\t#task with less difficulty might be more profitable\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], pd[difficulty[i-1]])\\n\\t\\n\\t#since the array is sorted and everything is done as stated above\\n\\t# we can just perform binary search and find the task with proper difficulty (equal or the nearest smaller)\\n\\t\\n\\tdef binary_search(w):\\n\\t\\ts, e = 0, l-1\\n\\t\\tpos = -1\\n\\t\\twhile s<=e:\\n\\t\\t\\tmid = s+(e-s)//2\\n\\t\\t\\tif difficulty[mid]==w:\\n\\t\\t\\t\\treturn mid\\n\\t\\t\\telif difficulty[mid]<w:\\n\\t\\t\\t\\tpos = mid\\n\\t\\t\\t\\ts = mid+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\te = mid-1\\n\\t\\treturn pos\\n\\n\\tres = 0\\n\\tfor w in worker:\\n\\t\\tpos = binary_search(w)\\n\\t\\tif pos>=0:\\n\\t\\t\\tres+=pd[difficulty[pos]]\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tpd = defaultdict(int)\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(0, l):\\n\\t\\t#there might be different profit for same difficulty level\\n\\t\\t#so we pick the maximum one\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], profit[i])\\n\\n\\tdifficulty = sorted(set(difficulty))\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(1, l):\\n\\t\\t#task with less difficulty might be more profitable\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], pd[difficulty[i-1]])\\n\\t\\n\\t#since the array is sorted and everything is done as stated above\\n\\t# we can just perform binary search and find the task with proper difficulty (equal or the nearest smaller)\\n\\t\\n\\tdef binary_search(w):\\n\\t\\ts, e = 0, l-1\\n\\t\\tpos = -1\\n\\t\\twhile s<=e:\\n\\t\\t\\tmid = s+(e-s)//2\\n\\t\\t\\tif difficulty[mid]==w:\\n\\t\\t\\t\\treturn mid\\n\\t\\t\\telif difficulty[mid]<w:\\n\\t\\t\\t\\tpos = mid\\n\\t\\t\\t\\ts = mid+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\te = mid-1\\n\\t\\treturn pos\\n\\n\\tres = 0\\n\\tfor w in worker:\\n\\t\\tpos = binary_search(w)\\n\\t\\tif pos>=0:\\n\\t\\t\\tres+=pd[difficulty[pos]]\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1509325,
                "title": "javascript-solution-sort-and-two-pointers",
                "content": "```\\nvar maxProfitAssignment = function(difficulties, profits, workers) {\\n    const n = difficulties.length;\\n    const m = workers.length;\\n\\n    const jobs = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        const difficulty = difficulties[i];\\n        const profit = profits[i];\\n\\n        jobs[i] = { difficulty, profit };\\n    }\\n\\n    jobs.sort((a, b) => a.difficulty - b.difficulty); // sort the jobs by their difficulties\\n    workers.sort((a, b) => a - b); // sort the workers by their abilities\\n\\n    let jobIdx = 0; // pointer for the jobs array\\n    let workerIdx = 0; // pointer for the workers array\\n\\n    let totMaxProfit = 0;\\n    let bestIdx = 0;\\n\\n    while (workerIdx < m) {\\n        const workerAbility = workers[workerIdx];\\n        \\n        while (jobIdx < n && jobs[jobIdx].difficulty <= workerAbility) {\\n            if (jobs[jobIdx].profit > jobs[bestIdx].profit) {\\n                bestIdx = jobIdx;\\n            }\\n            jobIdx++;\\n        }\\n        \\n        if (jobs[bestIdx].difficulty <= workerAbility) {\\n            totMaxProfit += jobs[bestIdx].profit;\\n        }\\n        workerIdx++;\\n    }\\n    \\n    return totMaxProfit;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nvar maxProfitAssignment = function(difficulties, profits, workers) {\\n    const n = difficulties.length;\\n    const m = workers.length;\\n\\n    const jobs = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        const difficulty = difficulties[i];\\n        const profit = profits[i];\\n\\n        jobs[i] = { difficulty, profit };\\n    }\\n\\n    jobs.sort((a, b) => a.difficulty - b.difficulty); // sort the jobs by their difficulties\\n    workers.sort((a, b) => a - b); // sort the workers by their abilities\\n\\n    let jobIdx = 0; // pointer for the jobs array\\n    let workerIdx = 0; // pointer for the workers array\\n\\n    let totMaxProfit = 0;\\n    let bestIdx = 0;\\n\\n    while (workerIdx < m) {\\n        const workerAbility = workers[workerIdx];\\n        \\n        while (jobIdx < n && jobs[jobIdx].difficulty <= workerAbility) {\\n            if (jobs[jobIdx].profit > jobs[bestIdx].profit) {\\n                bestIdx = jobIdx;\\n            }\\n            jobIdx++;\\n        }\\n        \\n        if (jobs[bestIdx].difficulty <= workerAbility) {\\n            totMaxProfit += jobs[bestIdx].profit;\\n        }\\n        workerIdx++;\\n    }\\n    \\n    return totMaxProfit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1494625,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker)\\n    {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        sort(v.begin(),v.end());\\n        int best=0;\\n        int cost=0;\\n        for(int i=0,j=0;i<worker.size();i++)\\n        {\\n            int wt=worker[i];\\n            while(j<diff.size()&&wt>=v[j].first)\\n            {\\n                best=max(best,v[j].second);\\n                j++;\\n            }\\n            cost+=best;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker)\\n    {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        sort(v.begin(),v.end());\\n        int best=0;\\n        int cost=0;\\n        for(int i=0,j=0;i<worker.size();i++)\\n        {\\n            int wt=worker[i];\\n            while(j<diff.size()&&wt>=v[j].first)\\n            {\\n                best=max(best,v[j].second);\\n                j++;\\n            }\\n            cost+=best;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461056,
                "title": "java-51-faster-solution-using-binary-search",
                "content": "```\\nclass Pair{ // class to store the pair of difficulty and profit together\\n    int d;\\n    int p;\\n    Pair(int d,int p)\\n    {\\n        this.d=d;\\n        this.p=p;\\n    }\\n}\\nclass Solution {\\n    public static int binarysearch(ArrayList<Pair> arr,int val,int s,int e) // binary search function to find the maximum possible difficulty that can be done by the worker\\n    {\\n        if(s>e)\\n            return -1;\\n        int m=s+(e-s)/2;\\n        if(arr.get(m).d>val)\\n         return binarysearch(arr,val,s,m-1);\\n        else\\n        {\\n            int t=binarysearch(arr,val,m+1,e);\\n            return t==-1?m:t;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> arr=new ArrayList<>(); // list to store the pairs of difficulty and profit together\\n        for(int i=0;i<profit.length;i++)\\n            arr.add(new Pair(difficulty[i],profit[i]));\\n        Collections.sort(arr , new Comparator<Pair>(){ \\n            public int compare(Pair p1,Pair p2) // custom sort the list w.r.t difficulty\\n            {\\n                if(p1.d>p2.d)\\n                    return 1;\\n                if(p1.d==p2.d)\\n                    return 0;\\n                return -1;\\n            }\\n        });\\n        ArrayList<Integer> maxsofar=new ArrayList<>(); // list to store the maximum profit from 0 to ith index in the difficulty wise sorted list\\n        int maxx=0;\\n        for(Pair pr : arr)\\n        {\\n            maxx=Math.max(maxx,pr.p);\\n            maxsofar.add(maxx);\\n        }\\n        int sum=0;\\n        for(int i : worker)\\n        {\\n            int t=binarysearch(arr,i,0,arr.size()-1);\\n            if(t==-1)\\n                continue;\\n            sum+=maxsofar.get(t);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Pair{ // class to store the pair of difficulty and profit together\\n    int d;\\n    int p;\\n    Pair(int d,int p)\\n    {\\n        this.d=d;\\n        this.p=p;\\n    }\\n}\\nclass Solution {\\n    public static int binarysearch(ArrayList<Pair> arr,int val,int s,int e) // binary search function to find the maximum possible difficulty that can be done by the worker\\n    {\\n        if(s>e)\\n            return -1;\\n        int m=s+(e-s)/2;\\n        if(arr.get(m).d>val)\\n         return binarysearch(arr,val,s,m-1);\\n        else\\n        {\\n            int t=binarysearch(arr,val,m+1,e);\\n            return t==-1?m:t;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> arr=new ArrayList<>(); // list to store the pairs of difficulty and profit together\\n        for(int i=0;i<profit.length;i++)\\n            arr.add(new Pair(difficulty[i],profit[i]));\\n        Collections.sort(arr , new Comparator<Pair>(){ \\n            public int compare(Pair p1,Pair p2) // custom sort the list w.r.t difficulty\\n            {\\n                if(p1.d>p2.d)\\n                    return 1;\\n                if(p1.d==p2.d)\\n                    return 0;\\n                return -1;\\n            }\\n        });\\n        ArrayList<Integer> maxsofar=new ArrayList<>(); // list to store the maximum profit from 0 to ith index in the difficulty wise sorted list\\n        int maxx=0;\\n        for(Pair pr : arr)\\n        {\\n            maxx=Math.max(maxx,pr.p);\\n            maxsofar.add(maxx);\\n        }\\n        int sum=0;\\n        for(int i : worker)\\n        {\\n            int t=binarysearch(arr,i,0,arr.size()-1);\\n            if(t==-1)\\n                continue;\\n            sum+=maxsofar.get(t);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434903,
                "title": "c-priority-queue-8-lines",
                "content": "```\\n\\n```public:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int i,ans=0;\\n       priority_queue<pair<int,int>>pq;\\n        for(i=0;i<profit.size();i++)\\n        {\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        for(i=0;i<worker.size();i++)\\n        {\\n            while(!pq.empty()&&pq.top().second>worker[i])\\n            {\\n                pq.pop();\\n            }\\n            if(!pq.empty())\\n            {\\n                ans=ans+pq.top().first;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1409945,
                "title": "simple-python-o-nlogn-mlogm-sort-greedy-solution",
                "content": "If the ability of worker 1 is at least that of worker 2, worker1 can make a profit of at least that of worker 2 as well. We can start from the least skilled worker and increase max profit when we can. This way the total complexity is O(nlogn) for sorting difficulty and profit, O(mlogm) for sorting worker skills, and O(n) for scanning through difficulties.\\n\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        # sort difficulty and profit together as a tuple\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        ret = max_profit = idx = 0\\n        for ability in sorted(worker):\\n            # if ability is smaller than the smallest difficulty\\n            # it\\'s smaller than all difficulties\\n            if ability < difficulty[0]: continue\\n            # try to find a larger profit than the current one\\n            # this while loop will be run for at most len(difficulty) times\\n            # as idx is not reset at the end\\n            while idx < len(difficulty) and ability >= difficulty[idx]:\\n                max_profit = max(max_profit, profit[idx])\\n                idx += 1\\n            # increment total profit\\n            ret += max_profit\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        # sort difficulty and profit together as a tuple\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        ret = max_profit = idx = 0\\n        for ability in sorted(worker):\\n            # if ability is smaller than the smallest difficulty\\n            # it\\'s smaller than all difficulties\\n            if ability < difficulty[0]: continue\\n            # try to find a larger profit than the current one\\n            # this while loop will be run for at most len(difficulty) times\\n            # as idx is not reset at the end\\n            while idx < len(difficulty) and ability >= difficulty[idx]:\\n                max_profit = max(max_profit, profit[idx])\\n                idx += 1\\n            # increment total profit\\n            ret += max_profit\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378443,
                "title": "c-faster-than-50-easiest-solution-insertion-sort",
                "content": "\\'\\'\\'\\n\\n\\tint maxProfitAssignment(int* difficulty, int difficultySize, int* profit, int profitSize, int* worker, int workerSize){\\n    int i, j, tempval, tempval2, pr=0;\\n\\t\\n\\t// Example - difficulty = [10,8,6,4,2], profit = [50,40,30,20,10], worker = [7,6,5,4]\\n\\t\\n\\t/* Sorting difficulty array based on profit array\\n\\tSince we want to maximize profit so we figure out how can we get maximum profit and what is the \\n\\tdifficulty associated with it (Insertion sort as it it Stable)\\n\\t*/\\n    for(i=1; i<profitSize; ++i){\\n        if(profit[i]<profit[i-1]){\\n            tempval=profit[i];\\n            tempval2=difficulty[i];\\n            j=i-1;\\n            while(j>=0 && profit[j]>tempval){\\n                profit[j+1]=profit[j];\\n                difficulty[j+1]=difficulty[j];\\n                --j;\\n            } \\n            profit[j+1]=tempval;\\n            difficulty[j+1]=tempval2;\\n        }\\n    }\\n\\t// After sorting - difficulty = [2,4,6,8,10], profit = [10,20,30,40,50]\\n\\t\\n\\t// Now we Sort worker array \\n    for(i=1; i<workerSize; ++i){\\n        if(worker[i]<worker[i-1]){\\n            tempval=worker[i];\\n            j=i-1;\\n            while(j>=0 && worker[j]>tempval){\\n                worker[j+1]=worker[j];\\n                --j;\\n            } \\n            worker[j+1]=tempval;\\n        }\\n    }\\n\\t\\n\\t// After sorting -  worker = [4,5,6,7]\\n\\t\\n    // Main Logic\\n    int x=difficultySize-1; // last index of difficulty array (x=4)\\n    for(i=workerSize-1; i>=0; --i){\\n\\t\\t// we decrement x till we figure out an index where difficulty[x] <= worker [i]\\n\\t\\t// This goes on till difficulty[x]=6 or x=2\\n        while(x>-1 && difficulty[x]>worker[i]){\\n            --x;\\n        }\\n        if(x==-1) break;\\n        pr+=profit[x]; // difficulty[x]=6  and worker[i]=7 so we get maximum profit out of it\\n    }\\n    return pr;\\n\\t}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tint maxProfitAssignment(int* difficulty, int difficultySize, int* profit, int profitSize, int* worker, int workerSize){\\n    int i, j, tempval, tempval2, pr=0;\\n\\t\\n\\t// Example - difficulty = [10,8,6,4,2], profit = [50,40,30,20,10], worker = [7,6,5,4]\\n\\t\\n\\t/* Sorting difficulty array based on profit array\\n\\tSince we want to maximize profit so we figure out how can we get maximum profit and what is the \\n\\tdifficulty associated with it (Insertion sort as it it Stable)\\n\\t*/\\n    for(i=1; i<profitSize; ++i){\\n        if(profit[i]<profit[i-1]){\\n            tempval=profit[i];\\n            tempval2=difficulty[i];\\n            j=i-1;\\n            while(j>=0 && profit[j]>tempval){\\n                profit[j+1]=profit[j];\\n                difficulty[j+1]=difficulty[j];\\n                --j;\\n            } \\n            profit[j+1]=tempval;\\n            difficulty[j+1]=tempval2;\\n        }\\n    }\\n\\t// After sorting - difficulty = [2,4,6,8,10], profit = [10,20,30,40,50]\\n\\t\\n\\t// Now we Sort worker array \\n    for(i=1; i<workerSize; ++i){\\n        if(worker[i]<worker[i-1]){\\n            tempval=worker[i];\\n            j=i-1;\\n            while(j>=0 && worker[j]>tempval){\\n                worker[j+1]=worker[j];\\n                --j;\\n            } \\n            worker[j+1]=tempval;\\n        }\\n    }\\n\\t\\n\\t// After sorting -  worker = [4,5,6,7]\\n\\t\\n    // Main Logic\\n    int x=difficultySize-1; // last index of difficulty array (x=4)\\n    for(i=workerSize-1; i>=0; --i){\\n\\t\\t// we decrement x till we figure out an index where difficulty[x] <= worker [i]\\n\\t\\t// This goes on till difficulty[x]=6 or x=2\\n        while(x>-1 && difficulty[x]>worker[i]){\\n            --x;\\n        }\\n        if(x==-1) break;\\n        pr+=profit[x]; // difficulty[x]=6  and worker[i]=7 so we get maximum profit out of it\\n    }\\n    return pr;\\n\\t}\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1353377,
                "title": "sorting-binary-search",
                "content": "```\\nclass Solution {\\nprivate:\\n    int bs(vector<pair<int, int>>& job, int workerCap, int start, int end){\\n        // cout<<\"Got workerCap: \"<<workerCap<<\"\\\\n\";\\n        while(start<end){\\n            int mid = start + (end-start+1)/2;\\n            // cout<<\"Mid Diff Job: \"<<job[mid].first<<\"\\\\n\";\\n            if(job[mid].first > workerCap){\\n                // cout<<\"Shrinking End to: \"<<job[mid-1].first<<\"\\\\n\";\\n                end = mid-1;\\n            } else if(job[mid].first <= workerCap){\\n                // cout<<\"Shrinking start to: \"<<job[mid].first<<\"\\\\n\";\\n                start = mid;\\n            }\\n        }\\n        if(job[start].first > workerCap){\\n            // cout<<\"LowerBound not found!\\\\n\\\\n\";\\n            return -1;\\n        }\\n        // cout<<\"Referring job with difficulty: \"<< job[start].first<<\"\\\\n\\\\n\";\\n        return start;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        int res = 0;\\n        vector<pair<int, int>> job(n);\\n        for(int i=0;i<n;i++){\\n            job[i] = {difficulty[i], profit[i]};\\n        }\\n        sort(job.begin(), job.end());\\n        vector<int> jobWithMaxProfitUntilNow(n);\\n        int maxProfitJob = job[0].second;\\n        int maxProfitJobId = 0;\\n        for(int i=0;i<n;i++){\\n            if(job[i].second > maxProfitJob){\\n                maxProfitJob = job[i].second;\\n                maxProfitJobId = i;\\n            }\\n            jobWithMaxProfitUntilNow[i] = maxProfitJobId;\\n        }\\n        for(int i = m-1;i>=0;i--){\\n            int workerCap = worker[i];\\n            int bsid = bs(job, workerCap, 0, n-1);\\n            if(bsid==-1){\\n                continue;\\n            }\\n            res += job[jobWithMaxProfitUntilNow[bsid]].second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int bs(vector<pair<int, int>>& job, int workerCap, int start, int end){\\n        // cout<<\"Got workerCap: \"<<workerCap<<\"\\\\n\";\\n        while(start<end){\\n            int mid = start + (end-start+1)/2;\\n            // cout<<\"Mid Diff Job: \"<<job[mid].first<<\"\\\\n\";\\n            if(job[mid].first > workerCap){\\n                // cout<<\"Shrinking End to: \"<<job[mid-1].first<<\"\\\\n\";\\n                end = mid-1;\\n            } else if(job[mid].first <= workerCap){\\n                // cout<<\"Shrinking start to: \"<<job[mid].first<<\"\\\\n\";\\n                start = mid;\\n            }\\n        }\\n        if(job[start].first > workerCap){\\n            // cout<<\"LowerBound not found!\\\\n\\\\n\";\\n            return -1;\\n        }\\n        // cout<<\"Referring job with difficulty: \"<< job[start].first<<\"\\\\n\\\\n\";\\n        return start;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        int res = 0;\\n        vector<pair<int, int>> job(n);\\n        for(int i=0;i<n;i++){\\n            job[i] = {difficulty[i], profit[i]};\\n        }\\n        sort(job.begin(), job.end());\\n        vector<int> jobWithMaxProfitUntilNow(n);\\n        int maxProfitJob = job[0].second;\\n        int maxProfitJobId = 0;\\n        for(int i=0;i<n;i++){\\n            if(job[i].second > maxProfitJob){\\n                maxProfitJob = job[i].second;\\n                maxProfitJobId = i;\\n            }\\n            jobWithMaxProfitUntilNow[i] = maxProfitJobId;\\n        }\\n        for(int i = m-1;i>=0;i--){\\n            int workerCap = worker[i];\\n            int bsid = bs(job, workerCap, 0, n-1);\\n            if(bsid==-1){\\n                continue;\\n            }\\n            res += job[jobWithMaxProfitUntilNow[bsid]].second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1344821,
                "title": "c-easy-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    static bool compare(const int&a , const int &b)\\n    {\\n        return a>b;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<profit.size();i++)\\n        {\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end(),compare);\\n        int i=0;\\n        int ans=0;\\n        while(i<worker.size())\\n        {\\n            while(!pq.empty() && pq.top().second>worker[i])\\n            {\\n                pq.pop();\\n            }\\n            if(!pq.empty())\\n            {\\n                ans+=pq.top().first;\\n                i++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static bool compare(const int&a , const int &b)\\n    {\\n        return a>b;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<profit.size();i++)\\n        {\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end(),compare);\\n        int i=0;\\n        int ans=0;\\n        while(i<worker.size())\\n        {\\n            while(!pq.empty() && pq.top().second>worker[i])\\n            {\\n                pq.pop();\\n            }\\n            if(!pq.empty())\\n            {\\n                ans+=pq.top().first;\\n                i++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343418,
                "title": "c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> check(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            check[i]={difficulty[i],profit[i]};\\n        }\\n        sort(check.begin(),check.end());\\n        sort(worker.begin(),worker.end());\\n        int ans=0;\\n        int ptr1=0,ptr2=0;\\n        int maxProfit=0;\\n        int flag=0;\\n        while(ptr1<worker.size() && ptr2<check.size()){  \\n            \\n            if( worker[ptr1]>=check[ptr2].first){\\n                maxProfit=max(maxProfit,check[ptr2].second);\\n                ptr2++;\\n            }else{\\n                ans+=maxProfit;\\n                ptr1++;\\n                flag++;\\n            }\\n        }\\n        if(flag<worker.size())\\n            ans+=maxProfit * (worker.size()-flag);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> check(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            check[i]={difficulty[i],profit[i]};\\n        }\\n        sort(check.begin(),check.end());\\n        sort(worker.begin(),worker.end());\\n        int ans=0;\\n        int ptr1=0,ptr2=0;\\n        int maxProfit=0;\\n        int flag=0;\\n        while(ptr1<worker.size() && ptr2<check.size()){  \\n            \\n            if( worker[ptr1]>=check[ptr2].first){\\n                maxProfit=max(maxProfit,check[ptr2].second);\\n                ptr2++;\\n            }else{\\n                ans+=maxProfit;\\n                ptr1++;\\n                flag++;\\n            }\\n        }\\n        if(flag<worker.size())\\n            ans+=maxProfit * (worker.size()-flag);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081349,
                "title": "c-short-solution-88",
                "content": "Run-time is `O(NlogN + MlogM)`, space is `O(N)`, where `N` is size of `difficulty` and `M` size of `worker`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        std::vector<std::pair<int,int>> dnp;\\n        int size{(int)difficulty.size()};\\n        for(int i{0}; i < size; ++i) dnp.emplace_back(difficulty[i], profit[i]);\\n        std::sort(dnp.begin(), dnp.end(), [](const auto& a, const auto& b){return a.first < b.first;});\\n        for(int i{0}, max_{0}; i < size; ++i) {\\n            max_ = std::max(max_, dnp[i].second);\\n            dnp[i].second = max_;\\n        }\\n\\n        int sum{0};\\n        for(const auto &w: worker) {\\n            int tmp = sum;\\n            auto it{std::upper_bound(dnp.begin(), dnp.end(), std::pair(w, 0), [](const auto& a, const auto& b){return a.first < b.first;})};\\n            if(it != dnp.begin()) sum += (--it)->second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        std::vector<std::pair<int,int>> dnp;\\n        int size{(int)difficulty.size()};\\n        for(int i{0}; i < size; ++i) dnp.emplace_back(difficulty[i], profit[i]);\\n        std::sort(dnp.begin(), dnp.end(), [](const auto& a, const auto& b){return a.first < b.first;});\\n        for(int i{0}, max_{0}; i < size; ++i) {\\n            max_ = std::max(max_, dnp[i].second);\\n            dnp[i].second = max_;\\n        }\\n\\n        int sum{0};\\n        for(const auto &w: worker) {\\n            int tmp = sum;\\n            auto it{std::upper_bound(dnp.begin(), dnp.end(), std::pair(w, 0), [](const auto& a, const auto& b){return a.first < b.first;})};\\n            if(it != dnp.begin()) sum += (--it)->second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069376,
                "title": "python-sort-binary-search",
                "content": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        D = collections.defaultdict(list)\\n        for i in range(len(profit)):\\n            D[difficulty[i]].append(profit[i])\\n        dif = sorted(set(difficulty))\\n        prof = [None] * len(dif)\\n        maxGlobal = 0\\n        for i, n in enumerate(dif):\\n            maxLocal = max(D[n])\\n            if maxLocal > maxGlobal:\\n                maxGlobal = maxLocal\\n                prof[i] = maxGlobal\\n            else:\\n                prof[i] = maxGlobal\\n        res = 0\\n        for w in worker:\\n            idx = bisect_left(dif, w)\\n            flag = False\\n            if idx >= len(dif): \\n                idx -= 1\\n                flag = True\\n            if dif[idx] == w:\\n                res += prof[idx]\\n            else:\\n                if flag:\\n                    res += prof[idx]\\n                else:\\n                    idx -= 1\\n                    if idx < 0: continue\\n                    res += prof[idx]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        D = collections.defaultdict(list)\\n        for i in range(len(profit)):\\n            D[difficulty[i]].append(profit[i])\\n        dif = sorted(set(difficulty))\\n        prof = [None] * len(dif)\\n        maxGlobal = 0\\n        for i, n in enumerate(dif):\\n            maxLocal = max(D[n])\\n            if maxLocal > maxGlobal:\\n                maxGlobal = maxLocal\\n                prof[i] = maxGlobal\\n            else:\\n                prof[i] = maxGlobal\\n        res = 0\\n        for w in worker:\\n            idx = bisect_left(dif, w)\\n            flag = False\\n            if idx >= len(dif): \\n                idx -= 1\\n                flag = True\\n            if dif[idx] == w:\\n                res += prof[idx]\\n            else:\\n                if flag:\\n                    res += prof[idx]\\n                else:\\n                    idx -= 1\\n                    if idx < 0: continue\\n                    res += prof[idx]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060394,
                "title": "java-memorization-very-easy-to-understand",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] temp = new int[100000];\\n        for(int i=0; i<difficulty.length; i++) {\\n          temp[difficulty[i]] =  Math.max(profit[i], temp[difficulty[i]]);    \\n        }\\n        \\n        for(int i=1; i<temp.length; i++) {\\n          temp[i] = Math.max(temp[i-1], temp[i]);\\n          \\n        }\\n        int result =0;\\n        for(int i=0; i<worker.length; i++) {\\n            result += temp[worker[i]];\\n        }\\n        return result;\\n    }\\n\\t\\n\\t\\nRuntime: 11 ms, faster than 96.37% of Java online submissions for Most Profit Assigning Work.\\nMemory Usage: 40.1 MB, less than 83.69% of Java online submissions for Most Profit Assigning Work.",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] temp = new int[100000];\\n        for(int i=0; i<difficulty.length; i++) {\\n          temp[difficulty[i]] =  Math.max(profit[i], temp[difficulty[i]]);    \\n        }\\n        \\n        for(int i=1; i<temp.length; i++) {\\n          temp[i] = Math.max(temp[i-1], temp[i]);\\n          \\n        }\\n        int result =0;\\n        for(int i=0; i<worker.length; i++) {\\n            result += temp[worker[i]];\\n        }\\n        return result;\\n    }\\n\\t\\n\\t\\nRuntime: 11 ms, faster than 96.37% of Java online submissions for Most Profit Assigning Work.\\nMemory Usage: 40.1 MB, less than 83.69% of Java online submissions for Most Profit Assigning Work.",
                "codeTag": "Unknown"
            },
            {
                "id": 1015778,
                "title": "java-super-easy-sort-by-profit",
                "content": "1. Sort by profit\\n2. Two pointers: count backwards, to make sure better worker gets better profit. If the better worker can\\'t do job[i], the worse one can\\'t either. \\n\\n```\\nclass Solution {\\n    \\n    class Job {\\n        public int d;\\n        public int p;\\n        Job(int difficulty, int profit) {\\n            this.d = difficulty;\\n            this.p = profit;\\n        }\\n    }\\n    \\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        // Edge case\\n        if(difficulty.length == 0 || profit.length == 0 || worker.length == 0) return 0;\\n        \\n        // Translate to job\\n        Job[] jobs = new Job[difficulty.length];\\n        for(int i = 0; i < jobs.length; i++) {\\n            jobs[i] = new Job(difficulty[i], profit[i]);\\n        }\\n        \\n        // Sort \\n        Arrays.sort(jobs, (Job a, Job b) -> (a.p - b.p));\\n        Arrays.sort(worker);\\n        \\n        // Two pointers\\n        int res = 0;\\n        int i = jobs.length - 1, j = worker.length - 1;\\n        while(j >= 0 && i >= 0) {\\n            if(jobs[i].d > worker[j]) i--;\\n            else if(jobs[i].d <= worker[j]) {\\n                res += jobs[i].p;\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Job {\\n        public int d;\\n        public int p;\\n        Job(int difficulty, int profit) {\\n            this.d = difficulty;\\n            this.p = profit;\\n        }\\n    }\\n    \\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        // Edge case\\n        if(difficulty.length == 0 || profit.length == 0 || worker.length == 0) return 0;\\n        \\n        // Translate to job\\n        Job[] jobs = new Job[difficulty.length];\\n        for(int i = 0; i < jobs.length; i++) {\\n            jobs[i] = new Job(difficulty[i], profit[i]);\\n        }\\n        \\n        // Sort \\n        Arrays.sort(jobs, (Job a, Job b) -> (a.p - b.p));\\n        Arrays.sort(worker);\\n        \\n        // Two pointers\\n        int res = 0;\\n        int i = jobs.length - 1, j = worker.length - 1;\\n        while(j >= 0 && i >= 0) {\\n            if(jobs[i].d > worker[j]) i--;\\n            else if(jobs[i].d <= worker[j]) {\\n                res += jobs[i].p;\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002260,
                "title": "c-map-and-two-pointers-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int, int> myMap;\\n        \\n        for (int i = 0; i < difficulty.size(); i++)\\n            myMap[difficulty[i]] = max(myMap[difficulty[i]], profit[i]);\\n        \\n        sort(worker.begin(), worker.end());\\n        \\n        auto it = myMap.begin();\\n        int i = 0;\\n        int curMaxProfit = 0, totalProfit = 0;\\n        \\n        while (i < worker.size()) {\\n            if (it == myMap.end() or worker[i] < it->first) {\\n                totalProfit += curMaxProfit;\\n                i++;\\n            }\\n            else {\\n                curMaxProfit = max(curMaxProfit, it->second);\\n                it++; \\n            }              \\n        }\\n        \\n        return totalProfit;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int, int> myMap;\\n        \\n        for (int i = 0; i < difficulty.size(); i++)\\n            myMap[difficulty[i]] = max(myMap[difficulty[i]], profit[i]);\\n        \\n        sort(worker.begin(), worker.end());\\n        \\n        auto it = myMap.begin();\\n        int i = 0;\\n        int curMaxProfit = 0, totalProfit = 0;\\n        \\n        while (i < worker.size()) {\\n            if (it == myMap.end() or worker[i] < it->first) {\\n                totalProfit += curMaxProfit;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 934864,
                "title": "python3-two-approaches",
                "content": "Approach 1 - binary search \\nMaintain a mapping from (sorted) difficulty to max profit within this category. Given `worker`, binary search the max profit so that `difficulty <= worker`. \\n\\nImplementation \\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        mp = {}\\n        mx = 0\\n        for x, y in sorted(zip(difficulty, profit)):\\n            mp[x] = max(mp.get(x, 0), mx := max(mx, y))\\n        arr = list(mp.keys()) # ordered since 3.6\\n        \\n        ans = 0 \\n        for x in worker: \\n            i = bisect_right(arr, x) - 1\\n            if 0 <= i < len(arr): ans += mp[arr[i]]\\n        return ans \\n```\\n\\nApproach 2 - sorting \\nA smarter implementation of similar idea given by @lee215 in this [post](https://leetcode.com/problems/most-profit-assigning-work/discuss/127031/C%2B%2BJavaPython-Sort-and-Two-pointer). \\n\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        job = sorted(zip(difficulty, profit))\\n        ans = i = mx = 0 \\n        for w in sorted(worker): \\n            while i < len(job) and job[i][0] <= w: \\n                mx = max(mx, job[i][1])\\n                i += 1\\n            ans += mx \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        mp = {}\\n        mx = 0\\n        for x, y in sorted(zip(difficulty, profit)):\\n            mp[x] = max(mp.get(x, 0), mx := max(mx, y))\\n        arr = list(mp.keys()) # ordered since 3.6\\n        \\n        ans = 0 \\n        for x in worker: \\n            i = bisect_right(arr, x) - 1\\n            if 0 <= i < len(arr): ans += mp[arr[i]]\\n        return ans \\n```\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        job = sorted(zip(difficulty, profit))\\n        ans = i = mx = 0 \\n        for w in sorted(worker): \\n            while i < len(job) and job[i][0] <= w: \\n                mx = max(mx, job[i][1])\\n                i += 1\\n            ans += mx \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 912152,
                "title": "c-easy-solution-using-sorting-and-two-pointer-technique",
                "content": "we divide the problem into two processes: 1.sort work, difficulty and profit. 2. two-pointer technique traversing to find result\\n```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    int res = 0, curMax = 0, m = (int)worker.size(), n = (int)difficulty.size();\\n    // sort difficuty-profit and worker\\n    sort(worker.begin(), worker.end());\\n    vector<pair<int, int>> diffProf(n);\\n    for (int i = 0; i < n; i++){\\n        diffProf[i].first = difficulty[i];\\n        diffProf[i].second = profit[i];\\n    }\\n    sort(diffProf.begin(), diffProf.end());\\n    // two-pointer traversing, i for worker, j for diffProf\\n    int i = 0, j = 0;\\n    while (i < m) {\\n        while (j < n && worker[i] >= diffProf[j].first)\\n        {\\n            curMax = max(curMax, diffProf[j].second);\\n            j++;\\n        }\\n        res += curMax;\\n        i++;\\n    }\\n    return res;\\n}",
                "solutionTags": [],
                "code": "we divide the problem into two processes: 1.sort work, difficulty and profit. 2. two-pointer technique traversing to find result\\n```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    int res = 0, curMax = 0, m = (int)worker.size(), n = (int)difficulty.size();\\n    // sort difficuty-profit and worker\\n    sort(worker.begin(), worker.end());\\n    vector<pair<int, int>> diffProf(n);\\n    for (int i = 0; i < n; i++){\\n        diffProf[i].first = difficulty[i];\\n        diffProf[i].second = profit[i];\\n    }\\n    sort(diffProf.begin(), diffProf.end());\\n    // two-pointer traversing, i for worker, j for diffProf\\n    int i = 0, j = 0;\\n    while (i < m) {\\n        while (j < n && worker[i] >= diffProf[j].first)\\n        {\\n            curMax = max(curMax, diffProf[j].second);\\n            j++;\\n        }\\n        res += curMax;\\n        i++;\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 906712,
                "title": "java-treemap-solution",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer,Integer> treemap = new TreeMap<>();\\n        for(int i = 0; i < difficulty.length; i++) {\\n            treemap.put(difficulty[i], Math.max(profit[i], treemap.getOrDefault(difficulty[i], 0)));\\n        }\\n        \\n        int max = 0, res = 0;\\n        for(Integer key : treemap.keySet()) {\\n            max = Math.max(treemap.get(key), max);\\n            treemap.put(key, max);\\n        }\\n       \\n        for(int i = 0; i < worker.length; i++){\\n            Integer key = treemap.floorKey(worker[i]);\\n             if(key != null)\\n                 res += treemap.get(key);\\n               }\\n            \\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer,Integer> treemap = new TreeMap<>();\\n        for(int i = 0; i < difficulty.length; i++) {\\n            treemap.put(difficulty[i], Math.max(profit[i], treemap.getOrDefault(difficulty[i], 0)));\\n        }\\n        \\n        int max = 0, res = 0;\\n        for(Integer key : treemap.keySet()) {\\n            max = Math.max(treemap.get(key), max);\\n            treemap.put(key, max);\\n        }\\n       \\n        for(int i = 0; i < worker.length; i++){\\n            Integer key = treemap.floorKey(worker[i]);\\n             if(key != null)\\n                 res += treemap.get(key);\\n               }\\n            \\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 808144,
                "title": "c",
                "content": "` ` `\\nclass Solution {\\npublic:\\n    \\n    int binary_search(vector<int>&p, int w){\\n        \\n        int n = p.size()-1;\\n        int l= 0;\\n        if(p[0]> w)\\n            return -1;\\n        int ans = 0;\\n        while(l<=n){\\n            int mid = (l+n)/2;\\n            \\n            if(p[mid]<=w){\\n                ans = mid;\\n                l = mid+1;\\n            }\\n            else\\n                n = mid -1 ;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int maxProfitAssignment(vector<int>& d, vector<int>& pr, vector<int>& w) {\\n        \\n        int n = d.size();\\n        vector<pair<int,int>> p(n);\\n        \\n        for(int i=0;i<n;i++){\\n            p[i] = {d[i],pr[i]};\\n        }\\n        \\n        sort(d.begin(),d.end());\\n        \\n        sort(p.begin(),p.end());\\n        for(int i=1;i<n;i++){\\n            p[i].second = max(p[i].second,p[i-1].second);\\n        }\\n        \\n        int res =0;\\n        \\n        for(int i =0;i<w.size();i++){\\n            int it = binary_search(d,w[i]);\\n            //cout<<it<<\" \";\\n            if(it>=0){\\n                //cout<<p[it].second<<\" \";\\n                res += p[it].second;\\n            }\\n                \\n        }\\n        \\n        return res;\\n                \\n    }\\n};\\n` ` `",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int binary_search(vector<int>&p, int w){\\n        \\n        int n = p.size()-1;\\n        int l= 0;\\n        if(p[0]> w)\\n            return -1;\\n        int ans = 0;\\n        while(l<=n){\\n            int mid = (l+n)/2;\\n            \\n            if(p[mid]<=w){\\n                ans = mid;\\n                l = mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 754240,
                "title": "c-simle-sort-and-run",
                "content": "Just sort by profit and try to gain as much profit as possible\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pro, vector<int>& worker) \\n    {\\n        int n=dif.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++) v[i]={pro[i],dif[i]};\\n        // sort by profit descending\\n        sort(v.begin(),v.end(),greater<pair<int,int>>());\\n        // sort ability in descending\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        // ans is final answer, j is current worker\\'s index\\n        int j=0,ans=0;\\n\\t\\t// iterate over jobs\\n        for(int i=0;i<n;)\\n        {\\n            // no more workers left\\n            if(j>=worker.size()) break;\\n            // worker j can do task i\\n            if(worker[j]>=v[i].second) {ans+=v[i].first; j++;}\\n            // else goto next task\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pro, vector<int>& worker) \\n    {\\n        int n=dif.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++) v[i]={pro[i],dif[i]};\\n        // sort by profit descending\\n        sort(v.begin(),v.end(),greater<pair<int,int>>());\\n        // sort ability in descending\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        // ans is final answer, j is current worker\\'s index\\n        int j=0,ans=0;\\n\\t\\t// iterate over jobs\\n        for(int i=0;i<n;)\\n        {\\n            // no more workers left\\n            if(j>=worker.size()) break;\\n            // worker j can do task i\\n            if(worker[j]>=v[i].second) {ans+=v[i].first; j++;}\\n            // else goto next task\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680822,
                "title": "python-an-o-n-logn-solution",
                "content": "We sort both the works and the workers in decreasing order of profit and difficulty. Then for each worker, we try to pick the most profitable work he can take. Since we already sort the workers and the profit in terms of profit and difficulty, if worker i can take work j, then every worker coming after i can only at best take work j, or some work k with k > j. So, we can use two-pointer techniques to accumulate the result in O(N). Overall complexity: O(N logN).\\n\\n```\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        pd = list(zip(profit, difficulty))\\n        pd = sorted(pd, key = lambda x: -x[0])\\n        worker = sorted(worker, key = lambda x: -x)\\n        j, res = 0, 0\\n        for i, e in enumerate(worker):\\n            while j < len(pd) and e < pd[j][1]:\\n                j += 1\\n            if j == len(pd):\\n                return res\\n            res += pd[j][0]\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        pd = list(zip(profit, difficulty))\\n        pd = sorted(pd, key = lambda x: -x[0])\\n        worker = sorted(worker, key = lambda x: -x)\\n        j, res = 0, 0\\n        for i, e in enumerate(worker):\\n            while j < len(pd) and e < pd[j][1]:\\n                j += 1\\n            if j == len(pd):\\n                return res\\n            res += pd[j][0]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 615597,
                "title": "fast-concise-javascript-solution",
                "content": "\\n```\\nconst maxProfitAssignment = (difficultyArr, profitArr, workerArr) => {\\n    let jobMap = Array.from(difficultyArr, (x,i) => [profitArr[i], x])\\n    jobMap.sort((a,b) => b[0] - a[0]); workerArr.sort((a,b) => b - a)\\n    let totalProfit = 0\\n    let j = 0, w = 0\\n    while(j < jobMap.length && w < workerArr.length){\\n        let [profit, difficulty] = jobMap[j],\\n            worker = workerArr[w]\\n        if(difficulty > worker)j++\\n        else{\\n            totalProfit += profit\\n            w++\\n        }\\n        \\n    }\\n    return totalProfit\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxProfitAssignment = (difficultyArr, profitArr, workerArr) => {\\n    let jobMap = Array.from(difficultyArr, (x,i) => [profitArr[i], x])\\n    jobMap.sort((a,b) => b[0] - a[0]); workerArr.sort((a,b) => b - a)\\n    let totalProfit = 0\\n    let j = 0, w = 0\\n    while(j < jobMap.length && w < workerArr.length){\\n        let [profit, difficulty] = jobMap[j],\\n            worker = workerArr[w]\\n        if(difficulty > worker)j++\\n        else{\\n            totalProfit += profit\\n            w++\\n        }\\n        \\n    }\\n    return totalProfit\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520905,
                "title": "java-using-array-to-store-profit-for-each-difficulty",
                "content": "class Solution {\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] allProfit = new int[100000];\\n        int lOfJobs = difficulty.length;\\n        for(int i = 0; i < lOfJobs; i++) {\\n            if(profit[i] > allProfit[difficulty[i]]) {\\n                allProfit[difficulty[i]] = profit[i];\\n            }\\n        }\\n        \\n        int lOfAllProfit = allProfit.length;\\n        int max = allProfit[0];\\n        for(int i = 1; i < lOfAllProfit; i++) {\\n            max = Math.max(max, allProfit[i]);\\n\\t\\t\\tallProfit[i] = max;\\n        }\\n        \\n        int res = 0;\\n        int numOfWorker = worker.length;\\n        for(int i = 0; i < numOfWorker; i++) {\\n            res += allProfit[worker[i]];\\n        }\\n        return res;\\n    }\\n\\t\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] allProfit = new int[100000];\\n        int lOfJobs = difficulty.length;\\n        for(int i = 0; i < lOfJobs; i++) {\\n            if(profit[i] > allProfit[difficulty[i]]) {\\n                allProfit[difficulty[i]] = profit[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 449522,
                "title": "java-priority-queue-solution",
                "content": "```\\nclass Solution \\n{\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) \\n    {\\n        PriorityQueue<Data> pq = new PriorityQueue<>();\\n        for(int i = 0; i < difficulty.length; i++) \\n            pq.offer(new Data(difficulty[i], profit[i]));\\n        int max = 0, sum = 0;\\n        Arrays.sort(worker);\\n        for(int i = 0; i < worker.length; i++)\\n        {\\n            int ability = worker[i];\\n            while(!pq.isEmpty())\\n            {\\n                Data data = pq.peek();\\n                if(data.difficulty > ability) break;\\n                if(data.profit > max) max = data.profit;\\n                pq.poll();\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n    \\n    private class Data implements Comparable<Data>\\n    {\\n        int difficulty, profit;\\n        \\n        Data(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n        \\n        public int compareTo(Data data)\\n        {\\n            return this.difficulty - data.difficulty;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) \\n    {\\n        PriorityQueue<Data> pq = new PriorityQueue<>();\\n        for(int i = 0; i < difficulty.length; i++) \\n            pq.offer(new Data(difficulty[i], profit[i]));\\n        int max = 0, sum = 0;\\n        Arrays.sort(worker);\\n        for(int i = 0; i < worker.length; i++)\\n        {\\n            int ability = worker[i];\\n            while(!pq.isEmpty())\\n            {\\n                Data data = pq.peek();\\n                if(data.difficulty > ability) break;\\n                if(data.profit > max) max = data.profit;\\n                pq.poll();\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n    \\n    private class Data implements Comparable<Data>\\n    {\\n        int difficulty, profit;\\n        \\n        Data(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n        \\n        public int compareTo(Data data)\\n        {\\n            return this.difficulty - data.difficulty;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321714,
                "title": "java-solution-using-treemap",
                "content": "```\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        map.put(0, 0);\\n        for(int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(map.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        int max = 0;\\n        for(int key: map.keySet()) {\\n            max = Math.max(max, map.get(key));\\n            map.put(key, max);\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        map.put(0, 0);\\n        for(int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(map.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        int max = 0;\\n        for(int key: map.keySet()) {\\n            max = Math.max(max, map.get(key));\\n            map.put(key, max);\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267878,
                "title": "super-simple-kotlin-solution-faster-then-100",
                "content": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n\\n        val diffProfit =\\n            difficulty\\n                .zip(profit)\\n                .sortedByDescending { it.second }\\n\\n        return worker\\n            .map { workerMax ->\\n                diffProfit.find { it.first <= workerMax }\\n                    ?.second ?: 0\\n            }.sum()\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n\\n        val diffProfit =\\n            difficulty\\n                .zip(profit)\\n                .sortedByDescending { it.second }\\n\\n        return worker\\n            .map { workerMax ->\\n                diffProfit.find { it.first <= workerMax }\\n                    ?.second ?: 0\\n            }.sum()\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254762,
                "title": "treemap-simple-solution",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t//initialize difficult to profit map\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\tfor(int i=0;i<difficulty.length;i++){\\n\\t\\tmap.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i],0)));\\n\\t}\\n\\t//difficult jobs should have at least easier job\\'s profit \\n\\tint max =0;\\n\\tfor(Integer sortedDifficulty:map.keySet()){\\n\\t\\tmap.put(sortedDifficulty, Math.max(max, map.get(sortedDifficulty)));\\n\\t\\tmax = map.get(sortedDifficulty);\\n\\t}\\n\\t//add each profit to the result\\n\\tint result = 0;\\n\\tfor(int i=0;i<worker.length;i++){\\n\\t\\tif(map.floorKey(worker[i]) != null){\\n\\t\\t\\tresult += map.get(map.floorKey(worker[i]));\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t//initialize difficult to profit map\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\tfor(int i=0;i<difficulty.length;i++){\\n\\t\\tmap.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i],0)));\\n\\t}\\n\\t//difficult jobs should have at least easier job\\'s profit \\n\\tint max =0;\\n\\tfor(Integer sortedDifficulty:map.keySet()){\\n\\t\\tmap.put(sortedDifficulty, Math.max(max, map.get(sortedDifficulty)));\\n\\t\\tmax = map.get(sortedDifficulty);\\n\\t}\\n\\t//add each profit to the result\\n\\tint result = 0;\\n\\tfor(int i=0;i<worker.length;i++){\\n\\t\\tif(map.floorKey(worker[i]) != null){\\n\\t\\t\\tresult += map.get(map.floorKey(worker[i]));\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205773,
                "title": "python-sorting-and-two-pointers",
                "content": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        job = sorted(list(zip(profit, difficulty)), reverse = True)\\n        worker.sort(reverse = True)\\n        \\n        i = j = 0\\n        total = 0\\n        while i < len(worker) and j < len(job):\\n            if worker[i] >= job[j][1]:\\n                total += job[j][0]\\n                i += 1\\n            else:\\n                j += 1\\n        return total\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        job = sorted(list(zip(profit, difficulty)), reverse = True)\\n        worker.sort(reverse = True)\\n        \\n        i = j = 0\\n        total = 0\\n        while i < len(worker) and j < len(job):\\n            if worker[i] >= job[j][1]:\\n                total += job[j][0]\\n                i += 1\\n            else:\\n                j += 1\\n        return total\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 202734,
                "title": "c-javascript-two-pointer-binary-search-solution",
                "content": "C++ Binary Search\\n```\\nclass Solution {\\npublic:\\n    int findProfit(vector<pair<int,int> >& jobs,int target){\\n        \\n        int low=0;\\n        int high=jobs.size()-1;\\n       \\n        while(low+1<high){\\n            int mid=low+((high-low)>>1);\\n    \\n            if(target>=jobs[mid].first){\\n                low=mid;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n        if(target>=jobs[high].first) return jobs[high].second;\\n        if(target>=jobs[low].first) return jobs[low].second;\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        for(int i=1;i<jobs.size();i++){\\n            jobs[i].second=max(jobs[i].second,jobs[i-1].second);\\n        }\\n        for(auto work:worker){\\n            out+=findProfit(jobs,work);\\n        }\\n        return out;\\n    }\\n};\\n```\\n\\nC++ Two Pointers Solution\\n```\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        sort(worker.begin(),worker.end());\\n        int i=0,maxP=0;\\n        for(auto work:worker){\\n            while(i<jobs.size() && work>=jobs[i].first) maxP=max(maxP,jobs[i++].second);\\n            out+=maxP;\\n        }\\n        return out;\\n    }\\n```\\n\\nJavaScript Two Pointers Solution\\n```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    difficulty.forEach(function(value,index){\\n        p[index]=[difficulty[index],profit[index]];\\n    });\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    \\n    let i=0,maxP=0;\\n    worker.sort((a,b)=>a-b);\\n    for(let work of worker){\\n        while(i<p.length && work>=p[i][0])maxP=Math.max(p[i++][1],maxP)\\n        out+=maxP;\\n        \\n    }\\n    return out;\\n};\\n```\\n\\nJavaScript Binary Search\\n```\\nlet findProfit= function(difficulty,target){\\n\\n    let low=0;\\n    let high=difficulty.length-1;\\n\\n    while(low+1<high){\\n        let mid=low+((high-low)>>1);\\n\\n        if(target>=difficulty[mid][0]){\\n            low=mid;\\n        }else{\\n            high=mid;\\n        }\\n    }\\n    if(target>=difficulty[high][0]) return difficulty[high][1];\\n    if(target>=difficulty[low][0]) return difficulty[low][1];\\n\\n    return 0;\\n}\\n    \\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    for(let i=0;i<difficulty.length;i++){\\n        p[i]=[difficulty[i],profit[i]];\\n    }\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    for(let i=1;i<p.length;i++){\\n        p[i][1]=Math.max(p[i][1],p[i-1][1]);\\n    }\\n    for(let work of worker){\\n        out+=findProfit(p,work);\\n    }\\n    return out;\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findProfit(vector<pair<int,int> >& jobs,int target){\\n        \\n        int low=0;\\n        int high=jobs.size()-1;\\n       \\n        while(low+1<high){\\n            int mid=low+((high-low)>>1);\\n    \\n            if(target>=jobs[mid].first){\\n                low=mid;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n        if(target>=jobs[high].first) return jobs[high].second;\\n        if(target>=jobs[low].first) return jobs[low].second;\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        for(int i=1;i<jobs.size();i++){\\n            jobs[i].second=max(jobs[i].second,jobs[i-1].second);\\n        }\\n        for(auto work:worker){\\n            out+=findProfit(jobs,work);\\n        }\\n        return out;\\n    }\\n};\\n```\n```\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        sort(worker.begin(),worker.end());\\n        int i=0,maxP=0;\\n        for(auto work:worker){\\n            while(i<jobs.size() && work>=jobs[i].first) maxP=max(maxP,jobs[i++].second);\\n            out+=maxP;\\n        }\\n        return out;\\n    }\\n```\n```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    difficulty.forEach(function(value,index){\\n        p[index]=[difficulty[index],profit[index]];\\n    });\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    \\n    let i=0,maxP=0;\\n    worker.sort((a,b)=>a-b);\\n    for(let work of worker){\\n        while(i<p.length && work>=p[i][0])maxP=Math.max(p[i++][1],maxP)\\n        out+=maxP;\\n        \\n    }\\n    return out;\\n};\\n```\n```\\nlet findProfit= function(difficulty,target){\\n\\n    let low=0;\\n    let high=difficulty.length-1;\\n\\n    while(low+1<high){\\n        let mid=low+((high-low)>>1);\\n\\n        if(target>=difficulty[mid][0]){\\n            low=mid;\\n        }else{\\n            high=mid;\\n        }\\n    }\\n    if(target>=difficulty[high][0]) return difficulty[high][1];\\n    if(target>=difficulty[low][0]) return difficulty[low][1];\\n\\n    return 0;\\n}\\n    \\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    for(let i=0;i<difficulty.length;i++){\\n        p[i]=[difficulty[i],profit[i]];\\n    }\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    for(let i=1;i<p.length;i++){\\n        p[i][1]=Math.max(p[i][1],p[i-1][1]);\\n    }\\n    for(let work of worker){\\n        out+=findProfit(p,work);\\n    }\\n    return out;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188589,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n        val costAndProfit = (0 until difficulty.size)\\n                .map { Pair(difficulty[it], profit[it]) }\\n                .sortedBy { it.first }\\n                .groupBy { it.first }\\n                .map { it -> Pair(it.key, it.value.maxBy { it.second }!!.second) }\\n        \\n        val prefixMaxProfit = IntArray(costAndProfit.size)\\n        (0 until prefixMaxProfit.size).forEach {\\n            when (it) {\\n                0 -> prefixMaxProfit[it] = costAndProfit[0].second\\n                else -> prefixMaxProfit[it] = Math.max(prefixMaxProfit[it - 1], costAndProfit[it].second)\\n            }\\n        }\\n        \\n        return worker.sumBy { ability ->\\n            val insertAt = costAndProfit.binarySearchBy(ability, 0, costAndProfit.size) { it.first }\\n            when {\\n                insertAt >= 0 -> prefixMaxProfit[insertAt]\\n                insertAt == -1 -> 0\\n                else -> prefixMaxProfit[-insertAt - 2]\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n        val costAndProfit = (0 until difficulty.size)\\n                .map { Pair(difficulty[it], profit[it]) }\\n                .sortedBy { it.first }\\n                .groupBy { it.first }\\n                .map { it -> Pair(it.key, it.value.maxBy { it.second }!!.second) }\\n        \\n        val prefixMaxProfit = IntArray(costAndProfit.size)\\n        (0 until prefixMaxProfit.size).forEach {\\n            when (it) {\\n                0 -> prefixMaxProfit[it] = costAndProfit[0].second\\n                else -> prefixMaxProfit[it] = Math.max(prefixMaxProfit[it - 1], costAndProfit[it].second)\\n            }\\n        }\\n        \\n        return worker.sumBy { ability ->\\n            val insertAt = costAndProfit.binarySearchBy(ability, 0, costAndProfit.size) { it.first }\\n            when {\\n                insertAt >= 0 -> prefixMaxProfit[insertAt]\\n                insertAt == -1 -> 0\\n                else -> prefixMaxProfit[-insertAt - 2]\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164351,
                "title": "simple-java-solution-using-priority-queue",
                "content": "```\\n    public static int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> (a[0]-b[0]));\\n        int n = profit.length, t=0, cur=0;\\n        Arrays.sort(worker);\\n        \\n        for(int i=0;i<n;i++){\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        \\n        for(int i=0;i<worker.length;i++){\\n            while(!pq.isEmpty() && worker[i] >= pq.peek()[0]){\\n                cur = Math.max(cur, pq.poll()[1]);\\n            }\\n            t += cur;\\n        }\\n        \\n        return t;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> (a[0]-b[0]));\\n        int n = profit.length, t=0, cur=0;\\n        Arrays.sort(worker);\\n        \\n        for(int i=0;i<n;i++){\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        \\n        for(int i=0;i<worker.length;i++){\\n            while(!pq.isEmpty() && worker[i] >= pq.peek()[0]){\\n                cur = Math.max(cur, pq.poll()[1]);\\n            }\\n            t += cur;\\n        }\\n        \\n        return t;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 130307,
                "title": "c-nlogn-solution-greedy-using-map-and-sort",
                "content": "```\\n#include <vector>\\n#include <algorithm>\\n#include <vector>\\n#include <algorithm>\\n#include <functional>\\n#include <map>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int,greater<int>> m;\\n        for(int i = 0 ; i < difficulty.size() ; i++)\\n                {\\n                  m[profit[i]] =( m[profit[i]] > difficulty[i] ) ||  m[profit[i]] == 0 ? difficulty[i] : m[profit[i]];\\n                }\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        int ans = 0;\\n        auto iter = m.begin();\\n        for(int i = 0 ; i < worker.size() ; i++)\\n        {\\n          while(iter != m.end() && worker[i] < iter->second ) iter =  m.erase(iter);\\n                ans += iter == m.end() ? 0 : iter->first;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThe key thought is sort and \\n1.if worker_i.ablity > worker_j.ablity && worker_i cannot finish job_k , the work_j cannot finish job_k either.\\n2.if job_m.profit == job_n.profit && job_m.difficulty < job_n.difficulty , then no one will select job_n.\\nSo use sort is a very good way .",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n#include <vector>\\n#include <algorithm>\\n#include <functional>\\n#include <map>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int,greater<int>> m;\\n        for(int i = 0 ; i < difficulty.size() ; i++)\\n                {\\n                  m[profit[i]] =( m[profit[i]] > difficulty[i] ) ||  m[profit[i]] == 0 ? difficulty[i] : m[profit[i]];\\n                }\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        int ans = 0;\\n        auto iter = m.begin();\\n        for(int i = 0 ; i < worker.size() ; i++)\\n        {\\n          while(iter != m.end() && worker[i] < iter->second ) iter =  m.erase(iter);\\n                ans += iter == m.end() ? 0 : iter->first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 129241,
                "title": "c-sort-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>>v;\\n        for(int i = 0; i < difficulty.size(); i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [](vector<int>& v1, vector<int>& v2){ return v1[0] < v2[0]; });\\n        int maxProfit = 0;\\n        for(auto& x: v){\\n            maxProfit = max(maxProfit, x[1]);\\n            x[1] = maxProfit;\\n        }\\n        for(auto& x: worker){\\n            int pos = upper_bound(v.begin(), v.end(), x, [](int v1, vector<int>& v2){ return v1 < v2[0]; }) - v.begin() - 1;\\n            if(pos >= 0) res += v[pos][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>>v;\\n        for(int i = 0; i < difficulty.size(); i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [](vector<int>& v1, vector<int>& v2){ return v1[0] < v2[0]; });\\n        int maxProfit = 0;\\n        for(auto& x: v){\\n            maxProfit = max(maxProfit, x[1]);\\n            x[1] = maxProfit;\\n        }\\n        for(auto& x: worker){\\n            int pos = upper_bound(v.begin(), v.end(), x, [](int v1, vector<int>& v2){ return v1 < v2[0]; }) - v.begin() - 1;\\n            if(pos >= 0) res += v[pos][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127873,
                "title": "c-o-n-using-map",
                "content": "using map to remove possible same level with different profit, and then sort according to the difficulty.\\nsort the worker and using two pointer method to loop. The complxity is O(n+m)\\nThe max_profit is the max profit so far at difficulty level. This is to handle the case when the difficulty is higher, but profit is lower.\\nI add a INT_MAX diffcult at the map so that we can handle the worker>the max difficulty case.\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int> vp;\\n        for(int i=0;i<profit.size();i++) vp[difficulty[i]]=max(vp[difficulty[i]],profit[i]);\\n        vp[INT_MAX]=0;//add one as the end so worker>max can work\\n        sort(worker.begin(),worker.end());\\n        int i=0,max_profit=0,total=0; //max shall be 0\\n        for(auto it=vp.begin();it!=vp.end();it++)\\n        {\\n            while(it->first>worker[i])\\n            {\\n                total+=max_profit;i++;\\n                if(i>=worker.size()) break;\\n            }\\n            if(i>=worker.size()) break;\\n            max_profit=max(max_profit,it->second);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int> vp;\\n        for(int i=0;i<profit.size();i++) vp[difficulty[i]]=max(vp[difficulty[i]],profit[i]);\\n        vp[INT_MAX]=0;//add one as the end so worker>max can work\\n        sort(worker.begin(),worker.end());\\n        int i=0,max_profit=0,total=0; //max shall be 0\\n        for(auto it=vp.begin();it!=vp.end();it++)\\n        {\\n            while(it->first>worker[i])\\n            {\\n                total+=max_profit;i++;\\n                if(i>=worker.size()) break;\\n            }\\n            if(i>=worker.size()) break;\\n            max_profit=max(max_profit,it->second);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127151,
                "title": "java-accepted-solution",
                "content": "Sort and assign.\\n\\n```\\nclass Solution {\\n    private class Task {\\n        int diff;\\n        int pro;\\n        public Task(int d, int p) {\\n            diff = d;\\n            pro = p;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Task> tasks = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            tasks.add(new Task(difficulty[i], profit[i]));\\n        }\\n        \\n        Collections.sort(tasks, (a, b) -> b.pro - a.pro);\\n        int res = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            for (Task t : tasks) {\\n                if (t.diff <= worker[i]) {\\n                    res += t.pro;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private class Task {\\n        int diff;\\n        int pro;\\n        public Task(int d, int p) {\\n            diff = d;\\n            pro = p;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Task> tasks = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            tasks.add(new Task(difficulty[i], profit[i]));\\n        }\\n        \\n        Collections.sort(tasks, (a, b) -> b.pro - a.pro);\\n        int res = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            for (Task t : tasks) {\\n                if (t.diff <= worker[i]) {\\n                    res += t.pro;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127114,
                "title": "concise-java-solution-using-map",
                "content": "```\\n public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int maxD = 0;\\n        for(int i = 0;i<difficulty.length;++i){\\n            if(!map.containsKey(difficulty[i])) map.put(difficulty[i],profit[i]);   \\n            else map.put(difficulty[i],Math.max(map.get(difficulty[i]),profit[i])); \\n            maxD = Math.max(maxD,difficulty[i]);     \\n        }    \\n        int[] p =  new int[maxD + 1];\\n        for(int i=1;i<p.length;++i){\\n            p[i] = Math.max(p[i-1],map.getOrDefault(i,0));  // max profit for difficulty in [1,maxD]\\n        }\\n        \\n        int maxP = 0;\\n        for(int i=0;i<worker.length;++i){\\n            maxP+= worker[i] > maxD? p[maxD] : p[worker[i]];\\n        }\\n        return maxP;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int maxD = 0;\\n        for(int i = 0;i<difficulty.length;++i){\\n            if(!map.containsKey(difficulty[i])) map.put(difficulty[i],profit[i]);   \\n            else map.put(difficulty[i],Math.max(map.get(difficulty[i]),profit[i])); \\n            maxD = Math.max(maxD,difficulty[i]);     \\n        }    \\n        int[] p =  new int[maxD + 1];\\n        for(int i=1;i<p.length;++i){\\n            p[i] = Math.max(p[i-1],map.getOrDefault(i,0));  // max profit for difficulty in [1,maxD]\\n        }\\n        \\n        int maxP = 0;\\n        for(int i=0;i<worker.length;++i){\\n            maxP+= worker[i] > maxD? p[maxD] : p[worker[i]];\\n        }\\n        return maxP;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 127028,
                "title": "java-solution-o-m-n-log-m-n-time-and-o-n-space-with-explanation-easily-understand",
                "content": "```\\n/** O O((m + n)log(m + n)) time complexity and O(n) space complexity, m is the length of workers, n is length of jobs;\\n *  sort jobs according to the profit, and sort workers\\n *  scan jobs and workers both from the end, for worker[i], decrement j if jobs[j].level is higher than worker[i];\\n *  otherwise, the current profit is highest one worker[i] can achieve, add it to the maxprofit;\\n *  for worker[i - 1], since worker[i - 1] can only complete work with difficulty less than worker[i]\\n *  so all the previous jobs pass by worker[i] will also be passed by worker[i - 1], so we don\\'t need to back up pointer j to recheck\\n */\\nclass Solution {\\n    private class Job implements Comparable<Job>{\\n        int level;\\n        int prof;\\n        \\n        public Job(int level, int prof) {\\n            this.level = level;\\n            this.prof = prof;\\n        }\\n        \\n        public int compareTo(Job that) {\\n            return this.prof - that.prof;\\n        }\\n    }\\n    \\n            \\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Arrays.sort(worker);\\n        int n = difficulty.length;\\n        Job[] jobs = new Job[n];\\n        for (int i = 0; i < n; i++) {\\n            jobs[i] = new Job(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(jobs);\\n        int max = 0;\\n        \\n        int i = worker.length - 1, j = jobs.length - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (jobs[j].level > worker[i]) j--;\\n            else {\\n                max += jobs[j].prof;\\n                i--;\\n            }\\n        }\\n        return max;     \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private class Job implements Comparable<Job>{\\n        int level;\\n        int prof;\\n        \\n        public Job(int level, int prof) {\\n            this.level = level;\\n            this.prof = prof;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 126988,
                "title": "o-m-n-solution-based-on-preprocessing",
                "content": "Just keep a preprocess array for max profit until difficulty[index]\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] diff = new int[100000 + 1]; //10^5\\n        //diff[i] = maxProfit until difficulty i (inclusive)\\n        for(int i = 0; i < difficulty.length; ++i){\\n            diff[difficulty[i]] = Math.max(diff[difficulty[i]], profit[i]);\\n        }\\n        \\n        for(int i = 1; i < diff.length; ++i){\\n            diff[i] = Math.max(diff[i], diff[i - 1]);\\n        }\\n        int sol = 0;\\n        \\n        for(int x : worker) sol += diff[x];\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] diff = new int[100000 + 1]; //10^5\\n        //diff[i] = maxProfit until difficulty i (inclusive)\\n        for(int i = 0; i < difficulty.length; ++i){\\n            diff[difficulty[i]] = Math.max(diff[difficulty[i]], profit[i]);\\n        }\\n        \\n        for(int i = 1; i < diff.length; ++i){\\n            diff[i] = Math.max(diff[i], diff[i - 1]);\\n        }\\n        int sol = 0;\\n        \\n        for(int x : worker) sol += diff[x];\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126987,
                "title": "easy-to-understand-java-solution-with-priorityqueue-detail-explanation",
                "content": "This problem seems easy at first glance, but it does not provide too much details. Now consider, if a lower difficulty task has a higher profit, or two same difficulty tasks have different profits, then simply sorting the arrays and putting them into a map will not yield the most profit (sometimes it may work?). So I used a PriorityQueue to sort based on the profit (descending), and if there are same profits, then sort by their corresponding difficulties (descending). \\nNow sort the workers array. Check if their abilities are sufficient to do the work (pq.peek()). This way, it will certainly yield the highest profit.\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t\\t// sort the profit and difficulty arrays based on profit value and then difficulty values.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] > b[0]) return -1;\\n                else if (a[0] < b[0]) return 1;\\n                else return b[1] - a[1];\\n            }\\n        });\\n        for (int i = 0; i < profit.length; i++) {\\n            pq.offer(new int[]{profit[i], difficulty[i]});\\n        }\\n        Arrays.sort(worker);\\n        int res = 0;\\n\\t\\t\\t\\t// check workers ability, if it does not match, the next object in the pq will give next highest profit with less difficulty \\n        for (int i = worker.length - 1; i >= 0; i--) {\\n            while (!pq.isEmpty() && worker[i] < pq.peek()[1]) pq.poll();\\n            if (!pq.isEmpty()) res += pq.peek()[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t\\t// sort the profit and difficulty arrays based on profit value and then difficulty values.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] > b[0]) return -1;\\n                else if (a[0] < b[0]) return 1;\\n                else return b[1] - a[1];\\n            }\\n        });\\n        for (int i = 0; i < profit.length; i++) {\\n            pq.offer(new int[]{profit[i], difficulty[i]});\\n        }\\n        Arrays.sort(worker);\\n        int res = 0;\\n\\t\\t\\t\\t// check workers ability, if it does not match, the next object in the pq will give next highest profit with less difficulty \\n        for (int i = worker.length - 1; i >= 0; i--) {\\n            while (!pq.isEmpty() && worker[i] < pq.peek()[1]) pq.poll();\\n            if (!pq.isEmpty()) res += pq.peek()[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126983,
                "title": "python-solution",
                "content": "```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        import bisect\\n        \\n        sum_=0\\n        \\n        diff_profit = [(a,b) for a,b in zip(difficulty,profit)]\\n        \\n        diff_profit=sorted(diff_profit, key=lambda a:a[0])\\n                \\n        new_diffs=[0]\\n        new_profits=[0]\\n        \\n        for i in range(len(diff_profit)):\\n            if diff_profit[i][1]>new_profits[-1]:\\n                new_profits.append(diff_profit[i][1])\\n                new_diffs.append(diff_profit[i][0])\\n\\n        \\n        for i in range(len(worker)):\\n            index= bisect.bisect(new_diffs, worker[i])\\n            # print index, worker[i]\\n            if index-1<0:\\n                continue\\n            sum_+=new_profits[index-1]\\n        return sum_\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        import bisect\\n        \\n        sum_=0\\n        \\n        diff_profit = [(a,b) for a,b in zip(difficulty,profit)]\\n        \\n        diff_profit=sorted(diff_profit, key=lambda a:a[0])\\n                \\n        new_diffs=[0]\\n        new_profits=[0]\\n        \\n        for i in range(len(diff_profit)):\\n            if diff_profit[i][1]>new_profits[-1]:\\n                new_profits.append(diff_profit[i][1])\\n                new_diffs.append(diff_profit[i][0])\\n\\n        \\n        for i in range(len(worker)):\\n            index= bisect.bisect(new_diffs, worker[i])\\n            # print index, worker[i]\\n            if index-1<0:\\n                continue\\n            sum_+=new_profits[index-1]\\n        return sum_\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 126956,
                "title": "easy-java-solution-with-treemap-sorting",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int[][] arr = new int[difficulty.length][2];\\n        for(int i=0; i < difficulty.length; i++){\\n\\t\\t\\tarr[i][0] = difficulty[i];\\n\\t\\t\\tarr[i][1] = profit[i];\\n\\t\\t}\\n        Arrays.sort(arr, new Comparator<int[]>(){\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] a1, int[] a2){\\n\\t\\t\\t\\treturn a1[0]<a2[0]? -1: a1[0] == a2[0]? 0:1;\\n\\t\\t\\t}\\n\\t\\t});\\n        for(int i=1; i<arr.length; i++){\\n\\t\\t\\tarr[i][1] = Math.max(arr[i-1][1], arr[i][1]);\\n\\t\\t}\\n\\t\\tfor(int i=0; i<arr.length; i++){\\n\\t\\t\\tmap.put(arr[i][0], arr[i][1]);\\n\\t\\t}\\n        int ans = 0;\\n\\t\\tfor(int i=0; i<worker.length; i++){\\n\\t\\t\\tint ability = worker[i];\\n\\t\\t\\tInteger index = map.floorKey(ability);\\n\\t\\t\\tif(index != null){\\n                ans+=map.get(index);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int[][] arr = new int[difficulty.length][2];\\n        for(int i=0; i < difficulty.length; i++){\\n\\t\\t\\tarr[i][0] = difficulty[i];\\n\\t\\t\\tarr[i][1] = profit[i];\\n\\t\\t}\\n        Arrays.sort(arr, new Comparator<int[]>(){\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] a1, int[] a2){\\n\\t\\t\\t\\treturn a1[0]<a2[0]? -1: a1[0] == a2[0]? 0:1;\\n\\t\\t\\t}\\n\\t\\t});\\n        for(int i=1; i<arr.length; i++){\\n\\t\\t\\tarr[i][1] = Math.max(arr[i-1][1], arr[i][1]);\\n\\t\\t}\\n\\t\\tfor(int i=0; i<arr.length; i++){\\n\\t\\t\\tmap.put(arr[i][0], arr[i][1]);\\n\\t\\t}\\n        int ans = 0;\\n\\t\\tfor(int i=0; i<worker.length; i++){\\n\\t\\t\\tint ability = worker[i];\\n\\t\\t\\tInteger index = map.floorKey(ability);\\n\\t\\t\\tif(index != null){\\n                ans+=map.get(index);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126941,
                "title": "python-binary-search-solution-with-comments",
                "content": "```\\nclass Solution(object):\\n    def maxProfitAssignment(self, diff, pro, worker):\\n        N = len(diff)\\n        # Record max profit for each difficulty\\n        dic = {}\\n        for i in range(N):\\n            if diff[i] not in dic or pro[i]>dic[diff[i]]:\\n                dic[diff[i]] = pro[i]\\n        # Sort difficult and record max profit with diff[i] in pre\\n        diff = list(set(diff))\\n        diff.sort()\\n        pre = [0]*(len(diff)+1)\\n        \\n        for i in range(len(diff)):\\n            pre[i] = max(pre[i-1], dic[diff[i]])\\n        \\n        ret = 0\\n        for w in worker:\\n            # Use binary seach for each worker\\n            idx = bisect.bisect_left(diff, w)\\n            if idx==len(diff) or w<diff[idx]:\\n                idx -= 1\\n            ret += pre[idx]\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfitAssignment(self, diff, pro, worker):\\n        N = len(diff)\\n        # Record max profit for each difficulty\\n        dic = {}\\n        for i in range(N):\\n            if diff[i] not in dic or pro[i]>dic[diff[i]]:\\n                dic[diff[i]] = pro[i]\\n        # Sort difficult and record max profit with diff[i] in pre\\n        diff = list(set(diff))\\n        diff.sort()\\n        pre = [0]*(len(diff)+1)\\n        \\n        for i in range(len(diff)):\\n            pre[i] = max(pre[i-1], dic[diff[i]])\\n        \\n        ret = 0\\n        for w in worker:\\n            # Use binary seach for each worker\\n            idx = bisect.bisect_left(diff, w)\\n            if idx==len(diff) or w<diff[idx]:\\n                idx -= 1\\n            ret += pre[idx]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096222,
                "title": "easiest-way-to-solve-using-matrix-and-greedy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    // //brute force\\n    // let resprofit=0,map=new Map();\\n    // for(let i=0;i<difficulty.length;i++){\\n    //     map.set(difficulty[i],profit[i]);\\n    // }\\n    // const getMaxProfit=(target)=>{\\n    //     let maxprofit=0;\\n    //  for(let i=0;i<difficulty.length;i++){\\n    //   if(difficulty[i]<=target){\\n    //   maxprofit=Math.max(maxprofit,map.get(difficulty[i]))\\n    //   }\\n    //   else break;\\n    //  }\\n    //  return maxprofit;\\n    // }\\n    // for(let i=0;i<worker.length;i++){\\n    //     let currworker=worker[i];\\n    //     resprofit+=getMaxProfit(currworker);\\n    // }\\n    // return resprofit;\\n\\n    //greedy approch\\n    let jobs=[];\\n    for(let i=0;i<difficulty.length;i++){\\n        jobs.push([difficulty[i],profit[i]]);\\n    }\\n    jobs.sort((a,b)=>a[0]-b[0]);\\n    worker.sort((a,b)=>a-b);\\n\\n    let maxprofit=0,jobindex=0,bestprofit=0;\\n    for(let i=0;i<worker.length;i++){\\n        let ability=worker[i];\\n        while(jobindex < difficulty.length && jobs[jobindex][0] <=ability){\\n            bestprofit=Math.max(bestprofit,jobs[jobindex][1]);\\n            jobindex++;\\n        }\\n        maxprofit+=bestprofit;\\n    }\\n    return maxprofit;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    // //brute force\\n    // let resprofit=0,map=new Map();\\n    // for(let i=0;i<difficulty.length;i++){\\n    //     map.set(difficulty[i],profit[i]);\\n    // }\\n    // const getMaxProfit=(target)=>{\\n    //     let maxprofit=0;\\n    //  for(let i=0;i<difficulty.length;i++){\\n    //   if(difficulty[i]<=target){\\n    //   maxprofit=Math.max(maxprofit,map.get(difficulty[i]))\\n    //   }\\n    //   else break;\\n    //  }\\n    //  return maxprofit;\\n    // }\\n    // for(let i=0;i<worker.length;i++){\\n    //     let currworker=worker[i];\\n    //     resprofit+=getMaxProfit(currworker);\\n    // }\\n    // return resprofit;\\n\\n    //greedy approch\\n    let jobs=[];\\n    for(let i=0;i<difficulty.length;i++){\\n        jobs.push([difficulty[i],profit[i]]);\\n    }\\n    jobs.sort((a,b)=>a[0]-b[0]);\\n    worker.sort((a,b)=>a-b);\\n\\n    let maxprofit=0,jobindex=0,bestprofit=0;\\n    for(let i=0;i<worker.length;i++){\\n        let ability=worker[i];\\n        while(jobindex < difficulty.length && jobs[jobindex][0] <=ability){\\n            bestprofit=Math.max(bestprofit,jobs[jobindex][1]);\\n            jobindex++;\\n        }\\n        maxprofit+=bestprofit;\\n    }\\n    return maxprofit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090525,
                "title": "c-sorting",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\\\log{n})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>> v;\\n        for (int i = 0; i < profit.size(); ++ i) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [] (const vector<int>& l, const vector<int>& r) {\\n            return l[0] == r[0] ? l[1] < r[1] : l[0] < r[0];\\n        });\\n        for (int i = 1; i < v.size(); ++ i) v[i][1] = max(v[i][1], v[i - 1][1]);\\n        sort(worker.begin(), worker.end());\\n        int k = 0;\\n        for (int w : worker) {\\n            while (k < v.size() && v[k][0] <= w) ++ k;\\n            if (k) -- k;\\n            if (v[k][0] <= w) res += v[k][1];\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>> v;\\n        for (int i = 0; i < profit.size(); ++ i) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [] (const vector<int>& l, const vector<int>& r) {\\n            return l[0] == r[0] ? l[1] < r[1] : l[0] < r[0];\\n        });\\n        for (int i = 1; i < v.size(); ++ i) v[i][1] = max(v[i][1], v[i - 1][1]);\\n        sort(worker.begin(), worker.end());\\n        int k = 0;\\n        for (int w : worker) {\\n            while (k < v.size() && v[k][0] <= w) ++ k;\\n            if (k) -- k;\\n            if (v[k][0] <= w) res += v[k][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055585,
                "title": "c-o-nlogn-easy-solution",
                "content": "# Complexity\\n# - Time complexity:**O(nlogn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# - Space complexity:**O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w){\\n        vector<pair<int,int>>vp;\\n        for(int i =0 ;i<(int)d.size();i++){\\n            vp.push_back(make_pair(d[i],p[i]));\\n        }\\n        sort(d.begin(),d.end()),sort(vp.begin(),vp.end());\\n        int res = 0;\\n        for(int i = 1;i<(int)vp.size();i++){\\n            vp[i].second = max(vp[i].second,vp[i-1].second);\\n        }\\n        for(int i = 0;i<(int)w.size();i++){\\n            int idx = upper_bound(d.begin(),d.end(),w[i]) - d.begin();\\n            if(idx){\\n                idx--;\\n                res+=vp[idx].second;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w){\\n        vector<pair<int,int>>vp;\\n        for(int i =0 ;i<(int)d.size();i++){\\n            vp.push_back(make_pair(d[i],p[i]));\\n        }\\n        sort(d.begin(),d.end()),sort(vp.begin(),vp.end());\\n        int res = 0;\\n        for(int i = 1;i<(int)vp.size();i++){\\n            vp[i].second = max(vp[i].second,vp[i-1].second);\\n        }\\n        for(int i = 0;i<(int)w.size();i++){\\n            int idx = upper_bound(d.begin(),d.end(),w[i]) - d.begin();\\n            if(idx){\\n                idx--;\\n                res+=vp[idx].second;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024965,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012095,
                "title": "simple-sorting-for-loop-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d,vector<int>& p,vector<int>& w) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            v.push_back(make_pair(p[i],d[i]));\\n        }\\n        sort(v.rbegin(),v.rend());\\n        sort(w.rbegin(),w.rend());\\n        int j=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(w[j]>=v[i].second)\\n            {\\n                ans+=v[i].first;\\n                j++;\\n                i--;\\n            }\\n            if(j==w.size()) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d,vector<int>& p,vector<int>& w) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            v.push_back(make_pair(p[i],d[i]));\\n        }\\n        sort(v.rbegin(),v.rend());\\n        sort(w.rbegin(),w.rend());\\n        int j=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(w[j]>=v[i].second)\\n            {\\n                ans+=v[i].first;\\n                j++;\\n                i--;\\n            }\\n            if(j==w.size()) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007709,
                "title": "most-profit-assigning-work",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    let Ability = new Map();\\n    for(let i=0;i<worker.length;i++){\\n        for(let j=0;j<difficulty.length;j++){\\n        if(worker[i]>=difficulty[j]){\\n            if(Ability.has(i)){\\n                Ability.set(i,Math.max(Math.max(Ability.get(i),profit[j])))\\n            }\\n            else{\\n                Ability.set(i,profit[j])\\n            }\\n        }\\n        }\\n    }\\n   return Array.from(Ability.values()).reduce((acc,cur)=>{return acc+=cur},0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    let Ability = new Map();\\n    for(let i=0;i<worker.length;i++){\\n        for(let j=0;j<difficulty.length;j++){\\n        if(worker[i]>=difficulty[j]){\\n            if(Ability.has(i)){\\n                Ability.set(i,Math.max(Math.max(Ability.get(i),profit[j])))\\n            }\\n            else{\\n                Ability.set(i,profit[j])\\n            }\\n        }\\n        }\\n    }\\n   return Array.from(Ability.values()).reduce((acc,cur)=>{return acc+=cur},0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005645,
                "title": "javascript-compact-solution",
                "content": "```javascript\\nconst maxProfitAssignment = (dif, prof, workers) => {\\n  const tasks = dif.map((d, i) => [d, prof[i]]);\\n  tasks.sort(([d1, p1], [d2, p2]) => d1 - d2);\\n\\n  workers = workers.filter((w) => w >= tasks[0][0]);\\n  if (!workers.length) return 0; // strongest worker < easiest job\\n\\n  let maxProf = 0;\\n  const balancedTasks = tasks.map(([d, p]) => {\\n    if (p > maxProf) maxProf = p;\\n    return [d, maxProf];\\n  });\\n\\n  workers.sort((a, b) => a - b);\\n  const len = balancedTasks.length;\\n  let i = 0;\\n\\n  return workers.reduce((tot, worker) => {\\n    while (i < len && balancedTasks[i][0] <= worker) i++;\\n    return tot + balancedTasks[i - 1][1];\\n  }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst maxProfitAssignment = (dif, prof, workers) => {\\n  const tasks = dif.map((d, i) => [d, prof[i]]);\\n  tasks.sort(([d1, p1], [d2, p2]) => d1 - d2);\\n\\n  workers = workers.filter((w) => w >= tasks[0][0]);\\n  if (!workers.length) return 0; // strongest worker < easiest job\\n\\n  let maxProf = 0;\\n  const balancedTasks = tasks.map(([d, p]) => {\\n    if (p > maxProf) maxProf = p;\\n    return [d, maxProf];\\n  });\\n\\n  workers.sort((a, b) => a - b);\\n  const len = balancedTasks.length;\\n  let i = 0;\\n\\n  return workers.reduce((tot, worker) => {\\n    while (i < len && balancedTasks[i][0] <= worker) i++;\\n    return tot + balancedTasks[i - 1][1];\\n  }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992366,
                "title": "greedy-static-comparator",
                "content": "# Intuition\\nFirst arrange the difficulty array according to the profit array in descending order so that we can select closest difficulty with max profit.\\n\\nFor all the elements of worker check if the max profit difficulty is lesser than or equal to and if not keep decreasing difficulty.\\n\\nif correct difficulty is found add subsequent profit to the profit(total)\\n\\nreturn total profit\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool static cmp(const pair<int,int>& p1,const pair<int,int>& p2)\\n    {\\n        return p1.second>p2.second;\\n    }\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) \\n    {\\n        vector<pair<int,int>> m;//difficulty and profit\\n        for(int i=0;i<d.size();i++)\\n        {\\n            m.push_back({d[i],p[i]});\\n        }\\n        int n=w.size();\\n        int profit=0;\\n        sort(m.begin(),m.end(),cmp);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m.size();j++)\\n            {\\n                if(m[j].first<=w[i])\\n                {\\n                    profit+=m[j].second;\\n                    break;\\n                }\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(const pair<int,int>& p1,const pair<int,int>& p2)\\n    {\\n        return p1.second>p2.second;\\n    }\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) \\n    {\\n        vector<pair<int,int>> m;//difficulty and profit\\n        for(int i=0;i<d.size();i++)\\n        {\\n            m.push_back({d[i],p[i]});\\n        }\\n        int n=w.size();\\n        int profit=0;\\n        sort(m.begin(),m.end(),cmp);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m.size();j++)\\n            {\\n                if(m[j].first<=w[i])\\n                {\\n                    profit+=m[j].second;\\n                    break;\\n                }\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975311,
                "title": "dry-run-it-is-easiest-solution-begineer-friendly",
                "content": "# easy solution ...  :)\\n# HAPPY LEETCODING\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        worker.sort()\\n        arr=[]\\n        for i in range(len(profit)):\\n            arr.append([difficulty[i],profit[i]])\\n        arr.sort()\\n        ans=0\\n        max_score=0\\n        l=0\\n        for i in range(len(worker)):\\n            while l<len(arr) and arr[l][0]<=worker[i]:\\n                max_score=max(max_score,arr[l][1])\\n                l+=1\\n            ans+=max_score\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        worker.sort()\\n        arr=[]\\n        for i in range(len(profit)):\\n            arr.append([difficulty[i],profit[i]])\\n        arr.sort()\\n        ans=0\\n        max_score=0\\n        l=0\\n        for i in range(len(worker)):\\n            while l<len(arr) and arr[l][0]<=worker[i]:\\n                max_score=max(max_score,arr[l][1])\\n                l+=1\\n            ans+=max_score\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938170,
                "title": "kotlin-2-pointers",
                "content": "# Intuition\\nSort both the workers (descending) and the jobs by profit (descending). Start from the first job (most profitable) and try to assign it to as many capable workers as you can.\\n\\nSince the workers array is decendengly sorted by difficulty, the most capable worker is the one at hand. If that worker can not handle the job at hand, then no other worker will. We can safley discard the job in that case and pickup the next job in line.\\n\\nKeep matching jobs with workers as long as we still have jobs and workers remaining.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    data class Job(val difficulty: Int, val profit: Int)\\n\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n       // Most capable worker is the first.\\n       worker.sortDescending()\\n\\n       val jobs = mutableListOf<Job>()\\n       for(i in difficulty.indices) {\\n           jobs.add(Job(difficulty[i], profit[i]))\\n       }\\n       // Most profitable job is the first.\\n       // Try to assign it to as many workers as we can.\\n       jobs.sortWith(Comparator { x, y -> y.profit.compareTo(x.profit) })\\n\\n       var w = 0\\n       var j = 0\\n       var sum = 0\\n       // We still have workers and jobs left.\\n       while(w < worker.size && j < jobs.size) {\\n           // The most profitable job can be handled by the most capable worker.\\n           if(jobs[j].difficulty <= worker[w]) \\n               sum += jobs[j].profit\\n               // Assign the job to the worker and pickup the next worker in line. \\n               // We\\'ll keep the same job since it is the most profitable so far.\\n               // We\\'ll try to assign it to the next worker in the next iteration.\\n               w += 1\\n           } else {\\n               // The most capable worker so far can not handle this job. No one else can.\\n               // Discard the job and pickup the next one in line.\\n               j += 1\\n           }\\n       }\\n\\n       return sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\n    data class Job(val difficulty: Int, val profit: Int)\\n\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n       // Most capable worker is the first.\\n       worker.sortDescending()\\n\\n       val jobs = mutableListOf<Job>()\\n       for(i in difficulty.indices) {\\n           jobs.add(Job(difficulty[i], profit[i]))\\n       }\\n       // Most profitable job is the first.\\n       // Try to assign it to as many workers as we can.\\n       jobs.sortWith(Comparator { x, y -> y.profit.compareTo(x.profit) })\\n\\n       var w = 0\\n       var j = 0\\n       var sum = 0\\n       // We still have workers and jobs left.\\n       while(w < worker.size && j < jobs.size) {\\n           // The most profitable job can be handled by the most capable worker.\\n           if(jobs[j].difficulty <= worker[w]) \\n               sum += jobs[j].profit\\n               // Assign the job to the worker and pickup the next worker in line. \\n               // We\\'ll keep the same job since it is the most profitable so far.\\n               // We\\'ll try to assign it to the next worker in the next iteration.\\n               w += 1\\n           } else {\\n               // The most capable worker so far can not handle this job. No one else can.\\n               // Discard the job and pickup the next one in line.\\n               j += 1\\n           }\\n       }\\n\\n       return sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929649,
                "title": "java-treemap-solution-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924278,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& prof, vector<int>& worker) \\n    {\\n        int j,ans;\\n        j=0;\\n        ans=0;\\n\\n        vector<pair<int,int>> v;\\n\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],prof[i]});\\n        }    \\n\\n        sort(v.begin(),v.end());\\n        sort(worker.begin(),worker.end());\\n\\n        //for(int i=0;i<worker.size();i++)\\n        //{\\n        //    cout<<worker[i]<<\" \";\\n        //}\\n        //cout<<endl;\\n//\\n        //for(int i=0;i<v.size();i++)\\n        //{\\n        //    cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n        //}\\n\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            while(j<v.size() && v[j].first<=worker[i])\\n            {\\n                j++;\\n                v[j].second=max(v[j-1].second,v[j].second);\\n            }\\n\\n            if(j!=0)\\n            {\\n                ans+=v[j-1].second;\\n            }    \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& prof, vector<int>& worker) \\n    {\\n        int j,ans;\\n        j=0;\\n        ans=0;\\n\\n        vector<pair<int,int>> v;\\n\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],prof[i]});\\n        }    \\n\\n        sort(v.begin(),v.end());\\n        sort(worker.begin(),worker.end());\\n\\n        //for(int i=0;i<worker.size();i++)\\n        //{\\n        //    cout<<worker[i]<<\" \";\\n        //}\\n        //cout<<endl;\\n//\\n        //for(int i=0;i<v.size();i++)\\n        //{\\n        //    cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n        //}\\n\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            while(j<v.size() && v[j].first<=worker[i])\\n            {\\n                j++;\\n                v[j].second=max(v[j-1].second,v[j].second);\\n            }\\n\\n            if(j!=0)\\n            {\\n                ans+=v[j-1].second;\\n            }    \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3872181,
                "title": "c-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Array.Sort(difficulty, profit);\\n        Array.Sort(worker);\\n        \\n        int i = 0, j = 0, maxpro = 0, res = 0;\\n        \\n        while(j < worker.Length)\\n        {\\n            if(i < difficulty.Length && difficulty[i] <= worker[j])\\n            {\\n                maxpro = Math.Max(maxpro, profit[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                res += maxpro;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Array.Sort(difficulty, profit);\\n        Array.Sort(worker);\\n        \\n        int i = 0, j = 0, maxpro = 0, res = 0;\\n        \\n        while(j < worker.Length)\\n        {\\n            if(i < difficulty.Length && difficulty[i] <= worker[j])\\n            {\\n                maxpro = Math.Max(maxpro, profit[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                res += maxpro;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865355,
                "title": "easy-and-fast-max-heap-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.) Use of Priority queue to obtain the maximum profit job every time.\\n2.) sort the worker array and traverse it from right side to check for the maximum skill with maximum profit from priority queue.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n           \\n             priority_queue< pair<int,int>  > pq;\\n\\n             for(int i=0;i<profit.size();i++){\\n                   pq.push({profit[i],difficulty[i]});\\n             }\\n\\n             sort(worker.begin(),worker.end());\\n             int ans=0;\\n             int i=worker.size()-1;\\n\\n             while(i>=0 && !pq.empty()){\\n\\n                 int skill=worker[i];\\n\\n                 if(skill < pq.top().second)\\n                      pq.pop();\\n                 \\n                 else\\n                     ans += pq.top().first,i--;\\n\\n                     \\n\\n             }\\n\\n             \\n\\n\\n                return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n           \\n             priority_queue< pair<int,int>  > pq;\\n\\n             for(int i=0;i<profit.size();i++){\\n                   pq.push({profit[i],difficulty[i]});\\n             }\\n\\n             sort(worker.begin(),worker.end());\\n             int ans=0;\\n             int i=worker.size()-1;\\n\\n             while(i>=0 && !pq.empty()){\\n\\n                 int skill=worker[i];\\n\\n                 if(skill < pq.top().second)\\n                      pq.pop();\\n                 \\n                 else\\n                     ans += pq.top().first,i--;\\n\\n                     \\n\\n             }\\n\\n             \\n\\n\\n                return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857231,
                "title": "using-maxheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\n        maxHeap = []\\n        for d, p in zip(difficulty, profit):\\n            heappush(maxHeap, (-p, d))\\n\\n        sorted_worker = sorted(worker)\\n        maxProfit = 0\\n\\n        for w in sorted_worker[::-1]:\\n\\n            while maxHeap and w < maxHeap[0][1]:\\n                heappop(maxHeap)\\n            if not maxHeap:\\n                return maxProfit\\n            maxProfit += -maxHeap[0][0]\\n\\n        return maxProfit\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\n        maxHeap = []\\n        for d, p in zip(difficulty, profit):\\n            heappush(maxHeap, (-p, d))\\n\\n        sorted_worker = sorted(worker)\\n        maxProfit = 0\\n\\n        for w in sorted_worker[::-1]:\\n\\n            while maxHeap and w < maxHeap[0][1]:\\n                heappop(maxHeap)\\n            if not maxHeap:\\n                return maxProfit\\n            maxProfit += -maxHeap[0][0]\\n\\n        return maxProfit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853608,
                "title": "c-solution-in-o-w",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847464,
                "title": "c-sorting",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn(n) + mlog(m))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i].first = profit[i];\\n            v[i].second = difficulty[i];\\n        }\\n        sort(v.begin(),v.end());\\n        int i = n - 1;\\n        sort(worker.begin(),worker.end());\\n        int j = m - 1;\\n        int ans = 0;\\n        while(i >= 0)\\n        {\\n            while(j >= 0 && worker[j] >= v[i].second)\\n            {\\n                ans += v[i].first;\\n                j--;\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i].first = profit[i];\\n            v[i].second = difficulty[i];\\n        }\\n        sort(v.begin(),v.end());\\n        int i = n - 1;\\n        sort(worker.begin(),worker.end());\\n        int j = m - 1;\\n        int ans = 0;\\n        while(i >= 0)\\n        {\\n            while(j >= 0 && worker[j] >= v[i].second)\\n            {\\n                ans += v[i].first;\\n                j--;\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828435,
                "title": "easy-to-understand-easy-solution-better-approach",
                "content": "# Intuition\\nYou have to sort the difficulty and worker array if you want to complete in one iteration.\\n\\n\\n# Complexity\\n- Time complexity: O(N logN) + O(M logM)\\n\\n- Space complexity: O(N) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& wor) {\\n        int n = diff.size() , m = wor.size();\\n        vector<int> map(100001 , 0);       \\n        for(int i = 0 ; i < n ; i++){\\n            map[diff[i]] = max(map[diff[i]] , pro[i]);\\n        }\\n        sort(diff.begin() , diff.end());  \\n        sort(wor.begin() , wor.end());\\n        int i = 0 , j = 0 , ans = 0 , maxi = 0;\\n        while(i<m){\\n            while(j < n && wor[i] >= diff[j]){\\n                maxi = max(maxi , map[diff[j]]) ; j++;\\n            }\\n            ans += maxi;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& wor) {\\n        int n = diff.size() , m = wor.size();\\n        vector<int> map(100001 , 0);       \\n        for(int i = 0 ; i < n ; i++){\\n            map[diff[i]] = max(map[diff[i]] , pro[i]);\\n        }\\n        sort(diff.begin() , diff.end());  \\n        sort(wor.begin() , wor.end());\\n        int i = 0 , j = 0 , ans = 0 , maxi = 0;\\n        while(i<m){\\n            while(j < n && wor[i] >= diff[j]){\\n                maxi = max(maxi , map[diff[j]]) ; j++;\\n            }\\n            ans += maxi;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812917,
                "title": "c-simple-solution-sorting-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = profit.size(), ans = 0;\\n        vector<pair<int, int>> v;\\n\\n        for(int i = 0; i < n; i++)\\n            v.push_back({difficulty[i], profit[i]});\\n\\n        sort(v.begin(), v.end());\\n        for(int i = 1; i < n; i++)\\n            v[i].second = max(v[i].second, v[i - 1].second);\\n\\n        for(auto &i : worker)\\n            ans += helper(i, v);\\n\\n        return ans;\\n    }\\n\\n    int helper(int x, vector<pair<int, int>> &v)\\n    {\\n        int i = 0, j = v.size() - 1;\\n        int ans = -1;\\n        while(i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n\\n            if(v[mid].first <= x)\\n                ans = mid, i = mid + 1;\\n            else\\n                j = mid - 1;\\n        }\\n\\n        return ans == -1 ? 0 : v[ans].second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = profit.size(), ans = 0;\\n        vector<pair<int, int>> v;\\n\\n        for(int i = 0; i < n; i++)\\n            v.push_back({difficulty[i], profit[i]});\\n\\n        sort(v.begin(), v.end());\\n        for(int i = 1; i < n; i++)\\n            v[i].second = max(v[i].second, v[i - 1].second);\\n\\n        for(auto &i : worker)\\n            ans += helper(i, v);\\n\\n        return ans;\\n    }\\n\\n    int helper(int x, vector<pair<int, int>> &v)\\n    {\\n        int i = 0, j = v.size() - 1;\\n        int ans = -1;\\n        while(i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n\\n            if(v[mid].first <= x)\\n                ans = mid, i = mid + 1;\\n            else\\n                j = mid - 1;\\n        }\\n\\n        return ans == -1 ? 0 : v[ans].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811314,
                "title": "easy-c-linear-tc",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797057,
                "title": "using-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        int def;\\n        int pro;\\n        Pair(int def, int pro)\\n        {\\n           this.def = def;\\n           this.pro = pro;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n          int len = difficulty.length;\\n          Pair arr[] = new Pair[len];\\n          for(int i = 0;i<len;i++)\\n          {\\n              arr[i] = new Pair(difficulty[i], profit[i]);\\n          }\\n\\n          Arrays.sort(arr, (a, b)-> a.def-b.def);\\n          Arrays.sort(worker);\\n          int curMax = 0;\\n          int totalMax = 0;\\n          int index = 0;\\n          for(int i = 0;i<worker.length;i++)\\n          {\\n              int wk = worker[i];\\n              while(index < len && arr[index].def <= wk)\\n              {\\n                  curMax = Math.max(curMax, arr[index].pro);\\n                  index++;\\n              }\\n              totalMax += curMax;\\n          }\\n\\n          return totalMax;\\n\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int def;\\n        int pro;\\n        Pair(int def, int pro)\\n        {\\n           this.def = def;\\n           this.pro = pro;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n          int len = difficulty.length;\\n          Pair arr[] = new Pair[len];\\n          for(int i = 0;i<len;i++)\\n          {\\n              arr[i] = new Pair(difficulty[i], profit[i]);\\n          }\\n\\n          Arrays.sort(arr, (a, b)-> a.def-b.def);\\n          Arrays.sort(worker);\\n          int curMax = 0;\\n          int totalMax = 0;\\n          int index = 0;\\n          for(int i = 0;i<worker.length;i++)\\n          {\\n              int wk = worker[i];\\n              while(index < len && arr[index].def <= wk)\\n              {\\n                  curMax = Math.max(curMax, arr[index].pro);\\n                  index++;\\n              }\\n              totalMax += curMax;\\n          }\\n\\n          return totalMax;\\n\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787328,
                "title": "make-pair-of-diff-profit-then-sort-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> diffPro;\\n        for(int i=0;i<difficulty.size();i++) diffPro.push_back({difficulty[i],profit[i]});\\n        sort(diffPro.begin(),diffPro.end());\\n        vector<int> MaxArr; int maxi = 0;\\n        for(int i=0;i<diffPro.size();i++){\\n            maxi = max(maxi,diffPro[i].second);\\n            MaxArr.push_back(maxi);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++){\\n            auto it = upper_bound(diffPro.begin(),diffPro.end(),make_pair(worker[i], numeric_limits<int>::max()));\\n            if(it==diffPro.end()){\\n                ans += MaxArr[MaxArr.size()-1];\\n                continue;\\n            }\\n            int idx = it - diffPro.begin();\\n            idx--;\\n            if(idx<0) continue;\\n            if(idx==0 && worker[i]<diffPro[idx].first){\\n                continue;\\n            }\\n            ans += MaxArr[idx];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> diffPro;\\n        for(int i=0;i<difficulty.size();i++) diffPro.push_back({difficulty[i],profit[i]});\\n        sort(diffPro.begin(),diffPro.end());\\n        vector<int> MaxArr; int maxi = 0;\\n        for(int i=0;i<diffPro.size();i++){\\n            maxi = max(maxi,diffPro[i].second);\\n            MaxArr.push_back(maxi);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++){\\n            auto it = upper_bound(diffPro.begin(),diffPro.end(),make_pair(worker[i], numeric_limits<int>::max()));\\n            if(it==diffPro.end()){\\n                ans += MaxArr[MaxArr.size()-1];\\n                continue;\\n            }\\n            int idx = it - diffPro.begin();\\n            idx--;\\n            if(idx<0) continue;\\n            if(idx==0 && worker[i]<diffPro[idx].first){\\n                continue;\\n            }\\n            ans += MaxArr[idx];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785630,
                "title": "easy-sol-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>items;int n=profit.size();\\n        for(int i=0;i<n;i++)items.push_back({difficulty[i],profit[i]});\\n        sort(items.begin(),items.end());\\n        for(int i=0;i<n;i++)difficulty[i]=items[i].first;\\n        profit[0]=items[0].second;\\n        for(int i=1;i<n;i++)profit[i]=max(profit[i-1],items[i].second);\\n        int ans=0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int ind=upper_bound(difficulty.begin(),difficulty.end(),worker[i])-difficulty.begin();\\n            if(ind==0)ans+=0;\\n            else\\n            {\\n                ans+=profit[ind-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>items;int n=profit.size();\\n        for(int i=0;i<n;i++)items.push_back({difficulty[i],profit[i]});\\n        sort(items.begin(),items.end());\\n        for(int i=0;i<n;i++)difficulty[i]=items[i].first;\\n        profit[0]=items[0].second;\\n        for(int i=1;i<n;i++)profit[i]=max(profit[i-1],items[i].second);\\n        int ans=0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int ind=upper_bound(difficulty.begin(),difficulty.end(),worker[i])-difficulty.begin();\\n            if(ind==0)ans+=0;\\n            else\\n            {\\n                ans+=profit[ind-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785537,
                "title": "simple-java-self-explaining-two-pointers-without-using-map",
                "content": "\\n\\n# Approach\\n1. Sort jobs with reverse profit \\n2. Sort worker with ability\\n3. Maximze profit by assign all capable worker to high profit job, iterating from high -> low\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\n        int[][] jobs = new int[profit.length][2]; \\n        for (int i = 0; i < profit.length; i++) {\\n            jobs[i][0] = difficulty[i];\\n            jobs[i][1] = profit[i]; \\n        }\\n        Arrays.sort(jobs, (a, b) -> b[1] - a[1]); \\n        Arrays.sort(worker); \\n\\n        int a = 0; \\n        int b = worker.length - 1; \\n        int max = 0; \\n\\n        for (int i = 0; i < jobs.length; i++) {\\n            int diff = jobs[i][0]; \\n            \\n            while ( b >= 0 && worker[b] >= diff) {\\n                max += jobs[i][1]; \\n                b--; \\n            }\\n        }\\n\\n        return max; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\n        int[][] jobs = new int[profit.length][2]; \\n        for (int i = 0; i < profit.length; i++) {\\n            jobs[i][0] = difficulty[i];\\n            jobs[i][1] = profit[i]; \\n        }\\n        Arrays.sort(jobs, (a, b) -> b[1] - a[1]); \\n        Arrays.sort(worker); \\n\\n        int a = 0; \\n        int b = worker.length - 1; \\n        int max = 0; \\n\\n        for (int i = 0; i < jobs.length; i++) {\\n            int diff = jobs[i][0]; \\n            \\n            while ( b >= 0 && worker[b] >= diff) {\\n                max += jobs[i][1]; \\n                b--; \\n            }\\n        }\\n\\n        return max; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780633,
                "title": "a-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] d, int[] p, int[] w) {\\n        var dict = new Dictionary<int, int>();\\n        for (int i = 0; i < d.Length; i++)\\n        {\\n            if (dict.ContainsKey(d[i]))\\n                dict[d[i]] = Math.Max(p[i], dict[d[i]]);\\n            else dict[d[i]] = p[i];\\n        }\\n        dict = dict.OrderByDescending(x => x.Value).ToDictionary(x => x.Key, x => x.Value);\\n        int res = 0;\\n        foreach(var worker in w)\\n        {\\n            foreach(var item in dict)\\n            {\\n                if (worker >= item.Key) \\n                {\\n                    res += item.Value; break;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] d, int[] p, int[] w) {\\n        var dict = new Dictionary<int, int>();\\n        for (int i = 0; i < d.Length; i++)\\n        {\\n            if (dict.ContainsKey(d[i]))\\n                dict[d[i]] = Math.Max(p[i], dict[d[i]]);\\n            else dict[d[i]] = p[i];\\n        }\\n        dict = dict.OrderByDescending(x => x.Value).ToDictionary(x => x.Key, x => x.Value);\\n        int res = 0;\\n        foreach(var worker in w)\\n        {\\n            foreach(var item in dict)\\n            {\\n                if (worker >= item.Key) \\n                {\\n                    res += item.Value; break;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1717060,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1947375,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 2018415,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1805295,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1786439,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 2071436,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 2054711,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1851627,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1829082,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            }
        ]
    },
    {
        "title": "Ugly Number III",
        "question_content": "<p>An <strong>ugly number</strong> is a positive integer that is divisible by <code>a</code>, <code>b</code>, or <code>c</code>.</p>\n\n<p>Given four integers <code>n</code>, <code>a</code>, <code>b</code>, and <code>c</code>, return the <code>n<sup>th</sup></code> <strong>ugly number</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, a = 2, b = 3, c = 5\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3<sup>rd</sup> is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, a = 2, b = 3, c = 4\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4<sup>th</sup> is 6.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, a = 2, b = 11, c = 13\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5<sup>th</sup> is 10.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, a, b, c &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= a * b * c &lt;= 10<sup>18</sup></code></li>\n\t<li>It is guaranteed that the result will be in range <code>[1, 2 * 10<sup>9</sup>]</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 387539,
                "title": "cpp-binary-search-with-picture-binary-search-template",
                "content": "For every integer N, `F(N) = (total number of positive integers <= N which are divisible by a or b or c.).`\\n![image](https://assets.leetcode.com/users/insomniacat/image_1569133734.png)\\n\\n`The left-top circle stands for numbers <= N that are divisible by a` \\nothers the same idea, and the intersection of two/three circles is the total number of positive integers  <= N which are divisible by the` least common multiple` of them.\\n`F(N) =  a + b + c -  a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c `\\n`F(N) =    N/a  + N/b +  N/c - N/lcm(a, c) -  N/lcm(a, b) -   N/lcm(b, c) + N/lcm(a, b, c) `(lcm = least common multiple)\\nFind the least integer `N` that satisfies the condition `F(N) >= K` \\n```\\nclass Solution {\\npublic:    \\n   int nthUglyNumber(int k, int A, int B, int C) {\\n        int lo = 1, hi = 2 * (int) 1e9;\\n        long a = long(A), b = long(B), c = long(C);\\n        long ab = a * b / __gcd(a, b);\\n        long bc = b * c / __gcd(b, c);\\n        long ac = a * c / __gcd(a, c);\\n        long abc = a * bc / __gcd(a, bc);\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo)/2;\\n            int cnt = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ac + mid/abc;\\n            if(cnt < k) \\n                lo = mid + 1;\\n            else\\n\\t\\t\\t   //the condition: F(N) >= k\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n};\\n```\\nComplexity\\n* Time: O(log(2* 1e9))\\n* Space: O(1)\\n\\nUpdate: \\nI used to solve the Binary Search problems with this template:\\n```\\nwhile(lo < hi) {\\nint mid = lo + (hi - lo) / 2;\\nif(Special condition passed)(optional):\\n\\treturn mid; \\nif(condition passed)\\n  hi = mid;\\nelse \\n  lo = mid + 1;\\n}\\nreturn lo;\\n```\\nThe key idea is that the range of searching is monotonic, i.e., `If F(a) == true, then for every b > a, F(b) = true`. So our goal is to find the leftmost point a that `F(a) == true`, which can be solved by binary search. In order to find the leftmost point which satisfies the condition, do not break the loop immediately when u find a valid point (There may exist some valid points on the left side). Instead, what u can do is to `narrow the searching range`, and the `lo` point will be the answer. In some cases there\\'s no answer and `lo` will return as the initial `hi` value, check that case too.\\nMost of binary search problems can be solved by the template above.\\nTry [875](https://leetcode.com/problems/koko-eating-bananas/)\\n[1011](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n[668](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\\n[719](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\nHope it helps.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n   int nthUglyNumber(int k, int A, int B, int C) {\\n        int lo = 1, hi = 2 * (int) 1e9;\\n        long a = long(A), b = long(B), c = long(C);\\n        long ab = a * b / __gcd(a, b);\\n        long bc = b * c / __gcd(b, c);\\n        long ac = a * c / __gcd(a, c);\\n        long abc = a * bc / __gcd(a, bc);\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo)/2;\\n            int cnt = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ac + mid/abc;\\n            if(cnt < k) \\n                lo = mid + 1;\\n            else\\n\\t\\t\\t   //the condition: F(N) >= k\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n};\\n```\n```\\nwhile(lo < hi) {\\nint mid = lo + (hi - lo) / 2;\\nif(Special condition passed)(optional):\\n\\treturn mid; \\nif(condition passed)\\n  hi = mid;\\nelse \\n  lo = mid + 1;\\n}\\nreturn lo;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387780,
                "title": "java-c-binary-search-with-venn-diagram-explain-math-formula",
                "content": "**Formula**\\nCalculate how many numbers from `1` to `num` are divisible by either `a`, `b` or `c` by using below formula:\\n`num/a + num/b + num/c \\u2013 num/lcm(a, b) \\u2013 num/lcm(b, c) \\u2013 num/lcm(a, c) + num/lcm(a, b, c)`\\n\\n**Explain**\\n![image](https://assets.leetcode.com/users/hiepit/image_1569139496.png)\\n\\n**Complexity**\\n- Time: `O(log(MAX_ANS))`, MAX_ANS = 2*10^9\\n- Space: `O(1)`\\n\\n**Java**\\n```java\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```\\n\\n**C++**\\n```c++\\ntypedef long long ll;\\n#define MAX_ANS 2e9 // 2 * 10^9\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { // find mid as small as possible that count == n\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```\\n\\nThanks for watching. If you have any question, feel free to comment below. :D",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```\n```c++\\ntypedef long long ll;\\n#define MAX_ANS 2e9 // 2 * 10^9\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { // find mid as small as possible that count == n\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769707,
                "title": "python-clear-explanation-powerful-ultimate-binary-search-template-solved-many-problems",
                "content": "First thing first, here is the code:\\n\\n```python\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def enough(num) -> bool:\\n            total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n            return total >= n\\n\\n        ab = a * b // math.gcd(a, b)\\n        ac = a * c // math.gcd(a, c)\\n        bc = b * c // math.gcd(b, c)\\n        abc = a * bc // math.gcd(a, bc)\\n        left, right = 1, 10 ** 10\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if enough(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\nI have built a powerful generalized binary search template and used it to solve many problems easily. Below is the detailed and clear introduction to this template. I believe it will be worth your time :)\\n\\n****\\n\\n# Intro\\n\\nBinary Search is quite easy to understand conceptually. Basically, it splits the search space into two halves and only keep the half that probably has the search target and throw away the other half that would not possibly have the answer. In this manner, we reduce the search space to half the size at every step, until we find the target. Binary Search helps us reduce the search time from linear O(n) to logarithmic O(log n). But when it comes to implementation, it\\'s rather difficult to write a bug-free code in just a few minutes. Some of the most common problems include:\\n\\n- When to exit the loop? Should we use `left < right` or `left <= right` as the while loop condition?\\n- How to initialize the boundary variable `left` and `right`?\\n- How to update the boundary? How to choose the appropriate combination from `left = mid `, `left = mid + 1` and  `right = mid`, `right = mid - 1`?\\n\\nA rather common misunderstanding of binary search is that people often think this technique could only be used in simple scenario like \"Given a sorted array, find a specific value in it\". As a matter of fact, it can be applied to much more complicated situations.\\n\\nAfter a lot of practice in LeetCode, I\\'ve made a powerful binary search template and solved many Hard problems by just slightly twisting this template. I\\'ll share the template with you guys in this post. I don\\'t want to just show off the code and leave. Most importantly, I want to share the logical thinking: how to apply this general template to all sorts of problems. Hopefully, after reading this post, people wouldn\\'t be pissed off any more when LeetCoding, \"Holy sh*t! This problem could be solved with binary search! Why didn\\'t I think of that before!\"\\n\\n\\n\\n****\\n\\n\\n\\n# Most Generalized Binary Search\\n\\nSuppose we have a search space. It could be an array, a range, etc. Usually it\\'s sorted in ascend order. For most tasks, we can transform the requirement into the following generalized form:\\n\\n**Minimize k ,    s.t.  condition(k) is True**\\n\\nThe following code is the most generalized binary search template:\\n\\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nWhat\\'s really nice of this template is that, for most of the binary search problems, we only need to modify three parts after copy-pasting this template, and never need to worry about corner cases and bugs in code any more:\\n\\n- Correctly initialize the boundary variables `left` and `right`. Only one rule: set up the boundary to **include all possible elements**;\\n- Decide return value. Is it `return left` or `return left - 1`? Remember this: **after exiting the while loop, `left` is the minimal k\\u200B satisfying the `condition ` function**;\\n- Design the `condition` function. This is the most difficult and most beautiful part. Needs lots of practice.\\n\\nBelow I\\'ll show you guys how to apply this powerful template to many LeetCode problems.\\n\\n\\n\\n****\\n\\n\\n\\n# Basic Application\\n\\n## [278. First Bad Version [Easy]](https://leetcode.com/problems/first-bad-version/)\\n\\nYou are a product manager and currently leading a team to develop a new product. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API `bool isBadVersion(version)` which will return whether `version` is bad.\\n\\n**Example:**\\n\\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\\n\\nFirst, we initialize `left = 1` and `right = n` to include all possible values. Then we notice that we don\\'t even need to design the `condition` function. It\\'s already given by the `isBadVersion` API. Finding the first bad version is equivalent to finding the minimal k satisfying `isBadVersion(k) is True`. Our template can fit in very nicely:\\n\\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n****\\n\\n\\n\\n## [69. Sqrt(x) [Easy]](https://leetcode.com/problems/sqrtx/)\\n\\nImplement `int sqrt(int x)`. Compute and return the square root of *x*, where *x* is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\\n\\n**Example:**\\n\\n```scala\\nInput: 4\\nOutput: 2\\n```\\n\\n```scala\\nInput: 8\\nOutput: 2\\n```\\n\\nQuite an easy problem. We need to search for maximal k satisfying `k^2 <= x`, so we can easily come up with the solution:\\n\\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\\n\\nThere\\'s one thing I\\'d like to point out. Remember I say that **we usually look for the minimal k value satisfying certain condition**? But in this problem we are searching for maximal k value instead. Feeling confused? Don\\'t be. Actually, the maximal k satisfying `condition(k) is False` is just equal to the minimal k satisfying `condition(k) is True` minus one. This is why I mentioned earlier that we need to decide which value to return, `left` or `left - 1`.\\n\\n\\n\\n****\\n\\n\\n\\n## [35. Search Insert Position [Easy]](https://leetcode.com/problems/search-insert-position/)\\n\\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\\n\\n**Example:**\\n\\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\\n\\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\\n\\nVery classic application of binary search. We are looking for the minimal k value satisfying `nums[k] >= target`, and we can just copy-paste our template. Notice that our solution is correct regardless of whether the input array `nums` has duplicates. Also notice that the input  `target` might be larger than all elements in `nums` and therefore needs to placed at the end of the array. That\\'s why we should initialize `right = len(nums)` instead of `right = len(nums) - 1`.\\n\\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# Advanced Application\\n\\nThe above problems are quite easy to solve, because they already give us the array to be searched. We\\'d know that we should use binary search to solve them at first glance.  However, more often are the situations where the search space and search target are not so readily available. Sometimes we won\\'t even realize that the problem should be solved with binary search -- we might just turn to dynamic programming or DFS and get stuck for a very long time.\\n\\nAs for the question \"When can we use binary search?\", my answer is that, **If we can discover some kind of monotonicity, for example, if `condition(k) is True` then `condition(k + 1) is True`, then we can consider binary search**.\\n\\n## [1011. Capacity To Ship Packages Within D Days [Medium]](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\ndays. The `i`-th package on the conveyor belt has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship. \\n\\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `D` days.\\n\\n**Example :**\\n\\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\\n\\nBinary search probably would not come to our mind when we first meet this problem. We might automatically treat `weights` as search space and then realize we\\'ve entered a dead end after wasting lots of time. In fact, we are looking for the minimal one among all feasible capacities. We dig out the monotonicity of this problem: if we can successfully ship all packages within `D` days with capacity `m`, then we can definitely ship them all with any capacity larger than `m`. Now we can design a `condition` function, let\\'s call it `feasible`, given an input `capacity`, it returns whether it\\'s possible to ship all packages within `D` days. This can run in a greedy way: if there\\'s still room for the current package, we put this package onto the conveyor belt, otherwise we wait for the next day to place this package. If the total days needed exceeds `D`, we return `False`, otherwise we return `True`.\\n\\nNext, we need to initialize our boundary correctly. Obviously `capacity` should be at least `max(weights)`, otherwise the conveyor belt couldn\\'t ship the heaviest package. On the other hand, `capacity` need not be more than`sum(weights)`, because then we can ship all packages in just one day.\\n\\nNow we\\'ve got all we need to apply our binary search template:\\n\\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [410. Split Array Largest Sum [Hard]](https://leetcode.com/problems/split-array-largest-sum/)\\n\\nGiven an array which consists of non-negative integers and an integer *m*, you can split the array into *m* non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these *m* subarrays.\\n\\n**Example:**\\n\\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\\n\\nIf you take a close look, you would probably see how similar this problem is with LC 1011 above. Similarly, we can design a `feasible` function: given an input `threshold`, then decide if we can split the array into several subarrays such that every subarray-sum is less than or equal to `threshold`. In this way, we discover the monotonicity of the problem: if `feasible(m)` is `True`, then all inputs larger than `m` can satisfy `feasible` function. You can see that the solution code is exactly the same as LC 1011.\\n\\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nBut we probably would have doubts: It\\'s true that `left` returned by our solution is the minimal value satisfying `feasible`, but how can we know that we can split the original array to **actually get this subarray-sum**? For example, let\\'s say `nums = [7,2,5,10,8]` and `m = 2`. We have 4 different ways to split the array to get 4 different largest subarray-sum correspondingly: `25:[[7], [2,5,10,8]]`, `23:[[7,2], [5,10,8]]`, `18:[[7,2,5], [10,8]]`, `24:[[7,2,5,10], [8]]`. Only 4 values. But our search space `[max(nums), sum(nums)] = [10, 32]` has much more that just 4 values. That is, no matter how we split the input array, we cannot get most of the values in our search space.\\n\\nLet\\'s say `k` is the minimal value satisfying `feasible` function. We can prove the correctness of our solution with proof by contradiction. Assume that no subarray\\'s sum is equal to `k`, that is, every subarray sum is less than `k`. The variable `total` inside `feasible` function keeps track of the total weights of current load. If our assumption is correct, then `total` would always be less than `k`. As a result, `feasible(k - 1)` must be `True`, because `total` would at most be equal to `k - 1` and would never trigger the if-clause `if total > threshold`, therefore `feasible(k - 1)` must have the same output as `feasible(k)`, which is `True`. But we already know that `k`  is the minimal value satisfying `feasible` function, so `feasible(k - 1)` has to be `False`, which is a contradiction. So our assumption is incorrect. Now we\\'ve proved that our algorithm is correct.\\n\\n\\n\\n****\\n\\n\\n\\n## [875. Koko Eating Bananas [Medium]](https://leetcode.com/problems/koko-eating-bananas/)\\n\\nKoko loves to eat bananas. There are `N` piles of bananas, the `i`-th pile has `piles[i]` bananas. The guards have gone and will come back in `H` hours. Koko can decide her bananas-per-hour eating speed of `K`. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than `K` bananas, she eats all of them instead, and won\\'t eat any more bananas during this hour. \\n\\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. **Return the minimum integer `K` such that she can eat all the bananas within `H` hours**.\\n\\n**Example :**\\n\\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\\n\\nVery similar to LC 1011 and LC 410 mentioned above. Let\\'s design a `feasible` function, given an input `speed`, determine whether Koko can finish all bananas within `H` hours with hourly eating speed `speed`. Obviously, the lower bound of the search space is 1, and upper bound is `max(piles)`, because Koko can only choose one pile of bananas to eat every hour.\\n\\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1482. Minimum Number of Days to Make m Bouquets [Medium]](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n\\nGiven an integer array `bloomDay`, an integer `m` and an integer `k`. We need to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden. The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet. Return *the minimum number of days* you need to wait to be able to make `m` bouquets from the garden. If it is impossible to make `m` bouquets return **-1**.\\n\\n**Examples:**\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\\n\\nNow that we\\'ve solved three advanced problems above, this one should be pretty easy to do. The monotonicity of this problem is very clear: if we can make `m` bouquets after waiting for `d` days, then we can definitely finish that as well if we wait more than `d` days.\\n\\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [668. Kth Smallest Number in Multiplication Table [Hard]](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\\n\\nNearly every one have used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). But could you find out the `k-th` smallest number quickly from the multiplication table? Given the height `m` and the length `n` of a `m * n` Multiplication Table, and a positive integer `k`, you need to return the `k-th` smallest number in this table.\\n\\n**Example :**\\n\\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\\n\\nFor Kth-Smallest problems like this, what comes to our mind first is Heap. Usually we can  maintain a Min-Heap and just pop the top of the Heap for k times. However, that doesn\\'t work out in this problem. We don\\'t have every single number in the entire Multiplication Table, instead, we only have the height and the length of the table. If we are to apply Heap method, we need to explicitly calculate these `m * n` values and save them to a heap. The time complexity and space complexity of this process are both O(mn), which is quite inefficient. This is when binary search comes in. Remember we say that designing `condition` function is the most difficult part? In order to find the k-th smallest value in the table, we can design an `enough` function, given an input `num`, determine whether there\\'re at least k values less than or equal to `num`. **The minimal `num` satisfying `enough` function is the answer we\\'re looking for**. Recall that the key to binary search is discovering monotonicity. In this problem, if `num` satisfies `enough`, then of course any value larger than `num` can satisfy. This monotonicity is the fundament of our binary search algorithm.\\n\\nLet\\'s consider search space. Obviously the lower bound should be 1, and the upper bound should be the largest value in the Multiplication Table, which is `m * n`, then we have search space `[1, m * n]`. The overwhelming advantage of binary search solution to heap solution is that it doesn\\'t need to explicitly calculate all numbers in that table, all it needs is just picking up one value out of the search space and apply `enough` function to this value, to determine should we keep the left half or the right half of the search space. In this way, binary search solution only requires constant space complexity, much better than heap solution.\\n\\nNext let\\'s consider how to implement `enough` function. It can be observed that every row in the Multiplication Table is just multiples of its index. For example, all numbers in 3rd row `[3,6,9,12,15...]` are multiples of 3. Therefore, we can just go row by row to count the total number of entries less than or equal to input `num`. Following is the complete solution.\\n\\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\\n\\nIn LC 410 above, we have doubt \"Is the result from binary search actually a subarray sum?\". Here we have a similar doubt: \"Is the result from binary search actually in the Multiplication Table?\". The answer is yes, and we also can apply proof by contradiction. Denote `num` as the minimal input that satisfies `enough` function. Let\\'s assume that `num` is not in the table, which means that `num` is not divisible by any `val` in `[1, m]`, that is, `num % val > 0`. Therefore, changing the input from `num` to `num - 1` doesn\\'t have any effect on the expression `add = min(num // val, n)`. So `enough(num)` would also return `True`,  just like `enough(num)`. But we already know `num` is the minimal input satisfying `enough` function, so `enough(num - 1)` has to be `False`. Contradiction! The opposite of our original assumption is true: `num` is actually in the table.\\n\\n\\n\\n****\\n\\n\\n\\n## [719. Find K-th Smallest Pair Distance [Hard]](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n\\nGiven an integer array, return the k-th smallest **distance** among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.\\n\\n**Example :**\\n\\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\\n\\nVery similar to LC 668 above, both are about finding Kth-Smallest. Just like LC 668, We can design an `enough` function, given an input `distance`, determine whether there\\'re at least k pairs whose distances are less than or equal to `distance`. We can sort the input array and use two pointers (fast pointer and slow pointer, pointed at a pair) to scan it. Both pointers go from leftmost end. If the current pair pointed at has a distance less than or equal to `distance`, all pairs between these pointers are valid (since the array is already sorted), we move forward the fast pointer. Otherwise, we move forward the slow pointer. By the time both pointers reach the rightmost end, we finish our scan and see if total counts exceed k. Here is the implementation:\\n\\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\\n\\nObviously, our search space should be `[0, max(nums) - min(nums)]`. Now we are ready to copy-paste our template:\\n\\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1201. Ugly Number III [Medium]](https://leetcode.com/problems/ugly-number-iii/)\\n\\nWrite a program to find the `n`-th ugly number. Ugly numbers are **positive integers** which are divisible by `a` **or** `b` **or** `c`.\\n\\n**Example :**\\n\\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\\n\\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\\n\\nNothing special. Still finding the Kth-Smallest. We need to design an `enough` function, given an input `num`, determine whether there are at least n ugly numbers less than or equal to `num`. Since `a` might be a multiple of `b` or `c`, or the other way round, we need the help of greatest common divisor to avoid counting duplicate numbers.\\n\\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1283. Find the Smallest Divisor Given a Threshold [Medium]](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n\\nGiven an array of integers `nums` and an integer `threshold`, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the **smallest** divisor such that the result mentioned above is less than or equal to `threshold`.\\n\\nEach result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). It is guaranteed that there will be an answer.\\n\\n**Example :**\\n\\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\\n\\nAfter so many problems introduced above, this one should be a piece of cake. We don\\'t even need to bother to design a `condition` function, because the problem has already told us explicitly what condition we need to satisfy.\\n\\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# End\\n\\nWow, thank you so much for making it to the end, really appreciate that. As you can see from the python codes above, they all look very similar to each other. That\\'s because I copy-pasted my template all the time. No exception. This is the strong proof of my template\\'s powerfulness. I believe everyone can acquire this binary search template to solve many problems. All we need is just more practice to build up our ability to discover the monotonicity of the problem and to design a beautiful `condition` function.\\n\\nHope this helps.\\n\\n**Reference**\\n\\n- [[C++ / Fast / Very clear explanation / Clean Code] Solution with Greedy Algorithm and Binary Search](https://leetcode.com/problems/split-array-largest-sum/discuss/89819/C%2B%2B-Fast-Very-clear-explanation-Clean-Code-Solution-with-Greedy-Algorithm-and-Binary-Search)\\n- [Approach the problem using the \"trial and error\" algorithm](https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-\"trial-and-error\"-algorithm)\\n- [Binary Search 101 The-Ultimate-Binary-Search-Handbook - LeetCode](https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook)\\n- [ugly-number-iii Binary Search with picture & Binary Search Template - LeetCode](https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def enough(num) -> bool:\\n            total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n            return total >= n\\n\\n        ab = a * b // math.gcd(a, b)\\n        ac = a * c // math.gcd(a, c)\\n        bc = b * c // math.gcd(b, c)\\n        abc = a * bc // math.gcd(a, bc)\\n        left, right = 1, 10 ** 10\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if enough(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: 4\\nOutput: 2\\n```\n```scala\\nInput: 8\\nOutput: 2\\n```\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387561,
                "title": "short-and-concise-c-solution-binary-search-with-explanation",
                "content": "This problem can easily solved by binary-search by defining the predicate: \"Given N, how many numbers upto N are divisible by A or B or C\"\\n\\nThe predicate can be evaluated by inclusion-exclusion principle:\\n\\n\\tNo. of numbers upto N divisible by A = N/A;\\n\\tNo. of numbers upto N divisible by B = N/B;\\n\\tNo. of numbers upto N divisible by C = N/C;\\n\\t\\n\\tNo. of numbers upto N divisible by both A and B = N / lcm(A, B);\\n\\tNo. of numbers upto N divisible by both B and C = N / lcm(B, C);\\n\\tNo. of numbers upto N divisible by both A and C = N / lcm(A, C);\\n\\t\\n\\tNo. of numbers upto N divisible by all A, B and C = N / lcm(A, B, C);\\n\\t\\nFurthermore LCM(A, B) can be computed as LCM(A, B) = (A*B) / GCD(A, B)\\n\\nFor problem solving technique using binary search predicate, refer to the following awesome article:\\n\\thttps://www.topcoder.com/community/competitive-programming/tutorials/binary-search\\n\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll lcm(ll a, ll b) {\\n        return a*b / __gcd(a, b);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll N = (ll)n, A = ll(a), B = ll(b), C = ll(c);\\n        ll lo = 1, hi = 2000000000, mid, ans;\\n        \\n        while(lo <= hi)\\n        {\\n            mid = lo + (hi - lo)/2;\\n            ll cnt = 0;\\n            cnt += mid/A;\\n            cnt += mid/B;\\n            cnt += mid/C;\\n            cnt -= mid / lcm(A, B);\\n            cnt -= mid / lcm(B, C);\\n            cnt -= mid / lcm(C, A);\\n            cnt += mid / lcm(a, lcm(b, c));\\n            \\n            if(cnt >= N)\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll lcm(ll a, ll b) {\\n        return a*b / __gcd(a, b);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll N = (ll)n, A = ll(a), B = ll(b), C = ll(c);\\n        ll lo = 1, hi = 2000000000, mid, ans;\\n        \\n        while(lo <= hi)\\n        {\\n            mid = lo + (hi - lo)/2;\\n            ll cnt = 0;\\n            cnt += mid/A;\\n            cnt += mid/B;\\n            cnt += mid/C;\\n            cnt -= mid / lcm(A, B);\\n            cnt -= mid / lcm(B, C);\\n            cnt -= mid / lcm(C, A);\\n            cnt += mid / lcm(a, lcm(b, c));\\n            \\n            if(cnt >= N)\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723589,
                "title": "python3-inconsistent-definition-of-ugly-numbers",
                "content": "The term \"ugly number\" seems to reflect a poorly-defined concept. Upon Googling it, I can only find it in a few places such as LC, GFG, etc. Even in the few posts on LC, the concept varies. For example, in [263. Ugly Number](https://leetcode.com/problems/ugly-number/), an ugly number is a positive integer whose only factors are 2, 3 and 5, but 1 is treated as an ugly number. This definition is consistent with that of [264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/). But in [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/), ugly number becomes positive integers divisible by given factors (let\\'s still use 2, 3, 5 unless stated otherwise), and 1 is not considered ugly any more. \\n\\nLet\\'s refer to the definition in 263 and 264 \"Def 1\" and the definition in 1201 \"Def 2\". Under Def 1, the first few ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ... while under Def 2 the first few ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 15, ... . The similarity is obvious at first glance. But if you look deeper, a fundamental difference can be revealed. Namely, under Def 1, ugly number is self-generated, i.e. large ugly numbers are generated by multiplying factors with small ugly numbers. Because of this, ugly numbers become rarer as number becomes larger. However, under Def 2, ugly numbers are periodic. The pattern repeats when least common multiple is reached. \\n\\nTo reflect the \"self-generating\" property of ugly number under Def 1, 263 and 264 can be solved using dynamic programming. For example, this [post](https://leetcode.com/problems/ugly-number/discuss/719320/Python3-4-line-concise) and this [post](https://leetcode.com/problems/ugly-number-ii/discuss/720034/Python3-7-line-dp) implement the solution using top-down approach. But 1201 needs to be solved in a completely different way. In the spirit of this difference, I think it is more confusing than helpful to put 1201 in the ugly number series. It is probably clearer if this is treated as a completely independent problem. \\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        # inclusion-exclusion principle\\n        ab = a*b//gcd(a, b)\\n        bc = b*c//gcd(b, c)\\n        ca = c*a//gcd(c, a)\\n        abc = ab*c//gcd(ab, c)\\n        \\n        lo, hi = 1, n*min(a, b, c)\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1\\n            else: hi = mid \\n        return lo \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        # inclusion-exclusion principle\\n        ab = a*b//gcd(a, b)\\n        bc = b*c//gcd(b, c)\\n        ca = c*a//gcd(c, a)\\n        abc = ab*c//gcd(ab, c)\\n        \\n        lo, hi = 1, n*min(a, b, c)\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1\\n            else: hi = mid \\n        return lo \\n```",
                "codeTag": "Java"
            },
            {
                "id": 387587,
                "title": "math-binarysearch-solution-java",
                "content": "Calculate how many numbers from 1 to num are divisible by either a, b or c by using the formula: \\n`(num / a) + (num / b) + (num / c) \\u2013 (num / lcm(a, b)) \\u2013 (num / lcm(b, c)) \\u2013 (num / lcm(a, c)) + (num / lcm(a, b, c))`\\n```\\n private long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n\\n        return gcd(b % a, a);\\n    }\\n\\n    private long lcm(long a, long b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n\\n    private int count(long a, long b, long c, long num) {\\n        return (int) ((num / a) + (num / b) + (num / c)\\n                - (num / lcm(a, b))\\n                - (num / lcm(b, c))\\n                - (num / lcm(a, c))\\n                + (num / lcm(a, lcm(b, c)))); // lcm(a,b,c) = lcm(a,lcm(b,c))\\n    }\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = Integer.MAX_VALUE, mid;\\n\\n        while (low < high) {\\n            mid = low + (high - low) / 2;\\n\\n            if (count((a), b, c, mid) < n)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n\\n        return high;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n private long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n\\n        return gcd(b % a, a);\\n    }\\n\\n    private long lcm(long a, long b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n\\n    private int count(long a, long b, long c, long num) {\\n        return (int) ((num / a) + (num / b) + (num / c)\\n                - (num / lcm(a, b))\\n                - (num / lcm(b, c))\\n                - (num / lcm(a, c))\\n                + (num / lcm(a, lcm(b, c)))); // lcm(a,b,c) = lcm(a,lcm(b,c))\\n    }\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = Integer.MAX_VALUE, mid;\\n\\n        while (low < high) {\\n            mid = low + (high - low) / 2;\\n\\n            if (count((a), b, c, mid) < n)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n\\n        return high;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390530,
                "title": "simple-python-binary-search",
                "content": "Please see my solutions for these similar problems.\\n\\nFor these problems, it\\'s relatively easy to solve the subproblem:\\ngiven a specific guess, determine whether it\\'s possible to xxx?\\nFurthermore, the range of guess is limited, and the boolean answer of the above subproblem has the pattern\\nF...FT...T or T..TF...F.\\nThus, we can use binary search to find the minimal/maximal value such that the boolean answer is True.\\n[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1004232/Python-solution-with-thinking-process)\\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/discuss/1714072/Simple-Python-Binary-Search-(similar-problem-listed))\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/discuss/326747/Python-solutions-with-thinking-process)\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/390359/Simple-Python-Binary-Search)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/409956/Simple-Python-Binary-Search-(similar-problem-listed))\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/390523/Simple-Python-Binary-Search)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/390526/Simple-Python-Binary-Search)\\n[1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/discuss/390530/Simple-Python-Binary-Search)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/1714075/Simple-Python-Binary-Search-(similar-problem-listed))\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2361972/Python-Binary-search-solution-(similar-problems-listed))\\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/discuss/1698346/Python-Binary-search-solution-(similar-problems-listed))\\n\\n\\nFor every integer A, F(A) = (total number of positive integers <= A which are divisible by a or b or c.).\\nF(A) = A/a + A/b + A/c - A/lcm(a, c) - A/lcm(a, b) - A/lcm(a, c) + A/lcm(a, b, c)(lcm = least common multiple)\\nFind the least integer A that satisfies the condition F(A) == n.\\n\\n```\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(x, y):\\n            return x * y // math.gcd(x, y)\\n        \\n        def count_ugly(n, a, b, c, ab, bc, ca, abc):\\n            answer = n // a + n // b + n // c\\n            answer -= n // ab + n // bc + n // ca\\n            answer += n // abc\\n            return answer\\n        \\n        ab, bc, ca = lcm(a, b), lcm(b, c), lcm(c, a)\\n        abc = lcm(ab, c)\\n        low = 1\\n        high = 2 * 10 ** 9\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if count_ugly(mid, a, b, c, ab, bc, ca, abc) < n:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "solutionTags": [],
                "code": "```\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(x, y):\\n            return x * y // math.gcd(x, y)\\n        \\n        def count_ugly(n, a, b, c, ab, bc, ca, abc):\\n            answer = n // a + n // b + n // c\\n            answer -= n // ab + n // bc + n // ca\\n            answer += n // abc\\n            return answer\\n        \\n        ab, bc, ca = lcm(a, b), lcm(b, c), lcm(c, a)\\n        abc = lcm(ab, c)\\n        low = 1\\n        high = 2 * 10 ** 9\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if count_ugly(mid, a, b, c, ab, bc, ca, abc) < n:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1790736,
                "title": "some-basic-math-we-need-for-this-problem",
                "content": "One of the nice solutions for this problem involves writing a function that counts the number of ugly numbers that are smaller than or equal to a given number, so then we can use binary search to find the *n*th ugly number. I want to talk a bit about the math behind designing a such a function.\\n\\nFor positive integers *a &le; b*, there exist unique integers *q* and *r* such that *b = a &times; q + r*, with *0 &le; r < a*. Note that *q* is the number of multiples of *a* that are smaller than or equal to *b*. Since *r < a*, we can easily compute *q* by doing `q = floor(b / a)`.\\n\\nIn this problem we are interested not only in the multiples of an integer *a*, but in the mutiples of three integers *a*, *b*, and *c*. We want to be careful not to overcount numbers when there is some overlap in the sets of multiples of each. For this purpose we can use **PIE**, the *Principle of Inclusion and Exclusion*. This is a really useful combinatorics technique to count the number of elements in the union of two or more sets.\\n\\n<strong>PIE:</strong> Let *A*, *B*, and *C* be three sets with *n(A)*, *n(B)*, and *n(C)* elements, respectively. Then the number of elements in the union of all three, *A &cup; B &cup; C*, is given by\\n<center><i>\\nn(A &cup; B &cup; C) = n(A) + n(B) + n(C) - n(A &cap; B) - n(A &cap; C) - n(B &cap; C) + n(A &cap; B &cap; C)\\n</i></center>\\n\\n<strong> Proof (ish): </strong> When we add the number of elements of each set in *n(A) + n(B) + n(C)*, since *A &cap; B &#8838; A,  B*, all elements in *A &cap; B* are being counted twice. Similary all elements of *A &cap; C* and *B &cap; C* are being counted twice as well. To remedy this, we subtract *n(A &cap; B) + n(A &cap; C) + n(B &cap; C)*. Now, *n(A &cap; B &cap; C)* was added three times and then subtracted three times, so it is missing. Thus, we add *n(A &cap; B &cap; C)*. &#8718;\\n\\nNote: This result can be easily generalized to count the number of elements in the union of any finite collection of sets.\\n\\nGiven integers *a*,*b*, *c*, and *k*, let *A*, *B*, and *C* be the sets of multiples of *a*, *b*, and *c*, respectively, that are less than or equal to *k*. Then there are exactly *n(A &cup; B &cup; C)* numbers smaller than or equal to *k* that are divisible by *a*, *b*, or *c* (the ugly numbers smaller than or equal to *k*). Since a number is a multiple of *a* and *b* if and only if it is a multiple of *LCM(a, b)*, we have that *n(A &cap; B) =* `floor(k / lcm(a, b))`. Similarly, a number is a multiple of all *a*, *b*, and *c* if and only if it is a multiple of *LCM(a, b, c)*, so *n(A &cap; B &cap; C) =* `floor(k / lcm(a, b, c))`.\\n\\nTherefore, the number of ugly numbers that are less than or equal to *k* is given by\\n```\\nfloor(k / a) + floor(k / b) + floor(k / c) - floor(k / lcm(a, b)) - floor(k / lcm(a, c)) - floor(k / lcm(b, c)) + floor(k / lcm(a, b, c))\\n```\\n\\nSince *a &times; b = LCM(a, b) &times; GCD(a, b)*, and GCD is already available (based on Euclid\\'s algorithm), we can compute the LCM of two numbers as `a * b / gcd(a, b)`.\\n**Careful:** It is not always true that *a &times; b &times; c = LCM(a, b, c) &times; GCD(a, b, c)*. However, it is true that *LCM(a, b, c) = LCM(LCM(a, b), c)*.",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nfloor(k / a) + floor(k / b) + floor(k / c) - floor(k / lcm(a, b)) - floor(k / lcm(a, c)) - floor(k / lcm(b, c)) + floor(k / lcm(a, b, c))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387673,
                "title": "java-binary-search-solution-with-illustration-explanation-video",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Rl4PznQDz3o\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [],
                "code": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Rl4PznQDz3o\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 387568,
                "title": "easy-python-binary-search-no-need-to-consider-conner-cases",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            return abs(a*b) // math.gcd(a, b)\\n        def count(val,a,b,c):\\n            return val//a + val//b + val//c -val//lcm(a, b)-val//lcm(a, c)-val//lcm(c, b) + val//lcm(lcm(a, b),c)\\n        l = 1\\n        r = min([a,b,c]) * n\\n        tmp = (l+r)//2\\n        while count(tmp,a,b,c) != n-1:\\n            if count(tmp,a,b,c) > n-1:\\n                r = tmp\\n            else:\\n                l = tmp\\n            tmp = (l+r)//2\\n        while count(tmp,a,b,c) != n:\\n            tmp += 1\\n        return tmp\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            return abs(a*b) // math.gcd(a, b)\\n        def count(val,a,b,c):\\n            return val//a + val//b + val//c -val//lcm(a, b)-val//lcm(a, c)-val//lcm(c, b) + val//lcm(lcm(a, b),c)\\n        l = 1\\n        r = min([a,b,c]) * n\\n        tmp = (l+r)//2\\n        while count(tmp,a,b,c) != n-1:\\n            if count(tmp,a,b,c) > n-1:\\n                r = tmp\\n            else:\\n                l = tmp\\n            tmp = (l+r)//2\\n        while count(tmp,a,b,c) != n:\\n            tmp += 1\\n        return tmp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843224,
                "title": "my-java-solution-binary-search",
                "content": "The main note to remind in this problem is:\\nn(AUBUC) = n(A)+n(B)+n(C)-n(A\\u2229B)-n(A\\u2229C)-n(B\\u2229C)+n(A\\u2229B\\u2229C)\\n\\nnumber / lcm(a, b) is equivalent ot n(A\\u2229B)........\\n\\nI was stuck to get this equation and the template about binary search helped me with this idea.\\nhttps://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template-solved-many-problems\\n\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 1;\\n        int right = Integer.MAX_VALUE;\\n        int count = 0;\\n        while (left < right) {\\n            int middle = left + (right - left) / 2;\\n            if (isUgly(middle, a, b, c, n)) {\\n                right = middle;\\n            }\\n            else\\n                left = middle + 1;\\n        }\\n        return left;\\n    }\\n    public boolean isUgly(long middle, long a, long b, long c, long n) {\\n        return (int) (middle/a + middle/b + middle/c - middle/lcm(a, b) - middle/lcm(b, c) - middle/lcm(c, a) + middle/lcm(a, lcm(b, c))) >= n;\\n    }\\n    public long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        else return gcd(b%a, a);\\n    }\\n    public long lcm(long a, long b) {\\n        return a * b / (gcd(a, b)); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 1;\\n        int right = Integer.MAX_VALUE;\\n        int count = 0;\\n        while (left < right) {\\n            int middle = left + (right - left) / 2;\\n            if (isUgly(middle, a, b, c, n)) {\\n                right = middle;\\n            }\\n            else\\n                left = middle + 1;\\n        }\\n        return left;\\n    }\\n    public boolean isUgly(long middle, long a, long b, long c, long n) {\\n        return (int) (middle/a + middle/b + middle/c - middle/lcm(a, b) - middle/lcm(b, c) - middle/lcm(c, a) + middle/lcm(a, lcm(b, c))) >= n;\\n    }\\n    public long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        else return gcd(b%a, a);\\n    }\\n    public long lcm(long a, long b) {\\n        return a * b / (gcd(a, b)); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569006,
                "title": "c-explaination-with-code-100-time-and-space",
                "content": "There are three numbers a, b and c.\\nNow Suppose all multiples of a are represented by set A, B represents same for b and C does for c;\\nNow it is possible that one or more members of set A are present in B(i.e. A \\u2229 B) and some menbers are present C(A\\u2229C).\\nSimilarly for B and C some member(B\\u2229C) and some are present in all 3 (A\\u2229B\\u2229C). \\nNow we aim to find the lowest number for which A U B U C (i.e. with no repetition) = n. This lowest number represents the nth number. \\nUsing set theory, \\n\\tA U B U C = A + B + C - A\\u2229B - B\\u2229C - A\\u2229C + A\\u2229B\\u2229C\\n\\nWe use lcm of the numbers to find the number of multiples for that set i.e. A = m/A, B\\u2229C = M / LCM(B,C). We can find lcm using LCM (A,B) = A*B / GCD(A,B).\\n\\nWe use Binary Search technique to find the lowest number.\\nlowerBound = 2, upperBound =1e18\\n```\\n\\n#define lli long long int\\n#define mod 1e9 + 7\\nclass Solution {\\n    int gcd(lli a, lli b){\\n        if(a<b)\\n            return gcd(b,a);\\n        if(b==0)\\n            return a;\\n        return gcd(b, a%b);\\n    }\\n    \\npublic:\\n    int nthUglyNumber(int n, lli a, lli b, lli c) {\\n        lli lAB = (a*b)/gcd(a,b);\\n        lli lBC = (b*c)/gcd(b,c);\\n        lli lAC = (a*c)/gcd(a,c); \\n        lli lABC = lAB*c/gcd(lAB, c);\\n        lli l = 2;\\n        lli r = 1e18;\\n        while(l<r){\\n            lli m = (l+r)/2;\\n            if(m/a + m/b + m/c + m/lABC -m/lAB -m/lBC -m/lAC < n)\\n                l = m+1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n#define lli long long int\\n#define mod 1e9 + 7\\nclass Solution {\\n    int gcd(lli a, lli b){\\n        if(a<b)\\n            return gcd(b,a);\\n        if(b==0)\\n            return a;\\n        return gcd(b, a%b);\\n    }\\n    \\npublic:\\n    int nthUglyNumber(int n, lli a, lli b, lli c) {\\n        lli lAB = (a*b)/gcd(a,b);\\n        lli lBC = (b*c)/gcd(b,c);\\n        lli lAC = (a*c)/gcd(a,c); \\n        lli lABC = lAB*c/gcd(lAB, c);\\n        lli l = 2;\\n        lli r = 1e18;\\n        while(l<r){\\n            lli m = (l+r)/2;\\n            if(m/a + m/b + m/c + m/lABC -m/lAB -m/lBC -m/lAC < n)\\n                l = m+1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514893,
                "title": "python-sol-by-binary-search-and-set-theory-80-with-hint-and-comment",
                "content": "Python sol. by **binary-search** and **set-theory**.\\n\\n---\\n\\n**Hint**:\\n\\n#1.\\nThink of **multiple counting** and **set theory**\\n\\nBy **set theory**, we can know **total number of multiples** in within given range within positive integer *k*.\\n\\n---\\n\\nTake *a*, *b*, *c* = 2, 3, 5, *k*=50 for example\\n\\nTotal number of multiple on *a*=2, *b*=3, *c*=5, from 1 to k = 50\\n\\n= ( k // 2 + k // 3 + k // 5 ) - ( k // lcm(2,3) - k // lcm(2, 5) - k // lcm(3, 5) ) + k // lcm( 2, 3, 5 )\\n\\n= 50 // 2 + 50 // 3 + 50 // 5 - 50 // 6 - 50 // 10 - 50 // 15 + 50 // 30\\n\\n= #Mutiple of 2 + #Multiple of 3 + #Multiple of 5 - #Multiple of 6 - #Multiple of 10 - #Multiple of 15+ #Multiple of 30\\n\\n= 25 + 16 + 10 - 8 - 5 - 3 + 1\\n\\n= 36 = **n**\\n\\nTherefore, we can say k=50 is the n = 36th ug1y number of 2, 3, 5.\\n\\n---\\n\\n#2.\\nThink of the **framework of Binary search**.\\n\\nUse **binary search** to compute the **smallest k** such that there are **n multiples of a, b, c**.\\nThat also means, k is the nth u-number of a, b, c.\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    \\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        \\n        def lcm( x, y):\\n            \\n            # From number theory,\\n            # gcd(x,y) * lcm(x,y) = x * y\\n            \\n            return  x * y  // gcd(x,y)        \\n        \\n        # -----------------------------------\\n        \\n        def total_num_of_multiples( number, a, b, c):\\n            \\n            # From set theory,\\n            # count the total number of mutiples of a, b, c, range from 1 to number.\\n            ab = lcm(a,b)\\n            bc = lcm(b,c)\\n            ac = lcm(a,c)\\n\\n            abc = lcm(a, bc)\\n\\n            result = number // a + number // b + number // c \\n            result -= number // ab + number // bc + number // ac\\n            result += number // abc\\n\\n            return result        \\n        \\n        # -----------------------------------\\n        \\n        # Goal:\\n        # Find the smallest number k, such that k has n multiples of a, b, or c.\\n        \\n        # Binary search approach\\n        lower = 1\\n        upper = 2 * (10 ** 9)\\n        \\n        while lower < upper:\\n            \\n            mid = lower + (upper - lower) // 2\\n            \\n            count_of_u_number = total_num_of_multiples(mid, a, b, c)\\n\\n            if count_of_u_number >= n:\\n                upper = mid\\n                \\n            else:\\n                lower = mid+1\\n            \\n        return lower\\n        \\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #263 Ugly Number](https://leetcode.com/problems/ugly-number)\\n\\n[Leetcode #264 Ugly Number II](https://leetcode.com/problems/ugly-number-ii)\\n\\n[Leetcode #313 Super Ugly Number](https://leetcode.com/problems/super-ugly-number/)\\n\\n\\n---\\n\\nReference:\\n\\n[1] [GfG: Count of Multiples of A ,B or C less than or equal to N](https://www.geeksforgeeks.org/count-of-multiples-of-a-b-or-c-less-than-or-equal-to-n/)",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nfrom math import gcd\\n\\nclass Solution:\\n    \\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        \\n        def lcm( x, y):\\n            \\n            # From number theory,\\n            # gcd(x,y) * lcm(x,y) = x * y\\n            \\n            return  x * y  // gcd(x,y)        \\n        \\n        # -----------------------------------\\n        \\n        def total_num_of_multiples( number, a, b, c):\\n            \\n            # From set theory,\\n            # count the total number of mutiples of a, b, c, range from 1 to number.\\n            ab = lcm(a,b)\\n            bc = lcm(b,c)\\n            ac = lcm(a,c)\\n\\n            abc = lcm(a, bc)\\n\\n            result = number // a + number // b + number // c \\n            result -= number // ab + number // bc + number // ac\\n            result += number // abc\\n\\n            return result        \\n        \\n        # -----------------------------------\\n        \\n        # Goal:\\n        # Find the smallest number k, such that k has n multiples of a, b, or c.\\n        \\n        # Binary search approach\\n        lower = 1\\n        upper = 2 * (10 ** 9)\\n        \\n        while lower < upper:\\n            \\n            mid = lower + (upper - lower) // 2\\n            \\n            count_of_u_number = total_num_of_multiples(mid, a, b, c)\\n\\n            if count_of_u_number >= n:\\n                upper = mid\\n                \\n            else:\\n                lower = mid+1\\n            \\n        return lower\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 387582,
                "title": "1ms-java-binary-search",
                "content": "https://www.geeksforgeeks.org/find-the-nth-term-divisible-by-a-or-b-or-c/\\nto understand it better read this post of GFG\\n\\nOur range ~ 10^9\\nso replace int to long \\n\\n```\\npublic static int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = Integer.MAX_VALUE, mid;\\n\\n        while (low < high) {\\n            mid = low + (high - low) / 2;\\n            if (divTermCount(a, b, c, mid) < n)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n\\n    static long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    static long lcm(long a, long b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n\\n    static long divTermCount(long a, long b, long c, long num) {\\n        return ((num / a) + (num / b) + (num / c)\\n                - (num / lcm(a, b))\\n                - (num / lcm(b, c))\\n                - (num / lcm(a, c))\\n                + (num / lcm(a, lcm(b, c))));\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\npublic static int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = Integer.MAX_VALUE, mid;\\n\\n        while (low < high) {\\n            mid = low + (high - low) / 2;\\n            if (divTermCount(a, b, c, mid) < n)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n\\n    static long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    static long lcm(long a, long b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n\\n    static long divTermCount(long a, long b, long c, long num) {\\n        return ((num / a) + (num / b) + (num / c)\\n                - (num / lcm(a, b))\\n                - (num / lcm(b, c))\\n                - (num / lcm(a, c))\\n                + (num / lcm(a, lcm(b, c))));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 388652,
                "title": "clear-python-solution",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a,b):\\n            return a if b == 0 else gcd(b,a%b)\\n            \\n        def lcm(a,b):\\n            return a*b//gcd(a,b)\\n        \\n        def count(n,a,b,c):\\n            # count ugly number n\\'s position\\n            return n//a + n//b + n//c - n//lcm(a,b) - n//lcm(a,c) - n//lcm(b,c) + n//lcm(lcm(a,b),c)\\n        \\n        l = 1\\n        r = n*min(a,b,c)\\n        while l<r:\\n            mid = (l+r)//2\\n            if count(mid,a,b,c) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        \\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a,b):\\n            return a if b == 0 else gcd(b,a%b)\\n            \\n        def lcm(a,b):\\n            return a*b//gcd(a,b)\\n        \\n        def count(n,a,b,c):\\n            # count ugly number n\\'s position\\n            return n//a + n//b + n//c - n//lcm(a,b) - n//lcm(a,c) - n//lcm(b,c) + n//lcm(lcm(a,b),c)\\n        \\n        l = 1\\n        r = n*min(a,b,c)\\n        while l<r:\\n            mid = (l+r)//2\\n            if count(mid,a,b,c) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        \\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387526,
                "title": "python-binary-search-o-log-n",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        # basic function for LCM\\n        import math\\n        def lcm(x, y):\\n            return (x * y) // math.gcd(x, y)\\n\\n        lcm1 = lcm(a, b)\\n        lcm2 = lcm(b, c)\\n        lcm3 = lcm(c, a)\\n        lcm4 = lcm(lcm1, lcm2)\\n\\n        # count how many ugly numbers exist below x\\n        def count_below(x):\\n            return x // a + x // b + x // c + x // lcm4 - (x // lcm1 + x // lcm2 + x // lcm3)\\n\\n        # binary search\\n        lb = 0\\n        ub = 2 * 10 ** 9\\n        while (ub - lb > 1):\\n            mid = (lb + ub) // 2\\n            if count_below(mid) >= n:\\n                ub = mid\\n            else:\\n                lb = mid\\n\\n        return ub\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        # basic function for LCM\\n        import math\\n        def lcm(x, y):\\n            return (x * y) // math.gcd(x, y)\\n\\n        lcm1 = lcm(a, b)\\n        lcm2 = lcm(b, c)\\n        lcm3 = lcm(c, a)\\n        lcm4 = lcm(lcm1, lcm2)\\n\\n        # count how many ugly numbers exist below x\\n        def count_below(x):\\n            return x // a + x // b + x // c + x // lcm4 - (x // lcm1 + x // lcm2 + x // lcm3)\\n\\n        # binary search\\n        lb = 0\\n        ub = 2 * 10 ** 9\\n        while (ub - lb > 1):\\n            mid = (lb + ub) // 2\\n            if count_below(mid) >= n:\\n                ub = mid\\n            else:\\n                lb = mid\\n\\n        return ub\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867599,
                "title": "100-faster-binary-search-easy-understand-c-solution",
                "content": "```\\ntypedef long long ll;\\n#define MAX_ANS 2e9 \\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { \\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long ll;\\n#define MAX_ANS 2e9 \\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { \\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012626,
                "title": "java-binary-search-w-gcd-lcm",
                "content": "The total area of this graph is `A + B + C - AB - AC - BC + ABC`, and that\\'s what we will use to solve this problem. \\nFor example, A = 3, B = 5, C = 2, then 6 belong to AC, and 30 belong to ABC.\\n\\nBe careful about overflowing.\\n\\n![image](https://assets.leetcode.com/users/images/3874e36d-da07-4a95-bfa7-84e1f92d3428_1651814281.0619926.png)\\n\\n\\n```Java\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int lo = 1, hi = (int)2e9;\\n        long ab = lcm(a, b), ac = lcm(a, c), bc = lcm(b, c), abc = lcm(ab, c);\\n        while(lo < hi){\\n            int mid = lo + (hi - lo)/2;\\n            long count = 0L + mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc;\\n            if (count >= n)\\n                hi = mid;\\n            else\\n                lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n\\n    private long gcd(long a, long b){\\n        return b == 0? a : gcd(b, a % b);\\n    }\\n\\n    private long lcm(long a, long b){\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int lo = 1, hi = (int)2e9;\\n        long ab = lcm(a, b), ac = lcm(a, c), bc = lcm(b, c), abc = lcm(ab, c);\\n        while(lo < hi){\\n            int mid = lo + (hi - lo)/2;\\n            long count = 0L + mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc;\\n            if (count >= n)\\n                hi = mid;\\n            else\\n                lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n\\n    private long gcd(long a, long b){\\n        return b == 0? a : gcd(b, a % b);\\n    }\\n\\n    private long lcm(long a, long b){\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828662,
                "title": "1201-ugly-number-iii",
                "content": "### ***ALERTT\\n### FIRST SEE THE LOG![image](https://assets.leetcode.com/users/images/62337ea0-5bb9-4c8f-a25f-6f2e51083c9c_1646671980.7753525.jpeg)\\nIC THEN GO TO CODE \\n### PLZZZ LIKE IT*\\n```\\nclass Solution {\\npublic:\\n        using ll=long long int;\\n        ll lcm(ll a,ll b)\\n        {\\n                return (a*b)/(__gcd(a,b));\\n        }\\n        ll solve(ll a,ll b, ll c,ll mid)\\n        {\\n                return (mid/a)+(mid/b)+(mid/c)-(mid/lcm(a,b))-(mid/lcm(a,c))-(mid/lcm(b,c))+(mid/(lcm(a,lcm(b,c))));\\n        }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll start=min({a,b,c});\\n            ll end=INT_MAX;\\n            ll ans;\\n            while(start<=end)\\n            {\\n                    ll mid=start+(end-start)/2;\\n                    if(solve(a,b,c,mid)<n)\\n                    {\\n                            start=mid+1;\\n                    }\\n                    else\\n                    {\\n                            ans=mid;\\n                            end=mid-1;\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        using ll=long long int;\\n        ll lcm(ll a,ll b)\\n        {\\n                return (a*b)/(__gcd(a,b));\\n        }\\n        ll solve(ll a,ll b, ll c,ll mid)\\n        {\\n                return (mid/a)+(mid/b)+(mid/c)-(mid/lcm(a,b))-(mid/lcm(a,c))-(mid/lcm(b,c))+(mid/(lcm(a,lcm(b,c))));\\n        }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll start=min({a,b,c});\\n            ll end=INT_MAX;\\n            ll ans;\\n            while(start<=end)\\n            {\\n                    ll mid=start+(end-start)/2;\\n                    if(solve(a,b,c,mid)<n)\\n                    {\\n                            start=mid+1;\\n                    }\\n                    else\\n                    {\\n                            ans=mid;\\n                            end=mid-1;\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742578,
                "title": "java-o-n-vs-binary-search-o-lgn",
                "content": "Version 1, brutal force, O(N), TLE\\nActually I gave this version while my FB phone screen and passed the interview. \\nI don\\'t think it is a bad solution, though.\\nIt is concise, clean and straightforward.\\n```\\n        int am = 1, bm = 1, cm = 1, cnt = 0, min = 1;\\n        while (cnt++ < n) {\\n            int an = am * a, bn = bm * b, cn = cm * c;\\n            min = Math.min(an, Math.min(bn, cn));\\n            if (an == min) am++;\\n            if (bn == min) bm++;\\n            if (cn == min) cm++;\\n        }\\n        return min;\\n```\\n\\nversion 2 \\nBinary Search O(lgN);\\nref https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long l = 0, r = 2_000_000_000, res = 0;\\n        long ab = lcm((long) a, (long) b), ac = lcm((long) a, (long) c), bc = lcm((long) b, (long) c), abc = lcm(a, bc);\\n        while (l < r) {\\n            long mid = l + (r - l) / 2;\\n            if (count(mid, a, b, c, ab, ac, bc, abc) < n) l = mid + 1;\\n            else r = mid;\\n        }\\n        return (int) l;\\n    }\\n    \\n    private long count(long num, int a, int b, int c, long ab, long ac, long bc, long abc) {\\n        return num / a + num / b + num / c \\n            - num / ab - num /ac - num / bc\\n            + num / abc;\\n    } \\n    \\n    private long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n    \\n    private long gcd(long a, long b) {\\n        if (a < b) return gcd(b, a);\\n        while (b > 0) {\\n            long tmp = a % b;\\n            a = b;\\n            b = tmp;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n        int am = 1, bm = 1, cm = 1, cnt = 0, min = 1;\\n        while (cnt++ < n) {\\n            int an = am * a, bn = bm * b, cn = cm * c;\\n            min = Math.min(an, Math.min(bn, cn));\\n            if (an == min) am++;\\n            if (bn == min) bm++;\\n            if (cn == min) cm++;\\n        }\\n        return min;\\n```\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long l = 0, r = 2_000_000_000, res = 0;\\n        long ab = lcm((long) a, (long) b), ac = lcm((long) a, (long) c), bc = lcm((long) b, (long) c), abc = lcm(a, bc);\\n        while (l < r) {\\n            long mid = l + (r - l) / 2;\\n            if (count(mid, a, b, c, ab, ac, bc, abc) < n) l = mid + 1;\\n            else r = mid;\\n        }\\n        return (int) l;\\n    }\\n    \\n    private long count(long num, int a, int b, int c, long ab, long ac, long bc, long abc) {\\n        return num / a + num / b + num / c \\n            - num / ab - num /ac - num / bc\\n            + num / abc;\\n    } \\n    \\n    private long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n    \\n    private long gcd(long a, long b) {\\n        if (a < b) return gcd(b, a);\\n        while (b > 0) {\\n            long tmp = a % b;\\n            a = b;\\n            b = tmp;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696041,
                "title": "python-binary-search-and-math-with-detailed-explanation-and-complexity",
                "content": "The idea is, we search for the smallest K such that the number of numbers divisible by a or b or c in [1, K] is exactly N.\\nWe know the number of numbers divisible by x in [1, K] is K div x (or K // x, in Python).\\nThe number of numbers divisible by a or b or c in [1, K]:\\n= #(divisible by a) + #(divisible by b) + #(divisible by c) - #(divisible by a, b) - #(divisible by (b, c)) - #(divisible by a, c) + #(divisible by a, b, c)\\n= (K//a + K// b + K//c) - (K//lcm(a,b) + K//lcm(b, c) + K//lcm(c, a)) + K//lcm(a, b, c)\\n\\nwhere lcm is lowest common multiplier of the inside numeric arguments.\\nTime Complexity: Note that the time complexity of computing lcm or gcd is O(log N). Thus, the overall time complexity is O((logN)^2)\\n```\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            prod = a*b\\n            if a < b:\\n                a, b = b, a\\n            while b > 0:\\n                a = a % b\\n                a, b = b, a\\n            return prod//a\\n        def count(k):\\n            #how many numbers divisible by a or b or c in [1, k]\\n            na = k // a\\n            nb = k // b\\n            nc = k // c\\n            nab = k // lcm(a, b)\\n            nac = k // lcm(a, c)\\n            nbc = k // lcm(b, c)\\n            nabc = k // lcm(lcm(a, b), c)\\n            return na + nb + nc - nab - nac - nbc + nabc\\n        l, r = 0, 2*10**9\\n        while l <= r:\\n            mid = l + (r - l)//2\\n            if count(mid) >= n:\\n                if count(mid) == n and (mid % a == 0 or mid % b == 0 or mid % c == 0):\\n                    return mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "solutionTags": [],
                "code": "```\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            prod = a*b\\n            if a < b:\\n                a, b = b, a\\n            while b > 0:\\n                a = a % b\\n                a, b = b, a\\n            return prod//a\\n        def count(k):\\n            #how many numbers divisible by a or b or c in [1, k]\\n            na = k // a\\n            nb = k // b\\n            nc = k // c\\n            nab = k // lcm(a, b)\\n            nac = k // lcm(a, c)\\n            nbc = k // lcm(b, c)\\n            nabc = k // lcm(lcm(a, b), c)\\n            return na + nb + nc - nab - nac - nbc + nabc\\n        l, r = 0, 2*10**9\\n        while l <= r:\\n            mid = l + (r - l)//2\\n            if count(mid) >= n:\\n                if count(mid) == n and (mid % a == 0 or mid % b == 0 or mid % c == 0):\\n                    return mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 388429,
                "title": "wrong-test-case",
                "content": "Run the last given case in the description:\\n```\\n1000000000\\n2\\n217983653\\n336916467\\n```\\nThe expected answer is `1999999984`, which is the same as in the description.\\n\\nBut when run this case, moving `2` to the last line, switching `a`,`b`,`c`:\\n```\\n1000000000\\n217983653\\n336916467\\n2\\n```\\nThe expected answer becomes `1999999982`, which is wrong.",
                "solutionTags": [],
                "code": "```\\n1000000000\\n2\\n217983653\\n336916467\\n```\n```\\n1000000000\\n217983653\\n336916467\\n2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274620,
                "title": "math",
                "content": "Here we count the occurence of number which are multiple of a,b,c which are less than equal to val. \\nThe main principle used here is\\n> **The principle of inclusion and exclusion (PIE)** is a counting technique that computes the number of elements that satisfy at least one of several properties while guaranteeing that elements satisfying more than one property are not counted twice.\\n\\nAn underlying idea behind PIE is that summing the number of elements that satisfy at least one of two categories and subtracting the overlap prevents double counting.\\n\\nSimple Formula is $$ n(A \\u222A B \\u222A C) = n(A) + n(B) + n(C) - n(A \\u2229 B) - n(A \\u2229 C) - n(B \\u2229 C) + n(A \\u2229 B \\u2229 C) $$\\n\\nIt is visually easy to prove this point (See the image ) - \\n![Screenshot_20230309_094721.png](https://assets.leetcode.com/users/images/1149e415-5fd7-40fb-9fc8-f6df083f91d7_1678335798.192373.png)\\n\\nA+B+C = (a+d+g+f) + (d+b+g+e) + (f+g+e+c) - (d+g) - (f+g) - (g+e) + (g)\\n\\nHere we have to add common part of A,B,C (i.e g) because g is added 3 times and is also subtracted 3 times \\n\\n>Tip: LCM(a,b) = GCD(a,b) / (a*b) is True but it is not guranteed that\\nLCM(a,b,c) = GCD(a,b,c) / (a*b*c). But it is guranteed that LCM(a,b,c)=LCM(a, LCM(b,c) ) !!\\n\\n# Code\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        low = min(a,b,c)\\n        high = 2*10**9\\n\\n        def feasible(val):\\n            result = val//a + val//b + val//c - val//lcm(a,b) - val//lcm(b,c) - val//lcm(a,c) + val//lcm(a,b,c)\\n            return result>=n\\n        \\n        while low<high:\\n            mid = low+high>>1\\n            if feasible(mid):\\n                high = mid\\n            else:\\n                low= mid+1\\n        return low\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        low = min(a,b,c)\\n        high = 2*10**9\\n\\n        def feasible(val):\\n            result = val//a + val//b + val//c - val//lcm(a,b) - val//lcm(b,c) - val//lcm(a,c) + val//lcm(a,b,c)\\n            return result>=n\\n        \\n        while low<high:\\n            mid = low+high>>1\\n            if feasible(mid):\\n                high = mid\\n            else:\\n                low= mid+1\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443538,
                "title": "an-important-pitfall-that-most-of-the-posts-didn-t-mention",
                "content": "Most posts didn\\'t cover why we can not simply return the value when that matched to n, which is an important part we need to clarify during an interview.\\n\\nThe answer is that the binary search can pass non-ugly numbers when calculating the current value\\'s ranking. \\nJust because we found the nth number doesn\\'t mean it\\'s a valid answer.\\n\\nI hope the following code will help to understand the detail of the exit condition.\\n\\n\\n```\\nfrom math import lcm\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        def ranking_of(value): \\n\\t\\t# Input value can be a non-ugly number.\\n\\t\\t# In that case, this can return the same value toward different inputs due to its floor div operations.\\n\\t\\t# i.e. Smallest input that provides the same answer is the valid number.\\n            return (value // a) + (value // b) + (value // c) - (value // lcm(a, b)) - (value // lcm(b, c)) - (value // lcm(c, a)) + (value // lcm(a, b, c))\\n        \\n  \\n        l = 1\\n        r = 2 * (10 ** 9)\\n        \\n        smallest_satisifed = None\\n        while l <= r:\\n            value = (l + r) // 2\\n            rank = ranking_of(value)\\n            if rank < n:\\n                l = value + 1\\n            else: # rank >= n\\n                # We can not return the rank immediately when we face n == rank, since the value provoded this binary search can be a \"non-ugly\" number. \\n                smallest_satisifed = value\\n                r = value - 1\\n        return smallest_satisifed\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom math import lcm\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        def ranking_of(value): \\n\\t\\t# Input value can be a non-ugly number.\\n\\t\\t# In that case, this can return the same value toward different inputs due to its floor div operations.\\n\\t\\t# i.e. Smallest input that provides the same answer is the valid number.\\n            return (value // a) + (value // b) + (value // c) - (value // lcm(a, b)) - (value // lcm(b, c)) - (value // lcm(c, a)) + (value // lcm(a, b, c))\\n        \\n  \\n        l = 1\\n        r = 2 * (10 ** 9)\\n        \\n        smallest_satisifed = None\\n        while l <= r:\\n            value = (l + r) // 2\\n            rank = ranking_of(value)\\n            if rank < n:\\n                l = value + 1\\n            else: # rank >= n\\n                # We can not return the rank immediately when we face n == rank, since the value provoded this binary search can be a \"non-ugly\" number. \\n                smallest_satisifed = value\\n                r = value - 1\\n        return smallest_satisifed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299901,
                "title": "python-brute-force-to-optimzied-sol-full-detailed-explanation",
                "content": "\\n# EXPLANATION BRUTE FORCE\\n```\\nBrute force is trying each number from 1 untill we get our nth ugly number\\nNow we can improve this approach by using the idea that we need to get the nth ugly number which is divisible  by a,b,or c\\n\\nSo we make a list of size 3 \"times = [1,1,1]\" having all values as 1 indicating the current number \\nusing number a,b,c, respectively\\n\\nNow we find the smallest number  which will be minimum of \\n( times[0] * a, times[1] * b , times[c] * c )\\n\\nTHE smallest one can also occur by more than 1 source that is 2,3 may collide at 6\\nso we traverse the list and compare the smallest with times[0]*a , times[1]*b and times[2]*c and if smallest is equal to it we increment times[i] by 1 making the number its next occurence\\n\\n```\\n\\n\\n# CODE ( UNOPTIMIZED / BRUTE FORCE + )\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        times = [1,1,1]\\n        smallest = inf\\n        while n != 0:\\n            smallest = min ( times[0]*a,times[1]*b,times[2]*c)\\n            if times[0]*a == smallest: times[0] += 1\\n            if times[1]*b == smallest: times[1] += 1\\n            if times[2]*c == smallest: times[2] += 1\\n            n -= 1\\n        return smallest\\n```\\n\\n# EXPLANATION BINARY SEARCH + VENN DIAGRAM\\n![image](https://assets.leetcode.com/users/images/67651342-d4fc-4076-8c46-27fc7f840b35_1658155062.1077657.png)\\n\\na \\u2229 b \\u2229 c = a \\u222A b + a \\u222A c + b \\u222A c - a \\u2229 b - a \\u2229 c - b \\u2229 c + a \\u2229 b \\u2229 c\\n\\n```\\nLets say we have a = 2 , b = 3, c  = 5 , n = 10\\nNow the number must lie between the first occurence = min(a,b,c) i.e. 2\\nand the n th occurence in case of no collision = min(a,b,c) * n i.e. 20\\nas 2 , 4, 6 , 8 ,10 ,12 , 14 , 16 18 ,20 will lead to 10th ugly number is b,c do not collide\\n\\nNow since we know the range ... how can we decide to choose the left half or the right half\\n... The main logic of binary search\\n\\nSee if we get to know the count of ugly numbers till mid we can decide which way to walk\\n\\nSO the question is how to find the count\\n\\n\\nSay numbers a = 2 , b = 3 , c = 5 , n = 10\\nlow = 2\\nhigh = 20\\nmid = 11\\n\\nNow we need to find the count of ugly numbers till 11........\\nremember the formula\\na \\u2229 b \\u2229 c = a \\u222A b + a \\u222A c + b \\u222A c - a \\u2229 b - a \\u2229 c - b \\u2229 c + a \\u2229 b \\u2229 c\\n\\nhow many 2s will occur till 11 = 11 // 2 = 5 ( 2,4,6,8,10)\\nhow many 3s will occur till 11 = 11 // 3 = 3 ( 3,6,9)\\nhow many 5s will occur till 11 = 11 // 5 = 2 ( 5,10)\\nnow 2,3 may collide so we count them as\\n11 // (lcm 2,3) = 11 // 6 = 1 (6)\\nnow 2,5 may collide so we count them as\\n11 // (lcm 2,5) = 11 // 10 = 1(10)\\nnow 3,5 may collide so we count them as\\n11 // (lcm 3,5) = 11 // 15  = 0 \\nnow we may have count collision of (2,3) and (2,5) but it should be counted once as (2,3,5)\\nso we have to add 11 // (lcm 2,3,5) = 11// 30 = 0\\n\\nSo according to our formula total count  = 5 + 3 + 2 - 1 - 1 - 0 + 0  =  8\\n(2,4,6,8,10) + ( 3,6,9) + (5,10) - (6) - (10) - ( )  + ( ) =  (2,3,4,5,6,8,9,10)\\n\\nNow since the count is 8 and we need 10th ugly number we should go right\\n\\n\\n\\n\\nTO GET LCM of two numbers:\\n\\tLCM(a,b) * HCF(a,b)   =  a*b\\n\\t\\nTO GET LCM of three numbers:\\n\\tLCM(a,b,c) = a*b*c*HCF(a,b,c) //  HCF(a,b) * HCF(b,c) * HCF(a,c)\\n```\\n# CODE ( BINARY SEARCH )\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        a,b,c = sorted((a,b,c))\\n        ans = inf\\n        def hcf(a,b):\\n            if a %b == 0: return b\\n            return hcf(b , a % b)\\n        p,q,r= hcf(a,b),hcf(b,c),hcf(a,c)\\n        s = hcf(r,b)\\n        x1 = (a*b) // p\\n        x2 = (b*c) // q \\n        x3 = (a*c) // r\\n        x4 = (a * b * c * s)// (p * q * r )\\n        low,high = a , a *n\\n        while low <= high:\\n            mid = (low + high)//2\\n            times = mid//a + mid//b + mid//c - mid//x1 - mid//x2 - mid//x3 + mid//x4\\n            if times < n : low = mid + 1\\n            elif times == n:\\n                ans = min(ans,mid)\\n                high = mid - 1\\n            else: high = mid - 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nBrute force is trying each number from 1 untill we get our nth ugly number\\nNow we can improve this approach by using the idea that we need to get the nth ugly number which is divisible  by a,b,or c\\n\\nSo we make a list of size 3 \"times = [1,1,1]\" having all values as 1 indicating the current number \\nusing number a,b,c, respectively\\n\\nNow we find the smallest number  which will be minimum of \\n( times[0] * a, times[1] * b , times[c] * c )\\n\\nTHE smallest one can also occur by more than 1 source that is 2,3 may collide at 6\\nso we traverse the list and compare the smallest with times[0]*a , times[1]*b and times[2]*c and if smallest is equal to it we increment times[i] by 1 making the number its next occurence\\n\\n```\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        times = [1,1,1]\\n        smallest = inf\\n        while n != 0:\\n            smallest = min ( times[0]*a,times[1]*b,times[2]*c)\\n            if times[0]*a == smallest: times[0] += 1\\n            if times[1]*b == smallest: times[1] += 1\\n            if times[2]*c == smallest: times[2] += 1\\n            n -= 1\\n        return smallest\\n```\n```\\nLets say we have a = 2 , b = 3, c  = 5 , n = 10\\nNow the number must lie between the first occurence = min(a,b,c) i.e. 2\\nand the n th occurence in case of no collision = min(a,b,c) * n i.e. 20\\nas 2 , 4, 6 , 8 ,10 ,12 , 14 , 16 18 ,20 will lead to 10th ugly number is b,c do not collide\\n\\nNow since we know the range ... how can we decide to choose the left half or the right half\\n... The main logic of binary search\\n\\nSee if we get to know the count of ugly numbers till mid we can decide which way to walk\\n\\nSO the question is how to find the count\\n\\n\\nSay numbers a = 2 , b = 3 , c = 5 , n = 10\\nlow = 2\\nhigh = 20\\nmid = 11\\n\\nNow we need to find the count of ugly numbers till 11........\\nremember the formula\\na \\u2229 b \\u2229 c = a \\u222A b + a \\u222A c + b \\u222A c - a \\u2229 b - a \\u2229 c - b \\u2229 c + a \\u2229 b \\u2229 c\\n\\nhow many 2s will occur till 11 = 11 // 2 = 5 ( 2,4,6,8,10)\\nhow many 3s will occur till 11 = 11 // 3 = 3 ( 3,6,9)\\nhow many 5s will occur till 11 = 11 // 5 = 2 ( 5,10)\\nnow 2,3 may collide so we count them as\\n11 // (lcm 2,3) = 11 // 6 = 1 (6)\\nnow 2,5 may collide so we count them as\\n11 // (lcm 2,5) = 11 // 10 = 1(10)\\nnow 3,5 may collide so we count them as\\n11 // (lcm 3,5) = 11 // 15  = 0 \\nnow we may have count collision of (2,3) and (2,5) but it should be counted once as (2,3,5)\\nso we have to add 11 // (lcm 2,3,5) = 11// 30 = 0\\n\\nSo according to our formula total count  = 5 + 3 + 2 - 1 - 1 - 0 + 0  =  8\\n(2,4,6,8,10) + ( 3,6,9) + (5,10) - (6) - (10) - ( )  + ( ) =  (2,3,4,5,6,8,9,10)\\n\\nNow since the count is 8 and we need 10th ugly number we should go right\\n\\n\\n\\n\\nTO GET LCM of two numbers:\\n\\tLCM(a,b) * HCF(a,b)   =  a*b\\n\\t\\nTO GET LCM of three numbers:\\n\\tLCM(a,b,c) = a*b*c*HCF(a,b,c) //  HCF(a,b) * HCF(b,c) * HCF(a,c)\\n```\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        a,b,c = sorted((a,b,c))\\n        ans = inf\\n        def hcf(a,b):\\n            if a %b == 0: return b\\n            return hcf(b , a % b)\\n        p,q,r= hcf(a,b),hcf(b,c),hcf(a,c)\\n        s = hcf(r,b)\\n        x1 = (a*b) // p\\n        x2 = (b*c) // q \\n        x3 = (a*c) // r\\n        x4 = (a * b * c * s)// (p * q * r )\\n        low,high = a , a *n\\n        while low <= high:\\n            mid = (low + high)//2\\n            times = mid//a + mid//b + mid//c - mid//x1 - mid//x2 - mid//x3 + mid//x4\\n            if times < n : low = mid + 1\\n            elif times == n:\\n                ans = min(ans,mid)\\n                high = mid - 1\\n            else: high = mid - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569253,
                "title": "javascript-binary-search-with-with-lcm-76ms",
                "content": "```\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\nconst lcm = (a, b) => (a / gcd(a, b)) * b;\\nconst ll = BigInt;\\n\\nconst nthUglyNumber = (n, a, b, c) => {\\n    let low = 0n, high = ll(2e9);\\n    let ab = lcm(a, b), bc = lcm(b, c), ac = lcm(a, c), abc = lcm(a, bc);\\n    a = ll(a), b = ll(b), c = ll(c), ab = ll(ab), bc = ll(bc), ac = ll(ac), abc = ll(abc);\\n    while (low < high) {\\n        let mid = low + high >> 1n;\\n        let cnt = mid / a + mid / b + mid / c - mid / ab - mid / bc - mid / ac + mid / abc;\\n        cnt < n ? low = mid + 1n : high = mid;\\n    }\\n    return low;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\nconst lcm = (a, b) => (a / gcd(a, b)) * b;\\nconst ll = BigInt;\\n\\nconst nthUglyNumber = (n, a, b, c) => {\\n    let low = 0n, high = ll(2e9);\\n    let ab = lcm(a, b), bc = lcm(b, c), ac = lcm(a, c), abc = lcm(a, bc);\\n    a = ll(a), b = ll(b), c = ll(c), ab = ll(ab), bc = ll(bc), ac = ll(ac), abc = ll(abc);\\n    while (low < high) {\\n        let mid = low + high >> 1n;\\n        let cnt = mid / a + mid / b + mid / c - mid / ab - mid / bc - mid / ac + mid / abc;\\n        cnt < n ? low = mid + 1n : high = mid;\\n    }\\n    return low;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1289614,
                "title": "binary-search-template-just-figure-out-the-math-visualised",
                "content": "# [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/)\\n\\n---\\n\\n### Hints :\\n\\n-   Topics :\\n    -   #medium\\n    -   #math\\n    -   #binarysearch\\n        -   #seachonans/[Template](https://leetcode.com/discuss/general-discussion/786126/Python-Powerful-Ultimate-Binary-Search-Template.-Solved-many-problems)\\n\\n---\\n\\n## Explanation :\\n\\n-   **Key observations**:\\n\\n    -   > Apply template but figure out the math part\\n    -   > **let A be set of multiples of A that are smaller than equal to the given key**...B be ...C be..\\n    -   > ==Our ans will lie in the set of (A + B + C) merged set with unique elements==\\n    -   > we know : ![image](https://assets.leetcode.com/users/hiepit/image_1569139496.png)\\n    -   > _we are taking set as cardinality of the set rather than its elements since we dont need the actual elements_\\n\\n---\\n\\n## Solution :\\n\\n```python\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def isans(key) -> bool:\\n            return int(key // a + key // b + key // c       # A + B + C\\n                       - key // math.lcm(a, b)              # (A U B)\\n                       - key // math.lcm(b, c)              # (B U C)\\n                       - key // math.lcm(a, c)              # (A U C)\\n                       + key // (math.lcm(a, b, c))) >= n   # (A U B U C)\\n\\n        l, r = 1, 10 ** 10  # r is specified in the leetcode constraints\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if isans(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l  # = the least index which satisifies isans()\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def isans(key) -> bool:\\n            return int(key // a + key // b + key // c       # A + B + C\\n                       - key // math.lcm(a, b)              # (A U B)\\n                       - key // math.lcm(b, c)              # (B U C)\\n                       - key // math.lcm(a, c)              # (A U C)\\n                       + key // (math.lcm(a, b, c))) >= n   # (A U B U C)\\n\\n        l, r = 1, 10 ** 10  # r is specified in the leetcode constraints\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if isans(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l  # = the least index which satisifies isans()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586169,
                "title": "java-100-0ms-binary-search-with-lcm-explained",
                "content": "The approach I used is called [Inclusion-Exclusion Principle](https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle) . I explain the idea behind this principle below;\\n\\nLet a, b, and c be three numbers, also, let A, B, C respectively be the set of numbers that a, b, c can divide between 1 and M (M integer greater or equal to 1).\\nNotice that there is possibility of A, B, C containing same elements. In such case,  what do you think would be the cardinality of (i.e. number of elements in ) the union of A, B, C? \\n\\nWith [Inclusion-Exclusion Principle](https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle), you can calculate the cardinality of the union of A, B, and C, while avoiding double counting elements that appear in more that one set. Thus\\n\\n![image](https://assets.leetcode.com/users/images/abb8b579-bdc1-4332-a7df-c089d9e1ad30_1640536477.23598.png)\\n\\nThen  how can we get the following sets A, B, C, A\\u2229B, B\\u2229C, A\\u2229C, A\\u2229B\\u2229C?\\nLet us consider an example;\\n\\nLet a = 6, b = 3, c = 4,  M = 30\\nThen between 1 and 30;\\n\\nNumbers divisible by a = 6, i.e. A = {6, 12, 18, 24, 30},   |A| = 5\\n\\nNumbers divisible by b = 3, i.e. B = {3, 6, 9, 12, 15, 18, 21, 24, 27, 30}, |B| = 10\\n\\nNumbers divisible by c = 4, i.e. C = {4, 8, 12, 16, 20, 24, 28}, |C| = 7\\n\\nNotice the followings about the sets A,B, and C;\\n|A| = 5 corresponds to 30/6\\n|B| = 10 corresponds to 30/3\\n|C| = 7 corresponds to 30/4 (integer division)\\n\\nNotice also that \\n|A\\u2229B| = |{6,12,18,24,30}| = 5  corresponds to 30/lcm(6,3) = 30/6 = 5\\n\\n|A\\u2229C| = |{12,24}| = 2 corresponds to 30/lcm(6,4) = 30/12 = 2 (integer division)\\n\\n|B\\u2229C| = |{12,24}| = 2 corresponds to 30/lcm(3,4) = 30/12 = 2 (integer division)\\n\\n|A\\u2229B\\u2229C| = |{12,24}| = 2 corresponds to 30/lcm(6,3,4} = 30/12 = 2 (integer division)\\n\\nNB: the question is simply asking for the number of elements in the union of A,B, and C\\ni.e. |A\\u222AB\\u222AC| = |{3,4,6,8,9,12,15,16,18,20,21,24,27,28,30}| = 15.\\nNotice that it is wrong to simply add the cardinality of A, B, and C (i.e. |A| + |B| + |C| = 22) since there are duplicates between sets. This is why the inclusion-exclusion principle is used. Thus, putting everything together, we have\\n\\n|A\\u222AB\\u222AC| = 5 + 10 + 7 - 5 - 2 - 2 + 2 = 15\\n\\nThe best way to understand the problem is to take time and consider some examples. It\\'ll definitely sink in.\\n```\\n/*\\nSo, given a,b,c. Let M be a positive integer, the number of positive integers between 1 and M (inclusive) that a, b, or c divides can be calculated as follows\\n\\nM/a + M/b + M/c - M/lcm(a,b) - M/lcm(a,c) - M/lcm(b,c) + M/lcm(a,b,c)\\n\\nSince we can easily calculate the number of ulgly numbers between 1 and any positive integer M, then we can perform a binary search until we found M such that ulgly numbers is equal to n.\\nWhat would be the upper bound of the binary search?\\nFor me, I believe the nth ulgly number cannot exceed  min(a,b,c)*n. You probably know lower upper bound.\\n\\nThus, we can perform a binary search over the range  [1,  min(a,b,c)*n] to find nth ulgly number \\n*/\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n       \\n        long aa = Math.min(a,Math.min(b,c));\\n        long cc = Math.max(a,Math.max(b,c));\\n        long bb = a + b + c - aa - cc;\\n        long LCMabc = lcm( lcm(a,b), c);\\n        long LCMab = lcm(a,b);\\n        long LCMac = lcm(a,c);\\n        long LCMbc = lcm(b,c);\\n        \\n        long left = 1, right = n * aa;\\n        while(left < right){\\n            long mid = left + (right - left)/2;\\n            long count = mid/a + mid/b + mid/c - mid/LCMab - mid/LCMbc - mid/LCMac + mid/LCMabc;\\n    \\n            if(n > count)\\n                left = mid+1;\\n            else\\n                right = mid;\\n        }\\n        return Long.valueOf(left).intValue();\\n    }\\n    private long lcm(long a, long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    private long gcd(long a, long b){\\n        if(b == 0)return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nSo, given a,b,c. Let M be a positive integer, the number of positive integers between 1 and M (inclusive) that a, b, or c divides can be calculated as follows\\n\\nM/a + M/b + M/c - M/lcm(a,b) - M/lcm(a,c) - M/lcm(b,c) + M/lcm(a,b,c)\\n\\nSince we can easily calculate the number of ulgly numbers between 1 and any positive integer M, then we can perform a binary search until we found M such that ulgly numbers is equal to n.\\nWhat would be the upper bound of the binary search?\\nFor me, I believe the nth ulgly number cannot exceed  min(a,b,c)*n. You probably know lower upper bound.\\n\\nThus, we can perform a binary search over the range  [1,  min(a,b,c)*n] to find nth ulgly number \\n*/\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n       \\n        long aa = Math.min(a,Math.min(b,c));\\n        long cc = Math.max(a,Math.max(b,c));\\n        long bb = a + b + c - aa - cc;\\n        long LCMabc = lcm( lcm(a,b), c);\\n        long LCMab = lcm(a,b);\\n        long LCMac = lcm(a,c);\\n        long LCMbc = lcm(b,c);\\n        \\n        long left = 1, right = n * aa;\\n        while(left < right){\\n            long mid = left + (right - left)/2;\\n            long count = mid/a + mid/b + mid/c - mid/LCMab - mid/LCMbc - mid/LCMac + mid/LCMabc;\\n    \\n            if(n > count)\\n                left = mid+1;\\n            else\\n                right = mid;\\n        }\\n        return Long.valueOf(left).intValue();\\n    }\\n    private long lcm(long a, long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    private long gcd(long a, long b){\\n        if(b == 0)return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554087,
                "title": "binary-search-python-solution-with-explanation",
                "content": "```\\nimport math\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        # define boolean function to do binary search\\n        # fulfill(num) check if there at least n ugly numbers that are <= num\\n        def fulfill(num) -> bool:\\n            total = num//a + num//b + num//c - num//ab - num//ac - num//bc + num//abc\\n            return total >= n\\n        \\n        # define variables that are to be consumed by fulfill function\\n        # ab, ac, bc are the Least Common Multiple (\\u6700\\u5C0F\\u516C\\u500D\\u6570:LCM) of (a, b), (a, c), (b, c) \\n        # respectively, similarly abc is the LCM of a, b, c.\\n        ab = a * b // math.gcd(a, b)\\n        ac = a * c // math.gcd(a, c)\\n        bc = b * c // math.gcd(b, c)\\n        abc = a * bc // math.gcd(a, bc)\\n        \\n        # find min x s.t. fulfill(x) is True\\n        # the x is what we want\\n        left, right = 1, 2 * 10 ** 9 + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if fulfill(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        # define boolean function to do binary search\\n        # fulfill(num) check if there at least n ugly numbers that are <= num\\n        def fulfill(num) -> bool:\\n            total = num//a + num//b + num//c - num//ab - num//ac - num//bc + num//abc\\n            return total >= n\\n        \\n        # define variables that are to be consumed by fulfill function\\n        # ab, ac, bc are the Least Common Multiple (\\u6700\\u5C0F\\u516C\\u500D\\u6570:LCM) of (a, b), (a, c), (b, c) \\n        # respectively, similarly abc is the LCM of a, b, c.\\n        ab = a * b // math.gcd(a, b)\\n        ac = a * c // math.gcd(a, c)\\n        bc = b * c // math.gcd(b, c)\\n        abc = a * bc // math.gcd(a, bc)\\n        \\n        # find min x s.t. fulfill(x) is True\\n        # the x is what we want\\n        left, right = 1, 2 * 10 ** 9 + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if fulfill(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396645,
                "title": "binary-search-c-with-approach-faster-than-100",
                "content": "The idea behind this solution is that, for some number **num** we are finding number of ugly numbers that are less than or equal to **num**.\\n\\tThis can be done using the formula: **num / a + num / b + num / c - num / lcm(a, b) - num / lcm(b, c) - num / lcm(a, c) + num / lcm(a, b, c)**\\n\\tHere num / a gives number of integers that are <= num and multiples of a\\n\\tnum / b gives number of integers that are <= num and multiples of b\\n\\tnum / c gives number of integers that are <= num and multiples of c\\n\\tbut directly adding these will not give us the answer as some numbers have been counted multiple times\\n\\tWe need to check for double counting:\\n\\ttake 2, 3 and 6 for example \\n\\t6 will be added for 2 and 3 both, similarly 12, 18, 24 ....\\n\\tso we need to subtract these numbers once\\n\\tnow for the last term in formula take a = 2, b = 3, c = 5 \\n\\twe will check how many times 30 will be counted\\n\\tfor 2, 30 will be counted once similarly for 3 and 5\\n\\tit will be subtracted for lcm(a, b), lcm(a, c) and lcm(b, c) \\n\\tSo total count becomes 0, hence we will need to add numbers that are multiples of lcm(a, b, c) once.\\n\\t\\n```\\ntypedef long long ull;\\nclass Solution {\\npublic:\\n\\t//function to find gcd [lcm(a, b) = (a * b)/gcd(a, b))\\n    ull gcd(ull a, ull b){\\n        if(a % b == 0) return b;\\n        return gcd(b, a % b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ull high = 1e18;\\n        ull low = 1;\\n        int answer = 0;\\n\\t\\t//lcm of a, b\\n        ull a_b = (ull(a) * b) / gcd(a, b);\\n\\t\\t//lcm of b, c\\n        ull b_c = (ull(b) * c) / gcd(b, c);\\n\\t\\t//lcm of a, c\\n        ull a_c = (ull(a) * c) / gcd(a, c);\\n\\t\\t//lcm of a, b, c\\n        ull a_b_c = (a_b * c) /gcd(a_b, c);\\n        while(low <= high){\\n            ull mid = (low + high) / 2;\\n            ull temp = mid / a + mid / b + mid / c - mid / a_b - mid / a_c - mid / b_c + mid / a_b_c;\\n            if(temp >= n){\\n                answer = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\t//function to find gcd [lcm(a, b) = (a * b)/gcd(a, b))\\n    ull gcd(ull a, ull b){\\n        if(a % b == 0) return b;\\n        return gcd(b, a % b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 905775,
                "title": "100-faster-100-memory-efficient-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long int  left = min(min(a,b),c), right = 1e18;\\n        cout<<left <<\"\\\\n\";\\n        while(left < right ){\\n            long long int mid = left + (right - left )/2;\\n            if(condition(mid,n,a,b,c)){\\n                right = mid;\\n            }\\n            else left = mid+1;\\n        }\\n        return left;\\n    }\\n    bool condition(long long int num,int n,int a,int b,int c){\\n    \\n        long long int ab = (a)/__gcd(a,b),bc  = (c)/__gcd(c,b),ca = (a)/__gcd(a,c);\\n        ab *=b;\\n        ca *=c;\\n        bc *=b;\\n        \\n        long long int abc = (ab)/(__gcd(ab,bc));\\n        abc *= bc;\\n        long long int count = 0;\\n       \\n        count = num/a + num/b + num/c - num/ab - num/bc - num/ca +num/abc;\\n\\n        if(count >=n ) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long int  left = min(min(a,b),c), right = 1e18;\\n        cout<<left <<\"\\\\n\";\\n        while(left < right ){\\n            long long int mid = left + (right - left )/2;\\n            if(condition(mid,n,a,b,c)){\\n                right = mid;\\n            }\\n            else left = mid+1;\\n        }\\n        return left;\\n    }\\n    bool condition(long long int num,int n,int a,int b,int c){\\n    \\n        long long int ab = (a)/__gcd(a,b),bc  = (c)/__gcd(c,b),ca = (a)/__gcd(a,c);\\n        ab *=b;\\n        ca *=c;\\n        bc *=b;\\n        \\n        long long int abc = (ab)/(__gcd(ab,bc));\\n        abc *= bc;\\n        long long int count = 0;\\n       \\n        count = num/a + num/b + num/c - num/ab - num/bc - num/ca +num/abc;\\n\\n        if(count >=n ) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 553029,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int A, int B, int C) {\\n        if(A==1||B==1||C==1)return n;\\n        long res=0;\\n        long a=A;\\n        long b=B;\\n        long c=C;\\n        long ab=a*b/gcd(a,b);\\n        long ac=a*c/gcd(a,c);\\n        long bc=b*c/gcd(b,c);\\n        long abc=a*bc/gcd(a,bc);\\n        long left=0;long right=2000000000;\\n        while(left<=right){\\n            long mid=left+(right-left)/2;\\n            long cnt=mid/a+mid/b+mid/c-mid/ab-mid/ac-mid/bc+mid/abc;\\n            if(cnt==n){\\n                res=mid;\\n                right=mid-1;\\n            }\\n            else if(cnt>n){\\n                right=mid-1;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        return (int)res;\\n    }\\n    \\n    public long gcd( long a, long b) {\\n        if( a < b) return gcd(b,a);\\n        if( b == 0 ) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int A, int B, int C) {\\n        if(A==1||B==1||C==1)return n;\\n        long res=0;\\n        long a=A;\\n        long b=B;\\n        long c=C;\\n        long ab=a*b/gcd(a,b);\\n        long ac=a*c/gcd(a,c);\\n        long bc=b*c/gcd(b,c);\\n        long abc=a*bc/gcd(a,bc);\\n        long left=0;long right=2000000000;\\n        while(left<=right){\\n            long mid=left+(right-left)/2;\\n            long cnt=mid/a+mid/b+mid/c-mid/ab-mid/ac-mid/bc+mid/abc;\\n            if(cnt==n){\\n                res=mid;\\n                right=mid-1;\\n            }\\n            else if(cnt>n){\\n                right=mid-1;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        return (int)res;\\n    }\\n    \\n    public long gcd( long a, long b) {\\n        if( a < b) return gcd(b,a);\\n        if( b == 0 ) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542464,
                "title": "c-solution-100-in-time-and-space-with-explanation",
                "content": "The idea is to keep tracking the multiples of a, b and c. We can use integer p, q and r for that, each time when we caculate the next ugly number, we get the minimum from `p*a`, `q*b` and `r*c`, and increment p, q or r accordingly. So the first version looks like this:\\n```cpp\\n     int nthUglyNumber(int n, int a, int b, int c) {\\n        int p = 1, q = 1, r = 1, last;\\n        for (int i=0; i<n; i++) {\\n            last = min(min(a*p, b*q), c*r);\\n            if (last == a*p) p++;\\n            if (last == b*q) q++;\\n            if (last == c*r) r++;\\n        }\\n        return last;\\n    }\\n```\\nUnfortunately, this will fail for some case due to timeout, such as\\n```\\n1000000000\\n2\\n217983653\\n336916467\\n```\\n\\nSo, the following code is to optimise for this kind of scenario, we try to increment the multiple` p` for `a` in bulk, it works very well.\\n```cpp\\n    using INT=int64_t;\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        INT p = 1, q = 1, r = 1, last, step, middle, s;\\n        for (int i=0; i<n;) {\\n            s = a*p + b*q + c*r; \\n            last = min(c * r, min(a * p, b * q));\\n            middle = s - last - max(c * r, max(a * p, b * q));\\n            step = 1;\\n            if (last == c*r) { r++;}\\n            if (last == b*q) { q++;}\\n            if (last == a*p) {\\n                INT k = (middle - last)/a - 1;\\n                if (k > 0 && k + i >= n) {\\n                    k = n - i - 2;\\n                }\\n                step = max(step, k);\\n                p += step; \\n            }\\n            i += step;\\n        }\\n        return last;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n     int nthUglyNumber(int n, int a, int b, int c) {\\n        int p = 1, q = 1, r = 1, last;\\n        for (int i=0; i<n; i++) {\\n            last = min(min(a*p, b*q), c*r);\\n            if (last == a*p) p++;\\n            if (last == b*q) q++;\\n            if (last == c*r) r++;\\n        }\\n        return last;\\n    }\\n```\n```\\n1000000000\\n2\\n217983653\\n336916467\\n```\n```cpp\\n    using INT=int64_t;\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        INT p = 1, q = 1, r = 1, last, step, middle, s;\\n        for (int i=0; i<n;) {\\n            s = a*p + b*q + c*r; \\n            last = min(c * r, min(a * p, b * q));\\n            middle = s - last - max(c * r, max(a * p, b * q));\\n            step = 1;\\n            if (last == c*r) { r++;}\\n            if (last == b*q) { q++;}\\n            if (last == a*p) {\\n                INT k = (middle - last)/a - 1;\\n                if (k > 0 && k + i >= n) {\\n                    k = n - i - 2;\\n                }\\n                step = max(step, k);\\n                p += step; \\n            }\\n            i += step;\\n        }\\n        return last;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 440495,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int NthUglyNumber(int n, int a, int b, int c) \\n    {\\n        int start = 0, end = int.MaxValue;\\n        long ab = LCM(a, b), bc = LCM(b, c), ca = LCM(c, a), abc = LCM(a, bc);\\n        while(start < end)\\n        {\\n            int mid = start + (end - start) / 2;\\n            int count = (int) (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc);\\n            if(count < n)\\n                start = mid + 1;\\n            else\\n                end = mid;\\n        }\\n        \\n        return start;\\n    }\\n    \\n    private long GCD(long x, long y)\\n    {\\n        return y == 0 ? x : GCD(y, x % y);\\n    }\\n    \\n    private long LCM(long x, long y)\\n    {\\n        return (x * y) / GCD(x, y);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int NthUglyNumber(int n, int a, int b, int c) \\n    {\\n        int start = 0, end = int.MaxValue;\\n        long ab = LCM(a, b), bc = LCM(b, c), ca = LCM(c, a), abc = LCM(a, bc);\\n        while(start < end)\\n        {\\n            int mid = start + (end - start) / 2;\\n            int count = (int) (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc);\\n            if(count < n)\\n                start = mid + 1;\\n            else\\n                end = mid;\\n        }\\n        \\n        return start;\\n    }\\n    \\n    private long GCD(long x, long y)\\n    {\\n        return y == 0 ? x : GCD(y, x % y);\\n    }\\n    \\n    private long LCM(long x, long y)\\n    {\\n        return (x * y) / GCD(x, y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838180,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mab,mbc,mac,mabc;\\n    long long  gcd(long long  a, long long  b)\\n    {\\n        if(b==0) \\n        return a;\\n        if(a<b) \\n        return gcd(b,a);\\n        return gcd(b,a%b);\\n    }\\n    long long  lcm(long long  a, long long  b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n    long long  before(long long  x, long long  a, long long  b, long long  c)\\n    {\\n        return (x/a)+(x/b)+(x/c)-(x/mab)-(x/mbc)-(x/mac)+(x/mabc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        mab=lcm(a,b);\\n        mbc=lcm(b,c);\\n        mac=lcm(a,c);\\n        mabc=lcm(mab,c);\\n        long long  lo=1;\\n        long long  hi=2e9;\\n        while(lo<hi){\\n            long long  x=lo+(hi-lo)/2;\\n            if(before(x,a,b,c)>=n) hi=x;\\n            else lo=x+1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mab,mbc,mac,mabc;\\n    long long  gcd(long long  a, long long  b)\\n    {\\n        if(b==0) \\n        return a;\\n        if(a<b) \\n        return gcd(b,a);\\n        return gcd(b,a%b);\\n    }\\n    long long  lcm(long long  a, long long  b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n    long long  before(long long  x, long long  a, long long  b, long long  c)\\n    {\\n        return (x/a)+(x/b)+(x/c)-(x/mab)-(x/mbc)-(x/mac)+(x/mabc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        mab=lcm(a,b);\\n        mbc=lcm(b,c);\\n        mac=lcm(a,c);\\n        mabc=lcm(mab,c);\\n        long long  lo=1;\\n        long long  hi=2e9;\\n        while(lo<hi){\\n            long long  x=lo+(hi-lo)/2;\\n            if(before(x,a,b,c)>=n) hi=x;\\n            else lo=x+1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456765,
                "title": "simple-solution-using-binary-search-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long GCD(long long x, long long y){\\n        if(y==0){\\n            return x;\\n        }\\n        return GCD(y, x%y);\\n    }\\n    long long bin(long long st, long long end, int& target, long long& a, long long& b, long long&d){\\n        if(st<=end){\\n            long long mid=(st+end)/2;\\n            long long val=(mid/a) + (mid/b) - (mid/(a*b/d));\\n            if(val==target){\\n                if(mid%a==0 or mid%b==0){\\n                    return mid;\\n                }\\n                else{\\n                    return bin(st,mid-1,target,a,b,d);\\n                }\\n            }\\n            else if(val<target){\\n                return bin(mid+1,end,target,a,b,d);\\n            }\\n            else{\\n                return bin(st,mid-1,target,a,b,d);\\n            }\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    long long binary(long long st, long long end, int& target,long long& a, long long& b, long long& c, long long& d, long long& e, long long& f, long long& g){\\n        if(st<=end){\\n            long long mid=(st+end)/2;\\n            long long ans=(mid/a)+(mid/b)+(mid/c)-(mid/(a*b/d))-(mid/(b*c/e))-(mid/(a*c/f))+(mid/(g));\\n            if(ans==target){\\n                if(mid%a==0 or mid%b==0 or mid%c==0){\\n                    return mid;\\n                }\\n                else{\\n                    return binary(st,mid-1,target,a,b,c,d,e,f,g);\\n                }\\n            }\\n            else if(ans<target){\\n                return binary(mid+1,end,target,a,b,c,d,e,f,g);\\n            }\\n            else{\\n                return binary(st,mid-1,target,a,b,c,d,e,f,g);\\n            }\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(a==b and b==c){\\n            return a*n;\\n        }\\n        else if(a==b or b==c or a==c){\\n            a=min(a,min(b,c));\\n            b=max(a,max(b,c));\\n            long long a1=a;\\n            long long b1=b;\\n            long long d=GCD(a1,b1);\\n            long long end=2000000000;\\n            long long val=bin(1,end,n,a1,b1,d);\\n            return val;\\n        }\\n        else{\\n            long long end=2000000000;\\n            long long a1=a;\\n            long long b1=b;\\n            long long c1=c;\\n            long long d=GCD(a1,b1);\\n            long long e=GCD(b1,c1);\\n            long long f=GCD(a1,c1);\\n            long long g=(a1*b1/d)*c1/GCD(a1*b1/d,c1);\\n            long long val=binary(1,end,n,a1,b1,c1,d,e,f,g);\\n            return val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long GCD(long long x, long long y){\\n        if(y==0){\\n            return x;\\n        }\\n        return GCD(y, x%y);\\n    }\\n    long long bin(long long st, long long end, int& target, long long& a, long long& b, long long&d){\\n        if(st<=end){\\n            long long mid=(st+end)/2;\\n            long long val=(mid/a) + (mid/b) - (mid/(a*b/d));\\n            if(val==target){\\n                if(mid%a==0 or mid%b==0){\\n                    return mid;\\n                }\\n                else{\\n                    return bin(st,mid-1,target,a,b,d);\\n                }\\n            }\\n            else if(val<target){\\n                return bin(mid+1,end,target,a,b,d);\\n            }\\n            else{\\n                return bin(st,mid-1,target,a,b,d);\\n            }\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    long long binary(long long st, long long end, int& target,long long& a, long long& b, long long& c, long long& d, long long& e, long long& f, long long& g){\\n        if(st<=end){\\n            long long mid=(st+end)/2;\\n            long long ans=(mid/a)+(mid/b)+(mid/c)-(mid/(a*b/d))-(mid/(b*c/e))-(mid/(a*c/f))+(mid/(g));\\n            if(ans==target){\\n                if(mid%a==0 or mid%b==0 or mid%c==0){\\n                    return mid;\\n                }\\n                else{\\n                    return binary(st,mid-1,target,a,b,c,d,e,f,g);\\n                }\\n            }\\n            else if(ans<target){\\n                return binary(mid+1,end,target,a,b,c,d,e,f,g);\\n            }\\n            else{\\n                return binary(st,mid-1,target,a,b,c,d,e,f,g);\\n            }\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(a==b and b==c){\\n            return a*n;\\n        }\\n        else if(a==b or b==c or a==c){\\n            a=min(a,min(b,c));\\n            b=max(a,max(b,c));\\n            long long a1=a;\\n            long long b1=b;\\n            long long d=GCD(a1,b1);\\n            long long end=2000000000;\\n            long long val=bin(1,end,n,a1,b1,d);\\n            return val;\\n        }\\n        else{\\n            long long end=2000000000;\\n            long long a1=a;\\n            long long b1=b;\\n            long long c1=c;\\n            long long d=GCD(a1,b1);\\n            long long e=GCD(b1,c1);\\n            long long f=GCD(a1,c1);\\n            long long g=(a1*b1/d)*c1/GCD(a1*b1/d,c1);\\n            long long val=binary(1,end,n,a1,b1,c1,d,e,f,g);\\n            return val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179363,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\nclass Solution {\\n    long a, b, c, ab, bc, ac, abc;\\n\\n    public long countMultiples(long mid) {\\n        return (mid / a) + (mid / b) + (mid / c) - (mid / ab) - (mid / bc) - (mid / ac) + (mid / abc);\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return (b == 0) ? a : gcd(b, a % b);\\n    }\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        this.a = a;\\n        this.b = b;\\n        this.c = c;\\n\\n        ab = ((long) a * b) / gcd(a, b);\\n        bc = ((long) b * c) / gcd(b, c);\\n        ac = ((long) a * c) / gcd(a, c);\\n        abc = ((long) a * bc) / gcd(a, (int) bc);\\n\\n        long left = 0, right = Long.MAX_VALUE;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            if (countMultiples(mid) < n) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n\\n        return (int) left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    long a, b, c, ab, bc, ac, abc;\\n\\n    public long countMultiples(long mid) {\\n        return (mid / a) + (mid / b) + (mid / c) - (mid / ab) - (mid / bc) - (mid / ac) + (mid / abc);\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return (b == 0) ? a : gcd(b, a % b);\\n    }\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        this.a = a;\\n        this.b = b;\\n        this.c = c;\\n\\n        ab = ((long) a * b) / gcd(a, b);\\n        bc = ((long) b * c) / gcd(b, c);\\n        ac = ((long) a * c) / gcd(a, c);\\n        abc = ((long) a * bc) / gcd(a, (int) bc);\\n\\n        long left = 0, right = Long.MAX_VALUE;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            if (countMultiples(mid) < n) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n\\n        return (int) left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989598,
                "title": "easy-binary-searching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\n#define MAX_ANS 2e9 \\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { \\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\n#define MAX_ANS 2e9 \\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { \\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568523,
                "title": "python-binary-search-solution-do-878-first",
                "content": "[878. Nth Magical Number](https://leetcode.com/problems/nth-magical-number/)\\n```\\nclass Solution:\\n    # an extended problem as Leetcode 878. Nth Magical Number\\n    # n could be as large as 10^9, so we cannot use a heap as in Ugly Number II\\n    # Because we do not need to know every ugly number up to n, instead we could use binary search to find the answer\\n    # The lower limit is 1, the upper limit is 2*10^9\\n    # if any of a or b or c equals 1, just return n\\n    # We use a function ugly to return number of ugly numbers smaller than the certain number x\\n    # It is given by (x // a) + (x // b) + (x // c) - (x // lcm(a,b)) - x // lcm(b,c) - x // lcm(a,c) + x // lcm(a, lcm(b,c))\\n    \\n    def gcd(self, a, b):\\n        if a < b:\\n            a,b = b,a\\n        if b == 0:\\n            return a\\n        else:\\n            return self.gcd(b, a%b)\\n    \\n    def lcm(self, a, b):\\n        return a*b // self.gcd(a,b)\\n    \\n    def ugly(self, x, a, b, c):\\n        return (x // a) + (x // b) + (x // c) - (x // self.lcm(a,b)) - (x // self.lcm(b,c)) - (x // self.lcm(a,c)) + (x // self.lcm(a, self.lcm(b,c)))\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        left, right = 1, 2*pow(10,9)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if self.ugly(mid, a, b, c) >= n:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # an extended problem as Leetcode 878. Nth Magical Number\\n    # n could be as large as 10^9, so we cannot use a heap as in Ugly Number II\\n    # Because we do not need to know every ugly number up to n, instead we could use binary search to find the answer\\n    # The lower limit is 1, the upper limit is 2*10^9\\n    # if any of a or b or c equals 1, just return n\\n    # We use a function ugly to return number of ugly numbers smaller than the certain number x\\n    # It is given by (x // a) + (x // b) + (x // c) - (x // lcm(a,b)) - x // lcm(b,c) - x // lcm(a,c) + x // lcm(a, lcm(b,c))\\n    \\n    def gcd(self, a, b):\\n        if a < b:\\n            a,b = b,a\\n        if b == 0:\\n            return a\\n        else:\\n            return self.gcd(b, a%b)\\n    \\n    def lcm(self, a, b):\\n        return a*b // self.gcd(a,b)\\n    \\n    def ugly(self, x, a, b, c):\\n        return (x // a) + (x // b) + (x // c) - (x // self.lcm(a,b)) - (x // self.lcm(b,c)) - (x // self.lcm(a,c)) + (x // self.lcm(a, self.lcm(b,c)))\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        left, right = 1, 2*pow(10,9)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if self.ugly(mid, a, b, c) >= n:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370905,
                "title": "binary-search-solution-with-overflow-handled-without-long",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high =2*(int)1e9;\\n        \\n        int ab = lcm(a,b), bc = lcm(b,c), ca = lcm(c,a), abc = lcm(a,bc);\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            int count = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc;\\n            if(count>=n){\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n    private int lcm(int x,int y){\\n        int a = x, b = y; \\n        while(a!=0){\\n            int t = a;\\n            a = b%a;\\n            b = t;\\n        }\\n        int ans = 0;\\n        try{\\n            ans = (x>y) ? Math.multiplyExact(y,(x/b)) : Math.multiplyExact(x,(y/b));  // x*y/gcd(x,y)\\n        }catch(Exception e){\\n            ans = Integer.MAX_VALUE;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high =2*(int)1e9;\\n        \\n        int ab = lcm(a,b), bc = lcm(b,c), ca = lcm(c,a), abc = lcm(a,bc);\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            int count = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc;\\n            if(count>=n){\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n    private int lcm(int x,int y){\\n        int a = x, b = y; \\n        while(a!=0){\\n            int t = a;\\n            a = b%a;\\n            b = t;\\n        }\\n        int ans = 0;\\n        try{\\n            ans = (x>y) ? Math.multiplyExact(y,(x/b)) : Math.multiplyExact(x,(y/b));  // x*y/gcd(x,y)\\n        }catch(Exception e){\\n            ans = Integer.MAX_VALUE;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217473,
                "title": "c-clear-explanation-you-will-get-it-binary-search",
                "content": "```\\n// This is a typical Binary Search Problem Here I did Binary Search and Optimized my lcm function a lot.\\n// Here Number of Ugly numbers for any number is \\n// that number/a + that number/b + that number/c + that number/lcm(a,b,c) - that number/lcm(a,b) - that number/lcm(b,c) - that number/(a,c) and howzz that??\\n//     See Lets suppose that number is 17 for which you are checking values and a = 2 , b=3 and c= 4 now figure out \\n//     all the possible values for a = 2,4,6,8,10,12,14,16\\n//         b = 3,6,9,12,15\\n//         c = 4,8,12,16\\n//         Now if we add them all we can see 4,6,8,16 are coming twice and 12 is coming thrice so we do lcm(2,3) = 6\\n//             then we are basically multiple occurance of numbers divisible by 6 simlarly for lcm(2,4) & lcm(3,4)\\n//                 but any number which is divisble by all three of them we have deleted it 3 times we  need at least so we are adding numbers which are divisble by lcm(2,3,4) which is 12 here So if suppose we are countering more numbers than n then h = mid-1 we need to move backward else we need to forward.\\nclass Solution {\\npublic:\\n    #define ll long long\\n     ll gcd(ll a, ll b)\\n     {\\n       if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n      }\\n      ll lcm(ll a, ll b)\\n     {\\n         return (a / gcd(a, b)) * b;\\n     }\\n    bool check(ll mid , int a , int b , int c, int n)\\n    {\\n        ll j1 = lcm(a,b);\\n        ll j2 = lcm(a,c);\\n        ll j3 = lcm(b,c);\\n        ll j4 = lcm(j1,c);\\n        ll k = mid/a + mid/b + mid/c + mid/j4 - (mid/j1 + mid/j2 + mid/j3);\\n        return k==n;\\n    }\\n    bool check1(ll mid , int a , int b , int c, int n)\\n    {\\n        ll j1 = lcm(a,b);\\n        ll j2 = lcm(a,c);\\n        ll j3 = lcm(b,c);\\n        ll j4 = lcm(j1,c);\\n        ll k = mid/a + mid/b + mid/c + mid/j4 - (mid/j1 + mid/j2 + mid/j3);\\n        return k>=n;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll l = min(a,min(b,c));\\n        ll h = INT_MAX;\\n        while(l<=h)\\n        {\\n             ll  mid = l + (h-l)/2;\\n             if(check(mid,a,b,c,n) && (mid%a==0 || mid%b==0 || mid%c==0))\\n             {\\n                 return mid;\\n             }\\n             else\\n             {\\n                 if(check1(mid,a,b,c,n))\\n                 {\\n                     h = mid-1;\\n                 }\\n                 else\\n                 {\\n                     l = mid+1;\\n                 }\\n             }\\n        }\\n        return 1;\\n    }\\n};\\n```\\n**Please Upvote it...**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n// This is a typical Binary Search Problem Here I did Binary Search and Optimized my lcm function a lot.\\n// Here Number of Ugly numbers for any number is \\n// that number/a + that number/b + that number/c + that number/lcm(a,b,c) - that number/lcm(a,b) - that number/lcm(b,c) - that number/(a,c) and howzz that??\\n//     See Lets suppose that number is 17 for which you are checking values and a = 2 , b=3 and c= 4 now figure out \\n//     all the possible values for a = 2,4,6,8,10,12,14,16\\n//         b = 3,6,9,12,15\\n//         c = 4,8,12,16\\n//         Now if we add them all we can see 4,6,8,16 are coming twice and 12 is coming thrice so we do lcm(2,3) = 6\\n//             then we are basically multiple occurance of numbers divisible by 6 simlarly for lcm(2,4) & lcm(3,4)\\n//                 but any number which is divisble by all three of them we have deleted it 3 times we  need at least so we are adding numbers which are divisble by lcm(2,3,4) which is 12 here So if suppose we are countering more numbers than n then h = mid-1 we need to move backward else we need to forward.\\nclass Solution {\\npublic:\\n    #define ll long long\\n     ll gcd(ll a, ll b)\\n     {\\n       if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n      }\\n      ll lcm(ll a, ll b)\\n     {\\n         return (a / gcd(a, b)) * b;\\n     }\\n    bool check(ll mid , int a , int b , int c, int n)\\n    {\\n        ll j1 = lcm(a,b);\\n        ll j2 = lcm(a,c);\\n        ll j3 = lcm(b,c);\\n        ll j4 = lcm(j1,c);\\n        ll k = mid/a + mid/b + mid/c + mid/j4 - (mid/j1 + mid/j2 + mid/j3);\\n        return k==n;\\n    }\\n    bool check1(ll mid , int a , int b , int c, int n)\\n    {\\n        ll j1 = lcm(a,b);\\n        ll j2 = lcm(a,c);\\n        ll j3 = lcm(b,c);\\n        ll j4 = lcm(j1,c);\\n        ll k = mid/a + mid/b + mid/c + mid/j4 - (mid/j1 + mid/j2 + mid/j3);\\n        return k>=n;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll l = min(a,min(b,c));\\n        ll h = INT_MAX;\\n        while(l<=h)\\n        {\\n             ll  mid = l + (h-l)/2;\\n             if(check(mid,a,b,c,n) && (mid%a==0 || mid%b==0 || mid%c==0))\\n             {\\n                 return mid;\\n             }\\n             else\\n             {\\n                 if(check1(mid,a,b,c,n))\\n                 {\\n                     h = mid-1;\\n                 }\\n                 else\\n                 {\\n                     l = mid+1;\\n                 }\\n             }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096817,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) \\n    {\\n        int low=1,high=2*int(1e9);\\n        long a=long(A), b=long(B), c=long(C);\\n        long ab=a*b/__gcd(a,b);\\n        long bc=b*c/__gcd(b,c);\\n        long ac=a*c/__gcd(a,c);\\n        long abc=a*bc/__gcd(a,bc);\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int cnt=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(cnt<n)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid;\\n            }\\n        }\\n        return low;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) \\n    {\\n        int low=1,high=2*int(1e9);\\n        long a=long(A), b=long(B), c=long(C);\\n        long ab=a*b/__gcd(a,b);\\n        long bc=b*c/__gcd(b,c);\\n        long ac=a*c/__gcd(a,c);\\n        long abc=a*bc/__gcd(a,bc);\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int cnt=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(cnt<n)\\n            {\\n                low=mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2015286,
                "title": "c-solution-with-binary-search",
                "content": "```\\nlong gcd(long a, long b) {\\n    return a ? gcd(b % a, a) : b;\\n}\\n\\nlong lcm(long a, long b) {\\n    return a * b / gcd(a, b);\\n}\\n\\nint uglyNumbers(long m, long a, long b, long c) {\\n    long lcmab = lcm(a, b);\\n    long lcmac = lcm(a, c);\\n    long lcmbc = lcm(b, c);\\n    long lcmabc = lcm(lcmab, c);\\n    return (int)(m / a + m / b + m /c - m / lcmab - m / lcmac - m / lcmbc + m / lcmabc);\\n}\\n\\nint nthUglyNumber(int n, int a, int b, int c){\\n    int left = 1, right = 2e9;\\n    while(left < right) \\n    {\\n        int mid = left + (right - left) / 2;\\n        if (uglyNumbers(mid, a, b, c) >= n)\\n            right = mid;\\n        else\\n            left = mid + 1;\\n    }\\n    return left;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nlong gcd(long a, long b) {\\n    return a ? gcd(b % a, a) : b;\\n}\\n\\nlong lcm(long a, long b) {\\n    return a * b / gcd(a, b);\\n}\\n\\nint uglyNumbers(long m, long a, long b, long c) {\\n    long lcmab = lcm(a, b);\\n    long lcmac = lcm(a, c);\\n    long lcmbc = lcm(b, c);\\n    long lcmabc = lcm(lcmab, c);\\n    return (int)(m / a + m / b + m /c - m / lcmab - m / lcmac - m / lcmbc + m / lcmabc);\\n}\\n\\nint nthUglyNumber(int n, int a, int b, int c){\\n    int left = 1, right = 2e9;\\n    while(left < right) \\n    {\\n        int mid = left + (right - left) / 2;\\n        if (uglyNumbers(mid, a, b, c) >= n)\\n            right = mid;\\n        else\\n            left = mid + 1;\\n    }\\n    return left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997183,
                "title": "100-0ms-easy-simple-concise",
                "content": "```\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Go",
                    "PHP"
                ],
                "code": "```\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940748,
                "title": "0ms-java-simple-clear-explaination-in-code-binary-search",
                "content": "``` \\n//just tried to explain as much as I can. Upvote if it helped. thanks\\nclass Solution {\\n  \\n    long lcmOfAC;\\n    long lcmOfAB;\\n    long lcmOfBC;\\n    long lcmOfABC;\\n  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n      lcmOfAC  = lcm(a,c);\\n      lcmOfAB  = lcm(a,b);\\n      lcmOfBC  = lcm(b,c);\\n      lcmOfABC = lcm(a,lcmOfBC);\\n      \\n      int left = 1;\\n      int right = Integer.MAX_VALUE;\\n      \\n      \\n      //how BS works here: If our count of ugly numbers before the value of \\'mid\\'\\n      //is greater or equal we decrease right. \\n      //And when we have exactly \\'n-1\\' on the left side, our answer is \\'left\\', \\n      //meaning that left is the number which is at ((n-1)+1) th position.\\n      \\n      \\n      /// MOST IMPORTANT THING TO UNDERSTAND HERE IS: HOW DOES HOW MANY UGLY NUMBERS ARE THERE BEFORE \\'MID\\' GIVES THE NTH UGLY NUMBER??? WE ARE JUST COUNTING NUMBERS RIGHT?? HOW DOES IT EVEN WORK??\\n      /*\\n        LET ME EXPLAIN: FOR EXAMPLE TEST-CASE 1: \\n        \\n        N = 3, A = 2, B = 3, C = 5. CLEAR HERE.\\n        \\n        NOW TAKE A SERIES OF N NATURAL NUMBERS. LIKE:\\n        \\n        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21...\\n        \\n        NOW FOR 2 IT\\'S: 2 4 6 8 10 12 14 16...\\n                 FOR 3: 3 6 9 12 15 18\\n                 FOR 5: 5 10 15 20 25.....\\n                 \\n        //WITH THIS LINE: long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;        \\n        //WE ARE ADDING EVERY UNIQUE MULTIPLE OF ALL OF THE THREE ONLY ONE TIME.\\n        \\n        //SO OUR FINAL N-NATURAL NUMBER SERIES BECOMES:  //EVERY DUPLICATE IS REMOVED.\\n          1, 2, 3, 4, 5, 6, 8, 9, 10... (SAME AS PROVIDED IN TEST CASE) //EVERY NUMBER IS UNIQUE AND INCREASING. //ONE IS INCLUDED BECAUSE LEFT = 1.\\n          \\n        //KEEP-IN-MIND, BY COUNTING WE ARE SAYING - HOW MANY UGLY NUMBERS APPEAR BEFORE THIS \\'MID\\'\\n        // WE ARE SAYING IF THERE ARE \"n-1\" UGLY NUMBERS BEFORE THAN \"n\" IS OUR ANSWER. HERE \"LEFT\" IS THAT \"N\"\\n\\n        // SO IF OUR MID IS FINALLY AT LET SAY \\'5\\', WE DECREASE OUR RIGHT TO \\'MID\\' (RIGHT = MID),\\n        // BECAUSE TOTAL NUMBERS BEFORE 5 ARE 3 (1,2,3,4).\\n        \\n        //THIS PROCESS KEEPS GOING UNTIL MID IS AT 3, AND COUNT < N WHICH MEANS LEFT = MID+1 (3+1) = 4;\\n        \\n        //TRY TO THINK IN YOUR WAY A LITTLE MORE IF YOU STILL DON\\'T GET IT.\\n          \\n      */\\n      \\n      \\n      \\n      while(left<right){\\n        \\n        int mid = left+(right-left)/2;\\n\\n        if(count(mid, a, b, c, n)){\\n          right = mid;\\n        }\\n        \\n        else\\n          left = mid+1;        \\n      }\\n      \\n      return left;      \\n    }\\n  \\n   \\n    \\n    boolean count(long mid, long a, long b, long c, long n){\\n      \\n      \\n\\t\\t/*\\n\\t\\t*   mid/a = total number of multiples \\'a\\' till chosen \\'mid\\'. //same for \\'b\\' and \\'c\\'.\\n\\t\\t*  \\n\\t\\t*   mid/lcm(a,b) = total number of duplicate multiples that appear for series of \\'a\\' and \\'b\\'  // same for (b,c) & (c,a)      \\n\\t\\t*   \\n\\t\\t*   now because we subtract all the common mulitples  that appear for all three \\'a\\' & \\'b\\' & \\'c\\'\\n\\n\\t\\t*   we\\'ll have to again add those who appear in all three series again (check below comment)\\n\\t\\t*/      \\n\\t\\t /* example: \\n\\n\\t\\t\\t\\tfor 2:- 2 4 6 8 10 12 14\\n\\t\\t\\t\\tfor 3:- 3 9 12 15 18 21\\n\\t\\t\\t\\tfor 4:- 4 8 12\\n\\n\\t\\t\\t\\t//now notice that \\'12\\' is common in all of them, it should be counted only \\'once\\', not \\'thrice\\'.\\n\\t\\t\\t\\t// same goes for \\'4\\', it appeared 2 times, we want to count only \\'one\\' time.\\n\\n\\t\\t\\t\\t// this is why we subtracted  all common duplicates first, then lastly add the lcm(a,lcm(b,c)) //simply say -  lcm(a,b,c)\\n\\t\\t\\t\\t// we do this last \\'add\\' step because we have already subtracted all duplicates that are common.\\n\\t\\t\\t\\t// so to add those who are common in \"all three series\" (like 12 here), we do this last  \\'+ lcm(a,b,c)\\' step.\\n\\t\\t*/\\n\\t\\t\\n     \\n      long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;\\n      \\n      return total >= n;\\n      \\n    }\\n  \\n  \\n    static long gcd(long a,long b){\\n      while(b>0){\\n        a%=b;\\n        //swap\\n        long temp = a;\\n        a = b;\\n        b = temp;\\n      }\\n      return a;\\n    }\\n\\n    static long lcm(long a, long b){\\n      \\n      return a/gcd(a,b)*b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "``` \\n//just tried to explain as much as I can. Upvote if it helped. thanks\\nclass Solution {\\n  \\n    long lcmOfAC;\\n    long lcmOfAB;\\n    long lcmOfBC;\\n    long lcmOfABC;\\n  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n      lcmOfAC  = lcm(a,c);\\n      lcmOfAB  = lcm(a,b);\\n      lcmOfBC  = lcm(b,c);\\n      lcmOfABC = lcm(a,lcmOfBC);\\n      \\n      int left = 1;\\n      int right = Integer.MAX_VALUE;\\n      \\n      \\n      //how BS works here: If our count of ugly numbers before the value of \\'mid\\'\\n      //is greater or equal we decrease right. \\n      //And when we have exactly \\'n-1\\' on the left side, our answer is \\'left\\', \\n      //meaning that left is the number which is at ((n-1)+1) th position.\\n      \\n      \\n      /// MOST IMPORTANT THING TO UNDERSTAND HERE IS: HOW DOES HOW MANY UGLY NUMBERS ARE THERE BEFORE \\'MID\\' GIVES THE NTH UGLY NUMBER??? WE ARE JUST COUNTING NUMBERS RIGHT?? HOW DOES IT EVEN WORK??\\n      /*\\n        LET ME EXPLAIN: FOR EXAMPLE TEST-CASE 1: \\n        \\n        N = 3, A = 2, B = 3, C = 5. CLEAR HERE.\\n        \\n        NOW TAKE A SERIES OF N NATURAL NUMBERS. LIKE:\\n        \\n        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21...\\n        \\n        NOW FOR 2 IT\\'S: 2 4 6 8 10 12 14 16...\\n                 FOR 3: 3 6 9 12 15 18\\n                 FOR 5: 5 10 15 20 25.....\\n                 \\n        //WITH THIS LINE: long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;        \\n        //WE ARE ADDING EVERY UNIQUE MULTIPLE OF ALL OF THE THREE ONLY ONE TIME.\\n        \\n        //SO OUR FINAL N-NATURAL NUMBER SERIES BECOMES:  //EVERY DUPLICATE IS REMOVED.\\n          1, 2, 3, 4, 5, 6, 8, 9, 10... (SAME AS PROVIDED IN TEST CASE) //EVERY NUMBER IS UNIQUE AND INCREASING. //ONE IS INCLUDED BECAUSE LEFT = 1.\\n          \\n        //KEEP-IN-MIND, BY COUNTING WE ARE SAYING - HOW MANY UGLY NUMBERS APPEAR BEFORE THIS \\'MID\\'\\n        // WE ARE SAYING IF THERE ARE \"n-1\" UGLY NUMBERS BEFORE THAN \"n\" IS OUR ANSWER. HERE \"LEFT\" IS THAT \"N\"\\n\\n        // SO IF OUR MID IS FINALLY AT LET SAY \\'5\\', WE DECREASE OUR RIGHT TO \\'MID\\' (RIGHT = MID),\\n        // BECAUSE TOTAL NUMBERS BEFORE 5 ARE 3 (1,2,3,4).\\n        \\n        //THIS PROCESS KEEPS GOING UNTIL MID IS AT 3, AND COUNT < N WHICH MEANS LEFT = MID+1 (3+1) = 4;\\n        \\n        //TRY TO THINK IN YOUR WAY A LITTLE MORE IF YOU STILL DON\\'T GET IT.\\n          \\n      */\\n      \\n      \\n      \\n      while(left<right){\\n        \\n        int mid = left+(right-left)/2;\\n\\n        if(count(mid, a, b, c, n)){\\n          right = mid;\\n        }\\n        \\n        else\\n          left = mid+1;        \\n      }\\n      \\n      return left;      \\n    }\\n  \\n   \\n    \\n    boolean count(long mid, long a, long b, long c, long n){\\n      \\n      \\n\\t\\t/*\\n\\t\\t*   mid/a = total number of multiples \\'a\\' till chosen \\'mid\\'. //same for \\'b\\' and \\'c\\'.\\n\\t\\t*  \\n\\t\\t*   mid/lcm(a,b) = total number of duplicate multiples that appear for series of \\'a\\' and \\'b\\'  // same for (b,c) & (c,a)      \\n\\t\\t*   \\n\\t\\t*   now because we subtract all the common mulitples  that appear for all three \\'a\\' & \\'b\\' & \\'c\\'\\n\\n\\t\\t*   we\\'ll have to again add those who appear in all three series again (check below comment)\\n\\t\\t*/      \\n\\t\\t /* example: \\n\\n\\t\\t\\t\\tfor 2:- 2 4 6 8 10 12 14\\n\\t\\t\\t\\tfor 3:- 3 9 12 15 18 21\\n\\t\\t\\t\\tfor 4:- 4 8 12\\n\\n\\t\\t\\t\\t//now notice that \\'12\\' is common in all of them, it should be counted only \\'once\\', not \\'thrice\\'.\\n\\t\\t\\t\\t// same goes for \\'4\\', it appeared 2 times, we want to count only \\'one\\' time.\\n\\n\\t\\t\\t\\t// this is why we subtracted  all common duplicates first, then lastly add the lcm(a,lcm(b,c)) //simply say -  lcm(a,b,c)\\n\\t\\t\\t\\t// we do this last \\'add\\' step because we have already subtracted all duplicates that are common.\\n\\t\\t\\t\\t// so to add those who are common in \"all three series\" (like 12 here), we do this last  \\'+ lcm(a,b,c)\\' step.\\n\\t\\t*/\\n\\t\\t\\n     \\n      long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;\\n      \\n      return total >= n;\\n      \\n    }\\n  \\n  \\n    static long gcd(long a,long b){\\n      while(b>0){\\n        a%=b;\\n        //swap\\n        long temp = a;\\n        a = b;\\n        b = temp;\\n      }\\n      return a;\\n    }\\n\\n    static long lcm(long a, long b){\\n      \\n      return a/gcd(a,b)*b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622570,
                "title": "c-textbook-binary-search-beat-100",
                "content": "```\\n//https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template\\n#define ll long long \\nclass Solution {\\npublic:\\n    // Binary search \\n    int nthUglyNumber(int N, int A, int B, int C) {\\n        \\n        ll n = N; ll a = A; ll b = B; ll c = C;\\n        \\n        ll low = 1;\\n        ll high = INT_MAX;\\n        \\n        while(low <= high){\\n            \\n            ll mid = (low + high) >> 1;\\n            \\n            // Find the number of ugly numbers upto and including \\'mid\\'\\n            ll uglies = mid/a + mid/b + mid/c - mid/lcm(a,b) - mid/lcm(a,c) - mid/lcm(b,c) + mid/lcm(a,lcm(b,c));\\n            \\n\\t\\t\\t// if uglies >= n, then for all numbers >= mid, uglies will always be >= n \\n            if(uglies >= n) \\n                high = mid-1;\\n\\t\\t\\t\\n\\t\\t\\t// if uglies < n, then for all numbers<= mid, uglies will always be < n\\n            else \\n                low = mid+1;\\n\\t\\t\\t\\t\\n\\t\\t/*\\n\\t\\tHere, the predicate function F(mid)  = True if uglies >= n\\n\\t\\tHence the search space will be like\\n\\t\\t\\n\\t\\tF F F F F F F F T T T T T T T T\\n\\t\\t\\n\\t\\tHence we apply binary search\\n\\t\\t*/\\n        }\\n        \\n        return low; \\n            \\n    }\\n    \\n    \\n    ll lcm(ll x, ll y){\\n        //finds the lcm of x and y\\n        // LCM(x,y) = (x*y) / GCD(x,y)\\n        \\n        return (x*y) / __gcd(x,y);\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template\\n#define ll long long \\nclass Solution {\\npublic:\\n    // Binary search \\n    int nthUglyNumber(int N, int A, int B, int C) {\\n        \\n        ll n = N; ll a = A; ll b = B; ll c = C;\\n        \\n        ll low = 1;\\n        ll high = INT_MAX;\\n        \\n        while(low <= high){\\n            \\n            ll mid = (low + high) >> 1;\\n            \\n            // Find the number of ugly numbers upto and including \\'mid\\'\\n            ll uglies = mid/a + mid/b + mid/c - mid/lcm(a,b) - mid/lcm(a,c) - mid/lcm(b,c) + mid/lcm(a,lcm(b,c));\\n            \\n\\t\\t\\t// if uglies >= n, then for all numbers >= mid, uglies will always be >= n \\n            if(uglies >= n) \\n                high = mid-1;\\n\\t\\t\\t\\n\\t\\t\\t// if uglies < n, then for all numbers<= mid, uglies will always be < n\\n            else \\n                low = mid+1;\\n\\t\\t\\t\\t\\n\\t\\t/*\\n\\t\\tHere, the predicate function F(mid)  = True if uglies >= n\\n\\t\\tHence the search space will be like\\n\\t\\t\\n\\t\\tF F F F F F F F T T T T T T T T\\n\\t\\t\\n\\t\\tHence we apply binary search\\n\\t\\t*/\\n        }\\n        \\n        return low; \\n            \\n    }\\n    \\n    \\n    ll lcm(ll x, ll y){\\n        //finds the lcm of x and y\\n        // LCM(x,y) = (x*y) / GCD(x,y)\\n        \\n        return (x*y) / __gcd(x,y);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622523,
                "title": "binary-search-with-venn-diagram-in-python-time-o-log-n-min-a-b-c-space-o-1",
                "content": "https://leetcode.com/problems/nth-magical-number/solution/\\nThere is a similar problem and you can see the solution in the problem above to deepen your understanding.\\n\\nget_lcm is a self-made function to get the least common multiple of all the arguments.\\n\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def num_of_ugly_below(val):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm_ab) - (val // lcm_bc) - (val // lcm_ca) + (val // lcm_abc)\\n        \\n        def get_lcm(*vals):\\n            res = vals[0]\\n            for i in range(1, len(vals)):\\n                res = res * vals[i] // gcd(res, vals[i])\\n            return res\\n        \\n        lcm_ab, lcm_bc, lcm_ca, lcm_abc = get_lcm(a, b), get_lcm(b, c), get_lcm(c, a), get_lcm(a, b, c)\\n        \\n        #binary search\\n        l, r = 1, min(a, b, c) * n\\n        while l < r:\\n            mid = (l + r) // 2\\n            if num_of_ugly_below(mid) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nfrom math import gcd\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def num_of_ugly_below(val):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm_ab) - (val // lcm_bc) - (val // lcm_ca) + (val // lcm_abc)\\n        \\n        def get_lcm(*vals):\\n            res = vals[0]\\n            for i in range(1, len(vals)):\\n                res = res * vals[i] // gcd(res, vals[i])\\n            return res\\n        \\n        lcm_ab, lcm_bc, lcm_ca, lcm_abc = get_lcm(a, b), get_lcm(b, c), get_lcm(c, a), get_lcm(a, b, c)\\n        \\n        #binary search\\n        l, r = 1, min(a, b, c) * n\\n        while l < r:\\n            mid = (l + r) // 2\\n            if num_of_ugly_below(mid) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159919,
                "title": "easy-python-solution",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        minimum = min(a, b, c)\\n        left = minimum; right = n*minimum\\n        l1 = (a*b)//math.gcd(a, b)\\n        l2 = (b*c)//math.gcd(b, c)\\n        l3 = (c*a)//math.gcd(c, a)\\n        l4 = l1*c//math.gcd(l1, c)\\n        while left <= right:\\n            mid = left + (right-left)//2\\n            pos = mid//a + mid//b + mid//c - mid//l1 - mid//l2 - mid//l3 + mid//l4\\n            if pos > n:\\n                right = mid - 1\\n            elif pos < n:\\n                left = mid + 1\\n            else:\\n                if mid%a == 0 or mid%b == 0 or mid%c == 0:\\n                    return mid\\n                else:\\n                    right = mid - 1 \\n ```",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        minimum = min(a, b, c)\\n        left = minimum; right = n*minimum\\n        l1 = (a*b)//math.gcd(a, b)\\n        l2 = (b*c)//math.gcd(b, c)\\n        l3 = (c*a)//math.gcd(c, a)\\n        l4 = l1*c//math.gcd(l1, c)\\n        while left <= right:\\n            mid = left + (right-left)//2\\n            pos = mid//a + mid//b + mid//c - mid//l1 - mid//l2 - mid//l3 + mid//l4\\n            if pos > n:\\n                right = mid - 1\\n            elif pos < n:\\n                left = mid + 1\\n            else:\\n                if mid%a == 0 or mid%b == 0 or mid%c == 0:\\n                    return mid\\n                else:\\n                    right = mid - 1 \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1128338,
                "title": "python3-using-binary-search-100-memory-and-70-faster",
                "content": "```\\nclass Solution:\\n    def gcd(self, m, n):\\n        if m == n:\\n            return m\\n        \\n        if n == 0:\\n            return m\\n        \\n        result = 0\\n        while 1:\\n            r = m % n\\n            if r == 0:\\n                result = n\\n                break\\n            m = n\\n            n = r\\n        return result\\n    \\n    def lcm(self, a, b):\\n        return (a * b) // self.gcd(a, b)\\n    \\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:   \\n        def count_ugly(mid):\\n            \"\"\"Using set theory\\n            C -> count;\\n            Formula: C(a \\u222A b \\u222A c) = (C(a) + C(b) + C(c)) - (C(a \\u2229 b) + C(a \\u2229 c) + C(b \\u2229 c)) + C(a \\u2229 b \\u2229 c)\\n            \"\"\"\\n            single = ((mid // a) + (mid // b) + (mid // c))\\n            double = ((mid // self.lcm(a, b)) + (mid // self.lcm(a, c)) + (mid // self.lcm(b, c)))\\n            tripple = mid // self.lcm(self.lcm(a, b), c)\\n            return single - double + tripple\\n            \\n        def binary_search():\\n            \"\"\"use binary search to find the nth count\"\"\"\\n            low = 1\\n            high = 2**31 - 1 # set it as high as possible\\n            \\n            while low < high:\\n                mid = (low + high) >> 1\\n                count = count_ugly(mid)\\n\\n                if count < n:\\n                    low = mid + 1\\n                elif count > n:\\n                    high = mid - 1\\n                else:\\n                    if mid % a != 0 and mid % b != 0 and mid % c != 0:\\n                        high = mid - 1\\n                    else:\\n                        return mid\\n            return low\\n        return binary_search()\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def gcd(self, m, n):\\n        if m == n:\\n            return m\\n        \\n        if n == 0:\\n            return m\\n        \\n        result = 0\\n        while 1:\\n            r = m % n\\n            if r == 0:\\n                result = n\\n                break\\n            m = n\\n            n = r\\n        return result\\n    \\n    def lcm(self, a, b):\\n        return (a * b) // self.gcd(a, b)\\n    \\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:   \\n        def count_ugly(mid):\\n            \"\"\"Using set theory\\n            C -> count;\\n            Formula: C(a \\u222A b \\u222A c) = (C(a) + C(b) + C(c)) - (C(a \\u2229 b) + C(a \\u2229 c) + C(b \\u2229 c)) + C(a \\u2229 b \\u2229 c)\\n            \"\"\"\\n            single = ((mid // a) + (mid // b) + (mid // c))\\n            double = ((mid // self.lcm(a, b)) + (mid // self.lcm(a, c)) + (mid // self.lcm(b, c)))\\n            tripple = mid // self.lcm(self.lcm(a, b), c)\\n            return single - double + tripple\\n            \\n        def binary_search():\\n            \"\"\"use binary search to find the nth count\"\"\"\\n            low = 1\\n            high = 2**31 - 1 # set it as high as possible\\n            \\n            while low < high:\\n                mid = (low + high) >> 1\\n                count = count_ugly(mid)\\n\\n                if count < n:\\n                    low = mid + 1\\n                elif count > n:\\n                    high = mid - 1\\n                else:\\n                    if mid % a != 0 and mid % b != 0 and mid % c != 0:\\n                        high = mid - 1\\n                    else:\\n                        return mid\\n            return low\\n        return binary_search()\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698709,
                "title": "c-100-fast-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long int gcdFind(long long int a, long long int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return gcdFind(b, a % b);\\n    }\\n    \\n    long long int lcm(long long int a, long long int b)\\n    {\\n        long long int gcd = gcdFind(a, b);\\n        return (a*b) / gcd;\\n    }\\n    \\n    long long int find(int a, int b, int c, long long int no)\\n    {\\n        long long int individuals = 0;\\n        individuals += no/a;\\n        individuals += no/b;\\n        individuals += no/c;\\n        \\n        long long int doubles = 0;\\n        doubles += (no /lcm(a,b));\\n        doubles += (no /lcm(b,c));\\n        doubles += (no /lcm(c,a));\\n        \\n        long long int triples = 0;\\n        triples += (no/lcm(lcm(a,b),c));\\n        \\n        return individuals - doubles + triples;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long int l, r, mid;\\n        l = 1;\\n        r = 2 * 1e9;\\n        \\n        while(l < r)\\n        {\\n            mid = (l+r)/2;\\n            long long int res = find(a, b, c, mid);\\n            if(find(a, b, c, mid) >= n)\\n            {\\n               r = mid;\\n            }\\n            else\\n            {\\n               l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long int gcdFind(long long int a, long long int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return gcdFind(b, a % b);\\n    }\\n    \\n    long long int lcm(long long int a, long long int b)\\n    {\\n        long long int gcd = gcdFind(a, b);\\n        return (a*b) / gcd;\\n    }\\n    \\n    long long int find(int a, int b, int c, long long int no)\\n    {\\n        long long int individuals = 0;\\n        individuals += no/a;\\n        individuals += no/b;\\n        individuals += no/c;\\n        \\n        long long int doubles = 0;\\n        doubles += (no /lcm(a,b));\\n        doubles += (no /lcm(b,c));\\n        doubles += (no /lcm(c,a));\\n        \\n        long long int triples = 0;\\n        triples += (no/lcm(lcm(a,b),c));\\n        \\n        return individuals - doubles + triples;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long int l, r, mid;\\n        l = 1;\\n        r = 2 * 1e9;\\n        \\n        while(l < r)\\n        {\\n            mid = (l+r)/2;\\n            long long int res = find(a, b, c, mid);\\n            if(find(a, b, c, mid) >= n)\\n            {\\n               r = mid;\\n            }\\n            else\\n            {\\n               l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550836,
                "title": "the-question-is-similar-to-lc-878",
                "content": "The question is similar to LC[878](https://leetcode.com/problems/nth-magical-number/)\\n```cpp\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) {\\n        long left = 1, right = 2*1e9;\\n        long a = long(A), b = long(B), c = long(C);\\n        long ab = a*b/__gcd(a, b);\\n        long ac = a*c/__gcd(a, c);\\n        long bc = b*c/__gcd(b, c);\\n        long abc = a*bc/__gcd(a, bc);\\n        while(left < right)\\n        {\\n            long mid = left + (right - left)/2;\\n            int cnt = mid/a+mid/b+mid/c+mid/abc-mid/ab-mid/ac-mid/bc;\\n            if(cnt < n)left = mid+1;\\n            else right = mid;\\n        }\\n        return left;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) {\\n        long left = 1, right = 2*1e9;\\n        long a = long(A), b = long(B), c = long(C);\\n        long ab = a*b/__gcd(a, b);\\n        long ac = a*c/__gcd(a, c);\\n        long bc = b*c/__gcd(b, c);\\n        long abc = a*bc/__gcd(a, bc);\\n        while(left < right)\\n        {\\n            long mid = left + (right - left)/2;\\n            int cnt = mid/a+mid/b+mid/c+mid/abc-mid/ab-mid/ac-mid/bc;\\n            if(cnt < n)left = mid+1;\\n            else right = mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 523246,
                "title": "java-o-logn-solution-from-the-view-of-set-0ms-beats-100",
                "content": "Explain from the view of sets union and intersection.\\n\\n# Structure of the problem\\nThis ulgy number problem actually has a beautiful math structure.\\n\\nLet `A`,`B`,`C` denote the 3 base integers, then for any number `N>=1`, it is an ugly number if and only if `N%A==0`, `N%B==0` or `N%C==0`, here `%` means taking the modulus.\\n\\nNow let\\'s consider given a number `N>=1`, how many **unique** ugly number is there in range `[1,N]`. Let\\'s try to write all possible ugly numbers:\\n\\n`SA = {A  2A 3A  .... r*A}...N`\\n\\n`SB = {B  2B 3B .... p*B}...N`\\n\\n`SC = {C  2C  3C .... q*C}...N`\\n\\nIn the above representation, we use `r*A`,`p*B`,`q*C` to denote the biggest number nearest to N(less than or equals to N), and `SA`, `SB`, `SC` to denote three sets for each base integer.\\n\\n\\nThen the count of unique ugly number is `|SA\\u222ASB\\u222ASC|`, which expands to \\n\\n`|SA\\u222ASB\\u222ASC|=|SA| + |SB| + |SC| - |SA \\u2229 SB| - |SA \\u2229 SC| - |SB \\u2229 SC| + |SA \\u2229 SB \\u2229 SC|`.\\n\\n# Calculation of |SA|\\nWe know that `|SA| = r = floor(N/A)`, `|SB| = p = floor(N/B)`,`|SC| = q = floor(N/C)`.\\n\\n\\n# Calculation of |SA \\u2229 SB|\\nNow lets consider how to calculate `|SA \\u2229 SB|`. Let `e \\u2208 (SA \\u2229 SB)`, then `e` can be both divided by `A` and `B`, let `e=i*A=j*B`, our task is to find how many `i` is there in `[1,r]`. \\n\\nlet `d` be the biggest common factor for `A` and `B`, i.e. `d=gcd(A,B)`, and let `Ax=A/d`, `Bx=B/d`, then we divide `d` in both sides, getting the following equation: `i*Ax=j*Bx`.\\n\\nBecause `Ax`,`Bx` have no common factor except `1`, then must `i` be multiple of `Bx` to make the equation true.\\n\\nThen we known that `i%Bx==0`.Let `i=h*Bx`, thus `1<= (e==h*Bx*A)  <=N`,\\n\\ni.e.  \\n\\n`1/(Bx*A) <= h <= N/(Bx*A)`,  \\n\\nwe know that there is `floor(N/(Bx*A))` possible values for `h`, thus `|SA \\u2229 SB| = floor(N/(Bx*A)) = floor(N/(B/gcd(A,B)*A))`.\\n\\nAnd similarly `|SA \\u2229 SC| = floor(N/(C/gcd(A,C)*A))`,  `|SB \\u2229 SC| = floor(N/(C/gcd(B,C)*B))`.\\n\\n# Calculation of |SA \\u2229 SB \\u2229 SC|\\nSimilarly lets consider `e \\u2208 (SA \\u2229 SB \\u2229 SC)`, then there exists some `i`,`j`,`k` such that `e=i*A=j*B=k*C`.\\n\\nLet `Bx = B/gcd(A,B)`, `Cx = C/gcd(A,C)`, then divide `gcd(A,B)`,`gcd(A,C)` in each side,we know that `i` is a multiple of `Bx`, and also a multiple of `Cx`, which means `i` is minimal common multiple of `Bx`,`Cx`, which is `Bx*Cx/gcd(Bx,Cx)`, let `i = h*Bx*Cx/gcd(Bx,Cx)`.\\n\\nThen we know that `1 <= (e==A*i==A*h*Bx*Cx/gcd(Bx,Cx)) <= N`, then `|SA \\u2229 SB \\u2229 SC| = floor(N*gcd(Bx,Cx)/(A*Bx*Cx)) = floor(N*gcd(gcd(A,B),gcd(B,C))/(A*gcd(A,B)*gcd(A,C)))`.\\n\\nAnd because `|SA \\u2229 SB| = |SA \\u2229 SB \\u2229 SA|`, it can also be epxressed in this form.\\n\\n\\n# Binary Search to Find the Nearest Number `N`\\nOur task is to find the `n`th ugly number, we known `n` must exist, so we search from `1` to `n*a`, this could be done by a binary search.\\n\\n# Code(0ms,beats 100%)\\n```java\\nclass Solution {\\n    public int nthUglyNumber(int n,int a,int b,int c) {\\n        long  min=Math.min(Math.min(a,b),c);\\n        long r=1;\\n        long p=min*n;\\n        \\n        while(r<=p){\\n            long m=r+((p-r)/2);\\n            long s=count(m,a,b,c);\\n            if(s==n)return (int)Math.max(Math.max(m/a*a,m/b*b),m/c*c);\\n            else if(s<n) r=m+1;\\n            else p=m-1;\\n\\n        }\\n        throw new IllegalArgumentException(\"n is too large\");\\n    }\\n\\n    long count(long N,int A,int B,int C){\\n        return N/A+N/B+N/C-countIntersection(N,A,B,A)-countIntersection(N,A,C,A)-countIntersection(N,B,C,B)+countIntersection(N,A,B,C);\\n    }\\n\\n    // |SA \\u2229 SB \\u2229 SC|, when A==C,|SA \\u2229 SB \\u2229 SC| = |SA \\u2229 SB|\\n    long countIntersection(long N,int A,int B,int C){\\n        int Bx=B/gcd(A,B);\\n        int Cx=C/gcd(A,C);\\n        int Dx=gcd(Bx,Cx);\\n        long F=(long)A*Bx*Cx;\\n        return Dx*N/F;\\n    }\\n\\n    int gcd(int x,int y){\\n        return y==0?x:gcd(y,x%y);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int nthUglyNumber(int n,int a,int b,int c) {\\n        long  min=Math.min(Math.min(a,b),c);\\n        long r=1;\\n        long p=min*n;\\n        \\n        while(r<=p){\\n            long m=r+((p-r)/2);\\n            long s=count(m,a,b,c);\\n            if(s==n)return (int)Math.max(Math.max(m/a*a,m/b*b),m/c*c);\\n            else if(s<n) r=m+1;\\n            else p=m-1;\\n\\n        }\\n        throw new IllegalArgumentException(\"n is too large\");\\n    }\\n\\n    long count(long N,int A,int B,int C){\\n        return N/A+N/B+N/C-countIntersection(N,A,B,A)-countIntersection(N,A,C,A)-countIntersection(N,B,C,B)+countIntersection(N,A,B,C);\\n    }\\n\\n    // |SA \\u2229 SB \\u2229 SC|, when A==C,|SA \\u2229 SB \\u2229 SC| = |SA \\u2229 SB|\\n    long countIntersection(long N,int A,int B,int C){\\n        int Bx=B/gcd(A,B);\\n        int Cx=C/gcd(A,C);\\n        int Dx=gcd(Bx,Cx);\\n        long F=(long)A*Bx*Cx;\\n        return Dx*N/F;\\n    }\\n\\n    int gcd(int x,int y){\\n        return y==0?x:gcd(y,x%y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686976,
                "title": "binary-search-with-simple-maths-logic-of-sets-and-union-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nlong long check(long long mid, vector<long long> v, long long n)\\n{\\n    // lcm of a, b;\\n    long long a = v[0], b = v[1], c = v[2];\\n    long long lcmAB = a * b / __gcd(a, b);\\n    long long lcmBC = b * c / __gcd(b, c);\\n    long long lcmAC = a * c / __gcd(a, c);\\n    long long lcmABC = lcmAB * c / __gcd(lcmAB, c);\\n    long long cnt = mid / a;\\n    cnt += mid / b;\\n    cnt += mid / c;\\n    cnt -= mid / lcmAB;\\n    cnt -= mid / lcmBC;\\n    cnt -= mid / lcmAC;\\n    cnt += mid / lcmABC;\\n\\n    return cnt;\\n}\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n          vector<long long> v = {a, b, c};\\n    sort(v.begin(), v.end());\\n    long long st = 1, end = 1e18;\\n    // long long ans = end;\\n    long long ans = -1;\\n    while (st <= end)\\n    {\\n        long long mid = st + (end - st) / 2;\\n        long long pos = check(mid, v, n);\\n        if (pos == n)\\n        {\\n            ans = mid;\\n            break;\\n        }\\n        else if (pos > n)\\n            end = mid;\\n        else\\n            st = mid + 1;\\n    }\\n\\n    if (ans % a == 0 or ans % b == 0 or ans % c == 0)\\n        return ans;\\n    while (ans % a != 0 and ans % b != 0 and ans % c != 0)\\n        ans--;\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nlong long check(long long mid, vector<long long> v, long long n)\\n{\\n    // lcm of a, b;\\n    long long a = v[0], b = v[1], c = v[2];\\n    long long lcmAB = a * b / __gcd(a, b);\\n    long long lcmBC = b * c / __gcd(b, c);\\n    long long lcmAC = a * c / __gcd(a, c);\\n    long long lcmABC = lcmAB * c / __gcd(lcmAB, c);\\n    long long cnt = mid / a;\\n    cnt += mid / b;\\n    cnt += mid / c;\\n    cnt -= mid / lcmAB;\\n    cnt -= mid / lcmBC;\\n    cnt -= mid / lcmAC;\\n    cnt += mid / lcmABC;\\n\\n    return cnt;\\n}\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n          vector<long long> v = {a, b, c};\\n    sort(v.begin(), v.end());\\n    long long st = 1, end = 1e18;\\n    // long long ans = end;\\n    long long ans = -1;\\n    while (st <= end)\\n    {\\n        long long mid = st + (end - st) / 2;\\n        long long pos = check(mid, v, n);\\n        if (pos == n)\\n        {\\n            ans = mid;\\n            break;\\n        }\\n        else if (pos > n)\\n            end = mid;\\n        else\\n            st = mid + 1;\\n    }\\n\\n    if (ans % a == 0 or ans % b == 0 or ans % c == 0)\\n        return ans;\\n    while (ans % a != 0 and ans % b != 0 and ans % c != 0)\\n        ans--;\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634300,
                "title": "kotlin-explained-with-comments",
                "content": "**Problem**: find **n<sup>th</sup>** positive integer that is divisible by either **a**, **b** or **c**\\n\\nWhat if we can quickly calculate how many numbers are divisible by either **a**, **b** or **c** and less or equal to some number **k**? It is said that answer is not greater than `2 * 10^9` and we can do binary search in this range. Awesome! \\n\\nHow can we calculate for any **k**? Let\\'s build intuition step-by-step:\\n1. How many numbers divisible only by **a**? It\\'s **k / a**\\n2. How many numbers divisible by **a** or **b**? \\n2.1 For **a** it is **k / a**. \\n2.2 For **b** it is **k / b**. \\n2.3 Are there any numbers that can be calculated twice if we sum up **k / a** and **k / b**? Yes!\\n2.4 What numbers can be calculated twice? The ones divisible by **a** and **b** at the same time. For example, **a * b**, **2 * a * b**, **3 * a * b** and etc\\n2.5 Is **a * b** the smallest number divible by a and b at the same time? Not always!\\n2.6 What number is the smallest one? It is known as **[Least Common Multiple](https://en.wikipedia.org/wiki/Least_common_multiple)**. Let\\'s call it **lcm** so that least common multiple for **a** and **b** will be **lcm(a, b)**. It has properties like **lcm(a, b)** divides **a * b** and less or equal to** a * b**.\\n2.7 Any other numbers not counted or counted more than once? No. \\n2.8 Final count is **(k / a) + (k / b) - (k / lcm(a, b))**\\n3. How many numbers divisible by **a**, **b** or **c**?\\n3.1 Based on previous steps: **(k / a) + (k / b) + (k / c) - (k / lcm(a, b)) - (k / lcm(a, c)) - (k / lcm(b, c))**\\n3.2 Are there any numbers that not counted or counted more than once? Yes.\\n3.3 What numbers? For example, the ones divisible by **a**, **b** and **c** at the same time?\\n3.4 Why is it so? Let\\'s assume **k** is big enough so that **a * b * c** is equal or smaller then **k**: \\n3.4.1 Every multiple of **a** included into **k / a**. Since **a * (b * c)** is a **(b * c)-th** mutliple of **a**, **a * b * c** will be included into **(k / a)** if **k** big enough. This true for **b** with **(k / b)** and **c** with **(k / c)**. As a result of that **a * b * c** will be counted 3 times! \\n3.4.2 Since **lcm(a, b)** divides **a * b** then **a * b * c** is also divisible by **lcm(a, b)**. Since **k** is big enough, then **a * b * c** also counted in **k / lcm(a, b)** part of formula above. The same holds true to **k / lcm(a, c)** and **k / lcm(b, c)** parts. As a result of that, **a * b * c** will be subtracted 3 times and not counted at all!\\n3.4.3 Is **a * b * c** is the smallest number divisible by **a**, **b** and **c** at the same time? From the case for **a** and **b** only, it is [least common multiple](https://en.wikipedia.org/wiki/Least_common_multiple) for **a**, **b**, and **c**. Let\\'s call it **lcm(a, b, c)**. It has the same properties as in the case of 2 numbers: **lcm(a, b, c)** is smaller or equal to **a * b * c** and divides **a * b * c**. As a result of that, conclusions for **a * b * c** above holds true to **lcm(a, b, c)**\\n\\nFinal formula: **(k / a) + (k / b) + (k / c) - (k / lcm(a, b)) - (k / lcm(a, c)) - (k / lcm(b, c)) + (k / lcm(a, b, c))**\\n\\nComplexity: `O(log(range))`\\n```\\nclass Solution {\\n\\tfun nthUglyNumber(n: Int, _a: Int, _b: Int, _c: Int): Int {\\n\\t\\t// intermediate results can be bigger than `Int.MAX_VALUE`\\n\\t\\t// let\\'s convert to `Long`\\n\\t\\tval a = _a.toLong()\\n\\t\\tval b = _b.toLong()\\n\\t\\tval c = _c.toLong()\\n\\n\\t\\t// greatest common divisor\\n\\t\\tfun gcd(a: Long, b: Long): Long = if (a == 0L) b else gcd(b % a, a)\\n\\n\\t\\t// least common multiple\\n\\t\\tfun lcm(a: Long, b: Long): Long {\\n\\t\\t\\treturn a * b / gcd(a, b)\\n\\t\\t}\\n\\n\\t\\tval ab = lcm(a, b)\\n\\t\\tval bc = lcm(b, c)\\n\\t\\tval ac = lcm(a, c)\\n\\t\\t// lcm(a, b, c) = lcm(lcm(a, b), c)\\n\\t\\tval abc = lcm(ab, c)\\n\\n\\t\\tfun calc(n: Long): Long = n / a + n / b + n / c - n / ab - n / ac - n / bc + n / abc\\n\\n\\t\\tvar l = 1L\\n\\t\\t// Fact 1. As per description, result will fit into 2*10^9\\n\\t\\t// Fact 2. We need n-th number which is divisible by either a, b or c. n * minOf(a, b, c) is guarantee to be \\n\\t\\t// equal or bigger than the result we are looking for.\\n\\t\\t// Let\\'s grab minimum out of those values to decrease range for search \\n\\t\\tvar r = minOf(2_000_000_000L, n * minOf(a, b, c))\\n\\n\\t\\twhile (l < r) {\\n\\t\\t\\tval mid = (l + r) / 2\\n\\t\\t\\tif (calc(mid) >= n) r = mid else l = mid + 1\\n\\t\\t}\\n\\n\\t\\treturn l.toInt()\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\tfun nthUglyNumber(n: Int, _a: Int, _b: Int, _c: Int): Int {\\n\\t\\t// intermediate results can be bigger than `Int.MAX_VALUE`\\n\\t\\t// let\\'s convert to `Long`\\n\\t\\tval a = _a.toLong()\\n\\t\\tval b = _b.toLong()\\n\\t\\tval c = _c.toLong()\\n\\n\\t\\t// greatest common divisor\\n\\t\\tfun gcd(a: Long, b: Long): Long = if (a == 0L) b else gcd(b % a, a)\\n\\n\\t\\t// least common multiple\\n\\t\\tfun lcm(a: Long, b: Long): Long {\\n\\t\\t\\treturn a * b / gcd(a, b)\\n\\t\\t}\\n\\n\\t\\tval ab = lcm(a, b)\\n\\t\\tval bc = lcm(b, c)\\n\\t\\tval ac = lcm(a, c)\\n\\t\\t// lcm(a, b, c) = lcm(lcm(a, b), c)\\n\\t\\tval abc = lcm(ab, c)\\n\\n\\t\\tfun calc(n: Long): Long = n / a + n / b + n / c - n / ab - n / ac - n / bc + n / abc\\n\\n\\t\\tvar l = 1L\\n\\t\\t// Fact 1. As per description, result will fit into 2*10^9\\n\\t\\t// Fact 2. We need n-th number which is divisible by either a, b or c. n * minOf(a, b, c) is guarantee to be \\n\\t\\t// equal or bigger than the result we are looking for.\\n\\t\\t// Let\\'s grab minimum out of those values to decrease range for search \\n\\t\\tvar r = minOf(2_000_000_000L, n * minOf(a, b, c))\\n\\n\\t\\twhile (l < r) {\\n\\t\\t\\tval mid = (l + r) / 2\\n\\t\\t\\tif (calc(mid) >= n) r = mid else l = mid + 1\\n\\t\\t}\\n\\n\\t\\treturn l.toInt()\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468756,
                "title": "python-binary-search-thoroughly-explained-in-code",
                "content": "Main idea:\\n- Guess a number, check its ugly rank\\n- Adjust your guess using binary search\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        def get_nth_ugly(x, a, b, c):\\n            \"\"\"Returns the ugly rank of number x based on divisors a b and c\"\"\"\\n            a_divisors = x // a\\n            b_divisors = x // b\\n            c_divisors = x // c\\n\\n            ab_divisors = x // math.lcm(a, b)\\n            ac_divisors = x // math.lcm(a, c)\\n            bc_divisors = x // math.lcm(b, c)\\n\\n            abc_divisors = x // math.lcm(a, b, c)\\n\\n            return a_divisors + b_divisors + c_divisors - ab_divisors - ac_divisors - bc_divisors + abc_divisors\\n        \\n        def is_ugly(x, a, b, c):\\n            \"\"\"Checks whether the current number is an ugly number\"\"\"\\n            return x % a == 0 or x % b == 0 or x % c == 0\\n        \\n        # binary search\\n        # initialize at min and max results\\n        left = 1\\n        right = 2_000_000_000\\n        \\n        while left <= right:\\n            # set the mid point to look at\\n            target = (left + right) // 2\\n            \\n            # check the ugly rank\\n            nth_ugly = get_nth_ugly(target, a, b, c)\\n            \\n            # was this the number we were looking for?\\n            if nth_ugly == n:\\n                \\n                # correct rank AND is ugly\\n                if is_ugly(target, a, b, c):\\n                    return target\\n                else:\\n                    \\n                    # correct rank but not ugly, a lower number with the same rank exists that IS ugly\\n                    right = target - 1\\n                \\n                # not found, move the boundary accordingly\\n            elif nth_ugly < n:\\n                left = target + 1\\n            else:\\n                right = target - 1\\n        \\n        # code is guaranteed to have a solution, no ending return is needed\\n        ```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        def get_nth_ugly(x, a, b, c):\\n            \"\"\"Returns the ugly rank of number x based on divisors a b and c\"\"\"\\n            a_divisors = x // a\\n            b_divisors = x // b\\n            c_divisors = x // c\\n\\n            ab_divisors = x // math.lcm(a, b)\\n            ac_divisors = x // math.lcm(a, c)\\n            bc_divisors = x // math.lcm(b, c)\\n\\n            abc_divisors = x // math.lcm(a, b, c)\\n\\n            return a_divisors + b_divisors + c_divisors - ab_divisors - ac_divisors - bc_divisors + abc_divisors\\n        \\n        def is_ugly(x, a, b, c):\\n            \"\"\"Checks whether the current number is an ugly number\"\"\"\\n            return x % a == 0 or x % b == 0 or x % c == 0\\n        \\n        # binary search\\n        # initialize at min and max results\\n        left = 1\\n        right = 2_000_000_000\\n        \\n        while left <= right:\\n            # set the mid point to look at\\n            target = (left + right) // 2\\n            \\n            # check the ugly rank\\n            nth_ugly = get_nth_ugly(target, a, b, c)\\n            \\n            # was this the number we were looking for?\\n            if nth_ugly == n:\\n                \\n                # correct rank AND is ugly\\n                if is_ugly(target, a, b, c):\\n                    return target\\n                else:\\n                    \\n                    # correct rank but not ugly, a lower number with the same rank exists that IS ugly\\n                    right = target - 1\\n                \\n                # not found, move the boundary accordingly\\n            elif nth_ugly < n:\\n                left = target + 1\\n            else:\\n                right = target - 1\\n        \\n        # code is guaranteed to have a solution, no ending return is needed\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2421037,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n\\n  long long lcm(int a, int b)\\n  {\\n    long long int gcd=__gcd(a,b);  \\n    return (a /gcd) * b;\\n  } \\n    \\n   long long int check(int n, int a, int b, int c) {\\n      \\n        long long int c1=n/a;\\n        long long int c2=n/b;\\n        long long int c3=n/c;\\n        long long int c4=n/lcm(a,b);  \\n        long long int c5=n/lcm(b,c);  \\n        long long int c6=n/lcm(c,a);  \\n        long long int c7=n/lcm(lcm(a,b),c);\\n      \\n       \\n       return c1+c2+c3-c4-c5-c6+c7;\\n    }\\n    \\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n     \\n        \\n     long long int end=2*1e9;   \\n        \\n     long long int start=1;\\n        \\n     long long int mid=1; \\n      while(start<=end){\\n       \\n       mid=(start+end)/2;   \\n          \\n       if(check(mid,a,b,c)==n){\\n           break;\\n       }\\n       else if(check(mid,a,b,c)>n){\\n           end=mid-1;\\n       }\\n       else{\\n           start=mid+1; \\n       }   \\n          \\n          \\n          \\n      }   \\n        \\n      long long int x=mid/a*a;\\n        \\n      long long int y=mid/b*b;\\n        \\n      long long int z=mid/c*c;  \\n      \\n        \\n      int max1=max(max(x,y),z);\\n        \\n      return max1;  \\n          \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n\\n  long long lcm(int a, int b)\\n  {\\n    long long int gcd=__gcd(a,b);  \\n    return (a /gcd) * b;\\n  } \\n    \\n   long long int check(int n, int a, int b, int c) {\\n      \\n        long long int c1=n/a;\\n        long long int c2=n/b;\\n        long long int c3=n/c;\\n        long long int c4=n/lcm(a,b);  \\n        long long int c5=n/lcm(b,c);  \\n        long long int c6=n/lcm(c,a);  \\n        long long int c7=n/lcm(lcm(a,b),c);\\n      \\n       \\n       return c1+c2+c3-c4-c5-c6+c7;\\n    }\\n    \\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n     \\n        \\n     long long int end=2*1e9;   \\n        \\n     long long int start=1;\\n        \\n     long long int mid=1; \\n      while(start<=end){\\n       \\n       mid=(start+end)/2;   \\n          \\n       if(check(mid,a,b,c)==n){\\n           break;\\n       }\\n       else if(check(mid,a,b,c)>n){\\n           end=mid-1;\\n       }\\n       else{\\n           start=mid+1; \\n       }   \\n          \\n          \\n          \\n      }   \\n        \\n      long long int x=mid/a*a;\\n        \\n      long long int y=mid/b*b;\\n        \\n      long long int z=mid/c*c;  \\n      \\n        \\n      int max1=max(max(x,y),z);\\n        \\n      return max1;  \\n          \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420975,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long med=1, end, beg;\\n        beg=1; end=2*1e9;\\n        \\n        while(beg<=end){\\n            med=(beg + end)/2;\\n            long long fk=uglyNumsLessThanK(med,a,b,c);\\n            if(fk==n){\\n                cout<<med;\\n                break;\\n            }\\n            else if(n<fk){\\n                end=med-1;\\n            }\\n            else{\\n                beg=med+1;\\n            }\\n        }\\n        \\n        \\n                long long c1=med/a*a, c2=med/b*b, c3=med/c*c;\\n                long long max=0;\\n                max=c1>c2?c1:c2;\\n                max=max>c3?max:c3;\\n                return (int)max; \\n    }\\n    \\n    long long uglyNumsLessThanK(long long k, int a, int b, int c){\\n        int lcm12=lcm(a,b);\\n        long long c1=k/a, c2=k/b, c3=k/c, c12=k/lcm12, c13=k/lcm(a,c), c23=k/lcm(b,c), c123=k/lcm(lcm12,c);\\n        \\n        return c1+c2+c3-c12-c13-c23+c123;\\n    }\\n    \\n    long long gcd(long long int a, long long int b)\\n{\\n  if (b == 0)\\n    return a;\\n  return gcd(b, a % b);\\n}\\n \\n// Function to return LCM of two numbers\\nlong long lcm(int a, int b)\\n{\\n    return (a / gcd(a, b)) * b;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long med=1, end, beg;\\n        beg=1; end=2*1e9;\\n        \\n        while(beg<=end){\\n            med=(beg + end)/2;\\n            long long fk=uglyNumsLessThanK(med,a,b,c);\\n            if(fk==n){\\n                cout<<med;\\n                break;\\n            }\\n            else if(n<fk){\\n                end=med-1;\\n            }\\n            else{\\n                beg=med+1;\\n            }\\n        }\\n        \\n        \\n                long long c1=med/a*a, c2=med/b*b, c3=med/c*c;\\n                long long max=0;\\n                max=c1>c2?c1:c2;\\n                max=max>c3?max:c3;\\n                return (int)max; \\n    }\\n    \\n    long long uglyNumsLessThanK(long long k, int a, int b, int c){\\n        int lcm12=lcm(a,b);\\n        long long c1=k/a, c2=k/b, c3=k/c, c12=k/lcm12, c13=k/lcm(a,c), c23=k/lcm(b,c), c123=k/lcm(lcm12,c);\\n        \\n        return c1+c2+c3-c12-c13-c23+c123;\\n    }\\n    \\n    long long gcd(long long int a, long long int b)\\n{\\n  if (b == 0)\\n    return a;\\n  return gcd(b, a % b);\\n}\\n \\n// Function to return LCM of two numbers\\nlong long lcm(int a, int b)\\n{\\n    return (a / gcd(a, b)) * b;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2402964,
                "title": "leetcode-the-hard-way-inclusive-exclusive-binary-search",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int ok(long long n, long long a, long long b, long long c) {\\n        // numbers (1 to n) divisble by a = n / a\\n        // numbers (1 to n) divisble by b = n / b\\n        // numbers (1 to n) divisble by c = n / c\\n        // exclude overlapping counts for a and b = n / lcm(a, b)\\n        // exclude overlapping counts for b and c = n / lcm(b, c)\\n        // exclude overlapping counts for a and c = n / lcm(a, c)\\n        // include those covered by all a, b and c = n / lcm(a, lcm(b, c))  \\n        \\n        // Set theory Formula: \\n        // a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n        return (int) n / a + n / b + n / c \\n        - n / lcm(a, b)\\n        - n / lcm(b, c)\\n        - n / lcm(a, c)\\n        + n / lcm(a, lcm(b, c));\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        // init possible range [1, 2 * 10 ^ 9]\\n        int l = 1, r = 2e9;\\n        while (l < r) {\\n            // get the middle one\\n            // for even number of elements, take the lower one\\n            int m = l + (r - l) / 2;\\n            // exclude m\\n            if (n > ok(m, a, b, c)) l = m + 1;\\n            // include m\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int ok(long long n, long long a, long long b, long long c) {\\n        // numbers (1 to n) divisble by a = n / a\\n        // numbers (1 to n) divisble by b = n / b\\n        // numbers (1 to n) divisble by c = n / c\\n        // exclude overlapping counts for a and b = n / lcm(a, b)\\n        // exclude overlapping counts for b and c = n / lcm(b, c)\\n        // exclude overlapping counts for a and c = n / lcm(a, c)\\n        // include those covered by all a, b and c = n / lcm(a, lcm(b, c))  \\n        \\n        // Set theory Formula: \\n        // a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n        return (int) n / a + n / b + n / c \\n        - n / lcm(a, b)\\n        - n / lcm(b, c)\\n        - n / lcm(a, c)\\n        + n / lcm(a, lcm(b, c));\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        // init possible range [1, 2 * 10 ^ 9]\\n        int l = 1, r = 2e9;\\n        while (l < r) {\\n            // get the middle one\\n            // for even number of elements, take the lower one\\n            int m = l + (r - l) / 2;\\n            // exclude m\\n            if (n > ok(m, a, b, c)) l = m + 1;\\n            // include m\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147013,
                "title": "java-solution-binary-search-maths",
                "content": "**This solution is nothing but based on the formula maths derivation show below:** \\n\\n*1.n(AUBUC) = n(A)+n(B)+n(C)-n(A\\u2229B)-n(A\\u2229C)-n(B\\u2229C)+n(A\\u2229B\\u2229C).*\\n\\n*2. n(A)=mid/a similarly n(B)=mid/b and n(C)=mid/c .* \\n\\n*3.n(A\\u2229B)=mid/lcm(a,b) similarly n(A\\u2229C)=mid/lcm(a,c) and n(B\\u2229C)=mid/lcm(b,c)*\\n\\n*4.n(A\\u2229B\\u2229C)=mid/lcm(a,lcm(b,c)) by the help of this above illustrations we will apply the binary searching* \\n*algorithm and find out the ugly number for the given number for this problem.*\\n\\n**TC-O(log(n * min(a, b, c)))\\nSC-O(1)**\\n\\n class Solution {\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int start=1;\\n        int end=Integer.MAX_VALUE;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if(isUgly(mid,a,b,c,n)){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n    public boolean isUgly(long mid,long a,long b,long c,long n){\\n        return (int)(mid/a+mid/b+mid/c-mid/lcm(a,b)-mid/lcm(b,c)-mid/lcm(c,a)+mid/lcm(a,lcm(b,c)))>=n;\\n    }\\n    public long gcd(long m,long n){\\n          if(m==0)\\n              return n;\\n        else\\n            return gcd(n%m,m);\\n    }\\n    public long lcm(long m,long n){\\n       return m*n/(gcd(m,n));\\n    }\\n}",
                "solutionTags": [
                    "Math",
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int start=1;\\n        int end=Integer.MAX_VALUE;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if(isUgly(mid,a,b,c,n)){\\n                end=mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2105407,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long lla = (long long)a;\\n        long long llb = (long long)b;\\n        long long llc = (long long)c;\\n        \\n        // function f(k) to determine how many ugly numbers smaller than k.\\n        // f(k) is non-decreasing.\\n        auto f = [](long long k, long long a, long long b, long long c) {\\n            return k/a + k/b + k/c - k/lcm(a, b) - k/lcm(b, c) - k/lcm(a, c) + k/lcm(a, lcm(b, c));\\n        };\\n        \\n        int lo = 1, hi = 2 * 1e9;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo) / 2;\\n            \\n            int num = f(mid, lla, llb, llc);\\n            \\n            if (num < n) {\\n                lo = mid + 1;\\n            }\\n            else if (num > n) {\\n                hi = mid - 1;\\n            }\\n            else {\\n                hi = mid;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long lla = (long long)a;\\n        long long llb = (long long)b;\\n        long long llc = (long long)c;\\n        \\n        // function f(k) to determine how many ugly numbers smaller than k.\\n        // f(k) is non-decreasing.\\n        auto f = [](long long k, long long a, long long b, long long c) {\\n            return k/a + k/b + k/c - k/lcm(a, b) - k/lcm(b, c) - k/lcm(a, c) + k/lcm(a, lcm(b, c));\\n        };\\n        \\n        int lo = 1, hi = 2 * 1e9;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo) / 2;\\n            \\n            int num = f(mid, lla, llb, llc);\\n            \\n            if (num < n) {\\n                lo = mid + 1;\\n            }\\n            else if (num > n) {\\n                hi = mid - 1;\\n            }\\n            else {\\n                hi = mid;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063707,
                "title": "python3-binary-search",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        lcm_ab = a * b // math.gcd(a, b)\\n        lcm_ac = a * c // math.gcd(a, c)\\n        lcm_bc = b * c // math.gcd(b, c)\\n        lcm_abc = a * lcm_bc // math.gcd(a, lcm_bc)\\n    \\n        def isEnough(num):\\n            cnt = num // a + num // b + num // c \\\\\\n                    - num // lcm_ab - num // lcm_ac - num // lcm_bc \\\\\\n                    + num // lcm_abc\\n            return cnt >= n\\n            \\n        left, right = 1, 10**10\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isEnough(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        lcm_ab = a * b // math.gcd(a, b)\\n        lcm_ac = a * c // math.gcd(a, c)\\n        lcm_bc = b * c // math.gcd(b, c)\\n        lcm_abc = a * lcm_bc // math.gcd(a, lcm_bc)\\n    \\n        def isEnough(num):\\n            cnt = num // a + num // b + num // c \\\\\\n                    - num // lcm_ab - num // lcm_ac - num // lcm_bc \\\\\\n                    + num // lcm_abc\\n            return cnt >= n\\n            \\n        left, right = 1, 10**10\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isEnough(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919652,
                "title": "illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/82574c8a-c4f6-4274-b32f-c86a74c59f47_1649247475.906736.png)\\n\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S\"\"\"\\n        fn = lambda x: x // a + x // b + x // c - x // math.lcm(a, b) - x // math.lcm(a, c) - x // math.lcm(b, c) + x // math.lcm(a, b, c) >= n\\n        return bisect.bisect_left(range(10 ** 10), True, 1, key=fn)",
                "solutionTags": [
                    "Python"
                ],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/82574c8a-c4f6-4274-b32f-c86a74c59f47_1649247475.906736.png)\\n\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S\"\"\"\\n        fn = lambda x: x // a + x // b + x // c - x // math.lcm(a, b) - x // math.lcm(a, c) - x // math.lcm(b, c) + x // math.lcm(a, b, c) >= n\\n        return bisect.bisect_left(range(10 ** 10), True, 1, key=fn)",
                "codeTag": "Python3"
            },
            {
                "id": 1873045,
                "title": "c-binary-search-100-faster-ugly-number",
                "content": "```\\n long long int mini(long long int a,long long int b,long long int c){\\n        if(a<b && a<c)\\n            return a;\\n        else if(b<c)\\n            return b;\\n        else\\n            return c;\\n    }\\n    long long int fun(long long int n,long long int a,long long int b,long long int c){\\n        long long int lcm1=(a*b)/__gcd(a,b);\\n        long long int lcm2=(b*c)/__gcd(b,c);\\n        long long int lcm3=(a*c)/__gcd(a,c);\\n        long long int lcm=(lcm1*c)/__gcd(lcm1,c);\\n        return (n/a+n/b+n/c-n/lcm1-n/lcm2-n/lcm3+n/lcm);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n       long long int low=mini(a,b,c);\\n        long long int high=1e18;\\n        while(low<=high){\\n            long long int mid=low+((high-low)/2);\\n            long long int count=fun(mid,a,b,c);\\n            if(count==n){\\n                long long int count1=fun(mid-1,a,b,c);\\n                if(count1!=n)\\n                    return mid;\\n                else high=mid-1;\\n            }\\n            else if(count>n)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n long long int mini(long long int a,long long int b,long long int c){\\n        if(a<b && a<c)\\n            return a;\\n        else if(b<c)\\n            return b;\\n        else\\n            return c;\\n    }\\n    long long int fun(long long int n,long long int a,long long int b,long long int c){\\n        long long int lcm1=(a*b)/__gcd(a,b);\\n        long long int lcm2=(b*c)/__gcd(b,c);\\n        long long int lcm3=(a*c)/__gcd(a,c);\\n        long long int lcm=(lcm1*c)/__gcd(lcm1,c);\\n        return (n/a+n/b+n/c-n/lcm1-n/lcm2-n/lcm3+n/lcm);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n       long long int low=mini(a,b,c);\\n        long long int high=1e18;\\n        while(low<=high){\\n            long long int mid=low+((high-low)/2);\\n            long long int count=fun(mid,a,b,c);\\n            if(count==n){\\n                long long int count1=fun(mid-1,a,b,c);\\n                if(count1!=n)\\n                    return mid;\\n                else high=mid-1;\\n            }\\n            else if(count>n)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1708753,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long lcm(long long n1, long long n2) {\\n        return n1 * n2 / __gcd(n1, n2);\\n    }\\n       \\n    bool enough(long long x, int n, int a, int b, int c) {\\n        long long cnt = x/a + x/b + x/c - x/lcm(a, b) - x/lcm(b, c) - x/lcm(a, c) + x/lcm(a, lcm(b, c));\\n        return cnt >= n;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long lo = 1;\\n        long long hi = 2e9;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo) / 2;\\n            if (enough(mid, n, a, b, c))\\n                hi = mid;\\n            else\\n                lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long lcm(long long n1, long long n2) {\\n        return n1 * n2 / __gcd(n1, n2);\\n    }\\n       \\n    bool enough(long long x, int n, int a, int b, int c) {\\n        long long cnt = x/a + x/b + x/c - x/lcm(a, b) - x/lcm(b, c) - x/lcm(a, c) + x/lcm(a, lcm(b, c));\\n        return cnt >= n;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long lo = 1;\\n        long long hi = 2e9;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo) / 2;\\n            if (enough(mid, n, a, b, c))\\n                hi = mid;\\n            else\\n                lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662661,
                "title": "100-faster-easy-to-understand-c-code",
                "content": "* ******Using Binary Search******\\n\\n1. ***Time Complexity : O(log(size of integer variable))***\\n2. ***Space Complexity : O(1)***\\n\\n```\\nlong long lcm(long long a, long long b)\\n    {\\n        return (a * b) / __gcd(a, b) ;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long low = 1;\\n        \\n        long long high = INT_MAX;\\n        \\n        while(low <= high)\\n        {\\n            long long mid = (low + high) / 2 ;\\n            \\n            long long nth_ugly = mid / a + mid / b + mid / c - mid / (lcm(a, b)) - mid / (lcm(b, c)) - mid / (lcm(c, a)) + mid / (lcm(a, lcm(b, c))) ;\\n            \\n            if(nth_ugly >= n)\\n                high = mid - 1 ;\\n            \\n            else if(nth_ugly < n)\\n            {\\n                low = mid + 1 ;\\n            }  \\n        }\\n        \\n        return low;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nlong long lcm(long long a, long long b)\\n    {\\n        return (a * b) / __gcd(a, b) ;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long low = 1;\\n        \\n        long long high = INT_MAX;\\n        \\n        while(low <= high)\\n        {\\n            long long mid = (low + high) / 2 ;\\n            \\n            long long nth_ugly = mid / a + mid / b + mid / c - mid / (lcm(a, b)) - mid / (lcm(b, c)) - mid / (lcm(c, a)) + mid / (lcm(a, lcm(b, c))) ;\\n            \\n            if(nth_ugly >= n)\\n                high = mid - 1 ;\\n            \\n            else if(nth_ugly < n)\\n            {\\n                low = mid + 1 ;\\n            }  \\n        }\\n        \\n        return low;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499626,
                "title": "javascript-binary-search-solution",
                "content": "**Complexity**\\nTime: O(log(MAX_ANS)), MAX_ANS = 2*10^9\\nSpace: O(1)\\n\\n```\\n/**\\n * @param {number} n\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar nthUglyNumber = function (n, a, b, c) {\\n  const ab = lcm(a, b);\\n  const bc = lcm(b, c);\\n  const ac = lcm(a, c);\\n  const abc = lcm(ab, c);\\n\\n  const f = (num) => Math.floor(num);\\n  const getUglyNumberCount = (k) => {\\n    return (\\n      f(k / a) +\\n      f(k / b) +\\n      f(k / c) -\\n      f(k / ab) -\\n      f(k / ac) -\\n      f(k / bc) +\\n      f(k / abc)\\n    );\\n  };\\n\\n  let start = n;\\n  let end = n * Math.min(a, b, c);\\n  let boundaryIndex = end;\\n\\n  while (start <= end) {\\n    const mid = Math.floor((end - start) / 2) + start;\\n    if (getUglyNumberCount(mid) < n) {\\n      start = mid + 1;\\n    } else {\\n      boundaryIndex = mid;\\n      end = mid - 1;\\n    }\\n  }\\n\\n  return boundaryIndex;\\n};\\n\\nconst lcm = (a, b) => {\\n  return (a * b) / gcd(a, b);\\n};\\n\\nconst gcd = function (a, b) {\\n  if (b === 0) return a;\\n  return gcd(b, a % b);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar nthUglyNumber = function (n, a, b, c) {\\n  const ab = lcm(a, b);\\n  const bc = lcm(b, c);\\n  const ac = lcm(a, c);\\n  const abc = lcm(ab, c);\\n\\n  const f = (num) => Math.floor(num);\\n  const getUglyNumberCount = (k) => {\\n    return (\\n      f(k / a) +\\n      f(k / b) +\\n      f(k / c) -\\n      f(k / ab) -\\n      f(k / ac) -\\n      f(k / bc) +\\n      f(k / abc)\\n    );\\n  };\\n\\n  let start = n;\\n  let end = n * Math.min(a, b, c);\\n  let boundaryIndex = end;\\n\\n  while (start <= end) {\\n    const mid = Math.floor((end - start) / 2) + start;\\n    if (getUglyNumberCount(mid) < n) {\\n      start = mid + 1;\\n    } else {\\n      boundaryIndex = mid;\\n      end = mid - 1;\\n    }\\n  }\\n\\n  return boundaryIndex;\\n};\\n\\nconst lcm = (a, b) => {\\n  return (a * b) / gcd(a, b);\\n};\\n\\nconst gcd = function (a, b) {\\n  if (b === 0) return a;\\n  return gcd(b, a % b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1434654,
                "title": "c-binary-search-100-faster",
                "content": "```\\n#define ll long long int\\n#define gcd(a,b) __gcd(a,b)\\nclass Solution {\\npublic:\\n    //note : x / a => give no of int devisible by \\'a\\' from 1 to x.\\n    ll HowManyUglyTill(ll x,ll a,ll b,ll c)\\n    {\\n        ll lcm_ab = (a * b) / gcd(a,b);\\n        ll lcm_bc = (b * c) / gcd(b,c);\\n        ll lcm_ca = (c * a) / gcd(c,a);\\n        ll lcm_abc = (lcm_ab  * c) / gcd(lcm_ab,c);\\n                                    \\n        return (x / a) + (x / b) + (x / c) - (x / lcm_ab) - (x / lcm_bc) - (x / lcm_ca) + (x / lcm_abc);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll ans = -1;\\n        ll beg = 1,end = 2 * 1e9;\\n        while(beg <= end)\\n        {\\n            ll mid = (beg + end) / 2;\\n            ll now = HowManyUglyTill(mid,a,b,c);\\n            \\n            if(now >= n)\\n            {\\n                if((mid % a == 0) || (mid % b == 0) || (mid % c == 0)) \\n                    ans = mid;\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n#define gcd(a,b) __gcd(a,b)\\nclass Solution {\\npublic:\\n    //note : x / a => give no of int devisible by \\'a\\' from 1 to x.\\n    ll HowManyUglyTill(ll x,ll a,ll b,ll c)\\n    {\\n        ll lcm_ab = (a * b) / gcd(a,b);\\n        ll lcm_bc = (b * c) / gcd(b,c);\\n        ll lcm_ca = (c * a) / gcd(c,a);\\n        ll lcm_abc = (lcm_ab  * c) / gcd(lcm_ab,c);\\n                                    \\n        return (x / a) + (x / b) + (x / c) - (x / lcm_ab) - (x / lcm_bc) - (x / lcm_ca) + (x / lcm_abc);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll ans = -1;\\n        ll beg = 1,end = 2 * 1e9;\\n        while(beg <= end)\\n        {\\n            ll mid = (beg + end) / 2;\\n            ll now = HowManyUglyTill(mid,a,b,c);\\n            \\n            if(now >= n)\\n            {\\n                if((mid % a == 0) || (mid % b == 0) || (mid % c == 0)) \\n                    ans = mid;\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275018,
                "title": "c-binary-search-faster-than-100",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll lcm(ll a,ll b){\\n        return (a*b)/(__gcd(a,b));\\n    }\\n    ll uglyhelper(ll m,ll a,ll b,ll c){\\n        return m/a+m/b+m/c-(m/lcm(a,b))-(m/lcm(b,c))-(m/lcm(a,c))+(m/lcm(a,lcm(b,c)));\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll l=1;\\n        ll h=2*1000000000;\\n        while(l<=h){\\n            ll mid=(l+h)/2;\\n            ll cnt=uglyhelper(mid,a,b,c);\\n            if(cnt<n){\\n                l=mid+1;\\n            }\\n            else if(cnt>=n){\\n                if(uglyhelper(mid-1,a,b,c)<n){\\n                    return mid;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll lcm(ll a,ll b){\\n        return (a*b)/(__gcd(a,b));\\n    }\\n    ll uglyhelper(ll m,ll a,ll b,ll c){\\n        return m/a+m/b+m/c-(m/lcm(a,b))-(m/lcm(b,c))-(m/lcm(a,c))+(m/lcm(a,lcm(b,c)));\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll l=1;\\n        ll h=2*1000000000;\\n        while(l<=h){\\n            ll mid=(l+h)/2;\\n            ll cnt=uglyhelper(mid,a,b,c);\\n            if(cnt<n){\\n                l=mid+1;\\n            }\\n            else if(cnt>=n){\\n                if(uglyhelper(mid-1,a,b,c)<n){\\n                    return mid;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180051,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // \\u8FD4\\u56DE\\u4E0D\\u5927\\u4E8Em\\u7684ugly number\\n    long long numOfUglyNumberWithUpperLimit(long m, long a, long b, long c) {\\n        long long lcm_ab = std::lcm(a, b);\\n        long long lcm_ac = std::lcm(a, c);\\n        long long lcm_bc = std::lcm(b, c);\\n        long long lcm_abc = std::lcm(a, std::lcm(b, c));\\n        return (m / a + m / b + m / c - m / lcm_ab - m / lcm_ac - m / lcm_bc + m / lcm_abc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l = 1;\\n        long long u = 2 * 1e9;\\n        while (l <= u) {\\n            long long m = (l + u) / 2;\\n            if (numOfUglyNumberWithUpperLimit(m, a, b, c) >= n) {\\n                u = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return (int)l;\\n    }\\n};\\n```\\n1. C++\\u6709\\u6807\\u51C6\\u5E93\\u51FD\\u6570\\u53EF\\u4EE5\\u7528\\u6765\\u6C42\\u89E3\\u6700\\u5C0F\\u516C\\u500D\\u6570\\uFF0Cstd::lcm\\uFF0C\\u5BF9\\u5E94\\u7684\\u5934\\u6587\\u4EF6\\u662F#include <numeric>\\n2. \\u4E0D\\u5927\\u4E8Em\\u7684\\u548Ca, b, c\\u76F8\\u5173\\u7684ugly number\\u662F(m/a + m/b + m/c - m/lcm(a, b) - m/lcm(a, c) - m/lcm(b, c) + m/lcm(a, lcm(b, c)));\\n3. \\u7528\\u4E8C\\u5206\\u6CD5\\u6C42\\u89E3\\uFF0C\\u8FB9\\u754C\\u95EE\\u9898\\u6211\\u8FD8\\u9700\\u8981\\u5B66\\u4E60",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // \\u8FD4\\u56DE\\u4E0D\\u5927\\u4E8Em\\u7684ugly number\\n    long long numOfUglyNumberWithUpperLimit(long m, long a, long b, long c) {\\n        long long lcm_ab = std::lcm(a, b);\\n        long long lcm_ac = std::lcm(a, c);\\n        long long lcm_bc = std::lcm(b, c);\\n        long long lcm_abc = std::lcm(a, std::lcm(b, c));\\n        return (m / a + m / b + m / c - m / lcm_ab - m / lcm_ac - m / lcm_bc + m / lcm_abc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l = 1;\\n        long long u = 2 * 1e9;\\n        while (l <= u) {\\n            long long m = (l + u) / 2;\\n            if (numOfUglyNumberWithUpperLimit(m, a, b, c) >= n) {\\n                u = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return (int)l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068074,
                "title": "simple-maths-union-inersection-lcm-python3-solution",
                "content": "formula:-\\na U b U c = a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(x,y):\\n            if x==0:\\n                return y\\n            return gcd(y%x,x)\\n        def lcm(a,b):\\n            return (a*b)//gcd(a,b)\\n        res=0\\n        l=min(a,b,c)\\n        r=10**18\\n        while(l<=r):\\n            m=l+(r-l)//2\\n            s=0\\n            s=s+((m//a)+(m//b)+(m//c))\\n            s-=(m//lcm(a,b))\\n            s-=(m//lcm(a,c))\\n            s-=(m//lcm(b,c))\\n            x=lcm(a,b)\\n            s+=(m//lcm(x,c))\\n            if s>=n:\\n                res = m\\n                r=m-1\\n            else:\\n                l=m+1\\n        return res",
                "solutionTags": [],
                "code": "formula:-\\na U b U c = a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(x,y):\\n            if x==0:\\n                return y\\n            return gcd(y%x,x)\\n        def lcm(a,b):\\n            return (a*b)//gcd(a,b)\\n        res=0\\n        l=min(a,b,c)\\n        r=10**18\\n        while(l<=r):\\n            m=l+(r-l)//2\\n            s=0\\n            s=s+((m//a)+(m//b)+(m//c))\\n            s-=(m//lcm(a,b))\\n            s-=(m//lcm(a,c))\\n            s-=(m//lcm(b,c))\\n            x=lcm(a,b)\\n            s+=(m//lcm(x,c))\\n            if s>=n:\\n                res = m\\n                r=m-1\\n            else:\\n                l=m+1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1021129,
                "title": "c-binary-search-and-math-solution-0ms",
                "content": "Run-time is `O(loga + logb + logc)`, space is `O(1)`. Idea is to realize that the `nth` number must be a multiple of `a`, `b`, or `c`, so we can run binary search for that multiple value using `a`, `b`, and `c`, since one of them must work. Each search we are checking to see if the number of multiples of `a`, `b`, and `c` less than or equal to `a*mid` is equal to `n`. If it is, then`a*mid` is the solution. \\n\\nTo do this problem correctly, math is needed to use the inclusion-exclusion principle to not double-count multiples of more than 1 of `a`, `b`, or `c`. Also, the knowledge that `LCM(a,b) = a*b/gcd(a,b)` and `LCM(a,b,c) = LCM(a,b)*c/gcd(LCM(a,b),c)` is needed to count number of multiples of some combination of numbers. \\n\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(c == a || c == b) {\\n            if(b == a) return a*n;\\n            int res{search2(n,a,b)};\\n            if(res) return res;\\n            return search2(n,b,a);\\n        }\\n        int res{search3(n,a,b,c)};\\n        if(res) return res;\\n        res = search3(n,b,a,c);\\n        if(res) return res;\\n        res = search3(n,c,a,b);\\n        if(res) return res;\\n        return 0;\\n    }\\n    \\n    int search3(int n, int a, int b, int c) {\\n        int64_t lo{0}, hi{(int64_t)n}, mid, det, ab{(int64_t)a*b/gcd(a,b)}, ac{(int64_t)a*c/gcd(a,c)}, bc{(int64_t)b*c/gcd(b,c)}, abc{(int64_t)ab*c/gcd(ab,c)};\\n        while(lo <= hi) {\\n            mid = (lo+hi)>>1, det = mid + (a*mid-1)/b + (a*mid-1)/c - (a*mid-1)/ab - (a*mid-1)/ac - (a*mid-1)/bc + (a*mid-1)/abc;\\n            if(det == n) return mid*a;\\n            else if(det > n) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return 0;\\n    }\\n    \\n    int search2(int n, int a, int b) {\\n        int64_t lo{0}, hi{(int64_t)n}, mid, det, ab{(int64_t)a*b/gcd(a,b)};\\n        while(lo <= hi) {\\n            mid = (lo+hi)>>1, det = mid + (a*mid-1)/b - (a*mid-1)/(ab);\\n            if(det == n) return mid*a;\\n            else if(det > n) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(c == a || c == b) {\\n            if(b == a) return a*n;\\n            int res{search2(n,a,b)};\\n            if(res) return res;\\n            return search2(n,b,a);\\n        }\\n        int res{search3(n,a,b,c)};\\n        if(res) return res;\\n        res = search3(n,b,a,c);\\n        if(res) return res;\\n        res = search3(n,c,a,b);\\n        if(res) return res;\\n        return 0;\\n    }\\n    \\n    int search3(int n, int a, int b, int c) {\\n        int64_t lo{0}, hi{(int64_t)n}, mid, det, ab{(int64_t)a*b/gcd(a,b)}, ac{(int64_t)a*c/gcd(a,c)}, bc{(int64_t)b*c/gcd(b,c)}, abc{(int64_t)ab*c/gcd(ab,c)};\\n        while(lo <= hi) {\\n            mid = (lo+hi)>>1, det = mid + (a*mid-1)/b + (a*mid-1)/c - (a*mid-1)/ab - (a*mid-1)/ac - (a*mid-1)/bc + (a*mid-1)/abc;\\n            if(det == n) return mid*a;\\n            else if(det > n) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return 0;\\n    }\\n    \\n    int search2(int n, int a, int b) {\\n        int64_t lo{0}, hi{(int64_t)n}, mid, det, ab{(int64_t)a*b/gcd(a,b)};\\n        while(lo <= hi) {\\n            mid = (lo+hi)>>1, det = mid + (a*mid-1)/b - (a*mid-1)/(ab);\\n            if(det == n) return mid*a;\\n            else if(det > n) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926706,
                "title": "the-best-solution-ever",
                "content": "The main idea of my solution is to calculate the maximum possible value for n-th ugly number which is obviously min(a, b, c) * n. Then we have to determine the index of this value in the sequence of ugly numbers. After that is is easy to iterate backwards by the ugly number sequence until we reach n-th entry.\\n\\n```\\nclass Solution {\\n    \\n\\t//Helper structure\\n    struct Divisor{\\n\\n        let value : Int\\n        var top : Int\\n\\n    }\\n    \\n    func nthUglyNumber(_ n: Int, _ aVal: Int, _ bVal: Int, _ cVal: Int) -> Int {\\n\\n\\t\\t//Make sure a <= b <= c\\n        let orderedParams = [aVal, bVal, cVal].sorted()\\n        let a = orderedParams[0]\\n        let b = orderedParams[1]\\n        let c = orderedParams[2]\\n\\n\\t\\t//Maximum value for n-th ugly number is the min(a, b, c) * n\\n        let aTop = a * n //Maximum value\\n        let bTop = (aTop / b) * b\\n        let cTop = (aTop / c) * c\\n\\n\\t\\t//Calculate the number of multiples of b which are not divisible by a.\\n\\t\\t//Here we get the number of ugly sequence entries which arised only due to b factor\\n        var bUniqueEntrys = 0\\n        var bSteps = aTop / b\\n        if bSteps >= 1{\\n            for i in 1...bSteps{\\n                let value = (b * i)\\n                if !value.isMultiple(of: a){\\n                    bUniqueEntrys += 1\\n                }\\n            }\\n        }\\n\\n\\t\\t//Calculate the number of multiples of c which are not divisible by b and a.\\n\\t\\t//Here we get the number of ugly sequence entries which arised only due to c factor     \\n        var cUniqueEntrys = 0\\n        var cSteps = aTop / c\\n        if cSteps >= 1{    \\n            for i in 1...cSteps{\\n                let value = (c * i)\\n                if !value.isMultiple(of: b) && !value.isMultiple(of: a){\\n                    cUniqueEntrys += 1\\n                }\\n            }\\n        }\\n\\n        //This is an index of ugly number which value is a * n\\n        var index = n + bUniqueEntrys + cUniqueEntrys\\n\\n        var divisors = [Divisor(value: a, top: aTop), Divisor(value: b, top: bTop), Divisor(value: c, top: cTop)]\\n        var currentValue = aTop\\n\\t\\t\\n\\t\\t//Next we iterate backwards from an index of maximum possible value down to n-th value\\n        while index > n {\\n\\n            let maxValue = max(max(divisors[0].top, divisors[1].top), divisors[2].top)\\n            for i in 0..<divisors.count{\\n                if divisors[i].top == maxValue{\\n                    divisors[i].top = divisors[i].top - divisors[i].value\\n                }\\n            }\\n            index -= 1\\n\\n        }\\n\\n        return max(max(divisors[0].top, divisors[1].top), divisors[2].top)\\n        \\n    }\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n\\t//Helper structure\\n    struct Divisor{\\n\\n        let value : Int\\n        var top : Int\\n\\n    }\\n    \\n    func nthUglyNumber(_ n: Int, _ aVal: Int, _ bVal: Int, _ cVal: Int) -> Int {\\n\\n\\t\\t//Make sure a <= b <= c\\n        let orderedParams = [aVal, bVal, cVal].sorted()\\n        let a = orderedParams[0]\\n        let b = orderedParams[1]\\n        let c = orderedParams[2]\\n\\n\\t\\t//Maximum value for n-th ugly number is the min(a, b, c) * n\\n        let aTop = a * n //Maximum value\\n        let bTop = (aTop / b) * b\\n        let cTop = (aTop / c) * c\\n\\n\\t\\t//Calculate the number of multiples of b which are not divisible by a.\\n\\t\\t//Here we get the number of ugly sequence entries which arised only due to b factor\\n        var bUniqueEntrys = 0\\n        var bSteps = aTop / b\\n        if bSteps >= 1{\\n            for i in 1...bSteps{\\n                let value = (b * i)\\n                if !value.isMultiple(of: a){\\n                    bUniqueEntrys += 1\\n                }\\n            }\\n        }\\n\\n\\t\\t//Calculate the number of multiples of c which are not divisible by b and a.\\n\\t\\t//Here we get the number of ugly sequence entries which arised only due to c factor     \\n        var cUniqueEntrys = 0\\n        var cSteps = aTop / c\\n        if cSteps >= 1{    \\n            for i in 1...cSteps{\\n                let value = (c * i)\\n                if !value.isMultiple(of: b) && !value.isMultiple(of: a){\\n                    cUniqueEntrys += 1\\n                }\\n            }\\n        }\\n\\n        //This is an index of ugly number which value is a * n\\n        var index = n + bUniqueEntrys + cUniqueEntrys\\n\\n        var divisors = [Divisor(value: a, top: aTop), Divisor(value: b, top: bTop), Divisor(value: c, top: cTop)]\\n        var currentValue = aTop\\n\\t\\t\\n\\t\\t//Next we iterate backwards from an index of maximum possible value down to n-th value\\n        while index > n {\\n\\n            let maxValue = max(max(divisors[0].top, divisors[1].top), divisors[2].top)\\n            for i in 0..<divisors.count{\\n                if divisors[i].top == maxValue{\\n                    divisors[i].top = divisors[i].top - divisors[i].value\\n                }\\n            }\\n            index -= 1\\n\\n        }\\n\\n        return max(max(divisors[0].top, divisors[1].top), divisors[2].top)\\n        \\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902383,
                "title": "java-0ms-o-logn-using-lcm",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int ab = lcm(a,b);\\n        int bc = lcm(b,c);\\n        int ca = lcm(c,a);\\n        int abc = lcm(ab,c);\\n        \\n        int s = 1, e = 2000000000, m;\\n        int x;\\n        while(s<e){\\n            m = s/2 + e/2 +(s%2+e%2)/2;\\n            x = m/a + m/b + m/c - m/ab - m/bc - m/ca + m/abc;\\n            if(x>=n) e=m;\\n            else s=m+1;\\n        }\\n        \\n        return s;\\n    }\\n    \\n    public int lcm(int a, int b){\\n        if(a==Integer.MAX_VALUE || b==Integer.MAX_VALUE)return Integer.MAX_VALUE;\\n        int gcd = gcd(a, b);\\n        if(Integer.MAX_VALUE / (a/gcd) < b)return Integer.MAX_VALUE;\\n        return a / gcd * b;\\n    }\\n    \\n    public int gcd(int a, int b){\\n        if(b==0)return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int ab = lcm(a,b);\\n        int bc = lcm(b,c);\\n        int ca = lcm(c,a);\\n        int abc = lcm(ab,c);\\n        \\n        int s = 1, e = 2000000000, m;\\n        int x;\\n        while(s<e){\\n            m = s/2 + e/2 +(s%2+e%2)/2;\\n            x = m/a + m/b + m/c - m/ab - m/bc - m/ca + m/abc;\\n            if(x>=n) e=m;\\n            else s=m+1;\\n        }\\n        \\n        return s;\\n    }\\n    \\n    public int lcm(int a, int b){\\n        if(a==Integer.MAX_VALUE || b==Integer.MAX_VALUE)return Integer.MAX_VALUE;\\n        int gcd = gcd(a, b);\\n        if(Integer.MAX_VALUE / (a/gcd) < b)return Integer.MAX_VALUE;\\n        return a / gcd * b;\\n    }\\n    \\n    public int gcd(int a, int b){\\n        if(b==0)return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796719,
                "title": "java-100-faster-binary-search",
                "content": "\\nUgly numbers are positive integers which are divisible by a or b or c.\\n\\n**Solution 1**\\nFirst n ugly numbers.\\nRuntime complexity - O(N)\\nSpace - constant\\n**Note** : this solution failed with TLE  \\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long am = 1, bm = 1, cm = 1, cnt = 0, min = 1;\\n        while (cnt++ < n) {\\n            long an = am * a, bn = bm * b, cn = cm * c;\\n            min = Math.min(an, Math.min(bn, cn));\\n            if (an == min) am++;\\n            if (bn == min) bm++;\\n            if (cn == min) cm++;\\n        }\\n        return (int)min;\\n    }\\n}\\n```\\n\\n**Solution 2**\\n\\nSince we have to find only **n th** ugly number, it is not required to find all the first n ugly numbers.\\n\\nWe can find the nth ugly number using binary search. \\nCondition - keep checking the count of ugly numbers less **n**. \\n\\nRuntime complexity - O(Log(N))\\nSpace - constant\\n\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long lo = Math.min(a,Math.min(b,c));\\n        long hi = lo*n;\\n        while(lo<hi){\\n            long mid = lo+(hi-lo)/2;\\n            if(count(a,b,c,mid)>=n) hi=mid;\\n            else lo=mid+1;\\n        } \\n        return (int)lo;\\n    }\\n    \\n\\t//total number of ugly numbers less than **mid**\\n    public long count(int a,int b,int c,long mid){\\n\\t   //remove multiples lcm(a,b),  lcm(b,c),  lcm(c,a) - since they are counted twice.  add multiples of lcm(a,b,c);\\n\\t   // mid/a - > contains count including -> mid/lcm(a,b)+mid/lcm(a,c)+mid/lcm(a,b,c) , similarly for b and c\\n        return mid/a+mid/b+mid/c-mid/lcm(a,b)-mid/lcm(b,c)-mid/lcm(a,c)+mid/lcm(lcm(a,b),c);\\n    }\\n    \\n    private long lcm(long a,long b){\\n        return a*b/gcd(a,b);\\n    }\\n    private long gcd(long a,long b){\\n        if(b==0) return a;\\n        if(a<b) return gcd(b,a);\\n        return gcd(a%b,b);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long am = 1, bm = 1, cm = 1, cnt = 0, min = 1;\\n        while (cnt++ < n) {\\n            long an = am * a, bn = bm * b, cn = cm * c;\\n            min = Math.min(an, Math.min(bn, cn));\\n            if (an == min) am++;\\n            if (bn == min) bm++;\\n            if (cn == min) cm++;\\n        }\\n        return (int)min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long lo = Math.min(a,Math.min(b,c));\\n        long hi = lo*n;\\n        while(lo<hi){\\n            long mid = lo+(hi-lo)/2;\\n            if(count(a,b,c,mid)>=n) hi=mid;\\n            else lo=mid+1;\\n        } \\n        return (int)lo;\\n    }\\n    \\n\\t//total number of ugly numbers less than **mid**\\n    public long count(int a,int b,int c,long mid){\\n\\t   //remove multiples lcm(a,b),  lcm(b,c),  lcm(c,a) - since they are counted twice.  add multiples of lcm(a,b,c);\\n\\t   // mid/a - > contains count including -> mid/lcm(a,b)+mid/lcm(a,c)+mid/lcm(a,b,c) , similarly for b and c\\n        return mid/a+mid/b+mid/c-mid/lcm(a,b)-mid/lcm(b,c)-mid/lcm(a,c)+mid/lcm(lcm(a,b),c);\\n    }\\n    \\n    private long lcm(long a,long b){\\n        return a*b/gcd(a,b);\\n    }\\n    private long gcd(long a,long b){\\n        if(b==0) return a;\\n        if(a<b) return gcd(b,a);\\n        return gcd(a%b,b);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791018,
                "title": "python-o-log-n-faster-than-97",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        ab = a*b//math.gcd(a, b)\\n        bc = b*c//math.gcd(c, b)\\n        ac = a*c//math.gcd(a, c)\\n        abc = ab*c//math.gcd(ab, c)\\n        \\n        \\n        def nthUgly(k:int) -> bool: #are there more than n uglies below it number?\\n        \\n            h = k//a + k//b + k//c - k//ab - k//ac - k//bc+ k//abc\\n            \\n            if h >= n:\\n                return True\\n            \\n            \\n            return False\\n        \\n        left, right = 1, 10**10\\n        print(nthUgly(10))\\n        while left < right:\\n            mid = left + (right - left)//2\\n            if nthUgly(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return left\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        ab = a*b//math.gcd(a, b)\\n        bc = b*c//math.gcd(c, b)\\n        ac = a*c//math.gcd(a, c)\\n        abc = ab*c//math.gcd(ab, c)\\n        \\n        \\n        def nthUgly(k:int) -> bool: #are there more than n uglies below it number?\\n        \\n            h = k//a + k//b + k//c - k//ab - k//ac - k//bc+ k//abc\\n            \\n            if h >= n:\\n                return True\\n            \\n            \\n            return False\\n        \\n        left, right = 1, 10**10\\n        print(nthUgly(10))\\n        while left < right:\\n            mid = left + (right - left)//2\\n            if nthUgly(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761482,
                "title": "python-100-speed-commented-o-log-n-binary-search",
                "content": "**Python | 100% Speed | Commented | O( Log n ) Binary Search**\\n\\n```\\n# Python 2/3 Compatibility:\\nif hasattr(math,\\'gcd\\'):\\n    gcd = math.gcd\\nelse:\\n    from fractions import gcd\\n#\\nclass Solution:\\n    def nthUglyNumber(self, n, a, b, c):\\n        # Multiples have the form K*a, K*b, K*c\\n        #     - How about binary search?\\n        #         - Try number, find K-th position... move forward\\n        #\\n        # Cross-Products\\n        lcm = lambda x,y: x*y//gcd(x,y)\\n        ab  = lcm(a,b)\\n        ac  = lcm(a,c)\\n        bc  = lcm(b,c)\\n        abc = lcm(ab,c)\\n        #\\n        def index(mid):\\n            # Get n-th index of multiple \"mid\"\\n            Ka,Kb,Kc    = mid//a , mid//b , mid//c\\n            Kabc        = mid//abc\\n            Kab,Kac,Kbc = mid//ab, mid//ac, mid//bc\\n            return Ka + Kb + Kc - Kab - Kac - Kbc + Kabc\\n        def closest(m):\\n            # Find closest number to \"m\" that is a multiple of [a,b,c]\\n            Ka,Kb,Kc = m//a, m//b, m//c\\n            return max(Ka*a,Kb*b,Kc*c)\\n        #\\n        # Low and High Guesses for the K-th multiple (get started with numbers that are multiples themselves)\\n        lo, hi = min(a,b,c), closest(int(2e9))\\n        while lo<=hi:\\n            # m: mid guess\\n            m   = (lo+hi)//2\\n            # mid: closest multiple to mid guess\\n            mid = closest( m )\\n            # Kth: Position of K-th multiple \"mid\"\\n            Kth = index(mid)\\n            if Kth==n:\\n                return mid # Success\\n            if Kth<n:\\n                lo = m + 1 # m was too low\\n            else: # Kth>n\\n                hi = m - 1 # m was too high\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Python 2/3 Compatibility:\\nif hasattr(math,\\'gcd\\'):\\n    gcd = math.gcd\\nelse:\\n    from fractions import gcd\\n#\\nclass Solution:\\n    def nthUglyNumber(self, n, a, b, c):\\n        # Multiples have the form K*a, K*b, K*c\\n        #     - How about binary search?\\n        #         - Try number, find K-th position... move forward\\n        #\\n        # Cross-Products\\n        lcm = lambda x,y: x*y//gcd(x,y)\\n        ab  = lcm(a,b)\\n        ac  = lcm(a,c)\\n        bc  = lcm(b,c)\\n        abc = lcm(ab,c)\\n        #\\n        def index(mid):\\n            # Get n-th index of multiple \"mid\"\\n            Ka,Kb,Kc    = mid//a , mid//b , mid//c\\n            Kabc        = mid//abc\\n            Kab,Kac,Kbc = mid//ab, mid//ac, mid//bc\\n            return Ka + Kb + Kc - Kab - Kac - Kbc + Kabc\\n        def closest(m):\\n            # Find closest number to \"m\" that is a multiple of [a,b,c]\\n            Ka,Kb,Kc = m//a, m//b, m//c\\n            return max(Ka*a,Kb*b,Kc*c)\\n        #\\n        # Low and High Guesses for the K-th multiple (get started with numbers that are multiples themselves)\\n        lo, hi = min(a,b,c), closest(int(2e9))\\n        while lo<=hi:\\n            # m: mid guess\\n            m   = (lo+hi)//2\\n            # mid: closest multiple to mid guess\\n            mid = closest( m )\\n            # Kth: Position of K-th multiple \"mid\"\\n            Kth = index(mid)\\n            if Kth==n:\\n                return mid # Success\\n            if Kth<n:\\n                lo = m + 1 # m was too low\\n            else: # Kth>n\\n                hi = m - 1 # m was too high\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761280,
                "title": "rust-0ms",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Ugly Number III.\\nMemory Usage: 2.1 MB, less than 100.00% of Rust online submissions for Ugly Number III.\\n\\n```rust\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        #[inline]\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if a == 0 {\\n                b\\n            } else {\\n                gcd(b % a, a)\\n            }\\n        }\\n\\n        #[inline]\\n        fn lcm(a: i64, b: i64) -> i64 {\\n            a / gcd(a, b) * b\\n        }\\n\\n        #[inline]\\n        fn count(x: i64, a: i64, b: i64, c: i64) -> i64 {\\n            x / a + x / b + x / c - x / lcm(a, b) - x / lcm(b, c) - x / lcm(c, a)\\n                + x / lcm(a, lcm(b, c))\\n        }\\n\\n        let mut left = 1;\\n        let mut right = 2_000_000_000;\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            if count(mid as i64, a as i64, b as i64, c as i64) as i32 >= n {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        left\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_nth_ugly_number() {\\n        assert_eq!(Solution::nth_ugly_number(3, 2, 3, 5), 4)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_02() {\\n        assert_eq!(Solution::nth_ugly_number(4, 2, 3, 4), 6)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_03() {\\n        assert_eq!(Solution::nth_ugly_number(5, 2, 11, 13), 10)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_04() {\\n        assert_eq!(\\n            Solution::nth_ugly_number(1_000_000_000, 2, 217_983_653, 336_916_467),\\n            1999_999_984\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        #[inline]\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if a == 0 {\\n                b\\n            } else {\\n                gcd(b % a, a)\\n            }\\n        }\\n\\n        #[inline]\\n        fn lcm(a: i64, b: i64) -> i64 {\\n            a / gcd(a, b) * b\\n        }\\n\\n        #[inline]\\n        fn count(x: i64, a: i64, b: i64, c: i64) -> i64 {\\n            x / a + x / b + x / c - x / lcm(a, b) - x / lcm(b, c) - x / lcm(c, a)\\n                + x / lcm(a, lcm(b, c))\\n        }\\n\\n        let mut left = 1;\\n        let mut right = 2_000_000_000;\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            if count(mid as i64, a as i64, b as i64, c as i64) as i32 >= n {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        left\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_nth_ugly_number() {\\n        assert_eq!(Solution::nth_ugly_number(3, 2, 3, 5), 4)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_02() {\\n        assert_eq!(Solution::nth_ugly_number(4, 2, 3, 4), 6)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_03() {\\n        assert_eq!(Solution::nth_ugly_number(5, 2, 11, 13), 10)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_04() {\\n        assert_eq!(\\n            Solution::nth_ugly_number(1_000_000_000, 2, 217_983_653, 336_916_467),\\n            1999_999_984\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 672901,
                "title": "rust-100-ac-calculate-lcm-from-gcd",
                "content": "#### 100% AC Solution:\\n\\n```\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        let (a, b, c) = (a as i64, b as i64, c as i64);\\n        let lcm_ab = Solution::lcm(a, b);\\n        let lcm_bc = Solution::lcm(b, c);\\n        let lcm_ac = Solution::lcm(a, c);\\n        let lcm_abc = Solution::lcm(lcm_ab, c);\\n\\n        let mut lo: i64 = 1;\\n        let mut hi: i64 = 2 * 1e9 as i64;\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2;\\n            let cnt = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac\\n                + mid / lcm_abc;\\n            if cnt < n as i64 {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        lo as i32\\n    }\\n\\n    pub fn lcm(a: i64, b: i64) -> i64 {\\n        a * b / Solution::gcd(a, b)\\n    }\\n\\n    pub fn gcd(mut x: i64, mut y: i64) -> i64 {\\n        x = x.abs();\\n        y = y.abs();\\n        while y != 0 {\\n            // let (x, y) = (y, x % y);  This will not work! due to rust\\'s binding and ownership.\\n            let tmp = x;\\n            x = y;\\n            y = tmp % y;\\n        }\\n        x\\n    }\\n}\\n\\n```\\n\\n__Time Complexity:__ O(Log(2 * 1e9))\\n__Space Complexity:__ O(1)\\nshould be obvious!\\n\\n#### if we can use crate\\n```\\nextern crate num;\\nuse num::integer::lcm;\\n\\nfn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n    let a = a as i64;\\n    let b = b as i64;\\n    let c = c as i64;\\n    let lcm_ab = lcm(a, b);\\n    let lcm_bc = lcm(b, c);\\n    let lcm_ac = lcm(a, c);\\n    let lcm_abc = lcm(lcm_ab, c);\\n\\n    let mut lo: i64 = 1;\\n    let mut hi: i64 = 2 * 1e9 as i64;\\n    while lo < hi {\\n        let mid = lo + (hi - lo) / 2;\\n        let cnt = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac\\n            + mid / lcm_abc;\\n        if cnt < n as i64 {\\n            lo = mid + 1\\n        } else {\\n            hi = mid\\n        }\\n    }\\n    lo as i32\\n}\\n\\n```\\n\\n__Reference for Rustacean:__\\n* use lcm from crate `num` \\n\\t* https://crates.io/crates/num\\n\\t* https://docs.rs/num/0.2.1/num/integer/fn.lcm.html\\n\\n\\n> Please give it a star \\uD83C\\uDF1F if you find the solution and resources rustacean and helpful!\\n",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        let (a, b, c) = (a as i64, b as i64, c as i64);\\n        let lcm_ab = Solution::lcm(a, b);\\n        let lcm_bc = Solution::lcm(b, c);\\n        let lcm_ac = Solution::lcm(a, c);\\n        let lcm_abc = Solution::lcm(lcm_ab, c);\\n\\n        let mut lo: i64 = 1;\\n        let mut hi: i64 = 2 * 1e9 as i64;\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2;\\n            let cnt = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac\\n                + mid / lcm_abc;\\n            if cnt < n as i64 {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        lo as i32\\n    }\\n\\n    pub fn lcm(a: i64, b: i64) -> i64 {\\n        a * b / Solution::gcd(a, b)\\n    }\\n\\n    pub fn gcd(mut x: i64, mut y: i64) -> i64 {\\n        x = x.abs();\\n        y = y.abs();\\n        while y != 0 {\\n            // let (x, y) = (y, x % y);  This will not work! due to rust\\'s binding and ownership.\\n            let tmp = x;\\n            x = y;\\n            y = tmp % y;\\n        }\\n        x\\n    }\\n}\\n\\n```\n```\\nextern crate num;\\nuse num::integer::lcm;\\n\\nfn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n    let a = a as i64;\\n    let b = b as i64;\\n    let c = c as i64;\\n    let lcm_ab = lcm(a, b);\\n    let lcm_bc = lcm(b, c);\\n    let lcm_ac = lcm(a, c);\\n    let lcm_abc = lcm(lcm_ab, c);\\n\\n    let mut lo: i64 = 1;\\n    let mut hi: i64 = 2 * 1e9 as i64;\\n    while lo < hi {\\n        let mid = lo + (hi - lo) / 2;\\n        let cnt = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac\\n            + mid / lcm_abc;\\n        if cnt < n as i64 {\\n            lo = mid + 1\\n        } else {\\n            hi = mid\\n        }\\n    }\\n    lo as i32\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619616,
                "title": "1201-ugly-number-iii-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Math LCM: Binary Search**\\n| O(T): O(lgn) | O(S): O(1) | Rt: 28ms | \\n```python\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        lcm = lambda x, y: x * y // math.gcd(x, y)\\n        ab, bc, ac = lcm(a, b), lcm(b, c), lcm(a, c)\\n        abc = lcm(ab, c)\\n        l, r = 0, 2 * (10 ** 9)\\n        while l < r:\\n            m = l + (r - l) // 2\\n            ct = m//a + m//b + m//c - m//ab - m//bc - m//ac + m//abc\\n            if ct < n: l = m+1\\n            else: r = m\\n        return l\\n```\\nReferrence: https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template\\n\\nAlternative: | Rt: 28ms |\\n```python\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a%b\\n            return a\\n        \\n        lcm = lambda x, y: x * y // gcd(x, y)\\n        ab, bc, ac = lcm(a, b), lcm(b, c), lcm(a, c)\\n        abc = lcm(ab, c)\\n        l, r = 0, 2 * (10 ** 9)\\n        while l < r:\\n            m = l + (r - l) // 2\\n            ct = m//a + m//b + m//c - m//ab - m//bc - m//ac + m//abc\\n            if ct < n: l = m+1\\n            else: r = m\\n        return l\\n```",
                "solutionTags": [],
                "code": "```python\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        lcm = lambda x, y: x * y // math.gcd(x, y)\\n        ab, bc, ac = lcm(a, b), lcm(b, c), lcm(a, c)\\n        abc = lcm(ab, c)\\n        l, r = 0, 2 * (10 ** 9)\\n        while l < r:\\n            m = l + (r - l) // 2\\n            ct = m//a + m//b + m//c - m//ab - m//bc - m//ac + m//abc\\n            if ct < n: l = m+1\\n            else: r = m\\n        return l\\n```\n```python\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a%b\\n            return a\\n        \\n        lcm = lambda x, y: x * y // gcd(x, y)\\n        ab, bc, ac = lcm(a, b), lcm(b, c), lcm(a, c)\\n        abc = lcm(ab, c)\\n        l, r = 0, 2 * (10 ** 9)\\n        while l < r:\\n            m = l + (r - l) // 2\\n            ct = m//a + m//b + m//c - m//ab - m//bc - m//ac + m//abc\\n            if ct < n: l = m+1\\n            else: r = m\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 591808,
                "title": "c-100-time-and-space-using-binary-search",
                "content": "The concept used here is to find the smallest number x such that \\nthe number of values v<=x divisible by either a,b, or c is n.\\nBinary search can be used to find this value. \\n\\nFor finding the number of values v<=x divisible by either a,b, or c :\\nWe need to use Inclusion-exclusion principle as the values divisible by lcm(a,b), lcm(b,c) and lcm(c,a) get counted more than once.\\nSo subtract x/lcm(a,b) , x/lcm(b,c) and x/lcm(a,c).\\nNow the values which are divisible by lcm(a,b,c) have been removed more than once, therefore we need to include then again.\\nSo add x/lcm(a,lcm(b,c))\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a*b)/__gcd(a,b);\\n    }\\n    \\n    long long func(long long x,long long a,long long b,long long c){\\n        long long ans = x/a + x/b + x/c - x/lcm(a,b) - x/lcm(b,c) - x/lcm(c,a) + x/lcm(a,lcm(b,c));\\n        return ans;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long low = min(a,min(b,c)),high = INT_MAX,mid;\\n        while(low<high){\\n            mid = (low+high)/2;\\n            if(func(mid,a,b,c)>=n){\\n                high = mid-1;\\n            }\\n            else if(func(mid,a,b,c)<n){\\n                low = mid+1;\\n            }\\n        }\\n        while(func(mid,a,b,c)<n) mid++;\\n        while(func(mid,a,b,c)>=n) mid--;\\n        return mid+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a*b)/__gcd(a,b);\\n    }\\n    \\n    long long func(long long x,long long a,long long b,long long c){\\n        long long ans = x/a + x/b + x/c - x/lcm(a,b) - x/lcm(b,c) - x/lcm(c,a) + x/lcm(a,lcm(b,c));\\n        return ans;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long low = min(a,min(b,c)),high = INT_MAX,mid;\\n        while(low<high){\\n            mid = (low+high)/2;\\n            if(func(mid,a,b,c)>=n){\\n                high = mid-1;\\n            }\\n            else if(func(mid,a,b,c)<n){\\n                low = mid+1;\\n            }\\n        }\\n        while(func(mid,a,b,c)<n) mid++;\\n        while(func(mid,a,b,c)>=n) mid--;\\n        return mid+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487173,
                "title": "3-lines-binary-search-with-inclusion-exclusion-ruby",
                "content": "Same idea that apparently everyone else came up with as well (so I won\\'t repeat the explanation), but Ruby is so awesome that it not only provides simple short binary search but even least common multiple.\\n```\\ndef nth_ugly_number(n, a, b, c)\\n  ab, ac, bc = a.lcm(b), a.lcm(c), b.lcm(c)\\n  abc = ab.lcm(c)\\n  (1..2*10**9).bsearch { |m| m/a + m/b + m/c - m/ab - m/ac - m/bc + m/abc >= n }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef nth_ugly_number(n, a, b, c)\\n  ab, ac, bc = a.lcm(b), a.lcm(c), b.lcm(c)\\n  abc = ab.lcm(c)\\n  (1..2*10**9).bsearch { |m| m/a + m/b + m/c - m/ab - m/ac - m/bc + m/abc >= n }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 467329,
                "title": "most-efficient-c-solution-faster-than-100-100-memory-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long ab,bc,ac,abc,l=1,r=2*1e9,m,ans;\\n        ab=(long long)a*b/__gcd(a,b);\\n        bc=(long long)b*c/__gcd(b,c);\\n        ac=(long long)a*c/__gcd(a,c);\\n        abc=ab*c/__gcd(ab,(long long)c);\\n        while(l<=r){\\n            m=(l+r)/2;\\n            ans=m/a+m/b+m/c+m/abc-m/ab-m/bc-m/ac;\\n            if(ans<n)\\n                l=m+1;\\n            else\\n                r=m-1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long ab,bc,ac,abc,l=1,r=2*1e9,m,ans;\\n        ab=(long long)a*b/__gcd(a,b);\\n        bc=(long long)b*c/__gcd(b,c);\\n        ac=(long long)a*c/__gcd(a,c);\\n        abc=ab*c/__gcd(ab,(long long)c);\\n        while(l<=r){\\n            m=(l+r)/2;\\n            ans=m/a+m/b+m/c+m/abc-m/ab-m/bc-m/ac;\\n            if(ans<n)\\n                l=m+1;\\n            else\\n                r=m-1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424329,
                "title": "0-ms-c-solution-faster-than-100-percent",
                "content": "```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    int f(ll &n, int &a, int &b, int &c, ll &d, ll &e, ll &f, ll &g){\\n        return n/a+n/b+n/c-n/d-n/e-n/f+n/g;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll lcmab = ((ll)a*b)/gcd(a,b);\\n        ll lcmbc = ((ll)b*c)/gcd(b,c);\\n        ll lcmac = ((ll)a*c)/gcd(a,c);\\n        ll lcmabc = ((ll)a*lcmbc)/gcd(a,lcmbc);\\n        int ans;\\n        int l=0, r=2*1e9;\\n        while(l<r){\\n            ll mid=((ll)l+r)/2;\\n            ll count = f(mid,a,b,c,lcmab,lcmbc,lcmac,lcmabc);\\n            if(count >= n) r = mid;\\n            else l = mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    int f(ll &n, int &a, int &b, int &c, ll &d, ll &e, ll &f, ll &g){\\n        return n/a+n/b+n/c-n/d-n/e-n/f+n/g;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll lcmab = ((ll)a*b)/gcd(a,b);\\n        ll lcmbc = ((ll)b*c)/gcd(b,c);\\n        ll lcmac = ((ll)a*c)/gcd(a,c);\\n        ll lcmabc = ((ll)a*lcmbc)/gcd(a,lcmbc);\\n        int ans;\\n        int l=0, r=2*1e9;\\n        while(l<r){\\n            ll mid=((ll)l+r)/2;\\n            ll count = f(mid,a,b,c,lcmab,lcmbc,lcmac,lcmabc);\\n            if(count >= n) r = mid;\\n            else l = mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423450,
                "title": "python-concise-bi-search",
                "content": "numbers <=x which is divider of a,b,c==f(x)==f(a)+f(b)+f(c)-f(divide a,b)-f(divide b,c)-f(divide a,c)+f(divide a,b,c)\\nanother formula gcm(a,b)=a*b/gcd(a,b)\\n```\\nclass Solution(object):\\n    def nthUglyNumber(self, n, a, b, c):\\n        def gcd(a,b):\\n            while b>0:\\n                a,b=b,a%b\\n            return a\\n        \\n        def gcm(a,b):\\n            return a*b/gcd(a,b)\\n        \\n        def f(x,a):\\n            return x//a\\n        \\n        l,r=0,2*10**9\\n        while l<r:\\n            mid=(l+r)//2\\n            num=f(mid,a)+f(mid,b)+f(mid,c)-f(mid,gcm(a,b))-f(mid,gcm(b,c))-f(mid,gcm(a,c))+f(mid,gcm(gcm(a,b),c))\\n            if num==n:\\n                r=mid\\n            elif num>n:\\n                r=mid-1\\n            else:\\n                l=mid+1\\n        return l",
                "solutionTags": [],
                "code": "numbers <=x which is divider of a,b,c==f(x)==f(a)+f(b)+f(c)-f(divide a,b)-f(divide b,c)-f(divide a,c)+f(divide a,b,c)\\nanother formula gcm(a,b)=a*b/gcd(a,b)\\n```\\nclass Solution(object):\\n    def nthUglyNumber(self, n, a, b, c):\\n        def gcd(a,b):\\n            while b>0:\\n                a,b=b,a%b\\n            return a\\n        \\n        def gcm(a,b):\\n            return a*b/gcd(a,b)\\n        \\n        def f(x,a):\\n            return x//a\\n        \\n        l,r=0,2*10**9\\n        while l<r:\\n            mid=(l+r)//2\\n            num=f(mid,a)+f(mid,b)+f(mid,c)-f(mid,gcm(a,b))-f(mid,gcm(b,c))-f(mid,gcm(a,c))+f(mid,gcm(gcm(a,b),c))\\n            if num==n:\\n                r=mid\\n            elif num>n:\\n                r=mid-1\\n            else:\\n                l=mid+1\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 389059,
                "title": "clean-python-solution-beat-99-submission",
                "content": "```\\ndef nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\tfrom math import gcd\\n\\tab = a * b // gcd(a, b)\\n\\tac = a * c // gcd(a, c)\\n\\tbc = b * c // gcd(b, c)\\n\\tabc = ab * c // gcd(ab, c)\\n\\tl, r = 1, min(a, b, c) * n\\n\\twhile l < r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tcnt = mid//a + mid // b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n\\t\\tif cnt < n:\\n\\t\\t\\tl = mid + 1\\n\\t\\telse:\\n\\t\\t\\tr = mid\\n\\treturn l\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\ndef nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\tfrom math import gcd\\n\\tab = a * b // gcd(a, b)\\n\\tac = a * c // gcd(a, c)\\n\\tbc = b * c // gcd(b, c)\\n\\tabc = ab * c // gcd(ab, c)\\n\\tl, r = 1, min(a, b, c) * n\\n\\twhile l < r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tcnt = mid//a + mid // b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n\\t\\tif cnt < n:\\n\\t\\t\\tl = mid + 1\\n\\t\\telse:\\n\\t\\t\\tr = mid\\n\\treturn l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 388461,
                "title": "c-binary-search-solution-with-explanation",
                "content": "My solution is inspired by hint 1. Our goal is to find a function f that f(x) means number of ugly number smaller than or equal to x.\\n\\nFor number x, there are x/a number can be divisible by a, x/b number can be divisible by b and x/c number can be divisible by c.\\nHowever, in such case, if one number can be divisible by both (a,b), we count it twice. We have to subtract those cases from our total count. \\n\\nLucky enough, if a number can be divisible by both (a,b), it must can be divisible by lcm(a,b). So we need to calucalte least common multiple between (a,b) (b,c) (a,c) and (a,b,c).\\n\\nThen we know, there are x/lcm(a,b) number can be divisible by both (a,b), x/lcm(b,c) number can be divisible by both (b,c), and x/lcm(a,c) number can be divisible by both (a,c). \\n\\nHowever, after subtracting them, we don\\'t count number which can be divisible by (a,b,c) together, to fix it, we simply need to add x/lcm(a,lcm(b,c)).\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long gcd(long long a, long long b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b, a%b);\\n    }\\n    \\n    long long lcm(long long a, long long b){\\n        if(a<b){\\n            swap(a,b);\\n        }\\n        return a*b / gcd(a,b);\\n    }\\n    \\n    template<typename T>\\n    void sort3(T& a, T& b, T& c){\\n        if (a > c)\\n            swap(a, c);\\n        if (a > b)\\n            swap(a, b);\\n        if (b > c)\\n            swap(b, c);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        sort3(a,b,c);\\n        long long ab = lcm(a,b);\\n        long long bc = lcm(b,c);\\n        long long ac = lcm(a,c);\\n        long long abc = lcm(a,lcm(b,c));\\n        auto f = [&](long long x){\\n            return x/a + x/b + x/c - x/ab - x/ac - x/bc + x/abc;\\n        };\\n        long long l = a;\\n        long long r = a*n;\\n        while(l<r){\\n            long long m = (l+r)/2;\\n            int _n = f(m);\\n            if(_n == n){\\n                r = m;\\n                break;\\n            }\\n            else if (_n<n){\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        while(r){\\n            if(r%a == 0 || r%b == 0 || r%c == 0){\\n                return r;\\n            }\\n            r--;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long gcd(long long a, long long b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b, a%b);\\n    }\\n    \\n    long long lcm(long long a, long long b){\\n        if(a<b){\\n            swap(a,b);\\n        }\\n        return a*b / gcd(a,b);\\n    }\\n    \\n    template<typename T>\\n    void sort3(T& a, T& b, T& c){\\n        if (a > c)\\n            swap(a, c);\\n        if (a > b)\\n            swap(a, b);\\n        if (b > c)\\n            swap(b, c);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        sort3(a,b,c);\\n        long long ab = lcm(a,b);\\n        long long bc = lcm(b,c);\\n        long long ac = lcm(a,c);\\n        long long abc = lcm(a,lcm(b,c));\\n        auto f = [&](long long x){\\n            return x/a + x/b + x/c - x/ab - x/ac - x/bc + x/abc;\\n        };\\n        long long l = a;\\n        long long r = a*n;\\n        while(l<r){\\n            long long m = (l+r)/2;\\n            int _n = f(m);\\n            if(_n == n){\\n                r = m;\\n                break;\\n            }\\n            else if (_n<n){\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        while(r){\\n            if(r%a == 0 || r%b == 0 || r%c == 0){\\n                return r;\\n            }\\n            r--;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387736,
                "title": "python3-beats-100",
                "content": "If it\\'s nth ugly number in sequence, then this number must be less than **a * n**. With this limit, the binary search can be more efficient.\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            return (a * b) // math.gcd(a, b) # a, b, c >= 1\\n        \\n        def count(val, a, b, c):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm(a, b)) - \\\\\\n                   (val // lcm(a, c)) - (val // lcm(b, c)) + (val // lcm(lcm(a, b), c))\\n        \\n        low = 1\\n        high = n * a\\n        \\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if count(mid, a, b, c) < n:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            return (a * b) // math.gcd(a, b) # a, b, c >= 1\\n        \\n        def count(val, a, b, c):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm(a, b)) - \\\\\\n                   (val // lcm(a, c)) - (val // lcm(b, c)) + (val // lcm(lcm(a, b), c))\\n        \\n        low = 1\\n        high = n * a\\n        \\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if count(mid, a, b, c) < n:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387728,
                "title": "java-clean-binarysearch-solution",
                "content": "```\\nclass Solution {\\n   public int nthUglyNumber(int n, int a, int b, int c) {\\n        int start = 1, end = Integer.MAX_VALUE;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (countUgly(a, b, c, mid) >= n) {\\n                end = mid;\\n            } else {\\n                start = mid;\\n            }\\n        }\\n        return end;\\n    }\\n\\n    private int countUgly(int a, int b, int c, int target) {\\n        int count = 0;\\n        count += (target / a + target / b + target / c);\\n        count -= (target / GCM(a, b) + target / GCM(a, c) + target / GCM(b, c));\\n        count += target / GCM(a, GCM(b, c));\\n        return count;\\n    }\\n\\n    private long GCM(long a, long b) {\\n        return a * b / GCD(a, b);\\n    }\\n\\n    private long GCD(long a, long b) {\\n        if (b != 0) {\\n            return GCD(b, a % b);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int nthUglyNumber(int n, int a, int b, int c) {\\n        int start = 1, end = Integer.MAX_VALUE;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (countUgly(a, b, c, mid) >= n) {\\n                end = mid;\\n            } else {\\n                start = mid;\\n            }\\n        }\\n        return end;\\n    }\\n\\n    private int countUgly(int a, int b, int c, int target) {\\n        int count = 0;\\n        count += (target / a + target / b + target / c);\\n        count -= (target / GCM(a, b) + target / GCM(a, c) + target / GCM(b, c));\\n        count += target / GCM(a, GCM(b, c));\\n        return count;\\n    }\\n\\n    private long GCM(long a, long b) {\\n        return a * b / GCD(a, b);\\n    }\\n\\n    private long GCD(long a, long b) {\\n        if (b != 0) {\\n            return GCD(b, a % b);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387554,
                "title": "cxx-inclusion-exclusion-and-binary-search",
                "content": "Inclusion-Exclusion may be visualized by the following Venn-diagram\\n\\n```\\n             \\n      /-----------------------------\\\\\\n      |  Divisible by A             |\\n      |                             |\\n      |                             |\\n /----+---------------\\\\             |\\n/     | Div. by       |             |\\n|     | A and B       |             |\\n|     |               |             |\\n|     |    /----------+-------------+---------\\\\\\n|     |    |Div by    | Divisible   |         |\\n|     |    |A,B and C |   by A and C|         |\\n|     |    |          |             |         |\\n|     \\\\----+----------+-------------/         |\\n|          | Div. by  |                       |\\n| Divisible|  B and C |                       |\\n|  by B    |          |  Divisible            |\\n|          |          |     by C              |\\n|          |          |                       |\\n\\\\----------+----------/                       |\\n           |                                  |\\n\\t\\t   \\\\----------------------------------/\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n\\tlong gcd(long a, long b) {\\n\\t\\tlong rem = 0;\\n\\t\\tdo {\\n\\t\\t\\trem = a % b;\\n\\t\\t\\ta = b;\\n\\t\\t\\tb = rem;\\n\\t\\t} while (b!=0);\\n\\t\\treturn a;\\n\\t}\\n\\tlong lcm(long a, long b) {\\n\\t\\treturn a * b / gcd(a,b);\\n\\t}\\n\\tlong a, b, c, lcm_ab, lcm_bc, lcm_ac, lcm_abc;\\n\\tint rank(int x) {\\n\\t\\treturn x/a + x/b + x/c - x/lcm_ab - x/lcm_bc - x/lcm_ac + x/lcm_abc;\\n\\t}\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n\\t\\tthis->a = a;\\n\\t\\tthis->b = b;\\n\\t\\tthis->c = c;\\n\\t\\tlcm_ab =  lcm(long(a), long(b));\\n\\t\\tlcm_bc =  lcm(long(b), long(c));\\n\\t\\tlcm_ac =  lcm(long(a), long(c));\\n\\t\\tlcm_abc = lcm(long(lcm_ac), long(b));\\n\\n\\t\\t// lb = Lower Bound, ub = Upper Bound\\n\\t\\tint lb = 1, ub = 2147483647;\\n\\n\\t\\t// Binary Search!\\n\\t\\twhile (lb+1 < ub) {\\n\\t\\t\\tint mid = int((long(lb) + long(ub)) / 2L);\\n\\t\\t\\tint rank_mid = rank(mid);\\n\\t\\t\\tif (rank_mid < n) { lb = mid; }\\n\\t\\t\\telse ub = mid;\\n\\n\\t\\t\\tprintf(\"%d,%d\\\\n\", lb, ub);\\n\\t\\t}\\n\\t\\tif (rank(lb) == n) return lb;\\n\\t\\telse return ub;\\n    }\\n};\\n\\nint main() {\\n\\tSolution s;\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(3, 2, 3, 5));\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(4, 2, 3, 4));\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(1000000000, 2, 217983653, 336916467));\\n}\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n             \\n      /-----------------------------\\\\\\n      |  Divisible by A             |\\n      |                             |\\n      |                             |\\n /----+---------------\\\\             |\\n/     | Div. by       |             |\\n|     | A and B       |             |\\n|     |               |             |\\n|     |    /----------+-------------+---------\\\\\\n|     |    |Div by    | Divisible   |         |\\n|     |    |A,B and C |   by A and C|         |\\n|     |    |          |             |         |\\n|     \\\\----+----------+-------------/         |\\n|          | Div. by  |                       |\\n| Divisible|  B and C |                       |\\n|  by B    |          |  Divisible            |\\n|          |          |     by C              |\\n|          |          |                       |\\n\\\\----------+----------/                       |\\n           |                                  |\\n\\t\\t   \\\\----------------------------------/\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\tlong gcd(long a, long b) {\\n\\t\\tlong rem = 0;\\n\\t\\tdo {\\n\\t\\t\\trem = a % b;\\n\\t\\t\\ta = b;\\n\\t\\t\\tb = rem;\\n\\t\\t} while (b!=0);\\n\\t\\treturn a;\\n\\t}\\n\\tlong lcm(long a, long b) {\\n\\t\\treturn a * b / gcd(a,b);\\n\\t}\\n\\tlong a, b, c, lcm_ab, lcm_bc, lcm_ac, lcm_abc;\\n\\tint rank(int x) {\\n\\t\\treturn x/a + x/b + x/c - x/lcm_ab - x/lcm_bc - x/lcm_ac + x/lcm_abc;\\n\\t}\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n\\t\\tthis->a = a;\\n\\t\\tthis->b = b;\\n\\t\\tthis->c = c;\\n\\t\\tlcm_ab =  lcm(long(a), long(b));\\n\\t\\tlcm_bc =  lcm(long(b), long(c));\\n\\t\\tlcm_ac =  lcm(long(a), long(c));\\n\\t\\tlcm_abc = lcm(long(lcm_ac), long(b));\\n\\n\\t\\t// lb = Lower Bound, ub = Upper Bound\\n\\t\\tint lb = 1, ub = 2147483647;\\n\\n\\t\\t// Binary Search!\\n\\t\\twhile (lb+1 < ub) {\\n\\t\\t\\tint mid = int((long(lb) + long(ub)) / 2L);\\n\\t\\t\\tint rank_mid = rank(mid);\\n\\t\\t\\tif (rank_mid < n) { lb = mid; }\\n\\t\\t\\telse ub = mid;\\n\\n\\t\\t\\tprintf(\"%d,%d\\\\n\", lb, ub);\\n\\t\\t}\\n\\t\\tif (rank(lb) == n) return lb;\\n\\t\\telse return ub;\\n    }\\n};\\n\\nint main() {\\n\\tSolution s;\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(3, 2, 3, 5));\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(4, 2, 3, 4));\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(1000000000, 2, 217983653, 336916467));\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3996401,
                "title": "100-beat-easy-to-understand-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gcd(long long a,long long b){\\n        if(b==0){\\n            return a;\\n        }\\n        else{\\n            return gcd(b,a%b);\\n        }\\n        return 0;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n    long long left=1,right=1e13;\\n    long long a_b=(1ll*a*b)/(1ll*gcd(1ll*a,1ll*b));\\n    long long a_c=(1ll*a*c)/(1ll*gcd(1ll*a,1ll*c));\\n    long long b_c=(1ll*b*c)/(1ll*gcd(1ll*b,1ll*c));\\n    long long a_b_c=(1ll*a_b*c)/(1ll*gcd(a_b,1ll*c));\\n    long long ans=-1;\\n    while(left<=right){\\n        long long mid=(left+right)/2;\\n    long long count=mid/a+mid/b+mid/c-mid/a_b-mid/a_c-mid/b_c+mid/a_b_c;\\n    if(count==n){\\n    \\n        ans=mid;\\n        right=mid-1;\\n    }\\n    else if(count>n){\\n        right=mid-1;\\n    }\\n    else{\\n        left=mid+1;\\n    }\\n    }\\n    return  ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gcd(long long a,long long b){\\n        if(b==0){\\n            return a;\\n        }\\n        else{\\n            return gcd(b,a%b);\\n        }\\n        return 0;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n    long long left=1,right=1e13;\\n    long long a_b=(1ll*a*b)/(1ll*gcd(1ll*a,1ll*b));\\n    long long a_c=(1ll*a*c)/(1ll*gcd(1ll*a,1ll*c));\\n    long long b_c=(1ll*b*c)/(1ll*gcd(1ll*b,1ll*c));\\n    long long a_b_c=(1ll*a_b*c)/(1ll*gcd(a_b,1ll*c));\\n    long long ans=-1;\\n    while(left<=right){\\n        long long mid=(left+right)/2;\\n    long long count=mid/a+mid/b+mid/c-mid/a_b-mid/a_c-mid/b_c+mid/a_b_c;\\n    if(count==n){\\n    \\n        ans=mid;\\n        right=mid-1;\\n    }\\n    else if(count>n){\\n        right=mid-1;\\n    }\\n    else{\\n        left=mid+1;\\n    }\\n    }\\n    return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929703,
                "title": "java-solution-for-nth-ugly-number-inclusion-exclusion-principles-binary-search",
                "content": "\\n# Approach\\nSteps:\\n1. Find GCD\\n2. Find LCM\\n3. Create function based on of Inclusion-Exclusion Sets principle\\n4. Do a binary search to find the nth element\\n\\n# Complexity\\n- Time complexity:\\nFor LCM & GCD :  O(log min(a, b))\\nFor Binary Search : O(log M)\\nOverall : O(log M)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left  = 1;\\n        int right = Integer.MAX_VALUE;\\n\\n        while( left < right){                       //  Binary Search\\n            int m = left + (right - left) /2;  \\n            if( isUgly(m, a, b, c, n))\\n                right = m;\\n            \\n            else\\n                left = m +1;\\n        }\\n        return left;\\n    }\\n\\n    public long gcd ( long a, long  b){  // Function to find GCD using\\n        if( a == 0){                        //      Recursion\\n            return b;\\n        }\\n        else{\\n            return gcd(b%a, a);\\n        }\\n    }\\n\\n    public long lcm ( long a, long b){      // Formual to calculate\\n        return (a*b)/ (gcd(a,b));              //  lcm using gcd\\n    }\\n\\n    public boolean isUgly(long m, long a, long b, long c, long n){ // Inclucsion Sets Principle\\n        return (int) (m/a + m/b + m/c - m/lcm(a,b) - m/lcm(b,c) - m/ lcm(c,a) + m/ lcm(a, lcm(b,c))) >= n;   \\n    }                                        \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left  = 1;\\n        int right = Integer.MAX_VALUE;\\n\\n        while( left < right){                       //  Binary Search\\n            int m = left + (right - left) /2;  \\n            if( isUgly(m, a, b, c, n))\\n                right = m;\\n            \\n            else\\n                left = m +1;\\n        }\\n        return left;\\n    }\\n\\n    public long gcd ( long a, long  b){  // Function to find GCD using\\n        if( a == 0){                        //      Recursion\\n            return b;\\n        }\\n        else{\\n            return gcd(b%a, a);\\n        }\\n    }\\n\\n    public long lcm ( long a, long b){      // Formual to calculate\\n        return (a*b)/ (gcd(a,b));              //  lcm using gcd\\n    }\\n\\n    public boolean isUgly(long m, long a, long b, long c, long n){ // Inclucsion Sets Principle\\n        return (int) (m/a + m/b + m/c - m/lcm(a,b) - m/lcm(b,c) - m/ lcm(c,a) + m/ lcm(a, lcm(b,c))) >= n;   \\n    }                                        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807293,
                "title": "bs-approach-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int __gcd(int a,int b){\\n        if(b==0)return a;\\n        return __gcd(b,a%b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l=1;\\n        long long r=2000000000;\\n        long long amb = 1ll*a*b;\\n        long long bmc = 1ll*b*c;\\n        long long cma = 1ll*a*c;\\n        long long a_b=(amb)/__gcd(a,b);\\n        long long b_c=(bmc)/__gcd(b,c);\\n        long long a_c=(cma)/__gcd(a,c);\\n        long long a_b_c=(a_b*c)/__gcd(a_b,c);\\n        while(l<r){\\n            long long mid = l+(r-l)/2;\\n            long long lessOrEqualToMid = (mid/a + mid/b + mid/c - mid/(a_b) - mid/(b_c) - mid/(a_c) + mid/(a_b_c));\\n            if(lessOrEqualToMid < n){\\n                l=mid+1;\\n            }else{\\n                r=mid;\\n            }\\n        }return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int __gcd(int a,int b){\\n        if(b==0)return a;\\n        return __gcd(b,a%b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l=1;\\n        long long r=2000000000;\\n        long long amb = 1ll*a*b;\\n        long long bmc = 1ll*b*c;\\n        long long cma = 1ll*a*c;\\n        long long a_b=(amb)/__gcd(a,b);\\n        long long b_c=(bmc)/__gcd(b,c);\\n        long long a_c=(cma)/__gcd(a,c);\\n        long long a_b_c=(a_b*c)/__gcd(a_b,c);\\n        while(l<r){\\n            long long mid = l+(r-l)/2;\\n            long long lessOrEqualToMid = (mid/a + mid/b + mid/c - mid/(a_b) - mid/(b_c) - mid/(a_c) + mid/(a_b_c));\\n            if(lessOrEqualToMid < n){\\n                l=mid+1;\\n            }else{\\n                r=mid;\\n            }\\n        }return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630940,
                "title": "the-inclusion-exclusion-principle",
                "content": "148A (RU): https://codeforces.com/blog/entry/3819\\n```ruby\\ndef nth_ugly_number n, *d0\\n    a, b, c = *d0.sort!\\n    d1 = [a.lcm(b), a.lcm(c), b.lcm(c)]\\n    d2 = d0.reduce(&:lcm)\\n    (1..a * n).bsearch do | x |\\n        r = d0.sum { x / _1 } -\\n            d1.sum { x / _1 } +\\n            x / d2\\n        return x if r == n && d0.any? { x % _1 == 0 }\\n        r >= n\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef nth_ugly_number n, *d0\\n    a, b, c = *d0.sort!\\n    d1 = [a.lcm(b), a.lcm(c), b.lcm(c)]\\n    d2 = d0.reduce(&:lcm)\\n    (1..a * n).bsearch do | x |\\n        r = d0.sum { x / _1 } -\\n            d1.sum { x / _1 } +\\n            x / d2\\n        return x if r == n && d0.any? { x % _1 == 0 }\\n        r >= n\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3626938,
                "title": "just-to-be-a-c-version-of-the-code",
                "content": "# Code\\n```\\npublic class Solution {\\n    int max_ans = 2000000000;\\n\\n    public int NthUglyNumber(int n, int a, int b, int c) {\\n        int l = 1, r = max_ans, result = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if ( count(mid,a,b,c) >= n) {\\n                // find mid as small as possible that count == n\\n                result = mid;\\n                r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n        return result;\\n    }\\n\\n    public int count(long num, long a, long b, long c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a,lcm(b, c)))\\n            );\\n    }\\n\\n    // Greatest common divider\\n    public long gcd(long a, long b){\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    // Least common multiple\\n    public long lcm(long a, long b){\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    int max_ans = 2000000000;\\n\\n    public int NthUglyNumber(int n, int a, int b, int c) {\\n        int l = 1, r = max_ans, result = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if ( count(mid,a,b,c) >= n) {\\n                // find mid as small as possible that count == n\\n                result = mid;\\n                r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n        return result;\\n    }\\n\\n    public int count(long num, long a, long b, long c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a,lcm(b, c)))\\n            );\\n    }\\n\\n    // Greatest common divider\\n    public long gcd(long a, long b){\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    // Least common multiple\\n    public long lcm(long a, long b){\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616631,
                "title": "easy-viennn-diagram-principles",
                "content": "```\\nlong long ab,ac,bc,abc;\\n    long long solve(int m,int a,int b,int c)\\n    {\\n        long long count=0;\\n        \\n        /// draw the veiin diagram \\n        \\n        count+=(m/a);\\n        count+=(m/b);\\n        count+=(m/c);\\n        \\n        count-=(m/ab);\\n        count-=(m/ac);\\n        count-=(m/bc);\\n        \\n        count+=(m/abc);\\n        return count;\\n        \\n        \\n    }\\n    int nthUglyNumber(int n, int A, int B, int C)\\n    {\\n        long long l=1,h=2*1e9;\\n        long long a=A,b=B,c=C;\\n        long long pro=a*b;\\n        ab=pro/__gcd(a,b);\\n        pro=a*c;\\n        ac=pro/__gcd(a,c);\\n        pro=b*c;\\n        bc=pro/__gcd(b,c);\\n        pro=ab*c;\\n        abc=pro/__gcd(ab,c);\\n \\n        while(l<=h)\\n        {\\n            long long m=l+(h-l)/2;\\n            \\n            long long uglyCount=solve(m,a,b,c);\\n            \\n            bool checkDivisibility =(m%a==0) || (m%b==0) || (m%c==0);\\n            \\n            if(uglyCount==n and checkDivisibility)\\n                return m;\\n            if(uglyCount>=n) // answer will be on right side \\n                h=m-1;\\n            else\\n                l=m+1;\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nlong long ab,ac,bc,abc;\\n    long long solve(int m,int a,int b,int c)\\n    {\\n        long long count=0;\\n        \\n        /// draw the veiin diagram \\n        \\n        count+=(m/a);\\n        count+=(m/b);\\n        count+=(m/c);\\n        \\n        count-=(m/ab);\\n        count-=(m/ac);\\n        count-=(m/bc);\\n        \\n        count+=(m/abc);\\n        return count;\\n        \\n        \\n    }\\n    int nthUglyNumber(int n, int A, int B, int C)\\n    {\\n        long long l=1,h=2*1e9;\\n        long long a=A,b=B,c=C;\\n        long long pro=a*b;\\n        ab=pro/__gcd(a,b);\\n        pro=a*c;\\n        ac=pro/__gcd(a,c);\\n        pro=b*c;\\n        bc=pro/__gcd(b,c);\\n        pro=ab*c;\\n        abc=pro/__gcd(ab,c);\\n \\n        while(l<=h)\\n        {\\n            long long m=l+(h-l)/2;\\n            \\n            long long uglyCount=solve(m,a,b,c);\\n            \\n            bool checkDivisibility =(m%a==0) || (m%b==0) || (m%c==0);\\n            \\n            if(uglyCount==n and checkDivisibility)\\n                return m;\\n            if(uglyCount>=n) // answer will be on right side \\n                h=m-1;\\n            else\\n                l=m+1;\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552320,
                "title": "binary-search-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        #Condition: Are there at least n ugly numbers smaller than or equal to value?\\n        def countUglyNumbers(value):\\n            count = (value//a) + (value//b) + (value//c) + (value//abc)\\n            count -= ((value//ab) + (value//bc) + (value//ac))\\n            return count >= n\\n\\n        ab = math.lcm(a,b) #LCM of a and b\\n        bc = math.lcm(b,c) #LCM of b and c\\n        ac = math.lcm(a,c) #LCM of a and c\\n        abc = math.lcm(ab,c) #LCM of a, b, and c\\n        \\n        left, right = 1, (2 * 10**9)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if countUglyNumbers(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        #Condition: Are there at least n ugly numbers smaller than or equal to value?\\n        def countUglyNumbers(value):\\n            count = (value//a) + (value//b) + (value//c) + (value//abc)\\n            count -= ((value//ab) + (value//bc) + (value//ac))\\n            return count >= n\\n\\n        ab = math.lcm(a,b) #LCM of a and b\\n        bc = math.lcm(b,c) #LCM of b and c\\n        ac = math.lcm(a,c) #LCM of a and c\\n        abc = math.lcm(ab,c) #LCM of a, b, and c\\n        \\n        left, right = 1, (2 * 10**9)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if countUglyNumbers(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531879,
                "title": "gcd-and-lcm-search-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor this problem, we are looking for the nth ugly numbers of three factors. We can do this by considering the combination of greatest common denominators and least common multiples. We will then search within this range and find the location of the nth ugly number by considering the value of the sum of nth ugly numbers of each factor at a value and then discount this by the sum of the least common multiples of the factors and increment by any joint least common multiple. \\n\\nIn this way we \\n- get how many nth ugly numbers of each factor at a given value \\n- reduce this by any matching ugly numbers of each factor by their least common multiples \\n- increase this by any triple matching ugly numbers of all factors least common multiple (since we already took these out in the prior step) \\n\\nFrom this it can be seen that we can binarily search for the correct lower bound of our valuation appropriately \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSome edge cases can be considered to speed up our search \\nFirst if we have n = 1, we can simply return the min of our factors \\n\\nSecondly, we can consider ways to reduce our number of factors via modulo comparisons. This can get us down to 2 or even 1 factor! If we can, we can of course speed up our process as well. \\n\\nFinally, we can get the least of our factors to determine if it is 1. If it is, we can simply return n. \\n\\nIn all other cases, we will proceed to solve. \\nUsing our above consideration, our count ugly numbers function takes a mid bound value to consider in binary searching. With it \\n- determine the number of single factor ugly numbers by factor and sum them up \\n- determine the number of two factor least common multiple ugly numbers and sum them up. For this, we leave off the last entry for either the case of only two factors, in which the final number is zero, or the case where we have three factors, in which case it is the least common multiple of all three factors\\n- Determine the number of three factor least common multiple ugly numbers either accordingly if we have three factors or set to zero otherwise \\n- return the value of the single factor ugly numbers minus the two factor least common multiple ugly numbers so we do not overcount plus the three factor least common multiple ugly numbers so we do not remove too many \\n\\nif our length of factors is two, \\n- set up a, b as factors \\n- set self.factors to [a, b] \\n- set self.lcms to [a * b // gcd (a, b), 0]\\n\\nif our length of factors is three, \\n- set up self.factors as list cast of factors \\n- set up self.lcms as above for a,b with (a,b), (a, c), and (b,c), then instead of 0 use a, b, c and gcd of a, b, c\\n\\nlower bound must be at least n - least factor * least factor // 2 or least factor * 2, whichever is greater. \\n\\nupper bound must be min of least factor by n or 2 * 10**9 \\n\\nWhile conducting binary search \\n- if count ugly numbers at mid bound is greater than or equal to n \\n    - move upper bound down to mid bound minus 1 \\n- otherwise \\n    - move lower bound up to mid bound + 1 \\n\\nwhen done return lower bound    \\n\\n# Complexity\\n- Time complexity : O (log (N))\\n    - We conduct binary search over N numbers, in log N time \\n        - in which we conduct O(1) operations with stored values  \\n\\n- Space complexity : O (1)\\n    - We are non-recursive and use no large data structures. O(1) \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int :\\n        # edge case for n == 1 \\n        if n == 1 : \\n            return min(a, b, c)\\n\\n        # determine modular relationships \\n        # if a mod b is 0 or a mod c is zero a is b -> a mod b == 0 -> implies b is subfactor of a, and so will reach sooner \\n        #                                              a mod c == 0 -> implies c is subfactor of a, and so will reach sooner  \\n        if a % b == 0 or a % c == 0:\\n            a = b\\n        # similar for other relationships \\n        if b % a == 0 or b % c == 0:\\n            b = a\\n        # note that after testing first, if a % b was equal to 0, b % a will be 0 as well. \\n        # However, if a % c was 0, and then b % c was zero, they are all now the same     \\n        if c % a == 0 or c % b == 0:\\n            c = b\\n\\n        # if a == b == c -> return n * a \\n        if a == b == c:\\n            return n * a\\n\\n        # reduce factors down to set cast of their list \\n        factors = set([a, b, c])\\n        # get least factor \\n        least_factor = min(factors)\\n\\n        # if least is 1, return n \\n        if least_factor == 1 : \\n            return n \\n\\n        # to count ugly numbers before some bound with 3 factors \\n        # find the number of single factor ugly numbers up to mid bound for each factor \\n        # find the number of two factor least common multiple ugly numbers for each factor pair -> we overcounted by these\\n        # find the number of three factor least common multiple ugly numbers for all factor pairs -> we took too many of these away \\n        # we thus want the number of single factor ugly numbers less the two factor lcm ugly numbers plus the three factor lcm ugly numbers \\n        def count_ugly_numbers(mid_bound) :\\n            # get number of single factor ugly numbers \\n            number_of_factor_ugly_numbers = 0\\n            for factor in self.factors : \\n                number_of_factor_ugly_numbers += mid_bound//factor\\n\\n            # get number of two factor ugly numbers \\n            number_of_two_factor_least_common_multiple_ugly_numbers = 0\\n            for lcm in self.lcms[:-1] : \\n                number_of_two_factor_least_common_multiple_ugly_numbers += mid_bound//lcm\\n            \\n            # get number of triple factor ugly numbers if possible, else get 0  \\n            number_of_three_factor_least_common_multiple_ugly_numbers  = mid_bound // self.lcms[-1] if self.lcms[-1] != 0 else 0 \\n            \\n            return number_of_factor_ugly_numbers - number_of_two_factor_least_common_multiple_ugly_numbers - number_of_three_factor_least_common_multiple_ugly_numbers  \\n\\n        # if length of set is 2 \\n        if len(factors) == 2 :\\n            # set a and b appropriately \\n            a, b = factors\\n            # set up factors and least common multiples \\n            self.factors = [a, b]\\n            self.lcms = [(a*b)//(gcd(a, b)), 0]\\n        else : \\n            # otherwise, set up to use 3 factors \\n            self.factors = list(factors)\\n            self.lcms = [(a*b)//(gcd(a,b)), (a*c)//(gcd(a, c)), (b*c)//(gcd(b,c)), (a*b*c)//(gcd(a, b, c))]\\n\\n\\n        # set lower bound as n - least factor * (least factor // 2)\\n        # we know it\\'s not 1 -> this means the least it can be is n - least factor * least factor // 2 -> \\n        # it is at least n - least factor as smallest upper value. Then it is at least least factor // 2 away from this value \\n        # this is because we need to have at least that much as this size. In the case this is 0 or less, we can also use least factor * 2 since n is at least not 1. \\n        # set upper bound as least factor * n or 2 * 10**9, whichever is smaller -> gauranteed to be in 2 * 10 ** 9 \\n        # the bounds are searching for the nth ugly number \\n        lower_bound = max((n-least_factor) * (least_factor//2), least_factor*2) \\n        upper_bound = min(least_factor * n, 2 * 10 ** 9)\\n\\n        # while lower less than equal to upper bound \\n        while lower_bound <= upper_bound :\\n            # find mid bound as mid point of upper and lower bound \\n            mid_bound = (lower_bound + upper_bound) // 2\\n            # if number of ugly numbers at mid bound is gte n -> upper bound needs to reduce \\n            if count_ugly_numbers(mid_bound) >= n :\\n                upper_bound = mid_bound - 1\\n            else:\\n                # otherwise, lower bound needs to increase \\n                lower_bound = mid_bound + 1\\n\\n        # return lower bound \\n        return lower_bound\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int :\\n        # edge case for n == 1 \\n        if n == 1 : \\n            return min(a, b, c)\\n\\n        # determine modular relationships \\n        # if a mod b is 0 or a mod c is zero a is b -> a mod b == 0 -> implies b is subfactor of a, and so will reach sooner \\n        #                                              a mod c == 0 -> implies c is subfactor of a, and so will reach sooner  \\n        if a % b == 0 or a % c == 0:\\n            a = b\\n        # similar for other relationships \\n        if b % a == 0 or b % c == 0:\\n            b = a\\n        # note that after testing first, if a % b was equal to 0, b % a will be 0 as well. \\n        # However, if a % c was 0, and then b % c was zero, they are all now the same     \\n        if c % a == 0 or c % b == 0:\\n            c = b\\n\\n        # if a == b == c -> return n * a \\n        if a == b == c:\\n            return n * a\\n\\n        # reduce factors down to set cast of their list \\n        factors = set([a, b, c])\\n        # get least factor \\n        least_factor = min(factors)\\n\\n        # if least is 1, return n \\n        if least_factor == 1 : \\n            return n \\n\\n        # to count ugly numbers before some bound with 3 factors \\n        # find the number of single factor ugly numbers up to mid bound for each factor \\n        # find the number of two factor least common multiple ugly numbers for each factor pair -> we overcounted by these\\n        # find the number of three factor least common multiple ugly numbers for all factor pairs -> we took too many of these away \\n        # we thus want the number of single factor ugly numbers less the two factor lcm ugly numbers plus the three factor lcm ugly numbers \\n        def count_ugly_numbers(mid_bound) :\\n            # get number of single factor ugly numbers \\n            number_of_factor_ugly_numbers = 0\\n            for factor in self.factors : \\n                number_of_factor_ugly_numbers += mid_bound//factor\\n\\n            # get number of two factor ugly numbers \\n            number_of_two_factor_least_common_multiple_ugly_numbers = 0\\n            for lcm in self.lcms[:-1] : \\n                number_of_two_factor_least_common_multiple_ugly_numbers += mid_bound//lcm\\n            \\n            # get number of triple factor ugly numbers if possible, else get 0  \\n            number_of_three_factor_least_common_multiple_ugly_numbers  = mid_bound // self.lcms[-1] if self.lcms[-1] != 0 else 0 \\n            \\n            return number_of_factor_ugly_numbers - number_of_two_factor_least_common_multiple_ugly_numbers - number_of_three_factor_least_common_multiple_ugly_numbers  \\n\\n        # if length of set is 2 \\n        if len(factors) == 2 :\\n            # set a and b appropriately \\n            a, b = factors\\n            # set up factors and least common multiples \\n            self.factors = [a, b]\\n            self.lcms = [(a*b)//(gcd(a, b)), 0]\\n        else : \\n            # otherwise, set up to use 3 factors \\n            self.factors = list(factors)\\n            self.lcms = [(a*b)//(gcd(a,b)), (a*c)//(gcd(a, c)), (b*c)//(gcd(b,c)), (a*b*c)//(gcd(a, b, c))]\\n\\n\\n        # set lower bound as n - least factor * (least factor // 2)\\n        # we know it\\'s not 1 -> this means the least it can be is n - least factor * least factor // 2 -> \\n        # it is at least n - least factor as smallest upper value. Then it is at least least factor // 2 away from this value \\n        # this is because we need to have at least that much as this size. In the case this is 0 or less, we can also use least factor * 2 since n is at least not 1. \\n        # set upper bound as least factor * n or 2 * 10**9, whichever is smaller -> gauranteed to be in 2 * 10 ** 9 \\n        # the bounds are searching for the nth ugly number \\n        lower_bound = max((n-least_factor) * (least_factor//2), least_factor*2) \\n        upper_bound = min(least_factor * n, 2 * 10 ** 9)\\n\\n        # while lower less than equal to upper bound \\n        while lower_bound <= upper_bound :\\n            # find mid bound as mid point of upper and lower bound \\n            mid_bound = (lower_bound + upper_bound) // 2\\n            # if number of ugly numbers at mid bound is gte n -> upper bound needs to reduce \\n            if count_ugly_numbers(mid_bound) >= n :\\n                upper_bound = mid_bound - 1\\n            else:\\n                # otherwise, lower bound needs to increase \\n                lower_bound = mid_bound + 1\\n\\n        # return lower bound \\n        return lower_bound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486838,
                "title": "javascript-1201-ugly-number-iii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\\nconst lcm = (a, b) => (a * b) / gcd(a, b);\\nconst div = (n, a) => ~~(n / a); // count of nums in [0,n] divisible by a\\nconst divisibleByABorC = (n, a, b, c) => {\\n    let s = div(n, a) + div(n, b) + div(n, c);\\n    let s2 = div(n, lcm(a, b)) + div(n, lcm(b, c)) + div(n, lcm(c, a));\\n    let s3 = div(n, lcm(lcm(a, b), c));\\n    return s - s2 + s3; // principle of inclusion and exclusion\\n};\\nvar nthUglyNumber = function (target, a, b, c) {\\n    let L = 1;\\n    let R = 2 * 10 ** 9; // result will be in range [1, 2 * 10**9]\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        divisibleByABorC(mid, a, b, c) < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n};\\n```\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\\nconst lcm = (a, b) => (a * b) / gcd(a, b);\\nconst div = (n, a) => ~~(n / a); // count of nums in [0,n] divisible by a\\nconst divisibleByABorC = (n, a, b, c) => {\\n    let s = div(n, a) + div(n, b) + div(n, c);\\n    let s2 = div(n, lcm(a, b)) + div(n, lcm(b, c)) + div(n, lcm(c, a));\\n    let s3 = div(n, lcm(lcm(a, b), c));\\n    return s - s2 + s3; // principle of inclusion and exclusion\\n};\\nvar nthUglyNumber = function (target, a, b, c) {\\n    let L = 1;\\n    let R = 2 * 10 ** 9; // result will be in range [1, 2 * 10**9]\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        divisibleByABorC(mid, a, b, c) < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486390,
                "title": "swift-binary-search-using-lcm-readable-and-commented",
                "content": "# Complexity\\n- Time complexity: $$O(log(n*w))$$, where $$w$$ is $$min(a, b, c)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func nthUglyNumber(_ n: Int, _ a: Int, _ b: Int, _ c: Int) -> Int\\n    {\\n        // since a might be multiple of b or c, or the other way round,\\n        // we need the help of least common multiple to avoid counting duplicate numbers\\n        let lcmAB = lcm(a, b), lcmAC = lcm(a, c), lcmBC = lcm(b, c), lcmABC = lcm(lcmAB, c)\\n\\n        // binary search for the smallest integer satisfying the condition\\n        // \"count of all ugly numbers less than or equal to it is at least n\"\\n        var low = min(a, b, c) * n / 3\\n        var high = min(a, b, c) * n\\n        var mid: Int\\n        while low < high\\n        {\\n            mid = (low + high) / 2\\n            if uglyCount(for: mid) >= n {\\n                high = mid\\n            }\\n            else {\\n                low = mid + 1\\n            }\\n        }\\n\\n        // count of all ugly numbers less than or equal to x\\n        func uglyCount(for x: Int) -> Int\\n        {\\n            (x/a + x/b + x/c) -              // all multiples of a, b, c up to x\\n            (x/lcmAB + x/lcmAC + x/lcmBC) +  // subtract those that have been counted twice\\n             x/lcmABC                        // add back the twice subtracted\\n        }\\n\\n        return low\\n    }\\n}\\n\\n// least common multiple\\nfunc lcm(_ x: Int, _ y: Int) -> Int {\\n    return x * y / gcd(x, y)\\n}\\n\\n// greatest common divisor, Euclidean algorithm\\nfunc gcd(_ x: Int, _ y: Int) -> Int\\n{\\n    let rem = x % y\\n    if rem == 0 { return y }\\n    else { return gcd(y, rem) }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    func nthUglyNumber(_ n: Int, _ a: Int, _ b: Int, _ c: Int) -> Int\\n    {\\n        // since a might be multiple of b or c, or the other way round,\\n        // we need the help of least common multiple to avoid counting duplicate numbers\\n        let lcmAB = lcm(a, b), lcmAC = lcm(a, c), lcmBC = lcm(b, c), lcmABC = lcm(lcmAB, c)\\n\\n        // binary search for the smallest integer satisfying the condition\\n        // \"count of all ugly numbers less than or equal to it is at least n\"\\n        var low = min(a, b, c) * n / 3\\n        var high = min(a, b, c) * n\\n        var mid: Int\\n        while low < high\\n        {\\n            mid = (low + high) / 2\\n            if uglyCount(for: mid) >= n {\\n                high = mid\\n            }\\n            else {\\n                low = mid + 1\\n            }\\n        }\\n\\n        // count of all ugly numbers less than or equal to x\\n        func uglyCount(for x: Int) -> Int\\n        {\\n            (x/a + x/b + x/c) -              // all multiples of a, b, c up to x\\n            (x/lcmAB + x/lcmAC + x/lcmBC) +  // subtract those that have been counted twice\\n             x/lcmABC                        // add back the twice subtracted\\n        }\\n\\n        return low\\n    }\\n}\\n\\n// least common multiple\\nfunc lcm(_ x: Int, _ y: Int) -> Int {\\n    return x * y / gcd(x, y)\\n}\\n\\n// greatest common divisor, Euclidean algorithm\\nfunc gcd(_ x: Int, _ y: Int) -> Int\\n{\\n    let rem = x % y\\n    if rem == 0 { return y }\\n    else { return gcd(y, rem) }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453814,
                "title": "basic-math-and-binary-search-solution-beats-100-cpp",
                "content": "# Intuition and Approach\\n* the ans lies in between [min(a,b,c),n*min(a,b,c)].\\n* find gcd of each pair of a,b,c and whole of three.\\n* now l=min(a,b,c) and r=n*min(a,b,c). apply binary seach on it.\\n* use the formula aUbUc=a+b+c-ab-bc-ca+abc.\\n* take care of conditions when gcd of pairs is greater then one(**remove the repeating part).\\n* at the end return the ans.\\n\\n# Complexity\\n- Time complexity: log(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        long long a=a1;\\n        long long b=b1;\\n        long long c=c1;\\n        long long l=min(a,min(b,c));\\n        long long r=l*n;\\n        long long ab=__gcd(a,b);\\n        long long bc=__gcd(b,c);\\n        long long ca=__gcd(c,a);\\n        long long abc=__gcd(ab,bc);\\n        while(l<r){\\n            long long mid=(l+r)/2;\\n            long long cnt=0;\\n            cnt+=mid/a;\\n            cnt+=mid/b;\\n            cnt+=mid/c;\\n            cnt-=mid/((a*b)/ab);\\n            cnt-=mid/((b*c)/bc);\\n            cnt-=mid/((c*a)/ca);\\n            cnt+=mid/(((((c*a*b)/ab)/ca)/bc)*abc);\\n            if(cnt<n){\\n                l=mid+1;\\n            }\\n            else {\\n                r=mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        long long a=a1;\\n        long long b=b1;\\n        long long c=c1;\\n        long long l=min(a,min(b,c));\\n        long long r=l*n;\\n        long long ab=__gcd(a,b);\\n        long long bc=__gcd(b,c);\\n        long long ca=__gcd(c,a);\\n        long long abc=__gcd(ab,bc);\\n        while(l<r){\\n            long long mid=(l+r)/2;\\n            long long cnt=0;\\n            cnt+=mid/a;\\n            cnt+=mid/b;\\n            cnt+=mid/c;\\n            cnt-=mid/((a*b)/ab);\\n            cnt-=mid/((b*c)/bc);\\n            cnt-=mid/((c*a)/ca);\\n            cnt+=mid/(((((c*a*b)/ab)/ca)/bc)*abc);\\n            if(cnt<n){\\n                l=mid+1;\\n            }\\n            else {\\n                r=mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452627,
                "title": "easy-to-understand-faster-simple-python-solution",
                "content": "\\n\\n# Code\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def num_of_ugly_below(val):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm_ab) - (val // lcm_bc) - (val // lcm_ca) + (val // lcm_abc)\\n        \\n        def get_lcm(*vals):\\n            res = vals[0]\\n            for i in range(1, len(vals)):\\n                res = res * vals[i] // gcd(res, vals[i])\\n            return res\\n        \\n        lcm_ab, lcm_bc, lcm_ca, lcm_abc = get_lcm(a, b), get_lcm(b, c), get_lcm(c, a), get_lcm(a, b, c)\\n        \\n        #binary search\\n        l, r = 1, min(a, b, c) * n\\n        while l < r:\\n            mid = (l + r) // 2\\n            if num_of_ugly_below(mid) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def num_of_ugly_below(val):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm_ab) - (val // lcm_bc) - (val // lcm_ca) + (val // lcm_abc)\\n        \\n        def get_lcm(*vals):\\n            res = vals[0]\\n            for i in range(1, len(vals)):\\n                res = res * vals[i] // gcd(res, vals[i])\\n            return res\\n        \\n        lcm_ab, lcm_bc, lcm_ca, lcm_abc = get_lcm(a, b), get_lcm(b, c), get_lcm(c, a), get_lcm(a, b, c)\\n        \\n        #binary search\\n        l, r = 1, min(a, b, c) * n\\n        while l < r:\\n            mid = (l + r) // 2\\n            if num_of_ugly_below(mid) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442999,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar nthUglyNumber = function(n, a, b, c) {\\n    const gcd = (a, b) => a === 0 ? b : gcd(b % a, a);\\n    const lcm = (a, b) => a * b / gcd(a, b);\\n    const lcmAB = lcm(a, b);\\n    const lcmBC = lcm(b, c);\\n    const lcmAC = lcm(a, c);\\n    const lcmABC = lcm(lcmAB, c);\\n    let low = 1;\\n    let high = 2 * 10 ** 9;\\n\\n    while (low < high) {\\n        const mid = Math.floor((low + high) / 2);\\n        const countA = Math.floor(mid / a);\\n        const countB = Math.floor(mid / b);\\n        const countC = Math.floor(mid / c);\\n        const countAB = Math.floor(mid / lcmAB);\\n        const countBC = Math.floor(mid / lcmBC);\\n        const countAC = Math.floor(mid / lcmAC);\\n        const countABC = Math.floor(mid / lcmABC);\\n        const count = countA + countB + countC - countAB - countBC - countAC + countABC;\\n\\n        count < n ? low = mid + 1 : high = mid;\\n    }\\n    return low;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nthUglyNumber = function(n, a, b, c) {\\n    const gcd = (a, b) => a === 0 ? b : gcd(b % a, a);\\n    const lcm = (a, b) => a * b / gcd(a, b);\\n    const lcmAB = lcm(a, b);\\n    const lcmBC = lcm(b, c);\\n    const lcmAC = lcm(a, c);\\n    const lcmABC = lcm(lcmAB, c);\\n    let low = 1;\\n    let high = 2 * 10 ** 9;\\n\\n    while (low < high) {\\n        const mid = Math.floor((low + high) / 2);\\n        const countA = Math.floor(mid / a);\\n        const countB = Math.floor(mid / b);\\n        const countC = Math.floor(mid / c);\\n        const countAB = Math.floor(mid / lcmAB);\\n        const countBC = Math.floor(mid / lcmBC);\\n        const countAC = Math.floor(mid / lcmAC);\\n        const countABC = Math.floor(mid / lcmABC);\\n        const count = countA + countB + countC - countAB - countBC - countAC + countABC;\\n\\n        count < n ? low = mid + 1 : high = mid;\\n    }\\n    return low;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3404295,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong int gcd(int a , int b)\\n{\\n    if(a==0)\\n    return b;\\n    else return gcd(b%a,a);\\n}\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n       long long  int l =  1 , h = min({a,b,c})*n , mid , ans;\\n       long long int  lcmab =  (long long )a*(long long)b/gcd(a,b);\\n       long long int  lcmbc =  (long long )b*(long long)c/gcd(b,c);\\n       long long int  lcmac =  (long long )a*(long long)c/gcd(a,c);\\n       long long int  lcmabc =   lcmab*c/gcd(lcmab,c);\\n\\n       \\n\\n        while(l<=h)\\n        {\\n            mid = (l+h)/2;\\n            int count =   mid/a + mid/b + mid/c - mid/lcmab - mid/lcmbc - mid/lcmac + mid/lcmabc; \\n\\n\\n            if(count>=n)\\n            {\\n                ans = mid; \\n                h = mid -1; \\n            }\\n            else  l = mid +1; \\n\\n\\n        }\\n        return  ans; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong int gcd(int a , int b)\\n{\\n    if(a==0)\\n    return b;\\n    else return gcd(b%a,a);\\n}\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n       long long  int l =  1 , h = min({a,b,c})*n , mid , ans;\\n       long long int  lcmab =  (long long )a*(long long)b/gcd(a,b);\\n       long long int  lcmbc =  (long long )b*(long long)c/gcd(b,c);\\n       long long int  lcmac =  (long long )a*(long long)c/gcd(a,c);\\n       long long int  lcmabc =   lcmab*c/gcd(lcmab,c);\\n\\n       \\n\\n        while(l<=h)\\n        {\\n            mid = (l+h)/2;\\n            int count =   mid/a + mid/b + mid/c - mid/lcmab - mid/lcmbc - mid/lcmac + mid/lcmabc; \\n\\n\\n            if(count>=n)\\n            {\\n                ans = mid; \\n                h = mid -1; \\n            }\\n            else  l = mid +1; \\n\\n\\n        }\\n        return  ans; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394666,
                "title": "c-easy-to-understand-binary-search-math",
                "content": "# Code\\n```\\ntypedef long long ll;\\n#define MAX_ANS 2e9\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left =0,right = MAX_ANS;\\n        int result =0;\\n        while(left<=right){\\n            int mid = left+(right-left)/2;\\n            if(count(mid,a,b,c)>=n){\\n                result = mid;\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num,ll a,ll b,ll c){\\n        return (int)(num/a+num/b+num/c-num/lcm(a,b)-num/lcm(b,c)-num/lcm(a,c)+num/(lcm(a,lcm(b,c))));\\n    }\\n\\n    ll gcd(ll a,ll b){\\n        if(a==0)\\n          return b;\\n        return gcd(b%a,a);\\n    }\\n    ll lcm(ll a,ll b){\\n        return a*b/gcd(a,b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\n#define MAX_ANS 2e9\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left =0,right = MAX_ANS;\\n        int result =0;\\n        while(left<=right){\\n            int mid = left+(right-left)/2;\\n            if(count(mid,a,b,c)>=n){\\n                result = mid;\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num,ll a,ll b,ll c){\\n        return (int)(num/a+num/b+num/c-num/lcm(a,b)-num/lcm(b,c)-num/lcm(a,c)+num/(lcm(a,lcm(b,c))));\\n    }\\n\\n    ll gcd(ll a,ll b){\\n        if(a==0)\\n          return b;\\n        return gcd(b%a,a);\\n    }\\n    ll lcm(ll a,ll b){\\n        return a*b/gcd(a,b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362768,
                "title": "easiest-java-solution",
                "content": "\\n\\n# Code\\n```\\n//just tried to explain as much as I can. Upvote if it helped. thanks\\nclass Solution {\\n  \\n    long lcmOfAC;\\n    long lcmOfAB;\\n    long lcmOfBC;\\n    long lcmOfABC;\\n  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n      lcmOfAC  = lcm(a,c);\\n      lcmOfAB  = lcm(a,b);\\n      lcmOfBC  = lcm(b,c);\\n      lcmOfABC = lcm(a,lcmOfBC);\\n      \\n      int left = 1;\\n      int right = Integer.MAX_VALUE;\\n      \\n      \\n      //how BS works here: If our count of ugly numbers before the value of \\'mid\\'\\n      //is greater or equal we decrease right. \\n      //And when we have exactly \\'n-1\\' on the left side, our answer is \\'left\\', \\n      //meaning that left is the number which is at ((n-1)+1) th position.\\n      \\n      \\n      /// MOST IMPORTANT THING TO UNDERSTAND HERE IS: HOW DOES HOW MANY UGLY NUMBERS ARE THERE BEFORE \\'MID\\' GIVES THE NTH UGLY NUMBER??? WE ARE JUST COUNTING NUMBERS RIGHT?? HOW DOES IT EVEN WORK??\\n      /*\\n        LET ME EXPLAIN: FOR EXAMPLE TEST-CASE 1: \\n        \\n        N = 3, A = 2, B = 3, C = 5. CLEAR HERE.\\n        \\n        NOW TAKE A SERIES OF N NATURAL NUMBERS. LIKE:\\n        \\n        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21...\\n        \\n        NOW FOR 2 IT\\'S: 2 4 6 8 10 12 14 16...\\n                 FOR 3: 3 6 9 12 15 18\\n                 FOR 5: 5 10 15 20 25.....\\n                 \\n        //WITH THIS LINE: long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;        \\n        //WE ARE ADDING EVERY UNIQUE MULTIPLE OF ALL OF THE THREE ONLY ONE TIME.\\n        \\n        //SO OUR FINAL N-NATURAL NUMBER SERIES BECOMES:  //EVERY DUPLICATE IS REMOVED.\\n          1, 2, 3, 4, 5, 6, 8, 9, 10... (SAME AS PROVIDED IN TEST CASE) //EVERY NUMBER IS UNIQUE AND INCREASING. //ONE IS INCLUDED BECAUSE LEFT = 1.\\n          \\n        //KEEP-IN-MIND, BY COUNTING WE ARE SAYING - HOW MANY UGLY NUMBERS APPEAR BEFORE THIS \\'MID\\'\\n        // WE ARE SAYING IF THERE ARE \"n-1\" UGLY NUMBERS BEFORE THAN \"n\" IS OUR ANSWER. HERE \"LEFT\" IS THAT \"N\"\\n\\n        // SO IF OUR MID IS FINALLY AT LET SAY \\'5\\', WE DECREASE OUR RIGHT TO \\'MID\\' (RIGHT = MID),\\n        // BECAUSE TOTAL NUMBERS BEFORE 5 ARE 3 (1,2,3,4).\\n        \\n        //THIS PROCESS KEEPS GOING UNTIL MID IS AT 3, AND COUNT < N WHICH MEANS LEFT = MID+1 (3+1) = 4;\\n        \\n        //TRY TO THINK IN YOUR WAY A LITTLE MORE IF YOU STILL DON\\'T GET IT.\\n          \\n      */\\n      \\n      \\n      \\n      while(left<right){\\n        \\n        int mid = left+(right-left)/2;\\n\\n        if(count(mid, a, b, c, n)){\\n          right = mid;\\n        }\\n        \\n        else\\n          left = mid+1;        \\n      }\\n      \\n      return left;      \\n    }\\n  \\n   \\n    \\n    boolean count(long mid, long a, long b, long c, long n){\\n      \\n      \\n\\t\\t/*\\n\\t\\t*   mid/a = total number of multiples \\'a\\' till chosen \\'mid\\'. //same for \\'b\\' and \\'c\\'.\\n\\t\\t*  \\n\\t\\t*   mid/lcm(a,b) = total number of duplicate multiples that appear for series of \\'a\\' and \\'b\\'  // same for (b,c) & (c,a)      \\n\\t\\t*   \\n\\t\\t*   now because we subtract all the common mulitples  that appear for all three \\'a\\' & \\'b\\' & \\'c\\'\\n\\n\\t\\t*   we\\'ll have to again add those who appear in all three series again (check below comment)\\n\\t\\t*/      \\n\\t\\t /* example: \\n\\n\\t\\t\\t\\tfor 2:- 2 4 6 8 10 12 14\\n\\t\\t\\t\\tfor 3:- 3 9 12 15 18 21\\n\\t\\t\\t\\tfor 4:- 4 8 12\\n\\n\\t\\t\\t\\t//now notice that \\'12\\' is common in all of them, it should be counted only \\'once\\', not \\'thrice\\'.\\n\\t\\t\\t\\t// same goes for \\'4\\', it appeared 2 times, we want to count only \\'one\\' time.\\n\\n\\t\\t\\t\\t// this is why we subtracted  all common duplicates first, then lastly add the lcm(a,lcm(b,c)) //simply say -  lcm(a,b,c)\\n\\t\\t\\t\\t// we do this last \\'add\\' step because we have already subtracted all duplicates that are common.\\n\\t\\t\\t\\t// so to add those who are common in \"all three series\" (like 12 here), we do this last  \\'+ lcm(a,b,c)\\' step.\\n\\t\\t*/\\n\\t\\t\\n     \\n      long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;\\n      \\n      return total >= n;\\n      \\n    }\\n  \\n  \\n    static long gcd(long a,long b){\\n      while(b>0){\\n        a%=b;\\n        //swap\\n        long temp = a;\\n        a = b;\\n        b = temp;\\n      }\\n      return a;\\n    }\\n\\n    static long lcm(long a, long b){\\n      \\n      return a/gcd(a,b)*b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//just tried to explain as much as I can. Upvote if it helped. thanks\\nclass Solution {\\n  \\n    long lcmOfAC;\\n    long lcmOfAB;\\n    long lcmOfBC;\\n    long lcmOfABC;\\n  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n      lcmOfAC  = lcm(a,c);\\n      lcmOfAB  = lcm(a,b);\\n      lcmOfBC  = lcm(b,c);\\n      lcmOfABC = lcm(a,lcmOfBC);\\n      \\n      int left = 1;\\n      int right = Integer.MAX_VALUE;\\n      \\n      \\n      //how BS works here: If our count of ugly numbers before the value of \\'mid\\'\\n      //is greater or equal we decrease right. \\n      //And when we have exactly \\'n-1\\' on the left side, our answer is \\'left\\', \\n      //meaning that left is the number which is at ((n-1)+1) th position.\\n      \\n      \\n      /// MOST IMPORTANT THING TO UNDERSTAND HERE IS: HOW DOES HOW MANY UGLY NUMBERS ARE THERE BEFORE \\'MID\\' GIVES THE NTH UGLY NUMBER??? WE ARE JUST COUNTING NUMBERS RIGHT?? HOW DOES IT EVEN WORK??\\n      /*\\n        LET ME EXPLAIN: FOR EXAMPLE TEST-CASE 1: \\n        \\n        N = 3, A = 2, B = 3, C = 5. CLEAR HERE.\\n        \\n        NOW TAKE A SERIES OF N NATURAL NUMBERS. LIKE:\\n        \\n        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21...\\n        \\n        NOW FOR 2 IT\\'S: 2 4 6 8 10 12 14 16...\\n                 FOR 3: 3 6 9 12 15 18\\n                 FOR 5: 5 10 15 20 25.....\\n                 \\n        //WITH THIS LINE: long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;        \\n        //WE ARE ADDING EVERY UNIQUE MULTIPLE OF ALL OF THE THREE ONLY ONE TIME.\\n        \\n        //SO OUR FINAL N-NATURAL NUMBER SERIES BECOMES:  //EVERY DUPLICATE IS REMOVED.\\n          1, 2, 3, 4, 5, 6, 8, 9, 10... (SAME AS PROVIDED IN TEST CASE) //EVERY NUMBER IS UNIQUE AND INCREASING. //ONE IS INCLUDED BECAUSE LEFT = 1.\\n          \\n        //KEEP-IN-MIND, BY COUNTING WE ARE SAYING - HOW MANY UGLY NUMBERS APPEAR BEFORE THIS \\'MID\\'\\n        // WE ARE SAYING IF THERE ARE \"n-1\" UGLY NUMBERS BEFORE THAN \"n\" IS OUR ANSWER. HERE \"LEFT\" IS THAT \"N\"\\n\\n        // SO IF OUR MID IS FINALLY AT LET SAY \\'5\\', WE DECREASE OUR RIGHT TO \\'MID\\' (RIGHT = MID),\\n        // BECAUSE TOTAL NUMBERS BEFORE 5 ARE 3 (1,2,3,4).\\n        \\n        //THIS PROCESS KEEPS GOING UNTIL MID IS AT 3, AND COUNT < N WHICH MEANS LEFT = MID+1 (3+1) = 4;\\n        \\n        //TRY TO THINK IN YOUR WAY A LITTLE MORE IF YOU STILL DON\\'T GET IT.\\n          \\n      */\\n      \\n      \\n      \\n      while(left<right){\\n        \\n        int mid = left+(right-left)/2;\\n\\n        if(count(mid, a, b, c, n)){\\n          right = mid;\\n        }\\n        \\n        else\\n          left = mid+1;        \\n      }\\n      \\n      return left;      \\n    }\\n  \\n   \\n    \\n    boolean count(long mid, long a, long b, long c, long n){\\n      \\n      \\n\\t\\t/*\\n\\t\\t*   mid/a = total number of multiples \\'a\\' till chosen \\'mid\\'. //same for \\'b\\' and \\'c\\'.\\n\\t\\t*  \\n\\t\\t*   mid/lcm(a,b) = total number of duplicate multiples that appear for series of \\'a\\' and \\'b\\'  // same for (b,c) & (c,a)      \\n\\t\\t*   \\n\\t\\t*   now because we subtract all the common mulitples  that appear for all three \\'a\\' & \\'b\\' & \\'c\\'\\n\\n\\t\\t*   we\\'ll have to again add those who appear in all three series again (check below comment)\\n\\t\\t*/      \\n\\t\\t /* example: \\n\\n\\t\\t\\t\\tfor 2:- 2 4 6 8 10 12 14\\n\\t\\t\\t\\tfor 3:- 3 9 12 15 18 21\\n\\t\\t\\t\\tfor 4:- 4 8 12\\n\\n\\t\\t\\t\\t//now notice that \\'12\\' is common in all of them, it should be counted only \\'once\\', not \\'thrice\\'.\\n\\t\\t\\t\\t// same goes for \\'4\\', it appeared 2 times, we want to count only \\'one\\' time.\\n\\n\\t\\t\\t\\t// this is why we subtracted  all common duplicates first, then lastly add the lcm(a,lcm(b,c)) //simply say -  lcm(a,b,c)\\n\\t\\t\\t\\t// we do this last \\'add\\' step because we have already subtracted all duplicates that are common.\\n\\t\\t\\t\\t// so to add those who are common in \"all three series\" (like 12 here), we do this last  \\'+ lcm(a,b,c)\\' step.\\n\\t\\t*/\\n\\t\\t\\n     \\n      long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;\\n      \\n      return total >= n;\\n      \\n    }\\n  \\n  \\n    static long gcd(long a,long b){\\n      while(b>0){\\n        a%=b;\\n        //swap\\n        long temp = a;\\n        a = b;\\n        b = temp;\\n      }\\n      return a;\\n    }\\n\\n    static long lcm(long a, long b){\\n      \\n      return a/gcd(a,b)*b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307928,
                "title": "c",
                "content": "```\\nclass Solution {\\n    long long LCM(int a, int b){\\n        long long ret = 1 ;\\n        return ret * a * b/gcd(a, b) ;\\n    }\\n        \\n    long long helper(int val, int x, int y, int z){\\n        int a = val/x ;\\n        int b = val/y ;\\n        int c = val/z ;\\n        int ab = val/LCM(x,y) ;\\n        int bc = val/LCM(y,z) ;\\n        int ac = val/LCM(x,z) ;\\n        int abc = val/LCM(LCM(x,y), z) ;\\n        return (long long)a + b + c - ab - bc - ac + abc ;\\n    }\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 1 , right = INT_MAX ;   \\n        while(left < right){\\n            int mid = left + (right - left)/2 ;\\n            long long k = helper(mid, a, b, c) ;\\n            if(k >= n)\\n                right = mid ;\\n            else\\n                left = mid + 1 ;\\n        }\\n        return left ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long LCM(int a, int b){\\n        long long ret = 1 ;\\n        return ret * a * b/gcd(a, b) ;\\n    }\\n        \\n    long long helper(int val, int x, int y, int z){\\n        int a = val/x ;\\n        int b = val/y ;\\n        int c = val/z ;\\n        int ab = val/LCM(x,y) ;\\n        int bc = val/LCM(y,z) ;\\n        int ac = val/LCM(x,z) ;\\n        int abc = val/LCM(LCM(x,y), z) ;\\n        return (long long)a + b + c - ab - bc - ac + abc ;\\n    }\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 1 , right = INT_MAX ;   \\n        while(left < right){\\n            int mid = left + (right - left)/2 ;\\n            long long k = helper(mid, a, b, c) ;\\n            if(k >= n)\\n                right = mid ;\\n            else\\n                left = mid + 1 ;\\n        }\\n        return left ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274035,
                "title": "python-binary-search-math-gcd-lcm-explained",
                "content": "The idea to solve this problem is to first binary search between the range and once we find the mid calculate how many numbers get hit at or before this number returning if the amount was larger than our target or less.\\n\\nThe way we can find this out is with the following idea:\\n\\n**a = 2, b = 3, c = 3, n = 4**\\n\\nif we get mid == 10\\n\\nwe can break the problem down as \\n**2,4,6,8,10 = 10 // a = 5\\n3,6,9 = 10 // b = 3\\n3,6,9 = 10 // c = 3\\n11 total**\\n\\nNow we have all the multiples before this number but we have a problem where numbers are overlapping if you look at the number 3 and 6 both of these numbers show up multiple times 3 showing up twice and 6 three times.\\n\\nThe way we can handle this is with LCM.\\nThere are 3 combinations to check (a,b), (a,c), (b,c)\\nthe lcm of a,b = 6, a,c = 6 and b,c = 3\\n\\nnow lets count how many times these numbers show up and remove them from our total\\n**mid // lcm(a,b) = 1\\nmid // lcm(a,c) = 1\\nmid// lcm(b,c) = 3**\\n\\nnow we have 11 - 5 = 6\\nbut this is still incorrect since we removed all 3 of the 6s since all 3 of our lcms hit 6 multiples so as a final step we should add back multiples where LCM(a,b,c)\\nto do this we take the LCM of 2 numbers say (a,b) than LCM the third # with it LCM(LCM(a,b),c) which will give us 6\\n\\nwe can calculate this the same way mid // LCM(LCM(a,b),c) = 1\\n**res = 6 + 1**\\n\\nnow we can return if our res is >= to our target and continue our BS.\\n\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        def lcm(a,b):\\n            \\n            return a * b // gcd(a,b)\\n        \\n        def isGood(mid):\\n            \\n            #calculate how many solves are before this number for each a, b and c\\n            tarA = mid // a\\n            tarB = mid // b\\n            tarC = mid // c\\n\\n            #remove intersection points\\n            ab = mid // abLCM\\n            ac = mid // acLCM\\n            bc = mid // bcLCM\\n            \\n            #remove points where they all intersect\\n            al = mid // allLCM\\n            \\n            #sum up all of our results\\n            s = tarA + tarB + tarC - ab - ac - bc + al\\n            \\n            #are we above and = or below our target\\n            return s >= n \\n            \\n        #check all lcms ahead of time\\n        abLCM = lcm(a,b)\\n        acLCM = lcm(a,c)\\n        bcLCM = lcm(b,c)\\n        allLCM = lcm(abLCM, c)\\n        \\n        #search range from \\n        l,r = 0, 2 * 10**9\\n        \\n        while l < r:\\n            \\n            mid = l + (r-l)//2\\n\\n            if isGood(mid):\\n                r = mid\\n            else:\\n                l = mid +1\\n                \\n        \\n        return l",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "The idea to solve this problem is to first binary search between the range and once we find the mid calculate how many numbers get hit at or before this number returning if the amount was larger than our target or less.\\n\\nThe way we can find this out is with the following idea:\\n\\n**a = 2, b = 3, c = 3, n = 4**\\n\\nif we get mid == 10\\n\\nwe can break the problem down as \\n**2,4,6,8,10 = 10 // a = 5\\n3,6,9 = 10 // b = 3\\n3,6,9 = 10 // c = 3\\n11 total**\\n\\nNow we have all the multiples before this number but we have a problem where numbers are overlapping if you look at the number 3 and 6 both of these numbers show up multiple times 3 showing up twice and 6 three times.\\n\\nThe way we can handle this is with LCM.\\nThere are 3 combinations to check (a,b), (a,c), (b,c)\\nthe lcm of a,b = 6, a,c = 6 and b,c = 3\\n\\nnow lets count how many times these numbers show up and remove them from our total\\n**mid // lcm(a,b) = 1\\nmid // lcm(a,c) = 1\\nmid// lcm(b,c) = 3**\\n\\nnow we have 11 - 5 = 6\\nbut this is still incorrect since we removed all 3 of the 6s since all 3 of our lcms hit 6 multiples so as a final step we should add back multiples where LCM(a,b,c)\\nto do this we take the LCM of 2 numbers say (a,b) than LCM the third # with it LCM(LCM(a,b),c) which will give us 6\\n\\nwe can calculate this the same way mid // LCM(LCM(a,b),c) = 1\\n**res = 6 + 1**\\n\\nnow we can return if our res is >= to our target and continue our BS.\\n\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        def lcm(a,b):\\n            \\n            return a * b // gcd(a,b)\\n        \\n        def isGood(mid):\\n            \\n            #calculate how many solves are before this number for each a, b and c\\n            tarA = mid // a\\n            tarB = mid // b\\n            tarC = mid // c\\n\\n            #remove intersection points\\n            ab = mid // abLCM\\n            ac = mid // acLCM\\n            bc = mid // bcLCM\\n            \\n            #remove points where they all intersect\\n            al = mid // allLCM\\n            \\n            #sum up all of our results\\n            s = tarA + tarB + tarC - ab - ac - bc + al\\n            \\n            #are we above and = or below our target\\n            return s >= n \\n            \\n        #check all lcms ahead of time\\n        abLCM = lcm(a,b)\\n        acLCM = lcm(a,c)\\n        bcLCM = lcm(b,c)\\n        allLCM = lcm(abLCM, c)\\n        \\n        #search range from \\n        l,r = 0, 2 * 10**9\\n        \\n        while l < r:\\n            \\n            mid = l + (r-l)//2\\n\\n            if isGood(mid):\\n                r = mid\\n            else:\\n                l = mid +1\\n                \\n        \\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 3262133,
                "title": "c-bring-smallest-to-2nd-smallest",
                "content": "For more parameters it is better to use priority queue.\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, long a, long b, long c) {\\n        vector<pair<long, long>> v = {{a, a}, {b, b}, {c, c}};\\n        while (n > 0){\\n            sort(v.begin(), v.end());\\n            --n;\\n            int dif = (v[1].first - v[0].first) / v[0].second;\\n            if (dif >= n) return v[0].first + n * v[0].second;\\n            else n -= dif;\\n            v[0].first += dif * v[0].second;\\n            long smallest = v[0].first;\\n            for (auto& [f,s] : v)\\n                if (f == smallest) f += s;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, long a, long b, long c) {\\n        vector<pair<long, long>> v = {{a, a}, {b, b}, {c, c}};\\n        while (n > 0){\\n            sort(v.begin(), v.end());\\n            --n;\\n            int dif = (v[1].first - v[0].first) / v[0].second;\\n            if (dif >= n) return v[0].first + n * v[0].second;\\n            else n -= dif;\\n            v[0].first += dif * v[0].second;\\n            long smallest = v[0].first;\\n            for (auto& [f,s] : v)\\n                if (f == smallest) f += s;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246732,
                "title": "java-0ms-easy-solution",
                "content": "# Intuition\\nThe idea behind this solution is to use binary search to find the nth ugly number. We start by initializing a range of possible ugly numbers between 1 and Integer.MAX_VALUE. \\n\\n# Approach\\n We then use the principle of inclusion-exclusion to count the number of ugly numbers in this range. Specifically, we count the number of multiples of a, b, and c, subtract the number of multiples of the least common multiple of a and b, a and c, b and c, and add back the number of multiples of the least common multiple of a, b, and c.\\n\\nIf the count of ugly numbers in the range is less than n, we adjust the range so that the lower bound is the midpoint of the current range plus one. Otherwise, we adjust the range so that the upper bound is the midpoint of the current range.\\n\\nWe repeat this process until the range has converged to a single value, which is the nth ugly number.\\n\\nThe lcm and gcd helper functions are used to compute the least common multiple and greatest common divisor of two numbers, respectively. These functions are used in the computation of the multiples of the least common multiple of a, b, and c.\\n\\n# Complexity\\n- Time complexity:\\nThe binary search algorithm used in this solution has a time complexity of O(log N), where N is the size of the search space. In this case, the search space is the range of possible ugly numbers between 1 and Integer.MAX_VALUE, which has a size of O(N). Therefore, the time complexity of the binary search step is O(log N).\\n\\n- Space complexity:\\nThe space complexity of the solution I provided for the Ugly Number III problem is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n     long low = 1, high = Integer.MAX_VALUE;\\n    long ab = lcm(a, b), ac = lcm(a, c), bc = lcm(b, c), abc = lcm(a, bc);\\n    \\n    while (low < high) {\\n        long mid = (low + high) / 2;\\n        long count = mid/a + mid/b + mid/c - mid/ab - mid/ac - mid/bc + mid/abc;\\n        if (count < n) {\\n            low = mid + 1;\\n        } else {\\n            high = mid;\\n        }\\n    }\\n    \\n    return (int)low;\\n}\\n\\nprivate long lcm(long a, long b) {\\n    return a * b / gcd(a, b);\\n}\\n\\nprivate long gcd(long a, long b) {\\n    if (b == 0) {\\n        return a;\\n    } else {\\n        return gcd(b, a % b);\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n     long low = 1, high = Integer.MAX_VALUE;\\n    long ab = lcm(a, b), ac = lcm(a, c), bc = lcm(b, c), abc = lcm(a, bc);\\n    \\n    while (low < high) {\\n        long mid = (low + high) / 2;\\n        long count = mid/a + mid/b + mid/c - mid/ab - mid/ac - mid/bc + mid/abc;\\n        if (count < n) {\\n            low = mid + 1;\\n        } else {\\n            high = mid;\\n        }\\n    }\\n    \\n    return (int)low;\\n}\\n\\nprivate long lcm(long a, long b) {\\n    return a * b / gcd(a, b);\\n}\\n\\nprivate long gcd(long a, long b) {\\n    if (b == 0) {\\n        return a;\\n    } else {\\n        return gcd(b, a % b);\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182838,
                "title": "binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long lcmab,lcmbc,lcmac,lcmabc;\\n    long long  gcd(long long  a, long long  b){\\n        if(b==0) return a;\\n        if(a<b) return gcd(b,a);\\n        return gcd(b,a%b);\\n    }\\n    long long  lcm(long long  a, long long  b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    long long  before(long long  x, long long  a, long long  b, long long  c){\\n        return (x/a)+(x/b)+(x/c)-(x/lcmab)-(x/lcmbc)-(x/lcmac)+(x/lcmabc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        lcmab=lcm(a,b);\\n        lcmbc=lcm(b,c);\\n        lcmac=lcm(a,c);\\n        lcmabc=lcm(lcmab,c);\\n        long long  lo=1;\\n        long long  hi=2e9;\\n        while(lo<hi){\\n            long long  x=lo+(hi-lo)/2;\\n            if(before(x,a,b,c)>=n) hi=x;\\n            else lo=x+1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long lcmab,lcmbc,lcmac,lcmabc;\\n    long long  gcd(long long  a, long long  b){\\n        if(b==0) return a;\\n        if(a<b) return gcd(b,a);\\n        return gcd(b,a%b);\\n    }\\n    long long  lcm(long long  a, long long  b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    long long  before(long long  x, long long  a, long long  b, long long  c){\\n        return (x/a)+(x/b)+(x/c)-(x/lcmab)-(x/lcmbc)-(x/lcmac)+(x/lcmabc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        lcmab=lcm(a,b);\\n        lcmbc=lcm(b,c);\\n        lcmac=lcm(a,c);\\n        lcmabc=lcm(lcmab,c);\\n        long long  lo=1;\\n        long long  hi=2e9;\\n        while(lo<hi){\\n            long long  x=lo+(hi-lo)/2;\\n            if(before(x,a,b,c)>=n) hi=x;\\n            else lo=x+1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136314,
                "title": "solution-in-java",
                "content": "```\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119018,
                "title": "c-binary-search-with-intersection-trick-and-explanation",
                "content": "Time: O(log(2e9))\\nSpace: O(1)\\n\\nWe notice that the constraints give us an upper and lower bound on the solution, so we think of binary search. (\"It is guaranteed that the result will be in range [1, 2e9].\")\\n\\nPredicate: P(x) = (Number of ugly numbers less than x) >= n\\nWe note that this is monotonically increasing, (the larger the x, the more ugly numbers, and eventually it will be >= n) \\nand we want the smallest x such that P(x) is true.\\n\\nNow we need to determine P(x). \\nWe note that the number of multiples of a less than or equal to x is x/a, however, summing up `x/a + x/b + x/c` is wrong since there can be double counting. We thus need to account for the intersections, much like a venn diagram. Note here that for the intersection of a and b, we need to divide x by lcm(a,b).\\n\\nOne last thing to note is that if any of a, b, or c are 1, every number is ugly and so we can return n directly.\\n```\\nclass Solution {\\npublic:\\n    // get number of ugly nums less than mid\\n    long long numLess(long long a, long long b, long long c, long long x){\\n        long long ans = 0;\\n        long long ab = a*b/__gcd(a,b);\\n        long long ac = a*c/__gcd(a,c);\\n        long long bc = b*c/__gcd(b,c);\\n        long long abc = ab*c/__gcd(ab,c);\\n        \\n        ans += x/a + x/b + x/c;\\n        ans -= x/ab + x/ac + x/bc;\\n        ans += x/abc;\\n        return ans;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(a==1 || b==1 || c==1) return n;\\n        long long low=0, high=2e9;\\n        while(low<high){\\n            long long mid = (low+high)/2;\\n            if(numLess(a,b,c,mid) >= n) high = mid;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // get number of ugly nums less than mid\\n    long long numLess(long long a, long long b, long long c, long long x){\\n        long long ans = 0;\\n        long long ab = a*b/__gcd(a,b);\\n        long long ac = a*c/__gcd(a,c);\\n        long long bc = b*c/__gcd(b,c);\\n        long long abc = ab*c/__gcd(ab,c);\\n        \\n        ans += x/a + x/b + x/c;\\n        ans -= x/ab + x/ac + x/bc;\\n        ans += x/abc;\\n        return ans;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(a==1 || b==1 || c==1) return n;\\n        long long low=0, high=2e9;\\n        while(low<high){\\n            long long mid = (low+high)/2;\\n            if(numLess(a,b,c,mid) >= n) high = mid;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094479,
                "title": "100-and-tle-solution-need-cleaning-typescript-js",
                "content": "\\n\\n# Code\\n```\\nfunction nthUglyNumber(n: number, a: number, b: number, c: number): number {\\n    // binary search\\n    const ab: number = Math.floor(a * b / gcd_two_num(a,b));\\n    const ac: number = Math.floor(a * c / gcd_two_num(a,c));\\n    const bc: number = Math.floor(b * c / gcd_two_num(b,c));\\n    const abc: number = Math.floor(a * bc / gcd_two_num(a,bc));\\n    const is_enough = (mid: number): boolean=>{\\n        const total: number = floor_div(mid,a) + floor_div(mid,b) + floor_div(mid,c) - floor_div(mid,ab) - floor_div(mid,bc) - floor_div(mid,ac) + floor_div(mid,abc);\\n        return total >= n;\\n    }\\n    let start: number = Math.min(a,b,c);\\n    // let start: number = 1;\\n    let end: number = 10 ** 10;\\n    while (start < end){\\n        const mid = Math.floor((start+end)/2);\\n        // const mid = start +  Math.floor((end-start)/2);\\n        if (is_enough(mid)){\\n            end = mid;\\n            continue;\\n        }\\n        start = mid + 1;\\n    }\\n    return start;\\n\\n\\n    // linear solution : TLE solution\\n    let count: number = 0;\\n    let num: number = Math.min(a,b,c);\\n    while (count < n){\\n        if (is_ugly(num, a, b, c)) count += 1;\\n        num += 1;\\n    }\\n    return num - 1;\\n\\n};\\n// utils\\nconst floor_div = (num1: number, num2: number): number => Math.floor(num1/num2);\\n\\n// euclid algo, source wikipedia\\n// function gcd(a, b)\\n//     while b \\u2260 0\\n//         t := b\\n//         b := a mod b\\n//         a := t\\n//     return a\\nconst gcd_two_num = (num1: number, num2: number): number => {\\n    let n1: number = num1;\\n    let n2: number = num2;\\n    while (n2 !== 0){\\n        const temp: number = n2;\\n        n2 = n1 % n2;\\n        n1 = temp;\\n    }\\n    return n1;\\n}\\n\\n// scuk algorthm\\nconst greatest_div = (...args: number[]): number =>{\\n    if (!args) return -1;\\n    const min_num: number = Math.min(...args);\\n    for (let div = min_num; div >= 1; div -= 1){\\n        let count: number = args.reduce((prev_count, curr_num)=>{\\n            if (curr_num % div === 0){\\n                return prev_count+1;\\n            }\\n        }, 0)\\n        if (count === args.length) return div;\\n    }\\n}\\n\\nconst is_ugly = (num: number, a: number, b: number, c: number): boolean =>{\\n    return num % a === 0 || num % b === 0 || num % c === 0;\\n}\\n\\nconst ugly_before = (num: number, a: number, b: number, c: number, start_num: number): number=>{\\n    let count: number = 1;\\n    for (let i = start_num; i < num; i += 1){\\n        if (is_ugly(i, a, b, c)) count += 1;\\n    }\\n    return count;\\n}\\n\\n// const all_ugly_below = (num: number, a: number, b: number, c: number): {nth: number, nth_num: number} => {\\n//    // return an array or nah think \\n// }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Math",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nfunction nthUglyNumber(n: number, a: number, b: number, c: number): number {\\n    // binary search\\n    const ab: number = Math.floor(a * b / gcd_two_num(a,b));\\n    const ac: number = Math.floor(a * c / gcd_two_num(a,c));\\n    const bc: number = Math.floor(b * c / gcd_two_num(b,c));\\n    const abc: number = Math.floor(a * bc / gcd_two_num(a,bc));\\n    const is_enough = (mid: number): boolean=>{\\n        const total: number = floor_div(mid,a) + floor_div(mid,b) + floor_div(mid,c) - floor_div(mid,ab) - floor_div(mid,bc) - floor_div(mid,ac) + floor_div(mid,abc);\\n        return total >= n;\\n    }\\n    let start: number = Math.min(a,b,c);\\n    // let start: number = 1;\\n    let end: number = 10 ** 10;\\n    while (start < end){\\n        const mid = Math.floor((start+end)/2);\\n        // const mid = start +  Math.floor((end-start)/2);\\n        if (is_enough(mid)){\\n            end = mid;\\n            continue;\\n        }\\n        start = mid + 1;\\n    }\\n    return start;\\n\\n\\n    // linear solution : TLE solution\\n    let count: number = 0;\\n    let num: number = Math.min(a,b,c);\\n    while (count < n){\\n        if (is_ugly(num, a, b, c)) count += 1;\\n        num += 1;\\n    }\\n    return num - 1;\\n\\n};\\n// utils\\nconst floor_div = (num1: number, num2: number): number => Math.floor(num1/num2);\\n\\n// euclid algo, source wikipedia\\n// function gcd(a, b)\\n//     while b \\u2260 0\\n//         t := b\\n//         b := a mod b\\n//         a := t\\n//     return a\\nconst gcd_two_num = (num1: number, num2: number): number => {\\n    let n1: number = num1;\\n    let n2: number = num2;\\n    while (n2 !== 0){\\n        const temp: number = n2;\\n        n2 = n1 % n2;\\n        n1 = temp;\\n    }\\n    return n1;\\n}\\n\\n// scuk algorthm\\nconst greatest_div = (...args: number[]): number =>{\\n    if (!args) return -1;\\n    const min_num: number = Math.min(...args);\\n    for (let div = min_num; div >= 1; div -= 1){\\n        let count: number = args.reduce((prev_count, curr_num)=>{\\n            if (curr_num % div === 0){\\n                return prev_count+1;\\n            }\\n        }, 0)\\n        if (count === args.length) return div;\\n    }\\n}\\n\\nconst is_ugly = (num: number, a: number, b: number, c: number): boolean =>{\\n    return num % a === 0 || num % b === 0 || num % c === 0;\\n}\\n\\nconst ugly_before = (num: number, a: number, b: number, c: number, start_num: number): number=>{\\n    let count: number = 1;\\n    for (let i = start_num; i < num; i += 1){\\n        if (is_ugly(i, a, b, c)) count += 1;\\n    }\\n    return count;\\n}\\n\\n// const all_ugly_below = (num: number, a: number, b: number, c: number): {nth: number, nth_num: number} => {\\n//    // return an array or nah think \\n// }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3066911,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        fn count(n: i64, a: i64, b: i64, c: i64) -> i64 {\\n            let mut count = 0;\\n            count += n / a;\\n            count += n / b;\\n            count += n / c;\\n            count -= n / lcm(a, b);\\n            count -= n / lcm(a, c);\\n            count -= n / lcm(b, c);\\n            count += n / lcm(a, lcm(b, c));\\n            count\\n        }\\n\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if b == 0 {\\n                a\\n            } else {\\n                gcd(b, a % b)\\n            }\\n        }\\n\\n        fn lcm(a: i64, b: i64) -> i64 {\\n            a * b / gcd(a, b)\\n        }\\n\\n        let (n, a, b, c) = (n as i64, a as i64, b as i64, c as i64);\\n\\n        let mut left = 1;\\n        let mut right = 2 * 10_i64.pow(9);\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            let count = count(mid, a, b, c);\\n            if count < n {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        left as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        fn count(n: i64, a: i64, b: i64, c: i64) -> i64 {\\n            let mut count = 0;\\n            count += n / a;\\n            count += n / b;\\n            count += n / c;\\n            count -= n / lcm(a, b);\\n            count -= n / lcm(a, c);\\n            count -= n / lcm(b, c);\\n            count += n / lcm(a, lcm(b, c));\\n            count\\n        }\\n\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if b == 0 {\\n                a\\n            } else {\\n                gcd(b, a % b)\\n            }\\n        }\\n\\n        fn lcm(a: i64, b: i64) -> i64 {\\n            a * b / gcd(a, b)\\n        }\\n\\n        let (n, a, b, c) = (n as i64, a as i64, b as i64, c as i64);\\n\\n        let mut left = 1;\\n        let mut right = 2 * 10_i64.pow(9);\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            let count = count(mid, a, b, c);\\n            if count < n {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        left as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2973181,
                "title": "great-question-for-gcd-eucledian-algorithm-implementation",
                "content": "# Intuition\\nIf you think of the greatest common divisors as groups, you can count the number of elements simply by adding and the groups and subtracting elements that are in two groups (wich will result in you subtracting twice elements that are in three groups) and adding elements that are in three groups.\\n\\n# Approach\\n- Euclidean Algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```java\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long nab = a*1l*b/gcd(a,b);\\n        long nac = a*1l*c/gcd(a,c);\\n        long nbc = b*1l*c/gcd(b,c);\\n        long nabc = nab*c/gcd(nab,c);\\n\\n        int x=1, y=2000000001;\\n        while(x<=y) {\\n            long mid=x+(y-x)/2;\\n            long g= mid/a + mid/b + mid/c - mid/nab - mid/nac - mid/nbc + mid/nabc;\\n            if(g<n) x=(int)mid+1;\\n            else y=(int)mid-1;\\n        }\\n        return x;\\n        \\n    }\\n\\n    long gcd(long a, long b) {\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long nab = a*1l*b/gcd(a,b);\\n        long nac = a*1l*c/gcd(a,c);\\n        long nbc = b*1l*c/gcd(b,c);\\n        long nabc = nab*c/gcd(nab,c);\\n\\n        int x=1, y=2000000001;\\n        while(x<=y) {\\n            long mid=x+(y-x)/2;\\n            long g= mid/a + mid/b + mid/c - mid/nab - mid/nac - mid/nbc + mid/nabc;\\n            if(g<n) x=(int)mid+1;\\n            else y=(int)mid-1;\\n        }\\n        return x;\\n        \\n    }\\n\\n    long gcd(long a, long b) {\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884326,
                "title": "javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar nthUglyNumber = function(n, a, b, c) {\\n    \\n    let left = 1, right = Math.pow(10,10)\\n\\n    const feasible = (num) => {\\n        let total = Math.floor(num/a) +Math.floor(num/b) +Math.floor(num/c) - Math.floor(num/ab) - Math.floor(num/ac) - Math.floor(num/bc) + Math.floor(num/abc)\\n\\n        return total >=n\\n    }\\n\\n    const gcd = (a,b) => b == 0  ? a : gcd(b,a%b)\\n\\n    let ab = Math.floor(a*b/ gcd(a,b))\\n    let bc = Math.floor(b*c/ gcd(b,c))\\n    let ac = Math.floor(a*c/ gcd(a,c))\\n    let abc = Math.floor(a*bc/ gcd(a,bc))\\n\\n\\n\\n    while(left<right){\\n        let mid = Math.floor(left + (right - left) / 2)\\n\\n        if(feasible(mid)) right = mid\\n        else left = mid + 1\\n    }\\n\\n    return left\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar nthUglyNumber = function(n, a, b, c) {\\n    \\n    let left = 1, right = Math.pow(10,10)\\n\\n    const feasible = (num) => {\\n        let total = Math.floor(num/a) +Math.floor(num/b) +Math.floor(num/c) - Math.floor(num/ab) - Math.floor(num/ac) - Math.floor(num/bc) + Math.floor(num/abc)\\n\\n        return total >=n\\n    }\\n\\n    const gcd = (a,b) => b == 0  ? a : gcd(b,a%b)\\n\\n    let ab = Math.floor(a*b/ gcd(a,b))\\n    let bc = Math.floor(b*c/ gcd(b,c))\\n    let ac = Math.floor(a*c/ gcd(a,c))\\n    let abc = Math.floor(a*bc/ gcd(a,bc))\\n\\n\\n\\n    while(left<right){\\n        let mid = Math.floor(left + (right - left) / 2)\\n\\n        if(feasible(mid)) right = mid\\n        else left = mid + 1\\n    }\\n\\n    return left\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858650,
                "title": "swift-solution",
                "content": "```\\n// Ugly number III\\n// https://leetcode.com/problems/ugly-number-iii/\\n\\nclass Solution {\\n    func nthUglyNumber(_ n: Int, _ a: Int, _ b: Int, _ c: Int) -> Int {\\n        var left = 1\\n        var right = Int(2e9)\\n        let ab = lcm(a, b)\\n        let ac = lcm(a, c)\\n        let bc = lcm(b, c)\\n        let abc = lcm(ab, c)\\n        while left < right {\\n            let mid = left + (right - left) / 2\\n            let count = mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc\\n            if count < n {\\n                left = mid + 1\\n            } else {\\n                right = mid\\n            }\\n        }\\n        return left\\n    }\\n    \\n    func gcd(_ a: Int, _ b: Int) -> Int {\\n        return b == 0 ? a : gcd(b, a % b)\\n    }\\n    \\n    func lcm(_ a: Int, _ b: Int) -> Int {\\n        return a * b / gcd(a, b)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Tree"
                ],
                "code": "```\\n// Ugly number III\\n// https://leetcode.com/problems/ugly-number-iii/\\n\\nclass Solution {\\n    func nthUglyNumber(_ n: Int, _ a: Int, _ b: Int, _ c: Int) -> Int {\\n        var left = 1\\n        var right = Int(2e9)\\n        let ab = lcm(a, b)\\n        let ac = lcm(a, c)\\n        let bc = lcm(b, c)\\n        let abc = lcm(ab, c)\\n        while left < right {\\n            let mid = left + (right - left) / 2\\n            let count = mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc\\n            if count < n {\\n                left = mid + 1\\n            } else {\\n                right = mid\\n            }\\n        }\\n        return left\\n    }\\n    \\n    func gcd(_ a: Int, _ b: Int) -> Int {\\n        return b == 0 ? a : gcd(b, a % b)\\n    }\\n    \\n    func lcm(_ a: Int, _ b: Int) -> Int {\\n        return a * b / gcd(a, b)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857929,
                "title": "binary-search-rust-solution",
                "content": "```\\nimpl Solution {\\n    \\n    pub fn gcd(a: i64, b: i64) -> i64 {\\n        \\n        let mut x = a;\\n        let mut y = b;\\n        \\n        while y != 0 {\\n            let temp = x;\\n            x = y;\\n            y = (temp%y);\\n        }\\n        \\n        return x;\\n    }\\n    \\n    pub fn lcm(a: i64, b: i64) -> i64 {\\n        \\n        return (a*b) / Solution::gcd(a, b);\\n        \\n    }\\n    \\n    pub fn ugly_numbers_count(n: i64, a: i64, b: i64, c: i64) -> i64 {\\n        \\n        let a_mult = n / a;\\n        let b_mult = n / b;\\n        let c_mult = n / c;\\n        \\n        let a_c = n / Solution::lcm(a, c);\\n        let a_b = n / Solution::lcm(a, b);\\n        let c_b = n / Solution::lcm(c, b);\\n        \\n        let a_b_c = n / Solution::lcm(a, Solution::lcm(b, c));\\n        \\n        return a_mult + b_mult + c_mult - a_b - a_c - c_b + a_b_c;\\n        \\n    }\\n    \\n    \\n    pub fn is_divisible(num: i64, a: i64, b: i64, c: i64) -> bool {\\n        \\n        if num % a == 0 || num % b == 0 || num % c == 0 {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    // O(logn) time,\\n    // O(logn) space,\\n    // Approach: binary search, math\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        \\n        let mut lo = 1 as i64;\\n        let mut hi = i32::MAX as i64;\\n        \\n        while lo <= hi {\\n            \\n            let mid = lo + (hi-lo)/2;\\n            let count = Solution::ugly_numbers_count(mid, a as i64, b as i64, c as i64);\\n\\n            if count == n as i64 && Solution::is_divisible(mid, a as i64, b as i64, c as i64) {\\n                return mid as i32;\\n            }\\n            else if count >= n  as i64 {\\n                hi = mid-1;\\n            }\\n            else {\\n                lo = mid + 1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nimpl Solution {\\n    \\n    pub fn gcd(a: i64, b: i64) -> i64 {\\n        \\n        let mut x = a;\\n        let mut y = b;\\n        \\n        while y != 0 {\\n            let temp = x;\\n            x = y;\\n            y = (temp%y);\\n        }\\n        \\n        return x;\\n    }\\n    \\n    pub fn lcm(a: i64, b: i64) -> i64 {\\n        \\n        return (a*b) / Solution::gcd(a, b);\\n        \\n    }\\n    \\n    pub fn ugly_numbers_count(n: i64, a: i64, b: i64, c: i64) -> i64 {\\n        \\n        let a_mult = n / a;\\n        let b_mult = n / b;\\n        let c_mult = n / c;\\n        \\n        let a_c = n / Solution::lcm(a, c);\\n        let a_b = n / Solution::lcm(a, b);\\n        let c_b = n / Solution::lcm(c, b);\\n        \\n        let a_b_c = n / Solution::lcm(a, Solution::lcm(b, c));\\n        \\n        return a_mult + b_mult + c_mult - a_b - a_c - c_b + a_b_c;\\n        \\n    }\\n    \\n    \\n    pub fn is_divisible(num: i64, a: i64, b: i64, c: i64) -> bool {\\n        \\n        if num % a == 0 || num % b == 0 || num % c == 0 {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    // O(logn) time,\\n    // O(logn) space,\\n    // Approach: binary search, math\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        \\n        let mut lo = 1 as i64;\\n        let mut hi = i32::MAX as i64;\\n        \\n        while lo <= hi {\\n            \\n            let mid = lo + (hi-lo)/2;\\n            let count = Solution::ugly_numbers_count(mid, a as i64, b as i64, c as i64);\\n\\n            if count == n as i64 && Solution::is_divisible(mid, a as i64, b as i64, c as i64) {\\n                return mid as i32;\\n            }\\n            else if count >= n  as i64 {\\n                hi = mid-1;\\n            }\\n            else {\\n                lo = mid + 1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2844082,
                "title": "java-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\n  //So what\\'s the thought process for this question if we generate linearly all the ugly number and give the nth ugly number it will give tle in this question like in the previousugly number2 approach we did solve with the help of dp but here we can\\'t since the constraints are too big so what else we can do... so what if I use the binary search why? I had the parameter start and end now if we will apply the binary search and find the mid than that mid have some numbers\\n//ya that\\'s true now if I divide that mid with first A than B than C what will I get I will get the amount of those numbers which are divisible by these number. \\n  //example 7 a=2 b=3 c=5  what will i get when i divide everyone 7/2=3  7/3=2  7/5=1  this shows how many divisible element are present so did you observe something if i add these numbers i will get as 3+2+1 =5 and from the range of 1to7 how many ugly number are there which are either divsible by 2 or 3 or 5 they are 5 numbers and has what I wanted but here we have 5 in the range of 7 but if n=3 was there i have to decrement the range in ordre to get the correct number but potentially i will store the mid in the answer as it can be ...\\n  \\n  //some important observation  as we can see we are adding the number divisible by 2 or 3 or 5 don\\'t you think we are adding some number twice which are both common in (2 and 3) (2 and 5) (3 and 5) as well as (a and b and c) so we ahd to remove these as well .\\n  \\n  //Don\\'t you think this is some type of formula yes exactly this is AuBuC formula observe it carefully \\n  \\n  //so final formula we will be using is k/A+k/B+k/C-k/(lcm(A,B))-k/(lcm(A,C))-k/(lcm(B,C))+k/(lcm(A,lcm(B,C)));\\n  \\n//least common divisible will give us the umber of common factors .Here k is the number which is nothing but mid have a look in the below implementation.  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n      long start=1;\\n      long end=(long)(2*1e9);\\n      long A=a;\\n      long B=b;\\n      long C=c;\\n      long ans=0;\\n      while(start<=end){\\n        long mid=start+(end-start)/2;\\n        long count=0;\\n        count+=mid/A;\\n        count+=mid/B;\\n        count+=mid/C;\\n        count-=mid/(LCM(A,B));\\n        count-=mid/(LCM(A,C));\\n        count-=mid/(LCM(B,C));\\n        count+=mid/(LCM(A,LCM(B,C)));\\n        \\n        if(count>=n){\\n          ans=mid;\\n          end=mid-1;\\n        }\\n        else{\\n          start=mid+1;\\n        }\\n      }\\n      return (int)ans;\\n    }\\n  \\n  public long LCM(long a,long b){\\n    return a*b/GCD(a,b);\\n  }\\n  public long GCD(long a,long b){\\n    if(b==0)return a;\\n    return GCD(b,a%b);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  //So what\\'s the thought process for this question if we generate linearly all the ugly number and give the nth ugly number it will give tle in this question like in the previousugly number2 approach we did solve with the help of dp but here we can\\'t since the constraints are too big so what else we can do... so what if I use the binary search why? I had the parameter start and end now if we will apply the binary search and find the mid than that mid have some numbers\\n//ya that\\'s true now if I divide that mid with first A than B than C what will I get I will get the amount of those numbers which are divisible by these number. \\n  //example 7 a=2 b=3 c=5  what will i get when i divide everyone 7/2=3  7/3=2  7/5=1  this shows how many divisible element are present so did you observe something if i add these numbers i will get as 3+2+1 =5 and from the range of 1to7 how many ugly number are there which are either divsible by 2 or 3 or 5 they are 5 numbers and has what I wanted but here we have 5 in the range of 7 but if n=3 was there i have to decrement the range in ordre to get the correct number but potentially i will store the mid in the answer as it can be ...\\n  \\n  //some important observation  as we can see we are adding the number divisible by 2 or 3 or 5 don\\'t you think we are adding some number twice which are both common in (2 and 3) (2 and 5) (3 and 5) as well as (a and b and c) so we ahd to remove these as well .\\n  \\n  //Don\\'t you think this is some type of formula yes exactly this is AuBuC formula observe it carefully \\n  \\n  //so final formula we will be using is k/A+k/B+k/C-k/(lcm(A,B))-k/(lcm(A,C))-k/(lcm(B,C))+k/(lcm(A,lcm(B,C)));\\n  \\n//least common divisible will give us the umber of common factors .Here k is the number which is nothing but mid have a look in the below implementation.  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n      long start=1;\\n      long end=(long)(2*1e9);\\n      long A=a;\\n      long B=b;\\n      long C=c;\\n      long ans=0;\\n      while(start<=end){\\n        long mid=start+(end-start)/2;\\n        long count=0;\\n        count+=mid/A;\\n        count+=mid/B;\\n        count+=mid/C;\\n        count-=mid/(LCM(A,B));\\n        count-=mid/(LCM(A,C));\\n        count-=mid/(LCM(B,C));\\n        count+=mid/(LCM(A,LCM(B,C)));\\n        \\n        if(count>=n){\\n          ans=mid;\\n          end=mid-1;\\n        }\\n        else{\\n          start=mid+1;\\n        }\\n      }\\n      return (int)ans;\\n    }\\n  \\n  public long LCM(long a,long b){\\n    return a*b/GCD(a,b);\\n  }\\n  public long GCD(long a,long b){\\n    if(b==0)return a;\\n    return GCD(b,a%b);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832655,
                "title": "c-solution-binary-search-faster-than-100-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n//reference : ugly number II\\n    long long lcm(long long a,long long b){\\n        return (a*b)/(__gcd(a,b));\\n    }\\n\\n    int nthUglyNumber(int n, int aa, int bb, int cc) {\\n        long long a=aa,b=bb,c=cc;\\n        long long low = 1 ,high = INT_MAX;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            //number of divisible numbers (aDiv) : numbers divisible by a,(abDiv):numbers divisible by a and b,(abcDiv) : numbers divisible by a,b and c;\\n            long long aDiv = mid/a, bDiv = mid/b , cDiv = mid/c , abDiv = mid/lcm(a,b), bcDiv = mid/lcm(b,c),caDiv = mid/lcm(c,a),abcDiv=mid/lcm(a,lcm(b,c));\\n\\n            long long total = aDiv + bDiv + cDiv - abDiv - bcDiv - caDiv + abcDiv;\\n            if(total < n) low = mid + 1;\\n            else high = mid;\\n        }\\n\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//reference : ugly number II\\n    long long lcm(long long a,long long b){\\n        return (a*b)/(__gcd(a,b));\\n    }\\n\\n    int nthUglyNumber(int n, int aa, int bb, int cc) {\\n        long long a=aa,b=bb,c=cc;\\n        long long low = 1 ,high = INT_MAX;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            //number of divisible numbers (aDiv) : numbers divisible by a,(abDiv):numbers divisible by a and b,(abcDiv) : numbers divisible by a,b and c;\\n            long long aDiv = mid/a, bDiv = mid/b , cDiv = mid/c , abDiv = mid/lcm(a,b), bcDiv = mid/lcm(b,c),caDiv = mid/lcm(c,a),abcDiv=mid/lcm(a,lcm(b,c));\\n\\n            long long total = aDiv + bDiv + cDiv - abDiv - bcDiv - caDiv + abcDiv;\\n            if(total < n) low = mid + 1;\\n            else high = mid;\\n        }\\n\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827729,
                "title": "python3-using-binary-search-and-set-theory",
                "content": "class Solution:\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a,b):\\n            if b == 0:\\n                return a\\n            return gcd(b,a%b)\\n        \\n        def lcm(a,b):\\n            return (a*b)//gcd(a,b)\\n        \\n        l,r = 1,2*10**9\\n        \\n        while l<r:\\n            mid = (l+r)//2\\n            count = mid//a+mid//b+mid//c-mid//lcm(a,b)-mid//lcm(a,c)-mid//lcm(b,c)+mid//lcm(a,lcm(b,c))\\n            if count<n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a,b):\\n            if b == 0:\\n                return a\\n            return gcd(b,a%b)\\n        \\n        def lcm(a,b):\\n            return (a*b)//gcd(a,b)\\n        \\n        l,r = 1,2*10**9\\n        \\n        while l<r:\\n            mid = (l+r)//2\\n            count = mid//a+mid//b+mid//c-mid//lcm(a,b)-mid//lcm(a,c)-mid//lcm(b,c)+mid//lcm(a,lcm(b,c))\\n            if count<n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 2814916,
                "title": "fully-explained-code-c-solution-binary-search-union-concept",
                "content": "\\nIf It helps plz upvote :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) {\\n        // Logic (Binary Search)\\n        // We can find the kth ugly element by binary searching it\\'s position\\n        // No upto N divisible by a = N / a\\n        // No upto N divisible by b = N / b\\n        // No upto N divisible by c = N / c\\n        // No upto N divisible by both (a,b) = N / Lcm(a,b)\\n        // No upto N divisible by both (b,c) = N / Lcm(b,c)\\n        // No upto N divisible by both (c,a) = N / Lcm(c,a)\\n        // No upto N divisible by (a,b,c) = N / Lcm(a,b,c)\\n\\n        // We can find the position of any ugly number by this\\n        // We already have range of ugly number from constraint\\n        \\n        long long s = 1;\\n        long long e = 2 * 1e9;\\n        long long ans;\\n        // Type converting\\n        long a = long(A);\\n        long b = long(B);\\n        long c = long(C);\\n\\n        while(s <= e){\\n            long long mid = s + (e - s) / 2;\\n            long long count = 0;\\n            // Finding the position of ugly number\\n            // (A U B U C) = A + B + C - (A \\u2229 B) - (B \\u2229 C) - (C \\u2229 A) + (A \\u2229 B \\u2229 C)\\n            count += mid / a;\\n            count += mid / b;\\n            count += mid / c;\\n            count -= mid / lcm(a,b);\\n            count -= mid / lcm(b,c);\\n            count -= mid / lcm(c,a);\\n            count += mid / lcm(a,lcm(b,c));\\n\\n            if(count >= n){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) {\\n        // Logic (Binary Search)\\n        // We can find the kth ugly element by binary searching it\\'s position\\n        // No upto N divisible by a = N / a\\n        // No upto N divisible by b = N / b\\n        // No upto N divisible by c = N / c\\n        // No upto N divisible by both (a,b) = N / Lcm(a,b)\\n        // No upto N divisible by both (b,c) = N / Lcm(b,c)\\n        // No upto N divisible by both (c,a) = N / Lcm(c,a)\\n        // No upto N divisible by (a,b,c) = N / Lcm(a,b,c)\\n\\n        // We can find the position of any ugly number by this\\n        // We already have range of ugly number from constraint\\n        \\n        long long s = 1;\\n        long long e = 2 * 1e9;\\n        long long ans;\\n        // Type converting\\n        long a = long(A);\\n        long b = long(B);\\n        long c = long(C);\\n\\n        while(s <= e){\\n            long long mid = s + (e - s) / 2;\\n            long long count = 0;\\n            // Finding the position of ugly number\\n            // (A U B U C) = A + B + C - (A \\u2229 B) - (B \\u2229 C) - (C \\u2229 A) + (A \\u2229 B \\u2229 C)\\n            count += mid / a;\\n            count += mid / b;\\n            count += mid / c;\\n            count -= mid / lcm(a,b);\\n            count -= mid / lcm(b,c);\\n            count -= mid / lcm(c,a);\\n            count += mid / lcm(a,lcm(b,c));\\n\\n            if(count >= n){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777954,
                "title": "python-binary-search-inclusion-and-exclusion",
                "content": "```\\nfrom math import gcd\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def count(k, a, b, c):\\n            ab = a*b//gcd(a,b)\\n            abc = ab*c//gcd(ab,c)\\n            return k//a + k//b + k//c - k//(a*b//gcd(a,b)) - k//(b*c//gcd(b,c)) -k//(a*c//gcd(a,c)) + k//abc\\n        left, right = 1, 2*10**9\\n        while left < right:\\n            m = (left + right)//2\\n            if count(m, a, b, c) >= n:\\n                right = m\\n            else:\\n                left = m + 1\\n        return left",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def count(k, a, b, c):\\n            ab = a*b//gcd(a,b)\\n            abc = ab*c//gcd(ab,c)\\n            return k//a + k//b + k//c - k//(a*b//gcd(a,b)) - k//(b*c//gcd(b,c)) -k//(a*c//gcd(a,c)) + k//abc\\n        left, right = 1, 2*10**9\\n        while left < right:\\n            m = (left + right)//2\\n            if count(m, a, b, c) >= n:\\n                right = m\\n            else:\\n                left = m + 1\\n        return left",
                "codeTag": "Java"
            },
            {
                "id": 2699325,
                "title": "clearly-explained-c-solution-runtime-0ms-o-log-n-complexity-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNth Smallest Number is same as finding the Kth smallest number\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo questions are required to be answered here.\\n\\nQ1. Given a number n, and three numbers a, b and c, calculate the total count of numbers in range [1,n] such that each number is either divisible by a or b or c.\\n\\nQ2. Think about if multiple of one another exist in (a or b or c) i.e, c can be a multiple of b\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool condition(long long int mid, int a, int b, int c, int n){\\n        long long int ab, ac, bc, abc,count = 0;\\n        ab = (((long)a*b)/__gcd(a,b));\\n        bc = (((long)b*c)/__gcd(b,c));\\n        ac = (((long)a*c)/__gcd(a,c));\\n        abc = (((long)a*bc)/__gcd((long long)a,bc));\\n        count += (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ac + mid/abc);\\n        return count>=n;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        //  are there n-1 smallest numbers when n = mid?\\n        long long int left = 1, right = 1e12, mid;\\n        while(left<right){\\n            mid = (left) + (right-left)/2;\\n            if(condition(mid,a,b,c,n))right = mid;\\n            else left = mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool condition(long long int mid, int a, int b, int c, int n){\\n        long long int ab, ac, bc, abc,count = 0;\\n        ab = (((long)a*b)/__gcd(a,b));\\n        bc = (((long)b*c)/__gcd(b,c));\\n        ac = (((long)a*c)/__gcd(a,c));\\n        abc = (((long)a*bc)/__gcd((long long)a,bc));\\n        count += (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ac + mid/abc);\\n        return count>=n;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        //  are there n-1 smallest numbers when n = mid?\\n        long long int left = 1, right = 1e12, mid;\\n        while(left<right){\\n            mid = (left) + (right-left)/2;\\n            if(condition(mid,a,b,c,n))right = mid;\\n            else left = mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659476,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    long gcd(long a,long b){\\n        if(a>b)return gcd(b,a);\\n        if(a==0)return b;\\n        return gcd(a,b%a);\\n    }\\n    long lcm(long a,long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(min({a,b,c})==1)return n;\\n        long long int l=min({a,b,c});\\n        long long int h=n*l;\\n        while(h>l){\\n            long long int mid=l+(h-l)/2;\\n            long long int pos=mid/a+mid/b+mid/c-(mid/lcm(a,b)+mid/lcm(a,c)+mid/lcm(b,c))+mid/lcm(a,lcm(b,c));\\n            if(pos>=n) h=mid;\\n            else  l=mid+1;\\n        }\\n        return (int)l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long gcd(long a,long b){\\n        if(a>b)return gcd(b,a);\\n        if(a==0)return b;\\n        return gcd(a,b%a);\\n    }\\n    long lcm(long a,long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(min({a,b,c})==1)return n;\\n        long long int l=min({a,b,c});\\n        long long int h=n*l;\\n        while(h>l){\\n            long long int mid=l+(h-l)/2;\\n            long long int pos=mid/a+mid/b+mid/c-(mid/lcm(a,b)+mid/lcm(a,c)+mid/lcm(b,c))+mid/lcm(a,lcm(b,c));\\n            if(pos>=n) h=mid;\\n            else  l=mid+1;\\n        }\\n        return (int)l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620373,
                "title": "java-easy-solution-java-binary-search-easy-beginner-friendly",
                "content": "class Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n    \\n        int lo=0;\\n        int hi=Integer.MAX_VALUE;\\n        \\n        long ab=lcm(a,b),bc=lcm(b,c),ac=lcm(a,c),abc=lcm(ab,c);\\n        \\n        while(lo < hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            long count =0L+ mid/a+mid/b+mid/c-mid/ab-mid/ac-mid/bc+mid/abc;\\n            \\n            if(count >=n){\\n                hi = mid;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        return lo;\\n        \\n        \\n        \\n    }\\n    long gcd(long a ,long b){\\n        return b==0 ? a : gcd(b,a%b);\\n    }\\n    \\n    long lcm(long a ,long b){\\n        return a*b /gcd(a,b);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n    \\n        int lo=0;\\n        int hi=Integer.MAX_VALUE;\\n        \\n        long ab=lcm(a,b),bc=lcm(b,c),ac=lcm(a,c),abc=lcm(ab,c);\\n        \\n        while(lo < hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            long count =0L+ mid/a+mid/b+mid/c-mid/ab-mid/ac-mid/bc+mid/abc;\\n            \\n            if(count >=n){\\n                hi = mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2560728,
                "title": "java-binary-search-gcd-lcm-lots-of-long-varaibles",
                "content": "```java\\nclass Solution {\\n    private static final int PLACEHOLDER = 2_000_000_001;\\n    \\n    \\n    private int a;\\n    private int b;\\n    private int c;\\n    private long ab;\\n    private long ac;\\n    private long bc;\\n    private long abc;\\n    \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        this.a = a;\\n        this.b = b;\\n        this.c = c;\\n        this.ab = lcm(a, b);\\n        this.ac = lcm(a, c);\\n        this.bc = lcm(b, c);\\n        this.abc = lcm(a, lcm(b, c));\\n        \\n        // System.out.println(ab);\\n        // System.out.println(ac);\\n        // System.out.println(bc);\\n        // System.out.println(abc);\\n        \\n        int left = 1;\\n        int right = 2_000_000_001;\\n        \\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(hasNUglyNumber(mid, n)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n            \\n        }\\n        \\n        return left == PLACEHOLDER ? -1 : left;\\n    }\\n    \\n    private boolean hasNUglyNumber(long number, long n) {\\n        long count = number/a + number/b + number/c \\n            - number/ab - number/bc - number/ac \\n            + number/abc;\\n        \\n        // System.out.println(String.format(\"number=%d, count=%d\", number, count));\\n        \\n        return count >= n;\\n    }\\n    \\n    private long gcd(long a, long b) {\\n        if(b == 0) {\\n            return a;\\n        }\\n        \\n        return gcd(b, a%b);\\n    }\\n    \\n    private long lcm(long a, long b) {\\n        return ((long)a * (long)b) / gcd(a, b);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private static final int PLACEHOLDER = 2_000_000_001;\\n    \\n    \\n    private int a;\\n    private int b;\\n    private int c;\\n    private long ab;\\n    private long ac;\\n    private long bc;\\n    private long abc;\\n    \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        this.a = a;\\n        this.b = b;\\n        this.c = c;\\n        this.ab = lcm(a, b);\\n        this.ac = lcm(a, c);\\n        this.bc = lcm(b, c);\\n        this.abc = lcm(a, lcm(b, c));\\n        \\n        // System.out.println(ab);\\n        // System.out.println(ac);\\n        // System.out.println(bc);\\n        // System.out.println(abc);\\n        \\n        int left = 1;\\n        int right = 2_000_000_001;\\n        \\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(hasNUglyNumber(mid, n)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n            \\n        }\\n        \\n        return left == PLACEHOLDER ? -1 : left;\\n    }\\n    \\n    private boolean hasNUglyNumber(long number, long n) {\\n        long count = number/a + number/b + number/c \\n            - number/ab - number/bc - number/ac \\n            + number/abc;\\n        \\n        // System.out.println(String.format(\"number=%d, count=%d\", number, count));\\n        \\n        return count >= n;\\n    }\\n    \\n    private long gcd(long a, long b) {\\n        if(b == 0) {\\n            return a;\\n        }\\n        \\n        return gcd(b, a%b);\\n    }\\n    \\n    private long lcm(long a, long b) {\\n        return ((long)a * (long)b) / gcd(a, b);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514921,
                "title": "c-0ms-100-faster-solution-gcd-binarysearch",
                "content": "```\\n        int low=1, high = 2e9;\\n        long a=long(A), b=long(B), c=long(C);\\n        long ab=a*b/__gcd(a,b);\\n        long bc=b*c/__gcd(b,c);\\n        long ac=a*c/__gcd(a,c);\\n        long abc=a*bc/__gcd(a,bc);\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int cnt=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(cnt<n)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid;\\n            }\\n        }\\n        return low;\\n```\\n![image](https://assets.leetcode.com/users/images/2751ba6e-a9d2-4f40-bf82-f560a35406db_1662049655.2491727.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n        int low=1, high = 2e9;\\n        long a=long(A), b=long(B), c=long(C);\\n        long ab=a*b/__gcd(a,b);\\n        long bc=b*c/__gcd(b,c);\\n        long ac=a*c/__gcd(a,c);\\n        long abc=a*bc/__gcd(a,bc);\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int cnt=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(cnt<n)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid;\\n            }\\n        }\\n        return low;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2480112,
                "title": "number-theory-binary-search",
                "content": "The key part in understanding the solution is to first understand how to calculate the total ugly numbers before a particular interger\\n\\nOnce that is done then we can binary search throgh 1 to 2e9 to find the answer\\n\\n```\\n#define ll long long\\n    ll func(ll a,ll b){\\n        ll pro=a*1ll*b;\\n        ll g=__gcd(a,b);\\n        pro=pro/g;\\n        return pro;}\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int ans=-1;\\n        int l=1,r=2e9;\\n        while(l<=r){\\n            ll m=l+(r-l)/2;\\n            ll temp=m/a;\\n            temp+=(m/b);\\n            temp+=(m/c);\\n            int v1=(m/func(a,b));\\n            int v2=(m/func(b,c));\\n            int v3=(m/func(c,a));\\n            int v4=(m/func(a,func(b,c)));\\n            temp-=v1;\\n            temp-=v2;\\n            temp-=v3;\\n            temp+=v4;\\n            if(temp>=n){\\n                ans=m;\\n                r=m-1;}\\n            else\\n                l=m+1;\\n       }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\n    ll func(ll a,ll b){\\n        ll pro=a*1ll*b;\\n        ll g=__gcd(a,b);\\n        pro=pro/g;\\n        return pro;}\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int ans=-1;\\n        int l=1,r=2e9;\\n        while(l<=r){\\n            ll m=l+(r-l)/2;\\n            ll temp=m/a;\\n            temp+=(m/b);\\n            temp+=(m/c);\\n            int v1=(m/func(a,b));\\n            int v2=(m/func(b,c));\\n            int v3=(m/func(c,a));\\n            int v4=(m/func(a,func(b,c)));\\n            temp-=v1;\\n            temp-=v2;\\n            temp-=v3;\\n            temp+=v4;\\n            if(temp>=n){\\n                ans=m;\\n                r=m-1;}\\n            else\\n                l=m+1;\\n       }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474587,
                "title": "binary-search-with-inclusion-and-exclusion-method",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    ll gcd(ll a,ll b)\\n    {\\n        if(a==0)\\n            return b;\\n        \\n        return gcd(b%a,a);\\n    }\\n    ll lcm(ll a,ll b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n    bool check(ll x, ll n,ll a,ll b,ll c)\\n    {\\n        // check how many ugly number is less than x \\n        // if count is greater than or equal to n return true otherwise return false;\\n        \\n        // n(aUbUc)=n(a)+n(b)+n(c)-n(a^b)-n(b^c)-n(c^a)+n(a^b^c) where ^ represent intersection\\n        \\n        ll n_a=(x/a);\\n        ll n_b=(x/b);\\n        ll n_c=(x/c);\\n        ll n_ab=(x/(lcm(a,b)));\\n        ll n_bc=(x/(lcm(b,c)));\\n        ll n_ca=(x/lcm(c,a));\\n        ll f=lcm(a,b);\\n        ll n_abc=(x/lcm(f,c));\\n        \\n        ll d=n_a+n_b+n_c-n_ab-n_bc-n_ca+n_abc;\\n        \\n        if(d>=n)\\n            return true;\\n        return false;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll start=1,end=2*1e9;\\n        ll ans=0;\\n        while(start<=end)\\n        {\\n            ll mid=(start+(end-start)/2);\\n            if(check(mid, n,a,b,c))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else\\n                start=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    ll gcd(ll a,ll b)\\n    {\\n        if(a==0)\\n            return b;\\n        \\n        return gcd(b%a,a);\\n    }\\n    ll lcm(ll a,ll b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n    bool check(ll x, ll n,ll a,ll b,ll c)\\n    {\\n        // check how many ugly number is less than x \\n        // if count is greater than or equal to n return true otherwise return false;\\n        \\n        // n(aUbUc)=n(a)+n(b)+n(c)-n(a^b)-n(b^c)-n(c^a)+n(a^b^c) where ^ represent intersection\\n        \\n        ll n_a=(x/a);\\n        ll n_b=(x/b);\\n        ll n_c=(x/c);\\n        ll n_ab=(x/(lcm(a,b)));\\n        ll n_bc=(x/(lcm(b,c)));\\n        ll n_ca=(x/lcm(c,a));\\n        ll f=lcm(a,b);\\n        ll n_abc=(x/lcm(f,c));\\n        \\n        ll d=n_a+n_b+n_c-n_ab-n_bc-n_ca+n_abc;\\n        \\n        if(d>=n)\\n            return true;\\n        return false;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll start=1,end=2*1e9;\\n        ll ans=0;\\n        while(start<=end)\\n        {\\n            ll mid=(start+(end-start)/2);\\n            if(check(mid, n,a,b,c))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else\\n                start=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455629,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    long lcm(long a, long b)\\n    {\\n        return (a*b) / __gcd(a,b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long low = 1, high = 2*1e9, mid, count,  ans;\\n        \\n        while(low <= high)\\n        {\\n             mid = low + (high -low)/2;\\n            \\n            count = 0;\\n            \\n            count += mid/a;\\n            count += mid/b;\\n            count += mid/c;\\n            \\n            count -= mid/ lcm(a,b);\\n            count -= mid / lcm(b,c);\\n            count -= mid / lcm(c,a);\\n            \\n            count += mid / lcm(a,lcm(b,c));\\n            \\n            if(count >= n)\\n            {\\n                high = mid-1;\\n                \\n                ans = mid;\\n            }\\n            else\\n            {\\n               low = mid+1; \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    long lcm(long a, long b)\\n    {\\n        return (a*b) / __gcd(a,b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2425821,
                "title": "python-simple-binary-search",
                "content": "\\n    def dfs(self, val, a, b, c):\\n        ab = a*b//math.gcd(a,b)\\n        bc = b*c//math.gcd(b,c)\\n        ca = c*a//math.gcd(c,a)\\n        abc = ab*c//math.gcd(ab,c)\\n        \\n        return val//a + val//b + val//c - val//ab - val//bc - val//ca + val//abc\\n        \\n    def nthUglyNumber(self, n, a, b, c):\\n        low, high = 1, 2*10**9\\n        \\n        while low <= high:\\n            mid = (low + high)//2\\n            \\n            if self.dfs(mid, a, b, c) >= n:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n                \\n        return low",
                "solutionTags": [],
                "code": "\\n    def dfs(self, val, a, b, c):\\n        ab = a*b//math.gcd(a,b)\\n        bc = b*c//math.gcd(b,c)\\n        ca = c*a//math.gcd(c,a)\\n        abc = ab*c//math.gcd(ab,c)\\n        \\n        return val//a + val//b + val//c - val//ab - val//bc - val//ca + val//abc\\n        \\n    def nthUglyNumber(self, n, a, b, c):\\n        low, high = 1, 2*10**9\\n        \\n        while low <= high:\\n            mid = (low + high)//2\\n            \\n            if self.dfs(mid, a, b, c) >= n:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n                \\n        return low",
                "codeTag": "Python3"
            },
            {
                "id": 2403282,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int lo = 1;\\n        int hi = 2*(int)1e9;\\n        \\n        long A = long(a);\\n        long B = long(b);\\n        long C = long(c);\\n        \\n        long AB = A*B/__gcd(A,B);\\n        long BC = B*C/__gcd(B,C);\\n        long AC = A*C/__gcd(A,C);\\n        \\n        long ABC = A*BC/__gcd(A,BC);\\n        \\n        while(lo<hi) {\\n            int mid = lo + (hi - lo)/2;\\n            int cnt = mid/A + mid/B + mid/C - mid/AB - mid/BC - mid/AC + mid/ABC;\\n            if(cnt<n)\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int lo = 1;\\n        int hi = 2*(int)1e9;\\n        \\n        long A = long(a);\\n        long B = long(b);\\n        long C = long(c);\\n        \\n        long AB = A*B/__gcd(A,B);\\n        long BC = B*C/__gcd(B,C);\\n        long AC = A*C/__gcd(A,C);\\n        \\n        long ABC = A*BC/__gcd(A,BC);\\n        \\n        while(lo<hi) {\\n            int mid = lo + (hi - lo)/2;\\n            int cnt = mid/A + mid/B + mid/C - mid/AB - mid/BC - mid/AC + mid/ABC;\\n            if(cnt<n)\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370064,
                "title": "simple-binary-search-solution-overflow-handled-java",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high =2*(int)1e9;\\n        \\n        int ab = lcm(a,b), bc = lcm(b,c), ca = lcm(c,a), abc = lcm(a,bc);\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            int count = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc;\\n            if(count>=n){\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n    private int lcm(int x,int y){\\n        int a = x, b = y; \\n        while(a!=0){\\n            int t = a;\\n            a = b%a;\\n            b = t;\\n        }\\n        return (int)(x*(y/(double)b));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high =2*(int)1e9;\\n        \\n        int ab = lcm(a,b), bc = lcm(b,c), ca = lcm(c,a), abc = lcm(a,bc);\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            int count = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc;\\n            if(count>=n){\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n    private int lcm(int x,int y){\\n        int a = x, b = y; \\n        while(a!=0){\\n            int t = a;\\n            a = b%a;\\n            b = t;\\n        }\\n        return (int)(x*(y/(double)b));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359321,
                "title": "intuitive-binary-search",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int cur = 0;\\n        \\n        auto lcm_ab = lcm<long long, long long>(a, b);\\n        auto lcm_ac = lcm<long long, long long>(a, c);\\n        auto lcm_bc = lcm<long long, long long>(b, c);\\n        auto lcm_abc = lcm<long long, long long>(lcm_ab, lcm_ac);\\n        \\n        long long l = 1;\\n        long long h = 2 * 1\\'000\\'000\\'001;\\n        \\n        int ans = 0;\\n        while (l <= h) {\\n            auto mid = (l + h) / 2;\\n            long long counter = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac + mid / lcm_abc;\\n            \\n            if (counter >= n) {\\n                h = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int cur = 0;\\n        \\n        auto lcm_ab = lcm<long long, long long>(a, b);\\n        auto lcm_ac = lcm<long long, long long>(a, c);\\n        auto lcm_bc = lcm<long long, long long>(b, c);\\n        auto lcm_abc = lcm<long long, long long>(lcm_ab, lcm_ac);\\n        \\n        long long l = 1;\\n        long long h = 2 * 1\\'000\\'000\\'001;\\n        \\n        int ans = 0;\\n        while (l <= h) {\\n            auto mid = (l + h) / 2;\\n            long long counter = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac + mid / lcm_abc;\\n            \\n            if (counter >= n) {\\n                h = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235272,
                "title": "c-runtime-0-ms-faster-than-100-00-of-c-online-submissions-for-ugly",
                "content": "class Solution {\\npublic:\\n\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        \\n    long long a=(long)a1;\\n    long long b=(long)b1;\\n    long long c=(long)c1;\\n    long long ab=a*b/__gcd(a,b);\\n    long long bc=b*c/__gcd(b,c);\\n    long long ac=a*c/__gcd(a,c);\\n    long long abc= a*bc/__gcd(a,bc);\\n    long long int l=min({a,b,c}),r=1e18+100;\\n        int ans =0;\\n        while(l<=r)\\n        {\\n            long long int mid=l+(r-l)/2;\\n            long long int count=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            \\n           \\n            if(count>=n)\\n            {   ans =mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        \\n    long long a=(long)a1;\\n    long long b=(long)b1;\\n    long long c=(long)c1;\\n    long long ab=a*b/__gcd(a,b);\\n    long long bc=b*c/__gcd(b,c);\\n    long long ac=a*c/__gcd(a,c);\\n    long long abc= a*bc/__gcd(a,bc);\\n    long long int l=min({a,b,c}",
                "codeTag": "Java"
            },
            {
                "id": 2178255,
                "title": "c-binary-search-with-inclusion-exclusion-principle",
                "content": "```\\n/* \\n    Time: O(log(n*min(a,b,c)))\\n    Space: O(1)\\n    Tag: Binary Search, Maths\\n    Difficulty: H\\n    Easier Version: https://leetcode.com/problems/nth-magical-number/\\n*/\\n\\nclass Solution {\\n    long long gcd(long long a, long long b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long lo = 0, hi = n * min({a, b, c});\\n        long long mid = 0, ans = -1;\\n\\n        long long lcmABC = (((long long)a * b * c) * gcd(c, gcd(a, b))) / (gcd(a, b) * gcd(b, c) * gcd(c, a));\\n        long long lcmAB = (long long)a * b / gcd(a, b);\\n        long long lcmBC = (long long)b * c / gcd(b, c);\\n        long long lcmCA = (long long)c * a / gcd(c, a);\\n\\n        while (lo <= hi) {\\n            mid = lo + (hi - lo) / 2;\\n\\n            long long curPos = mid / a + mid / b + mid / c - mid / lcmAB - mid / lcmBC - mid / lcmCA + mid / lcmABC;\\n\\n            if (curPos < n)\\n                lo = mid + 1;\\n            else {\\n                ans = mid;\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\n/* \\n    Time: O(log(n*min(a,b,c)))\\n    Space: O(1)\\n    Tag: Binary Search, Maths\\n    Difficulty: H\\n    Easier Version: https://leetcode.com/problems/nth-magical-number/\\n*/\\n\\nclass Solution {\\n    long long gcd(long long a, long long b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long lo = 0, hi = n * min({a, b, c});\\n        long long mid = 0, ans = -1;\\n\\n        long long lcmABC = (((long long)a * b * c) * gcd(c, gcd(a, b))) / (gcd(a, b) * gcd(b, c) * gcd(c, a));\\n        long long lcmAB = (long long)a * b / gcd(a, b);\\n        long long lcmBC = (long long)b * c / gcd(b, c);\\n        long long lcmCA = (long long)c * a / gcd(c, a);\\n\\n        while (lo <= hi) {\\n            mid = lo + (hi - lo) / 2;\\n\\n            long long curPos = mid / a + mid / b + mid / c - mid / lcmAB - mid / lcmBC - mid / lcmCA + mid / lcmABC;\\n\\n            if (curPos < n)\\n                lo = mid + 1;\\n            else {\\n                ans = mid;\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176900,
                "title": "java-solutions",
                "content": "class Solution {\\n    static long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n     static long lcm(long a, long b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n\\n   static long count(long a, long b, long c, long num) {\\n        return ((num / a) + (num / b) + (num / c)\\n                - (num / lcm(a, b))\\n                - (num / lcm(b, c))\\n                - (num / lcm(a, c))\\n                + (num / lcm(a, lcm(b, c))));\\n    }\\n      public static int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = Integer.MAX_VALUE; \\n        while (low < high) {\\n          int   mid = low + (high - low) / 2;\\n            if (count(a, b, c, mid) < n)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    static long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2130727,
                "title": "c-numbertheory-easy-binary-search",
                "content": "\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        long long a=(long)a1;\\n        long long b=(long)b1;\\n        long long c=(long)c1;\\n        long long ab=a*b/__gcd(a,b);\\n        long long bc=b*c/__gcd(b,c);\\n        long long ac=a*c/__gcd(a,c);\\n        long long abc= a*bc/__gcd(a,bc);\\n        int lo=1,hi=2*(int)1e9;\\n        int mid=0;\\n        while(lo<hi){\\n            mid=(hi-lo)/2+lo;\\n            int count= mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(count<n){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return lo;\\n\\n",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        long long a=(long)a1;\\n        long long b=(long)b1;\\n        long long c=(long)c1;\\n        long long ab=a*b/__gcd(a,b);\\n        long long bc=b*c/__gcd(b,c);\\n        long long ac=a*c/__gcd(a,c);\\n        long long abc= a*bc/__gcd(a,bc);\\n        int lo=1,hi=2*(int)1e9;\\n        int mid=0;\\n        while(lo<hi){\\n            mid=(hi-lo)/2+lo;\\n            int count= mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(count<n){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return lo;\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2066381,
                "title": "c-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n    long long lcm(int a, int b){\\n        return ((long long)a * b) / gcd(a, b);\\n    }\\n    \\n    long long getUglyCount(int n, int a, int b, int c){\\n        long long count = (long long)(n / a) + (n / b) + (n / c);\\n        count -= n / lcm(a, b);\\n        count -= n / lcm(b, c);\\n        count -= n / lcm(c, a);\\n        count += n / lcm(lcm(a, b), c);\\n        return count;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int start = 1;\\n        int end = 2e9;\\n        int mid;\\n        \\n        while(start <= end){\\n            mid = start + (end - start) / 2;\\n            if(start == mid){\\n                if(getUglyCount(start, a, b, c) == n){\\n                    return start;\\n                }\\n                else if(getUglyCount(end, a, b, c) == n){\\n                    return end;\\n                }\\n                return -1;\\n            }\\n            else{\\n                if(getUglyCount(mid, a, b, c) >= n){\\n                    end = mid;\\n                }\\n                else{\\n                    start = mid;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n    long long lcm(int a, int b){\\n        return ((long long)a * b) / gcd(a, b);\\n    }\\n    \\n    long long getUglyCount(int n, int a, int b, int c){\\n        long long count = (long long)(n / a) + (n / b) + (n / c);\\n        count -= n / lcm(a, b);\\n        count -= n / lcm(b, c);\\n        count -= n / lcm(c, a);\\n        count += n / lcm(lcm(a, b), c);\\n        return count;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int start = 1;\\n        int end = 2e9;\\n        int mid;\\n        \\n        while(start <= end){\\n            mid = start + (end - start) / 2;\\n            if(start == mid){\\n                if(getUglyCount(start, a, b, c) == n){\\n                    return start;\\n                }\\n                else if(getUglyCount(end, a, b, c) == n){\\n                    return end;\\n                }\\n                return -1;\\n            }\\n            else{\\n                if(getUglyCount(mid, a, b, c) >= n){\\n                    end = mid;\\n                }\\n                else{\\n                    start = mid;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992848,
                "title": "binary-search-inclusion-exclusion-c",
                "content": "```\\n    int gcd(int a, int b) \\n    {\\n        if (a == 0) return b;\\n        if (b == 0) return a;\\n        return gcd(b%a, a);\\n    }\\n\\n    int64_t lcm(int a, int b)\\n    {\\n        return (int64_t) a * (b / gcd(a, b));\\n    }\\n    \\n    int check(int x, int a, int b, int c)\\n    {\\n        /* Count ugly numbers less than or equal to x using inclusion-exclusion */\\n        return (unsigned) x / a + x / b + x / c +\\n         - (x / lcm(a, b) + x / lcm(a, c) + x / lcm(b, c))\\n        + x / lcm(lcm(a, b), c);\\n    }\\n\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        int l = 1, r = INT_MAX;\\n        while (l < r) { /* use binary search to find the smalest value for which the count is n */\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, a, b, c) >= n) \\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    int gcd(int a, int b) \\n    {\\n        if (a == 0) return b;\\n        if (b == 0) return a;\\n        return gcd(b%a, a);\\n    }\\n\\n    int64_t lcm(int a, int b)\\n    {\\n        return (int64_t) a * (b / gcd(a, b));\\n    }\\n    \\n    int check(int x, int a, int b, int c)\\n    {\\n        /* Count ugly numbers less than or equal to x using inclusion-exclusion */\\n        return (unsigned) x / a + x / b + x / c +\\n         - (x / lcm(a, b) + x / lcm(a, c) + x / lcm(b, c))\\n        + x / lcm(lcm(a, b), c);\\n    }\\n\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        int l = 1, r = INT_MAX;\\n        while (l < r) { /* use binary search to find the smalest value for which the count is n */\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, a, b, c) >= n) \\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980247,
                "title": "c-binary-search-inclusion-exclusion-principle",
                "content": "```\\n// NOTE: be careful on places where will overflow int\\n\\ntypedef long long LL;\\n\\nclass Solution {\\n    LL lcm(int a, int b)\\n    {\\n        return (LL)a * b / gcd(a, b);\\n    }\\n    int check(int x, int a, int b, int c, int n)\\n    {\\n        LL cnt = (LL)x / a + x / b + x / c;\\n        cnt -= (x / lcm(a, b) + x / lcm(a, c) + x / lcm(b, c));\\n        cnt += x / lcm(lcm(a, b), c);\\n        return cnt >= n;\\n    }\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int l = 1, r = 2e9;\\n        while (l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, a, b, c, n)) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// NOTE: be careful on places where will overflow int\\n\\ntypedef long long LL;\\n\\nclass Solution {\\n    LL lcm(int a, int b)\\n    {\\n        return (LL)a * b / gcd(a, b);\\n    }\\n    int check(int x, int a, int b, int c, int n)\\n    {\\n        LL cnt = (LL)x / a + x / b + x / c;\\n        cnt -= (x / lcm(a, b) + x / lcm(a, c) + x / lcm(b, c));\\n        cnt += x / lcm(lcm(a, b), c);\\n        return cnt >= n;\\n    }\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int l = 1, r = 2e9;\\n        while (l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, a, b, c, n)) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918861,
                "title": "binary-search-100-faster-c-principle-of-inclusion-exclusion",
                "content": "```\\nclass Solution {\\n\\n    long lcm(long a, long b) {\\n        if (a==0 or b==0)\\n            return 0;\\n        return a*b/__gcd(a, b);\\n    }\\n    \\n    long count(long a, long b, long c, long x) {\\n        long divs = x/a+x/b+x/c;\\n        divs -= ( x/lcm(a, b) + x/lcm(b, c) + x/lcm(c, a) );\\n        divs += ( x/lcm(a, lcm(b, c)) );\\n    return divs;\\n    }    \\n    \\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long l = 1;\\n        long r = INT_MAX;\\n        long ans=-1;\\n        while(l<=r) {\\n            long m = (l+r)/2;\\n            if (count((long)a, (long)b, (long)c, m)>=n) {\\n                ans=m;\\n                r=m-1;\\n            } else l=m+1;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    long lcm(long a, long b) {\\n        if (a==0 or b==0)\\n            return 0;\\n        return a*b/__gcd(a, b);\\n    }\\n    \\n    long count(long a, long b, long c, long x) {\\n        long divs = x/a+x/b+x/c;\\n        divs -= ( x/lcm(a, b) + x/lcm(b, c) + x/lcm(c, a) );\\n        divs += ( x/lcm(a, lcm(b, c)) );\\n    return divs;\\n    }    \\n    \\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long l = 1;\\n        long r = INT_MAX;\\n        long ans=-1;\\n        while(l<=r) {\\n            long m = (l+r)/2;\\n            if (count((long)a, (long)b, (long)c, m)>=n) {\\n                ans=m;\\n                r=m-1;\\n            } else l=m+1;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710035,
                "title": "100-binary-search",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong  lcm(long a,long b){\\n\\t\\t\\treturn a*b/__gcd(a,b);\\n\\t\\t}\\n\\t\\tint nthUglyNumber(int n, int a, int b, int c) {\\n\\n\\t\\t\\tlong  l=min({a,b,c}),r=long(n)*max({a,b,c});\\n\\n\\t\\t\\tlong lcmab=lcm(a,b),lcmac=lcm(a,c),lcmbc=lcm(b,c),lcmabc=lcm(a,lcmbc);\\n\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tlong mid=(r+l)/2;\\n\\t\\t\\t\\tlong t=mid/a+mid/b+mid/c;\\n\\t\\t\\t\\tt=t-mid/lcmab-mid/lcmac-mid/lcmbc+mid/lcmabc;\\n\\t\\t\\t\\tif(t<n)l=mid+1;\\n\\t\\t\\t\\telse r=mid;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn r;\\n\\t\\t}\\n\\n\\t};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong  lcm(long a,long b){\\n\\t\\t\\treturn a*b/__gcd(a,b);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1706361,
                "title": "c-binary-search-o-log-2000000000-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l=1,r=2000000000;\\n        long long p1=(long long)a*b;\\n        long long p2=(long long)c*b;\\n        long long p3=(long long)a*c;\\n        int x=p1/__gcd(a,b);\\n        long long p4=(long long)x*c;\\n        long long y=p2/__gcd(b,c);\\n        long long z=p3/__gcd(c,a);\\n        long long lcm=p4/__gcd(x,c);\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            long long cnt=(mid/a)+(mid/b)+(mid/c)-(mid/x)-(mid/y)-(mid/z)+(mid/lcm);\\n            if(cnt==n and (mid%a==0 or mid%b==0 or mid%c==0)){\\n                return mid;\\n            }\\n            \\n            if(cnt>=n){\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l=1,r=2000000000;\\n        long long p1=(long long)a*b;\\n        long long p2=(long long)c*b;\\n        long long p3=(long long)a*c;\\n        int x=p1/__gcd(a,b);\\n        long long p4=(long long)x*c;\\n        long long y=p2/__gcd(b,c);\\n        long long z=p3/__gcd(c,a);\\n        long long lcm=p4/__gcd(x,c);\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            long long cnt=(mid/a)+(mid/b)+(mid/c)-(mid/x)-(mid/y)-(mid/z)+(mid/lcm);\\n            if(cnt==n and (mid%a==0 or mid%b==0 or mid%c==0)){\\n                return mid;\\n            }\\n            \\n            if(cnt>=n){\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686494,
                "title": "c-binary-search-100-faster",
                "content": "```\\n//count of N elements in the set AUBUC\\n    //F(N) = a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n    long long lcm(long long a, long long b) \\n    {\\n        return a*b / __gcd(a, b);\\n    }\\n    \\n    int nthUglyNumber(int N, int A, int B, int C) \\n    {\\n        long long lo = 1, hi = 2000000000, mid, ans;\\n        \\n        while(lo <= hi)\\n        {\\n            mid = lo + (hi - lo)/2;\\n            long long ctr = 0;\\n            ctr += mid/A;\\n            ctr += mid/B;\\n            ctr += mid/C;\\n            ctr -= mid / lcm(A, B);\\n            ctr -= mid / lcm(B, C);\\n            ctr -= mid / lcm(C, A);\\n            ctr += mid / lcm(A, lcm(B, C));\\n            \\n            if(ctr >= N)\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n//count of N elements in the set AUBUC\\n    //F(N) = a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n    long long lcm(long long a, long long b) \\n    {\\n        return a*b / __gcd(a, b);\\n    }\\n    \\n    int nthUglyNumber(int N, int A, int B, int C) \\n    {\\n        long long lo = 1, hi = 2000000000, mid, ans;\\n        \\n        while(lo <= hi)\\n        {\\n            mid = lo + (hi - lo)/2;\\n            long long ctr = 0;\\n            ctr += mid/A;\\n            ctr += mid/B;\\n            ctr += mid/C;\\n            ctr -= mid / lcm(A, B);\\n            ctr -= mid / lcm(B, C);\\n            ctr -= mid / lcm(C, A);\\n            ctr += mid / lcm(A, lcm(B, C));\\n            \\n            if(ctr >= N)\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1628737,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    ll lcm(ll a,ll b)\\n    {\\n        return (a*b)/(__gcd(a,b));\\n    }\\n    ll find(ll a,ll b,ll c,ll mid)\\n    {\\n        ll x1=(mid/a)+(mid/b)+(mid/c);\\n        return x1-(mid/lcm(a,b))-(mid/lcm(b,c))-(mid/lcm(a,c))+(mid/lcm(a,lcm(b,c)));\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll l=min({a,b,c});\\n        ll r=1e18+1000;\\n        ll ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            if(find(a,b,c,mid)<n)\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    ll lcm(ll a,ll b)\\n    {\\n        return (a*b)/(__gcd(a,b));\\n    }\\n    ll find(ll a,ll b,ll c,ll mid)\\n    {\\n        ll x1=(mid/a)+(mid/b)+(mid/c);\\n        return x1-(mid/lcm(a,b))-(mid/lcm(b,c))-(mid/lcm(a,c))+(mid/lcm(a,lcm(b,c)));\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll l=min({a,b,c});\\n        ll r=1e18+1000;\\n        ll ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            if(find(a,b,c,mid)<n)\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622869,
                "title": "binary-search-0ms-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // Binary Search on the answer\\n    long long LCM(long long x, long long y){\\n        return (1LL * x * y ) / __gcd(x, y);\\n    }\\n    \\n    long long check(long long n, long long a, long long b, long long c, long long upper){\\n        \\n        long long count = (upper / a) + (upper / b) + (upper / c);\\n        count -= (upper / LCM(a,b)); // intersection of a and b (-)\\n        count -= (upper / LCM(a,c)); // intersection of a and c (-)\\n        count -= (upper / LCM(b,c)); // intersection of b and c (-)\\n        count += (upper/LCM(a, LCM(b,c))); // intersection of a, b and c (+)\\n        \\n        return count >= n;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long l = 1LL * min({a, b, c}) , r = 1LL * max({a , b , c}) * n;\\n        long long ans = 0;\\n\\n        while(l <= r){\\n            long long upper = l + (r - l) / 2;\\n            \\n            if(check(n,a,b,c,upper)){\\n                ans = upper;\\n                r = upper - 1;\\n            }\\n            else{\\n                l = upper + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Binary Search on the answer\\n    long long LCM(long long x, long long y){\\n        return (1LL * x * y ) / __gcd(x, y);\\n    }\\n    \\n    long long check(long long n, long long a, long long b, long long c, long long upper){\\n        \\n        long long count = (upper / a) + (upper / b) + (upper / c);\\n        count -= (upper / LCM(a,b)); // intersection of a and b (-)\\n        count -= (upper / LCM(a,c)); // intersection of a and c (-)\\n        count -= (upper / LCM(b,c)); // intersection of b and c (-)\\n        count += (upper/LCM(a, LCM(b,c))); // intersection of a, b and c (+)\\n        \\n        return count >= n;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long l = 1LL * min({a, b, c}) , r = 1LL * max({a , b , c}) * n;\\n        long long ans = 0;\\n\\n        while(l <= r){\\n            long long upper = l + (r - l) / 2;\\n            \\n            if(check(n,a,b,c,upper)){\\n                ans = upper;\\n                r = upper - 1;\\n            }\\n            else{\\n                l = upper + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585931,
                "title": "straightforward-approach-takes-0-ms-faster-than-100-00-of-c-submissions",
                "content": "I implemented just a simple cycle: we enumerate all the ugly numbers until we reach the n-th. And this algortithm works pretty fast (takes 0ms) and uses O(1) space.\\n\\nBut of course the idea to use binary search is very smart and should be used.\\n\\n```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll u = 1;\\n        ll A = a;\\n        ll B = b;\\n        ll C = c;\\n        ll i = 0;    \\n        while (i < n) {\\n            ll delta;\\n            ll D = min(B, C) - A;\\n            ll E = min(A, C) - B;\\n            ll F = min(A, B) - C;\\n            if (D >= 0) {\\n                delta = min(D / a, n - i - 1);\\n                u = A + a * delta;\\n                A = u + a;\\n            } else if (E >= 0) {\\n                delta = min(E / b, n - i - 1);\\n                u = B + b * delta;\\n                B = u + b;\\n            } else {\\n                delta = min(F / c, n - i - 1);\\n                u = C + c * delta;\\n                C = u + c;\\n            }\\n            i += delta + 1;\\n            \\n            if (u == A) {\\n                A += a;\\n            }\\n            if (u == B) {\\n                B += b;\\n            }\\n            if (u == C) {\\n                C += c;\\n            }\\n        }\\n        \\n        return u; \\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll u = 1;\\n        ll A = a;\\n        ll B = b;\\n        ll C = c;\\n        ll i = 0;    \\n        while (i < n) {\\n            ll delta;\\n            ll D = min(B, C) - A;\\n            ll E = min(A, C) - B;\\n            ll F = min(A, B) - C;\\n            if (D >= 0) {\\n                delta = min(D / a, n - i - 1);\\n                u = A + a * delta;\\n                A = u + a;\\n            } else if (E >= 0) {\\n                delta = min(E / b, n - i - 1);\\n                u = B + b * delta;\\n                B = u + b;\\n            } else {\\n                delta = min(F / c, n - i - 1);\\n                u = C + c * delta;\\n                C = u + c;\\n            }\\n            i += delta + 1;\\n            \\n            if (u == A) {\\n                A += a;\\n            }\\n            if (u == B) {\\n                B += b;\\n            }\\n            if (u == C) {\\n                C += c;\\n            }\\n        }\\n        \\n        return u; \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545883,
                "title": "c-1201-ugly-number-iii",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        // inclusion-exclusion principle\\n        long ab = (long) a/gcd(a, b)*b, bc = (long) b/gcd(b, c)*c, ca = (long) c/gcd(c, a)*a, abc = (long) ab/gcd(ab, c)*c; \\n        int lo = 0, hi = n*min({a, b, c});\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo)/2; \\n            if (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc < n) lo = mid + 1; \\n            else hi = mid; \\n        }\\n        return lo; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        // inclusion-exclusion principle\\n        long ab = (long) a/gcd(a, b)*b, bc = (long) b/gcd(b, c)*c, ca = (long) c/gcd(c, a)*a, abc = (long) ab/gcd(ab, c)*c; \\n        int lo = 0, hi = n*min({a, b, c});\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo)/2; \\n            if (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc < n) lo = mid + 1; \\n            else hi = mid; \\n        }\\n        return lo; \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1943203,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1568216,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1573075,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1573034,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1569764,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1569635,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1860364,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1717190,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1574746,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1574559,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1943203,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1568216,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1573075,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1573034,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1569764,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1569635,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1860364,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1717190,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1574746,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1574559,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            }
        ]
    },
    {
        "title": "Average Time of Process per Machine",
        "question_content": "<p>Table: <code>Activity</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| machine_id     | int     |\n| process_id     | int     |\n| activity_type  | enum    |\n| timestamp      | float   |\n+----------------+---------+\nThe table shows the user activities for a factory website.\n(machine_id, process_id, activity_type) is the primary key (combination of columns with unique values) of this table.\nmachine_id is the ID of a machine.\nprocess_id is the ID of a process running on the machine with ID machine_id.\nactivity_type is an ENUM (category) of type (&#39;start&#39;, &#39;end&#39;).\ntimestamp is a float representing the current time in seconds.\n&#39;start&#39; means the machine starts the process at the given timestamp and &#39;end&#39; means the machine ends the process at the given timestamp.\nThe &#39;start&#39; timestamp will always be before the &#39;end&#39; timestamp for every (machine_id, process_id) pair.</pre>\n\n<p>&nbsp;</p>\n\n<p>There is a factory website that has several machines each running the <strong>same number of processes</strong>. Write a solution&nbsp;to find the <strong>average time</strong> each machine takes to complete a process.</p>\n\n<p>The time to complete a process is the <code>&#39;end&#39; timestamp</code> minus the <code>&#39;start&#39; timestamp</code>. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.</p>\n\n<p>The resulting table should have the <code>machine_id</code> along with the <strong>average time</strong> as <code>processing_time</code>, which should be <strong>rounded to 3 decimal places</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nActivity table:\n+------------+------------+---------------+-----------+\n| machine_id | process_id | activity_type | timestamp |\n+------------+------------+---------------+-----------+\n| 0          | 0          | start         | 0.712     |\n| 0          | 0          | end           | 1.520     |\n| 0          | 1          | start         | 3.140     |\n| 0          | 1          | end           | 4.120     |\n| 1          | 0          | start         | 0.550     |\n| 1          | 0          | end           | 1.550     |\n| 1          | 1          | start         | 0.430     |\n| 1          | 1          | end           | 1.420     |\n| 2          | 0          | start         | 4.100     |\n| 2          | 0          | end           | 4.512     |\n| 2          | 1          | start         | 2.500     |\n| 2          | 1          | end           | 5.000     |\n+------------+------------+---------------+-----------+\n<strong>Output:</strong> \n+------------+-----------------+\n| machine_id | processing_time |\n+------------+-----------------+\n| 0          | 0.894           |\n| 1          | 0.995           |\n| 2          | 1.456           |\n+------------+-----------------+\n<strong>Explanation:</strong> \nThere are 3 machines running 2 processes each.\nMachine 0&#39;s average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\nMachine 1&#39;s average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\nMachine 2&#39;s average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456\n</pre>\n",
        "solutions": [
            {
                "id": 3722056,
                "title": "sql-join-or-subquery-easy-to-understand",
                "content": "# Intuition\\n***The paste was solved in 2 different ways.\\nIn the first one, a solution based on \\'join\\' is achieved (which is more self-explanatory)\\nIn the second one, the solution is achieved through subqueries (This solution is also understandable and wonderful)***\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/c0d84b6d-15b9-43c1-b31d-999d38c4781e_1688555463.4935868.png)\\n\\n# First Solution\\n```\\nselect a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time \\nfrom Activity a1\\njoin Activity a2 \\non a1.machine_id=a2.machine_id and a1.process_id=a2.process_id\\nand a1.activity_type=\\'start\\' and a2.activity_type=\\'end\\'\\ngroup by a1.machine_id\\n\\n```\\n# Second Solution\\n```\\nselect \\na.machine_id,\\nround(\\n      (select avg(a1.timestamp) from Activity a1 where a1.activity_type = \\'end\\' and a1.machine_id = a.machine_id) - \\n      (select avg(a1.timestamp) from Activity a1 where a1.activity_type = \\'start\\' and a1.machine_id = a.machine_id)\\n,3) as processing_time\\nfrom Activity a\\ngroup by a.machine_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nselect a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time \\nfrom Activity a1\\njoin Activity a2 \\non a1.machine_id=a2.machine_id and a1.process_id=a2.process_id\\nand a1.activity_type=\\'start\\' and a2.activity_type=\\'end\\'\\ngroup by a1.machine_id\\n\\n```\n```\\nselect \\na.machine_id,\\nround(\\n      (select avg(a1.timestamp) from Activity a1 where a1.activity_type = \\'end\\' and a1.machine_id = a.machine_id) - \\n      (select avg(a1.timestamp) from Activity a1 where a1.activity_type = \\'start\\' and a1.machine_id = a.machine_id)\\n,3) as processing_time\\nfrom Activity a\\ngroup by a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3537533,
                "title": "detailed-explanation-of-join-round-avg-group-by",
                "content": "# Approach\\nTo solve this problem, 1st we need to join the same table, so we will have starting time and ending time in the same line:\\n\\n```\\nselect a1.machine_id, a1.timestamp, a2.timestamp\\nfrom Activity a1\\njoin Activity a2\\non a1.process_id=a2.process_id\\nand a1.machine_id=a2.machine_id\\nand a1.timestamp<a2.timestamp;\\n\\n| machine_id | timestamp | timestamp |\\n| ---------- | --------- | --------- |\\n| 0          | 0.712     | 1.52      |\\n| 0          | 3.14      | 4.12      |\\n| 1          | 0.55      | 1.55      |\\n| 1          | 0.43      | 1.42      |\\n| 2          | 4.1       | 4.512     |\\n| 2          | 2.5       | 5         |\\n```\\n\\nnow we can calculate the difference between timestamps, group the values by machine_id and round average value of differences\\n\\n```\\nselect a1.machine_id\\n, ROUND(AVG(a2.timestamp - a1.timestamp),3) as processing_time\\nfrom Activity a1\\njoin Activity a2\\non a1.process_id=a2.process_id\\nand a1.machine_id=a2.machine_id\\nand a1.timestamp<a2.timestamp\\ngroup by a1.machine_id;\\n\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n```\\n\\nPlease upvote if you like my explanation. Good luck!\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect a1.machine_id, a1.timestamp, a2.timestamp\\nfrom Activity a1\\njoin Activity a2\\non a1.process_id=a2.process_id\\nand a1.machine_id=a2.machine_id\\nand a1.timestamp<a2.timestamp;\\n\\n| machine_id | timestamp | timestamp |\\n| ---------- | --------- | --------- |\\n| 0          | 0.712     | 1.52      |\\n| 0          | 3.14      | 4.12      |\\n| 1          | 0.55      | 1.55      |\\n| 1          | 0.43      | 1.42      |\\n| 2          | 4.1       | 4.512     |\\n| 2          | 2.5       | 5         |\\n```\n```\\nselect a1.machine_id\\n, ROUND(AVG(a2.timestamp - a1.timestamp),3) as processing_time\\nfrom Activity a1\\njoin Activity a2\\non a1.process_id=a2.process_id\\nand a1.machine_id=a2.machine_id\\nand a1.timestamp<a2.timestamp\\ngroup by a1.machine_id;\\n\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941770,
                "title": "mysql-self-join-100-faster-100-less-memory",
                "content": "```\\nSELECT s.machine_id, ROUND(AVG(e.timestamp-s.timestamp), 3) AS processing_time\\nFROM Activity s JOIN Activity e ON\\n    s.machine_id = e.machine_id AND s.process_id = e.process_id AND\\n    s.activity_type = \\'start\\' AND e.activity_type = \\'end\\'\\nGROUP BY s.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.machine_id, ROUND(AVG(e.timestamp-s.timestamp), 3) AS processing_time\\nFROM Activity s JOIN Activity e ON\\n    s.machine_id = e.machine_id AND s.process_id = e.process_id AND\\n    s.activity_type = \\'start\\' AND e.activity_type = \\'end\\'\\nGROUP BY s.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3574206,
                "title": "best-optimum-solution-with-explanation-using-joins",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe problem asks us to calculate the average time taken to process each machine based on start and end activities recorded in the \"Activity\" table.\\n\\n# Approach\\nTo solve this problem, we use a SQL query with the following steps:\\n\\n1. We join the \"Activity\" table with itself using the \"machine_id\" column. This allows us to pair the start and end activities for each machine.\\n1. We filter the rows to include only the start activities for the first occurrence and the end activities for the second occurrence. This ensures we have matched start and end activities for each machine.\\n1. We calculate the time difference between the start and end activities for each machine by subtracting the start timestamp from the end timestamp.\\n1. We use the AVG function to calculate the average processing time for each machine.\\n1. We round the average processing time to three decimal places using the ROUND function.\\n1. Finally, we group the results by \"machine_id\" to get the average processing time for each machine.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this query depends on the size of the \"Activity\" table and the efficiency of the database engine. For a well-indexed table, the time complexity is usually efficient. We can say that it will take $$O(n log n)$$ or $$O(n)$$ time, where n is the number of rows in the \"Activity\" table. The database engine uses techniques like indexing and joining algorithms to quickly process the query.\\n\\n- Space complexity:\\nThe space complexity of this query is determined by the size of the result set. In other words, it depends on the number of machines for which there are start and end activities. We can say the space complexity is $$O(n)$$, where n is the number of machines. The memory required to store the result set grows with the number of machines.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    s.machine_id, \\n    ROUND(AVG(e.timestamp-s.timestamp),3) as processing_time \\nFROM Activity s\\nJOIN Activity e ON e.machine_id=s.machine_id\\nWHERE s.activity_type=\\'start\\' AND e.activity_type=\\'end\\'\\nGROUP BY s.machine_id\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/0e5e5357-5af9-4902-a584-62f5ac275515_1685478393.9930801.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    s.machine_id, \\n    ROUND(AVG(e.timestamp-s.timestamp),3) as processing_time \\nFROM Activity s\\nJOIN Activity e ON e.machine_id=s.machine_id\\nWHERE s.activity_type=\\'start\\' AND e.activity_type=\\'end\\'\\nGROUP BY s.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950171,
                "title": "simple-mysql-no-join",
                "content": "```\\nSELECT machine_id, ROUND((SUM(CASE WHEN activity_type = \\'end\\' THEN timestamp END)-SUM(CASE WHEN activity_type = \\'start\\' THEN timestamp END))/COUNT(DISTINCT process_id), 3) processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT machine_id, ROUND((SUM(CASE WHEN activity_type = \\'end\\' THEN timestamp END)-SUM(CASE WHEN activity_type = \\'start\\' THEN timestamp END))/COUNT(DISTINCT process_id), 3) processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861997,
                "title": "100-easy-fast-clean-2-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code1\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT A1.machine_id, ROUND(AVG(A2.timestamp - A1.timestamp),3) As \\n\\nprocessing_time FROM Activity A1, Activity A2 WHERE \\n\\nA1.machine_id = A2.machine_id AND A1.process_id = A2.process_id \\n\\nAND A1.timestamp < A2.timestamp GROUP BY A1.machine_id\\n\\n\\n```\\n\\n# Code2\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT A.machine_id, ROUND(( SELECT AVG(A1.timestamp) FROM Activity A1\\n\\nWHERE A1.activity_type=\\'end\\' AND A1.machine_id = A.machine_id) -  \\n\\n( SELECT AVG(A1.timestamp) FROM Activity A1 WHERE \\n\\nA1.activity_type=\\'start\\' AND A1.machine_id = A.machine_id), 3) AS \\n\\nprocessing_time FROM Activity A GROUP BY A.machine_id\\n```\\n\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/2f9cf237-bad8-4dbf-b421-b227f9fbc79e_1691140207.4912024.jpeg)\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT A1.machine_id, ROUND(AVG(A2.timestamp - A1.timestamp),3) As \\n\\nprocessing_time FROM Activity A1, Activity A2 WHERE \\n\\nA1.machine_id = A2.machine_id AND A1.process_id = A2.process_id \\n\\nAND A1.timestamp < A2.timestamp GROUP BY A1.machine_id\\n\\n\\n```\n```\\n/* Write your PL/SQL query statement below */\\nSELECT A.machine_id, ROUND(( SELECT AVG(A1.timestamp) FROM Activity A1\\n\\nWHERE A1.activity_type=\\'end\\' AND A1.machine_id = A.machine_id) -  \\n\\n( SELECT AVG(A1.timestamp) FROM Activity A1 WHERE \\n\\nA1.activity_type=\\'start\\' AND A1.machine_id = A.machine_id), 3) AS \\n\\nprocessing_time FROM Activity A GROUP BY A.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084239,
                "title": "simple-solution-without-join",
                "content": "```\\nselect machine_id, \\nround(sum(case when activity_type = \\'start\\' then -1*timestamp else timestamp end)/count(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect machine_id, \\nround(sum(case when activity_type = \\'start\\' then -1*timestamp else timestamp end)/count(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081173,
                "title": "why-make-it-complicated-easiest-solution-ever",
                "content": "```\\nSELECT \\n    machine_id,\\n    ROUND(AVG(IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    machine_id,\\n    ROUND(AVG(IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1028190,
                "title": "solution-using-avg-and-case-mysql",
                "content": "Explanation:\\nWhat we actually want to do is to compute the difference corresponding to each machine and process pair and then take average. \\n1. Instead of difference, we can just add negative timestamp of the \\'start\\' entry and positive timestamp for \\'end\\' entry. It will effectively be the same.\\n2. After doing this, when you take average, the total number of entries double because value corresponding to end and start are considered separately. So, multiply the average with a 2.\\n3. Finally, the average we want is for all the processes corresponding to a machine. So, we just have to group by machine. Which process the start and end timestamps belong to is not required because we are just finding the average.\\n\\n```\\nSELECT\\n    a.machine_id, ROUND(AVG(CASE \\n                   WHEN a.activity_type = \\'end\\' THEN a.timestamp\\n                   WHEN a.activity_type = \\'start\\' THEN -a.timestamp\\n                  END)*2, 3) as processing_time\\nFROM\\n    Activity a\\nGROUP BY\\n    a.machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    a.machine_id, ROUND(AVG(CASE \\n                   WHEN a.activity_type = \\'end\\' THEN a.timestamp\\n                   WHEN a.activity_type = \\'start\\' THEN -a.timestamp\\n                  END)*2, 3) as processing_time\\nFROM\\n    Activity a\\nGROUP BY\\n    a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029004,
                "title": "no-joins-no-subquery-easy-solution",
                "content": "\\n# Approach\\n\\nCalculate the time take by processes to complete\\nby the formula given in question \\n\\nthen divide it by count(*) / 2  \\n\\ncount(*) will give pairs (start,end) for a  process\\ndivide it by 2 to get no. of processes\\n\\nat the end group iy by machine_id to get machine wise avg time\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n select machine_id ,\\n\\n Round(\\n\\n    ( sum(case when activity_type = \\'end\\' then timestamp else 0 end) - \\n     sum(case when activity_type = \\'start\\' then timestamp else 0 end) ) / (count(*)/2)\\n     \\n\\n     ,3\\n ) as processing_time\\n\\n from activity\\n group by machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n select machine_id ,\\n\\n Round(\\n\\n    ( sum(case when activity_type = \\'end\\' then timestamp else 0 end) - \\n     sum(case when activity_type = \\'start\\' then timestamp else 0 end) ) / (count(*)/2)\\n     \\n\\n     ,3\\n ) as processing_time\\n\\n from activity\\n group by machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449053,
                "title": "easy-simple-querry-using-only-case-when-then",
                "content": "**1.Lastly to round 3 digits after column**\\n\\uD83D\\uDC47\\uD83C\\uDFFB \\n```\\nRound( ,3)\\n```\\n**2.To get average of all cells with timestamp column**\\n\\uD83D\\uDC47\\uD83C\\uDFFB \\n```\\nRound(avg(),3)\\n```\\n**3.Simple institution \\uD83E\\uDD17 \\nwhen activity is start, get from row timestamp\\nwhen activity is end, get from row -timestamp**\\n\\uD83D\\uDC47\\uD83C\\uDFFB\\n```\\nRound(avg(case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend),3)\\n```\\n**4.In 3rd step our avg() getting 2 times more values,\\nso deviding it into the same number. \\nJust multiply it by 2**\\n\\n**5.As out end allways greater you can use \"-\" sign like this \\uD83D\\uDC47\\uD83C\\uDFFB**\\n```\\nRound(avg(\\n  case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend\\n)*(-2),3)\\n```\\n**or avg() function it is your wish**\\n\\n**GOOD LUCK\\u2757\\uFE0F**\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect machine_id, Round(avg(\\n  case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend\\n)*(-2),3)as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nRound( ,3)\\n```\n```\\nRound(avg(),3)\\n```\n```\\nRound(avg(case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend),3)\\n```\n```\\nRound(avg(\\n  case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend\\n)*(-2),3)\\n```\n```\\n# Write your MySQL query statement below\\nselect machine_id, Round(avg(\\n  case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend\\n)*(-2),3)as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1035191,
                "title": "mysql-case-when",
                "content": "\\n```\\nSELECT \\n    machine_id, \\n    ROUND(SUM(CASE WHEN activity_type = \"end\" THEN timestamp ELSE -timestamp END)/COUNT(DISTINCT process_id), 3) AS processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    machine_id, \\n    ROUND(SUM(CASE WHEN activity_type = \"end\" THEN timestamp ELSE -timestamp END)/COUNT(DISTINCT process_id), 3) AS processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2507960,
                "title": "5-different-methods-basically-sum-count-or-avg-difference",
                "content": "/*#window function\\nselect\\nmachine_id,\\nround(avg(time_diff),3) processing_time\\nfrom\\n(select\\nmachine_id,\\ntimestamp - lag(timestamp,1)over(partition by machine_id, Process_id order by timestamp) as time_diff\\nfrom activity) a\\nwhere time_diff is not null\\ngroup by 1\\n*/\\n/*#most simple way with temp table\\nwith starttime as (select machine_id, timestamp as starttime from activity where activity_type =\\'start\\'),\\n\\nendtime as (select machine_id, timestamp as endtime from activity where activity_type =\\'end\\')\\n\\nselect s.machine_id,\\nround(avg(endtime-starttime),3) as processing_time\\nfrom starttime s\\ninner join endtime e on s.machine_id=e.machine_id\\ngroup by 1\\n*/\\n/*#sum(if())\\nselect machine_id,\\nround(sum(if(activity_type=\\'start\\', -timestamp, timestamp)) / count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by 1\\n*/\\n/*case statement\\nselect\\nmachine_id,\\nround((endtime-starttime)/cnt_pid, 3) as processing_time\\nfrom\\n(\\nselect machine_id,\\nsum(case when activity_type=\\'start\\' then timestamp end) as starttime,\\nsum(case when activity_type=\\'end\\' then timestamp end) as endtime,\\ncount(distinct process_id) as cnt_pid\\nfrom activity\\ngroup by 1) a\\n*/\\n",
                "solutionTags": [],
                "code": "/*#window function\\nselect\\nmachine_id,\\nround(avg(time_diff),3) processing_time\\nfrom\\n(select\\nmachine_id,\\ntimestamp - lag(timestamp,1)over(partition by machine_id, Process_id order by timestamp) as time_diff\\nfrom activity) a\\nwhere time_diff is not null\\ngroup by 1\\n*/\\n/*#most simple way with temp table\\nwith starttime as (select machine_id, timestamp as starttime from activity where activity_type =\\'start\\'),\\n\\nendtime as (select machine_id, timestamp as endtime from activity where activity_type =\\'end\\')\\n\\nselect s.machine_id,\\nround(avg(endtime-starttime),3) as processing_time\\nfrom starttime s\\ninner join endtime e on s.machine_id=e.machine_id\\ngroup by 1\\n*/\\n/*#sum(if())\\nselect machine_id,\\nround(sum(if(activity_type=\\'start\\', -timestamp, timestamp)) / count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by 1\\n*/\\n/*case statement\\nselect\\nmachine_id,\\nround((endtime-starttime)/cnt_pid, 3) as processing_time\\nfrom\\n(\\nselect machine_id,\\nsum(case when activity_type=\\'start\\' then timestamp end) as starttime,\\nsum(case when activity_type=\\'end\\' then timestamp end) as endtime,\\ncount(distinct process_id) as cnt_pid\\nfrom activity\\ngroup by 1) a\\n*/\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2268489,
                "title": "simple-mysql-solution-cte-group-by-sum-case-when",
                "content": "```\\n# Write your MySQL query statement below\\nWITH t AS (\\n    SELECT\\n        machine_id,\\n        process_id,\\n        SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp ELSE 0 END) AS start_time,\\n        SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp ELSE 0 END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n    ORDER BY machine_id, process_id\\n)\\nSELECT\\n    machine_id,\\n    ROUND(AVG(end_time-start_time), 3) AS processing_time\\nFROM t\\nGROUP BY machine_id\\nORDER BY machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH t AS (\\n    SELECT\\n        machine_id,\\n        process_id,\\n        SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp ELSE 0 END) AS start_time,\\n        SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp ELSE 0 END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n    ORDER BY machine_id, process_id\\n)\\nSELECT\\n    machine_id,\\n    ROUND(AVG(end_time-start_time), 3) AS processing_time\\nFROM t\\nGROUP BY machine_id\\nORDER BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 945756,
                "title": "mysql-solution-no-join-a-simple-groupby",
                "content": "```\\n# Write your MySQL query statement below\\nselect machine_id, \\nround(sum(case when activity_type = \\'end\\' then `timestamp` else -`timestamp` end) / \\ncount(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect machine_id, \\nround(sum(case when activity_type = \\'end\\' then `timestamp` else -`timestamp` end) / \\ncount(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3716919,
                "title": "mysql-simple-and-clean-beats-88",
                "content": "# Average Time of Process per Machine\\n### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n## Intuition\\n\\nThe problem requires us to find the average time each machine takes to complete a process in a factory. We are given a table that records the start and end timestamps of each process for each machine. To calculate the average time, we need to subtract the start timestamp from the end timestamp for each process and then find the average time for all processes on each machine.\\n\\n## Approach\\n\\nTo solve the problem, we can use the following approach:\\n\\n1. Join the `Activity` table with itself, denoting the first occurrence as `a` and the second occurrence as `b`.\\n2. Use the `JOIN` condition to match the rows with the same `machine_id`, `process_id`, and activity types \\'start\\' and \\'end\\'.\\n3. Calculate the time taken for each process by subtracting the start timestamp (`a.timestamp`) from the end timestamp (`b.timestamp`).\\n4. Use the `GROUP BY` clause to group the results by `machine_id`.\\n5. Apply the `AVG` function on the time taken for each machine to calculate the average time.\\n6. Round the average time to 3 decimal places using the `ROUND` function.\\n7. Select the `machine_id` and the rounded average time as `processing_time`.\\n\\nThe SQL query for the above approach is as follows:\\n\\n```sql\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a\\nJOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\nGROUP BY a.machine_id;\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Average Time of Process per Machine\\n### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n## Intuition\\n\\nThe problem requires us to find the average time each machine takes to complete a process in a factory. We are given a table that records the start and end timestamps of each process for each machine. To calculate the average time, we need to subtract the start timestamp from the end timestamp for each process and then find the average time for all processes on each machine.\\n\\n## Approach\\n\\nTo solve the problem, we can use the following approach:\\n\\n1. Join the `Activity` table with itself, denoting the first occurrence as `a` and the second occurrence as `b`.\\n2. Use the `JOIN` condition to match the rows with the same `machine_id`, `process_id`, and activity types \\'start\\' and \\'end\\'.\\n3. Calculate the time taken for each process by subtracting the start timestamp (`a.timestamp`) from the end timestamp (`b.timestamp`).\\n4. Use the `GROUP BY` clause to group the results by `machine_id`.\\n5. Apply the `AVG` function on the time taken for each machine to calculate the average time.\\n6. Round the average time to 3 decimal places using the `ROUND` function.\\n7. Select the `machine_id` and the rounded average time as `processing_time`.\\n\\nThe SQL query for the above approach is as follows:\\n\\n```sql\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a\\nJOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\nGROUP BY a.machine_id;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3558610,
                "title": "easy-sql-code",
                "content": "\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    machine_id,\\n    ROUND(AVG(IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    machine_id,\\n    ROUND(AVG(IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815801,
                "title": "easy-mysql-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou are performing a self-join on the Activity table using the aliases \"a\" and \"b\" to join based on machine_id and process_id.\\n\\nYou use the condition \"b.activity_type = \\'end\\' AND a.activity_type = \\'start\\'\" in the WHERE clause to ensure that you are only considering pairs where the \\'start\\' activity comes before the \\'end\\' activity for each (machine_id, process_id) pair.\\n\\nNext, you GROUP BY a.machine_id to group the results by machine_id.\\n\\nInside the SELECT statement, you calculate the average processing time for each machine using \"AVG(b.timestamp - a.timestamp)\" and round the result to 3 decimal places using the ROUND function.\\n\\n# Code\\n```\\nSelect a.machine_id , ROUND(AVG(b.timestamp-a.timestamp),3) AS processing_time \\nFROM Activity AS a JOIN Activity AS b ON\\na.machine_id = b.machine_id AND\\na.process_id = b.process_id WHERE\\nb.activity_type = \\'end\\' AND A.activity_type =\\'start\\' \\nGROUP BY a.machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSelect a.machine_id , ROUND(AVG(b.timestamp-a.timestamp),3) AS processing_time \\nFROM Activity AS a JOIN Activity AS b ON\\na.machine_id = b.machine_id AND\\na.process_id = b.process_id WHERE\\nb.activity_type = \\'end\\' AND A.activity_type =\\'start\\' \\nGROUP BY a.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760156,
                "title": "really-easy-solution-without-any-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSo, the question asked about the average time each machine takes to complete a process. Therefore, what we can do is that we can group by each machine, then find all of the \"start\" and \"end\" activity, combining them together. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst, we find the sum for all of the activity_type, however, when activity_type = \"start\" then the number is negative. \\n\\n```\\nSELECT machine_id, ROUND(SUM(CASE WHEN activity_type = \"start\" THEN -timestamp\\n            WHEN activity_type = \"end\" THEN timestamp\\n            END), 3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n```\\n\\nAfter finding the total sum, then what we need to do is to find the average. The easy way we can do it is to find the distinct count for the process_id, since it can show the total count easily for each machine_id. The output will be:  \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(SUM(CASE WHEN activity_type = \"start\" THEN -timestamp\\n            WHEN activity_type = \"end\" THEN timestamp\\n            END) / COUNT(DISTINCT process_id), 3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT machine_id, ROUND(SUM(CASE WHEN activity_type = \"start\" THEN -timestamp\\n            WHEN activity_type = \"end\" THEN timestamp\\n            END), 3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n```\n```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(SUM(CASE WHEN activity_type = \"start\" THEN -timestamp\\n            WHEN activity_type = \"end\" THEN timestamp\\n            END) / COUNT(DISTINCT process_id), 3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587805,
                "title": "mysql-solution-for-average-time-of-process-per-machine-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe query aims to calculate the average time taken by each machine to complete a process. It involves retrieving the start and end timestamps for each process on each machine and then calculating the average processing time for each machine.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The inner subquery groups the activity records by machine_id and process_id and uses conditional statements (CASE WHEN) to determine the start and end timestamps for each process.\\n1. The subquery calculates the maximum start timestamp and maximum end timestamp for each process using the MAX() function.\\n1. The outer query uses the results from the subquery and calculates the average processing time for each machine by subtracting the start time from the end time.\\n1. The ROUND() function is used to round the average processing time to 3 decimal places.\\n1. Finally, the outer query groups the results by machine_id and retrieves the machine ID along with the corresponding average processing time.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this query depends on the number of records in the Activity table. Let\\'s denote this number as N.\\n\\n- The inner subquery performs a grouping operation on the Activity table, which requires iterating through all N records. Therefore, its time complexity is O(N).\\n- The outer query performs a grouping operation on the results of the subquery, which also requires iterating through all N records. Thus, its time complexity is O(N).\\nOverall, the time complexity of the query is O(N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the storage of the intermediate subquery results and the final result set. Since the subquery groups the records by machine_id and process_id, the number of rows in the subquery result will be equal to or less than the number of records in the Activity table. Therefore, the space complexity is O(N) to store the intermediate subquery results. The final result set will contain a row for each unique machine_id, so its space complexity is O(M), where M is the number of unique machines.\\nHence, the overall space complexity is O(N + M).\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id, MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n           MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n) AS subquery\\nGROUP BY machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id, MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n           MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n) AS subquery\\nGROUP BY machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583754,
                "title": "the-solution-to-oracle-average-time-of-process-per-machine-problem-beats-50-72-in-my-case",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI decided to divide problem into subqueries the following manner. Becaue this way we can solve our issue more effectively and intuitively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly we should find out the start and end timestamps where each process ends and starts accordingly. We could do this by the following subquery with grouping by end_time, start_time. Where MAX and MIN functions will let us find the appropriate timestamps.\\n\\n# Code \\n\\n```\\nSELECT machine_id, process_id,\\n    MIN(timestamp) AS start_time,\\n    MAX(timestamp) AS end_time\\nFROM Activity\\nGROUP BY machine_id, process_id\\nORDER BY machine_id, process_id;\\n\\n```\\nKeep it mind this is not strictly necessary to use ORDER BY here. But it gives you more concise and straight ordered result.\\n\\nAfter this you could easily wrap this structure inside the main query in order for you to find the essential result.\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM \\n  (\\n    SELECT machine_id, process_id,\\n      MIN(timestamp) AS start_time,\\n      MAX(timestamp) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n    ORDER BY machine_id, process_id\\n  ) \\nGROUP BY machine_id\\nORDER BY machine_id;\\n\\n```\\n\\nAs you can see, we round our AVG value so as to get the appropriate outcome. And actually we also should GROUP our result using GROUP BY and ORDER BY.\\n\\nThank you. Feel free to leave your comments.",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT machine_id, process_id,\\n    MIN(timestamp) AS start_time,\\n    MAX(timestamp) AS end_time\\nFROM Activity\\nGROUP BY machine_id, process_id\\nORDER BY machine_id, process_id;\\n\\n```\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM \\n  (\\n    SELECT machine_id, process_id,\\n      MIN(timestamp) AS start_time,\\n      MAX(timestamp) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n    ORDER BY machine_id, process_id\\n  ) \\nGROUP BY machine_id\\nORDER BY machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578548,
                "title": "simple-sql-solution",
                "content": "# Code\\n```\\nSelect s.machine_id, \\n        round(avg(e.timestamp-s.timestamp), 3) as processing_time\\nfrom Activity s \\njoin Activity e\\non s.machine_id = e.machine_id \\nand s.process_id = e.process_id\\nand s.activity_type = \\'start\\' \\nand e.activity_type = \\'end\\'\\ngroup by s.machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect s.machine_id, \\n        round(avg(e.timestamp-s.timestamp), 3) as processing_time\\nfrom Activity s \\njoin Activity e\\non s.machine_id = e.machine_id \\nand s.process_id = e.process_id\\nand s.activity_type = \\'start\\' \\nand e.activity_type = \\'end\\'\\ngroup by s.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571590,
                "title": "easy-solution-using-subquery",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake a subquery which will extract start and end points for every process in every machine using group by machine_id and process_id. Then goes an easy part. We just selct avg of end-start over our subquery and using group by machide_id. \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect machine_id, round(avg(end-start), 3) as processing_time\\n\\nfrom (select machine_id, process_id ,max(timestamp) as end, min(timestamp) as start from Activity group by machine_id, process_id) as a \\ngroup by machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect machine_id, round(avg(end-start), 3) as processing_time\\n\\nfrom (select machine_id, process_id ,max(timestamp) as end, min(timestamp) as start from Activity group by machine_id, process_id) as a \\ngroup by machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083603,
                "title": "mysql-clear-and-simple-approach",
                "content": "# Query\\n```\\n# Write your MySQL query statement below\\nWITH start AS (\\n    SELECT machine_id, process_id, activity_type, timestamp FROM Activity\\n    WHERE activity_type=\\'start\\'\\n),\\nends AS (\\n    SELECT machine_id, process_id, activity_type, timestamp FROM Activity\\n    WHERE activity_type=\\'end\\'\\n)\\n\\nSELECT s.machine_id, \\n       ROUND((SUM(e.timestamp) - SUM(s.timestamp))/COUNT(e.machine_id), 3) AS processing_time\\nFROM start s\\nJOIN ends e\\nON e.machine_id = s.machine_id AND e.process_id = s.process_id\\nGROUP BY e.machine_id\\n\\n```\\n\\n\\nThe above query might seem long and there are other approaches to obtain the solution(using JOINS). I just want to implement distinct queries in each problem.\\n\\n*if you find its helpful* **please upvote**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH start AS (\\n    SELECT machine_id, process_id, activity_type, timestamp FROM Activity\\n    WHERE activity_type=\\'start\\'\\n),\\nends AS (\\n    SELECT machine_id, process_id, activity_type, timestamp FROM Activity\\n    WHERE activity_type=\\'end\\'\\n)\\n\\nSELECT s.machine_id, \\n       ROUND((SUM(e.timestamp) - SUM(s.timestamp))/COUNT(e.machine_id), 3) AS processing_time\\nFROM start s\\nJOIN ends e\\nON e.machine_id = s.machine_id AND e.process_id = s.process_id\\nGROUP BY e.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3756397,
                "title": "mysql-solution-using-cross-join-90-28",
                "content": "# Code\\n```\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a, Activity b\\nWHERE a.activity_type = \\'start\\' \\n  AND b.activity_type = \\'end\\'\\n  AND a.machine_id = b.machine_id \\n  AND a.process_id = b.process_id\\nGROUP BY a.machine_id;\\n```\\n![laptop-cat.jpg](https://assets.leetcode.com/users/images/d6b89ae0-1c8f-4340-b3e1-b877c5762c72_1689187902.2983496.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a, Activity b\\nWHERE a.activity_type = \\'start\\' \\n  AND b.activity_type = \\'end\\'\\n  AND a.machine_id = b.machine_id \\n  AND a.process_id = b.process_id\\nGROUP BY a.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3705567,
                "title": "easily-understandable-solution",
                "content": "# Code\\n```\\nselect a.machine_id ,round(avg(b.timestamp-a.timestamp),3) as processing_time \\nfrom Activity a join Activity b on a.machine_id= b.machine_id and a.process_id=b.process_id \\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect a.machine_id ,round(avg(b.timestamp-a.timestamp),3) as processing_time \\nfrom Activity a join Activity b on a.machine_id= b.machine_id and a.process_id=b.process_id \\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556555,
                "title": "using-case-sum-count-distinct",
                "content": "# Intuition\\nCASE for seperating start & end values from activity table.\\nSUM for finding the difference.\\nCOUNT * DISTINCT for finding average.\\nROUND to round off values.\\n\\n# Approach\\nIn order to take average processing time, first step is to seperate the start & end time which is done using CASE.After finding the difference using CASE statement, to find average divide the difference with DISTINCT process_id\\'s which need to be grouped by machine_id.\\nFinal step is to reound off the values.\\n\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT machine_id,\\nROUND((SUM(CASE \\nWHEN activity_type = \\'end\\' THEN timestamp\\nEND) -\\nSUM(CASE \\nWHEN activity_type = \\'start\\' THEN timestamp\\nEND)) / COUNT(DISTINCT process_id),3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT machine_id,\\nROUND((SUM(CASE \\nWHEN activity_type = \\'end\\' THEN timestamp\\nEND) -\\nSUM(CASE \\nWHEN activity_type = \\'start\\' THEN timestamp\\nEND)) / COUNT(DISTINCT process_id),3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1792152,
                "title": "solution-using-avg-round",
                "content": "\\'\\'\\'\\nSELECT machine_id, ROUND((AVG(CASE WHEN activity_type = \\'end\\' THEN timestamp ELSE NULL END))-AVG((CASE WHEN activity_type = \\'start\\' THEN timestamp ELSE NULL END)), 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nSELECT machine_id, ROUND((AVG(CASE WHEN activity_type = \\'end\\' THEN timestamp ELSE NULL END))-AVG((CASE WHEN activity_type = \\'start\\' THEN timestamp ELSE NULL END)), 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 942098,
                "title": "easy-solution-with-window-function-100-no-joins",
                "content": "First create the query to determine the delta table. This can be done in a simple way with a window function. First order by activity within a partition, then subtract the lagged value (previous row) so that for the activity = \\'end\\' you will have the value you need and for the \\'start\\' you will have null values\\n```\\nselect machine_id, timestamp - lag(timestamp,1) over (partition by machine_id, process_id order by activity_type) as delta \\nfrom Activity as DeltaTabl\\n```\\n\\nNow all you have left to do is simply select the non-null entries and round, so the final query should look like: \\n```\\nselect machine_id, round(avg(delta),3) as processing_time from \\n(select machine_id, timestamp - lag(timestamp,1) over (partition by machine_id, process_id order by activity_type) as delta \\nfrom Activity as DeltaTable) \\nas result where delta is not null group by machine_id\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect machine_id, timestamp - lag(timestamp,1) over (partition by machine_id, process_id order by activity_type) as delta \\nfrom Activity as DeltaTabl\\n```\n```\\nselect machine_id, round(avg(delta),3) as processing_time from \\n(select machine_id, timestamp - lag(timestamp,1) over (partition by machine_id, process_id order by activity_type) as delta \\nfrom Activity as DeltaTable) \\nas result where delta is not null group by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039151,
                "title": "simplified-approach-using-case",
                "content": "# Approach\\n- Start by selecting the `machine_id` and calculating the time taken for each process:\\n  - Use a `CASE` statement to distinguish between \\'start\\' and \\'end\\' activities.\\n  - For \\'start\\' activities, multiply the `timestamp` by -1 to prepare for subtraction in the next step.\\n- Sum the calculated times for each `machine_id`.\\n- Divide the sum by the count of distinct `process_id` to get the average processing time.\\n- Round the result to 3 decimal places using the `ROUND` function.\\n- Group the results by `machine_id`.\\n\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect machine_id, \\nround(\\n  sum(case when activity_type = \\'start\\' then timestamp*-1 \\n  else timestamp end) / count(distinct process_id), 3) as processing_time \\nfrom Activity\\ngroup by machine_id\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect machine_id, \\nround(\\n  sum(case when activity_type = \\'start\\' then timestamp*-1 \\n  else timestamp end) / count(distinct process_id), 3) as processing_time \\nfrom Activity\\ngroup by machine_id\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3788077,
                "title": "sql",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect a.machine_id ,round(avg(b.timestamp-a.timestamp),3) as processing_time \\nfrom Activity a join Activity b on a.machine_id= b.machine_id and a.process_id=b.process_id \\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id \\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect a.machine_id ,round(avg(b.timestamp-a.timestamp),3) as processing_time \\nfrom Activity a join Activity b on a.machine_id= b.machine_id and a.process_id=b.process_id \\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3762798,
                "title": "simple-solution-with-using-cte-s",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith x as (select machine_id, round(sum(timestamp), 3) as total_starttime, count(machine_id) as machine_count from activity\\nwhere activity_type = \\'start\\'\\ngroup by machine_id),\\n\\ny as (select machine_id, round(sum(timestamp), 3) as total_endtime, count(machine_id) as machine_count from activity\\nwhere activity_type = \\'end\\'\\ngroup by machine_id)\\n\\nselect x.machine_id, round((y.total_endtime - x.total_starttime)/x.machine_count, 3) as processing_time from x\\njoin y on x.machine_id = y.machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith x as (select machine_id, round(sum(timestamp), 3) as total_starttime, count(machine_id) as machine_count from activity\\nwhere activity_type = \\'start\\'\\ngroup by machine_id),\\n\\ny as (select machine_id, round(sum(timestamp), 3) as total_endtime, count(machine_id) as machine_count from activity\\nwhere activity_type = \\'end\\'\\ngroup by machine_id)\\n\\nselect x.machine_id, round((y.total_endtime - x.total_starttime)/x.machine_count, 3) as processing_time from x\\njoin y on x.machine_id = y.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3646378,
                "title": "solution-using-with-and-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nwith starts as (\\n  select machine_id , process_id, timestamp from activity\\n  where activity_type = \\'start\\'\\n),ends as\\n(select machine_id , process_id , timestamp from activity \\nwhere activity_type = \\'end\\')\\nselect e.machine_id , round(avg(e.timestamp - s.timestamp),3)processing_time from starts s\\njoin ends e\\non s.machine_id = e.machine_id and s.process_id = e.process_id\\ngroup by e.machine_id\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nwith starts as (\\n  select machine_id , process_id, timestamp from activity\\n  where activity_type = \\'start\\'\\n),ends as\\n(select machine_id , process_id , timestamp from activity \\nwhere activity_type = \\'end\\')\\nselect e.machine_id , round(avg(e.timestamp - s.timestamp),3)processing_time from starts s\\njoin ends e\\non s.machine_id = e.machine_id and s.process_id = e.process_id\\ngroup by e.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589826,
                "title": "very-easy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Firstly, we perform a SELF JOIN on table Activity in order to get the timestamps for the start and the end of the process.\\n- In order to do that, we execute the query on the condition that the machine_id and process_id for the two aliases is the same.\\n- We then use average the timestamp for the same machine using GROUP BY clause and round the timestamp to 3 decimals.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In the SELECT statement, we retrieve the machine_id and the average of the timestamp for every machine upto 3 decimals using the **AVG() and ROUND()** functions.\\n2. In the FROM statement, we perform a **SELF JOIN** on the table Activity, with **aliases A1 and A2**, on the condition that **A1.process_id = A2.process_id AND A1.machine_id = A2.machine_id**. \\n3. Also, we put a condition that **A2.timestamp > A1.timestamp** in order to obtain the **end and start** for the same process running on the same machine as given in step 2.\\n4. We then use **GROUP BY to group the timestamps by machine_id** because we need the timestamp for every machine.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT A1.machine_id, ROUND(AVG(A2.timestamp-A1.timestamp),3) as processing_time\\nFROM Activity as A1 INNER JOIN Activity as A2\\nON A1.process_id = A2.process_id \\nAND A1.machine_id = A2.machine_id\\nAND A2.timestamp > A1.timestamp\\nGROUP BY machine_id;\\n```\\n# Note\\nPlease upvote if you find my solution helpful. If you have any doubts, suggestion or want to discuss any solution, comment it. If you wish to discuss other related topics, feel free to message me on LinkedIn, https://leetcode.com/prathams29/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT A1.machine_id, ROUND(AVG(A2.timestamp-A1.timestamp),3) as processing_time\\nFROM Activity as A1 INNER JOIN Activity as A2\\nON A1.process_id = A2.process_id \\nAND A1.machine_id = A2.machine_id\\nAND A2.timestamp > A1.timestamp\\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3577943,
                "title": "query-for-all-3-db-simple-query-using-self-join-and-then-group-by-on-machine-id",
                "content": "\\n```\\nselect a1.machine_id as MACHINE_ID, round(avg(a2.TIMESTAMP - a1.TIMESTAMP),3) as processing_time \\nfrom Activity a1 inner join Activity a2 \\non a1.machine_id = a2.machine_id and a1.process_id=a2.process_id and a1.ACTIVITY_TYPE not in (a2.ACTIVITY_TYPE,\\'end\\') \\ngroup by a1.machine_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect a1.machine_id as MACHINE_ID, round(avg(a2.TIMESTAMP - a1.TIMESTAMP),3) as processing_time \\nfrom Activity a1 inner join Activity a2 \\non a1.machine_id = a2.machine_id and a1.process_id=a2.process_id and a1.ACTIVITY_TYPE not in (a2.ACTIVITY_TYPE,\\'end\\') \\ngroup by a1.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438290,
                "title": "2-solution-with-lead-over-or-simple-sum-and-count-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n--SOLUTION WITH [ LEAD() OVER() ]\\r\\n\\r\\nWITH CTE AS (\\r\\n        SELECT\\r\\n            machine_id,\\r\\n            timestamp,\\r\\n            lead(timestamp) OVER(PARTITION BY machine_id,process_id ORDER BY activity_type DESC) nextActive\\r\\n        FROM\\r\\n            Activity\\r\\n)\\r\\nSELECT\\r\\n    machine_id,\\r\\n    ROUND(SUM(nextActive - timestamp) / COUNT( machine_id),3) processing_time\\r\\nFROM\\r\\n    CTE\\r\\nWHERE\\r\\n    nextActive IS NOT NULL\\r\\nGROUP BY\\r\\n    machine_id\\r\\n```\\r\\n\\r\\n\\r\\n--SOLUTION WITH SIMPLE SUM AND COUNT\\r\\n\\r\\nWITH CTE AS (SELECT\\r\\n    machine_id,\\r\\n    SUM(CASE WHEN activity_type = \\'start\\' THEN timestamp ELSE NULL END) SUMSTART,\\r\\n    SUM(CASE WHEN activity_type = \\'end\\' THEN timestamp ELSE NULL END) SUMEND,\\r\\n    COUNT(machine_id) / 2 CountM\\r\\nFROM\\r\\n    Activity\\r\\nGROUP BY \\r\\n    machine_id\\r\\n)\\r\\nSELECT\\r\\n    machine_id,\\r\\n    ROUND((SUMEND - SUMSTART) / CountM,3) processing_time\\r\\nFROM\\r\\n    CTE",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n--SOLUTION WITH [ LEAD() OVER() ]\\r\\n\\r\\nWITH CTE AS (\\r\\n        SELECT\\r\\n            machine_id,\\r\\n            timestamp,\\r\\n            lead(timestamp) OVER(PARTITION BY machine_id,process_id ORDER BY activity_type DESC) nextActive\\r\\n        FROM\\r\\n            Activity\\r\\n)\\r\\nSELECT\\r\\n    machine_id,\\r\\n    ROUND(SUM(nextActive - timestamp) / COUNT( machine_id),3) processing_time\\r\\nFROM\\r\\n    CTE\\r\\nWHERE\\r\\n    nextActive IS NOT NULL\\r\\nGROUP BY\\r\\n    machine_id\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2443220,
                "title": "super-easy-solution",
                "content": "```\\n# Write your MySQL query statement below\\nwith t1 as \\n(\\n    select machine_id, process_id, timestamp as start_time from Activity\\n    where activity_type = \\'start\\'\\n    ),\\nt2 as \\n(\\n    select machine_id, process_id, timestamp as end_time from Activity\\n    where activity_type = \\'end\\'\\n    )\\nselect t1.machine_id,\\nround(avg(end_time-start_time), 3) as processing_time\\nfrom t1\\njoin t2 on t1.machine_id=t2.machine_id and t1.process_id=t2.process_id\\ngroup by t1.machine_id\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nwith t1 as \\n(\\n    select machine_id, process_id, timestamp as start_time from Activity\\n    where activity_type = \\'start\\'\\n    ),\\nt2 as \\n(\\n    select machine_id, process_id, timestamp as end_time from Activity\\n    where activity_type = \\'end\\'\\n    )\\nselect t1.machine_id,\\nround(avg(end_time-start_time), 3) as processing_time\\nfrom t1\\njoin t2 on t1.machine_id=t2.machine_id and t1.process_id=t2.process_id\\ngroup by t1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937836,
                "title": "mysql-just-need-4-lines",
                "content": "select a.machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom Activity a, Activity b\\nwhere a.machine_id = b.machine_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\n",
                "solutionTags": [],
                "code": "select a.machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom Activity a, Activity b\\nwhere a.machine_id = b.machine_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1531983,
                "title": "mysql-1-cte-no-joins",
                "content": "```\\nwith cte as (\\nSELECT machine_id, process_id, min(case when activity_type = \\'start\\' then timestamp end) as start_time, min(case when activity_type = \\'end\\' then timestamp end) as end_time\\nFROM activity\\ngroup by 1,2\\n)\\nSELECT machine_id, round(avg(end_time - start_time),3) as processing_time\\nFROM cte \\ngroup by machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nwith cte as (\\nSELECT machine_id, process_id, min(case when activity_type = \\'start\\' then timestamp end) as start_time, min(case when activity_type = \\'end\\' then timestamp end) as end_time\\nFROM activity\\ngroup by 1,2\\n)\\nSELECT machine_id, round(avg(end_time - start_time),3) as processing_time\\nFROM cte \\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1289256,
                "title": "simple-solution-without-temp-table",
                "content": "```\\n/* Write your T-SQL query statement below */\\nSELECT DISTINCT A.machine_id, ROUND(AVG(B.timestamp - A.timestamp), 3) AS processing_time\\nFROM Activity AS A\\nINNER JOIN Activity AS B\\nON A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type = \\'start\\' AND B.activity_type = \\'end\\'\\nGROUP BY A.machine_id\\nORDER BY A.machine_id\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT DISTINCT A.machine_id, ROUND(AVG(B.timestamp - A.timestamp), 3) AS processing_time\\nFROM Activity AS A\\nINNER JOIN Activity AS B\\nON A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type = \\'start\\' AND B.activity_type = \\'end\\'\\nGROUP BY A.machine_id\\nORDER BY A.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232314,
                "title": "simple-mysql-solution-using-max-and-min",
                "content": "```\\nSELECT a.machine_id, ROUND(AVG(a.duration), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id, (MAX(timestamp) - MIN(timestamp)) AS duration\\n    FROM Activity\\n    GROUP BY 1, 2\\n) a\\nGROUP BY a.machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT a.machine_id, ROUND(AVG(a.duration), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id, (MAX(timestamp) - MIN(timestamp)) AS duration\\n    FROM Activity\\n    GROUP BY 1, 2\\n) a\\nGROUP BY a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941930,
                "title": "no-joins-no-cte-simple-solution-group-by-case",
                "content": "```\\nSELECT machine_id, ROUND(avg(end_time - start_time),3) as processing_time FROM (\\n    SELECT \\n    machine_id,\\n    process_id,\\n    SUM(CASE WHEN activity_type = \"start\"  then timestamp END) as start_time,\\n    SUM(CASE WHEN activity_type = \"end\"  then timestamp END) as end_time\\n    FROM Activity\\n    GROUP BY 1,2) as f\\nGROUP BY 1\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT machine_id, ROUND(avg(end_time - start_time),3) as processing_time FROM (\\n    SELECT \\n    machine_id,\\n    process_id,\\n    SUM(CASE WHEN activity_type = \"start\"  then timestamp END) as start_time,\\n    SUM(CASE WHEN activity_type = \"end\"  then timestamp END) as end_time\\n    FROM Activity\\n    GROUP BY 1,2) as f\\nGROUP BY 1\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077402,
                "title": "pandas-sql-easy-average-time-of-process-per-machine",
                "content": "[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1056441593/)\\n\\n```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # First, we filter rows from the activity DataFrame where the value in the \"activity_type\" column is equal to \\'start\\'\\n    start_activities = activity[activity[\\'activity_type\\'] == \\'start\\']\\n\\n     # Meanwhile, we also filter rows from the activity DataFrame where the value in the \"activity_type\" column is equal to \\'end\\'\\n    end_activities = activity[activity[\\'activity_type\\'] == \\'end\\']\\n\\n    # Then, we merge two DataFrames, `start_activities` and `end_activities`, based on the columns `machine_id` and `process_id`. Also, as a result it adds the suffixes \\'_start\\', \\'_end\\' to the columns to distinguish them after merging. \\n    merged_start_end = start_activities.merge(\\n        end_activities,\\n        on=[\\'machine_id\\', \\'process_id\\'],\\n        suffixes=(\\'_start\\', \\'_end\\')\\n    )\\n\\n    # After that, we calculate the `processing_time` as the difference between timestamps by  calculating the time duration between two the columns, specifically \"timestamp_end\" and \"timestamp_start\"\\n    merged_start_end[\\'processing_time\\'] = merged_start_end[\\'timestamp_end\\'] - merged_start_end[\\'timestamp_start\\']\\n    \\n\\n    # Next, we group data by the \"machine_id\" column and then select a specific column (\"processing_time\") from within each group.\\n    grouped_start_end = merged_start_end.groupby(\\'machine_id\\')[\\'processing_time\\']\\n    \\n    # After grouping by `machine_id`, the average `processing_time` is calculated.\\n    average_time = grouped_start_end.mean()\\n    \\n    # Now, we have to transform the grouped DataFrame back into a more conventional format, so we will reset the index after the Series has been grouped above. Because, after grouping the index often changes. By default, pandas assigns a new index to the resulting grouped DataFrame. This new index is typically a multi-level index, with one level for each grouping key. The original index becomes part of the DataFrame as metadata.\\n    structured_df = average_time.reset_index()\\n    \\n    # Finally, we  round the numerical values in the structured_df. Because, in the task it is asked to that the average time should be rounded to 3 decimal places.\\n    average_time_to_complete = structured_df.round(3)\\n\\n    return average_time_to_complete\\n    \\n```\\n\\n**SQL**\\n[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1061746957/)\\n\\n```\\nSELECT a.machine_id, ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id),3) as processing_time  \\n\\nFROM Activity as a \\n\\nJOIN Activity as c ON a.machine_id = c.machine_id \\nand a.process_id = c.process_id \\nand a.activity_type = \"start\" \\nand c.activity_type = \"end\"\\n\\nGROUP BY a.machine_id\\n```\\n\\n```\\n-- Select \\'machine_id\\' and calculate the average processing time for each machine\\n-- The processing time is calculated as the difference in timestamps between \"start\" and \"end\" activities\\nSELECT a.machine_id,\\n        ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id), 3) as processing_time  \\n\\n-- Retrieve data from the \\'Activity\\' table and alias it as \\'a\\'\\nFROM Activity as a \\n\\n-- Join the \\'Activity\\' table with itself as \\'c\\' based on specific conditions\\n-- - The same \\'machine_id\\'\\n-- - The same \\'process_id\\'\\n-- - \\'activity_type\\' is \"start\" for \\'a\\' and \"end\" for \\'c\\'\\nJOIN Activity as c ON a.machine_id = c.machine_id \\nand a.process_id = c.process_id \\nand a.activity_type = \"start\" \\nand c.activity_type = \"end\"\\n\\n-- Group the results by \\'machine_id\\' to calculate the average processing time for each machine\\nGROUP BY a.machine_id;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/04dd34e1-d7b5-4481-857e-8461fc196ece_1695399610.5759363.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # First, we filter rows from the activity DataFrame where the value in the \"activity_type\" column is equal to \\'start\\'\\n    start_activities = activity[activity[\\'activity_type\\'] == \\'start\\']\\n\\n     # Meanwhile, we also filter rows from the activity DataFrame where the value in the \"activity_type\" column is equal to \\'end\\'\\n    end_activities = activity[activity[\\'activity_type\\'] == \\'end\\']\\n\\n    # Then, we merge two DataFrames, `start_activities` and `end_activities`, based on the columns `machine_id` and `process_id`. Also, as a result it adds the suffixes \\'_start\\', \\'_end\\' to the columns to distinguish them after merging. \\n    merged_start_end = start_activities.merge(\\n        end_activities,\\n        on=[\\'machine_id\\', \\'process_id\\'],\\n        suffixes=(\\'_start\\', \\'_end\\')\\n    )\\n\\n    # After that, we calculate the `processing_time` as the difference between timestamps by  calculating the time duration between two the columns, specifically \"timestamp_end\" and \"timestamp_start\"\\n    merged_start_end[\\'processing_time\\'] = merged_start_end[\\'timestamp_end\\'] - merged_start_end[\\'timestamp_start\\']\\n    \\n\\n    # Next, we group data by the \"machine_id\" column and then select a specific column (\"processing_time\") from within each group.\\n    grouped_start_end = merged_start_end.groupby(\\'machine_id\\')[\\'processing_time\\']\\n    \\n    # After grouping by `machine_id`, the average `processing_time` is calculated.\\n    average_time = grouped_start_end.mean()\\n    \\n    # Now, we have to transform the grouped DataFrame back into a more conventional format, so we will reset the index after the Series has been grouped above. Because, after grouping the index often changes. By default, pandas assigns a new index to the resulting grouped DataFrame. This new index is typically a multi-level index, with one level for each grouping key. The original index becomes part of the DataFrame as metadata.\\n    structured_df = average_time.reset_index()\\n    \\n    # Finally, we  round the numerical values in the structured_df. Because, in the task it is asked to that the average time should be rounded to 3 decimal places.\\n    average_time_to_complete = structured_df.round(3)\\n\\n    return average_time_to_complete\\n    \\n```\n```\\nSELECT a.machine_id, ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id),3) as processing_time  \\n\\nFROM Activity as a \\n\\nJOIN Activity as c ON a.machine_id = c.machine_id \\nand a.process_id = c.process_id \\nand a.activity_type = \"start\" \\nand c.activity_type = \"end\"\\n\\nGROUP BY a.machine_id\\n```\n```\\n-- Select \\'machine_id\\' and calculate the average processing time for each machine\\n-- The processing time is calculated as the difference in timestamps between \"start\" and \"end\" activities\\nSELECT a.machine_id,\\n        ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id), 3) as processing_time  \\n\\n-- Retrieve data from the \\'Activity\\' table and alias it as \\'a\\'\\nFROM Activity as a \\n\\n-- Join the \\'Activity\\' table with itself as \\'c\\' based on specific conditions\\n-- - The same \\'machine_id\\'\\n-- - The same \\'process_id\\'\\n-- - \\'activity_type\\' is \"start\" for \\'a\\' and \"end\" for \\'c\\'\\nJOIN Activity as c ON a.machine_id = c.machine_id \\nand a.process_id = c.process_id \\nand a.activity_type = \"start\" \\nand c.activity_type = \"end\"\\n\\n-- Group the results by \\'machine_id\\' to calculate the average processing time for each machine\\nGROUP BY a.machine_id;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3932494,
                "title": "solution-using-with-clause",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nI thout as two table one containing sum of start time and other containig sum of end time  and difference will be the required time and in same we can count distinct process_id. so average can be calculate *(endTime-startTime)/no of distinct process_id*. Then I joined both table on machine_id\\r\\n\\r\\n<!-- # Complexity -->\\r\\n<!-- - Time complexity: -->\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n<!-- - Space complexity: -->\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\nwith t1 as\\r\\n(\\r\\n    select machine_id,count(distinct process_id) as cnt,\\r\\n    Sum(case when activity_type =\\'start\\' then timestamp end) as total_start_time\\r\\n     from Activity \\r\\n    group by machine_id\\r\\n),\\r\\nt2 as(\\r\\n   select machine_id,count(distinct process_id) as cnt,\\r\\n    Sum(case when activity_type =\\'end\\' then timestamp end) as total_end_time\\r\\n     from Activity \\r\\n    group by machine_id\\r\\n)\\r\\nselect t1.machine_id as machine_id ,\\r\\nround((t2.total_end_time-total_start_time)/t1.cnt,3) processing_time  \\r\\nfrom t1 \\r\\njoin t2 on t2.machine_id=t1.t1.machine_id;\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below\\r\\nwith t1 as\\r\\n(\\r\\n    select machine_id,count(distinct process_id) as cnt,\\r\\n    Sum(case when activity_type =\\'start\\' then timestamp end) as total_start_time\\r\\n     from Activity \\r\\n    group by machine_id\\r\\n),\\r\\nt2 as(\\r\\n   select machine_id,count(distinct process_id) as cnt,\\r\\n    Sum(case when activity_type =\\'end\\' then timestamp end) as total_end_time\\r\\n     from Activity \\r\\n    group by machine_id\\r\\n)\\r\\nselect t1.machine_id as machine_id ,\\r\\nround((t2.total_end_time-total_start_time)/t1.cnt,3) processing_time  \\r\\nfrom t1 \\r\\njoin t2 on t2.machine_id=t1.t1.machine_id;\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906851,
                "title": "mysql-easy-to-understand",
                "content": "# Approach\\nHere 2 is multiplied with sum value because count will add both start and end timestamp so it will divide the sum value accordingly. \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect machine_id, round(2 * sum(\\n  case\\n    when activity_type = \\'start\\' then -timestamp\\n    when activity_type = \\'end\\' then timestamp\\n  end\\n) / count(timestamp), 3) as processing_time \\nfrom activity \\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect machine_id, round(2 * sum(\\n  case\\n    when activity_type = \\'start\\' then -timestamp\\n    when activity_type = \\'end\\' then timestamp\\n  end\\n) / count(timestamp), 3) as processing_time \\nfrom activity \\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775028,
                "title": "eassy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time from Activity a1 join Activity a2 on a1.machine_id=a2.machine_id and a1.process_id=a2.process_id and a1.activity_type=\\'start\\' and a2.activity_type=\\'end\\' group by a1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time from Activity a1 join Activity a2 on a1.machine_id=a2.machine_id and a1.process_id=a2.process_id and a1.activity_type=\\'start\\' and a2.activity_type=\\'end\\' group by a1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611036,
                "title": "mssql-1-inner-join-and-no-where",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT s.machine_id, ROUND(SUM(e.timestamp - s.timestamp) / COUNT(s.process_id), 3) AS processing_time\\nFROM Activity s\\nINNER JOIN Activity e ON s.activity_type = \\'start\\'\\n                    AND e.activity_type=\\'end\\' \\n                    AND e.machine_id = s.machine_id\\n                    AND e.process_id = s.process_id\\nGROUP BY s.machine_id\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT s.machine_id, ROUND(SUM(e.timestamp - s.timestamp) / COUNT(s.process_id), 3) AS processing_time\\nFROM Activity s\\nINNER JOIN Activity e ON s.activity_type = \\'start\\'\\n                    AND e.activity_type=\\'end\\' \\n                    AND e.machine_id = s.machine_id\\n                    AND e.process_id = s.process_id\\nGROUP BY s.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609061,
                "title": "efficient-mysql-query-for-calculating-average-processing-time-per-machine",
                "content": "# Intuition\\nThe goal of the given MySQL query is to calculate the average processing time for each machine based on specific conditions. To achieve this, we need to join the \"Activity\" table with itself, filtering the rows based on activity types and matching machine and process IDs.\\n\\n# Approach\\n1. We start by selecting the columns we need for the result set: A.Machine_id and the rounded average processing time. The ROUND function is used to round the average processing time to three decimal places.\\n2. We specify the table we are fetching data from using the FROM clause, and we use table aliases A and B to refer to two instances of the \"Activity\" table.\\n3. We use the JOIN clause to combine rows from A and B based on specific conditions:\\n    - The ON keyword specifies the conditions for the join.\\n    - We match rows where A.machine_id is equal to B.Machine_id.\\n    - We match rows where A.process_id is equal to B.process_id.\\n    - We include rows where A.Activity_type is \\'start\\' and B.Activity_type is \\'end\\'.\\n1. Finally, we use the GROUP BY clause to group the result set by the first column specified in the SELECT statement, which is A.Machine_id. This groups the data by unique Machine_id values and allows us to calculate the average processing time for each machine.\\n\\n# Code\\n```\\nselect A.Machine_id, round(Avg(B.timestamp-A.timestamp), 3) \\nas processing_time from Activity A join Activity B \\non A.machine_id = B.Machine_id and A.process_id = B.process_id \\nand A.Activity_type = \\'start\\' and B.Activity_type = \\'end\\' \\ngroup by 1;\\n\\n```\\n# Summary\\nTo summarize, this query retrieves data from the \"Activity\" table and calculates the average processing time for each machine. It considers rows where the Activity_type is \\'start\\' for one instance (A) and \\'end\\' for another instance (B). The calculation is based on the difference between the timestamp values of the start and end activities. The result set will consist of the Machine_id and the rounded average processing time for each machine.\\n\\nPlease upvote if you find it helpful. Good luck!",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect A.Machine_id, round(Avg(B.timestamp-A.timestamp), 3) \\nas processing_time from Activity A join Activity B \\non A.machine_id = B.Machine_id and A.process_id = B.process_id \\nand A.Activity_type = \\'start\\' and B.Activity_type = \\'end\\' \\ngroup by 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3547690,
                "title": "simple-solution-using-temp-table-and-subquery",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith start as (select machine_id, process_id, timestamp from Activity where activity_type = \\'start\\' ),\\nstop as (select machine_id, process_id, timestamp from Activity where activity_type = \\'end\\' )\\nselect \\nmachine_id , ROUND(avg(minus),3) as processing_time \\nfrom \\n  (select a.machine_id, b.process_id, b.timestamp - a.timestamp as minus \\n  from start as a \\n  join stop as b \\n  on a.machine_id = b.machine_id and a.process_id = b.process_id ) as a\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith start as (select machine_id, process_id, timestamp from Activity where activity_type = \\'start\\' ),\\nstop as (select machine_id, process_id, timestamp from Activity where activity_type = \\'end\\' )\\nselect \\nmachine_id , ROUND(avg(minus),3) as processing_time \\nfrom \\n  (select a.machine_id, b.process_id, b.timestamp - a.timestamp as minus \\n  from start as a \\n  join stop as b \\n  on a.machine_id = b.machine_id and a.process_id = b.process_id ) as a\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477853,
                "title": "1661-average-time-of-process-per-machine-solution",
                "content": "# Code\\n```\\nselect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom Activity a join activity b\\non a.machine_id=b.machine_id and a.process_id=b.process_id\\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom Activity a join activity b\\non a.machine_id=b.machine_id and a.process_id=b.process_id\\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3416342,
                "title": "cte-with-window-function",
                "content": "\\r\\n\\r\\n# Code\\r\\n<b> start_ts</b> got via  window function because of \\r\\n<b>ORDER BY DESC \\'S\\'</b>tart letter is higher than <b>\\'E\\'</b>nd\\r\\nOR You could use <b>LAG</b> but with  <b>ORDER BY activity_type  ASC</b>\\r\\n```\\r\\nWITH \\r\\nactivity_lead AS (\\r\\nSELECT *, \\r\\n       LEAD(a.timestamp) OVER (PARTITION BY machine_id, process_id \\r\\n                               ORDER BY activity_type DESC) \\'start_ts\\'\\r\\nFROM Activity a\\r\\n\\r\\n)\\r\\n# here  a.timestamp is end_ts\\r\\nSELECT machine_id, ROUND(AVG(a.timestamp - start_ts), 3) \\'processing_time\\'\\r\\nFROM activity_lead a\\r\\nGROUP BY 1\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\nWITH \\r\\nactivity_lead AS (\\r\\nSELECT *, \\r\\n       LEAD(a.timestamp) OVER (PARTITION BY machine_id, process_id \\r\\n                               ORDER BY activity_type DESC) \\'start_ts\\'\\r\\nFROM Activity a\\r\\n\\r\\n)\\r\\n# here  a.timestamp is end_ts\\r\\nSELECT machine_id, ROUND(AVG(a.timestamp - start_ts), 3) \\'processing_time\\'\\r\\nFROM activity_lead a\\r\\nGROUP BY 1\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2034033,
                "title": "ms-sql-mysql-query-statement",
                "content": "Runtime: 180 ms, faster than 93.18% of MySQL online submissions for Average Time of Process per Machine.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Average Time of Process per Machine.\\n```\\n# Write your MySQL query statement below\\n\\nselect a.machine_id, ROUND(avg(b.timestamp - a.timestamp),3) processing_time\\nfrom Activity a left join Activity b on a.machine_id=b.machine_id and a.process_id=b.process_id and b.activity_type=\\'end\\'\\nwhere a.activity_type=\\'start\\'\\ngroup by a.machine_id\\n```\\n\\nRuntime: 558 ms, faster than 43.09% of MS SQL Server online submissions for Average Time of Process per Machine.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Average Time of Process per Machine.\\n```\\n/* Write your T-SQL query statement below */\\n\\nwith c1 as (\\n\\tselect *\\n\\tfrom Activity\\n\\twhere activity_type=\\'start\\'\\n)\\n, c2 as (\\n\\tselect *\\n\\tfrom Activity\\n\\twhere activity_type=\\'end\\'\\n)\\nselect c1.machine_id, ROUND(avg(c2.timestamp - c1.timestamp),3) processing_time\\nfrom c1, c2\\nwhere c1.machine_id = c2.machine_id and c1.process_id = c2.process_id\\ngroup by c1.machine_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect a.machine_id, ROUND(avg(b.timestamp - a.timestamp),3) processing_time\\nfrom Activity a left join Activity b on a.machine_id=b.machine_id and a.process_id=b.process_id and b.activity_type=\\'end\\'\\nwhere a.activity_type=\\'start\\'\\ngroup by a.machine_id\\n```\n```\\n/* Write your T-SQL query statement below */\\n\\nwith c1 as (\\n\\tselect *\\n\\tfrom Activity\\n\\twhere activity_type=\\'start\\'\\n)\\n, c2 as (\\n\\tselect *\\n\\tfrom Activity\\n\\twhere activity_type=\\'end\\'\\n)\\nselect c1.machine_id, ROUND(avg(c2.timestamp - c1.timestamp),3) processing_time\\nfrom c1, c2\\nwhere c1.machine_id = c2.machine_id and c1.process_id = c2.process_id\\ngroup by c1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2022816,
                "title": "case-when-solution",
                "content": "```\\nselect machine_id, \\n        round(sum(case when activity_type = \\'end\\' then timestamp else -timestamp end)/\\n        count(distinct process_id),3) as \\'processing_time\\'\\nfrom activity\\ngroup by machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect machine_id, \\n        round(sum(case when activity_type = \\'end\\' then timestamp else -timestamp end)/\\n        count(distinct process_id),3) as \\'processing_time\\'\\nfrom activity\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1962036,
                "title": "runtime-204-ms-shortest-and-simplest",
                "content": "select a.machine_id, round(avg(a.timestamp - b.timestamp),3) as processing_time\\nfrom Activity a\\njoin Activity b on a.machine_id  = b.machine_id and a.activity_type = \\'end\\' and b.activity_type = \\'start\\'\\ngroup by a.machine_id",
                "solutionTags": [],
                "code": "select a.machine_id, round(avg(a.timestamp - b.timestamp),3) as processing_time\\nfrom Activity a\\njoin Activity b on a.machine_id  = b.machine_id and a.activity_type = \\'end\\' and b.activity_type = \\'start\\'\\ngroup by a.machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1934115,
                "title": "subquery-mysql",
                "content": "SELECT\\n    machine_id,\\n    ROUND((SUM(processtime)/COUNT(machine_id)),3) AS processing_time\\nFROM    \\n\\n(SELECT\\n    o.machine_id,\\n    o.process_id,\\n    ROUND((o.timestamp - t.timestamp),3) AS processtime\\nFROM Activity o\\nJOIN Activity t\\nON o.machine_id = t.machine_id\\nWHERE o.activity_type = \"end\" AND t.activity_type = \\'start\\' AND o.process_id = t.process_id\\nGROUP BY Machine_id, process_id\\n) AS c\\nGROUP BY machine_id",
                "solutionTags": [],
                "code": "SELECT\\n    machine_id,\\n    ROUND((SUM(processtime)/COUNT(machine_id)),3) AS processing_time\\nFROM    \\n\\n(SELECT\\n    o.machine_id,\\n    o.process_id,\\n    ROUND((o.timestamp - t.timestamp),3) AS processtime\\nFROM Activity o\\nJOIN Activity t\\nON o.machine_id = t.machine_id\\nWHERE o.activity_type = \"end\" AND t.activity_type = \\'start\\' AND o.process_id = t.process_id\\nGROUP BY Machine_id, process_id\\n) AS c\\nGROUP BY machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1871386,
                "title": "sql-server-easy-to-read",
                "content": "```\\nselect a.machine_id,  CAST(sum(b.timestamp - a.timestamp)/count(a.process_id) AS DECIMAL(38,3)) as processing_time \\nfrom Activity a\\njoin Activity b\\non a.machine_id  = b.machine_id and a.process_id = b.process_id\\nwhere a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect a.machine_id,  CAST(sum(b.timestamp - a.timestamp)/count(a.process_id) AS DECIMAL(38,3)) as processing_time \\nfrom Activity a\\njoin Activity b\\non a.machine_id  = b.machine_id and a.process_id = b.process_id\\nwhere a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862686,
                "title": "simple-mysql-98-7-faster",
                "content": "```\\nselect \\n    machine_id, round(avg(end_time - start_time), 3) as processing_time\\nfrom\\n    (select\\n        machine_id, \\n        sum(if (activity_type = \\'start\\', timestamp, 0)) as start_time,\\n        sum(if (activity_type = \\'end\\', timestamp, 0)) as end_time\\n    from\\n        Activity\\n    group by\\n        machine_id, process_id)t\\ngroup by machine_id;\\n        \\n",
                "solutionTags": [],
                "code": "```\\nselect \\n    machine_id, round(avg(end_time - start_time), 3) as processing_time\\nfrom\\n    (select\\n        machine_id, \\n        sum(if (activity_type = \\'start\\', timestamp, 0)) as start_time,\\n        sum(if (activity_type = \\'end\\', timestamp, 0)) as end_time\\n    from\\n        Activity\\n    group by\\n        machine_id, process_id)t\\ngroup by machine_id;\\n        \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1826671,
                "title": "simple-and-straightforward",
                "content": "use round and avg function\\n```\\nSELECT machine_id, ROUND(AVG(CASE WHEN activity_type = \\'end\\' THEN a.timestamp ELSE -a.timestamp END)*2, 3) AS processing_time\\nFROM Activity a \\nGROUP BY machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT machine_id, ROUND(AVG(CASE WHEN activity_type = \\'end\\' THEN a.timestamp ELSE -a.timestamp END)*2, 3) AS processing_time\\nFROM Activity a \\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809242,
                "title": "cte-case-when-easy-and-faster-than-97-07",
                "content": "\\n```\\nWITH cte_process\\nAS\\n(\\n    SELECT\\n        machine_id,\\n        process_id,\\n        SUM(CASE WHEN activity_type = \\'end\\' THEN timestamp\\n                 ELSE -1*timestamp\\n                 END) AS avg_time \\n    FROM \\n        Activity\\n    GROUP BY machine_id,process_id\\n)\\n    \\nSELECT\\n    machine_id,\\n    ROUND(SUM(avg_time)/COUNT(*),3) AS processing_time\\nFROM\\n    cte_process\\nGROUP BY machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte_process\\nAS\\n(\\n    SELECT\\n        machine_id,\\n        process_id,\\n        SUM(CASE WHEN activity_type = \\'end\\' THEN timestamp\\n                 ELSE -1*timestamp\\n                 END) AS avg_time \\n    FROM \\n        Activity\\n    GROUP BY machine_id,process_id\\n)\\n    \\nSELECT\\n    machine_id,\\n    ROUND(SUM(avg_time)/COUNT(*),3) AS processing_time\\nFROM\\n    cte_process\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1776903,
                "title": "cte-easy-to-read-solution",
                "content": "* easy to read solution\\n* In an interview I\\'d mention the performance hit of using a CTE, but for analysis this is ok\\n* the median would probably be a better question to ask here\\n```\\n# Write your MySQL query statement below\\nWITH raw_data AS (\\nSELECT\\n    a.machine_id AS machine_id,\\n    COUNT(*) AS cnt,\\n    SUM(CASE WHEN a.activity_type = \\'start\\' THEN timestamp ELSE 0 END) AS sum_start,\\n    SUM(CASE WHEN a.activity_type = \\'end\\' THEN timestamp ELSE 0 END) AS sum_end\\nFROM\\n    Activity a\\nGROUP BY\\n    a.machine_id\\n)\\nSELECT\\n    rd.machine_id,\\n    ROUND((rd.sum_end - rd.sum_start) / rd.cnt * 2,3) AS processing_time\\nFROM\\n    raw_data rd\\nGROUP BY\\n    rd.machine_id\\n",
                "solutionTags": [],
                "code": "* easy to read solution\\n* In an interview I\\'d mention the performance hit of using a CTE, but for analysis this is ok\\n* the median would probably be a better question to ask here\\n```\\n# Write your MySQL query statement below\\nWITH raw_data AS (\\nSELECT\\n    a.machine_id AS machine_id,\\n    COUNT(*) AS cnt,\\n    SUM(CASE WHEN a.activity_type = \\'start\\' THEN timestamp ELSE 0 END) AS sum_start,\\n    SUM(CASE WHEN a.activity_type = \\'end\\' THEN timestamp ELSE 0 END) AS sum_end\\nFROM\\n    Activity a\\nGROUP BY\\n    a.machine_id\\n)\\nSELECT\\n    rd.machine_id,\\n    ROUND((rd.sum_end - rd.sum_start) / rd.cnt * 2,3) AS processing_time\\nFROM\\n    raw_data rd\\nGROUP BY\\n    rd.machine_id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1769613,
                "title": "mysql-no-joins-no-window-functions-no-subqueries",
                "content": "```\\n# avg = (x01 - x00) + (x11 - x10) + ... \\n# / nProcesses\\n\\n# nProcesses = machine_id count / 2\\n\\n# => avg = (x01 - x00 + x11 - x10) / count(machine_id) * 2\\n\\nselect machine_id\\n    , round(\\n        sum(\\n            case when activity_type = \\'end\\' \\n                then timestamp \\n                else -timestamp \\n            end)  / \\n            count(machine_id)\\n        * 2\\n        , 3 \\n    ) as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "solutionTags": [],
                "code": "```\\n# avg = (x01 - x00) + (x11 - x10) + ... \\n# / nProcesses\\n\\n# nProcesses = machine_id count / 2\\n\\n# => avg = (x01 - x00 + x11 - x10) / count(machine_id) * 2\\n\\nselect machine_id\\n    , round(\\n        sum(\\n            case when activity_type = \\'end\\' \\n                then timestamp \\n                else -timestamp \\n            end)  / \\n            count(machine_id)\\n        * 2\\n        , 3 \\n    ) as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1762241,
                "title": "mysql-self-join-avg",
                "content": "```sql\\nSELECT\\n  a.machine_id,\\n  ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM\\n  Activity a\\n  JOIN Activity b\\n    ON a.machine_id = b.machine_id\\n    AND a.process_id = b.process_id\\n    AND a.activity_type = \\'start\\'\\n    AND b.activity_type = \\'end\\'\\nGROUP BY\\n  a.machine_id;\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT\\n  a.machine_id,\\n  ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM\\n  Activity a\\n  JOIN Activity b\\n    ON a.machine_id = b.machine_id\\n    AND a.process_id = b.process_id\\n    AND a.activity_type = \\'start\\'\\n    AND b.activity_type = \\'end\\'\\nGROUP BY\\n  a.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1629433,
                "title": "easy-case-when-without-cte-or-joins",
                "content": "```\\nSELECT machine_id,\\n    ROUND((SUM(CASE WHEN activity_type = \"end\" THEN timestamp ELSE 0 END) - SUM(CASE WHEN activity_type = \"start\" THEN timestamp ELSE 0 END))/COUNT(DISTINCT process_id),3) as processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT machine_id,\\n    ROUND((SUM(CASE WHEN activity_type = \"end\" THEN timestamp ELSE 0 END) - SUM(CASE WHEN activity_type = \"start\" THEN timestamp ELSE 0 END))/COUNT(DISTINCT process_id),3) as processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513091,
                "title": "runtime-577-ms-faster-than-99-18-of-ms-sql-server",
                "content": "\\n\\n\\nselect machine_id, cast(sum(case when activity_type  = \\'start\\' then -1.0*timestamp when activity_type = \\'end\\' then timestamp  end)/count(distinct(process_id)) as numeric(36,3)) \\'processing_time\\' from Activity group by machine_id",
                "solutionTags": [],
                "code": "\\n\\n\\nselect machine_id, cast(sum(case when activity_type  = \\'start\\' then -1.0*timestamp when activity_type = \\'end\\' then timestamp  end)/count(distinct(process_id)) as numeric(36,3)) \\'processing_time\\' from Activity group by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1512665,
                "title": "ms-sql",
                "content": "#### Question\\n```\\nSQL Schema\\nTable: Activity\\n\\n+----------------+---------+\\n| Column Name    | Type    |\\n+----------------+---------+\\n| machine_id     | int     |\\n| process_id     | int     |\\n| activity_type  | enum    |\\n| timestamp      | float   |\\n+----------------+---------+\\nThe table shows the user activities for a factory website.\\n(machine_id, process_id, activity_type) is the primary key of this table.\\nmachine_id is the ID of a machine.\\nprocess_id is the ID of a process running on the machine with ID machine_id.\\nactivity_type is an ENUM of type (\\'start\\', \\'end\\').\\ntimestamp is a float representing the current time in seconds.\\n\\'start\\' means the machine starts the process at the given timestamp and \\'end\\' means the machine ends the process at the given timestamp.\\nThe \\'start\\' timestamp will always be before the \\'end\\' timestamp for every (machine_id, process_id) pair.\\n \\n\\nThere is a factory website that has several machines each running the same number of processes. Write an SQL query to find the average time each machine takes to complete a process.\\n\\nThe time to complete a process is the \\'end\\' timestamp minus the \\'start\\' timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.\\n\\nThe resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nActivity table:\\n+------------+------------+---------------+-----------+\\n| machine_id | process_id | activity_type | timestamp |\\n+------------+------------+---------------+-----------+\\n| 0          | 0          | start         | 0.712     |\\n| 0          | 0          | end           | 1.520     |\\n| 0          | 1          | start         | 3.140     |\\n| 0          | 1          | end           | 4.120     |\\n| 1          | 0          | start         | 0.550     |\\n| 1          | 0          | end           | 1.550     |\\n| 1          | 1          | start         | 0.430     |\\n| 1          | 1          | end           | 1.420     |\\n| 2          | 0          | start         | 4.100     |\\n| 2          | 0          | end           | 4.512     |\\n| 2          | 1          | start         | 2.500     |\\n| 2          | 1          | end           | 5.000     |\\n+------------+------------+---------------+-----------+\\n\\nResult table:\\n+------------+-----------------+\\n| machine_id | processing_time |\\n+------------+-----------------+\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n+------------+-----------------+\\n\\nThere are 3 machines running 2 processes each.\\nMachine 0\\'s average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\\nMachine 1\\'s average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\\nMachine 2\\'s average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456\\n```\\n\\n#### Answer\\n````SQL\\n/* Write your T-SQL query statement below */\\n\\nwith process_time as (select a1.machine_id, abs(a1.timestamp - a2.timestamp ) processing_time \\n            from Activity a1 join Activity a2 \\n             on a1.machine_id = a2.machine_id and a1.process_id = a2.process_id \\n             where a1.activity_type != a2.activity_type )\\n             \\n             \\nselect machine_id, ROUND(AVG(processing_time), 3) processing_time from process_time\\ngroup by machine_id\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSQL Schema\\nTable: Activity\\n\\n+----------------+---------+\\n| Column Name    | Type    |\\n+----------------+---------+\\n| machine_id     | int     |\\n| process_id     | int     |\\n| activity_type  | enum    |\\n| timestamp      | float   |\\n+----------------+---------+\\nThe table shows the user activities for a factory website.\\n(machine_id, process_id, activity_type) is the primary key of this table.\\nmachine_id is the ID of a machine.\\nprocess_id is the ID of a process running on the machine with ID machine_id.\\nactivity_type is an ENUM of type (\\'start\\', \\'end\\').\\ntimestamp is a float representing the current time in seconds.\\n\\'start\\' means the machine starts the process at the given timestamp and \\'end\\' means the machine ends the process at the given timestamp.\\nThe \\'start\\' timestamp will always be before the \\'end\\' timestamp for every (machine_id, process_id) pair.\\n \\n\\nThere is a factory website that has several machines each running the same number of processes. Write an SQL query to find the average time each machine takes to complete a process.\\n\\nThe time to complete a process is the \\'end\\' timestamp minus the \\'start\\' timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.\\n\\nThe resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nActivity table:\\n+------------+------------+---------------+-----------+\\n| machine_id | process_id | activity_type | timestamp |\\n+------------+------------+---------------+-----------+\\n| 0          | 0          | start         | 0.712     |\\n| 0          | 0          | end           | 1.520     |\\n| 0          | 1          | start         | 3.140     |\\n| 0          | 1          | end           | 4.120     |\\n| 1          | 0          | start         | 0.550     |\\n| 1          | 0          | end           | 1.550     |\\n| 1          | 1          | start         | 0.430     |\\n| 1          | 1          | end           | 1.420     |\\n| 2          | 0          | start         | 4.100     |\\n| 2          | 0          | end           | 4.512     |\\n| 2          | 1          | start         | 2.500     |\\n| 2          | 1          | end           | 5.000     |\\n+------------+------------+---------------+-----------+\\n\\nResult table:\\n+------------+-----------------+\\n| machine_id | processing_time |\\n+------------+-----------------+\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n+------------+-----------------+\\n\\nThere are 3 machines running 2 processes each.\\nMachine 0\\'s average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\\nMachine 1\\'s average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\\nMachine 2\\'s average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1467952,
                "title": "no-join-use-if-and-avg",
                "content": "select\\nmachine_id,\\nround(2*avg(if(activity_type=\\'end\\',timestamp,0)-if(activity_type=\\'start\\',timestamp,0)),3)\\nas processing_time\\n\\nfrom Activity\\ngroup by 1",
                "solutionTags": [],
                "code": "select\\nmachine_id,\\nround(2*avg(if(activity_type=\\'end\\',timestamp,0)-if(activity_type=\\'start\\',timestamp,0)),3)\\nas processing_time\\n\\nfrom Activity\\ngroup by 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1446434,
                "title": "sql-server-self-join-faster-than-99",
                "content": "select  a1.machine_id  , round(sum(a2.timestamp - a1.timestamp)/count(distinct a1.process_id), 3)  as processing_time \\nfrom    Activity a1\\njoin    Activity a2\\n        on a1.machine_id = a2.machine_id \\n        and a1.process_id = a2.process_id \\n        and a2.timestamp > a1.timestamp \\nwhere   a1.activity_type like \\'start\\'\\n        and a2.activity_type like \\'end\\'\\ngroup by a1.machine_id",
                "solutionTags": [],
                "code": "select  a1.machine_id  , round(sum(a2.timestamp - a1.timestamp)/count(distinct a1.process_id), 3)  as processing_time \\nfrom    Activity a1\\njoin    Activity a2\\n        on a1.machine_id = a2.machine_id \\n        and a1.process_id = a2.process_id \\n        and a2.timestamp > a1.timestamp \\nwhere   a1.activity_type like \\'start\\'\\n        and a2.activity_type like \\'end\\'\\ngroup by a1.machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1366562,
                "title": "no-join-2-line-solution",
                "content": "```\\nselect machine_id, round(sum(case when activity_type = \\'start\\' then -timestamp else timestamp end)/count(distinct process_id) ,3)as processing_time\\nfrom activity group by machine_id\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect machine_id, round(sum(case when activity_type = \\'start\\' then -timestamp else timestamp end)/count(distinct process_id) ,3)as processing_time\\nfrom activity group by machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362557,
                "title": "simple-self-join-solution",
                "content": "select  a.machine_id, round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom activity a, activity b\\nwhere b.timestamp>a.timestamp\\nand b.activity_type = \\'end\\'\\nand a.process_id = b.process_id\\nand a.activity_type = \\'start\\'\\nand a.machine_id = b.machine_id\\ngroup by a.machine_id",
                "solutionTags": [],
                "code": "select  a.machine_id, round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom activity a, activity b\\nwhere b.timestamp>a.timestamp\\nand b.activity_type = \\'end\\'\\nand a.process_id = b.process_id\\nand a.activity_type = \\'start\\'\\nand a.machine_id = b.machine_id\\ngroup by a.machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1330066,
                "title": "mysql-4-lines",
                "content": "```\\nselect machine_id,\\n    round(sum(case when activity_type = \\'start\\' then 0-timestamp else timestamp end)/count(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id",
                "solutionTags": [],
                "code": "```\\nselect machine_id,\\n    round(sum(case when activity_type = \\'start\\' then 0-timestamp else timestamp end)/count(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1303231,
                "title": "simple-my-sql-no-join-and-case",
                "content": "```\\nSELECT machine_id, ROUND(((SUM(IF(activity_type = \\'end\\',timestamp,0))\\n    - SUM(IF(activity_type = \\'start\\',timestamp,0))) / COUNT(DISTINCT process_id)),3)\\n    AS processing_time FROM Activity GROUP BY machine_id\\n\\n",
                "solutionTags": [],
                "code": "```\\nSELECT machine_id, ROUND(((SUM(IF(activity_type = \\'end\\',timestamp,0))\\n    - SUM(IF(activity_type = \\'start\\',timestamp,0))) / COUNT(DISTINCT process_id)),3)\\n    AS processing_time FROM Activity GROUP BY machine_id\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1259342,
                "title": "mysql-faster-than-95-8-using-with-if",
                "content": "with cte as (\\n    select machine_id, process_id, if(activity_type=\\'start\\',-timestamp,timestamp) as timestamp\\n    from activity)\\n    \\n   select machine_id, round(sum(timestamp)/count(distinct process_id),3) as processing_time\\n    from cte\\n    group by 1;",
                "solutionTags": [],
                "code": "with cte as (\\n    select machine_id, process_id, if(activity_type=\\'start\\',-timestamp,timestamp) as timestamp\\n    from activity)\\n    \\n   select machine_id, round(sum(timestamp)/count(distinct process_id),3) as processing_time\\n    from cte\\n    group by 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1219471,
                "title": "ms-sql-server-93-75-faster",
                "content": "select machine_id,\\nround(sum(case when activity_type = \\'start\\' then -[timestamp]\\n    when activity_type = \\'end\\' then [timestamp] end)/cast(count(distinct process_id) as float), 3) processing_time\\nfrom activity\\ngroup by machine_id",
                "solutionTags": [],
                "code": "select machine_id,\\nround(sum(case when activity_type = \\'start\\' then -[timestamp]\\n    when activity_type = \\'end\\' then [timestamp] end)/cast(count(distinct process_id) as float), 3) processing_time\\nfrom activity\\ngroup by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1151962,
                "title": "91-faster-using-mysql",
                "content": "```\\nSELECT t_start.machine_id, round(avg(t_end.timestamp- t_start.timestamp),3) as processing_time\\nFROM Activity as t_start join Activity as t_end\\non t_start.machine_id = t_end.machine_id and t_start.process_id = t_end.process_id\\nwhere t_start.activity_type = \\'start\\' and t_end.activity_type = \\'end\\'\\ngroup by t_start.machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT t_start.machine_id, round(avg(t_end.timestamp- t_start.timestamp),3) as processing_time\\nFROM Activity as t_start join Activity as t_end\\non t_start.machine_id = t_end.machine_id and t_start.process_id = t_end.process_id\\nwhere t_start.activity_type = \\'start\\' and t_end.activity_type = \\'end\\'\\ngroup by t_start.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139999,
                "title": "mysql-join-and-aggregate",
                "content": "```\\nselect\\na.machine_id,\\nround(avg(b.timestamp - a.timestamp), 3) as processing_time\\nfrom activity a\\njoin activity b on a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\na.machine_id,\\nround(avg(b.timestamp - a.timestamp), 3) as processing_time\\nfrom activity a\\njoin activity b on a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113345,
                "title": "simplest-line-by-line-breakdown",
                "content": "SELECT s.machine_id, ROUND(AVG(e.timestamp-s.timestamp), 3) AS processing_time\\nFROM Activity s JOIN Activity e ON\\n    s.machine_id = e.machine_id AND s.process_id = e.process_id AND\\n    s.activity_type = \\'start\\' AND e.activity_type = \\'end\\'\\nGROUP BY s.machine_id",
                "solutionTags": [],
                "code": "SELECT s.machine_id, ROUND(AVG(e.timestamp-s.timestamp), 3) AS processing_time\\nFROM Activity s JOIN Activity e ON\\n    s.machine_id = e.machine_id AND s.process_id = e.process_id AND\\n    s.activity_type = \\'start\\' AND e.activity_type = \\'end\\'\\nGROUP BY s.machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1094812,
                "title": "simple-if-statement-sql",
                "content": "select machine_id,\\nround(sum(if(activity_type like \\'end\\',timestamp,-timestamp))/count(distinct process_id),3) as processing_time \\nfrom activity \\ngroup by machine_id",
                "solutionTags": [],
                "code": "select machine_id,\\nround(sum(if(activity_type like \\'end\\',timestamp,-timestamp))/count(distinct process_id),3) as processing_time \\nfrom activity \\ngroup by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1030403,
                "title": "easy-self-join-solution",
                "content": "```\\nselect machine_id,round(avg(processing_time),3) as processing_time   from (\\nselect a.machine_id,a.process_id , b.timestamp-a.timestamp as processing_time \\nfrom activity a join activity b on a.machine_id=b.machine_id and a.process_id=b.process_id\\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\') a group by 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect machine_id,round(avg(processing_time),3) as processing_time   from (\\nselect a.machine_id,a.process_id , b.timestamp-a.timestamp as processing_time \\nfrom activity a join activity b on a.machine_id=b.machine_id and a.process_id=b.process_id\\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\') a group by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009609,
                "title": "simple-mysql-solution",
                "content": "```\\nWITH cte AS (\\n    SELECT machine_id, process_id, MAX(timestamp) - MIN(timestamp) AS process_time\\n    FROM activity\\n    GROUP BY machine_id, process_id\\n)\\nSELECT machine_id, ROUND(AVG(process_time), 3) AS processing_time\\nFROM cte\\nGROUP BY machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte AS (\\n    SELECT machine_id, process_id, MAX(timestamp) - MIN(timestamp) AS process_time\\n    FROM activity\\n    GROUP BY machine_id, process_id\\n)\\nSELECT machine_id, ROUND(AVG(process_time), 3) AS processing_time\\nFROM cte\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008138,
                "title": "using-only-case-no-joins",
                "content": "```\\nWITH main AS (\\nSELECT machine_id, process_id, activity_type, \\n    CASE WHEN  activity_type = \\'start\\' THEN timestamp*(-1)\\n    ELSE timestamp END as new_time\\nFROM Activity\\n)\\nSELECT machine_id, ROUND(2*AVG(new_time),3) as processing_time\\nFROM main\\nGROUP BY machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nWITH main AS (\\nSELECT machine_id, process_id, activity_type, \\n    CASE WHEN  activity_type = \\'start\\' THEN timestamp*(-1)\\n    ELSE timestamp END as new_time\\nFROM Activity\\n)\\nSELECT machine_id, ROUND(2*AVG(new_time),3) as processing_time\\nFROM main\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 963996,
                "title": "simple-mysql-solution-4-lines-of-code",
                "content": "select machine_id,\\n       round(avg(case when activity_type = \\'start\\' then -timestamp else timestamp end)*2, 3) as processing_time\\n  from Activity\\n  group by machine_id",
                "solutionTags": [],
                "code": "select machine_id,\\n       round(avg(case when activity_type = \\'start\\' then -timestamp else timestamp end)*2, 3) as processing_time\\n  from Activity\\n  group by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 948324,
                "title": "simple-sql-server-solution",
                "content": "first solution:\\n\\n```\\nselect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom Activity a join Activity b\\non a.machine_id = b.machine_id and a.process_id = b.process_id\\nwhere a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\norder by a.machine_id\\n```\\n\\nsecond solution:\\n\\n```\\nselect x.machine_id,round(sum(x.timestamp - x.endts)/count(distinct x.process_id)*1.0,3) as processing_time\\nfrom\\n(\\nselect *, lead(timestamp) over (partition by process_id,machine_id order by activity_type) as endts\\nfrom Activity\\n)x\\ngroup by x.machine_id",
                "solutionTags": [],
                "code": "```\\nselect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom Activity a join Activity b\\non a.machine_id = b.machine_id and a.process_id = b.process_id\\nwhere a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\norder by a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947997,
                "title": "simple-self-join-in-ms-sql",
                "content": "```\\nwith cte as (\\nselect a1.machine_id,\\n    a1.process_id,\\n    a2.timestamp - a1.timestamp as duration\\nfrom activity as a1\\n    inner join activity as a2\\n    on a1.machine_id = a2.machine_id\\n    and a1.process_id = a2.process_id\\n    and a1.activity_type > a2.activity_type\\n)\\n\\nselect machine_id,\\n    cast(avg(duration) as decimal(16,3)) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id\\n;\\n\\n\\n```\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nwith cte as (\\nselect a1.machine_id,\\n    a1.process_id,\\n    a2.timestamp - a1.timestamp as duration\\nfrom activity as a1\\n    inner join activity as a2\\n    on a1.machine_id = a2.machine_id\\n    and a1.process_id = a2.process_id\\n    and a1.activity_type > a2.activity_type\\n)\\n\\nselect machine_id,\\n    cast(avg(duration) as decimal(16,3)) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id\\n;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 945882,
                "title": "oracle-solution",
                "content": "Faster than 100% submissions\\n```\\nselect distinct a.machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom\\nActivity a, Activity b\\nwhere\\na.machine_id = b.machine_id and a.process_id = b.process_id\\nand a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\norder by a.machine_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect distinct a.machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom\\nActivity a, Activity b\\nwhere\\na.machine_id = b.machine_id and a.process_id = b.process_id\\nand a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\norder by a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941505,
                "title": "first-solution-easy-and-simple",
                "content": "```\\nselect a1.machine_id , round(avg(a2.timestamp - a1.timestamp),3) processing_time \\nfrom Activity a1 join Activity a2 on a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type != a2.activity_type\\nwhere a1.activity_type = \\'start\\'\\ngroup by a1.machine_id\\norder by 1\\n```\\n\\nFor some reason, the same code wont work in Oracle",
                "solutionTags": [],
                "code": "```\\nselect a1.machine_id , round(avg(a2.timestamp - a1.timestamp),3) processing_time \\nfrom Activity a1 join Activity a2 on a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type != a2.activity_type\\nwhere a1.activity_type = \\'start\\'\\ngroup by a1.machine_id\\norder by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4107370,
                "title": "step-by-step-process-for-the-query",
                "content": "# Intuition\\nFirst we make 2 saperate tables for starting and ending time \\nthen use the difference to calculate total time and then the average\\n\\n# Approach\\n\\n**Step 1**: First we create a Table \\'s\\' that has the following fields-\\nmachine_id , process_id and timestamp, where activity_type is eaqual\\nto \\'start\\'\\n\\n**Step 2**: Then we create a Table \\'e\\' that has the following fields-\\nmachine_id , process_id and timestamp, where activity_type is eaqual to \\'end\\'\\n\\n**Step 3**: We inner join the table on matching machine_id and process_id and create another table with following fields -\\nmachine_id and average of the difference of timestamps of the previous 2 tables\\n\\n**Step 4**: We group the final table by machine_id\\n\\nNote: ROUND() function rounds off the values\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n#SELECT s.machine_id , s.process_id , (e.timestamp - s.timestamp)\\n#FROM \\nSELECT s.machine_id ,ROUND(AVG((e.timestamp - s.timestamp)),3) as processing_time\\nFROM\\n(\\n    SELECT a.machine_id , a.process_id ,a.timestamp\\n    FROM Activity a\\n    WHERE activity_type = \\'start\\'\\n) s \\nINNER JOIN \\n(\\n    SELECT a.machine_id , a.process_id , a.timestamp\\n    FROM Activity a\\n    WHERE activity_type = \\'end\\'\\n) e\\nON s.machine_id = e.machine_id AND s.process_id = e.process_id\\nGROUP BY s.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n#SELECT s.machine_id , s.process_id , (e.timestamp - s.timestamp)\\n#FROM \\nSELECT s.machine_id ,ROUND(AVG((e.timestamp - s.timestamp)),3) as processing_time\\nFROM\\n(\\n    SELECT a.machine_id , a.process_id ,a.timestamp\\n    FROM Activity a\\n    WHERE activity_type = \\'start\\'\\n) s \\nINNER JOIN \\n(\\n    SELECT a.machine_id , a.process_id , a.timestamp\\n    FROM Activity a\\n    WHERE activity_type = \\'end\\'\\n) e\\nON s.machine_id = e.machine_id AND s.process_id = e.process_id\\nGROUP BY s.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4106437,
                "title": "run-time-beats-94-07-oracle-straight-forward-solution",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT MACHINE_ID,\\nROUND(\\n    (\\n        SUM(\\n            CASE WHEN ACTIVITY_TYPE = \\'end\\' THEN timestamp ELSE 0 END\\n            )\\n        -\\n        SUM(\\n            CASE WHEN ACTIVITY_TYPE = \\'start\\' THEN timestamp ELSE 0 END\\n            )\\n    ) / (COUNT(*) / 2)\\n    , 3\\n    ) AS processing_time\\nFROM ACTIVITY\\nGROUP BY MACHINE_ID\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT MACHINE_ID,\\nROUND(\\n    (\\n        SUM(\\n            CASE WHEN ACTIVITY_TYPE = \\'end\\' THEN timestamp ELSE 0 END\\n            )\\n        -\\n        SUM(\\n            CASE WHEN ACTIVITY_TYPE = \\'start\\' THEN timestamp ELSE 0 END\\n            )\\n    ) / (COUNT(*) / 2)\\n    , 3\\n    ) AS processing_time\\nFROM ACTIVITY\\nGROUP BY MACHINE_ID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4106333,
                "title": "average-time-of-process-per-machine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct(a1.machine_id) , round(avg(a2.timestamp - a1.timestamp),3) as processing_time  \\nfrom Activity a1, Activity a2\\nwhere a1.machine_id = a2.machine_id \\nand a1.process_id = a2.process_id\\nand a1.activity_type = \"start\" \\nand a2.activity_type = \"end\"\\ngroup by a1.machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct(a1.machine_id) , round(avg(a2.timestamp - a1.timestamp),3) as processing_time  \\nfrom Activity a1, Activity a2\\nwhere a1.machine_id = a2.machine_id \\nand a1.process_id = a2.process_id\\nand a1.activity_type = \"start\" \\nand a2.activity_type = \"end\"\\ngroup by a1.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4104848,
                "title": "cte",
                "content": "# Intuition\\nI am a big fan of CTEs because they make the query more readable\\n# Approach\\n1. Creating the table which gets the table with the activity_type= \\'start\\'\\n2. Creating the table which gets the table with the activity_type=\\'end\\' \\n3. Creating the intermediate table with the field end-start. \\n4. Selecting the machine id and dividing the sum of the time/count(proccess_id)\\n\\nThe method that I showed you is definetely more readable, however if you prefer you can use also double call method where you use \\n\\nFROM activites a, activites b\\nand start and end timestamps on one row level that will help you to do the calculations.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nWITH \\n    END_Spiel AS (\\n        SELECT MACHINE_ID, PROCESS_ID, SUM(timestamp) AS FINISH\\n        FROM Activity\\n        WHERE ACTIVITY_TYPE = \\'end\\'\\n        GROUP BY 1,2\\n    ),\\n    START_Spiel AS (\\n        SELECT MACHINE_ID, PROCESS_ID, SUM(timestamp) AS START\\n        FROM Activity\\n        WHERE ACTIVITY_TYPE = \\'start\\'\\n        GROUP BY 1,2\\n    ),\\n    Calcolo_intermedio AS (\\n        SELECT a.MACHINE_ID, a.PROCESS_ID, a.FINISH - b.START AS TIME_SPEND\\n        FROM END_Spiel a\\n        INNER JOIN START_Spiel b ON a.MACHINE_ID = b.MACHINE_ID AND a.PROCESS_ID = b.PROCESS_ID\\n    )\\nSELECT MACHINE_ID, round(SUM(TIME_SPEND) / COUNT(PROCESS_ID),3) AS processing_time\\nFROM Calcolo_intermedio\\nGROUP BY 1;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH \\n    END_Spiel AS (\\n        SELECT MACHINE_ID, PROCESS_ID, SUM(timestamp) AS FINISH\\n        FROM Activity\\n        WHERE ACTIVITY_TYPE = \\'end\\'\\n        GROUP BY 1,2\\n    ),\\n    START_Spiel AS (\\n        SELECT MACHINE_ID, PROCESS_ID, SUM(timestamp) AS START\\n        FROM Activity\\n        WHERE ACTIVITY_TYPE = \\'start\\'\\n        GROUP BY 1,2\\n    ),\\n    Calcolo_intermedio AS (\\n        SELECT a.MACHINE_ID, a.PROCESS_ID, a.FINISH - b.START AS TIME_SPEND\\n        FROM END_Spiel a\\n        INNER JOIN START_Spiel b ON a.MACHINE_ID = b.MACHINE_ID AND a.PROCESS_ID = b.PROCESS_ID\\n    )\\nSELECT MACHINE_ID, round(SUM(TIME_SPEND) / COUNT(PROCESS_ID),3) AS processing_time\\nFROM Calcolo_intermedio\\nGROUP BY 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4104072,
                "title": "sql-subquery-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id,\\n           MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n           MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n) AS machine_activities\\nGROUP BY machine_id\\nORDER BY machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id,\\n           MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n           MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n) AS machine_activities\\nGROUP BY machine_id\\nORDER BY machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102131,
                "title": "cte-2-agg-functions-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwith tablee as (\\nselect machine_id, process_id, \\nROUND(max(timestamp) - min(timestamp),3) as diff\\nfrom activity\\ngroup by machine_id, process_id)\\n\\nselect machine_id, round(avg(diff),3) as processing_time  from tablee\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith tablee as (\\nselect machine_id, process_id, \\nROUND(max(timestamp) - min(timestamp),3) as diff\\nfrom activity\\ngroup by machine_id, process_id)\\n\\nselect machine_id, round(avg(diff),3) as processing_time  from tablee\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4101886,
                "title": "pandas-and-mysql-with-explanation",
                "content": "```sql []\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a, Activity b\\nWHERE a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\nGROUP BY a.machine_id, b.machine_id;\\n```\\n\\n## MySQL Explanation\\n\\n![acti.png](https://assets.leetcode.com/users/images/717c9c1a-ea37-406b-b83a-a12e20920f0f_1695919608.416645.png)\\n\\nFor the red color part: (since we grouped by `GROUP BY a.machine_id, b.machine_id`)\\n- `a.machine_id = b.machine_id` matches the red group in a and b.\\n- For red group `a.process_id = b.process_id` matches green and blue part in both a and b.\\n- - `For the green part` : by `a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'` we\\'re telling who will be the start and end. We\\'ve no more condition, so let\\'s go to the `SELECT` part. We see `AVG(b.timestamp - a.timestamp)`, inside AVG, `b.timestamp - a.timestamp` taking places by 1.520 - 0.712 = `0.808`.\\n\\n#### Wait, is the condition `WHERE a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'` really finished? NO! For red group we\\'ve green and blue. Green is finished, blue will will take place now.\\n\\n- - `For the blue part` : Similarly we will get here 4.120 - 3.140 = `0.98`. But where the previous result `0.808` gone? It was stored in `AVG()` FUNCTION. \\n```py\\nIn Python: sum(v for v in [1,2,3]), what happens in sum() here? A value(v) is returned after every iteration in the loop and the value\\n(v) is being added by sum().\\n\\nThe same thing happens in the MySQL code. The whole where condition is the for loop and the return value is \\'b.timestamp - a.timestamp\\'\\nwhich is being stored in \\'AVG() FUNCTION\\' to be operated.\\n```\\n- - Now `0.98` will be added with `0.808` and then 0.98 + 0.808 = `1.788` will divided by 2 by the `AVG()` FUNCTION.\\n- In this way for red group the whole where condition is executed. Now similar operation will happen for the group of 1 and 2 in `machine_id`.\\n- \\n## Pandas\\n```py []\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    startDf, endDf = activity.query(\\'activity_type == \"start\"\\'), activity.query(\\'activity_type == \"end\"\\')\\n    merged_df = pd.merge(startDf, endDf, on=[\\'machine_id\\', \\'process_id\\'], suffixes=[\\'_start\\', \\'_end\\'])\\n    merged_df[\\'processing_time\\'] = merged_df[\\'timestamp_end\\'] - merged_df[\\'timestamp_start\\']\\n    return merged_df.groupby([\\'machine_id\\'])[\\'processing_time\\'].mean().round(3).reset_index()\\n```\\n\\n## Pandas Explanation\\nWe separated the the activity dataframe based on the `activity_type` column where first df `startDf` has values related with value `start` and second df `endDf` has values related with value `end`, then we merged them and added new column `processing_time`.. The rest is given in the below 2 pics :\\n![sivity1.png](https://assets.leetcode.com/users/images/ee72936b-e9a0-457a-99a0-5335dffa06bf_1695925401.88148.png)\\n\\n![sivity2.png](https://assets.leetcode.com/users/images/343319d1-44e9-4336-a64d-f02c609f9aaf_1695925411.748391.png)\\n\\n## If the solution was helpful, an upvote  will be appreciated. Thank youu\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```sql []\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a, Activity b\\nWHERE a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\nGROUP BY a.machine_id, b.machine_id;\\n```\n```py\\nIn Python: sum(v for v in [1,2,3]), what happens in sum() here? A value(v) is returned after every iteration in the loop and the value\\n(v) is being added by sum().\\n\\nThe same thing happens in the MySQL code. The whole where condition is the for loop and the return value is \\'b.timestamp - a.timestamp\\'\\nwhich is being stored in \\'AVG() FUNCTION\\' to be operated.\\n```\n```py []\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    startDf, endDf = activity.query(\\'activity_type == \"start\"\\'), activity.query(\\'activity_type == \"end\"\\')\\n    merged_df = pd.merge(startDf, endDf, on=[\\'machine_id\\', \\'process_id\\'], suffixes=[\\'_start\\', \\'_end\\'])\\n    merged_df[\\'processing_time\\'] = merged_df[\\'timestamp_end\\'] - merged_df[\\'timestamp_start\\']\\n    return merged_df.groupby([\\'machine_id\\'])[\\'processing_time\\'].mean().round(3).reset_index()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4101683,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH CTE AS \\n(\\n    SELECT\\n      A.machine_id,\\n      A.process_id,\\n      (Act.timestamp - A.timestamp) AS time_stamp\\n    FROM Activity A \\n      INNER JOIN Activity Act ON A.machine_id= Act.machine_id \\n        AND A. process_id=Act.process_id \\n        AND A.activity_type =\\'start\\' \\n        AND Act.activity_type=\\'end\\'\\n)\\nSELECT \\n  machine_id, \\n  ROUND(AVG(time_stamp),3) AS processing_time\\nFROM CTE\\nGROUP BY machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH CTE AS \\n(\\n    SELECT\\n      A.machine_id,\\n      A.process_id,\\n      (Act.timestamp - A.timestamp) AS time_stamp\\n    FROM Activity A \\n      INNER JOIN Activity Act ON A.machine_id= Act.machine_id \\n        AND A. process_id=Act.process_id \\n        AND A.activity_type =\\'start\\' \\n        AND Act.activity_type=\\'end\\'\\n)\\nSELECT \\n  machine_id, \\n  ROUND(AVG(time_stamp),3) AS processing_time\\nFROM CTE\\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100624,
                "title": "with-without-using-join",
                "content": "# Intuition\\nMy initial thoughts for solving this problem involve using SQL with a self-join on the \"Activity\" table to match \"start\" and \"end\" activities for the same machine and process. Then, I calculate the time difference for each process and average it per machine. Both answers provided use a similar approach.\\n\\n# Approach\\nThe approach in both answers is to perform a self-join on the \"Activity\" table, matching \"start\" and \"end\" activities based on machine_id and process_id. This allows us to calculate the time taken for each process and then average the times per machine. The ROUND function is used to round the result to three decimal places for the processing time.\\n\\n# Complexity\\n- Time complexity [For both Solutions]:\\nThe time complexity of these queries depends on the size of the \"Activity\" table but typically involves a linear scan of the table. Therefore, the time complexity is O(N), where N is the number of rows in the \"Activity\" table.\\n\\n- Space complexity  [For both Solutions]:\\nThe space complexity is minimal as the queries primarily involve calculations without significant additional space requirements. The space complexity can be considered constant, O(1).\\n\\n# Code 1\\n```\\nselect t1.machine_id, ROUND(avg(t2.timestamp - t1.timestamp), 3) as processing_time\\nfrom Activity as t1 \\nJOIN Activity as t2\\nON t1.machine_id = t2.machine_id AND t1.process_id = t2.process_id\\nAND t1.activity_type = \"start\" AND t2.activity_type = \"end\"\\ngroup by t1.machine_id;\\n```\\n# Code 2\\n```\\nselect t1.machine_id, ROUND(avg(t2.timestamp-t1.timestamp),3) as processing_time\\nfrom Activity as t1, Activity as t2\\nwhere t1.machine_id = t2.machine_id AND t1.process_id = t2.process_id AND t1.activity_type =\"start\" AND t2.activity_type = \"end\"\\ngroup by t1.machine_id;\\n\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect t1.machine_id, ROUND(avg(t2.timestamp - t1.timestamp), 3) as processing_time\\nfrom Activity as t1 \\nJOIN Activity as t2\\nON t1.machine_id = t2.machine_id AND t1.process_id = t2.process_id\\nAND t1.activity_type = \"start\" AND t2.activity_type = \"end\"\\ngroup by t1.machine_id;\\n```\n```\\nselect t1.machine_id, ROUND(avg(t2.timestamp-t1.timestamp),3) as processing_time\\nfrom Activity as t1, Activity as t2\\nwhere t1.machine_id = t2.machine_id AND t1.process_id = t2.process_id AND t1.activity_type =\"start\" AND t2.activity_type = \"end\"\\ngroup by t1.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100421,
                "title": "sql-easy-fast-using-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect A1.machine_id, round(sum(A2.timestamp-A1.timestamp)/(count(*)),3) as processing_time  from Activity as A1 JOIN Activity as A2 on \\nA1.activity_type=\"start\" and A2.activity_type=\"end\" and A1.machine_id=A2.machine_id\\ngroup by machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect A1.machine_id, round(sum(A2.timestamp-A1.timestamp)/(count(*)),3) as processing_time  from Activity as A1 JOIN Activity as A2 on \\nA1.activity_type=\"start\" and A2.activity_type=\"end\" and A1.machine_id=A2.machine_id\\ngroup by machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099797,
                "title": "average-time-of-process-per-machine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT a12.machine_id, ROUND(AVG(a12.end_time - a12.start_time), 3) AS processing_time \\nFROM (\\n    SELECT a1.machine_id, a1.process_id, a1.timestamp AS start_time, a2.timestamp AS end_time \\n    FROM (\\n        SELECT * \\n        FROM Activity \\n        WHERE activity_type=\\'start\\'\\n    ) AS a1 \\n    LEFT JOIN (\\n        SELECT * \\n        FROM Activity \\n        WHERE activity_type=\\'end\\'\\n    ) AS a2 \\n    ON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id\\n) AS a12\\nGROUP BY a12.machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT a12.machine_id, ROUND(AVG(a12.end_time - a12.start_time), 3) AS processing_time \\nFROM (\\n    SELECT a1.machine_id, a1.process_id, a1.timestamp AS start_time, a2.timestamp AS end_time \\n    FROM (\\n        SELECT * \\n        FROM Activity \\n        WHERE activity_type=\\'start\\'\\n    ) AS a1 \\n    LEFT JOIN (\\n        SELECT * \\n        FROM Activity \\n        WHERE activity_type=\\'end\\'\\n    ) AS a2 \\n    ON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id\\n) AS a12\\nGROUP BY a12.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099744,
                "title": "join-two-subqueries-beats-94-78",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect s.machine_id, \\n    round(avg(e.timestamp - s.timestamp), 3) as processing_time\\nfrom\\n(select * \\nfrom activity\\nwhere activity_type = \\'start\\') s\\njoin\\n(select * \\nfrom activity\\nwhere activity_type = \\'end\\') e\\non s.machine_id = e.machine_id and s.process_id = e.process_id\\ngroup by s.machine_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect s.machine_id, \\n    round(avg(e.timestamp - s.timestamp), 3) as processing_time\\nfrom\\n(select * \\nfrom activity\\nwhere activity_type = \\'start\\') s\\njoin\\n(select * \\nfrom activity\\nwhere activity_type = \\'end\\') e\\non s.machine_id = e.machine_id and s.process_id = e.process_id\\ngroup by s.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098712,
                "title": "1661-average-time-of-process-per-machine",
                "content": "```\\n# Write your MySQL query statement below\\nselect machine_id ,\\nround((\\n  -avg(case when activity_type=\"start\" then timestamp\\n        else 0\\n\\t\\tend )\\n+avg(case when activity_type=\"end\" then timestamp\\n        else 0\\n        end )\\n)*2,3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect machine_id ,\\nround((\\n  -avg(case when activity_type=\"start\" then timestamp\\n        else 0\\n\\t\\tend )\\n+avg(case when activity_type=\"end\" then timestamp\\n        else 0\\n        end )\\n)*2,3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097842,
                "title": "sql-query-avg-time-of-process-per-machine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nYou can find the average time each machine takes to complete a process by joining the Activity table with itself to calculate the difference in timestamps for \\'start\\' and \\'end\\' activities for each (machine_id, process_id) pair. Then, group the results by machine_id and calculate the average time for each machine.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nIn this query:\\n\\nIn the subquery, we calculate the start_time and end_time for each (machine_id, process_id) pair by using conditional aggregation. We use the MAX function to get the timestamps for \\'start\\' and \\'end\\' activities.\\n\\nThen, we calculate the difference between end_time and start_time for each (machine_id, process_id) pair.\\n\\nNext, we calculate the average processing time for each machine by summing up the differences and dividing by the number of distinct process_id values for that machine.\\n\\nFinally, we round the result to three decimal places using the ROUND function.\\n\\nThis query will give you the desired output with the machine_id and their corresponding average processing times.\\n\\n<!-- # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    a.machine_id,\\n    ROUND(SUM(end_time - start_time) / COUNT(DISTINCT a.process_id), 3) AS processing_time\\nFROM\\n    (SELECT\\n        machine_id,\\n        process_id,\\n        MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n        MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id) AS a\\nGROUP BY a.machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    a.machine_id,\\n    ROUND(SUM(end_time - start_time) / COUNT(DISTINCT a.process_id), 3) AS processing_time\\nFROM\\n    (SELECT\\n        machine_id,\\n        process_id,\\n        MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n        MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id) AS a\\nGROUP BY a.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097841,
                "title": "sql-query-avg-time-of-process-per-machine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nYou can find the average time each machine takes to complete a process by joining the Activity table with itself to calculate the difference in timestamps for \\'start\\' and \\'end\\' activities for each (machine_id, process_id) pair. Then, group the results by machine_id and calculate the average time for each machine.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nIn this query:\\n\\nIn the subquery, we calculate the start_time and end_time for each (machine_id, process_id) pair by using conditional aggregation. We use the MAX function to get the timestamps for \\'start\\' and \\'end\\' activities.\\n\\nThen, we calculate the difference between end_time and start_time for each (machine_id, process_id) pair.\\n\\nNext, we calculate the average processing time for each machine by summing up the differences and dividing by the number of distinct process_id values for that machine.\\n\\nFinally, we round the result to three decimal places using the ROUND function.\\n\\nThis query will give you the desired output with the machine_id and their corresponding average processing times.\\n\\n<!-- # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    a.machine_id,\\n    ROUND(SUM(end_time - start_time) / COUNT(DISTINCT a.process_id), 3) AS processing_time\\nFROM\\n    (SELECT\\n        machine_id,\\n        process_id,\\n        MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n        MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id) AS a\\nGROUP BY a.machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    a.machine_id,\\n    ROUND(SUM(end_time - start_time) / COUNT(DISTINCT a.process_id), 3) AS processing_time\\nFROM\\n    (SELECT\\n        machine_id,\\n        process_id,\\n        MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n        MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id) AS a\\nGROUP BY a.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097035,
                "title": "easy-solution-without-using-join",
                "content": "# Without using JOIN, just using GROUP BY and aggregate functions!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect c.machine_id, round(avg(c.timeTaken), 3) as processing_time\\nfrom (\\n\\tselect \\n\\t\\tmachine_id,\\n\\t\\tprocess_id,\\n\\t\\tmax(timestamp) - min(timestamp) as timeTaken\\n\\tfrom activity\\n\\tgroup by machine_id, process_id\\n) c\\ngroup by c.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect c.machine_id, round(avg(c.timeTaken), 3) as processing_time\\nfrom (\\n\\tselect \\n\\t\\tmachine_id,\\n\\t\\tprocess_id,\\n\\t\\tmax(timestamp) - min(timestamp) as timeTaken\\n\\tfrom activity\\n\\tgroup by machine_id, process_id\\n) c\\ngroup by c.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096544,
                "title": "pandas-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    df = activity.sort_values([\\'machine_id\\',\\'process_id\\',\\'timestamp\\'],ascending=[True,True,True])\\n    df = df.groupby([\\'machine_id\\',\\'process_id\\'])[\\'timestamp\\'].apply(lambda x: x.diff()).reset_index(name=\\'processing_time\\')\\n    return df.groupby(\\'machine_id\\')[\\'processing_time\\'].mean().round(3).reset_index()\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    df = activity.sort_values([\\'machine_id\\',\\'process_id\\',\\'timestamp\\'],ascending=[True,True,True])\\n    df = df.groupby([\\'machine_id\\',\\'process_id\\'])[\\'timestamp\\'].apply(lambda x: x.diff()).reset_index(name=\\'processing_time\\')\\n    return df.groupby(\\'machine_id\\')[\\'processing_time\\'].mean().round(3).reset_index()\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4095249,
                "title": "my-solution",
                "content": "\\n# Code\\n```\\nselect machine_id,\\nround(sum(case\\nwhen activity_type = \\'start\\' then -timestamp else timestamp end)/(count(process_id)/2),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect machine_id,\\nround(sum(case\\nwhen activity_type = \\'start\\' then -timestamp else timestamp end)/(count(process_id)/2),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093885,
                "title": "pandas-solution",
                "content": "I started by changing all start values to negative. \\n\\nThen I groupby machine_id and process_id and get the sum. Reset_index and drop columns that are not necessary (activity_type and process_id). \\n\\nThen perform another groupby using just the machine_id and get the mean for the summed timestamp values. \\n\\nReset_index again to bring back the machine_id column, rename columns for submission, and round to 3 decimal places.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    activity.loc[activity[\\'activity_type\\'] == \\'start\\', \\'timestamp\\'] *= -1\\n    return activity.groupby([\\'machine_id\\', \\'process_id\\']).sum().reset_index().drop(columns = [\\'activity_type\\', \\'process_id\\']).groupby(\\'machine_id\\').mean().reset_index().rename(columns={\\'timestamp\\': \\'processing_time\\'}).round(3)\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    activity.loc[activity[\\'activity_type\\'] == \\'start\\', \\'timestamp\\'] *= -1\\n    return activity.groupby([\\'machine_id\\', \\'process_id\\']).sum().reset_index().drop(columns = [\\'activity_type\\', \\'process_id\\']).groupby(\\'machine_id\\').mean().reset_index().rename(columns={\\'timestamp\\': \\'processing_time\\'}).round(3)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4093538,
                "title": "average-time-processing-per-machine-self-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSelect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time from Activity a, Activity b where a.machine_id=b.machine_id and a.process_id=b.process_id and a.activity_type=\\'start\\' and b.activity_type=\\'end\\' group by machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time from Activity a, Activity b where a.machine_id=b.machine_id and a.process_id=b.process_id and a.activity_type=\\'start\\' and b.activity_type=\\'end\\' group by machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093382,
                "title": "mysql-convoluted-solution-but-good-run-time",
                "content": "I\\'m getting the sum of end times, subtracting the sum of start times and dividing that by the # of start-end sequences (in hindsight the AVG function would make this cleaner). \\n```\\n# Write your MySQL query statement below\\nSELECT a.machine_id,\\nROUND( \\n  (\\n    (SELECT SUM(timestamp) \\n      FROM Activity \\n      WHERE activity_type=\\'end\\' \\n      AND machine_id=a.machine_id) -\\n    (SELECT SUM(timestamp) \\n      FROM Activity \\n      WHERE activity_type=\\'start\\' \\n      AND machine_id=a.machine_id)\\n  ) / (COUNT(a.machine_id) /2), 3 \\n)\\n  AS processing_time\\nFROM Activity a\\nGROUP BY a.machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT a.machine_id,\\nROUND( \\n  (\\n    (SELECT SUM(timestamp) \\n      FROM Activity \\n      WHERE activity_type=\\'end\\' \\n      AND machine_id=a.machine_id) -\\n    (SELECT SUM(timestamp) \\n      FROM Activity \\n      WHERE activity_type=\\'start\\' \\n      AND machine_id=a.machine_id)\\n  ) / (COUNT(a.machine_id) /2), 3 \\n)\\n  AS processing_time\\nFROM Activity a\\nGROUP BY a.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091921,
                "title": "using-joins-and-group-by-only",
                "content": "\\n1. We want to find the average time it takes for each machine to complete a process. To do this, we need to calculate the time it takes for each process to complete on each machine.\\n\\n2. We start by creating a subquery (a query within a query) to calculate the time it takes for each process to complete. This subquery does the following:\\n   - It joins the \"activity\" table with itself (aliased as \\'a\\' and \\'b\\') based on three conditions:\\n     - The machine_id must be the same for both activities (\\'a.machine_id = b.machine_id\\').\\n     - The process_id must be the same for both activities (\\'a.process_id = b.process_id\\').\\n     - The activity_type of \\'a\\' must be different from the activity_type of \\'b\\' (\\'a.activity_type != b.activity_type\\'). This ensures that we are pairing a \"start\" activity with an \"end\" activity for the same process on the same machine.\\n   - It calculates the time it takes to complete the process by subtracting the \\'timestamp\\' of the \"start\" activity (\\'b.timestamp\\') from the \\'timestamp\\' of the \"end\" activity (\\'a.timestamp\\').\\n   - It only selects records where the \\'activity_type\\' of \\'a\\' is \\'end\\'. This filters out any \"start\" activities without corresponding \"end\" activities.\\n\\n3. After calculating the time it takes for each process to complete, we use this subquery as a source for our main query.\\n\\n4. In the main query, we group the results by \\'machine_id\\' because we want to find the average processing time for each machine.\\n\\n5. We use the \\'AVG\\' function to calculate the average processing time for each machine. The \\'Round\\' function is used to round the result to three decimal places, as specified in the problem statement.\\n\\n6. Finally, we select \\'machine_id\\' and the rounded average processing time as \\'processing_time\\' in our result table.\\n\\nSo, in summary, this query first pairs \"start\" and \"end\" activities for the same process on the same machine, calculates the time it takes for each process to complete, and then finds the average processing time for each machine by grouping the results. The \\'Round\\' function is used to format the result to three decimal places.\\n\\n\\n\\n# Code\\n```\\n\\n\\nselect machine_id, Round(avg(timer),3) as processing_time \\n    from\\n     (select a.machine_id ,(a.timestamp-b.timestamp) as timer \\n      from activity  a \\n      join activity  b \\n      on (a.machine_id=b.machine_id and a.process_id=b.process_id and a.activity_type!=b.activity_type) \\n      where a.activity_type=\\'end\\') \\ngroup by machine_id\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n\\n\\nselect machine_id, Round(avg(timer),3) as processing_time \\n    from\\n     (select a.machine_id ,(a.timestamp-b.timestamp) as timer \\n      from activity  a \\n      join activity  b \\n      on (a.machine_id=b.machine_id and a.process_id=b.process_id and a.activity_type!=b.activity_type) \\n      where a.activity_type=\\'end\\') \\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088146,
                "title": "avg-time-of-process-per-machine",
                "content": "\\n# Code\\n```\\nSelect a1.machine_id , ROUND(AVG(a2.timestamp-a1.timestamp),3) AS processing_time \\nFROM Activity AS a1 JOIN Activity AS a2 ON\\na1.machine_id = a2.machine_id AND\\na1.process_id = a2.process_id WHERE\\na2.activity_type = \\'end\\' AND a1.activity_type =\\'start\\' \\nGROUP BY a1.machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect a1.machine_id , ROUND(AVG(a2.timestamp-a1.timestamp),3) AS processing_time \\nFROM Activity AS a1 JOIN Activity AS a2 ON\\na1.machine_id = a2.machine_id AND\\na1.process_id = a2.process_id WHERE\\na2.activity_type = \\'end\\' AND a1.activity_type =\\'start\\' \\nGROUP BY a1.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087358,
                "title": "not-an-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect table1.machine_id as machine_id, round(end-start,3) as processing_time from (select machine_id,avg(timestamp) as start from\\n (select machine_id,timestamp from activity where activity_type=\\'start\\') as a group by machine_id) table1 \\n inner join \\n (select machine_id,avg(timestamp) as end from (select machine_id,timestamp from activity where activity_type=\\'end\\') as a group by machine_id) as table2 on table1.machine_id=table2.machine_id; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect table1.machine_id as machine_id, round(end-start,3) as processing_time from (select machine_id,avg(timestamp) as start from\\n (select machine_id,timestamp from activity where activity_type=\\'start\\') as a group by machine_id) table1 \\n inner join \\n (select machine_id,avg(timestamp) as end from (select machine_id,timestamp from activity where activity_type=\\'end\\') as a group by machine_id) as table2 on table1.machine_id=table2.machine_id; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086876,
                "title": "join-avg-round",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo the join and have the start and end time of each process in single column\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nDo the join operation with following *ON* condition:\\n                        a1.machine_id = a2.machine_id   \\n                        and a1.process_id = a2.process_id \\n                        and a1.activity_type != a2.activity_type\\n                        and a1.activity_type != \\'start\\'\\nwe will have end and start time of process in single column\\n\\nthen we can group by machine_id and calculate the avg of the timestamp\\n\\n\\n**Hope the solution helps**\\n**Please upvote if you like the solution**\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\n\\n\\nselect  a1.machine_id,\\n        ROUND(Avg(a1.timestamp - a2.timestamp), 3) as processing_time\\nfrom activity as a1\\njoin\\nactivity as a2\\non a1.machine_id = a2.machine_id \\n                        and a1.process_id = a2.process_id \\n                        and a1.activity_type != a2.activity_type\\n                        and a1.activity_type != \\'start\\'\\n                        \\n  group by a1.machine_id;\\n                        \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\n\\n\\nselect  a1.machine_id,\\n        ROUND(Avg(a1.timestamp - a2.timestamp), 3) as processing_time\\nfrom activity as a1\\njoin\\nactivity as a2\\non a1.machine_id = a2.machine_id \\n                        and a1.process_id = a2.process_id \\n                        and a1.activity_type != a2.activity_type\\n                        and a1.activity_type != \\'start\\'\\n                        \\n  group by a1.machine_id;\\n                        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086010,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect a1.machine_id , round(avg(a2.timestamp-a1.timestamp),3) as processing_time\\nfrom Activity a1\\njoin Activity a2\\non a1.machine_id=a2.machine_id and a1.process_id=a2.process_id and\\na1.activity_type=\\'start\\' and a2.activity_type=\\'end\\'\\ngroup by a1.machine_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a1.machine_id , round(avg(a2.timestamp-a1.timestamp),3) as processing_time\\nfrom Activity a1\\njoin Activity a2\\non a1.machine_id=a2.machine_id and a1.process_id=a2.process_id and\\na1.activity_type=\\'start\\' and a2.activity_type=\\'end\\'\\ngroup by a1.machine_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084824,
                "title": "easy-solution-simply-explained",
                "content": "### Main idea: Calculate the average of the start timestamps and subtract from it the average of the end timestamps (for each machine_id). \\nWhy does this work ? Becouse ((e1-s1) + (e2-s2) + ... + (en - sn)) / n = (e1+e2+...+en)/n - (s1+s2+...+sn)/n \\n\\n\\n\\n# Code\\n```\\nselect\\n    machine_id, \\n    round(averageE - averagesS, 3) as processing_time\\nfrom \\n    (select \\n        x.machine_id, \\n        avg(x.averagestart) as averagesS, \\n        avg(y.averageend) as averageE\\n   \\n    from \\n        (select\\n            machine_id, \\n            avg(timestamp) as averagestart\\n        from activity \\n        where activity_type = \\'start\\'\\n        group by machine_id) as x\\n    join\\n        (select \\n            machine_id, \\n            avg(timestamp) as averageend \\n        from activity\\n        where activity_type = \\'end\\'\\n        group by machine_id) as y\\n        on x.machine_id = y.machine_id\\ngroup by machine_id\\n) as q\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    machine_id, \\n    round(averageE - averagesS, 3) as processing_time\\nfrom \\n    (select \\n        x.machine_id, \\n        avg(x.averagestart) as averagesS, \\n        avg(y.averageend) as averageE\\n   \\n    from \\n        (select\\n            machine_id, \\n            avg(timestamp) as averagestart\\n        from activity \\n        where activity_type = \\'start\\'\\n        group by machine_id) as x\\n    join\\n        (select \\n            machine_id, \\n            avg(timestamp) as averageend \\n        from activity\\n        where activity_type = \\'end\\'\\n        group by machine_id) as y\\n        on x.machine_id = y.machine_id\\ngroup by machine_id\\n) as q\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084806,
                "title": "beats-94-55-of-users-with-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n  Activity_1.machine_id,\\n  ROUND(AVG(processing_time),3) processing_time \\nFROM (\\n  SELECT \\n    Activity.machine_id,\\n    Activity.process_id,\\n    ROUND((Activity.end_time-Activity.start_time),3) processing_time \\n  FROM (\\n    SELECT\\n      machine_id,\\n      process_id,\\n      SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END) AS start_time, \\n      SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity  GROUP BY 1,2\\n      ) Activity \\n    ) Activity_1 \\n  GROUP BY \\n    Activity_1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n  Activity_1.machine_id,\\n  ROUND(AVG(processing_time),3) processing_time \\nFROM (\\n  SELECT \\n    Activity.machine_id,\\n    Activity.process_id,\\n    ROUND((Activity.end_time-Activity.start_time),3) processing_time \\n  FROM (\\n    SELECT\\n      machine_id,\\n      process_id,\\n      SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END) AS start_time, \\n      SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity  GROUP BY 1,2\\n      ) Activity \\n    ) Activity_1 \\n  GROUP BY \\n    Activity_1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084762,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time \\nFROM Activity a1\\nJOIN Activity a2 on a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id\\nAND a1.activity_type=\\'start\\' AND a2.activity_type=\\'end\\'\\nGROUP By a1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time \\nFROM Activity a1\\nJOIN Activity a2 on a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id\\nAND a1.activity_type=\\'start\\' AND a2.activity_type=\\'end\\'\\nGROUP By a1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084643,
                "title": "using-left-join-easy-solution",
                "content": "# Intuition\\nCalculating procissing time for each process on every machine and then averaging it\\n\\n# Approach\\nConsider the table as a1 and a2.\\na1 should only contain start time and a2 should only contain end time.\\nSubtracting a1.starttime from a2.endtime will give processing time for each process on every machine.\\n\\nThen use this table to get averages.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect machine_id, ROUND(sum(processing_time)/(max(process_id)+1), 3) as processing_time\\nfrom\\n(\\nselect machine_id,  a1.process_id as process_id, (a2.timestamp - a1.timestamp) as processing_time\\nfrom Activity as a1 left join Activity as a2 using(machine_id)\\nwhere a1.activity_type = \"start\" and a2.activity_type = \"end\" and a1.process_id = a2.process_id\\norder by machine_id\\n)\\nAS result\\n\\ngroup by machine_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect machine_id, ROUND(sum(processing_time)/(max(process_id)+1), 3) as processing_time\\nfrom\\n(\\nselect machine_id,  a1.process_id as process_id, (a2.timestamp - a1.timestamp) as processing_time\\nfrom Activity as a1 left join Activity as a2 using(machine_id)\\nwhere a1.activity_type = \"start\" and a2.activity_type = \"end\" and a1.process_id = a2.process_id\\norder by machine_id\\n)\\nAS result\\n\\ngroup by machine_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084041,
                "title": "oracle-easy-fast-solution",
                "content": "\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect a1.machine_id, round(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nfrom activity a1, activity a2\\nwhere a1.machine_id=a2.machine_id\\nand a1.process_id=a2.process_id\\nand a1.timestamp < a2.timestamp\\ngroup by a1.machine_id;\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect a1.machine_id, round(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nfrom activity a1, activity a2\\nwhere a1.machine_id=a2.machine_id\\nand a1.process_id=a2.process_id\\nand a1.timestamp < a2.timestamp\\ngroup by a1.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083341,
                "title": "beats-93-44-of-users-with-ms-sql-server",
                "content": "Beats 93.44%of users with MS SQL Server\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\nwith cte as\\r\\n(\\r\\n   Select *,--count(machine_id) over(partition by machine_id) as a,\\r\\n   lag(timestamp,1) over(partition by machine_id,process_id order by timestamp) as b\\r\\n   from activity\\r\\n)\\r\\nselect machine_id,\\r\\nround(sum(timestamp-b) * 1.000/count(machine_id),3) as processing_time from cte\\r\\nwhere activity_type = \\'end\\'\\r\\ngroup by machine_id\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\nwith cte as\\r\\n(\\r\\n   Select *,--count(machine_id) over(partition by machine_id) as a,\\r\\n   lag(timestamp,1) over(partition by machine_id,process_id order by timestamp) as b\\r\\n   from activity\\r\\n)\\r\\nselect machine_id,\\r\\nround(sum(timestamp-b) * 1.000/count(machine_id),3) as processing_time from cte\\r\\nwhere activity_type = \\'end\\'\\r\\ngroup by machine_id\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081983,
                "title": "beats-93-39-of-users-with-mysql",
                "content": "# Intuition\\nUse the process_id as a divisor and use min and max to get the difference \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect\\nmachine_id,\\nROUND(SUM(processing_time) / SUM(x), 3) as  processing_time\\nfrom(\\nselect distinct\\nmachine_id,\\nprocess_id,\\nDENSE_RANK() OVER ( PARTITION BY process_id\\n        ORDER BY process_id\\n    )  x,\\n(MAX(timestamp)  -  MIN(timestamp)) processing_time\\nfrom Activity\\ngroup by machine_id ,  process_id ) as a\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect\\nmachine_id,\\nROUND(SUM(processing_time) / SUM(x), 3) as  processing_time\\nfrom(\\nselect distinct\\nmachine_id,\\nprocess_id,\\nDENSE_RANK() OVER ( PARTITION BY process_id\\n        ORDER BY process_id\\n    )  x,\\n(MAX(timestamp)  -  MIN(timestamp)) processing_time\\nfrom Activity\\ngroup by machine_id ,  process_id ) as a\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081924,
                "title": "sql-two-approaches",
                "content": "# Code\\n\\n## Option 1\\n\\n```\\nSELECT \\n  a1.machine_id,\\n  round(avg(a1.timestamp - a2.timestamp), 3) AS processing_time\\nFROM Activity a1 \\nINNER JOIN Activity a2 \\n  ON a1.machine_id = a2.machine_id\\n    AND a1.process_id = a2.process_id \\n    AND a1.activity_type = \\'end\\'\\n    AND a2.activity_type = \\'start\\'\\nGROUP BY a1.machine_id\\n```\\n\\n## Option 2\\n\\n```\\nSELECT \\n  a1.machine_id,\\n  round(avg(a2.max - a2.min), 3) AS processing_time\\nFROM Activity a1 \\nINNER JOIN (\\n    SELECT \\n      machine_id, \\n      max(timestamp) AS max, \\n      min(timestamp) AS min\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n  ) a2 ON a1.machine_id = a2.machine_id\\nGROUP BY a1.machine_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT \\n  a1.machine_id,\\n  round(avg(a1.timestamp - a2.timestamp), 3) AS processing_time\\nFROM Activity a1 \\nINNER JOIN Activity a2 \\n  ON a1.machine_id = a2.machine_id\\n    AND a1.process_id = a2.process_id \\n    AND a1.activity_type = \\'end\\'\\n    AND a2.activity_type = \\'start\\'\\nGROUP BY a1.machine_id\\n```\n```\\nSELECT \\n  a1.machine_id,\\n  round(avg(a2.max - a2.min), 3) AS processing_time\\nFROM Activity a1 \\nINNER JOIN (\\n    SELECT \\n      machine_id, \\n      max(timestamp) AS max, \\n      min(timestamp) AS min\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n  ) a2 ON a1.machine_id = a2.machine_id\\nGROUP BY a1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081069,
                "title": "mysql-only-group-by-avg-if-my-solution-is-diff",
                "content": "# Intuition\\nThe query aims to calculate the average processing time for each machine based on activities recorded in a database. It appears to involve conditional calculations of time differences for different activity types and then averaging those differences for each machine.\\n\\n# Approach\\n1. The query selects data from the `activity` table.\\n2. It groups the data by `machine_id`, meaning it will calculate the average processing time for each unique machine.\\n3. Inside the `avg` function, there\\'s a conditional check using `If(activity_type = \"end\", timestamp, -timestamp)`. This means that if the `activity_type` is \"end,\" it takes the `timestamp` value as is, and if it\\'s not \"end,\" it negates the `timestamp` value (likely indicating the start time).\\n4. The `avg` function calculates the average of these modified `timestamp` values.\\n5. The key to ensure the result is in the desired result is the result is multiplied by 2. Because, when we calculate the `avg` function, we divide for both the timestamp of *end* and *start*). \\nEx: Let\\'s say there\\'s a machine with 3 `processes`. This means there are 6 `activities` in total. If we calculate the average, it would divides the total number of `activities` (6) by the number of `processes` (3). However, if we only want to divide by 3 `processes`, we need to multiply the result by `2` to get the most accurate outcome.\\n6. Then rounded to 3 decimal places.\\n7. The result is labeled as `processing_time` in the output.\\n\\n# Complexity\\n- Time complexity: The time complexity of this query depends on the size of the `activity` table and the number of unique `machine_id` values. It involves grouping and conditional calculations, so it may have a time complexity of approximately O(n), where n is the number of rows in the `activity` table.\\n- Space complexity: The space complexity of this query is generally related to the memory required for processing and storing intermediate results. It\\'s also influenced by the size of the result set, which in this case, consists of one row per unique `machine_id`. So, the space complexity can be considered moderate, depending on the database\\'s query optimization and indexing.\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT machine_id, \\n    ROUND(\\n        AVG(\\n            IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) as processing_time \\nFROM activity \\nGROUP BY machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT machine_id, \\n    ROUND(\\n        AVG(\\n            IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) as processing_time \\nFROM activity \\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078920,
                "title": "clean-solution-with-100-and-explanation-of-each-step",
                "content": "# Code\\n```\\nSELECT \\n  a1.machine_id, \\n  ROUND(AVG(a2.timestamp - a1.timestamp), 3) AS processing_time \\n  FROM Activity a1 \\n    INNER JOIN Activity a2 \\n      ON a1.machine_id = a2.machine_id \\n      AND a1.process_id = a2.process_id \\n      AND a1.activity_type = \\'start\\' \\n      AND a2.activity_type = \\'end\\'\\nGROUP BY machine_id\\n```\\n\\n# Explanation\\nWe know that for a given machine_id and process_id, there will be 2 rows in the table: 1 for start and 1 for end.\\nWe want to select these 2 rows as one, such that we can then find the processing time. To do this, we apply `INNER JOIN` on the same table with the condition (`ON`) that the machine_id and process_id are the same (`a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id`). \\nNext we can used the first table to get the start process, and the second table to get the second process. We do this by specifying `a1.activity_type = \\'start\\'` and `a2.activity_type = \\'end\\'`, resulting in a2 being the end process and a1 being the start process.\\n\\nNow that we have a1 as start, and a2 as end process for a given machine_id and process_id, we find the processing_time by subtracting start from end with `a2.timestamp - a1.timestamp`.\\nTo find the average of a machine of all processes, we find the average in 2 parts. First we apply `AVG()` method to the processing_time and use `GROUP BY machine_id` as we need average of all processes for a given machine_id.\\n\\nLastly, with the average processing_time, we use the `ROUND(_, 3)` method to round the average to 3 decimal places.\\n\\nHope this helps!\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n  a1.machine_id, \\n  ROUND(AVG(a2.timestamp - a1.timestamp), 3) AS processing_time \\n  FROM Activity a1 \\n    INNER JOIN Activity a2 \\n      ON a1.machine_id = a2.machine_id \\n      AND a1.process_id = a2.process_id \\n      AND a1.activity_type = \\'start\\' \\n      AND a2.activity_type = \\'end\\'\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078785,
                "title": "using-if-inside-select-thought-of-an-excel-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen working with the average value of data, I only care about the number of divisions and the total number of divisions. So I approach using Excel\\'s trick with the sum function \"sumif\" and it works\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproaching the problem: I think the problem is approached by 2 different times according to arithmetic as follows: when activity_type = end, the value is a positive number, when activity_type = start, the value is a negative number.\\n# Note\\nRemember to use group by and round to get the desired results\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT machine_id, \\n      round((SUM(IF(activity_type = \\'end\\', timestamp, 0)) - SUM(IF(activity_type = \\'start\\', timestamp, 0)))/COUNT(DISTINCT process_id),3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT machine_id, \\n      round((SUM(IF(activity_type = \\'end\\', timestamp, 0)) - SUM(IF(activity_type = \\'start\\', timestamp, 0)))/COUNT(DISTINCT process_id),3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074795,
                "title": "usando-pivot-round-avg-group-by",
                "content": "# Intuition\\nHay que tomarlo desde la perspectiva del Pivot\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nFacil no esta, es poco codigo, pero involucra muchos elementos\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT machine_id,ROUND(AVG([end]-[start]),3) as processing_time FROM\\n        (\\n          SELECT machine_id,activity_type,timestamp\\n          FROM Activity\\n        ) as T\\n        Pivot\\n        (AVG(timestamp)\\n        FOR Activity_type in ([start],[end])\\n        ) AS P\\n        GROUP BY machine_id\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT machine_id,ROUND(AVG([end]-[start]),3) as processing_time FROM\\n        (\\n          SELECT machine_id,activity_type,timestamp\\n          FROM Activity\\n        ) as T\\n        Pivot\\n        (AVG(timestamp)\\n        FOR Activity_type in ([start],[end])\\n        ) AS P\\n        GROUP BY machine_id\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074402,
                "title": "mssql",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    machine_id,\\n    round(avg(duration),3) as processing_time\\nfrom (    \\n    select\\n        start.machine_id,\\n        start.process_id,\\n        e.timestamp-start.timestamp as duration\\n    from Activity start\\n    inner join Activity e on e.machine_id=start.machine_id and e.process_id=start.process_id and e.activity_type=\\'end\\'\\n    where start.activity_type=\\'start\\'\\n) as aa\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    machine_id,\\n    round(avg(duration),3) as processing_time\\nfrom (    \\n    select\\n        start.machine_id,\\n        start.process_id,\\n        e.timestamp-start.timestamp as duration\\n    from Activity start\\n    inner join Activity e on e.machine_id=start.machine_id and e.process_id=start.process_id and e.activity_type=\\'end\\'\\n    where start.activity_type=\\'start\\'\\n) as aa\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074311,
                "title": "runtime-461ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT TF.machine_id as machine_id, ROUND(AVG(TF.timediff),3) as processing_time\\nFROM (SELECT A.machine_id as machine_id, (B.timestamp-A.timestamp) as timediff\\nFROM Activity as A, Activity as B\\nWHERE  A.machine_id = B.machine_id and\\nA.process_id = B.process_id and \\nA.activity_type = \"start\" and \\nB.activity_type = \"end\") TF\\nGROUP BY machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT TF.machine_id as machine_id, ROUND(AVG(TF.timediff),3) as processing_time\\nFROM (SELECT A.machine_id as machine_id, (B.timestamp-A.timestamp) as timediff\\nFROM Activity as A, Activity as B\\nWHERE  A.machine_id = B.machine_id and\\nA.process_id = B.process_id and \\nA.activity_type = \"start\" and \\nB.activity_type = \"end\") TF\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073006,
                "title": "using-nested-query-and-not-self-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect machine_id, round(avg(timestamp),3) processing_time\\nfrom(\\nselect machine_id, process_id, (max(timestamp) - min(timestamp)) timestamp\\nfrom Activity a\\ngroup by machine_id,process_id\\n) tab1\\ngroup by machine_id\\n;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect machine_id, round(avg(timestamp),3) processing_time\\nfrom(\\nselect machine_id, process_id, (max(timestamp) - min(timestamp)) timestamp\\nfrom Activity a\\ngroup by machine_id,process_id\\n) tab1\\ngroup by machine_id\\n;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070214,
                "title": "mysql-easy-solution-beats-95-69-in-time-complexity-beats-100-in-space-complexity",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect a1.machine_id, round(avg(a1.timestamp-a2.timestamp),3) as processing_time\\nfrom activity a1, activity a2\\nwhere a1.activity_type = \\'end\\' and a2.activity_type = \\'start\\' and a1.machine_id = a2.machine_id and a1.process_id = a2.process_id\\ngroup by a1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect a1.machine_id, round(avg(a1.timestamp-a2.timestamp),3) as processing_time\\nfrom activity a1, activity a2\\nwhere a1.activity_type = \\'end\\' and a2.activity_type = \\'start\\' and a1.machine_id = a2.machine_id and a1.process_id = a2.process_id\\ngroup by a1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070074,
                "title": "simple-two-loops",
                "content": "# Intuition\\nsimple two loops\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect machine_id, ROUND(sum(diff)/count(machine_id),3) as processing_time from ( select  t1.machine_id, t1.process_id,  \\n(\\n  select t2.timestamp-t1.timestamp \\n  from Activity t2 where \\n  t1.machine_id=t2.machine_id and  \\n  t1.process_id=t2.process_id  and \\n  t1.activity_type=\\'start\\' and \\n  t2.activity_type=\\'end\\'\\n)\\n as diff  from Activity t1 where  t1.activity_type=\\'start\\') as t3  group by machine_id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect machine_id, ROUND(sum(diff)/count(machine_id),3) as processing_time from ( select  t1.machine_id, t1.process_id,  \\n(\\n  select t2.timestamp-t1.timestamp \\n  from Activity t2 where \\n  t1.machine_id=t2.machine_id and  \\n  t1.process_id=t2.process_id  and \\n  t1.activity_type=\\'start\\' and \\n  t2.activity_type=\\'end\\'\\n)\\n as diff  from Activity t1 where  t1.activity_type=\\'start\\') as t3  group by machine_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068239,
                "title": "97-21-easy-mysql-solution",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# heading\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSelect a.machine_id as machine_id,\\nround( avg( a.timeCal ) ,3)  as processing_time \\n from \\n(\\nSelect machine_id ,\\nround( timestamp ,3 ) - lag ( round( timestamp ,3 ) ) \\nover(PARTITION BY  machine_id ,Process_id  order by  machine_id ,Process_id , activity_type   ) as timeCal\\nfrom Activity\\n) a\\nwhere a.timeCal is not null \\ngroup by a.machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSelect a.machine_id as machine_id,\\nround( avg( a.timeCal ) ,3)  as processing_time \\n from \\n(\\nSelect machine_id ,\\nround( timestamp ,3 ) - lag ( round( timestamp ,3 ) ) \\nover(PARTITION BY  machine_id ,Process_id  order by  machine_id ,Process_id , activity_type   ) as timeCal\\nfrom Activity\\n) a\\nwhere a.timeCal is not null \\ngroup by a.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067477,
                "title": "mysql-solution-using-simple-cte",
                "content": "# Intuition\\ndone using the cte \\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwith cte1 as\\n(select machine_id, process_id,timestamp from activity where activity_type = \"start\"),\\ncte2 as\\n(select machine_id, process_id,timestamp from activity where activity_type = \"end\")\\nselect a.machine_id as machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom cte1 a\\njoin cte2 b\\non a.machine_id = b.machine_id and a.process_id = b.process_id\\ngroup by machine_id\\norder by machine_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith cte1 as\\n(select machine_id, process_id,timestamp from activity where activity_type = \"start\"),\\ncte2 as\\n(select machine_id, process_id,timestamp from activity where activity_type = \"end\")\\nselect a.machine_id as machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom cte1 a\\njoin cte2 b\\non a.machine_id = b.machine_id and a.process_id = b.process_id\\ngroup by machine_id\\norder by machine_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067408,
                "title": "mysql-beats-99-99-solution-self-join-and-where-condition-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are 3 main components in this query:\\n1. **Self join:** Self join has to be used because start and end activities are listed in same table and we have to calculate the difference between them. So we joined the tables based on machine and process ids but we also wanted to think of table 1 with all start dates and table 2 with all end dates. Now, that is not possible to add in ON condition \\n2. **Where condition:** So the where condition came into picture. We separated table 1 and table 2 for start and end conditions and picked start condition from 1 table and end condition from another table\\n3. **Calculation of Average:** For calculation, we need end time - start time divided by total number of distinct processes (distinct is not required here because we are splitting start processes into 1 table and end processed into other table so process ids are not repeated)\\n4. Grouping is done on machine id only because obviously we need result for each machine only\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect a1.machine_id as machine_id ,\\nround(sum(a2.timestamp - a1.timestamp)/count(a1.process_id),3) as processing_time\\nfrom Activity a1 join \\nActivity a2\\non a1.machine_id = a2.machine_id and a1.process_id = a2.process_id \\nwhere a1.activity_type = \\'start\\' and a2.activity_type = \\'end\\'\\ngroup by a1.machine_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect a1.machine_id as machine_id ,\\nround(sum(a2.timestamp - a1.timestamp)/count(a1.process_id),3) as processing_time\\nfrom Activity a1 join \\nActivity a2\\non a1.machine_id = a2.machine_id and a1.process_id = a2.process_id \\nwhere a1.activity_type = \\'start\\' and a2.activity_type = \\'end\\'\\ngroup by a1.machine_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065395,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect A1.machine_id,Round(sum(A2.timestamp-A1.timestamp)/count(A1.process_id),3) as processing_time\\nfrom Activity A1 \\njoin Activity A2 \\non A1.machine_id=A2.machine_id \\nand A1.process_id =A2.process_id \\nand A1.activity_type =\"Start\" \\nand A2.activity_type=\"end\"\\ngroup by machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect A1.machine_id,Round(sum(A2.timestamp-A1.timestamp)/count(A1.process_id),3) as processing_time\\nfrom Activity A1 \\njoin Activity A2 \\non A1.machine_id=A2.machine_id \\nand A1.process_id =A2.process_id \\nand A1.activity_type =\"Start\" \\nand A2.activity_type=\"end\"\\ngroup by machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064333,
                "title": "oracle-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect \\n    machine_id,\\n    round(sum(processing_time)/count(processing_time), 3) as processing_time\\nfrom (\\n    select\\n        s.machine_id,\\n        s.process_id,\\n        e.timestamp-s.timestamp as processing_time\\n    from \\n        Activity s,\\n        Activity e\\n    where\\n        s.machine_id = e.machine_id and \\n        s.process_id = e.process_id and\\n        s.activity_type=\\'start\\' and\\n        e.activity_type=\\'end\\'\\n)\\ngroup by machine_id\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect \\n    machine_id,\\n    round(sum(processing_time)/count(processing_time), 3) as processing_time\\nfrom (\\n    select\\n        s.machine_id,\\n        s.process_id,\\n        e.timestamp-s.timestamp as processing_time\\n    from \\n        Activity s,\\n        Activity e\\n    where\\n        s.machine_id = e.machine_id and \\n        s.process_id = e.process_id and\\n        s.activity_type=\\'start\\' and\\n        e.activity_type=\\'end\\'\\n)\\ngroup by machine_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4063442,
                "title": "sql-server-solution-using-pivot-cte-group-by-avg",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Using PIVOT to seperate \\'start\\' and \\'end\\' type timestamp values.\\n- Then, getting a duration column by subtracting start timestamp from end timestamp.\\n- Then, using this table as \\'base_table\\' in CTE, and applying grouping of \\'machine_id\\' and average() on the \\'duration\\' column.\\n- Lastly, applying ROUND() and CAST() function to format the output as required.\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nWITH base_tbl AS (\\n\\tSELECT *, [end]-[start] AS duration FROM Activity\\n\\tPIVOT (\\n\\t\\tSUM(timestamp)\\n\\t\\tFOR activity_type IN ([start],[end])\\n\\t) AS pivot_table\\n)\\nSELECT machine_id, CAST(ROUND(AVG(duration), 3) AS DECIMAL(10,3) ) processing_time FROM base_tbl\\nGROUP BY machine_id;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWITH base_tbl AS (\\n\\tSELECT *, [end]-[start] AS duration FROM Activity\\n\\tPIVOT (\\n\\t\\tSUM(timestamp)\\n\\t\\tFOR activity_type IN ([start],[end])\\n\\t) AS pivot_table\\n)\\nSELECT machine_id, CAST(ROUND(AVG(duration), 3) AS DECIMAL(10,3) ) processing_time FROM base_tbl\\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062127,
                "title": "easy-3-line-solution-basic-mathematics",
                "content": "# Intuition\\nBasic mathematics\\navg_processing_time\\n= sum(processing_time) / count(process)\\n= sum(end_time - start_time) / count((start + end) / 2)\\n= 2 * (sum(end_time) - sum(start_time)) / count(start + end)\\n\\n# Code\\n```\\nselect machine_id, round(2 * sum(timestamp * if(activity_type=\\'start\\', -1, 1)) / count(*), 3) processing_time\\nfrom Activity\\ngroup by machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect machine_id, round(2 * sum(timestamp * if(activity_type=\\'start\\', -1, 1)) / count(*), 3) processing_time\\nfrom Activity\\ngroup by machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062004,
                "title": "sub-query-is-more-straightforward",
                "content": "# Intuition\\n<!-- Take advantage of **\"same number of processes\"** -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT X.machine_id, ROUND(MAX(avg_timestamp) - MIN(avg_timestamp), 3) AS processing_time\\nFROM\\n(SELECT machine_id, AVG(A.timestamp) as avg_timestamp\\nFROM Activity AS A\\nGROUP BY A.machine_id, A.activity_type\\n) AS X\\nGROUP BY X.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT X.machine_id, ROUND(MAX(avg_timestamp) - MIN(avg_timestamp), 3) AS processing_time\\nFROM\\n(SELECT machine_id, AVG(A.timestamp) as avg_timestamp\\nFROM Activity AS A\\nGROUP BY A.machine_id, A.activity_type\\n) AS X\\nGROUP BY X.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059293,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT t1.machine_id machine_id,round(avg(diff),3) as processing_time\\nFROM(\\n    SELECT a.machine_id,a.process_id,abs(a.timestamp-b.timestamp) as diff\\n\\n    FROM Activity a\\n    INNER JOIN Activity b\\n    on a.machine_id = b.machine_id\\n    AND a.process_id = b.process_id\\n    AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\n)t1\\n\\nGROUP BY t1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT t1.machine_id machine_id,round(avg(diff),3) as processing_time\\nFROM(\\n    SELECT a.machine_id,a.process_id,abs(a.timestamp-b.timestamp) as diff\\n\\n    FROM Activity a\\n    INNER JOIN Activity b\\n    on a.machine_id = b.machine_id\\n    AND a.process_id = b.process_id\\n    AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\n)t1\\n\\nGROUP BY t1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058303,
                "title": "with-cte-approach",
                "content": "\\n\\n# Code\\n```\\nwith start_table as\\n(\\n  select * from activity \\n  where activity_type = \\'start\\'\\n),\\nend_table as \\n(\\n  select * from activity\\n  where activity_type = \\'end\\'\\n) \\n\\nselect a.machine_id, round(sum(b.timestamp-a.timestamp)/count(a.process_id),3) as processing_time\\nfrom start_table a\\ninner join end_table b\\non a.machine_id = b.machine_id\\nand a.process_id = b.process_id\\ngroup by machine_id\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith start_table as\\n(\\n  select * from activity \\n  where activity_type = \\'start\\'\\n),\\nend_table as \\n(\\n  select * from activity\\n  where activity_type = \\'end\\'\\n) \\n\\nselect a.machine_id, round(sum(b.timestamp-a.timestamp)/count(a.process_id),3) as processing_time\\nfrom start_table a\\ninner join end_table b\\non a.machine_id = b.machine_id\\nand a.process_id = b.process_id\\ngroup by machine_id\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057690,
                "title": "mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    A1.machine_id,\\n    ROUND(AVG(A2.timestamp - A1.timestamp), 3) AS processing_time\\nFROM \\n    (SELECT machine_id, process_id, timestamp \\n     FROM Activity \\n     WHERE activity_type = \\'start\\') AS A1\\nJOIN \\n    (SELECT machine_id, process_id, timestamp \\n     FROM Activity \\n     WHERE activity_type = \\'end\\') AS A2\\nON \\n    A1.machine_id = A2.machine_id AND A1.process_id = A2.process_id\\nGROUP BY \\n    A1.machine_id;\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    A1.machine_id,\\n    ROUND(AVG(A2.timestamp - A1.timestamp), 3) AS processing_time\\nFROM \\n    (SELECT machine_id, process_id, timestamp \\n     FROM Activity \\n     WHERE activity_type = \\'start\\') AS A1\\nJOIN \\n    (SELECT machine_id, process_id, timestamp \\n     FROM Activity \\n     WHERE activity_type = \\'end\\') AS A2\\nON \\n    A1.machine_id = A2.machine_id AND A1.process_id = A2.process_id\\nGROUP BY \\n    A1.machine_id;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056994,
                "title": "easy-to-understand",
                "content": "# Intuition\\nit must use group by clause\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\njoining the tables to calculate difference between two values of the same column\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 4.19ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0.0 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect t.machine_id as machine_id , round(avg(t.d),3)\\nas processing_time\\nfrom\\n(select a.machine_id,b.timestamp-a.timestamp as d\\nfrom Activity a inner join Activity b\\non a.machine_id=b.machine_id\\nand a.process_id=b.process_id\\nand a.activity_type=\\'start\\' \\nand b.activity_type=\\'end\\') as t\\ngroup by t.machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect t.machine_id as machine_id , round(avg(t.d),3)\\nas processing_time\\nfrom\\n(select a.machine_id,b.timestamp-a.timestamp as d\\nfrom Activity a inner join Activity b\\non a.machine_id=b.machine_id\\nand a.process_id=b.process_id\\nand a.activity_type=\\'start\\' \\nand b.activity_type=\\'end\\') as t\\ngroup by t.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056407,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSelect s.machine_id,\\nRound(AVG(e.timestamp-s.timestamp),3) as processing_time\\nFrom Activity e\\nJoin Activity s ON s.machine_id=e.machine_id\\nwhere s.activity_type=\\'start\\' AND e.activity_type=\\'end\\'\\nGROUP BY s.machine_id\\n \\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect s.machine_id,\\nRound(AVG(e.timestamp-s.timestamp),3) as processing_time\\nFrom Activity e\\nJoin Activity s ON s.machine_id=e.machine_id\\nwhere s.activity_type=\\'start\\' AND e.activity_type=\\'end\\'\\nGROUP BY s.machine_id\\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054660,
                "title": "why-don-t-try-if-statement-here",
                "content": "# JAI HIND JAI BHARAT\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n->>Approach is simply to group it according to machine_id\\n\\n->>and then using if statement we - if its start and + if its end\\n\\n->>We find the average and before rounding it to 3 decimal place we multiply with 2.\\n\\n->>Rest of the work will be done by round().\\n\\nDo upvote if you have understood my simple uproach. :-) \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect machine_id,round(avg(if(activity_type = \"start\",-timestamp,+timestamp))*2,3) as processing_time\\nfrom Activity \\ngroup by machine_id;\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect machine_id,round(avg(if(activity_type = \"start\",-timestamp,+timestamp))*2,3) as processing_time\\nfrom Activity \\ngroup by machine_id;\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054282,
                "title": "average-time-of-process-per-machine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Use self join -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.machine_id, round(avg(e.timestamp - s.timestamp),3) as processing_time\\nfrom Activity e inner join Activity s \\non e.machine_id = s.machine_id\\nand e.process_id = s.process_id\\nand e.activity_type = \\'end\\'\\nand s.activity_type = \\'start\\'\\ngroup by machine_id; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.machine_id, round(avg(e.timestamp - s.timestamp),3) as processing_time\\nfrom Activity e inner join Activity s \\non e.machine_id = s.machine_id\\nand e.process_id = s.process_id\\nand e.activity_type = \\'end\\'\\nand s.activity_type = \\'start\\'\\ngroup by machine_id; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052950,
                "title": "sql-without-join",
                "content": "SELECT \\n    machine_id, \\n    ROUND(SUM(timestamp * (activity_type = \\'end\\') - timestamp * (activity_type = \\'start\\')) / \\n    COUNT(DISTINCT process_id), 3) AS processing_time\\nFROM \\n    activity\\nGROUP BY \\n    machine_id;\\n\\n",
                "solutionTags": [],
                "code": "SELECT \\n    machine_id, \\n    ROUND(SUM(timestamp * (activity_type = \\'end\\') - timestamp * (activity_type = \\'start\\')) / \\n    COUNT(DISTINCT process_id), 3) AS processing_time\\nFROM \\n    activity\\nGROUP BY \\n    machine_id;\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4052724,
                "title": "easy-solution-using-cte-join",
                "content": "# Approach\\nFirst filter rows using start time then similarly filter data for end time. Then Join both using machine_id and process_id. \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nWITH cte1 AS \\n  (SELECT machine_id,process_id,timestamp AS startTime\\n  FROM activity\\n  WHERE activity_type = \"start\"),\\ncte2 AS\\n  (SELECT machine_id,process_id,timestamp AS endTime\\n  FROM activity\\n  WHERE activity_type = \"end\")\\nSELECT \\n  c1.machine_id,\\n  ROUND(SUM(endTime-startTime)/COUNT(c1.process_id),3) AS processing_time\\nFROM cte1 c1\\nJOIN cte2 c2\\nON c1.machine_id = c2.machine_id AND c1.process_id = c2.process_id\\nGROUP BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nWITH cte1 AS \\n  (SELECT machine_id,process_id,timestamp AS startTime\\n  FROM activity\\n  WHERE activity_type = \"start\"),\\ncte2 AS\\n  (SELECT machine_id,process_id,timestamp AS endTime\\n  FROM activity\\n  WHERE activity_type = \"end\")\\nSELECT \\n  c1.machine_id,\\n  ROUND(SUM(endTime-startTime)/COUNT(c1.process_id),3) AS processing_time\\nFROM cte1 c1\\nJOIN cte2 c2\\nON c1.machine_id = c2.machine_id AND c1.process_id = c2.process_id\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051849,
                "title": "100-better-easy-and-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT a.machine_id,ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id),3) as processing_time  FROM Activity as a JOIN\\nActivity as c ON a.machine_id = c.machine_id and a.process_id = c.process_id and a.activity_type = \"start\" and c.activity_type = \"end\"\\nGROUP BY a.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT a.machine_id,ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id),3) as processing_time  FROM Activity as a JOIN\\nActivity as c ON a.machine_id = c.machine_id and a.process_id = c.process_id and a.activity_type = \"start\" and c.activity_type = \"end\"\\nGROUP BY a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051782,
                "title": "self-join-avg-round",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect et.machine_id, round(avg (et.timestamp-st.timestamp),3) as processing_time\\nfrom activity as et\\ninner join activity  as st\\non  et.machine_id = st.machine_id \\nand et.process_id = st.process_id \\nand et.activity_type = \\'end\\' \\nand  st.activity_type = \\'start\\'\\ngroup by et.machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect et.machine_id, round(avg (et.timestamp-st.timestamp),3) as processing_time\\nfrom activity as et\\ninner join activity  as st\\non  et.machine_id = st.machine_id \\nand et.process_id = st.process_id \\nand et.activity_type = \\'end\\' \\nand  st.activity_type = \\'start\\'\\ngroup by et.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051028,
                "title": "just-by-using-group-by",
                "content": "\\n\\n# Code\\n```\\nselect machine_id , round(avg(timediff),3) as processing_time\\nfrom\\n(\\nselect machine_id , process_id ,(max(timestamp)-min(timestamp)) as timediff\\nfrom Activity\\ngroup by machine_id , process_id\\n)\\ngroup by machine_id",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "\\n\\n# Code\\n```\\nselect machine_id , round(avg(timediff),3) as processing_time\\nfrom\\n(\\nselect machine_id , process_id ,(max(timestamp)-min(timestamp)) as timediff\\nfrom Activity\\ngroup by machine_id , process_id\\n)\\ngroup by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 4050704,
                "title": "easy-solution-using-self-join",
                "content": "# Code\\n```\\nSELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp), 3) AS processing_time\\nFROM Activity a1 JOIN Activity a2 ON\\n    a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND\\n    a2.activity_type = \\'start\\' AND a1.activity_type = \\'end\\'\\nGROUP BY a1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp), 3) AS processing_time\\nFROM Activity a1 JOIN Activity a2 ON\\n    a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND\\n    a2.activity_type = \\'start\\' AND a1.activity_type = \\'end\\'\\nGROUP BY a1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049392,
                "title": "clean-solution-using-with-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nBeats 84.92%of users with MySQL\\n\\n- Space complexity:\\nBeats 100.00%of users with MySQL\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH start as(\\n  SELECT *\\n  FROM Activity\\n  WHERE activity_type = \\'start\\'\\n),\\nend_t as(\\n  SELECT *\\n  FROM Activity\\n  WHERE activity_type = \\'end\\'\\n)\\nSELECT start.machine_id, ROUND(AVG(end_t.timestamp - start.timestamp),3) as processing_time\\nFROM start\\nINNER JOIN end_t\\nON start.machine_id = end_t.machine_id\\nAND start.process_id = end_t.process_id\\nGROUP BY start.machine_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH start as(\\n  SELECT *\\n  FROM Activity\\n  WHERE activity_type = \\'start\\'\\n),\\nend_t as(\\n  SELECT *\\n  FROM Activity\\n  WHERE activity_type = \\'end\\'\\n)\\nSELECT start.machine_id, ROUND(AVG(end_t.timestamp - start.timestamp),3) as processing_time\\nFROM start\\nINNER JOIN end_t\\nON start.machine_id = end_t.machine_id\\nAND start.process_id = end_t.process_id\\nGROUP BY start.machine_id\\n\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1911039,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1934803,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2033928,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1575226,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1570395,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1883530,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2009536,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2049070,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2046338,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1995112,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1911039,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1934803,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2033928,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1575226,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1570395,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1883530,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2009536,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2049070,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2046338,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1995112,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1958866,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2074670,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2073852,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2072973,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2070549,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2068211,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2058716,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2057459,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2054046,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2044604,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2044233,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2032807,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2030976,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2030261,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2027990,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2012786,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2000919,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2000125,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 1993887,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 1989327,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            }
        ]
    }
]