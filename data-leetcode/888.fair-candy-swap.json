[
    {
        "title": "Fair Candy Swap",
        "question_content": "Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has.\nSince they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.\nReturn an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists.\n&nbsp;\nExample 1:\n\nInput: aliceSizes = [1,1], bobSizes = [2,2]\nOutput: [1,2]\n\nExample 2:\n\nInput: aliceSizes = [1,2], bobSizes = [2,3]\nOutput: [1,2]\n\nExample 3:\n\nInput: aliceSizes = [2], bobSizes = [1,3]\nOutput: [2,3]\n\n&nbsp;\nConstraints:\n\n\t1 <= aliceSizes.length, bobSizes.length <= 104\n\t1 <= aliceSizes[i], bobSizes[j] <= 105\n\tAlice and Bob have a different total number of candies.\n\tThere will be at least one valid answer for the given input.",
        "solutions": [
            {
                "id": 161269,
                "title": "c-java-python-straight-forward",
                "content": "Calculate `dif = (sum(A) - sum(B)) / 2`\\nWe want find a pair `(a, b)` with `a = b + dif`\\n\\n**Time Complexity**:\\nO(N)\\n\\n**C++:**\\n```\\n    vector<int> fairCandySwap(vector<int> A, vector<int> B) {\\n        int dif = (accumulate(A.begin(), A.end(), 0) - accumulate(B.begin(), B.end(), 0)) / 2;\\n        unordered_set<int> S(A.begin(), A.end());\\n        for (int b: B)\\n            if (S.count(b + dif))\\n                return {b + dif, b};\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int dif = (IntStream.of(A).sum() - IntStream.of(B).sum()) / 2;\\n        HashSet<Integer> S = new HashSet<>();\\n        for (int a : A) S.add(a);\\n        for (int b : B) if (S.contains(b + dif)) return new int[] {b + dif, b};\\n        return new int[0];\\n    }\\n```\\n**Python:**\\n```\\n    def fairCandySwap(self, A, B):\\n        dif = (sum(A) - sum(B)) / 2\\n        A = set(A)\\n        for b in set(B):\\n            if dif + b in A:\\n                return [dif + b, b]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    vector<int> fairCandySwap(vector<int> A, vector<int> B) {\\n        int dif = (accumulate(A.begin(), A.end(), 0) - accumulate(B.begin(), B.end(), 0)) / 2;\\n        unordered_set<int> S(A.begin(), A.end());\\n        for (int b: B)\\n            if (S.count(b + dif))\\n                return {b + dif, b};\\n    }\\n```\n```\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int dif = (IntStream.of(A).sum() - IntStream.of(B).sum()) / 2;\\n        HashSet<Integer> S = new HashSet<>();\\n        for (int a : A) S.add(a);\\n        for (int b : B) if (S.contains(b + dif)) return new int[] {b + dif, b};\\n        return new int[0];\\n    }\\n```\n```\\n    def fairCandySwap(self, A, B):\\n        dif = (sum(A) - sum(B)) / 2\\n        A = set(A)\\n        for b in set(B):\\n            if dif + b in A:\\n                return [dif + b, b]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161316,
                "title": "java-2-solutions-clear-explanation-with-illustration",
                "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/marswork/image_1534651707.png)\\nTherefore, our target is to find a candy pair whose difference is exactly `x/2`\\nif B > A, logic is exactly the same\\n#### Sol1 Brute Force \\ntime complexity:`O(A + B + A * B)`\\nspace  complexity:`O(1)`\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0, sumB = 0;\\n        for (int i = 0; i < A.length; i++)\\n            sumA += A[i];\\n        for (int i = 0; i < B.length; i++)\\n            sumB += B[i];\\n        int dif = (sumA - sumB) / 2;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = 0; j < B.length; j++) {\\n                if (A[i] - B[j] == dif)\\n                    return new int[]{A[i], B[j]};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n#### Sol2 Use Hash Set \\ntime complexity: `O(A + B)`\\nspace complexity: `O(A)`\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0, sumB = 0;\\n        Set<Integer> setA = new HashSet<>();\\n        for (int i = 0; i < A.length; i++) {\\n            sumA += A[i];\\n            setA.add(A[i]);\\n        }\\n        for (int i = 0; i < B.length; i++)\\n            sumB += B[i];\\n        int dif = (sumA - sumB) / 2;\\n        for (int i = 0; i < B.length; i++) {\\n            int targetA = B[i] + dif;\\n            if (setA.contains(targetA))\\n                return new int[]{targetA, B[i]};\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0, sumB = 0;\\n        for (int i = 0; i < A.length; i++)\\n            sumA += A[i];\\n        for (int i = 0; i < B.length; i++)\\n            sumB += B[i];\\n        int dif = (sumA - sumB) / 2;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = 0; j < B.length; j++) {\\n                if (A[i] - B[j] == dif)\\n                    return new int[]{A[i], B[j]};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0, sumB = 0;\\n        Set<Integer> setA = new HashSet<>();\\n        for (int i = 0; i < A.length; i++) {\\n            sumA += A[i];\\n            setA.add(A[i]);\\n        }\\n        for (int i = 0; i < B.length; i++)\\n            sumB += B[i];\\n        int dif = (sumA - sumB) / 2;\\n        for (int i = 0; i < B.length; i++) {\\n            int targetA = B[i] + dif;\\n            if (setA.contains(targetA))\\n                return new int[]{targetA, B[i]};\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826376,
                "title": "c-6-lines",
                "content": "**Prerequiste:**\\n` `sumA -x + y = sumB +x -y\\n` `2y = 2x + sumB - sum A\\n` `y = x+ (sumB-sumA)/2\\n\\n**Explanation:**\\n` `Alice has sumA candies and gives x candies to Bob which has sumB candies. Besides, Bob gives y candies to Alice. They need to have same number of the candies.\\n\\n**C++:**\\n\\n```\\nvector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n\\tint sumA = accumulate(A.begin(),A.end(),0), sumB = accumulate(B.begin(), B.end(),0);\\n\\tint tmp = (sumB-sumA)/2;\\n\\tset<int> stA(A.begin(),A.end()),stB(B.begin(),B.end());\\n\\tfor(auto &x:stA)\\n\\t  if(stB.find(x+tmp)!=stB.end()) return {x,x+tmp};\\n\\treturn {0,0};\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n\\tint sumA = accumulate(A.begin(),A.end(),0), sumB = accumulate(B.begin(), B.end(),0);\\n\\tint tmp = (sumB-sumA)/2;\\n\\tset<int> stA(A.begin(),A.end()),stB(B.begin(),B.end());\\n\\tfor(auto &x:stA)\\n\\t  if(stB.find(x+tmp)!=stB.end()) return {x,x+tmp};\\n\\treturn {0,0};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209748,
                "title": "c-24-ms-99-o-n-solution-using-bitfield",
                "content": "The intuition is based on the equation for solving this problem: sumA - A + B = sumB + A - B.\\n\\nSimplifying this equation yields: 2*B = sumB - sumA + 2*A = 2*A - (sumA - sumB).\\n\\nThus, we need to go through each number in A, and see if there is a corresponding number in B that matches the equality. To do this, we can put numbers of B into a set, and then go through  A and see if there is a nubmer in set B that works.\\n\\nSince we only need to mark numbers, and the range of values are small, we can use a bitfield instead of a set. This saves space, which makes it more cache friendly. It also saves some overhead from doing hashes. (Using a set requires about 100ms run-time).\\n\\nThe time complexity is O(n + m), where n is size of A and m size of B. The space complexity is 200002 bits, which is about 25 KB, which fits inside most L1 caches.\\n\\nNote: Not sure if it is problem with my code or with LeetCode, but the first time I submitted this solution I got time limit exceeded, but the second time it is 24 ms.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        bitset<200002> bf;\\n        \\n        int sumA = 0, sumB = 0;\\n        for(auto n: A) {\\n            sumA += n;\\n        }\\n        for(auto n: B) {\\n            sumB += n;\\n            bf.set(2*n);\\n        }\\n        \\n        int diff = sumA - sumB;\\n        \\n        for(auto n: A) {\\n            int det = 2*n - diff;\\n            if(det > 0 && det < 200002 && bf.test(det)) {\\n                return {n, (2*n-diff)/2};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        bitset<200002> bf;\\n        \\n        int sumA = 0, sumB = 0;\\n        for(auto n: A) {\\n            sumA += n;\\n        }\\n        for(auto n: B) {\\n            sumB += n;\\n            bf.set(2*n);\\n        }\\n        \\n        int diff = sumA - sumB;\\n        \\n        for(auto n: A) {\\n            int det = 2*n - diff;\\n            if(det > 0 && det < 200002 && bf.test(det)) {\\n                return {n, (2*n-diff)/2};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3442225,
                "title": "brute-force-binary-search-hashmap",
                "content": "# Brute Force Intuition + Approach\\nJust consider every possible pair, and try to match one element `aliceCandies[i]` from alice and another element `bobCandies[j]` from bob. \\n\\nReturn when \\n```\\n  total(aliceCandies) - aliceCandies[i] + bobCandies[j] \\nequals\\n  total(bobCandies) - bobCandies[j] + aliceCandies[j]\\n```\\n\\nwhere\\n`total(aliceCandies) = all candies initially owned by alice`\\n`total(bobCandies) = all candies initially owned by alice`\\n`aliceCandies[i] = chosen box of candies to trade FROM alice`\\n`bobCandies[i] = chosen box of candies to trade FROM bob`\\n\\n# Complexity\\n- Time complexity:\\nO(mn) - m is length of array from alice, and n is length of array from bob\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes) aliceTotal += candies;\\n    for (int candies : bobSizes) bobTotal += candies;\\n    \\n    int m = aliceSizes.length, n = bobSizes.length;\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++)\\n        if ((aliceTotal - aliceSizes[i] + bobSizes[j]) == (bobTotal - bobSizes[j] + aliceSizes[i]))\\n          return new int[] { aliceSizes[i], bobSizes[j] };\\n\\n    return new int[0];\\n  }\\n```\\n\\n# Binary Search Intuition + Approach\\nThis builds off of previous solution by taking advantage of \\nthe formula:\\n\\n```\\n(aliceTotal - aliceSizes[i] + bobSizes[j]) == (bobTotal - bobSizes[j] + aliceSizes[i])\\n```\\n\\nwhere\\n`total(aliceCandies) = all candies initially owned by alice`\\n`total(bobCandies) = all candies initially owned by alice`\\n`aliceCandies[i] = chosen box of candies to trade FROM alice`\\n`bobCandies[i] = chosen box of candies to trade FROM bob`\\n\\nBecause we know that what alice is trading is proportional to what bob is losing and bob\\'s total, we arrive to the following formula to find `bobSizes[j]`, which is what bob needs to trade to get an equivalent total from both sides:\\n```\\nA_total - A[i] + B[j] = B_total - B[j] + A[i]\\nB[j] + A_total - A[i] + B[j] = B_total + A[i]\\n2 * B[j] + A_total - A[i] = B_total + A[i]\\n2 * B[j] + A_total = B_total + A[i] + A[i]\\n2 * B[j] + A_total = B_total + 2 * A[i]\\n2 * B[j] = B_total - A_total + 2 * A[i]\\nB[j] = (B_total - A_total + 2 * A[i]) / 2\\n```\\n`B[j]` in this case is equivalent to `target` in the code that we are going to binary search every ith iteration, in bob\\'s array.\\n\\nHowever, first need to sort bob\\'s array to be able to perform binary search.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn + mlogn) - m is length of array from alice, and n is length of array from bob\\n\\n- Space complexity:\\nO(1) - no extra space is used\\n\\n# Code\\n```\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes)\\n      aliceTotal += candies;\\n    for (int candies : bobSizes)\\n      bobTotal += candies;\\n    \\n    Arrays.sort(bobSizes);\\n    \\n    int m = aliceSizes.length, n = bobSizes.length;\\n    for (int i = 0; i < m; i++) {      \\n      int target = (bobTotal + 2 * aliceSizes[i] - aliceTotal) / 2;\\n      if (binarySearch(bobSizes, target))\\n        return new int[] { aliceSizes[i], target };\\n    }\\n\\n    return new int[0];\\n  }\\n\\n  private boolean binarySearch(int[] arr, int target) {\\n    int l = 0, r = arr.length - 1;\\n    while (l <= r) {\\n      int m = l + (r - l) / 2;\\n      if (target < arr[m])\\n        r = m - 1;\\n      else if (target > arr[m])\\n        l = m + 1;\\n      else\\n        return true;\\n    }\\n    return false;\\n  }\\n```\\n\\n# HashMap Intuition + Approach\\nThis again builds on previous intuition, where we can figure out hte corresponding pair that must be traded from bob. Store a hashmap of pairing between what alice trade (`A[i]`), and the calculation of what bob must trade.\\n\\nDo a first pass on alice array to compute all keys (trades from bob that must satisfy the formula, given a trade from alice `A[i]`)\\n\\nDo another pass on bob\\'s array, If the key existts in hashmap, then we found a pair, because this was precomputed in first pass.\\n\\n# Complexity\\n- Time complexity:\\nO(m + n) - m is length of array from alice, and n is length of array from bob\\n\\n- Space complexity:\\nO(m) - For storing the target pairs from alice array, m is the length fo the array from alice\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes) aliceTotal += candies;\\n    for (int candies : bobSizes) bobTotal += candies;\\n        \\n    Set<Integer> targets = new HashSet<>();\\n    for (int i = 0, m = aliceSizes.length; i < m; i++)\\n      targets.add((bobTotal - aliceTotal + 2 * aliceSizes[i]) / 2);\\n\\n    for (int j = 0, n = bobSizes.length; j < n; j++)\\n      if (targets.contains(bobSizes[j]))\\n        return new int[] { (aliceTotal + 2 * bobSizes[j] - bobTotal) / 2, bobSizes[j] };\\n\\n    return new int[0];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n  total(aliceCandies) - aliceCandies[i] + bobCandies[j] \\nequals\\n  total(bobCandies) - bobCandies[j] + aliceCandies[j]\\n```\n```\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes) aliceTotal += candies;\\n    for (int candies : bobSizes) bobTotal += candies;\\n    \\n    int m = aliceSizes.length, n = bobSizes.length;\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++)\\n        if ((aliceTotal - aliceSizes[i] + bobSizes[j]) == (bobTotal - bobSizes[j] + aliceSizes[i]))\\n          return new int[] { aliceSizes[i], bobSizes[j] };\\n\\n    return new int[0];\\n  }\\n```\n```\\n(aliceTotal - aliceSizes[i] + bobSizes[j]) == (bobTotal - bobSizes[j] + aliceSizes[i])\\n```\n```\\nA_total - A[i] + B[j] = B_total - B[j] + A[i]\\nB[j] + A_total - A[i] + B[j] = B_total + A[i]\\n2 * B[j] + A_total - A[i] = B_total + A[i]\\n2 * B[j] + A_total = B_total + A[i] + A[i]\\n2 * B[j] + A_total = B_total + 2 * A[i]\\n2 * B[j] = B_total - A_total + 2 * A[i]\\nB[j] = (B_total - A_total + 2 * A[i]) / 2\\n```\n```\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes)\\n      aliceTotal += candies;\\n    for (int candies : bobSizes)\\n      bobTotal += candies;\\n    \\n    Arrays.sort(bobSizes);\\n    \\n    int m = aliceSizes.length, n = bobSizes.length;\\n    for (int i = 0; i < m; i++) {      \\n      int target = (bobTotal + 2 * aliceSizes[i] - aliceTotal) / 2;\\n      if (binarySearch(bobSizes, target))\\n        return new int[] { aliceSizes[i], target };\\n    }\\n\\n    return new int[0];\\n  }\\n\\n  private boolean binarySearch(int[] arr, int target) {\\n    int l = 0, r = arr.length - 1;\\n    while (l <= r) {\\n      int m = l + (r - l) / 2;\\n      if (target < arr[m])\\n        r = m - 1;\\n      else if (target > arr[m])\\n        l = m + 1;\\n      else\\n        return true;\\n    }\\n    return false;\\n  }\\n```\n```\\nclass Solution {\\n  public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n    int aliceTotal = 0;\\n    int bobTotal = 0;\\n    for (int candies : aliceSizes) aliceTotal += candies;\\n    for (int candies : bobSizes) bobTotal += candies;\\n        \\n    Set<Integer> targets = new HashSet<>();\\n    for (int i = 0, m = aliceSizes.length; i < m; i++)\\n      targets.add((bobTotal - aliceTotal + 2 * aliceSizes[i]) / 2);\\n\\n    for (int j = 0, n = bobSizes.length; j < n; j++)\\n      if (targets.contains(bobSizes[j]))\\n        return new int[] { (aliceTotal + 2 * bobSizes[j] - bobTotal) / 2, bobSizes[j] };\\n\\n    return new int[0];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554019,
                "title": "java-easy-to-understand-o-1-space-binary-search",
                "content": "Let Sum of choclates by Alice Be Sa and Sum of choclates by Alice Be Sb\\n\\nLet the choclates from Alice to Bob be A and from Bob to Alice be B\\n\\nSa -A + B = Sb -B+A\\n2(A-B) = (Sa-Sb)\\nA-B = (Sa-Sb)/2\\nA = B+(Sa-Sb)/2\\n\\nSo the goal is to search the elements of Alice such that Bob + (Diff of Sum) exists in the Alice \\nFor optimisation Alice is sorted and Binary search is applied on Alice\\n\\n\\n```\\nclass Solution {\\n    \\n    private int binarySearch(int[] arr,int target){ \\n        int s=0,e = arr.length-1;\\n        \\n        while(s<=e){\\n            int mid = s+ (e-s)/2;\\n            if(arr[mid]==target) return mid;\\n            else if(arr[mid]<target) s=mid+1;\\n            else e=mid-1;\\n            \\n        }\\n        return -1;\\n    }\\n    \\n    public int[] fairCandySwap(int[] a, int[] b) { //a = Alice , b=Bob\\n        int suma=0,sumb=0;\\n        for(int i=0;i<a.length;i++)\\n            suma+=a[i];\\n        for(int i=0;i<b.length;i++)\\n            sumb+=b[i];\\n        \\n        int diff = (suma-sumb)/2;\\n        \\n        Arrays.sort(a);\\n        for(int num:b){\\n            if (binarySearch(a,num+diff) !=-1) return new int[]{num+diff,num};\\n        }\\n        \\n        return null;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int binarySearch(int[] arr,int target){ \\n        int s=0,e = arr.length-1;\\n        \\n        while(s<=e){\\n            int mid = s+ (e-s)/2;\\n            if(arr[mid]==target) return mid;\\n            else if(arr[mid]<target) s=mid+1;\\n            else e=mid-1;\\n            \\n        }\\n        return -1;\\n    }\\n    \\n    public int[] fairCandySwap(int[] a, int[] b) { //a = Alice , b=Bob\\n        int suma=0,sumb=0;\\n        for(int i=0;i<a.length;i++)\\n            suma+=a[i];\\n        for(int i=0;i<b.length;i++)\\n            sumb+=b[i];\\n        \\n        int diff = (suma-sumb)/2;\\n        \\n        Arrays.sort(a);\\n        for(int num:b){\\n            if (binarySearch(a,num+diff) !=-1) return new int[]{num+diff,num};\\n        }\\n        \\n        return null;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675821,
                "title": "binary-search-java-not-easy-level",
                "content": "*Let Sum of choclates by Alice Be Sa and Sum of choclates by Alice Be Sb\\n\\nLet the choclates from Alice to Bob be A and from Bob to Alice be B\\n\\nSa -A + B = Sb -B+A\\n2(A-B) = (Sa-Sb)\\nA-B = (Sa-Sb)/2\\nA = B+(Sa-Sb)/2\\n\\nSo the goal is to search the elements of Alice such that Bob + (Diff of Sum) exists in the Alice\\nFor optimisation Alice is sorted and Binary search is applied on Alice*\\n\\ni don\\'t think this question is an easy level question !! What do you think ?\\n\\n```\\nclass Solution {\\n    private int binarySearch(int[] arr,int target){ \\n\\n        int s = 0, e = arr.length-1;\\n        \\n        while(s <= e)\\n        {\\n            int mid = s + (e-s)/2;\\n            if(arr[mid] == target) return mid;\\n            else if(arr[mid] < target) s=mid+1;\\n            else e = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    public int[] fairCandySwap(int[] a, int[] b) { //a = Alice , b=Bob\\n\\n        int suma=0,sumb=0;\\n        for(int i = 0; i < a.length; i++)\\n            suma += a[i];\\n        \\n        for(int i = 0; i < b.length; i++)\\n            sumb +=b [i];\\n        \\n        int diff = (suma - sumb)/2;\\n        \\n        Arrays.sort(a);\\n        for(int num : b)\\n        {\\n            if (binarySearch(a, num + diff) !=-1) \\n                return new int[] { num + diff, num };\\n        }\\n        \\n        return null;\\n    }\\n}\\n```\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/26c10ed8-4af3-4b8e-9baa-9f486ad1ab0e_1674298298.8688552.webp)\\n\\n\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348) Thanks for voting !!**",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    private int binarySearch(int[] arr,int target){ \\n\\n        int s = 0, e = arr.length-1;\\n        \\n        while(s <= e)\\n        {\\n            int mid = s + (e-s)/2;\\n            if(arr[mid] == target) return mid;\\n            else if(arr[mid] < target) s=mid+1;\\n            else e = mid - 1;\\n        }\\n        return -1;\\n    }\\n    \\n    public int[] fairCandySwap(int[] a, int[] b) { //a = Alice , b=Bob\\n\\n        int suma=0,sumb=0;\\n        for(int i = 0; i < a.length; i++)\\n            suma += a[i];\\n        \\n        for(int i = 0; i < b.length; i++)\\n            sumb +=b [i];\\n        \\n        int diff = (suma - sumb)/2;\\n        \\n        Arrays.sort(a);\\n        for(int num : b)\\n        {\\n            if (binarySearch(a, num + diff) !=-1) \\n                return new int[] { num + diff, num };\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088075,
                "title": "python-super-simple-solution",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        difference = (sum(A) - sum(B)) / 2\\n        A = set(A)\\n        for candy in set(B):\\n            if difference + candy in A:\\n                return [difference + candy, candy]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        difference = (sum(A) - sum(B)) / 2\\n        A = set(A)\\n        for candy in set(B):\\n            if difference + candy in A:\\n                return [difference + candy, candy]",
                "codeTag": "Java"
            },
            {
                "id": 174893,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        //\\n        // Note that the problem statement says that Alice and Bob need to exchange one candy each, no more or no less.\\n        //\\n        // Assume x needs to be removed and y needs to be added to A to equalize, so:\\n        //  Sum(A) - x + y = Sum(B) - y + x\\n        //  therefore, Sum(A) - Sum(B) = -2y + 2x\\n        //  therefore, x = ((Sum(A) - Sum(B)) / 2) + y\\n        //  lets call ((Sum(A) - Sum(B)) / 2), delta\\n        //\\n        \\n        int sumA = 0;\\n        int sumB = 0;\\n        \\n        for (auto e : A)\\n            sumA += e;\\n        \\n        for (auto e : B)\\n            sumB += e;\\n        \\n        int delta = (sumA - sumB) / 2;\\n        \\n        set<int> searchA;\\n        for (auto x : A)\\n        {\\n            //cout << x << endl;\\n            searchA.insert(x);\\n        }\\n        \\n        \\n        //cout << endl;\\n        for (auto y : B)    \\n        {\\n            //cout << y << setw(5) << delta + y << endl;\\n            if (searchA.count(delta + y) > 0)\\n            {\\n                return vector<int>{delta + y, y};\\n            }\\n        }\\n        \\n        return vector<int>();\\n    }",
                "solutionTags": [],
                "code": "    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        //\\n        // Note that the problem statement says that Alice and Bob need to exchange one candy each, no more or no less.\\n        //\\n        // Assume x needs to be removed and y needs to be added to A to equalize, so:\\n        //  Sum(A) - x + y = Sum(B) - y + x\\n        //  therefore, Sum(A) - Sum(B) = -2y + 2x\\n        //  therefore, x = ((Sum(A) - Sum(B)) / 2) + y\\n        //  lets call ((Sum(A) - Sum(B)) / 2), delta\\n        //\\n        \\n        int sumA = 0;\\n        int sumB = 0;\\n        \\n        for (auto e : A)\\n            sumA += e;\\n        \\n        for (auto e : B)\\n            sumB += e;\\n        \\n        int delta = (sumA - sumB) / 2;\\n        \\n        set<int> searchA;\\n        for (auto x : A)\\n        {\\n            //cout << x << endl;\\n            searchA.insert(x);\\n        }\\n        \\n        \\n        //cout << endl;\\n        for (auto y : B)    \\n        {\\n            //cout << y << setw(5) << delta + y << endl;\\n            if (searchA.count(delta + y) > 0)\\n            {\\n                return vector<int>{delta + y, y};\\n            }\\n        }\\n        \\n        return vector<int>();\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2727134,
                "title": "c-5-different-approaches-brute-force-hash-set-bitset-binary-search-two-pointers",
                "content": "Please let me know if you have suggestions for an other approach or how to improve one of the approaches below.\\n\\n## Intuition\\n\\nIf Alice has a total of $$a$$ candies and Bob has a total of $$b$$ candies, then the target both need to hit is $$\\\\frac{a + b}{2}$$. Let\\'s assume $$a > b$$, then Alices needs to end up with $$d = \\\\frac{a - b}{2}$$ fewer canides than she has now, and likewise Bob needs $$d$$ more.  If Alices gives $$x$$ candies to Bob, then Bob needs to give Alice $$y = x - d$$ candies back, so that both hit the target number.  The question is now what is $$x$$ and $$y$$? Or stated differently if we pick a candy box from Alice with size $$x$$, does Bob have a candy box of size $$y$$?\\n\\n## Approach 1: brute force (572ms)\\n\\nIt was a bit surprising that this approach is still fast enough to pass.\\n\\n```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, const vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        // assert((sum_a - sum_b) % 2 == 0);\\n        const int diff = (sum_a - sum_b) / 2;\\n        for (int a : A)\\n            for (int b : B)\\n                if (a - b == diff) return {a, b};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\\n\\nNote that instead of ```std::reduce``` ```std::accumulate``` could have been used as well.\\n\\n**Complexity Analysis**\\nLet $$m$$ be the number of candy boxes Alice has (```size(A)```) and $$n$$ be the number of candy boxes Bob has (```size(B)```) then the\\n  * Time complexity is $$O(m * n)$$ as we are looping over all combinations, and the\\n  * Space complexity is $$O(1)$$ quite obviously.\\n\\n## afterthought\\n\\nI was trying to make this approach TLE by generating test cases with the following code:\\n\\n```py\\ndef gen(n):\\n  print(str([2 for i in range(n)] + [5]).replace(\", \", \",\"))\\n  print(str([2 for i in range(n - 1)] + [3]).replace(\", \", \",\"))\\n```\\n\\nThis yields test cases like this:\\n\\n```text\\n>>> gen(10)\\n[2,2,2,2,2,2,2,2,2,2,5]\\n[2,2,2,2,2,2,2,2,2,3]\\n```\\n\\nThe answer for a test case like this is always ```[5,3]```, but even a test case generated with ```gen(9999)``` which is the longest possible test case still passes.\\n\\n## Approach 2: hash set (99ms)\\n\\nInstead of linear scan over all of Bob\\'s candy boxes for each of Alice\\'s boxes, we can create an index using a hash set.\\n\\n```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, const vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n        \\n        const unordered_set<int> B_set(begin(B), end(B));\\n        \\n        for (int a : A)\\n            if (B_set.count(a - diff)) return {a, a - diff};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$m$$ be the number of candy boxes Alice has (```size(A)```) and $$n$$ be the number of candy boxes Bob has (```size(B)```) then the\\n  * Time complexity is $$O(m)$$ as we need to lookup for each of Alice\\'s boxes in $$O(1)$$ time of Bob has a matching box, and we need $$O(n)$$ for building the hash set, so that\\'s a total of $$O(m + n)$$, and the\\n  * Space complexity is $$O(n)$$ for creating the index of Bob\\'s boxes.\\n\\n## Approch 3: bitset (79 ms)\\n\\nThis input range is limited enough that we can use a ```bitset<>``` instead of a hash set, and this seems to perform also better than the hashset.\\n\\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n\\n        bitset<128 * 1024> B_set;\\n        for (int b : B) B_set.set(b);\\n\\n        for (int a : A) {\\n            const int b = a - diff;\\n            if (b > 0 && b < size(B_set) && B_set[b]) return {a, b};\\n        }\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\\n\\n**Complexity Analysis**\\nAs above $$m$$ is ```size(A)``` and $$n$$ is ```size(B)``` then the\\n  * Time complexity is $$O(m + n)$$ as we need to scan boths inputs and the rest is linear, and the\\n  * Space complexity is $$O(1)$$ albeit its a very big 1 as we need 16k for the bitset.\\n\\n## Approach 4: sort and binary search (69ms)\\n\\nInstead of using a hash set as an index we can also sort Bob\\'s boxes and use binary search.\\n\\n```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n        \\n        sort(begin(B), end(B));\\n        \\n        for (int a : A)\\n            if (binary_search(begin(B), end(B), a - diff)) return {a, a - diff};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\\n\\n**Complexity Analysis**\\nAs above $$m$$ is ```size(A)``` and $$n$$ is ```size(B)``` then the\\n  * Time complexity is $$O(m \\\\log n)$$ for the $$m$$ times binary search in an array of lenght $$n$$, and we need $$O(n \\\\log n)$$ to sort Bob\\'s boxes, that\\'s a total of $$O((m + n) \\\\log n)$$\\n  * Space complexity is $$O(1)$$ assuming we can sort ```B``` in place.\\n\\nThis seems to be again an example where the constant factors in the complexity analysis matter. While approach 2 has better asymptotic runtime of this seems to be faster.\\n\\n## Approach 5: two pointers (101ms)\\n\\nThis is based on a [post](https://leetcode.com/problems/fair-candy-swap/discuss/264171/Python-two-pointers) by @iamhehe.\\n\\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n\\n        sort(begin(A), end(A));\\n        sort(begin(B), end(B));\\n        \\n        for (int i = 0, j = 0; i < size(A) && j < size(B); ) {\\n            const int d = A[i] - B[j];\\n            if (d == diff) return {A[i], B[j]};\\n\\n            if (d < diff) {\\n                ++i;\\n            } else {\\n                ++j;\\n            }\\n        }\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\\n\\n**Complexity Analysis**\\nAs above $$m$$ is ```size(A)``` and $$n$$ is ```size(B)``` then the\\n  * Time complexity is $$O(m \\\\log m + n \\\\log n + n + m)$$ for sorting the two arrays and then the search with two pointers that touches each element at most once, and the\\n  * Space complexity is $$O(1)$$.\\n\\nThis result makes me wonder if this is just another testiment for the poor performance of the hash set / hash map implemention in the standard library.\\n\\n\\n## Appendix\\n\\nFor some approaches it would be beneficial to sort or index the smaller or larger array. To accompblish this we could add the following code at the beginning of these approaches:\\n\\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        if (size(B) > size(A)) {\\n            vector<int> tmp = fairCandySwap(B, A);\\n            return {tmp[1], tmp[0]};\\n        }\\n        assert(size(B) <= size(A));\\n\\n        // Here goes the remaining code ...\\n    }\\n```\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, const vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        // assert((sum_a - sum_b) % 2 == 0);\\n        const int diff = (sum_a - sum_b) / 2;\\n        for (int a : A)\\n            for (int b : B)\\n                if (a - b == diff) return {a, b};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\n```std::reduce```\n```std::accumulate```\n```size(A)```\n```size(B)```\n```py\\ndef gen(n):\\n  print(str([2 for i in range(n)] + [5]).replace(\", \", \",\"))\\n  print(str([2 for i in range(n - 1)] + [3]).replace(\", \", \",\"))\\n```\n```text\\n>>> gen(10)\\n[2,2,2,2,2,2,2,2,2,2,5]\\n[2,2,2,2,2,2,2,2,2,3]\\n```\n```[5,3]```\n```gen(9999)```\n```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, const vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n        \\n        const unordered_set<int> B_set(begin(B), end(B));\\n        \\n        for (int a : A)\\n            if (B_set.count(a - diff)) return {a, a - diff};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\n```size(A)```\n```size(B)```\n```bitset<>```\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n\\n        bitset<128 * 1024> B_set;\\n        for (int b : B) B_set.set(b);\\n\\n        for (int a : A) {\\n            const int b = a - diff;\\n            if (b > 0 && b < size(B_set) && B_set[b]) return {a, b};\\n        }\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\n```size(A)```\n```size(B)```\n```cpp\\n    static vector<int> fairCandySwap(const vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n        \\n        sort(begin(B), end(B));\\n        \\n        for (int a : A)\\n            if (binary_search(begin(B), end(B), a - diff)) return {a, a - diff};\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\n```size(A)```\n```size(B)```\n```B```\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        const int sum_a = reduce(begin(A), end(A));\\n        const int sum_b = reduce(begin(B), end(B));\\n        const int diff = (sum_a - sum_b) / 2;\\n\\n        sort(begin(A), end(A));\\n        sort(begin(B), end(B));\\n        \\n        for (int i = 0, j = 0; i < size(A) && j < size(B); ) {\\n            const int d = A[i] - B[j];\\n            if (d == diff) return {A[i], B[j]};\\n\\n            if (d < diff) {\\n                ++i;\\n            } else {\\n                ++j;\\n            }\\n        }\\n        \\n        // Unreachable, as the problem is guaranteed to have a solution.\\n        assert(false);\\n        return {-1, -1};\\n    }\\n```\n```size(A)```\n```size(B)```\n```cpp\\n    static vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        if (size(B) > size(A)) {\\n            vector<int> tmp = fairCandySwap(B, A);\\n            return {tmp[1], tmp[0]};\\n        }\\n        assert(size(B) <= size(A));\\n\\n        // Here goes the remaining code ...\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 264171,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        a,b=sum(A),sum(B)\\n        diff=(a-b)//2\\n        i,j=0,0\\n        A.sort()\\n        B.sort()\\n        while i<len(A) and j<len(B):\\n            temp = A[i]-B[j]\\n            if temp == diff:\\n                return [A[i],B[j]]\\n            elif temp<diff:\\n                i+=1\\n            else:\\n                j+=1\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        a,b=sum(A),sum(B)\\n        diff=(a-b)//2\\n        i,j=0,0\\n        A.sort()\\n        B.sort()\\n        while i<len(A) and j<len(B):\\n            temp = A[i]-B[j]\\n            if temp == diff:\\n                return [A[i],B[j]]\\n            elif temp<diff:\\n                i+=1\\n            else:\\n                j+=1\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888042,
                "title": "math-behind-lee215-s-solution",
                "content": "Assume that alice has sizes $[x_1, x_2, ..., x_m]$, while bob has sizes $[y_1, y_2, ..., y_n]$. Also, we are going to switch $x_a$ and $y_b$ so that they will have some size total at the end. Then, we have\\n\\n$$\\\\sum_{i=1}^nx_i - x_a + y_b = \\\\sum_{j=1}^my_j - y_b + x_a$$\\n\\nwhich can be rewritten as \\n\\n$$\\\\sum_{i=1}^nx_i - \\\\sum_{j=1}^my_j =  2x_a - 2y_b $$\\n\\nwhich is\\n\\n$$diff = \\\\frac{\\\\sum_{i=1}^nx_i - \\\\sum_{j=1}^my_j}{2} =  x_a - y_b $$\\n\\nTherefore, if `diff + bob_size` is in `aliceSizes`, we know that we find the result. \\n\\nHope this helps.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        delta = (sum(aliceSizes) - sum(bobSizes)) // 2\\n        aliceSizes = set(aliceSizes)\\n        for size in set(bobSizes):\\n            if delta + size in aliceSizes:\\n                return [delta + size, size]\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        delta = (sum(aliceSizes) - sum(bobSizes)) // 2\\n        aliceSizes = set(aliceSizes)\\n        for size in set(bobSizes):\\n            if delta + size in aliceSizes:\\n                return [delta + size, size]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571182,
                "title": "python-c-java-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q888. Fair Candy Swap***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff=(sum(A)-sum(B))//2;\\n        A=set(A)\\n        for i in set(B):\\n            if i+diff in A:\\n                return [diff+i,i]\\n```\\n**Runtime:**  915 ms\\t\\n**Memory Usage:**  16.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sa=0,sb=0;\\n        for(int i=0;i<A.length;i++)\\n            sa+=A[i];\\n        for(int i=0;i<B.length;i++)\\n            sb+=B[i];\\n        int diff=(sa-sb)/2;\\n        for(int i=0;i<A.length;i++)\\n            for(int j=0;j<B.length;j++)\\n                if(A[i]-B[j]==diff)\\n                    return new int[]{A[i],B[j]};\\n        return null;\\n    }\\n}\\n```\\n**Runtime:**  408 ms\\t\\t\\n**Memory Usage:**  43.8 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int>ans;\\n        int asum=0,bsum=0;\\n        for(auto x:aliceSizes)\\n            asum+=x;\\n        for(auto x:bobSizes)\\n            bsum+=x;\\n        int diff=(bsum-asum)/2;\\n        unordered_set<int> s(bobSizes.begin(),bobSizes.end());\\n        \\n        for(auto x : aliceSizes)\\n        {\\n              if(s.find(x + diff) != s.end())\\n              {\\n                  ans.push_back(x);\\n                  ans.push_back(x+diff);\\n                  break;\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Runtime:** 96 ms\\t\\n**Memory Usage:**  47.3 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff=(sum(A)-sum(B))//2;\\n        A=set(A)\\n        for i in set(B):\\n            if i+diff in A:\\n                return [diff+i,i]\\n```\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sa=0,sb=0;\\n        for(int i=0;i<A.length;i++)\\n            sa+=A[i];\\n        for(int i=0;i<B.length;i++)\\n            sb+=B[i];\\n        int diff=(sa-sb)/2;\\n        for(int i=0;i<A.length;i++)\\n            for(int j=0;j<B.length;j++)\\n                if(A[i]-B[j]==diff)\\n                    return new int[]{A[i],B[j]};\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int>ans;\\n        int asum=0,bsum=0;\\n        for(auto x:aliceSizes)\\n            asum+=x;\\n        for(auto x:bobSizes)\\n            bsum+=x;\\n        int diff=(bsum-asum)/2;\\n        unordered_set<int> s(bobSizes.begin(),bobSizes.end());\\n        \\n        for(auto x : aliceSizes)\\n        {\\n              if(s.find(x + diff) != s.end())\\n              {\\n                  ans.push_back(x);\\n                  ans.push_back(x+diff);\\n                  break;\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512064,
                "title": "javascript-solution-using-set",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @return {number[]}\\n */\\nvar fairCandySwap = function(A, B) {\\n  const sumA = A.reduce((acc, cur) => acc + cur);\\n  const sumB = B.reduce((acc, cur) => acc + cur);\\n  const diff = (sumA - sumB) >> 1;\\n  const setA = new Set(A);\\n  for (const candy of B) {\\n    if (setA.has(candy + diff)) return [candy + diff, candy];\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @return {number[]}\\n */\\nvar fairCandySwap = function(A, B) {\\n  const sumA = A.reduce((acc, cur) => acc + cur);\\n  const sumB = B.reduce((acc, cur) => acc + cur);\\n  const diff = (sumA - sumB) >> 1;\\n  const setA = new Set(A);\\n  for (const candy of B) {\\n    if (setA.has(candy + diff)) return [candy + diff, candy];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161309,
                "title": "python-solution-using-set-similar-to-twosum-concept",
                "content": "If we know the final same total amount ```total```, \\nwe can pick any element ```a``` in A  and check if **the rest in A** + **any element ```b``` in B** == **total**.\\nThat is, the rest of candy left in A = sum(A) - element in A\\npossible B = total - (the rest of candy left in A)\\n```python\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        sumA, sumB  = sum(A), sum(B)\\n        setA, setB = set(A), set(B)\\n        total = (sumA + sumB) // 2 # the final same total amount\\n        \\n        for i in setA:\\n            if total - (sumA - i) in setB:\\n                return [i, total - (sumA - i)]\\n```",
                "solutionTags": [],
                "code": "```total```\n```a```\n```b```\n```python\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        sumA, sumB  = sum(A), sum(B)\\n        setA, setB = set(A), set(B)\\n        total = (sumA + sumB) // 2 # the final same total amount\\n        \\n        for i in setA:\\n            if total - (sumA - i) in setB:\\n                return [i, total - (sumA - i)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229888,
                "title": "c-set-solution-with-explanation",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n\\t\\t\\tint sA = 0; // sA is the sum of the sizes of Alice\\'s candy bars\\n\\t\\t\\tint sB = 0; // sB is the sum of the sizes of Bob\\'s candy bars\\n\\t\\t\\tfor(int i = 0; i < aliceSizes.size(); i++){\\n\\t\\t\\t\\tsA += aliceSizes[i];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < bobSizes.size(); i++){\\n\\t\\t\\t\\tsB += bobSizes[i];\\n\\t\\t\\t}\\n\\t\\t\\t// Let x =  Size of a candy bar exchanged by Alice\\n\\t\\t\\t// Let y = Size of a candy bar exchanged by Bob\\n\\t\\t\\t// sA - x + y = sB - y + x \\n\\t\\t\\t// (sA - sB) / 2 = x - y;\\n\\n\\t\\t\\t// So, our target is to find a candy bar pair whose whose difference is (sA - sB) / 2 \\n\\t\\t\\tint d = (sA - sB) / 2;\\n\\n\\t\\t\\t// We want to find if any aliceSizes[i] = bobSizes[j] + d\\n\\t\\t\\tset<int> bob;\\n\\t\\t\\tfor(int i = 0; i < bobSizes.size(); i++){\\n\\t\\t\\t\\tbob.insert(bobSizes[i] + d);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < aliceSizes.size(); i++){\\n\\t\\t\\t\\tif(bob.find(aliceSizes[i]) != bob.end()){    \\n\\t\\t\\t\\t\\treturn {aliceSizes[i], aliceSizes[i] - d};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn {};\\n\\t\\t}\\n\\t};\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n\\t\\t\\tint sA = 0; // sA is the sum of the sizes of Alice\\'s candy bars\\n\\t\\t\\tint sB = 0; // sB is the sum of the sizes of Bob\\'s candy bars\\n\\t\\t\\tfor(int i = 0; i < aliceSizes.size(); i++){\\n\\t\\t\\t\\tsA += aliceSizes[i];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 750626,
                "title": "could-not-think-of-linear-time-solution-used-binary-search-instead",
                "content": "The linear time solution was pretty clever. I could not come up with it in 30-ish minutes. I was surprised that the naive `O(n^2)` solution was accepted. Working from the naive solution, I was able to get down to linearithmic runtime.\\n\\nLet `B = |B|` and `A = |A|`, `O(Blog(B) + Alog(B))` solution:\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int nA = A.size();\\n        int nB = B.size();\\n        // could help to sort the smaller of the two lists\\n        sort(B.begin(), B.end());\\n        \\n        int sumA = 0;\\n        int sumB = 0;\\n        \\n        for (int v : A)\\n            sumA += v;\\n        \\n        for (int v : B)\\n            sumB += v;\\n        \\n        for (int i = 0; i < nA; ++i) {\\n            int aliceBar = A[i];\\n            \\n            int ii = 0;\\n            int j = nB - 1;\\n            // find the element that will make the two sums\\n\\t\\t\\t// the same\\n            while (ii <= j) {\\n                int m = ii + (j-ii)/2;\\n                int bobBar = B[m];\\n                \\n                int resA = sumA - aliceBar + bobBar;\\n                int resB = sumB - bobBar + aliceBar;\\n                \\n                if (resA == resB) // both sums are the same!\\n                    return { aliceBar, bobBar };\\n                else if (resA > resB) {\\n\\t\\t\\t\\t\\t// if \\'swapping\\' something from B leads to a larger sum for A\\n\\t\\t\\t\\t\\t// then we should try to \\'swap\\' something smaller\\n                    j = m - 1;\\n                } else {\\n\\t\\t\\t\\t\\t// if \\'swapping\\' something from B leads to a smaller sum for A\\n\\t\\t\\t\\t\\t// then we should try to swap something bigger\\n                    ii = m + 1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int nA = A.size();\\n        int nB = B.size();\\n        // could help to sort the smaller of the two lists\\n        sort(B.begin(), B.end());\\n        \\n        int sumA = 0;\\n        int sumB = 0;\\n        \\n        for (int v : A)\\n            sumA += v;\\n        \\n        for (int v : B)\\n            sumB += v;\\n        \\n        for (int i = 0; i < nA; ++i) {\\n            int aliceBar = A[i];\\n            \\n            int ii = 0;\\n            int j = nB - 1;\\n            // find the element that will make the two sums\\n\\t\\t\\t// the same\\n            while (ii <= j) {\\n                int m = ii + (j-ii)/2;\\n                int bobBar = B[m];\\n                \\n                int resA = sumA - aliceBar + bobBar;\\n                int resB = sumB - bobBar + aliceBar;\\n                \\n                if (resA == resB) // both sums are the same!\\n                    return { aliceBar, bobBar };\\n                else if (resA > resB) {\\n\\t\\t\\t\\t\\t// if \\'swapping\\' something from B leads to a larger sum for A\\n\\t\\t\\t\\t\\t// then we should try to \\'swap\\' something smaller\\n                    j = m - 1;\\n                } else {\\n\\t\\t\\t\\t\\t// if \\'swapping\\' something from B leads to a smaller sum for A\\n\\t\\t\\t\\t\\t// then we should try to swap something bigger\\n                    ii = m + 1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929167,
                "title": "python3-with-explanation",
                "content": "sum(alice)-i+j=sum(bob)-j+i\\n        diff=2(i-j)\\n        diff/2=(i-j)\\n        diff/2+j=i\\n        j=i-diff/2\\n```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        total_alice=sum(aliceSizes)\\n        total_bob=sum(bobSizes)\\n        diff=(total_alice-total_bob)//2\\n        \\n        for i in set(aliceSizes):\\n            if i-diff in set(bobSizes):\\n                return [i,i-diff]\\n            \\n\\n\\t\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        total_alice=sum(aliceSizes)\\n        total_bob=sum(bobSizes)\\n        diff=(total_alice-total_bob)//2\\n        \\n        for i in set(aliceSizes):\\n            if i-diff in set(bobSizes):\\n                return [i,i-diff]\\n            \\n\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1641633,
                "title": "python-binary-search-with-explanation",
                "content": "* This is the first time I posted my solution, and I am a beginner in algorism, hope this simple solution can give you some help. \\n* Please feel free to comment, hope to learn more from you!\\n```\\nclass Solution(object):\\n    def fairCandySwap(self, aliceSizes, bobSizes):\\n        \"\"\"\\n        :type aliceSizes: List[int]\\n        :type bobSizes: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\t\\t# Calculate the total value each list should satisfy\\n        alice, bob = 0, 0\\n        for i in aliceSizes: alice += i\\n        for j in bobSizes: bob += j\\n        each = (alice+bob)/2\\n\\t\\t# Sort each list first to utilize the binary search\\n        aliceSizes.sort()\\n        bobSizes.sort()\\n        for i in range(len(aliceSizes)):\\n            alice_change = aliceSizes[i]\\n            bl, br = 0, len(bobSizes)-1\\n            while bl <= br:\\n                bm = bl + (br-bl)//2\\n                bob_change = bobSizes[bm]\\n                new_alice = alice - alice_change + bob_change\\n                new_bob = bob + alice_change - bob_change\\n\\t\\t\\t\\t# If two list have the same value, then break\\n                if new_alice == new_bob:\\n                    return [alice_change, bob_change]\\n                    break\\n\\t\\t\\t\\t# If new_alice > new_bob, we should choose a larger value for exchanging\\n                elif new_alice > new_bob:\\n                    br = bm - 1\\n\\t\\t\\t\\t# If new_alice < new_bob, we should choose a smaller value for exchanging\\n                elif new_alice < new_bob:\\n                    bl = bm + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def fairCandySwap(self, aliceSizes, bobSizes):\\n        \"\"\"\\n        :type aliceSizes: List[int]\\n        :type bobSizes: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\t\\t# Calculate the total value each list should satisfy\\n        alice, bob = 0, 0\\n        for i in aliceSizes: alice += i\\n        for j in bobSizes: bob += j\\n        each = (alice+bob)/2\\n\\t\\t# Sort each list first to utilize the binary search\\n        aliceSizes.sort()\\n        bobSizes.sort()\\n        for i in range(len(aliceSizes)):\\n            alice_change = aliceSizes[i]\\n            bl, br = 0, len(bobSizes)-1\\n            while bl <= br:\\n                bm = bl + (br-bl)//2\\n                bob_change = bobSizes[bm]\\n                new_alice = alice - alice_change + bob_change\\n                new_bob = bob + alice_change - bob_change\\n\\t\\t\\t\\t# If two list have the same value, then break\\n                if new_alice == new_bob:\\n                    return [alice_change, bob_change]\\n                    break\\n\\t\\t\\t\\t# If new_alice > new_bob, we should choose a larger value for exchanging\\n                elif new_alice > new_bob:\\n                    br = bm - 1\\n\\t\\t\\t\\t# If new_alice < new_bob, we should choose a smaller value for exchanging\\n                elif new_alice < new_bob:\\n                    bl = bm + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687223,
                "title": "java-solution-hash-set-with-explanantion",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        \\n        /*\\n          X is the value from Array A\\n          \\n          Y is the value from Array B\\n          \\n          sumA - sum of values in Array A\\n          \\n          sumB - sum of values in Array B\\n          \\n          We need to find X and Y values that satisfy below conditions\\n          \\n          sumA + Y - X  ==  sumB + X - Y\\n          \\n          sumA + 2Y - sumB = 2X \\n          \\n          X = (sumA - sumB + 2Y)/2\\n          \\n          populate all the values of Array A in a set\\n          \\n          loop through all the values of array B and calculate below formalu and check if the result exists in Array A\\n        \\n        */\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        int sumA = 0;\\n        \\n        int sumB = 0;\\n        \\n        for (int i : A)\\n        {\\n            sumA = sumA + i;\\n            \\n            set.add(i);\\n        }\\n        \\n         for (int i : B)\\n        {\\n            sumB = sumB + i;\\n            \\n        }\\n        \\n        for(int j: B)\\n        {\\n            int temp = (sumA - sumB + 2*j) / 2;\\n            if(set.contains(temp))\\n            {\\n                return new int[]{temp,j};\\n                   \\n               }\\n     \\n        }\\n        \\n        return new int[]{0,0};\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        \\n        /*\\n          X is the value from Array A\\n          \\n          Y is the value from Array B\\n          \\n          sumA - sum of values in Array A\\n          \\n          sumB - sum of values in Array B\\n          \\n          We need to find X and Y values that satisfy below conditions\\n          \\n          sumA + Y - X  ==  sumB + X - Y\\n          \\n          sumA + 2Y - sumB = 2X \\n          \\n          X = (sumA - sumB + 2Y)/2\\n          \\n          populate all the values of Array A in a set\\n          \\n          loop through all the values of array B and calculate below formalu and check if the result exists in Array A\\n        \\n        */\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        int sumA = 0;\\n        \\n        int sumB = 0;\\n        \\n        for (int i : A)\\n        {\\n            sumA = sumA + i;\\n            \\n            set.add(i);\\n        }\\n        \\n         for (int i : B)\\n        {\\n            sumB = sumB + i;\\n            \\n        }\\n        \\n        for(int j: B)\\n        {\\n            int temp = (sumA - sumB + 2*j) / 2;\\n            if(set.contains(temp))\\n            {\\n                return new int[]{temp,j};\\n                   \\n               }\\n     \\n        }\\n        \\n        return new int[]{0,0};\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652916,
                "title": "cpp-simple-solution-using-set-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int a=0,b=0;\\n        for(int i=0;i<A.size();i++)\\n            a+=A[i];\\n        for(int i=0;i<B.size();i++)\\n            b+=B[i];\\n        a=(b-a)/2;\\n        set<int> s;\\n        for(auto x:A)\\n            s.insert(x+a);\\n        for(auto x:B)\\n        {\\n            if(s.find(x)!=s.end())\\n                return {x-a,x};\\n        }\\n        return {};\\n        \\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int a=0,b=0;\\n        for(int i=0;i<A.size();i++)\\n            a+=A[i];\\n        for(int i=0;i<B.size();i++)\\n            b+=B[i];\\n        a=(b-a)/2;\\n        set<int> s;\\n        for(auto x:A)\\n            s.insert(x+a);\\n        for(auto x:B)\\n        {\\n            if(s.find(x)!=s.end())\\n                return {x-a,x};\\n        }\\n        return {};\\n        \\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259366,
                "title": "java-solution-using-binary-search-with-explanation",
                "content": "Same logic as the solution but use binary search.\\nTakes O(MlogN) time but it\\'s in-place.\\n```\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        Arrays.sort(B);//In order to use binary search\\n        \\n        int sumA=0, sumB=0;\\n        for(int i: A)\\n            sumA+=i;\\n        for(int i: B)\\n            sumB+=i;\\n        int diffOfAns = (sumA-sumB)/2;//Use the equation\\n       \\n        int[] ans = new int[2];//Initailize the answer array\\n        \\n        for(int i=0; i<A.length; i++){\\n        //want to find a number in B that satisfies: ansA - ansB = diffOfAns\\n            //binary search \\n            int left = 0, right = B.length-1;\\n            while(left<=right){\\n                int mid = left+(right-left)/2;\\n                if(B[mid] == A[i]-diffOfAns){\\n                    ans[0]=A[i];\\n                    ans[1]=B[mid];\\n                    return ans;\\n                }\\n                else if(B[mid] > A[i]-diffOfAns){\\n                    right = mid-1;\\n                }\\n                else{\\n                    left = mid+1;   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        Arrays.sort(B);//In order to use binary search\\n        \\n        int sumA=0, sumB=0;\\n        for(int i: A)\\n            sumA+=i;\\n        for(int i: B)\\n            sumB+=i;\\n        int diffOfAns = (sumA-sumB)/2;//Use the equation\\n       \\n        int[] ans = new int[2];//Initailize the answer array\\n        \\n        for(int i=0; i<A.length; i++){\\n        //want to find a number in B that satisfies: ansA - ansB = diffOfAns\\n            //binary search \\n            int left = 0, right = B.length-1;\\n            while(left<=right){\\n                int mid = left+(right-left)/2;\\n                if(B[mid] == A[i]-diffOfAns){\\n                    ans[0]=A[i];\\n                    ans[1]=B[mid];\\n                    return ans;\\n                }\\n                else if(B[mid] > A[i]-diffOfAns){\\n                    right = mid-1;\\n                }\\n                else{\\n                    left = mid+1;   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161305,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        a, diff = set(A), (sum(A) - sum(B)) // 2\\n        for b in B:\\n            if b + diff in a:\\n                return [b + diff, b]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        a, diff = set(A), (sum(A) - sum(B)) // 2\\n        for b in B:\\n            if b + diff in a:\\n                return [b + diff, b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406728,
                "title": "beats-90-sol-with-comments",
                "content": "# **Please Upvote me \\uD83E\\uDD79**\\n\\n# Approach\\nApproach is written in Code with Comments just go through them and pls dry run code once you will get to know the logic , and you will find it pretty simple and straightforward\\n\\n# If Helpful Please Upvote\\uD83E\\uDD79\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n        // Problem is very simple if you think about it with pen and paper\\n        // let us assume\\n        // Sa = sum of alice candies, Sb = sum of bob candies\\n        // acc to question\\n        // Sa - x + y = Sb + x - y\\n        // y = x + (Sb-Sa)/2\\n\\n        // finding the sum of candies that bob and alice have\\n        int sumA = 0;\\n        for(auto &i : alice){\\n            sumA += i;\\n        }\\n\\n        int sumB = 0;\\n        for(auto &i: bob){\\n            sumB += i;\\n        }\\n\\n        int z = (sumB-sumA)/2;\\n\\n        // putting all the elements of bob into the map \\n        unordered_map<int,int>mpp;\\n        for(int i = 0; i<bob.size(); i++){\\n            mpp[bob[i]]++; \\n        }\\n\\n        for(int i = 0; i<alice.size(); i++){\\n            int x = alice[i];\\n            int y = x+z;\\n            if(mpp.find(y) != mpp.end()){\\n                return {x,y};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n        // Problem is very simple if you think about it with pen and paper\\n        // let us assume\\n        // Sa = sum of alice candies, Sb = sum of bob candies\\n        // acc to question\\n        // Sa - x + y = Sb + x - y\\n        // y = x + (Sb-Sa)/2\\n\\n        // finding the sum of candies that bob and alice have\\n        int sumA = 0;\\n        for(auto &i : alice){\\n            sumA += i;\\n        }\\n\\n        int sumB = 0;\\n        for(auto &i: bob){\\n            sumB += i;\\n        }\\n\\n        int z = (sumB-sumA)/2;\\n\\n        // putting all the elements of bob into the map \\n        unordered_map<int,int>mpp;\\n        for(int i = 0; i<bob.size(); i++){\\n            mpp[bob[i]]++; \\n        }\\n\\n        for(int i = 0; i<alice.size(); i++){\\n            int x = alice[i];\\n            int y = x+z;\\n            if(mpp.find(y) != mpp.end()){\\n                return {x,y};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377028,
                "title": "my-accepted-c-code-easy-understanding-bs",
                "content": "```\\nclass Solution {\\npublic:\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n\\n    sort(bobSizes.begin(),bobSizes.end());\\n    sort(aliceSizes.begin(),aliceSizes.end());\\n\\n    int sum1=0;\\n    int sum2=0;\\n    vector <int> ans;\\n    for(int i =0 ; i <aliceSizes.size(); i++)\\n    {\\n        sum1+=aliceSizes[i];\\n    }\\n    for(int i =0 ; i <bobSizes.size(); i++)\\n    {\\n        sum2+=bobSizes[i];\\n    }\\n    \\n    int dif = (sum1-sum2)/2;\\n    \\n    \\n    for(int i = 0 ; i <aliceSizes.size(); i++)\\n    {\\n        \\n        int st=0;\\n        int end = bobSizes.size()-1;\\n        \\n        while(st<=end)\\n        {\\n            int mid = (st+end)/2;\\n            \\n            if(bobSizes[mid]==aliceSizes[i]-dif)\\n            {\\n             ans.push_back(aliceSizes[i]);\\n             ans.push_back(bobSizes[mid]);\\n             return ans;\\n            }\\n            \\n            else if(bobSizes[mid]<aliceSizes[i]-dif)\\n            {\\n                st=mid+1;\\n            }\\n            else if(bobSizes[mid]>aliceSizes[i]-dif)\\n            {\\n                end=mid-1;\\n            }\\n              \\n        }    \\n    }\\n    \\n    return ans;\\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n\\n    sort(bobSizes.begin(),bobSizes.end());\\n    sort(aliceSizes.begin(),aliceSizes.end());\\n\\n    int sum1=0;\\n    int sum2=0;\\n    vector <int> ans;\\n    for(int i =0 ; i <aliceSizes.size(); i++)\\n    {\\n        sum1+=aliceSizes[i];\\n    }\\n    for(int i =0 ; i <bobSizes.size(); i++)\\n    {\\n        sum2+=bobSizes[i];\\n    }\\n    \\n    int dif = (sum1-sum2)/2;\\n    \\n    \\n    for(int i = 0 ; i <aliceSizes.size(); i++)\\n    {\\n        \\n        int st=0;\\n        int end = bobSizes.size()-1;\\n        \\n        while(st<=end)\\n        {\\n            int mid = (st+end)/2;\\n            \\n            if(bobSizes[mid]==aliceSizes[i]-dif)\\n            {\\n             ans.push_back(aliceSizes[i]);\\n             ans.push_back(bobSizes[mid]);\\n             return ans;\\n            }\\n            \\n            else if(bobSizes[mid]<aliceSizes[i]-dif)\\n            {\\n                st=mid+1;\\n            }\\n            else if(bobSizes[mid]>aliceSizes[i]-dif)\\n            {\\n                end=mid-1;\\n            }\\n              \\n        }    \\n    }\\n    \\n    return ans;\\n    \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301988,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sum_a=0,sum_b=0;\\n        for(int i=0;i<A.length;i++)\\n        {\\n            sum_a+=A[i];\\n        }\\n        for(int i=0;i<B.length;i++)\\n        {\\n            sum_b+=B[i];\\n        }\\n        int target=(sum_a-sum_b)/2;\\n        int[] res=new int[2];\\n        for(int i=0;i<A.length;i++)\\n        {\\n            for(int j=0;j<B.length;j++)\\n            {\\n                if(A[i]==B[j]+target)\\n                {\\n                    res[0]=A[i];\\n                    res[1]=B[j];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sum_a=0,sum_b=0;\\n        for(int i=0;i<A.length;i++)\\n        {\\n            sum_a+=A[i];\\n        }\\n        for(int i=0;i<B.length;i++)\\n        {\\n            sum_b+=B[i];\\n        }\\n        int target=(sum_a-sum_b)/2;\\n        int[] res=new int[2];\\n        for(int i=0;i<A.length;i++)\\n        {\\n            for(int j=0;j<B.length;j++)\\n            {\\n                if(A[i]==B[j]+target)\\n                {\\n                    res[0]=A[i];\\n                    res[1]=B[j];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815011,
                "title": "python-simple-math-solution",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        sum_A = sum(A)\\n        sum_B = sum(B)\\n\\t\\t# we go over the candies in A and check if there is a candy in B to swap so the sums should be equal\\n        for candy in A:\\n            if candy + (sum_B - sum_A) / 2 in B:\\n                return [candy, candy + (sum_B - sum_A) / 2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        sum_A = sum(A)\\n        sum_B = sum(B)\\n\\t\\t# we go over the candies in A and check if there is a candy in B to swap so the sums should be equal\\n        for candy in A:\\n            if candy + (sum_B - sum_A) / 2 in B:\\n                return [candy, candy + (sum_B - sum_A) / 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252033,
                "title": "simple-python-with-explanation-beats-100",
                "content": "The average of both sums will be the  total amount that both of them will have at the end. This means if we have to add some value reqA to A, the same value reqA will be subtracted from B and vice versa. \\nWe add that required value (reqA) to an element of A (a) and if that exists in B we have our answer.\\nHere, suppose that required value is reqA (reqA =  finalTotal - sumA ) therefore if b exists such that b = a + reqA, then (b - reqA = a ), exists as well, thus we don\\'t need to check if B follows the given criteria. Only checking if a+ reqA is present in B is enough.\\n\\n```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sumb = sum(B)\\n        suma = sum(A)\\n        \\n        finalTotal = (suma+sumb)/2\\n        reqA = finalTotal - suma \\n      \\n        setB = set(B)\\n        \\n        for a in A:\\n            if a+reqA in setB :\\n                return a,a+reqA\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "The average of both sums will be the  total amount that both of them will have at the end. This means if we have to add some value reqA to A, the same value reqA will be subtracted from B and vice versa. \\nWe add that required value (reqA) to an element of A (a) and if that exists in B we have our answer.\\nHere, suppose that required value is reqA (reqA =  finalTotal - sumA ) therefore if b exists such that b = a + reqA, then (b - reqA = a ), exists as well, thus we don\\'t need to check if B follows the given criteria. Only checking if a+ reqA is present in B is enough.\\n\\n```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sumb = sum(B)\\n        suma = sum(A)\\n        \\n        finalTotal = (suma+sumb)/2\\n        reqA = finalTotal - suma \\n      \\n        setB = set(B)\\n        \\n        for a in A:\\n            if a+reqA in setB :\\n                return a,a+reqA\\n\\t\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 175595,
                "title": "python-simple-and-quick-solution-without-loop",
                "content": "```Python\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = (sum(A) - sum(B)) // 2\\n        A = list(map(lambda a: a - n, A))\\n        b = (list(set(A) & set(B)))[0]\\n        return [b + n, b]\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = (sum(A) - sum(B)) // 2\\n        A = list(map(lambda a: a - n, A))\\n        b = (list(set(A) & set(B)))[0]\\n        return [b + n, b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341418,
                "title": "c-easiest-explanation-ever",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sum1 = accumulate(aliceSizes.begin(), aliceSizes.end(), 0); // total number of candies Alice has\\n        int sum2 = accumulate(bobSizes.begin(), bobSizes.end(), 0); // total number of candies Bob has\\n\\n        int diff = (sum2 - sum1) / 2; // the difference that needs to be balanced between Alice and Bob\\n        \\n        set<int> s; // using a set to keep track of the candies that Bob has\\n        \\n        for (auto b : bobSizes) {\\n            s.insert(b);\\n        }\\n        \\n        for (auto a : aliceSizes) {\\n            int b = a + diff; // Bob needs to give this many candies to Alice to balance the total candy count\\n            if (s.count(b)) { // if Bob has this many candies\\n                return {a, b}; // return the boxes that need to be exchanged\\n            }\\n        }\\n        \\n        return {}; // this line will not be executed as at least one solution is guaranteed\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sum1 = accumulate(aliceSizes.begin(), aliceSizes.end(), 0); // total number of candies Alice has\\n        int sum2 = accumulate(bobSizes.begin(), bobSizes.end(), 0); // total number of candies Bob has\\n\\n        int diff = (sum2 - sum1) / 2; // the difference that needs to be balanced between Alice and Bob\\n        \\n        set<int> s; // using a set to keep track of the candies that Bob has\\n        \\n        for (auto b : bobSizes) {\\n            s.insert(b);\\n        }\\n        \\n        for (auto a : aliceSizes) {\\n            int b = a + diff; // Bob needs to give this many candies to Alice to balance the total candy count\\n            if (s.count(b)) { // if Bob has this many candies\\n                return {a, b}; // return the boxes that need to be exchanged\\n            }\\n        }\\n        \\n        return {}; // this line will not be executed as at least one solution is guaranteed\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811880,
                "title": "java-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsed Divide and Conquer approach with two for loop to iterate over each element of the arrays.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed an Optimized approach using the divide and conquer technique with Hashset to reduce the iteration Cost of the element of the array. \\n# Complexity\\n- Time complexity: $$O(n)$$ ( n = Maximum of arr1.length and arr2.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] arr1, int[] arr2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for(int i=0;i<arr1.length;i++){\\n            sum1+=arr1[i];\\n        }\\n        for(int i=0;i<arr2.length;i++){\\n            sum2+=arr2[i];\\n        }\\n        int mid = ( sum1 - sum2 ) / 2;\\n        Set<Integer> s2 = new HashSet<>();\\n\\n        for(int i=0;i<arr2.length;i++){\\n            s2.add(arr2[i]);\\n        }\\n\\n        for(int v : arr1){\\n            if( s2.contains(v-mid)){\\n                return new int[] {v,v-mid};\\n            }\\n        }\\n        return new int[] {0,0};\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] arr1, int[] arr2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for(int i=0;i<arr1.length;i++){\\n            sum1+=arr1[i];\\n        }\\n        for(int i=0;i<arr2.length;i++){\\n            sum2+=arr2[i];\\n        }\\n        int mid = ( sum1 - sum2 ) / 2;\\n        Set<Integer> s2 = new HashSet<>();\\n\\n        for(int i=0;i<arr2.length;i++){\\n            s2.add(arr2[i]);\\n        }\\n\\n        for(int v : arr1){\\n            if( s2.contains(v-mid)){\\n                return new int[] {v,v-mid};\\n            }\\n        }\\n        return new int[] {0,0};\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295343,
                "title": "fair-candy-swap-java",
                "content": "**java O(nlogn)**\\n```\\n  int sumA = 0;\\n        int sumB = 0;\\n        int y;\\n        for(int t: aliceSizes) sumA+=t;\\n        for(int t: bobSizes) sumB+=t;\\n        Arrays.sort(aliceSizes);\\n        \\n        int d = (sumA-sumB)/2;\\n        for(int x:bobSizes){\\n           y =  d+x;\\n           if(bs(aliceSizes, y)){\\n               return new int[]{y,x};\\n               \\n           } \\n        }\\n        return new int[]{};\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n  int sumA = 0;\\n        int sumB = 0;\\n        int y;\\n        for(int t: aliceSizes) sumA+=t;\\n        for(int t: bobSizes) sumB+=t;\\n        Arrays.sort(aliceSizes);\\n        \\n        int d = (sumA-sumB)/2;\\n        for(int x:bobSizes){\\n           y =  d+x;\\n           if(bs(aliceSizes, y)){\\n               return new int[]{y,x};\\n               \\n           } \\n        }\\n        return new int[]{};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731853,
                "title": "clear-explained-approach-java",
                "content": "```\\nBasically we need to equal the sum of these two arrays by swapping one of element from both array,\\nLets\\'s Suppose sum of aliceSizes is SumA and sum of bobSizes is SumB\\nSo we have to do the follow\\n    SumA-x+y = SumB +x-y\\n    \\n    where x is candies given by alice\\n    and y is candies given by bob\\n    \\n    As it is mentioned in question that they both have to excahnge some thing in order to have equal balance , Hence x and y always exists in the ans\\n   **SumA -x +y = SumB +x-y\\n   SumA-SumB = 2x - 2y\\n  (SumA-SumB)/2 = x-y ------------------------- equation 1\\n   ** \\n    Now problem is reduced to finding x and y where they follow eq. 1\\n\\t\\n\\t\\n\\t\\n\\t\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        int sum1 =0;\\n        int sum2 =0;\\n        for(int i : aliceSizes)\\n            sum1+=i;\\n        for(int i : bobSizes)\\n            sum2+= i;\\n        \\n        int diff = (sum1-sum2)/2;\\n        \\n        for(int j = aliceSizes.length -1;j>=0; j--)\\n        {\\n            for(int k = bobSizes.length -1; k>=0; k--)\\n                \\n            {\\n                if(aliceSizes[j]-bobSizes[k] == diff)\\n                    return new int[]{aliceSizes[j],bobSizes[k]};\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    } \\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nBasically we need to equal the sum of these two arrays by swapping one of element from both array,\\nLets\\'s Suppose sum of aliceSizes is SumA and sum of bobSizes is SumB\\nSo we have to do the follow\\n    SumA-x+y = SumB +x-y\\n    \\n    where x is candies given by alice\\n    and y is candies given by bob\\n    \\n    As it is mentioned in question that they both have to excahnge some thing in order to have equal balance , Hence x and y always exists in the ans\\n   **SumA -x +y = SumB +x-y\\n   SumA-SumB = 2x - 2y\\n  (SumA-SumB)/2 = x-y ------------------------- equation 1\\n   ** \\n    Now problem is reduced to finding x and y where they follow eq. 1\\n\\t\\n\\t\\n\\t\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402672,
                "title": "c-smart-version-of-two-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int sum_A = accumulate(begin(A), end(A), 0);\\n        int sum_B = accumulate(begin(B), end(B), 0);\\n        \\n        //According to question\\n        /*\\n            if we choose x from A and y from B\\n            sum_A - x + y = sum_B - y + x\\n            solve it:\\n            2*(y-x) = sum_B-sum_A;\\n            y - x   = (sum_B-sum_A)/2;\\n            \\n            So, if for any candy box \\'x\\' in A, we have candy box\\n            y = (sum_B - sum_A)/2 + x; then we have the answer {x, y}\\n        */\\n        \\n        unordered_set<int> st(begin(B), end(B));\\n        int target = (sum_B - sum_A)/2;\\n        for(int &x : A) {\\n            if(st.count(target+x))\\n                return {x, target+x};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        int sum_A = accumulate(begin(A), end(A), 0);\\n        int sum_B = accumulate(begin(B), end(B), 0);\\n        \\n        //According to question\\n        /*\\n            if we choose x from A and y from B\\n            sum_A - x + y = sum_B - y + x\\n            solve it:\\n            2*(y-x) = sum_B-sum_A;\\n            y - x   = (sum_B-sum_A)/2;\\n            \\n            So, if for any candy box \\'x\\' in A, we have candy box\\n            y = (sum_B - sum_A)/2 + x; then we have the answer {x, y}\\n        */\\n        \\n        unordered_set<int> st(begin(B), end(B));\\n        int target = (sum_B - sum_A)/2;\\n        for(int &x : A) {\\n            if(st.count(target+x))\\n                return {x, target+x};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352714,
                "title": "c-easy-to-understand-o-n-time-complexity",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        int sumA=0,sumB=0;\\n        unordered_set<int> a;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            a.insert(aliceSizes[i]);\\n            sumA+=aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            sumB+=bobSizes[i];\\n        }   \\n        int delta=(sumB-sumA)/2;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            if(a.count(bobSizes[i]-delta))\\n             return {bobSizes[i]-delta,bobSizes[i]};   \\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        int sumA=0,sumB=0;\\n        unordered_set<int> a;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            a.insert(aliceSizes[i]);\\n            sumA+=aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            sumB+=bobSizes[i];\\n        }   \\n        int delta=(sumB-sumA)/2;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            if(a.count(bobSizes[i]-delta))\\n             return {bobSizes[i]-delta,bobSizes[i]};   \\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306780,
                "title": "c-simple-easy-sol-with-explanation-o-n-sol",
                "content": "**Step by Step Approach:**\\n1) Get the sum of Alice\\'s candies & bob\\'s candies. \\n\\t\\t\\tSa = sum of Alice\\n\\t\\t\\tSb = sum of Bob\\n\\t\\t\\t\\n2) Calculate the difference of the sums : say c = Sa - Sb\\n3) Now, In order to make the sums same , let\\'s assume candy of hieght **a** is moved from Alice side & candy of height **b** is moved from bob side. After doing this resultant sum from both side should be equal right!. Now comes simple maths.\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tResultant sum of Alice       =        Resultant sum of Bob\\n\\t\\t\\t\\t\\t\\tSa - a + b           =            Sb - b + a\\n\\t\\t\\t\\t\\t\\tSa - Sb              =              2*(a-b)\\n\\t\\t\\t\\t\\t\\t\\tc                =              2*(a-b)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tor\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tb    =   (2a - c)/2\\n\\n4) So at last it means, if we are iterating on alice array(say a) we just need to find a number(say b) in bob array such     that  above relation satisfies.\\n\\nHope this explanation is simple and understandable!.\\n\\t\\t\\t\\t\\t\\t\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int c=0;\\n        for(int i : aliceSizes)\\n            c += i;\\n        for(int i : bobSizes)\\n            c -= i;\\n\\n        unordered_map<int,int> mp;\\n        for(int i : bobSizes)\\n            mp[i]++;\\n        \\n        for(int i : aliceSizes){\\n            if(mp.find((2*i - c)/2) != mp.end())\\n                return vector<int>({i,(2*i - c)/2});\\n        }\\n        \\n        return vector<int>({-1,-1});\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int c=0;\\n        for(int i : aliceSizes)\\n            c += i;\\n        for(int i : bobSizes)\\n            c -= i;\\n\\n        unordered_map<int,int> mp;\\n        for(int i : bobSizes)\\n            mp[i]++;\\n        \\n        for(int i : aliceSizes){\\n            if(mp.find((2*i - c)/2) != mp.end())\\n                return vector<int>({i,(2*i - c)/2}",
                "codeTag": "Java"
            },
            {
                "id": 1230846,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA = 0;\\n        int sumB = 0;\\n        int[] result = new int[2];\\n        \\n        for (int i=0; i<aliceSizes.length; i++) {\\n            sumA += aliceSizes[i];\\n        }\\n        for (int i=0; i<bobSizes.length; i++) {\\n            sumB += bobSizes[i];\\n        }\\n        \\n        int targetB = (sumA-sumB)/(2);\\n        \\n        for (int i=0; i<aliceSizes.length; i++) {\\n            for (int j=0; j<bobSizes.length; j++) {\\n                if (aliceSizes[i]==bobSizes[j]+targetB) {\\n                    result[0] = aliceSizes[i];\\n                    result[1] = bobSizes[j];\\n                    return result;\\n                }\\n            }    \\n        }\\n        return result;\\n    }\\n}\\n//Time: O(M*N)\\n//Space: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA = 0;\\n        int sumB = 0;\\n        int[] result = new int[2];\\n        \\n        for (int i=0; i<aliceSizes.length; i++) {\\n            sumA += aliceSizes[i];\\n        }\\n        for (int i=0; i<bobSizes.length; i++) {\\n            sumB += bobSizes[i];\\n        }\\n        \\n        int targetB = (sumA-sumB)/(2);\\n        \\n        for (int i=0; i<aliceSizes.length; i++) {\\n            for (int j=0; j<bobSizes.length; j++) {\\n                if (aliceSizes[i]==bobSizes[j]+targetB) {\\n                    result[0] = aliceSizes[i];\\n                    result[1] = bobSizes[j];\\n                    return result;\\n                }\\n            }    \\n        }\\n        return result;\\n    }\\n}\\n//Time: O(M*N)\\n//Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427002,
                "title": "python-6-lines-beats97-100-in-o-n",
                "content": "```python\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        sum1,sum2 = sum(A) , sum(B)\\n        B = set(B)\\n        for one in A:\\n            temp = int((sum2+2*one-sum1 )/2)\\n            if temp in B:\\n                return [one,temp]\\n```\\nafter swap:\\nsum1 + temp - one == sum2 - temp + one\\nso :\\ntemp = int((sum2+2*one-sum1 )/2)\\n\\n\\n**if it helps you , Please give me a vote star\\nThanks**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        sum1,sum2 = sum(A) , sum(B)\\n        B = set(B)\\n        for one in A:\\n            temp = int((sum2+2*one-sum1 )/2)\\n            if temp in B:\\n                return [one,temp]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410592,
                "title": "javascript-solution",
                "content": "var fairCandySwap = function(A, B) {\\n    let aliceArr = A;\\n    let bobArr = B;\\n    let aliceSize = 0;\\n    let bobSize = 0;\\n    let swap = [];\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        aliceSize += aliceArr[i];\\n    }\\n    \\n    for (let i = 0; i < bobArr.length; i++) {\\n        bobSize += bobArr[i];\\n    }\\n    \\n    let difference = aliceSize - bobSize;\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        for (let j = 0; j < bobArr.length; j++) {\\n            if ((aliceArr[i] - bobArr[j]) === (difference/2)) {\\n                swap.push(aliceArr[i], bobArr[j]);\\n                return swap;\\n            }\\n        }\\n    }\\n    \\n    return swap;\\n};\\n\\nalternative way ---> \\n___________________________________________________________\\n\\nvar fairCandySwap = function(A, B) {\\n    let aliceArr = A;\\n    let bobArr = B;\\n    let aliceSize = 0;\\n    let bobSize = 0;\\n    let swap = [];\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        aliceSize += aliceArr[i];\\n    }\\n    \\n    for (let i = 0; i < bobArr.length; i++) {\\n        bobSize += bobArr[i];\\n    }\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        for (let j = 0; j < bobArr.length; j++) {\\n            if ((aliceSize - aliceArr[i] + bobArr[j]) === bobSize - bobArr[j] + aliceArr[i]) {\\n                swap.push(aliceArr[i], bobArr[j]);\\n                return swap;\\n            }\\n        }\\n    }\\n    \\n    return swap;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var fairCandySwap = function(A, B) {\\n    let aliceArr = A;\\n    let bobArr = B;\\n    let aliceSize = 0;\\n    let bobSize = 0;\\n    let swap = [];\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        aliceSize += aliceArr[i];\\n    }\\n    \\n    for (let i = 0; i < bobArr.length; i++) {\\n        bobSize += bobArr[i];\\n    }\\n    \\n    let difference = aliceSize - bobSize;\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        for (let j = 0; j < bobArr.length; j++) {\\n            if ((aliceArr[i] - bobArr[j]) === (difference/2)) {\\n                swap.push(aliceArr[i], bobArr[j]);\\n                return swap;\\n            }\\n        }\\n    }\\n    \\n    return swap;\\n};\\n\\nalternative way ---> \\n___________________________________________________________\\n\\nvar fairCandySwap = function(A, B) {\\n    let aliceArr = A;\\n    let bobArr = B;\\n    let aliceSize = 0;\\n    let bobSize = 0;\\n    let swap = [];\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        aliceSize += aliceArr[i];\\n    }\\n    \\n    for (let i = 0; i < bobArr.length; i++) {\\n        bobSize += bobArr[i];\\n    }\\n    \\n    for (let i = 0; i < aliceArr.length; i++) {\\n        for (let j = 0; j < bobArr.length; j++) {\\n            if ((aliceSize - aliceArr[i] + bobArr[j]) === bobSize - bobArr[j] + aliceArr[i]) {\\n                swap.push(aliceArr[i], bobArr[j]);\\n                return swap;\\n            }\\n        }\\n    }\\n    \\n    return swap;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 205138,
                "title": "c-beat-95",
                "content": "```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B) {\\n            var k = (A.Sum() - B.Sum()) / 2; \\n\\n            var h = new HashSet<int>(A);\\n\\n            foreach (var b in B)\\n                if (h.Contains(k + b)) return new[] { k + b, b };\\n\\t\\t\\t\\t\\n            throw new Exception();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B) {\\n            var k = (A.Sum() - B.Sum()) / 2; \\n\\n            var h = new HashSet<int>(A);\\n\\n            foreach (var b in B)\\n                if (h.Contains(k + b)) return new[] { k + b, b };\\n\\t\\t\\t\\t\\n            throw new Exception();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416276,
                "title": "solution-using-array-and-hash-set-with-explanation",
                "content": "# Intuition\\nNOTE: The question said that there would be multiple right answers for a perticular question.\\n\\nIf Alice is giving some candies(i.e. x) to Bob then in return Alice get some candies(i.e. y) from Bob.  \\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe x and y are the values from the array.\\n\\nFind the total number of candies for each(i.e. sumA, sumB)\\n\\nNow, sumB-sumA will give you the difference(i.e. number of extra candies Bob have)\\n\\nTo make both have the same amount of candies, we have to equally distribute that difference between both, so-\\n\\n            delta= (sumB - sumA) / 2\\n\\nThat means, if Alice gives x candies to Bob then in return Alice receives y= (x+delta) amount of candies from Bob.\\n\\nWhy \"x+delta\"? --> because x = Alice[i] and delta= no. of extra candies that we want to equally distribute.\\n\\nFor better understanding, please go through the code.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        int sumA= 0;\\n        int sumB=0;\\n\\n        for(int i : aliceSizes) {\\n            sumA += i;\\n        }\\n\\n        for(int i : bobSizes) {\\n            sumB += i;\\n        }\\n\\n        int delta= (sumB-sumA)/2;\\n\\n        Set<Integer> setB= new HashSet<>();\\n\\n        for(int i : bobSizes) {\\n            setB.add(i);\\n        }\\n\\n        for(int i : aliceSizes) {\\n            if(setB.contains(i + delta)) {\\n                return new int[] {i, i+delta};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        int sumA= 0;\\n        int sumB=0;\\n\\n        for(int i : aliceSizes) {\\n            sumA += i;\\n        }\\n\\n        for(int i : bobSizes) {\\n            sumB += i;\\n        }\\n\\n        int delta= (sumB-sumA)/2;\\n\\n        Set<Integer> setB= new HashSet<>();\\n\\n        for(int i : bobSizes) {\\n            setB.add(i);\\n        }\\n\\n        for(int i : aliceSizes) {\\n            if(setB.contains(i + delta)) {\\n                return new int[] {i, i+delta};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800158,
                "title": "c-using-hashmap-easy",
                "content": "**UP VOTE**\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int suma=0,sumb=0;\\n        unordered_map<int,int> mp;\\n        for(auto x:aliceSizes)\\n            suma+=x;\\n        for(auto x:bobSizes)\\n            {\\n                sumb+=x;\\n                mp[x]=1;\\n            }\\n        int diff=((suma-sumb)/2);\\n        for(auto x:aliceSizes)\\n        {\\n            if(mp[x-diff]==1)\\n                return {x,x-diff};\\n        }\\n        return {0,0};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int suma=0,sumb=0;\\n        unordered_map<int,int> mp;\\n        for(auto x:aliceSizes)\\n            suma+=x;\\n        for(auto x:bobSizes)\\n            {\\n                sumb+=x;\\n                mp[x]=1;\\n            }\\n        int diff=((suma-sumb)/2);\\n        for(auto x:aliceSizes)\\n        {\\n            if(mp[x-diff]==1)\\n                return {x,x-diff};\\n        }\\n        return {0,0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582008,
                "title": "c-binary-search-sorting",
                "content": "**Code**\\n```\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int> &v, int target){\\n        int l = 0, r = v.size() - 1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(v[mid] == target){\\n                return true;\\n            } else if(v[mid] < target){\\n                l = mid+1;\\n            } else{\\n                r = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> solve(vector<int> &v1, vector<int> &v2, int target){\\n        for(int i = 0; i < v1.size(); ++i){\\n            if(binarySearch(v2, v1[i] + target)){\\n                return {v1[i], v1[i] + target};\\n            }\\n        }\\n        return {};\\n    }\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int aliceSum = 0, bobSum = 0;\\n        for(int i = 0; i < aliceSizes.size(); ++i){\\n            aliceSum = aliceSum + aliceSizes[i];\\n        }\\n        for(int i = 0; i < bobSizes.size(); ++i){\\n            bobSum = bobSum + bobSizes[i];\\n        }\\n        \\n        vector<int> res;\\n        if(aliceSum < bobSum){\\n            sort(bobSizes.begin(), bobSizes.end());\\n            res = solve(aliceSizes, bobSizes, (bobSum - aliceSum) >> 1);\\n        } else{\\n            sort(aliceSizes.begin(), aliceSizes.end());\\n            res = solve(bobSizes, aliceSizes, (aliceSum - bobSum) >> 1);\\n            swap(res[0], res[1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Output**\\n```\\nRuntime: 179 ms, faster than 45.65% of C++ online submissions for Fair Candy Swap.\\nMemory Usage: 39 MB, less than 94.76% of C++ online submissions for Fair Candy Swap.\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int> &v, int target){\\n        int l = 0, r = v.size() - 1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(v[mid] == target){\\n                return true;\\n            } else if(v[mid] < target){\\n                l = mid+1;\\n            } else{\\n                r = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> solve(vector<int> &v1, vector<int> &v2, int target){\\n        for(int i = 0; i < v1.size(); ++i){\\n            if(binarySearch(v2, v1[i] + target)){\\n                return {v1[i], v1[i] + target};\\n            }\\n        }\\n        return {};\\n    }\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int aliceSum = 0, bobSum = 0;\\n        for(int i = 0; i < aliceSizes.size(); ++i){\\n            aliceSum = aliceSum + aliceSizes[i];\\n        }\\n        for(int i = 0; i < bobSizes.size(); ++i){\\n            bobSum = bobSum + bobSizes[i];\\n        }\\n        \\n        vector<int> res;\\n        if(aliceSum < bobSum){\\n            sort(bobSizes.begin(), bobSizes.end());\\n            res = solve(aliceSizes, bobSizes, (bobSum - aliceSum) >> 1);\\n        } else{\\n            sort(aliceSizes.begin(), aliceSizes.end());\\n            res = solve(bobSizes, aliceSizes, (aliceSum - bobSum) >> 1);\\n            swap(res[0], res[1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nRuntime: 179 ms, faster than 45.65% of C++ online submissions for Fair Candy Swap.\\nMemory Usage: 39 MB, less than 94.76% of C++ online submissions for Fair Candy Swap.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558855,
                "title": "java-sol-using-binary-search",
                "content": "```\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int[] res = new int [] {0, 0};\\n        int alice = 0, bob = 0, start, end, mid;\\n        \\n        Arrays.sort(bobSizes);\\n        \\n        for (int i = 0; i < aliceSizes.length; ++i)\\n            alice += aliceSizes[i]; \\n        for (int i = 0; i < bobSizes.length; ++i)\\n            bob += bobSizes[i];\\n        \\n        for (int i = 0; i < aliceSizes.length; ++i)\\n        {\\n            alice -= aliceSizes[i];\\n            bob += aliceSizes[i];\\n            start = 0;\\n            end = bobSizes.length - 1;\\n            \\n            while (start <= end)\\n            {\\n                mid = start + (end - start) / 2;\\n                \\n                alice += bobSizes[mid];\\n                bob -= bobSizes[mid];\\n\\n                if (alice == bob)\\n                {\\n                    res[0] = aliceSizes[i];\\n                    res[1] = bobSizes[mid];\\n                    \\n                    return res;\\n                }\\n                else if (alice > bob)\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n                \\n                alice -= bobSizes[mid];\\n                bob += bobSizes[mid];\\n            }\\n            \\n            alice += aliceSizes[i];\\n            bob -= aliceSizes[i];\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int[] res = new int [] {0, 0};\\n        int alice = 0, bob = 0, start, end, mid;\\n        \\n        Arrays.sort(bobSizes);\\n        \\n        for (int i = 0; i < aliceSizes.length; ++i)\\n            alice += aliceSizes[i]; \\n        for (int i = 0; i < bobSizes.length; ++i)\\n            bob += bobSizes[i];\\n        \\n        for (int i = 0; i < aliceSizes.length; ++i)\\n        {\\n            alice -= aliceSizes[i];\\n            bob += aliceSizes[i];\\n            start = 0;\\n            end = bobSizes.length - 1;\\n            \\n            while (start <= end)\\n            {\\n                mid = start + (end - start) / 2;\\n                \\n                alice += bobSizes[mid];\\n                bob -= bobSizes[mid];\\n\\n                if (alice == bob)\\n                {\\n                    res[0] = aliceSizes[i];\\n                    res[1] = bobSizes[mid];\\n                    \\n                    return res;\\n                }\\n                else if (alice > bob)\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n                \\n                alice -= bobSizes[mid];\\n                bob += bobSizes[mid];\\n            }\\n            \\n            alice += aliceSizes[i];\\n            bob -= aliceSizes[i];\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2519085,
                "title": "c-solution-binary-search-solution-commented-approach-explained",
                "content": "Time complexity :- O(N*logM) N = Size of alice vector, M = Size of Bob vector\\n\\nclass Solution {\\npublic:\\n*     vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        // Approach :- We\\'ll sure binary search. we will try to replace every candy alice has with candies that Bob have if possible. The difference between the swapped candies must be (Sum of AliceSizes - Sum of Bob Sizes)/2. We\\'ll sort both the vectors and try to find this difference with every candy Alice has throigh binary search. If current difference is more less than the difference we need we\\'ll shrink the interval to left otherwise right.\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        long long sumalice = 0;\\n        long long sumbob = 0;\\n        int alice = aliceSizes.size();\\n        int bob = bobSizes.size();\\n        for(int i = 0;i < alice; i++)\\n        {\\n            sumalice += aliceSizes[i];\\n        }\\n        for(int i = 0;i < bob; i++)\\n        {\\n            sumbob += bobSizes[i];\\n        }\\n        long long diff = sumalice-sumbob;\\n        diff = diff/2;\\n        vector<int>ans(2);\\n        for(int i = 0;i < alice; i++)\\n        {\\n            int temp = solve(bobSizes,aliceSizes[i],diff);\\n            if(temp != INT_MAX)\\n            {\\n                ans[0] = aliceSizes[i];\\n                ans[1] = temp;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n*     int solve(vector<int>& bob, int& al, long long& diff){\\n        int h = bob.size()-1;\\n        int l = 0;\\n        int mid = l+(h-l)/2;\\n        while(l <= h)\\n        {\\n            mid = l+(h-l)/2;\\n            if(al-bob[mid] == diff)\\n            {\\n                return bob[mid];\\n            }\\n            if(al-bob[mid] < diff)\\n            {\\n                h = mid-1;\\n            }else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return INT_MAX;\\n    }\\n};\\n**Do upvote if you understood it !**",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n*     vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        // Approach :- We\\'ll sure binary search. we will try to replace every candy alice has with candies that Bob have if possible. The difference between the swapped candies must be (Sum of AliceSizes - Sum of Bob Sizes)/2. We\\'ll sort both the vectors and try to find this difference with every candy Alice has throigh binary search. If current difference is more less than the difference we need we\\'ll shrink the interval to left otherwise right.\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        long long sumalice = 0;\\n        long long sumbob = 0;\\n        int alice = aliceSizes.size();\\n        int bob = bobSizes.size();\\n        for(int i = 0;i < alice; i++)\\n        {\\n            sumalice += aliceSizes[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2431352,
                "title": "hashmap-easy-to-understand",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        Map<Integer, Integer> map = new HashMap();\\n        int sa = 0;\\n        int sb = 0;\\n        for (int i: A){\\n            sa += i;\\n            map.put(i, 1);\\n        }\\n        for (int i: B) sb += i;\\n        int dist = (sa - sb) / 2;\\n\\n        for (int i: B){\\n            if (map.get(i + dist) != null){\\n                return new int[]{i+dist, i};\\n            }\\n        }\\n\\n        return null;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1896913,
                "title": "python-binary-search",
                "content": "```\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        sum1 = sum(aliceSizes)\\n        sum2 = sum(bobSizes)\\n        \\n        aliceSizes = sorted(aliceSizes)\\n        bobSizes = sorted(bobSizes)\\n        \\n        for a in aliceSizes:\\n            maybe_b = (2*a - (sum1 - sum2))/2\\n            b = self.binarySearch(bobSizes, maybe_b)\\n            if not b:\\n                continue\\n            else:\\n                return [a, b]\\n                \\n    def binarySearch(self, nums, n):\\n        l, r = 0, len(nums)-1\\n        while l <= r:                     \\n            mid = (l+r)//2                \\n            if nums[mid] == n:\\n                return nums[mid]\\n            elif nums[mid] > n:\\n                r = mid-1\\n            elif nums[mid] < n:\\n                l = mid+1  \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        sum1 = sum(aliceSizes)\\n        sum2 = sum(bobSizes)\\n        \\n        aliceSizes = sorted(aliceSizes)\\n        bobSizes = sorted(bobSizes)\\n        \\n        for a in aliceSizes:\\n            maybe_b = (2*a - (sum1 - sum2))/2\\n            b = self.binarySearch(bobSizes, maybe_b)\\n            if not b:\\n                continue\\n            else:\\n                return [a, b]\\n                \\n    def binarySearch(self, nums, n):\\n        l, r = 0, len(nums)-1\\n        while l <= r:                     \\n            mid = (l+r)//2                \\n            if nums[mid] == n:\\n                return nums[mid]\\n            elif nums[mid] > n:\\n                r = mid-1\\n            elif nums[mid] < n:\\n                l = mid+1  \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1877306,
                "title": "two-ways-binary-search-and-find-in-c",
                "content": "1)using vector find stl :-\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sa=0,sb=0;\\n        for(int i:aliceSizes)\\n            sa+=i;\\n        for(int j:bobSizes)\\n            sb+=j;\\n        int delta = (sb-sa)/2;\\n        vector<int>ans;\\n    for(int i:aliceSizes){\\n        if(find(bobSizes.begin(),bobSizes.end(),i+delta)!=bobSizes.end()){\\n            ans.push_back(i);\\n            ans.push_back(i+delta);\\n            break;\\n        }\\n    }\\n           return ans;\\n    }\\n};\\n```\\n2) using binary search :-\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sa=0,sb=0;\\n        for(int i:aliceSizes)\\n            sa+=i;\\n        for(int j:bobSizes)\\n            sb+=j;\\n        int delta = (sb-sa)/2;\\n        \\n        for(int i=0;i<aliceSizes.size();i++){\\n            vector<int>ans;\\n            int l=0,h=aliceSizes.size()-1,target = aliceSizes[i]+delta;\\n            ans.push_back(aliceSizes[i]);\\n            while(l<=h){\\n                int mid = l + ((h-l)/2);\\n                if(bobSizes[mid] == target){\\n                    ans.push_back(target);\\n                    return ans;\\n                }\\n                else if(bobSizes[mid]<target){\\n                    l = mid+1;\\n                }\\n                else\\n                    h = mid-1;\\n            }\\n        }\\n        vector<int> v;\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sa=0,sb=0;\\n        for(int i:aliceSizes)\\n            sa+=i;\\n        for(int j:bobSizes)\\n            sb+=j;\\n        int delta = (sb-sa)/2;\\n        vector<int>ans;\\n    for(int i:aliceSizes){\\n        if(find(bobSizes.begin(),bobSizes.end(),i+delta)!=bobSizes.end()){\\n            ans.push_back(i);\\n            ans.push_back(i+delta);\\n            break;\\n        }\\n    }\\n           return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735583,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(int i=0;i<aliceSizes.length;i++)  //find sum of alicesizes array\\n        {\\n            sum1=sum1+aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.length;i++)   //find sum of bobsizesarray\\n        {\\n            sum2=sum2+bobSizes[i];\\n        }\\n        \\n        int diff=(sum1-sum2)/2;  /*it comes from the equation when alice gives x candies                                                    and receives y candies and bob gives y candies and receives x\\n                                                                   so sum1-x+y=sum2+x-y\\n                                                                    y=(sum2-sum1)/2+x*/\\n        int res[]=new int[2];\\n        for(int i=0;i<aliceSizes.length;i++)\\n        {\\n            for(int j=0;j<bobSizes.length;j++)\\n            {\\n                if(aliceSizes[i]==bobSizes[j]+diff)\\n                {\\n                    res[0]=aliceSizes[i];\\n                    res[1]=bobSizes[j];\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(int i=0;i<aliceSizes.length;i++)  //find sum of alicesizes array\\n        {\\n            sum1=sum1+aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.length;i++)   //find sum of bobsizesarray\\n        {\\n            sum2=sum2+bobSizes[i];\\n        }\\n        \\n        int diff=(sum1-sum2)/2;  /*it comes from the equation when alice gives x candies                                                    and receives y candies and bob gives y candies and receives x\\n                                                                   so sum1-x+y=sum2+x-y\\n                                                                    y=(sum2-sum1)/2+x*/\\n        int res[]=new int[2];\\n        for(int i=0;i<aliceSizes.length;i++)\\n        {\\n            for(int j=0;j<bobSizes.length;j++)\\n            {\\n                if(aliceSizes[i]==bobSizes[j]+diff)\\n                {\\n                    res[0]=aliceSizes[i];\\n                    res[1]=bobSizes[j];\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716760,
                "title": "c-binary-search-mlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& arr,int target)\\n    {\\n        int left = 0, right = arr.size()-1,mid;\\n        while(left <=right)\\n        {\\n            mid = left + (right-left)/2;\\n            if(arr[mid] == target)\\n            {\\n                return 1;\\n            }\\n            if(arr[mid] > target)\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            {\\n                left = mid +1;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        sort(bobSizes.begin(), bobSizes.end());\\n        int a = accumulate(aliceSizes.begin(), aliceSizes.end(), 0),b = accumulate(bobSizes.begin(), bobSizes.end(), 0);\\n        int exc = (b-a)/2;\\n        vector<int> ans;\\n        // if box b - box a == exc, exchange them and get ans\\n        // for each box that alice has binary search box a + exc and thats your solution\\n        for(auto i : aliceSizes)\\n        {\\n            if(bs(bobSizes,i+exc))\\n            {\\n                ans.push_back(i);\\n                ans.push_back(i+exc);\\n                return ans;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& arr,int target)\\n    {\\n        int left = 0, right = arr.size()-1,mid;\\n        while(left <=right)\\n        {\\n            mid = left + (right-left)/2;\\n            if(arr[mid] == target)\\n            {\\n                return 1;\\n            }\\n            if(arr[mid] > target)\\n            {\\n                right = mid-1;\\n            }\\n            else\\n            {\\n                left = mid +1;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        sort(bobSizes.begin(), bobSizes.end());\\n        int a = accumulate(aliceSizes.begin(), aliceSizes.end(), 0),b = accumulate(bobSizes.begin(), bobSizes.end(), 0);\\n        int exc = (b-a)/2;\\n        vector<int> ans;\\n        // if box b - box a == exc, exchange them and get ans\\n        // for each box that alice has binary search box a + exc and thats your solution\\n        for(auto i : aliceSizes)\\n        {\\n            if(bs(bobSizes,i+exc))\\n            {\\n                ans.push_back(i);\\n                ans.push_back(i+exc);\\n                return ans;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447364,
                "title": "java-with-self-explanatory-code-and-comments",
                "content": "Time Complexity - O(N)\\n\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int totalCandiesWithAlice = 0;\\n        int totalCandiesWithBob = 0;\\n        \\n        HashSet<Integer> setA = new HashSet<>();\\n        \\n        // calculate the total number of candies with Alice.\\n        // Also, construct a set so that it will store only unique box sizes(as we want to figure out only ANY answer and not all possible answers)\\n        for(int i=0; i<aliceSizes.length; i++)\\n        {\\n            totalCandiesWithAlice += aliceSizes[i];\\n            setA.add(aliceSizes[i]);\\n        }\\n        \\n        // calcualte the total number of candies with Bob\\n        for(int i=0; i< bobSizes.length; i++)\\n        {\\n            totalCandiesWithBob += bobSizes[i];\\n        }\\n        \\n        // THE CORE LOGIC OF THIS ANSWER IS DUE TO THE FOLLOWING ASSUMPTION - \"THERE EXISTS ATLEAST ONE ANSWER\".\\n        // So, the difference between atleast one element in the array should be even(divisble by 2) so that we can share half of it with the person with less candies.\\n        // As we constructed the set for Alice\\'s candy boxes, the intention is to search for the difference in that set. So, the difference should be total number of candies with Alice has minus total number of candies that Bob has\\n        int differenceToMatch = (totalCandiesWithAlice-totalCandiesWithBob)/2;\\n        \\n        // loop through all the boxes that bob has\\n        for(int i=0; i<bobSizes.length; i++)\\n        {\\n            // For every box that bob has, check if there exists a box with alice that can split the difference with Bob(this will ensure both of them will have same total count). When found, return the same.\\n            if(setA.contains(bobSizes[i]+differenceToMatch))\\n                return new int[]{bobSizes[i]+differenceToMatch, bobSizes[i]};\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int totalCandiesWithAlice = 0;\\n        int totalCandiesWithBob = 0;\\n        \\n        HashSet<Integer> setA = new HashSet<>();\\n        \\n        // calculate the total number of candies with Alice.\\n        // Also, construct a set so that it will store only unique box sizes(as we want to figure out only ANY answer and not all possible answers)\\n        for(int i=0; i<aliceSizes.length; i++)\\n        {\\n            totalCandiesWithAlice += aliceSizes[i];\\n            setA.add(aliceSizes[i]);\\n        }\\n        \\n        // calcualte the total number of candies with Bob\\n        for(int i=0; i< bobSizes.length; i++)\\n        {\\n            totalCandiesWithBob += bobSizes[i];\\n        }\\n        \\n        // THE CORE LOGIC OF THIS ANSWER IS DUE TO THE FOLLOWING ASSUMPTION - \"THERE EXISTS ATLEAST ONE ANSWER\".\\n        // So, the difference between atleast one element in the array should be even(divisble by 2) so that we can share half of it with the person with less candies.\\n        // As we constructed the set for Alice\\'s candy boxes, the intention is to search for the difference in that set. So, the difference should be total number of candies with Alice has minus total number of candies that Bob has\\n        int differenceToMatch = (totalCandiesWithAlice-totalCandiesWithBob)/2;\\n        \\n        // loop through all the boxes that bob has\\n        for(int i=0; i<bobSizes.length; i++)\\n        {\\n            // For every box that bob has, check if there exists a box with alice that can split the difference with Bob(this will ensure both of them will have same total count). When found, return the same.\\n            if(setA.contains(bobSizes[i]+differenceToMatch))\\n                return new int[]{bobSizes[i]+differenceToMatch, bobSizes[i]};\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357377,
                "title": "c-code-using-binary-search-o-nlogn",
                "content": "```\\n vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        vector<int> ans;\\n  \\n        \\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int sumalice=0,sumbob=0;\\n        \\n        for(auto x: bobSizes){\\n            sumbob+=x;\\n        }\\n        \\n        \\n        for(auto x: aliceSizes){\\n            sumalice+=x;\\n        }        \\n      \\n        \\n        int z=(sumbob - sumalice)/2;\\n        \\n        for(auto x: aliceSizes){\\n            \\n            int index=lower_bound(bobSizes.begin(),bobSizes.end(),z + x) - bobSizes.begin();\\n            \\n            if(bobSizes[index]==z + x){\\n                ans.push_back(x);\\n                ans.push_back(z + x);\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        vector<int> ans;\\n  \\n        \\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int sumalice=0,sumbob=0;\\n        \\n        for(auto x: bobSizes){\\n            sumbob+=x;\\n        }\\n        \\n        \\n        for(auto x: aliceSizes){\\n            sumalice+=x;\\n        }        \\n      \\n        \\n        int z=(sumbob - sumalice)/2;\\n        \\n        for(auto x: aliceSizes){\\n            \\n            int index=lower_bound(bobSizes.begin(),bobSizes.end(),z + x) - bobSizes.begin();\\n            \\n            if(bobSizes[index]==z + x){\\n                ans.push_back(x);\\n                ans.push_back(z + x);\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265407,
                "title": "python-3-solution-using-hash",
                "content": "**explanation:**\\n\\ntotal amount = total amount alice has + total amount bob has\\nbalance = total amount/2\\nextra amount alice needs to add/subtract = (asize-balance)\\n[if balance>asize, then extra amount will be negative, so (a-extra amount) will eventually end up adding extra amiunt to a]\\n\\nso we need to check\\nif a is the amount of one candy in alice\\'s collection, \\nbobs collection must contain (a-extra amount) as a counterpart.\\nfor that purpose, put b in hash and check for all (a-extra amount) against all a.\\n\\nThat\\'s it\\n```\\ndef fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n\\tasize, bsize = sum(aliceSizes), sum(bobSizes)\\n\\tbalance = (asize+bsize)//2\\n\\tadd = asize-balance\\n\\n\\tb = set(bobSizes)\\n\\n\\tfor a in aliceSizes:\\n\\t\\tif a-add in b:\\n\\t\\t\\treturn [a, a-add]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n\\tasize, bsize = sum(aliceSizes), sum(bobSizes)\\n\\tbalance = (asize+bsize)//2\\n\\tadd = asize-balance\\n\\n\\tb = set(bobSizes)\\n\\n\\tfor a in aliceSizes:\\n\\t\\tif a-add in b:\\n\\t\\t\\treturn [a, a-add]\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1196976,
                "title": "javascript-solution",
                "content": "```\\nvar fairCandySwap = function(A, B) {\\n    let tot = 0;\\n    \\n    const set = new Set();\\n    let sumA = 0;\\n    \\n    for (const num of A) {\\n        tot += num;\\n        sumA += num;\\n    }\\n    \\n    for (const num of B) {\\n        tot += num;\\n        set.add(num);\\n    }\\n    \\n    const half = tot / 2;\\n    \\n    for (const num of A) {\\n        const rem = sumA - num;\\n        const need = half - rem;\\n        \\n        if (set.has(need)) return [num, need];\\n    }\\n\\t\\n\\t// it is guaranteed that an answer exist, so we don\\'t need to return anything here\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fairCandySwap = function(A, B) {\\n    let tot = 0;\\n    \\n    const set = new Set();\\n    let sumA = 0;\\n    \\n    for (const num of A) {\\n        tot += num;\\n        sumA += num;\\n    }\\n    \\n    for (const num of B) {\\n        tot += num;\\n        set.add(num);\\n    }\\n    \\n    const half = tot / 2;\\n    \\n    for (const num of A) {\\n        const rem = sumA - num;\\n        const need = half - rem;\\n        \\n        if (set.has(need)) return [num, need];\\n    }\\n\\t\\n\\t// it is guaranteed that an answer exist, so we don\\'t need to return anything here\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950709,
                "title": "c-91",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(const vector<int>& a, vector<int>& b) {\\n        int diff=(accumulate(a.begin(),a.end(),0)-accumulate(b.begin(),b.end(),0))/2;\\n        sort(b.begin(),b.end());\\n        for(auto i:a)\\n            if(binary_search(b.begin(),b.end(),i-diff)) return {i,i-diff};\\n        return {0,0};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(const vector<int>& a, vector<int>& b) {\\n        int diff=(accumulate(a.begin(),a.end(),0)-accumulate(b.begin(),b.end(),0))/2;\\n        sort(b.begin(),b.end());\\n        for(auto i:a)\\n            if(binary_search(b.begin(),b.end(),i-diff)) return {i,i-diff};\\n        return {0,0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907579,
                "title": "python3-simple-amortized-o-n-with-set-beats-100-in-time",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        B_ = set(B)\\n        d = (sum(A) - sum(B)) // 2\\n        for a in A:\\n            if a - d in B_:\\n                return [a, a - d]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        B_ = set(B)\\n        d = (sum(A) - sum(B)) // 2\\n        for a in A:\\n            if a - d in B_:\\n                return [a, a - d]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484871,
                "title": "c-120ms-in-o-mlog-n",
                "content": "```\\n vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        vector <int> ans;\\n        int aSum,bSum;\\n        aSum = bSum = 0;\\n        sort(A.begin(),A.end());\\n        sort(B.begin(),B.end());\\n        aSum = accumulate(A.begin(),A.end(),0);\\n        bSum = accumulate(B.begin(),B.end(),0);\\n        int target = (aSum-bSum)/2;\\n        \\n        \\n            for(int i=0;i<A.size();i++)\\n            {\\n               // here apply binary search on B\\n                int left = 0;\\n                int right = B.size()-1;\\n                while(left<=right)\\n                {\\n                    int mid = (left+right)/2;\\n                    \\n                    if(B[mid]==A[i]-target)\\n                    {\\n                        ans.push_back(A[i]);\\n                        ans.push_back(B[mid]);\\n                        return ans;\\n                    }else if(A[i]-target<B[mid]){\\n                        right = mid -1;\\n                    }else{\\n                        left = mid+1;\\n                    }\\n                }\\n            }\\n        \\n                 \\n        return ans;         \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        vector <int> ans;\\n        int aSum,bSum;\\n        aSum = bSum = 0;\\n        sort(A.begin(),A.end());\\n        sort(B.begin(),B.end());\\n        aSum = accumulate(A.begin(),A.end(),0);\\n        bSum = accumulate(B.begin(),B.end(),0);\\n        int target = (aSum-bSum)/2;\\n        \\n        \\n            for(int i=0;i<A.size();i++)\\n            {\\n               // here apply binary search on B\\n                int left = 0;\\n                int right = B.size()-1;\\n                while(left<=right)\\n                {\\n                    int mid = (left+right)/2;\\n                    \\n                    if(B[mid]==A[i]-target)\\n                    {\\n                        ans.push_back(A[i]);\\n                        ans.push_back(B[mid]);\\n                        return ans;\\n                    }else if(A[i]-target<B[mid]){\\n                        right = mid -1;\\n                    }else{\\n                        left = mid+1;\\n                    }\\n                }\\n            }\\n        \\n                 \\n        return ans;         \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315803,
                "title": "easy-java-solution-11ms-40-4mb-using-hashset-o-n-m-time-complexity-o-m-space",
                "content": "```\\n    // sum1 - a[i] + b[j] = sum2 + a[i] - b[j]\\n    // sum1 - sum2 = 2*a[i] - 2*b[j]\\n    // b[j] = (2a[i] - sum1 + sum2) / 2 \\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sum1 = 0;\\n        for(int a : A){\\n            sum1+=a;\\n        }\\n        int sum2 = 0;\\n        Set<Integer> hsB = new HashSet<>();\\n        for(int b : B){\\n            sum2+=b;\\n            hsB.add(b);\\n        }\\n        for(int a : A){\\n            int b = (2*a - sum1 + sum2) / 2;\\n            if(hsB.contains(b))\\n                return new int[]{a, b};\\n        }\\n        return null;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // sum1 - a[i] + b[j] = sum2 + a[i] - b[j]\\n    // sum1 - sum2 = 2*a[i] - 2*b[j]\\n    // b[j] = (2a[i] - sum1 + sum2) / 2 \\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int sum1 = 0;\\n        for(int a : A){\\n            sum1+=a;\\n        }\\n        int sum2 = 0;\\n        Set<Integer> hsB = new HashSet<>();\\n        for(int b : B){\\n            sum2+=b;\\n            hsB.add(b);\\n        }\\n        for(int a : A){\\n            int b = (2*a - sum1 + sum2) / 2;\\n            if(hsB.contains(b))\\n                return new int[]{a, b};\\n        }\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238894,
                "title": "fast-and-readable-c-solution",
                "content": "This C solution faster than 83% of C online Submission and use less than 100% in term of memory usage.\\n```\\n/**\\n * Return an array of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* fairCandySwap(int* A, int ASize, int* B, int BSize, int* returnSize) {\\n    *returnSize = 2;\\n    int *rst = (int *) calloc(*returnSize, sizeof(int));\\n    int sumA = 0, sumB = 0;\\n    \\n    int i;\\n    for(i = 0; i < ASize; i++){\\n        sumA += A[i];\\n    }\\n    \\n    int minB = INT_MAX, maxB = INT_MIN;\\n    for(i = 0; i < BSize; i++){\\n        sumB += B[i];\\n        if(B[i] > maxB){\\n            maxB = B[i];\\n        }\\n        if(B[i] < minB){\\n            minB = B[i];\\n        }\\n    }\\n    \\n    int *map = (int *) calloc(maxB - minB + 1, sizeof(int));\\n    for(i = 0; i < BSize; i++){\\n        map[B[i] - minB]++;\\n    }\\n    \\n    int delta = (sumB - sumA) / 2;\\n    for(i = 0; i < ASize; A++){\\n        if((A[i] + delta >= minB) && (A[i] + delta <= maxB)){\\n            if(map[A[i] + delta - minB] > 0){\\n                rst[0] = A[i];\\n                rst[1] = A[i] + delta;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return rst;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Return an array of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* fairCandySwap(int* A, int ASize, int* B, int BSize, int* returnSize) {\\n    *returnSize = 2;\\n    int *rst = (int *) calloc(*returnSize, sizeof(int));\\n    int sumA = 0, sumB = 0;\\n    \\n    int i;\\n    for(i = 0; i < ASize; i++){\\n        sumA += A[i];\\n    }\\n    \\n    int minB = INT_MAX, maxB = INT_MIN;\\n    for(i = 0; i < BSize; i++){\\n        sumB += B[i];\\n        if(B[i] > maxB){\\n            maxB = B[i];\\n        }\\n        if(B[i] < minB){\\n            minB = B[i];\\n        }\\n    }\\n    \\n    int *map = (int *) calloc(maxB - minB + 1, sizeof(int));\\n    for(i = 0; i < BSize; i++){\\n        map[B[i] - minB]++;\\n    }\\n    \\n    int delta = (sumB - sumA) / 2;\\n    for(i = 0; i < ASize; A++){\\n        if((A[i] + delta >= minB) && (A[i] + delta <= maxB)){\\n            if(map[A[i] + delta - minB] > 0){\\n                rst[0] = A[i];\\n                rst[1] = A[i] + delta;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return rst;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 191392,
                "title": "javascript",
                "content": "```\nvar fairCandySwap = function(A, B) {\n    let sumA = 0, sumB = 0, result=[];\n    for(let a of A) {\n        sumA += a;\n    }\n    for(let b of B) {\n        sumB += b;\n    }\n    let mean = (sumA + sumB) / 2;\n    for(let i = 0; i < A.length; i++) {\n        let t = sumA - A[i];\n        let s = mean - t;\n        if(B.indexOf(s) >= 0 && (sumB - s + A[i] == mean)) {\n            result.push(A[i]);\n            result.push(s);\n            break;\n        }\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar fairCandySwap = function(A, B) {\n    let sumA = 0, sumB = 0, result=[];\n    for(let a of A) {\n        sumA += a;\n    }\n    for(let b of B) {\n        sumB += b;\n    }\n    let mean = (sumA + sumB) / 2;\n    for(let i = 0; i < A.length; i++) {\n        let t = sumA - A[i];\n        let s = mean - t;\n        if(B.indexOf(s) >= 0 && (sumB - s + A[i] == mean)) {\n            result.push(A[i]);\n            result.push(s);\n            break;\n        }\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186961,
                "title": "java-o-n-time-o-n-space-explanation",
                "content": "The idea is the following:\\nlet\\'s assume our arrays are:\\nA=[x1,x2,x3,....,k + d,....xn]\\nB=[y1,y2,y3,.....,k,...ym]\\nLet\\'s imagine we need to exchange only **k + d** and **k**. where **xk=k+d** and **yk=k**.\\nWhen we exchange these elements, aray sums will be the same, so let\\'s derive what are these sums now, before exchanging:\\n##### x1+x2+x3+...+ k +...xn == y1+y2+y3+...+k+d+...ym <->\\n##### x1+x2+x3+...+ k+d +...xn == y1+y2+y3+...+ k+d+d +...ym <->\\n\\u03A3A[] == \\u03A3B[] + 2d\\n\\nSo what we need to do:\\n1. find sums of each array (Java 8 stream)\\n2. find d \\n2. identify what sum is bigger (who is \"richer\"- Alice of Bob)\\n3. find paired elements from A[] and B[] that have d as a difference, taking into account who is richer (solution is similar to 2sum):\\n\\n```\\nclass FairCandySwap {\\n public int[] fairCandySwap(int[] A, int[] B) {\\n  int aliceSum = Arrays.stream(A).reduce(0, (x, y) -> x + y);\\n  int bobSum = Arrays.stream(B).reduce(0, (x, y) -> x + y);;\\n  boolean aliceRicher = (aliceSum - bobSum) > 0;\\n  return fairCandySwap(A, B, Math.abs(aliceSum - bobSum) / 2, aliceRicher);\\n }\\n public int[] fairCandySwap(int[] A, int[] B, int difference, boolean aliceRicher) {\\n  int[] res = new int[2];\\n  Set <Integer> differences = Arrays.stream(B).boxed()\\n   .map(x -> {\\n    if (aliceRicher) x += difference;\\n    else x -= difference;\\n    return x;\\n   })\\n   .collect(Collectors.toSet());\\n  for (int i = 0; i < A.length; i++) {\\n   if (differences.contains(A[i])) res[0] = A[i];\\n   if (aliceRicher) res[1] = res[0] - difference;\\n   else res[1] = res[0] + difference;\\n  }\\n  return res;\\n }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FairCandySwap {\\n public int[] fairCandySwap(int[] A, int[] B) {\\n  int aliceSum = Arrays.stream(A).reduce(0, (x, y) -> x + y);\\n  int bobSum = Arrays.stream(B).reduce(0, (x, y) -> x + y);;\\n  boolean aliceRicher = (aliceSum - bobSum) > 0;\\n  return fairCandySwap(A, B, Math.abs(aliceSum - bobSum) / 2, aliceRicher);\\n }\\n public int[] fairCandySwap(int[] A, int[] B, int difference, boolean aliceRicher) {\\n  int[] res = new int[2];\\n  Set <Integer> differences = Arrays.stream(B).boxed()\\n   .map(x -> {\\n    if (aliceRicher) x += difference;\\n    else x -= difference;\\n    return x;\\n   })\\n   .collect(Collectors.toSet());\\n  for (int i = 0; i < A.length; i++) {\\n   if (differences.contains(A[i])) res[0] = A[i];\\n   if (aliceRicher) res[1] = res[0] - difference;\\n   else res[1] = res[0] + difference;\\n  }\\n  return res;\\n }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161315,
                "title": "python-solution-very-easy-to-understand",
                "content": "We know the difference between two arrays.\\nLets call it diff.\\ncandy_alice is the candy alice gave to bob\\ncandy_bob is the candy bob gave to alice\\nAlice\\'s candy after exchange: sumA - candy_alice + candy_bob\\nBob\\'s candy after exchange : sumB - candy_bob + candy_alice\\nThese two should equal after exchange:\\nsumA - candy_alice + candy_bob = sumB - candy_bob + candy_alice\\nuse math we can get: sumA - sumB = 2*(candy_alice - candy_bob) = diff\\nWe can represent candy bob as: candy_alice - diff/2\\nthen, for each element in A, check if candy_alice - diff/2 is in B\\n\\n```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # calculate difference between A, B\\n        diff = sum(A) - sum(B)\\n        A = set(A)\\n        B = set(B)\\n        for item in A:\\n            item2 = item - float(diff/2)\\n            if item2 in B:\\n                return [item,int(item2)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # calculate difference between A, B\\n        diff = sum(A) - sum(B)\\n        A = set(A)\\n        B = set(B)\\n        for item in A:\\n            item2 = item - float(diff/2)\\n            if item2 in B:\\n                return [item,int(item2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944531,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum_A = aliceSizes.Sum();\\n        int sum_B = bobSizes.Sum();\\n        int[] answer = new int[2];\\n\\n        int diff = (sum_B - sum_A)/ 2;\\n        for (int i = 0; i < aliceSizes.Length; i++){\\n            if (bobSizes.Contains(aliceSizes[i] + diff)){\\n                answer[0] = aliceSizes[i];\\n                answer[1] = aliceSizes[i] + diff;\\n                break;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum_A = aliceSizes.Sum();\\n        int sum_B = bobSizes.Sum();\\n        int[] answer = new int[2];\\n\\n        int diff = (sum_B - sum_A)/ 2;\\n        for (int i = 0; i < aliceSizes.Length; i++){\\n            if (bobSizes.Contains(aliceSizes[i] + diff)){\\n                answer[0] = aliceSizes[i];\\n                answer[1] = aliceSizes[i] + diff;\\n                break;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936725,
                "title": "o-n-beginner-friendly-fully-explained",
                "content": "# Approach\\nTo find the candies that Alice and Bob need to exchange, we want to make the total number of candies held by both Alice and Bob equal. We\\'ll use a \"Two-Sum\" approach to find a candy from Alice and a candy from Bob that, when swapped, will lead to equal candy totals.\\n\\n**Logic:**\\n1. Calculate the total number of candies Alice and Bob have:\\n   - Iterate through both `aliceSizes` and `bobSizes` arrays and calculate the sum of candies Alice and Bob have, stored in `sumAlice` and `sumBob`.\\n\\n2. Create a HashSet for Bob\\'s candies:\\n   - Iterate through `bobSizes` and add each candy\\'s size to a HashSet named `bobSet`. This helps in fast lookups when we check if a certain candy is available in Bob\\'s collection.\\n\\n3. Calculate the target difference:\\n   - Calculate the target difference `targetDiff` between Alice and Bob\\'s total candies by subtracting `sumAlice` from `sumBob`.\\n\\n4. Find the candies for exchange:\\n   - Iterate through Alice\\'s candies using `aliceSizes`. For each candy size `aliceSize`, calculate the corresponding candy size `bobSize` that Bob would need to have a fair swap. Calculate this by adding `targetDiff` to `aliceSize`.\\n   - Check if `bobSet` contains the calculated `bobSize`. If it does, it means that a valid pair of candies for a fair swap has been found.\\n\\n5. Return the result:\\n   - If a valid pair is found, return an array containing Alice\\'s candy size and the calculated `bobSize` (the candy Bob needs to exchange).\\n   - If no valid pair is found, return a default array with zeros.\\n\\nThis approach ensures that Alice and Bob will have the same total number of candies after the swap. The \"Two-Sum\" technique simplifies the problem into finding a specific difference and checking if an element exists in a set, making the solution efficient and easy to understand.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(max(n, m))$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int[] ans = new int[2];\\n\\n        int sumAlice = 0;\\n        for (int a : aliceSizes)\\n            sumAlice += a;\\n\\n        int sumBob = 0;\\n        Set<Integer> bobSet = new HashSet<>();\\n        for (int b : bobSizes) {\\n            sumBob += b;\\n            bobSet.add(b);\\n        }\\n\\n        int targetDiff = (sumBob - sumAlice) / 2;\\n        for (int aliceSize : aliceSizes) {\\n            int bobSize = aliceSize + targetDiff;\\n            if (bobSet.contains(bobSize)) {\\n                ans[0] = aliceSize;\\n                ans[1] = bobSize;\\n                return ans;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int[] ans = new int[2];\\n\\n        int sumAlice = 0;\\n        for (int a : aliceSizes)\\n            sumAlice += a;\\n\\n        int sumBob = 0;\\n        Set<Integer> bobSet = new HashSet<>();\\n        for (int b : bobSizes) {\\n            sumBob += b;\\n            bobSet.add(b);\\n        }\\n\\n        int targetDiff = (sumBob - sumAlice) / 2;\\n        for (int aliceSize : aliceSizes) {\\n            int bobSize = aliceSize + targetDiff;\\n            if (bobSet.contains(bobSize)) {\\n                ans[0] = aliceSize;\\n                ans[1] = bobSize;\\n                return ans;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791647,
                "title": "java-two-pointer-binary-search-easy-solution",
                "content": "# Intuition\\nI have two approaches to solve this problem. \\n1- Two ponter\\n2- Binary Search.\\nI will explain both in below section.\\n# Approach\\n1 - Two Pointer approach :\\nA- first find total sum of alice and bob before exchange. \\nB- Now run the two loop and check what alice exchange by using this = aliceTotal - alicesize[i] + bobsize[j], means alice is giving one element and taking one element brom bob. \\nC- Do the same thing for bob exchange. \\nD- once you found both exchange then again compare with both sum of exchanges, if equal then return otherwise again check.\\n\\nNote :: I explaine this in a very nice way in my gitHub repo.\\nPlease check this one as well as:\\nhttps://github.com/Sufiyan33/Data-Structure\\n\\n2 - Binary Search\\nFirst four steps would be same as above :\\npublic static int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n\\t\\t// first we have to find total sum of each before exchanges.\\n\\t\\tint aliceTotal = 0;\\n\\t\\tint bobTotal = 0;\\n\\n\\t\\tfor (int aa : aliceSizes) {\\n\\t\\t\\taliceTotal += aa;\\n\\t\\t}\\n\\t\\tfor (int bb : bobSizes) {\\n\\t\\t\\tbobTotal += bb;\\n\\t\\t}\\n\\t\\t// Now iterate aliceSize array and then try to find out target so that we can do\\n\\t\\t// binary search.\\n\\n\\t\\tfor (int i = 0; i < aliceSizes.length; i++) {\\n\\t\\t\\t// here we will use some mathmatics to find mid value;\\n\\t\\t\\t/*\\n\\t\\t\\t * see as previouse example I explained very well. aliceTotal - aliceSizes[i] +\\n\\t\\t\\t * bobSizes[j] = bobTotal - bobSizes[j]+aliceSizes[i] aliceTotal = bobTotal +\\n\\t\\t\\t * aliceSizes[i] + aliceSizes[i] - bobSizes[j]-bobSizes[j] aliceTotal = bobTotal\\n\\t\\t\\t * + 2 * aliceSizes[i] - 2* bobSizes[j];\\n\\t\\t\\t * \\n\\t\\t\\t * 2 bobSizes[j] = bobTotal - aliceTotal + 2 * aliceSizes[i]; bobSizes[j] =\\n\\t\\t\\t * (bobTotal - aliceTotal + 2 * aliceSizes[i])/2\\n\\t\\t\\t */\\n\\n\\t\\t\\t/*\\n\\t\\t\\t * Here in this case we will take bobsize array as target to do binar search.\\n\\t\\t\\t * Hence we need to first sort bobsArray\\n\\t\\t\\t */\\n\\t\\t\\tint target = (bobTotal - aliceTotal + 2 * aliceSizes[i]) / 2;\\n\\t\\t\\tif (binarySearch(bobSizes, target)) {\\n\\t\\t\\t\\treturn new int[] { aliceSizes[i], target };\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn new int[0];\\n\\t}\\n\\n\\tpublic static boolean binarySearch(int[] arr, int target) {\\n\\t\\tint start = 0;\\n\\t\\tint end = arr.length - 1;\\n\\t\\tint mid = start + (end - start) / 2;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tif (target > arr[mid])\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\tif (target < arr[mid])\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        //using two pinter approach.\\n        int aliceTotal = 0;\\n        int bobTotal = 0;\\n        //Find sum of alice candies before exchange.\\n        for(int aa : aliceSizes)\\n            aliceTotal += aa;\\n        //Find sum of bob candies before exchange.\\n        for(int bb : bobSizes)\\n            bobTotal += bb;\\n        \\n        for(int i = 0; i< aliceSizes.length; i++){\\n            for(int j = 0; j< bobSizes.length; j++){\\n                int aliceExchange = aliceTotal - aliceSizes[i] + bobSizes[j];\\n                int bobExchange = bobTotal - bobSizes[j] + aliceSizes[i];\\n                if(aliceExchange == bobExchange){\\n                    return new int[]{aliceSizes[i], bobSizes[j]};\\n                }\\n            }\\n        }\\n        return new int[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        //using two pinter approach.\\n        int aliceTotal = 0;\\n        int bobTotal = 0;\\n        //Find sum of alice candies before exchange.\\n        for(int aa : aliceSizes)\\n            aliceTotal += aa;\\n        //Find sum of bob candies before exchange.\\n        for(int bb : bobSizes)\\n            bobTotal += bb;\\n        \\n        for(int i = 0; i< aliceSizes.length; i++){\\n            for(int j = 0; j< bobSizes.length; j++){\\n                int aliceExchange = aliceTotal - aliceSizes[i] + bobSizes[j];\\n                int bobExchange = bobTotal - bobSizes[j] + aliceSizes[i];\\n                if(aliceExchange == bobExchange){\\n                    return new int[]{aliceSizes[i], bobSizes[j]};\\n                }\\n            }\\n        }\\n        return new int[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511718,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        bitset<200002> bf;\\n        int sumA = 0, sumB = 0;\\n        for(auto n: A) {\\n            sumA += n;\\n        }\\n        for(auto n: B) {\\n            sumB += n;\\n            bf.set(2*n);\\n        }\\n        int diff = sumA - sumB;\\n        for(auto n: A) {\\n            int det = 2*n - diff;\\n            if(det > 0 && det < 200002 && bf.test(det)) {\\n                return {n, (2*n-diff)/2};\\n            }\\n        }\\n        return {};\\n    }\\n};\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        \\n        x = (sum(aliceSizes)-sum(bobSizes)) / 2\\n\\n        sets = set(aliceSizes)\\n\\n        for y in bobSizes:\\n            if y + x in sets: \\n                return [y + x, y]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int aum = 0;\\n        boolean[] inAlice = new boolean[100001];\\n        for (int i = 0; i < aliceSizes.length; i++) {\\n            aum += aliceSizes[i];\\n            inAlice[aliceSizes[i]] = true;\\n        }\\n        int bum = 0;\\n        for (int i = 0; i < bobSizes.length; i++) {\\n            bum += bobSizes[i];\\n        }\\n        int diff = aum - bum;\\n        int[] ans = new int[2];\\n        for (int i = 0; i < bobSizes.length; i++) {\\n            int target = bobSizes[i] + diff / 2;\\n            if (target > 0 && target < 100001) {\\n                if (inAlice[target]) {\\n                    ans = new int[] {target, bobSizes[i]};\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        bitset<200002> bf;\\n        int sumA = 0, sumB = 0;\\n        for(auto n: A) {\\n            sumA += n;\\n        }\\n        for(auto n: B) {\\n            sumB += n;\\n            bf.set(2*n);\\n        }\\n        int diff = sumA - sumB;\\n        for(auto n: A) {\\n            int det = 2*n - diff;\\n            if(det > 0 && det < 200002 && bf.test(det)) {\\n                return {n, (2*n-diff)/2};\\n            }\\n        }\\n        return {};\\n    }\\n};\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\n```Python3 []\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        \\n        x = (sum(aliceSizes)-sum(bobSizes)) / 2\\n\\n        sets = set(aliceSizes)\\n\\n        for y in bobSizes:\\n            if y + x in sets: \\n                return [y + x, y]\\n```\n```Java []\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int aum = 0;\\n        boolean[] inAlice = new boolean[100001];\\n        for (int i = 0; i < aliceSizes.length; i++) {\\n            aum += aliceSizes[i];\\n            inAlice[aliceSizes[i]] = true;\\n        }\\n        int bum = 0;\\n        for (int i = 0; i < bobSizes.length; i++) {\\n            bum += bobSizes[i];\\n        }\\n        int diff = aum - bum;\\n        int[] ans = new int[2];\\n        for (int i = 0; i < bobSizes.length; i++) {\\n            int target = bobSizes[i] + diff / 2;\\n            if (target > 0 && target < 100001) {\\n                if (inAlice[target]) {\\n                    ans = new int[] {target, bobSizes[i]};\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3233167,
                "title": "java-solution-without-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA=0;\\n        int sumB = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int alice:aliceSizes){\\n            sumA+=alice;\\n            hs.add(alice);\\n        }\\n        for(int bob:bobSizes){\\n            sumB+=bob;\\n        }\\n        int diff = (sumA-sumB)/2;\\n        for(int i =0;i<bobSizes.length;i++){\\n            int target = diff+bobSizes[i];\\n            if(hs.contains(target)){\\n                return new int[]{target, bobSizes[i]};\\n            }\\n        }\\n        \\n        return null;\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA=0;\\n        int sumB = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int alice:aliceSizes){\\n            sumA+=alice;\\n            hs.add(alice);\\n        }\\n        for(int bob:bobSizes){\\n            sumB+=bob;\\n        }\\n        int diff = (sumA-sumB)/2;\\n        for(int i =0;i<bobSizes.length;i++){\\n            int target = diff+bobSizes[i];\\n            if(hs.contains(target)){\\n                return new int[]{target, bobSizes[i]};\\n            }\\n        }\\n        \\n        return null;\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211098,
                "title": "awesome-approaches-fully-explained-2-approaches-c",
                "content": "# Intuition\\nWe have to make the number of total candies equal by exchanging one box each. So after Exchanging our boxes,The sum for both person will become (sum1 + sum2) / 2 which will be our target.\\n\\nSince we can exchange only one boxes start traversing alice or bob, and suppose we want to exchange the curent box, if y is present on other side then return {curr,y} where y is\\n\\n=> sum1-curr = target-y\\n=> y = target-sum1+cur;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) || O(N)\\n\\n- Space complexity:\\nO(1) || O(N)\\n\\n# Approach\\n\\n1.) **O(NLogN) Time Complexity using Sorting**\\nFor searching y on bob side , If you are traversing in Alice Side,  You can sort Bob Boxes and then use binary search to find y.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        int sum1=0; \\n        int sum2=0;\\n\\n        for(auto i:aliceSizes) sum1+=i;\\n        for(auto i:bobSizes) sum2+=i;\\n\\n        int target = (sum1+sum2)/2; \\n\\n        sort(bobSizes.begin(),bobSizes.end());\\n\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int cur=aliceSizes[i];\\n            int y=target-sum1+cur;\\n            if(binary_search(bobSizes.begin(),bobSizes.end(),y)) return {cur,y};\\n        }\\n\\n        // Nothing is find (which is not possible according to question)\\n        return {};\\n    }\\n};\\n```\\n\\n2.) **O(N) Time Complexity Appraoch using Hashset/Hashmap**\\nFor searching y on Bob Side, You can first store Bob values in Hashset or Hashmap, Then you can search for y in O(1) Time\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        int sum1=0; \\n        int sum2=0; \\n\\n        for(auto i:aliceSizes) sum1+=i;\\n        \\n        for(auto i:bobSizes)\\n        {\\n            sum2+=i;\\n            bob.insert(i);\\n        }\\n\\n        int target = (sum1+sum2)/2; \\n\\n        unordered_set<int> bob;\\n\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int cur=aliceSizes[i]; \\n            int y=target-sum1+cur;\\n            if(bob.find(y)!=bob.end()) return {cur,y};\\n        }\\n\\n        return {};\\n    }\\n};\\n```\\n\\n\\n\\n\\nPLEASE UPVOTE ME IF MY SOLUTION HELPED YOU \\n![image.png](https://assets.leetcode.com/users/images/d820bc6f-f7ae-4b81-9ec7-df7f92e5359a_1676914309.4178846.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        int sum1=0; \\n        int sum2=0;\\n\\n        for(auto i:aliceSizes) sum1+=i;\\n        for(auto i:bobSizes) sum2+=i;\\n\\n        int target = (sum1+sum2)/2; \\n\\n        sort(bobSizes.begin(),bobSizes.end());\\n\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int cur=aliceSizes[i];\\n            int y=target-sum1+cur;\\n            if(binary_search(bobSizes.begin(),bobSizes.end(),y)) return {cur,y};\\n        }\\n\\n        // Nothing is find (which is not possible according to question)\\n        return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        int sum1=0; \\n        int sum2=0; \\n\\n        for(auto i:aliceSizes) sum1+=i;\\n        \\n        for(auto i:bobSizes)\\n        {\\n            sum2+=i;\\n            bob.insert(i);\\n        }\\n\\n        int target = (sum1+sum2)/2; \\n\\n        unordered_set<int> bob;\\n\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int cur=aliceSizes[i]; \\n            int y=target-sum1+cur;\\n            if(bob.find(y)!=bob.end()) return {cur,y};\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172928,
                "title": "easy-to-understand-c-solution-using-map-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        map <int,int> mp;\\n        vector <int> v(2);\\n        int sum1=0,sum2=0;\\n        for(int i:bobSizes){\\n            mp[i]++;\\n            sum2+=i;\\n        } \\n        for(int i:aliceSizes) sum1+=i;\\n        for(int i:aliceSizes){\\n            if(mp.find((sum2-sum1+i+i)/2)!=mp.end()){\\n                v[0]=i;\\n                v[1]=(sum2-sum1+i+i)/2;\\n                return v;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        map <int,int> mp;\\n        vector <int> v(2);\\n        int sum1=0,sum2=0;\\n        for(int i:bobSizes){\\n            mp[i]++;\\n            sum2+=i;\\n        } \\n        for(int i:aliceSizes) sum1+=i;\\n        for(int i:aliceSizes){\\n            if(mp.find((sum2-sum1+i+i)/2)!=mp.end()){\\n                v[0]=i;\\n                v[1]=(sum2-sum1+i+i)/2;\\n                return v;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111814,
                "title": "simplest-java-solution",
                "content": "**I know this code is little lengthy and slow but it is simplest that i can think at first thought**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : BruteForce , Linear Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    \\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        // calculating the sum of both candies and equal number of candies after swapping candies\\n        int sumAlice = sum(aliceSizes);\\n        int sumbob = sum(bobSizes);\\n        int equal = (sumAlice + sumbob)/2;\\n        \\n        //calculating the difference\\n        int diff;\\n        int vari;\\n        // vari is made to  vari  = alicesize[i] + diff\\n        /* \\n        aliceSizes[1,2,3,4,8,6]= 24 bobSizes[2,2,3,5,6,7,1] = 26\\n\\n        equal  = (24 + 26 )/2 = 25;\\n\\n        diff = 25 - 24 = 1;\\n\\n        var = diff + aliceSizes[0] == 1 + 1 = 2;\\n         \\n         linear search for  2 in bobsizes if found return [alicesSizes[0],bobSizes[i]];\\n\\n         if not then go for \\n\\n         var = diff + aliceSizes[1] = 1 + 2 = 3;\\n        \\n        now linear search  for three;\\n\\n        \\n        \\n        */\\n           if(sumAlice<equal){\\n               diff = equal - sumAlice;\\n               for(int i=0;i<aliceSizes.length;i++){\\n               vari = aliceSizes[i] + diff;\\n               for(int j=0;j<bobSizes.length;j++){\\n                   if(vari == bobSizes[j]){\\n                       return new int[]{aliceSizes[i],bobSizes[j]};\\n                   }\\n               }\\n                   \\n               }\\n           }\\n    \\n        if(sumbob<equal){\\n               diff = equal - sumbob;\\n               for(int i=0;i<bobSizes.length;i++){\\n               vari = bobSizes[i] + diff;\\n               for(int j=0;j<aliceSizes.length;j++){\\n                   if(vari == aliceSizes[j]){\\n                       return new int[]{aliceSizes[j],bobSizes[i]};\\n                   }\\n               }\\n                   \\n               }\\n           }\\n        \\n    return new int[]{0,0};\\n\\n\\n    }\\n    static int sum(int[] arr){\\n        int sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum += arr[i];\\n        }\\n        return sum;\\n    }\\n\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    \\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        // calculating the sum of both candies and equal number of candies after swapping candies\\n        int sumAlice = sum(aliceSizes);\\n        int sumbob = sum(bobSizes);\\n        int equal = (sumAlice + sumbob)/2;\\n        \\n        //calculating the difference\\n        int diff;\\n        int vari;\\n        // vari is made to  vari  = alicesize[i] + diff\\n        /* \\n        aliceSizes[1,2,3,4,8,6]= 24 bobSizes[2,2,3,5,6,7,1] = 26\\n\\n        equal  = (24 + 26 )/2 = 25;\\n\\n        diff = 25 - 24 = 1;\\n\\n        var = diff + aliceSizes[0] == 1 + 1 = 2;\\n         \\n         linear search for  2 in bobsizes if found return [alicesSizes[0],bobSizes[i]];\\n\\n         if not then go for \\n\\n         var = diff + aliceSizes[1] = 1 + 2 = 3;\\n        \\n        now linear search  for three;\\n\\n        \\n        \\n        */\\n           if(sumAlice<equal){\\n               diff = equal - sumAlice;\\n               for(int i=0;i<aliceSizes.length;i++){\\n               vari = aliceSizes[i] + diff;\\n               for(int j=0;j<bobSizes.length;j++){\\n                   if(vari == bobSizes[j]){\\n                       return new int[]{aliceSizes[i],bobSizes[j]};\\n                   }\\n               }\\n                   \\n               }\\n           }\\n    \\n        if(sumbob<equal){\\n               diff = equal - sumbob;\\n               for(int i=0;i<bobSizes.length;i++){\\n               vari = bobSizes[i] + diff;\\n               for(int j=0;j<aliceSizes.length;j++){\\n                   if(vari == aliceSizes[j]){\\n                       return new int[]{aliceSizes[j],bobSizes[i]};\\n                   }\\n               }\\n                   \\n               }\\n           }\\n        \\n    return new int[]{0,0};\\n\\n\\n    }\\n    static int sum(int[] arr){\\n        int sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum += arr[i];\\n        }\\n        return sum;\\n    }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078758,
                "title": "beating-94-using-only-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check ( vector < int > & b , int x , int sum1 , int sum2 ){\\n        int left =0  ; \\n        int right = b.size() - 1 ; \\n        while ( left <= right ){\\n            int mid = ( left + right ) / 2 ; \\n            int v = sum1 + b[mid] -x ; \\n            int c = sum2 + x - b[mid] ; \\n            if ( v == c)\\n             return mid ; \\n             if ( v < c ) \\n              left = mid + 1 ; \\n              else \\n              right = mid -1 ; \\n        }\\n        return -1 ; \\n    }\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n         sort ( b.begin() , b.end() ) ; \\n         int sum1 = 0 , sum2 = 0 ; \\n         for ( int i =0 ; i < a.size() ; i++) sum1 += a[i] ;\\n         for ( int i = 0 ; i < b.size() ; i++) sum2 +=b[i] ; \\n         vector < int > ans ( 2 ) ; \\n         for ( int i=0 ; i < a.size() ; i++) {\\n             int v = check ( b , a[i] , sum1 , sum2 ) ; \\n             if ( v == -1 ) continue;\\n             ans[0] = a[i] ; \\n             ans[1] = b[v] ; \\n             break;\\n         }\\n         return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check ( vector < int > & b , int x , int sum1 , int sum2 ){\\n        int left =0  ; \\n        int right = b.size() - 1 ; \\n        while ( left <= right ){\\n            int mid = ( left + right ) / 2 ; \\n            int v = sum1 + b[mid] -x ; \\n            int c = sum2 + x - b[mid] ; \\n            if ( v == c)\\n             return mid ; \\n             if ( v < c ) \\n              left = mid + 1 ; \\n              else \\n              right = mid -1 ; \\n        }\\n        return -1 ; \\n    }\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n         sort ( b.begin() , b.end() ) ; \\n         int sum1 = 0 , sum2 = 0 ; \\n         for ( int i =0 ; i < a.size() ; i++) sum1 += a[i] ;\\n         for ( int i = 0 ; i < b.size() ; i++) sum2 +=b[i] ; \\n         vector < int > ans ( 2 ) ; \\n         for ( int i=0 ; i < a.size() ; i++) {\\n             int v = check ( b , a[i] , sum1 , sum2 ) ; \\n             if ( v == -1 ) continue;\\n             ans[0] = a[i] ; \\n             ans[1] = b[v] ; \\n             break;\\n         }\\n         return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959108,
                "title": "my-c-solution-with-complexity-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int>v;\\n        map<int,int>m;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<aliceSizes.size();i++){\\n        sum1=sum1+aliceSizes[i];\\n\\n      }\\n        for(int i=0;i<bobSizes.size();i++){\\n        sum2=sum2+bobSizes[i];\\n        m[bobSizes[i]]=i;\\n        }\\n        int t=(sum1-sum2)/2;\\n        for(int i=0;i<aliceSizes.size();i++){\\n             if(m.count(aliceSizes[i]-t)){\\n                 v.push_back(aliceSizes[i]);\\n                 v.push_back(aliceSizes[i]-t);\\n                 break;\\n             }\\n        }\\n     \\n    \\n     return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int>v;\\n        map<int,int>m;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<aliceSizes.size();i++){\\n        sum1=sum1+aliceSizes[i];\\n\\n      }\\n        for(int i=0;i<bobSizes.size();i++){\\n        sum2=sum2+bobSizes[i];\\n        m[bobSizes[i]]=i;\\n        }\\n        int t=(sum1-sum2)/2;\\n        for(int i=0;i<aliceSizes.size();i++){\\n             if(m.count(aliceSizes[i]-t)){\\n                 v.push_back(aliceSizes[i]);\\n                 v.push_back(aliceSizes[i]-t);\\n                 break;\\n             }\\n        }\\n     \\n    \\n     return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748738,
                "title": "c-binary-search-easy-115-ms",
                "content": "```\\nint sum_a = 0, sum_b = 0;\\n        vector <int> ans;\\n        \\n        sort(bobSizes.begin(),bobSizes.end());\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n\\n        \\n        for(int i = 0; i < aliceSizes.size(); i++) {\\n            sum_a = aliceSizes[i] + sum_a;\\n        }\\n        \\n        for(int i = 0; i < bobSizes.size(); i++) {\\n            sum_b = bobSizes[i] + sum_b;\\n        }\\n        \\n        int diff = (sum_a - sum_b)/2;\\n        \\n        for(int i = 0 ; i <aliceSizes.size(); i++) {\\n        \\n        int s = 0;\\n        int e = bobSizes.size()-1;\\n        \\n        while(s<=e)\\n        {\\n            int mid = s + (e-s)/2;\\n            \\n            if(bobSizes[mid] == aliceSizes[i]-diff) {\\n                ans.push_back(aliceSizes[i]);\\n                ans.push_back(bobSizes[mid]);\\n                return ans;\\n            }\\n            \\n            else if(bobSizes[mid] < aliceSizes[i]-diff) {\\n                s = mid + 1;\\n            }\\n            \\n            else if(bobSizes[mid] > aliceSizes[i]-diff) {\\n                e = mid - 1;\\n            }\\n              \\n        }    \\n    }\\n        \\n        return ans;",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint sum_a = 0, sum_b = 0;\\n        vector <int> ans;\\n        \\n        sort(bobSizes.begin(),bobSizes.end());\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n\\n        \\n        for(int i = 0; i < aliceSizes.size(); i++) {\\n            sum_a = aliceSizes[i] + sum_a;\\n        }\\n        \\n        for(int i = 0; i < bobSizes.size(); i++) {\\n            sum_b = bobSizes[i] + sum_b;\\n        }\\n        \\n        int diff = (sum_a - sum_b)/2;\\n        \\n        for(int i = 0 ; i <aliceSizes.size(); i++) {\\n        \\n        int s = 0;\\n        int e = bobSizes.size()-1;\\n        \\n        while(s<=e)\\n        {\\n            int mid = s + (e-s)/2;\\n            \\n            if(bobSizes[mid] == aliceSizes[i]-diff) {\\n                ans.push_back(aliceSizes[i]);\\n                ans.push_back(bobSizes[mid]);\\n                return ans;\\n            }\\n            \\n            else if(bobSizes[mid] < aliceSizes[i]-diff) {\\n                s = mid + 1;\\n            }\\n            \\n            else if(bobSizes[mid] > aliceSizes[i]-diff) {\\n                e = mid - 1;\\n            }\\n              \\n        }    \\n    }\\n        \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2707860,
                "title": "java",
                "content": "//brute force\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA=0,sumB=0;\\n        for(int i=0;i<aliceSizes.length;i++)\\n            sumA+=aliceSizes[i];\\n        for(int i=0;i<bobSizes.length;i++)\\n            sumB+=bobSizes[i];\\n\\n        int diff =(sumA-sumB)/2;\\n        \\n        for(int i=0;i<aliceSizes.length;i++)\\n            for(int j=0;j<bobSizes.length;j++)\\n                if(aliceSizes[i]-bobSizes[j]==diff)\\n                    return new int[]{aliceSizes[i],bobSizes[j]};\\n                return null;\\n         \\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sumA=0,sumB=0;\\n        for(int i=0;i<aliceSizes.length;i++)\\n            sumA+=aliceSizes[i];\\n        for(int i=0;i<bobSizes.length;i++)\\n            sumB+=bobSizes[i];\\n\\n        int diff =(sumA-sumB)/2;\\n        \\n        for(int i=0;i<aliceSizes.length;i++)\\n            for(int j=0;j<bobSizes.length;j++)\\n                if(aliceSizes[i]-bobSizes[j]==diff)\\n                    return new int[]{aliceSizes[i],bobSizes[j]}",
                "codeTag": "Java"
            },
            {
                "id": 2624282,
                "title": "find-the-difference-from-the-mid-i-e-sum-of-array1-and-array2-2-and-search-it-in-other-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& as, vector<int>& bs) {\\n        \\n        \\n        int n = as.size();\\n        int m = bs.size();\\n        \\n        int val1 = accumulate(as.begin(),as.end(),0);\\n        int val2 = accumulate(bs.begin(),bs.end(),0);\\n        unordered_map<int ,int> mp,mp2;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            mp[bs[i]] = i;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp2[as[i]] = i;\\n        }\\n        \\n        if(val1 == val2)\\n            return {0,0};\\n        \\n        int mid = (val1+val2)/2;\\n        if(mid>val1){\\n             for(int i=0;i<n;i++)\\n             {\\n                 int f = mid-(val1-as[i]);\\n                 if(mp.count(f))\\n                 {\\n                     return {as[i],f};\\n                 }\\n             }\\n        }\\n        \\n        if(mid>val2){\\n             for(int i=0;i<m;i++)\\n             {\\n                 int f= mid-(val2-bs[i]);\\n                 if(mp2.count(f))\\n                 {\\n                     return {f,bs[i]};\\n                 }\\n             }\\n        }\\n        \\n        return {0,0};\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& as, vector<int>& bs) {\\n        \\n        \\n        int n = as.size();\\n        int m = bs.size();\\n        \\n        int val1 = accumulate(as.begin(),as.end(),0);\\n        int val2 = accumulate(bs.begin(),bs.end(),0);\\n        unordered_map<int ,int> mp,mp2;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            mp[bs[i]] = i;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp2[as[i]] = i;\\n        }\\n        \\n        if(val1 == val2)\\n            return {0,0};\\n        \\n        int mid = (val1+val2)/2;\\n        if(mid>val1){\\n             for(int i=0;i<n;i++)\\n             {\\n                 int f = mid-(val1-as[i]);\\n                 if(mp.count(f))\\n                 {\\n                     return {as[i],f};\\n                 }\\n             }\\n        }\\n        \\n        if(mid>val2){\\n             for(int i=0;i<m;i++)\\n             {\\n                 int f= mid-(val2-bs[i]);\\n                 if(mp2.count(f))\\n                 {\\n                     return {f,bs[i]};\\n                 }\\n             }\\n        }\\n        \\n        return {0,0};\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570047,
                "title": "js-faster-than-100-best-solution-with-hashmap",
                "content": "![image](https://assets.leetcode.com/users/images/9d7beb52-cddd-4522-babd-83eaf30b4061_1663058151.6730382.png)\\n```\\nvar fairCandySwap = function(aliceSizes, bobSizes) {\\n    const totalAliceSize = aliceSizes.reduce((prev, current) => prev + current, 0);\\n    const totalBobSize = bobSizes.reduce((prev, current) => prev + current, 0);\\n    \\n    const resolve = (array1, array2, difference) => {\\n        const hashmap = new Map();\\n        for (let i = 0; i < array1.length; i++) {\\n            hashmap.set(array1[i], i);\\n        }\\n        \\n        for (let i = 0; i < array2.length; i++) {\\n            if (hashmap.has(array2[i] + difference/2)) return [array2[i] + difference/2, array2[i]];\\n        }\\n    }\\n    \\n    return resolve(aliceSizes, bobSizes, totalAliceSize - totalBobSize);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fairCandySwap = function(aliceSizes, bobSizes) {\\n    const totalAliceSize = aliceSizes.reduce((prev, current) => prev + current, 0);\\n    const totalBobSize = bobSizes.reduce((prev, current) => prev + current, 0);\\n    \\n    const resolve = (array1, array2, difference) => {\\n        const hashmap = new Map();\\n        for (let i = 0; i < array1.length; i++) {\\n            hashmap.set(array1[i], i);\\n        }\\n        \\n        for (let i = 0; i < array2.length; i++) {\\n            if (hashmap.has(array2[i] + difference/2)) return [array2[i] + difference/2, array2[i]];\\n        }\\n    }\\n    \\n    return resolve(aliceSizes, bobSizes, totalAliceSize - totalBobSize);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2489838,
                "title": "c-short-solution-no-map-o-n-time-paperba1l",
                "content": "1) the final sum has to be equal to (aliceSum + bobSum) / 2, lets call it **sm**\\n2) Pick one array, either alice\\'s or bob\\'s does not matter.\\n3) remove one box from the selected list\\n4) the sum of the list reduces by box size which was removed \\n5) if we now want to make the total sum of the selected list  equal to **sm** then we need exactly **(sm2 - box_removed)** from the other list.\\n6) we can use a map, but can use an array to just flag the presence of an integer in a list.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sm1 = 0;\\n        int sm2 = 0;\\n        for(int s : aliceSizes) {\\n            sm1+=s;\\n        }\\n        \\n        int mpp[100000+4];\\n        memset(mpp, 0, sizeof(mpp));\\n        for(int s : bobSizes) {\\n            sm2+=s;\\n            mpp[s]++;\\n        }\\n        \\n        int sm = (sm2 + sm1);\\n        if((sm%2) == 1) {\\n            return {};\\n        }\\n        \\n        sm/=2;\\n        \\n        for(int s : aliceSizes) {\\n            int new_alice_sm = sm1 - s;\\n            if(new_alice_sm >= sm) {\\n                continue;\\n            }\\n            \\n            int extra_wt_needed = sm - new_alice_sm;\\n            if(extra_wt_needed > (1e5)) {\\n                continue;\\n            }\\n            if(mpp[extra_wt_needed] != 0) {\\n                return {s, extra_wt_needed};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        int sm1 = 0;\\n        int sm2 = 0;\\n        for(int s : aliceSizes) {\\n            sm1+=s;\\n        }\\n        \\n        int mpp[100000+4];\\n        memset(mpp, 0, sizeof(mpp));\\n        for(int s : bobSizes) {\\n            sm2+=s;\\n            mpp[s]++;\\n        }\\n        \\n        int sm = (sm2 + sm1);\\n        if((sm%2) == 1) {\\n            return {};\\n        }\\n        \\n        sm/=2;\\n        \\n        for(int s : aliceSizes) {\\n            int new_alice_sm = sm1 - s;\\n            if(new_alice_sm >= sm) {\\n                continue;\\n            }\\n            \\n            int extra_wt_needed = sm - new_alice_sm;\\n            if(extra_wt_needed > (1e5)) {\\n                continue;\\n            }\\n            if(mpp[extra_wt_needed] != 0) {\\n                return {s, extra_wt_needed};\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489060,
                "title": "java-97-21-faster-solution-o-n",
                "content": "class Solution {\\n\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        int totalA=0;\\n        int totalB=0;\\n        \\n        for(int a:aliceSizes){\\n            totalA = totalA + a;\\n        }\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int b:bobSizes){\\n            totalB = totalB + b;\\n            set.add(b);\\n        }\\n        \\n        int delta = (totalB-totalA)/2;\\n        int ans[] = new int[2];\\n        for(int a:aliceSizes){\\n            if(set.contains(delta+a)){\\n                ans[0]=a;\\n                ans[1]=delta+a;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        \\n        int totalA=0;\\n        int totalB=0;\\n        \\n        for(int a:aliceSizes){\\n            totalA = totalA + a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2423557,
                "title": "python-o-n-solution-using-set",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        sumAlice, sumBob, ans = sum(aliceSizes), sum(bobSizes), []\\n        diff = (sumBob - sumAlice) / 2\\n        setAliceSizes = set(aliceSizes)\\n        for bobItem in bobSizes:\\n            if bobItem - diff in setAliceSizes:\\n                ans.append(int(bobItem - diff))\\n                ans.append(bobItem)\\n                return ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        sumAlice, sumBob, ans = sum(aliceSizes), sum(bobSizes), []\\n        diff = (sumBob - sumAlice) / 2\\n        setAliceSizes = set(aliceSizes)\\n        for bobItem in bobSizes:\\n            if bobItem - diff in setAliceSizes:\\n                ans.append(int(bobItem - diff))\\n                ans.append(bobItem)\\n                return ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408387,
                "title": "java-solution-for-beginners-and-intermediate",
                "content": "Beginners ....sol works but very slow (brute force)\\n\\n```\\npublic int[] fairCandySwap(int[] arr1, int[] arr2) {\\n        \\n        int sum1 = IntStream.of(arr1).sum();\\n\\t\\tint sum2 = IntStream.of(arr2).sum();\\n        \\n        for(int i=0;i <arr1.length; i++) {\\n\\t\\t\\tfor(int j=0;j <arr2.length; j++) {\\n\\t\\t\\t\\tif((sum1-arr1[i]) + arr2[j] == (sum2-arr2[j])+arr1[i]) {\\n\\t\\t\\t\\t    return new int[] {arr1[i],arr2[j]};\\n\\t\\t     \\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn new int[] {-1,-1};\\n    }\\n```\\n\\n\\nsol2 two pointer approach\\n\\nspeed is better\\n\\n```\\nArrays.sort(arr1);\\n        Arrays.sort(arr2);\\n       int sum1 = IntStream.of(arr1).sum();\\n\\t\\tint sum2 = IntStream.of(arr2).sum();\\n\\t\\t\\n\\t\\tint i=0,j=0;\\n\\t\\t\\n\\t\\twhile(i < arr1.length && j < arr2.length) {\\n\\t\\t\\t\\n\\t\\t\\tint sum1Replaced = (sum1-arr1[i]) + arr2[j];\\n\\t\\t\\tint sum2Replaced = (sum2-arr2[j]) + arr1[i];\\n\\n\\t\\t\\t\\n\\t\\t\\tif(sum1Replaced == sum2Replaced) {\\n\\t\\t\\t\\treturn new int[] {arr1[i],arr2[j]};\\n\\t\\t\\t}\\n\\t\\t\\tif(sum1Replaced > sum2Replaced) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn null;\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] fairCandySwap(int[] arr1, int[] arr2) {\\n        \\n        int sum1 = IntStream.of(arr1).sum();\\n\\t\\tint sum2 = IntStream.of(arr2).sum();\\n        \\n        for(int i=0;i <arr1.length; i++) {\\n\\t\\t\\tfor(int j=0;j <arr2.length; j++) {\\n\\t\\t\\t\\tif((sum1-arr1[i]) + arr2[j] == (sum2-arr2[j])+arr1[i]) {\\n\\t\\t\\t\\t    return new int[] {arr1[i],arr2[j]};\\n\\t\\t     \\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn new int[] {-1,-1};\\n    }\\n```\n```\\nArrays.sort(arr1);\\n        Arrays.sort(arr2);\\n       int sum1 = IntStream.of(arr1).sum();\\n\\t\\tint sum2 = IntStream.of(arr2).sum();\\n\\t\\t\\n\\t\\tint i=0,j=0;\\n\\t\\t\\n\\t\\twhile(i < arr1.length && j < arr2.length) {\\n\\t\\t\\t\\n\\t\\t\\tint sum1Replaced = (sum1-arr1[i]) + arr2[j];\\n\\t\\t\\tint sum2Replaced = (sum2-arr2[j]) + arr1[i];\\n\\n\\t\\t\\t\\n\\t\\t\\tif(sum1Replaced == sum2Replaced) {\\n\\t\\t\\t\\treturn new int[] {arr1[i],arr2[j]};\\n\\t\\t\\t}\\n\\t\\t\\tif(sum1Replaced > sum2Replaced) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn null;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325365,
                "title": "c-2-apparoches-binary-search-set-easy-to-understand",
                "content": "Please Upvote if you like this apparoach\\n1 : Binary Search \\n```\\nclass Solution {\\nprivate:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid]>target)\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int aSum = 0;\\n        int bSum = 0;\\n\\t\\t//Finding total size of Alice\\n        for(auto x: aliceSizes)\\n        {\\n            aSum += x;\\n        }\\n\\t\\t//Finding total size of Bob\\n        for(auto x: bobSizes)\\n        {\\n            bSum += x;\\n        }\\n        // we take elements one by one that if exchange this the total size got balance\\n        for(int i = 0;i<aliceSizes.size();i++)\\n        {\\n           int alice = aSum - aliceSizes[i];        //Remove the element for checking from total\\n           int bob = bSum + aliceSizes[i];       //Accept the element from alice\\n            \\n           int val = (bob - alice)/2;                //This size which now bob has to give to Alice\\n           int index = search(bobSizes,val);\\n           if(index != -1)                               //If the val is present in BobSizes than push both\\n           {                                                   //sizes in ans\\n               ans.push_back(aliceSizes[i]);\\n               ans.push_back(bobSizes[index]);\\n               return ans;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n2 : By set\\n\\n```\\n vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        int aSum = 0;\\n        int bSum = 0;\\n        for(auto x: aliceSizes)\\n        {\\n            aSum += x;\\n        }\\n        for(auto x: bobSizes)\\n        {\\n            bSum += x;\\n        }\\n        int delta = (bSum - aSum)/2;\\n        \\n        unordered_set<int> s(bobSizes.begin(),bobSizes.end());\\n        \\n        for(auto x : aliceSizes)\\n        {\\n              if(s.find(x + delta) != s.end())\\n              {\\n                  ans.push_back(x);\\n                  ans.push_back(x+delta);\\n                  break;\\n              }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid]>target)\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int aSum = 0;\\n        int bSum = 0;\\n\\t\\t//Finding total size of Alice\\n        for(auto x: aliceSizes)\\n        {\\n            aSum += x;\\n        }\\n\\t\\t//Finding total size of Bob\\n        for(auto x: bobSizes)\\n        {\\n            bSum += x;\\n        }\\n        // we take elements one by one that if exchange this the total size got balance\\n        for(int i = 0;i<aliceSizes.size();i++)\\n        {\\n           int alice = aSum - aliceSizes[i];        //Remove the element for checking from total\\n           int bob = bSum + aliceSizes[i];       //Accept the element from alice\\n            \\n           int val = (bob - alice)/2;                //This size which now bob has to give to Alice\\n           int index = search(bobSizes,val);\\n           if(index != -1)                               //If the val is present in BobSizes than push both\\n           {                                                   //sizes in ans\\n               ans.push_back(aliceSizes[i]);\\n               ans.push_back(bobSizes[index]);\\n               return ans;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        vector<int> ans;\\n        int aSum = 0;\\n        int bSum = 0;\\n        for(auto x: aliceSizes)\\n        {\\n            aSum += x;\\n        }\\n        for(auto x: bobSizes)\\n        {\\n            bSum += x;\\n        }\\n        int delta = (bSum - aSum)/2;\\n        \\n        unordered_set<int> s(bobSizes.begin(),bobSizes.end());\\n        \\n        for(auto x : aliceSizes)\\n        {\\n              if(s.find(x + delta) != s.end())\\n              {\\n                  ans.push_back(x);\\n                  ans.push_back(x+delta);\\n                  break;\\n              }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2295325,
                "title": "fair-candy-swap",
                "content": "# ***python 3  Binary Search solution :***\\n```\\nclass Solution:\\n    def bs (self,arr,j):\\n        l=0\\n        r= len(arr)-1\\n        while l<=r:\\n            m = (l+r)//2\\n            if arr[m]==j:\\n                return True\\n            if  arr[m]<j:\\n                l=m+1\\n            else:\\n                r= m-1\\n        return False \\n    \\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        aliceSum= sum(aliceSizes)\\n        bobSum = sum(bobSizes)\\n        aliceSizes.sort()\\n        const = (aliceSum-bobSum)//2\\n        for i in bobSizes:\\n            diff = i+const\\n            x = self.bs(aliceSizes,diff)\\n            if x:\\n                return [diff,i]\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def bs (self,arr,j):\\n        l=0\\n        r= len(arr)-1\\n        while l<=r:\\n            m = (l+r)//2\\n            if arr[m]==j:\\n                return True\\n            if  arr[m]<j:\\n                l=m+1\\n            else:\\n                r= m-1\\n        return False \\n    \\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        aliceSum= sum(aliceSizes)\\n        bobSum = sum(bobSizes)\\n        aliceSizes.sort()\\n        const = (aliceSum-bobSum)//2\\n        for i in bobSizes:\\n            diff = i+const\\n            x = self.bs(aliceSizes,diff)\\n            if x:\\n                return [diff,i]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264776,
                "title": "fastest-java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int a=0,b=0;\\n        for(int i:aliceSizes)\\n            a+=i;\\n        HashSet<Integer> hset = new HashSet<>();\\n        for(int i:bobSizes)\\n        {\\n            b+=i;\\n            hset.add(i);\\n        }\\n        int del = (b-a)/2;\\n        for(int i:aliceSizes)\\n            if(hset.contains(i+del))\\n                return new int[]{i,i+del};\\n        return null;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int a=0,b=0;\\n        for(int i:aliceSizes)\\n            a+=i;\\n        HashSet<Integer> hset = new HashSet<>();\\n        for(int i:bobSizes)\\n        {\\n            b+=i;\\n            hset.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2254710,
                "title": "faster-than-86-java",
                "content": "```\\n\\n```import java.util.*;\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int k=0,l=0,m=0;\\n        for(int i=0;i<aliceSizes.length;i++)\\n             k+=aliceSizes[i];\\n        for(int i=0;i<bobSizes.length;i++)\\n            l+=bobSizes[i];\\n        int d= (l-k)/2;\\n        Arrays.sort(bobSizes);\\n        for(int i=0;i<aliceSizes.length;i++)\\n        {int y=bin(bobSizes,aliceSizes[i]+d);\\n            if(y!=-1)\\n                return new int[]{aliceSizes[i],bobSizes[y]};\\n        }\\n        return new int[]{-1,-1};\\n    }\\n     int bin(int nums2[], int t){\\n       int s=0,e=nums2.length-1;\\n         while(s<=e)\\n         {\\n             int mid=s+(e-s)/2;\\n             if(nums2[mid]<t)\\n             {  s=mid+1;}\\n             else if (nums2[mid]>t) \\n             { e=mid-1;}\\n             else\\n             {return mid;}\\n         }\\n         return -1;\\n    }\\n\\n}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2149984,
                "title": "c-simple-easy-to-understand-with-explanation",
                "content": "**Intuition:**\\nSuppose I have **m** candies and you have **n** candies. We should each have **(m + n) / 2** candies to have the same number of candies. So the net number of candies I should take from you is **(n - m) / 2** candies. If I give you **k** candies, I should take back **(n - m) / 2 + k** candies from you. In short, simply check if you have **(n - m) / 2 + k** candies for **k** candies I have in each box.\\n\\n**Code :**\\n```\\nclass Solution {\\n public:\\n  vector<int> FairCandySwap(const vector<int> &me, const vector<int> &you) {\\n    unordered_set<int> your_set(you.begin(), you.end());\\n    int give_me = (accumulate(you.begin(), you.end(), 0) -\\n                   accumulate(me.begin(), me.end(), 0)) / 2;\\n\\n    auto it = me.begin();\\n    while (!your_set.count(give_me + *it)) it++;\\n    return {*it, give_me + *it};\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> FairCandySwap(const vector<int> &me, const vector<int> &you) {\\n    unordered_set<int> your_set(you.begin(), you.end());\\n    int give_me = (accumulate(you.begin(), you.end(), 0) -\\n                   accumulate(me.begin(), me.end(), 0)) / 2;\\n\\n    auto it = me.begin();\\n    while (!your_set.count(give_me + *it)) it++;\\n    return {*it, give_me + *it};\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050865,
                "title": "simple-java-solution-without-hash-map",
                "content": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes){\\n      \\n\\n        int s1=0;\\n        int s2 =0;\\n        int p = aliceSizes.length;\\n        int q =  bobSizes.length;\\n        \\n        for (int i =0; i <p ; i++){\\n           s1 =  s1 + aliceSizes[i];     \\n        }\\n        \\n          for (int i =0; i <q ; i++){\\n           s2 =  s2 + bobSizes[i];     \\n    }\\n        int delta = (s1 -s2)/ 2;\\n        \\n   \\n        \\n        for (int i = 0;  i < p;i++){\\n            int x = aliceSizes[i];\\n            \\n            for (int j =0 ; j < q;j++){\\n                int y = bobSizes[j];\\n                if (y == x - delta){\\n                    return new int [] {x , y};\\n                }\\n            }\\n            \\n        }\\n        return  new int [] {-1,-1};\\n}\\n}****",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes){\\n      \\n\\n        int s1=0;\\n        int s2 =0;\\n        int p = aliceSizes.length;\\n        int q =  bobSizes.length;\\n        \\n        for (int i =0; i <p ; i++){\\n           s1 =  s1 + aliceSizes[i];     \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2016401,
                "title": "92-faster-java-simple-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        Set<Integer>set=new HashSet<>();\\n        int candy2=0,candy1=0;\\n        for(int c : bobSizes){\\n            set.add(c);\\n            candy2+=c;\\n        }\\n        for(int c : aliceSizes) candy1+=c;\\n        //transfer is no of more candies will alice finally get \\n        int transfer=(candy2-candy1)/2;\\n        for(int num  : aliceSizes){\\n            if(set.contains(num+trans)) return new int[]{num,num+trans};\\n        }\\n        return new int[]{};\\n    }\\n}\\n```\\n\\nTime : O(n) linear time\\nSpace : O(linear extra space)\\n\\nplease upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        Set<Integer>set=new HashSet<>();\\n        int candy2=0,candy1=0;\\n        for(int c : bobSizes){\\n            set.add(c);\\n            candy2+=c;\\n        }\\n        for(int c : aliceSizes) candy1+=c;\\n        //transfer is no of more candies will alice finally get \\n        int transfer=(candy2-candy1)/2;\\n        for(int num  : aliceSizes){\\n            if(set.contains(num+trans)) return new int[]{num,num+trans};\\n        }\\n        return new int[]{};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989020,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int n=aliceSizes.length;\\n        int m=bobSizes.length;\\n        int []ans=new int [2];\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(int i:aliceSizes)\\n        {\\n            sum1=sum1+i;\\n        }\\n        for(int j:bobSizes)\\n        {\\n            sum2=sum2+j;\\n        }\\n        int target=(sum2-sum1)/2;\\n        \\n        \\n      ans=takeFairCandySwap(aliceSizes,bobSizes,target);\\n           return ans;\\n    }\\n    public int[] takeFairCandySwap(int []a,int []b,int target)\\n    {\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<b.length;j++)\\n            {\\n                if(b[j]==a[i]+target)            // we have to satisfy this condition for fair candy swap\\n                    return new int[]{a[i],b[j]};\\n            }\\n        }\\n        return new int[] {-1,-1};  \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int n=aliceSizes.length;\\n        int m=bobSizes.length;\\n        int []ans=new int [2];\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(int i:aliceSizes)\\n        {\\n            sum1=sum1+i;\\n        }\\n        for(int j:bobSizes)\\n        {\\n            sum2=sum2+j;\\n        }\\n        int target=(sum2-sum1)/2;\\n        \\n        \\n      ans=takeFairCandySwap(aliceSizes,bobSizes,target);\\n           return ans;\\n    }\\n    public int[] takeFairCandySwap(int []a,int []b,int target)\\n    {\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<b.length;j++)\\n            {\\n                if(b[j]==a[i]+target)            // we have to satisfy this condition for fair candy swap\\n                    return new int[]{a[i],b[j]};\\n            }\\n        }\\n        return new int[] {-1,-1};  \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959695,
                "title": "go-hashmap-binary-search-clear-solutions",
                "content": "HashMap:\\n```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n    alice, bob, aliceCandies := 0, 0, map[int]bool{}\\n    for _, candy := range aliceSizes { alice += candy; aliceCandies[candy] = true }\\n    for _, candy := range bobSizes { bob += candy }\\n    delta := (alice-bob)/2\\n    for _, b := range bobSizes { if aliceCandies[b+delta] { return []int{b+delta, b} } }\\n    return nil\\n}\\n```\\n\\nBinary Search:\\n```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n    alice, bob := 0, 0\\n    for _, candy := range aliceSizes { alice += candy }\\n    for _, candy := range bobSizes { bob += candy }\\n    delta := (alice-bob)/2\\n    sort.Ints(aliceSizes)\\n    for _, b := range bobSizes { if a := binarySearch(aliceSizes, b+delta); a != -1 { return []int{a, b} } }\\n    return nil\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    left, right := 0, len(arr)-1\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        if arr[mid] == target { return arr[mid] }\\n        if arr[mid] < target { left = mid+1 } else { right = mid-1 }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n    alice, bob, aliceCandies := 0, 0, map[int]bool{}\\n    for _, candy := range aliceSizes { alice += candy; aliceCandies[candy] = true }\\n    for _, candy := range bobSizes { bob += candy }\\n    delta := (alice-bob)/2\\n    for _, b := range bobSizes { if aliceCandies[b+delta] { return []int{b+delta, b} } }\\n    return nil\\n}\\n```\n```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n    alice, bob := 0, 0\\n    for _, candy := range aliceSizes { alice += candy }\\n    for _, candy := range bobSizes { bob += candy }\\n    delta := (alice-bob)/2\\n    sort.Ints(aliceSizes)\\n    for _, b := range bobSizes { if a := binarySearch(aliceSizes, b+delta); a != -1 { return []int{a, b} } }\\n    return nil\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    left, right := 0, len(arr)-1\\n    for left <= right {\\n        mid := left+(right-left)/2\\n        if arr[mid] == target { return arr[mid] }\\n        if arr[mid] < target { left = mid+1 } else { right = mid-1 }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850451,
                "title": "java-sol-binary-search-approach",
                "content": "```\\nclass Solution {\\n    \\n    int sum(int[] arr){\\n        int sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n    \\n    boolean binarySearch(int[] arr,int target){\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low + (high-low)/2;\\n            if(arr[mid] == target){\\n                return true;\\n            }\\n            if(arr[mid] > target){\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int SumA = sum(aliceSizes);\\n        int SumB = sum(bobSizes);\\n        \\n        Arrays.sort(aliceSizes);\\n        Arrays.sort(bobSizes);\\n        \\n        int delta = ( SumB- SumA ) / 2;\\n        \\n        for(int i=0; i<aliceSizes.length; i++){\\n            if( binarySearch(bobSizes, aliceSizes[i] + delta) ){\\n                return new int[]{ aliceSizes[i], aliceSizes[i] + delta};\\n            }\\n        }\\n        throw null;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int sum(int[] arr){\\n        int sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n    \\n    boolean binarySearch(int[] arr,int target){\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low + (high-low)/2;\\n            if(arr[mid] == target){\\n                return true;\\n            }\\n            if(arr[mid] > target){\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int SumA = sum(aliceSizes);\\n        int SumB = sum(bobSizes);\\n        \\n        Arrays.sort(aliceSizes);\\n        Arrays.sort(bobSizes);\\n        \\n        int delta = ( SumB- SumA ) / 2;\\n        \\n        for(int i=0; i<aliceSizes.length; i++){\\n            if( binarySearch(bobSizes, aliceSizes[i] + delta) ){\\n                return new int[]{ aliceSizes[i], aliceSizes[i] + delta};\\n            }\\n        }\\n        throw null;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831641,
                "title": "python-2-solutions-o-n-and-o-nlog-n",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        totA = sum(aliceSizes)\\n        totB = 0\\n        setB = set()\\n        for n in bobSizes:\\n            totB += n\\n            setB.add(n)\\n        for boxA in aliceSizes:\\n\\t\\t    # new_totB = new_totA -->\\n\\t\\t    # totB - boxB + boxA = totA - boxA + boxB\\n            boxB = (totB + 2 * boxA - totA) // 2\\n            if boxB in setB:   # O(1)\\n                return [boxA, boxB]\\n```\\nTIME COMPLEXITY: O(n)\\n\\n```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        aliceSizes.sort()\\n        bobSizes.sort()\\n        totA , totB = sum(aliceSizes), sum(bobSizes)\\n        i, j = 0, 0\\n        while True:\\n            new_totA = totA - aliceSizes[i] + bobSizes[j]\\n            new_totB = totB - bobSizes[j] + aliceSizes[i]\\n            if new_totA == new_totB:\\n                return [aliceSizes[i], bobSizes[j]]\\n            elif new_totA > new_totB:\\n                i += 1\\n            else:\\n                j += 1\\n```\\nTIME COMPLEXITY: O(nlog(n))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        totA = sum(aliceSizes)\\n        totB = 0\\n        setB = set()\\n        for n in bobSizes:\\n            totB += n\\n            setB.add(n)\\n        for boxA in aliceSizes:\\n\\t\\t    # new_totB = new_totA -->\\n\\t\\t    # totB - boxB + boxA = totA - boxA + boxB\\n            boxB = (totB + 2 * boxA - totA) // 2\\n            if boxB in setB:   # O(1)\\n                return [boxA, boxB]\\n```\n```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        aliceSizes.sort()\\n        bobSizes.sort()\\n        totA , totB = sum(aliceSizes), sum(bobSizes)\\n        i, j = 0, 0\\n        while True:\\n            new_totA = totA - aliceSizes[i] + bobSizes[j]\\n            new_totB = totB - bobSizes[j] + aliceSizes[i]\\n            if new_totA == new_totB:\\n                return [aliceSizes[i], bobSizes[j]]\\n            elif new_totA > new_totB:\\n                i += 1\\n            else:\\n                j += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769729,
                "title": "c-clear-solution-with-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        int sum1 = 0,sum2 = 0;\\n        int x = 0,y = 0;\\n        for(int i=0;i<aliceSizes.size();i++) sum1 += aliceSizes[i];\\n        for(int i=0;i<bobSizes.size();i++) sum2 += bobSizes[i];\\n        vector<int> ans;\\n        int tsum1 = sum1,tsum2 = sum2;\\n        while(x<aliceSizes.size() && y<bobSizes.size()){\\n            sum1 -= aliceSizes[x];\\n            sum1 += bobSizes[y];\\n            sum2 -= bobSizes[y];\\n            sum2 += aliceSizes[x];\\n            if(sum1==sum2){\\n                ans.push_back(aliceSizes[x]);\\n                ans.push_back(bobSizes[y]);\\n                break;\\n            }\\n            else if(sum1>sum2) x++;\\n            else y++;\\n            sum1 = tsum1;\\n            sum2 = tsum2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n   **Let me know if you want me to explain**",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        int sum1 = 0,sum2 = 0;\\n        int x = 0,y = 0;\\n        for(int i=0;i<aliceSizes.size();i++) sum1 += aliceSizes[i];\\n        for(int i=0;i<bobSizes.size();i++) sum2 += bobSizes[i];\\n        vector<int> ans;\\n        int tsum1 = sum1,tsum2 = sum2;\\n        while(x<aliceSizes.size() && y<bobSizes.size()){\\n            sum1 -= aliceSizes[x];\\n            sum1 += bobSizes[y];\\n            sum2 -= bobSizes[y];\\n            sum2 += aliceSizes[x];\\n            if(sum1==sum2){\\n                ans.push_back(aliceSizes[x]);\\n                ans.push_back(bobSizes[y]);\\n                break;\\n            }\\n            else if(sum1>sum2) x++;\\n            else y++;\\n            sum1 = tsum1;\\n            sum2 = tsum2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718367,
                "title": "java-solution",
                "content": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n      int sumA = 0;\\n        int sumB=0;\\n        for(int i=0 ;i<aliceSizes.length;i++){\\n        sumA += aliceSizes[i];\\n        }\\n        int[] ans = new int[2];\\n        Set<Integer> bob = new HashSet();\\n        \\n         for(int j=0 ;j<bobSizes.length;j++){\\n        sumB += bobSizes[j];\\n        bob.add(bobSizes[j]);\\n        }\\n        \\n        int delta = (sumB-sumA)/2;\\n        \\n        for(int x=0 ;x<aliceSizes.length;x++){\\n       if(bob.contains(aliceSizes[x]+delta)){\\n           ans[0]=aliceSizes[x];\\n           ans[1]=aliceSizes[x]+delta;\\n           return ans;\\n       }\\n        \\n        }\\n         \\n        \\n   return ans;     \\n      \\n      }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n      int sumA = 0;\\n        int sumB=0;\\n        for(int i=0 ;i<aliceSizes.length;i++){\\n        sumA += aliceSizes[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1690091,
                "title": "kotlin-solution-faster-than-60",
                "content": "```\\nclass Solution {\\n    fun fairCandySwap(aliceSizes: IntArray, bobSizes: IntArray): IntArray {\\n        val aliceSum = aliceSizes.sum()\\n        val bobSum = bobSizes.sum()\\n        val target = (aliceSum - bobSum) / 2\\n        val aliceHash = aliceSizes.toHashSet()\\n        val bobHash = bobSizes.toHashSet()\\n        var x: Int = 0\\n        var y: Int = 0\\n        for (a in aliceHash) {\\n\\t\\t// always calculating how many bob will get from alice\\n\\t\\t// can be (+) or can be (-)\\n            if (bobHash.contains(a - target)){\\n                x=a;\\n                y=a-target\\n            }\\n        }\\n        return intArrayOf(x,y)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun fairCandySwap(aliceSizes: IntArray, bobSizes: IntArray): IntArray {\\n        val aliceSum = aliceSizes.sum()\\n        val bobSum = bobSizes.sum()\\n        val target = (aliceSum - bobSum) / 2\\n        val aliceHash = aliceSizes.toHashSet()\\n        val bobHash = bobSizes.toHashSet()\\n        var x: Int = 0\\n        var y: Int = 0\\n        for (a in aliceHash) {\\n\\t\\t// always calculating how many bob will get from alice\\n\\t\\t// can be (+) or can be (-)\\n            if (bobHash.contains(a - target)){\\n                x=a;\\n                y=a-target\\n            }\\n        }\\n        return intArrayOf(x,y)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672645,
                "title": "java-not-optimal",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum1=0,sum2=0,n1=aliceSizes.length,n2=bobSizes.length;\\n        for(int i=0;i<n1;i++) //Number of candies Alice has\\n        {\\n            sum1+=aliceSizes[i];\\n        }\\n        for(int i=0;i<n2;i++) //Number of candies Bob has\\n        {\\n            sum2+=bobSizes[i];\\n        }\\n        int common=(sum1+sum2)/2; //Candies both should have\\n        sum1=common-sum1; //Candies Alice need\\n        int ans[]=new int[2];\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<n2;i++) //Put Bob\\'s candies in a set\\n        {\\n            set.add(bobSizes[i]);\\n        }\\n        for(int i=0;i<n1;i++)\\n        {\\n            if(set.contains(aliceSizes[i]+sum1)) //aliceneed + aliceCandy == candy Bob has then \\n            {\\n                ans[0]=aliceSizes[i];\\n                ans[1]=aliceSizes[i]+sum1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int sum1=0,sum2=0,n1=aliceSizes.length,n2=bobSizes.length;\\n        for(int i=0;i<n1;i++) //Number of candies Alice has\\n        {\\n            sum1+=aliceSizes[i];\\n        }\\n        for(int i=0;i<n2;i++) //Number of candies Bob has\\n        {\\n            sum2+=bobSizes[i];\\n        }\\n        int common=(sum1+sum2)/2; //Candies both should have\\n        sum1=common-sum1; //Candies Alice need\\n        int ans[]=new int[2];\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<n2;i++) //Put Bob\\'s candies in a set\\n        {\\n            set.add(bobSizes[i]);\\n        }\\n        for(int i=0;i<n1;i++)\\n        {\\n            if(set.contains(aliceSizes[i]+sum1)) //aliceneed + aliceCandy == candy Bob has then \\n            {\\n                ans[0]=aliceSizes[i];\\n                ans[1]=aliceSizes[i]+sum1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662643,
                "title": "python-simple-readable-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef fairCandySwap(self, aliceSizes, bobSizes):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type aliceSizes: List[int]\\n\\t\\t\\t:type bobSizes: List[int]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tsumA = sum(aliceSizes)\\n\\t\\t\\tsumB = sum(bobSizes)\\n\\n\\t\\t\\tsetB = set(bobSizes)\\n\\n\\t\\t\\tfor ele in aliceSizes:\\n\\t\\t\\t\\tdiff = ele+((sumB-sumA)/2)\\n\\t\\t\\t\\tif diff in setB:\\n\\t\\t\\t\\t\\treturn [ele,diff]\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef fairCandySwap(self, aliceSizes, bobSizes):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type aliceSizes: List[int]\\n\\t\\t\\t:type bobSizes: List[int]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tsumA = sum(aliceSizes)\\n\\t\\t\\tsumB = sum(bobSizes)\\n\\n\\t\\t\\tsetB = set(bobSizes)\\n\\n\\t\\t\\tfor ele in aliceSizes:\\n\\t\\t\\t\\tdiff = ele+((sumB-sumA)/2)\\n\\t\\t\\t\\tif diff in setB:\\n\\t\\t\\t\\t\\treturn [ele,diff]\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1641742,
                "title": "c-easy-approach",
                "content": "**Please do upvote if it helps you!**\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n         int sumA = 0;\\n    int sumB = 0;\\n    \\n    for (auto e : A)\\n        sumA += e;\\n    \\n    for (auto e : B)\\n        sumB += e;\\n    \\n    int delta = (sumA - sumB) / 2;\\n    \\n    set<int> searchA;\\n    for (auto x : A)\\n    {\\n        //cout << x << endl;\\n        searchA.insert(x);\\n    }\\n    \\n    \\n    //cout << endl;\\n    for (auto y : B)    \\n    {\\n        //cout << y << setw(5) << delta + y << endl;\\n        if (searchA.count(delta + y) > 0)\\n        {\\n            return vector<int>{delta + y, y};\\n        }\\n    }\\n    \\n    return vector<int>();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n         int sumA = 0;\\n    int sumB = 0;\\n    \\n    for (auto e : A)\\n        sumA += e;\\n    \\n    for (auto e : B)\\n        sumB += e;\\n    \\n    int delta = (sumA - sumB) / 2;\\n    \\n    set<int> searchA;\\n    for (auto x : A)\\n    {\\n        //cout << x << endl;\\n        searchA.insert(x);\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1614801,
                "title": "easiest-c-soln-using-binary-search",
                "content": "**Time Complexity: O(NlogN)**\\n(neglecting the differences in both array length)\\n\\n```\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int sum1=0,sum2=0;\\n        vector<int>ans;\\n        \\n        for(int i:aliceSizes)\\n            sum1+=i;\\n        for(int i:bobSizes)\\n            sum2+=i;\\n        \\n        int diff=(sum2-sum1)/2;\\n        \\n        for(int i:aliceSizes)\\n        {\\n            int lc=0,uc=bobSizes.size()-1,mid=0;\\n            while(lc<=uc)\\n            {\\n                mid=lc+(uc-lc)/2;\\n                if(i+diff==bobSizes[mid])\\n                {\\n                    ans.push_back(i);\\n                    ans.push_back(i+diff);\\n                    return ans;\\n                }\\n                else if(i+diff<bobSizes[mid])\\n                    uc=mid-1;\\n                else\\n                    lc=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nIf you liked my solution please hit an upvote.\\nIf you have any query regarding the solution, drop a comment below and lets discuss!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int sum1=0,sum2=0;\\n        vector<int>ans;\\n        \\n        for(int i:aliceSizes)\\n            sum1+=i;\\n        for(int i:bobSizes)\\n            sum2+=i;\\n        \\n        int diff=(sum2-sum1)/2;\\n        \\n        for(int i:aliceSizes)\\n        {\\n            int lc=0,uc=bobSizes.size()-1,mid=0;\\n            while(lc<=uc)\\n            {\\n                mid=lc+(uc-lc)/2;\\n                if(i+diff==bobSizes[mid])\\n                {\\n                    ans.push_back(i);\\n                    ans.push_back(i+diff);\\n                    return ans;\\n                }\\n                else if(i+diff<bobSizes[mid])\\n                    uc=mid-1;\\n                else\\n                    lc=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570739,
                "title": "python-3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        diff = (sum(aliceSizes) - sum(bobSizes)) // 2\\n        s = set(aliceSizes)\\n        for bag in bobSizes:\\n            if bag + diff in s:\\n                return [bag + diff, bag]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        diff = (sum(aliceSizes) - sum(bobSizes)) // 2\\n        s = set(aliceSizes)\\n        for bag in bobSizes:\\n            if bag + diff in s:\\n                return [bag + diff, bag]",
                "codeTag": "Java"
            },
            {
                "id": 1562473,
                "title": "java-easy-binary-search",
                "content": "* Sort bobSizes array to perform binary  search on it.\\n* with the help of for loop find total number of candies for both alice and bob.\\n* Iterate aliceSizes array and perform binary search on bobSizes array.\\n\\nEquation:\\naliceSizes - x + y = bobSizes + x - y\\ny = x + (bobSizes - aliceSizes)/2\\n\\nx number of candies from aliceSizes and y number of candies from bobSizes\\n\\nCode:\\n```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int alice = 0,bob = 0;\\n        int[] ans = new int[2];\\n        Arrays.sort(bobSizes);\\n        for(int i=0;i<aliceSizes.length;i++){\\n            alice = alice + aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.length;i++){\\n            bob = bob + bobSizes[i];\\n        }\\n        for(int i=0;i<aliceSizes.length;i++){\\n            int l=0,r=bobSizes.length-1;\\n            int x = aliceSizes[i] + (bob-alice)/2;\\n            while(l<=r){\\n                int mid = l+(r-l)/2;\\n                if(bobSizes[mid] == x){\\n                    ans[1] = bobSizes[mid];\\n                    ans[0] = aliceSizes[i];\\n                    return ans;\\n                }else if(bobSizes[mid] < x){\\n                    l = mid + 1;\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\\n        int alice = 0,bob = 0;\\n        int[] ans = new int[2];\\n        Arrays.sort(bobSizes);\\n        for(int i=0;i<aliceSizes.length;i++){\\n            alice = alice + aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.length;i++){\\n            bob = bob + bobSizes[i];\\n        }\\n        for(int i=0;i<aliceSizes.length;i++){\\n            int l=0,r=bobSizes.length-1;\\n            int x = aliceSizes[i] + (bob-alice)/2;\\n            while(l<=r){\\n                int mid = l+(r-l)/2;\\n                if(bobSizes[mid] == x){\\n                    ans[1] = bobSizes[mid];\\n                    ans[0] = aliceSizes[i];\\n                    return ans;\\n                }else if(bobSizes[mid] < x){\\n                    l = mid + 1;\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561230,
                "title": "c-basic-math-approach-set",
                "content": "```\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        set<int>s;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            sum1+=aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            sum2+=bobSizes[i];\\n        }\\n        int diff=(sum2-sum1)/2;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            s.insert(bobSizes[i]);\\n        }\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            if(s.find(aliceSizes[i]+diff)!=s.end())\\n            {\\n                \\n                return {aliceSizes[i],aliceSizes[i]+diff};\\n            }\\n        }\\n        return {};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        set<int>s;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            sum1+=aliceSizes[i];\\n        }\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            sum2+=bobSizes[i];\\n        }\\n        int diff=(sum2-sum1)/2;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            s.insert(bobSizes[i]);\\n        }\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            if(s.find(aliceSizes[i]+diff)!=s.end())\\n            {\\n                \\n                return {aliceSizes[i],aliceSizes[i]+diff};\\n            }\\n        }\\n        return {};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1551239,
                "title": "javascript-simple-solution",
                "content": "\\t\\tvar fairCandySwap = function(aliceSizes, bobSizes) {\\n\\t\\t\\tconst aliceSum = aliceSizes.reduce((a,b)=> a + b)\\n\\t\\t\\tconst bobSum = bobSizes.reduce((a,b)=> a + b)\\n\\n\\t\\t\\tconst average = (aliceSum + bobSum)/2\\n\\n\\t\\t\\tfor(let i = 0; i < aliceSizes.length; i++){\\n\\t\\t\\t\\tlet found = average - (aliceSum - aliceSizes[i])\\n\\t\\t\\t\\tif(bobSizes.includes(found)){\\n\\t\\t\\t\\t\\treturn [aliceSizes[i], found]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "\\t\\tvar fairCandySwap = function(aliceSizes, bobSizes) {\\n\\t\\t\\tconst aliceSum = aliceSizes.reduce((a,b)=> a + b)\\n\\t\\t\\tconst bobSum = bobSizes.reduce((a,b)=> a + b)\\n\\n\\t\\t\\tconst average = (aliceSum + bobSum)/2\\n\\n\\t\\t\\tfor(let i = 0; i < aliceSizes.length; i++){\\n\\t\\t\\t\\tlet found = average - (aliceSum - aliceSizes[i])\\n\\t\\t\\t\\tif(bobSizes.includes(found)){\\n\\t\\t\\t\\t\\treturn [aliceSizes[i], found]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1536460,
                "title": "c-simplest-solution",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n        vector<int> result;\\n        set<int> s;\\n        int n = alice.size(), m = bob.size();\\n        \\n        int alicesum = 0 , bobsum = 0;\\n        \\n        for(int i=0 ; i<n ; ++i) alicesum += alice[i];\\n        \\n        for(int j=0 ; j<m ; ++j)\\n        {\\n            bobsum += bob[j];\\n            s.insert(bob[j]);\\n        }\\n        \\n        // y = x + (bobsum-alicesum)/2;\\n        int temp = (bobsum - alicesum)/2;\\n        for(int i=0 ; i<n ; ++i)\\n        {\\n            // y = alice[i] + temp;\\n            \\n            auto it = s.find(alice[i]+temp);\\n            if(it != s.end())\\n            {\\n                result.push_back(alice[i]);\\n                result.push_back(alice[i] + temp);\\n                return result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n        vector<int> result;\\n        set<int> s;\\n        int n = alice.size(), m = bob.size();\\n        \\n        int alicesum = 0 , bobsum = 0;\\n        \\n        for(int i=0 ; i<n ; ++i) alicesum += alice[i];\\n        \\n        for(int j=0 ; j<m ; ++j)\\n        {\\n            bobsum += bob[j];\\n            s.insert(bob[j]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1530132,
                "title": "simplest-c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int binarysearch(vector<int>& bobSizes,int target)\\n    {\\n        int i=0,l=bobSizes.size()-1;\\n        while(i<=l)\\n        {\\n            int mid =i+(l-i)/2;\\n            if(bobSizes[mid]==target)\\n            {\\n                return mid;\\n            }\\n            else if(bobSizes[mid]>target)\\n            {\\n                l=mid-1;\\n            }\\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int alicesum=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            alicesum=alicesum+aliceSizes[i];\\n        }\\n        \\n        int bobsum=0;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            bobsum=bobsum+bobSizes[i];\\n        }\\n        \\n        vector<int> answer;\\n        \\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int target=(bobsum-alicesum+2*aliceSizes[i])/2;\\n            int temp=binarysearch(bobSizes,target);\\n            if(temp!=-1)\\n            {\\n                answer.push_back(aliceSizes[i]);\\n                answer.push_back(target);\\n                return answer;\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int binarysearch(vector<int>& bobSizes,int target)\\n    {\\n        int i=0,l=bobSizes.size()-1;\\n        while(i<=l)\\n        {\\n            int mid =i+(l-i)/2;\\n            if(bobSizes[mid]==target)\\n            {\\n                return mid;\\n            }\\n            else if(bobSizes[mid]>target)\\n            {\\n                l=mid-1;\\n            }\\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) \\n    {\\n        sort(aliceSizes.begin(),aliceSizes.end());\\n        sort(bobSizes.begin(),bobSizes.end());\\n        \\n        int alicesum=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            alicesum=alicesum+aliceSizes[i];\\n        }\\n        \\n        int bobsum=0;\\n        for(int i=0;i<bobSizes.size();i++)\\n        {\\n            bobsum=bobsum+bobSizes[i];\\n        }\\n        \\n        vector<int> answer;\\n        \\n        for(int i=0;i<aliceSizes.size();i++)\\n        {\\n            int target=(bobsum-alicesum+2*aliceSizes[i])/2;\\n            int temp=binarysearch(bobSizes,target);\\n            if(temp!=-1)\\n            {\\n                answer.push_back(aliceSizes[i]);\\n                answer.push_back(target);\\n                return answer;\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496060,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) \\n    {\\n        Arrays.sort(aliceSizes);\\n        Arrays.sort(bobSizes);\\n        long sum1=0 , sum2=0;\\n         for(int i=0;i<aliceSizes.length ; i++)      \\n            sum1 = sum1 + aliceSizes[i];\\n        for(int i=0;i<bobSizes.length ; i++)      \\n            sum2 = sum2 + bobSizes[i];\\n        int i=0 ; \\n        int j=0;\\n        if(sum1>sum2)\\n        {\\n            long dif = (sum1 - sum2)/2;\\n            while(i<aliceSizes.length && j<bobSizes.length)\\n            {\\n                if(aliceSizes[i] == bobSizes[j]+dif)    \\n                    return new int[]{aliceSizes[i] , bobSizes[j]};\\n                else if(aliceSizes[i]<bobSizes[j]+dif)\\n                    i++;\\n                else\\n                    j++;\\n            }\\n        }\\n        else\\n            {\\n            long dif = (sum2 - sum1)/2;\\n            while(i<aliceSizes.length && j<bobSizes.length)\\n            {\\n                if(aliceSizes[i] + dif  == bobSizes[j])    \\n                    return new int[]{aliceSizes[i] , bobSizes[j]};\\n                else if(aliceSizes[i]+ dif >bobSizes[j])\\n                    j++;\\n                else\\n                    i++;\\n            }\\n        }\\n       return new int[]{-1,-1};\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) \\n    {\\n        Arrays.sort(aliceSizes);\\n        Arrays.sort(bobSizes);\\n        long sum1=0 , sum2=0;\\n         for(int i=0;i<aliceSizes.length ; i++)      \\n            sum1 = sum1 + aliceSizes[i];\\n        for(int i=0;i<bobSizes.length ; i++)      \\n            sum2 = sum2 + bobSizes[i];\\n        int i=0 ; \\n        int j=0;\\n        if(sum1>sum2)\\n        {\\n            long dif = (sum1 - sum2)/2;\\n            while(i<aliceSizes.length && j<bobSizes.length)\\n            {\\n                if(aliceSizes[i] == bobSizes[j]+dif)    \\n                    return new int[]{aliceSizes[i] , bobSizes[j]};\\n                else if(aliceSizes[i]<bobSizes[j]+dif)\\n                    i++;\\n                else\\n                    j++;\\n            }\\n        }\\n        else\\n            {\\n            long dif = (sum2 - sum1)/2;\\n            while(i<aliceSizes.length && j<bobSizes.length)\\n            {\\n                if(aliceSizes[i] + dif  == bobSizes[j])    \\n                    return new int[]{aliceSizes[i] , bobSizes[j]};\\n                else if(aliceSizes[i]+ dif >bobSizes[j])\\n                    j++;\\n                else\\n                    i++;\\n            }\\n        }\\n       return new int[]{-1,-1};\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460273,
                "title": "javascript-solution-with-comments",
                "content": "```\\nvar fairCandySwap = function(aliceSizes, bobSizes) {\\n    let sumA = 0;\\n    let sumB = 0;\\n    let setB = new Set();\\n    let diff = 0;\\n    let res = [];\\n    \\n    for (let i = 0; i < aliceSizes.length; i++) {\\n        sumA += aliceSizes[i];\\n    }\\n    \\n    for (let j = 0; j < bobSizes.length; j++) {\\n        sumB += bobSizes[j];\\n        setB.add(bobSizes[j]);\\n    }\\n    \\n    diff = (sumB - sumA) / 2;\\n    \\n    for (let i = 0; i < aliceSizes.length; i++) {\\n        //for each candy of alice we are checking if the value is same as diff + alice is present in the Bobs candy\\n        //Reason being: after solving the equation\\n        // y = x + (sumB - sumA) / 2 ==> y = x + diff\\n        if (setB.has(diff+aliceSizes[i])) {\\n            res[0] = aliceSizes[i];\\n            res[1] = diff+aliceSizes[i];\\n            break;\\n        };\\n    }\\n    return res; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fairCandySwap = function(aliceSizes, bobSizes) {\\n    let sumA = 0;\\n    let sumB = 0;\\n    let setB = new Set();\\n    let diff = 0;\\n    let res = [];\\n    \\n    for (let i = 0; i < aliceSizes.length; i++) {\\n        sumA += aliceSizes[i];\\n    }\\n    \\n    for (let j = 0; j < bobSizes.length; j++) {\\n        sumB += bobSizes[j];\\n        setB.add(bobSizes[j]);\\n    }\\n    \\n    diff = (sumB - sumA) / 2;\\n    \\n    for (let i = 0; i < aliceSizes.length; i++) {\\n        //for each candy of alice we are checking if the value is same as diff + alice is present in the Bobs candy\\n        //Reason being: after solving the equation\\n        // y = x + (sumB - sumA) / 2 ==> y = x + diff\\n        if (setB.has(diff+aliceSizes[i])) {\\n            res[0] = aliceSizes[i];\\n            res[1] = diff+aliceSizes[i];\\n            break;\\n        };\\n    }\\n    return res; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447435,
                "title": "py-candy-swap",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        each = (sum(aliceSizes) + sum(bobSizes))//2\\n        diff = each - sum(aliceSizes)\\n        for a in set(aliceSizes):\\n            if a + diff in set(bobSizes):\\n                return [a, a+diff]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        each = (sum(aliceSizes) + sum(bobSizes))//2\\n        diff = each - sum(aliceSizes)\\n        for a in set(aliceSizes):\\n            if a + diff in set(bobSizes):\\n                return [a, a+diff]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419942,
                "title": "two-approaches-using-set-and-binary-search",
                "content": "**Method 1 :**\\n\\n**Using set and it will take extra memory**\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n     int n=alice.size();\\n        int m=bob.size();\\n        int sa=0,sb=0;\\n        for(auto it:alice) sa+=it;\\n         set<int>b;\\n        vector<int>output;\\n        for(auto it:bob) \\n        {\\n            sb+=it;\\n            b.insert(it);\\n        }\\n        int x,y;\\n        y=(sb-sa)/2 ;\\n        for(auto it:alice){\\n            if(b.find(y+it)!=b.end()){\\n                output.push_back(it);\\n                 output.push_back(y+it);\\n                return output;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n\\n**Method 2 :**\\n\\n**Using binary search and using O(1) space**\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n     int n=alice.size();\\n        int m=bob.size();\\n        int sa=0,sb=0;\\n        for(auto it:alice) sa+=it;\\n        vector<int>output;\\n        for(auto it:bob) \\n        {\\n            sb+=it;\\n        }\\n        sort(bob.begin(),bob.end());\\n        int x,y;\\n        y=(sb-sa)/2 ;\\n        for(auto it:alice){\\n            if(binary_search(bob.begin(),bob.end(),it+y)==true){\\n                output.push_back(it);\\n                 output.push_back(y+it);\\n                return output;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n     int n=alice.size();\\n        int m=bob.size();\\n        int sa=0,sb=0;\\n        for(auto it:alice) sa+=it;\\n         set<int>b;\\n        vector<int>output;\\n        for(auto it:bob) \\n        {\\n            sb+=it;\\n            b.insert(it);\\n        }\\n        int x,y;\\n        y=(sb-sa)/2 ;\\n        for(auto it:alice){\\n            if(b.find(y+it)!=b.end()){\\n                output.push_back(it);\\n                 output.push_back(y+it);\\n                return output;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& alice, vector<int>& bob) {\\n     int n=alice.size();\\n        int m=bob.size();\\n        int sa=0,sb=0;\\n        for(auto it:alice) sa+=it;\\n        vector<int>output;\\n        for(auto it:bob) \\n        {\\n            sb+=it;\\n        }\\n        sort(bob.begin(),bob.end());\\n        int x,y;\\n        y=(sb-sa)/2 ;\\n        for(auto it:alice){\\n            if(binary_search(bob.begin(),bob.end(),it+y)==true){\\n                output.push_back(it);\\n                 output.push_back(y+it);\\n                return output;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391545,
                "title": "golang-map-solution-100",
                "content": "```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n\\taliceSum := 0\\n\\taliceBoxes := make(map[int]struct{}, len(aliceSizes))\\n\\tfor _, n := range aliceSizes {\\n\\t\\taliceSum += n\\n\\t\\taliceBoxes[n] = struct{}{}\\n\\t}\\n\\tbobSum := 0\\n\\tfor _, n := range bobSizes {\\n\\t\\tbobSum += n\\n\\t}\\n\\n\\ttarget := (aliceSum + bobSum) / 2\\n\\n\\tfor _, bobBox := range bobSizes {\\n\\t\\tif _, ok := aliceBoxes[aliceSum + bobBox- target]; ok {\\n\\t\\t\\treturn []int{aliceSum + bobBox - target, bobBox}\\n\\t\\t}\\n\\t}\\n\\tpanic(\"unreachable\")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc fairCandySwap(aliceSizes []int, bobSizes []int) []int {\\n\\taliceSum := 0\\n\\taliceBoxes := make(map[int]struct{}, len(aliceSizes))\\n\\tfor _, n := range aliceSizes {\\n\\t\\taliceSum += n\\n\\t\\taliceBoxes[n] = struct{}{}\\n\\t}\\n\\tbobSum := 0\\n\\tfor _, n := range bobSizes {\\n\\t\\tbobSum += n\\n\\t}\\n\\n\\ttarget := (aliceSum + bobSum) / 2\\n\\n\\tfor _, bobBox := range bobSizes {\\n\\t\\tif _, ok := aliceBoxes[aliceSum + bobBox- target]; ok {\\n\\t\\t\\treturn []int{aliceSum + bobBox - target, bobBox}\\n\\t\\t}\\n\\t}\\n\\tpanic(\"unreachable\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1386588,
                "title": "rust-using-hashset-and-a-bit-of-an-explanation",
                "content": "The reasoning behind it: the total amount of candies that Alice has is `sum_a`. Similarly, the total amount of candies that Bob has is `sum_b`. For the candy swap to be fair, Alice gives a box `x` of candies to Bob and in exchange receives a box `y` of candies from Bob, such that `sum_a - x + y = sum_b - y + x`. If we move things around, then we get `((sum_a - sum_b) / 2) + y = x`. So, effectively, we need to check if there is a pair (`x`, `y`) that solves the equation. In other words, we iterate over Bob\\'s boxes of candies, `y`, and check if the `((sum_a - sum_b) / 2) + y` exists in Alice\\'s boxes of candies.\\n\\n```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn fair_candy_swap(alice_sizes: Vec<i32>, bob_sizes: Vec<i32>) -> Vec<i32> {\\n        let sum_a = alice_sizes.iter().sum::<i32>();\\n        let sum_b = bob_sizes.iter().sum::<i32>();\\n        let set_a = alice_sizes.iter().fold(HashSet::new(), |mut acc, x| {\\n            acc.insert(x);\\n            acc\\n        });\\n\\t\\t\\n        for y in bob_sizes.iter() {\\n            let x = (sum_a - sum_b) / 2 + y;\\n            if set_a.contains(&x) {\\n                return vec![x, *y];\\n            }\\n        }\\n        \\n        unreachable!()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn fair_candy_swap(alice_sizes: Vec<i32>, bob_sizes: Vec<i32>) -> Vec<i32> {\\n        let sum_a = alice_sizes.iter().sum::<i32>();\\n        let sum_b = bob_sizes.iter().sum::<i32>();\\n        let set_a = alice_sizes.iter().fold(HashSet::new(), |mut acc, x| {\\n            acc.insert(x);\\n            acc\\n        });\\n\\t\\t\\n        for y in bob_sizes.iter() {\\n            let x = (sum_a - sum_b) / 2 + y;\\n            if set_a.contains(&x) {\\n                return vec![x, *y];\\n            }\\n        }\\n        \\n        unreachable!()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341063,
                "title": "c-using-binary-search-o-n-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& m, vector<int>& n) {\\n        vector<int> v;\\n        int x, y;\\n        int s1 = 0, s2 = 0;\\n        for(int i = 0; i < m.size(); i++){\\n            s1 += m[i];\\n        }\\n        for(int i = 0; i < n.size(); i++){\\n            s2 += n[i];\\n        }\\n        sort(n.begin(), n.end());\\n        for(int i = 0; i < m.size(); i++){\\n            x = m[i];\\n            y = (s2 - s1)/2 + x;\\n            int lo = 0, hi = n.size() - 1;\\n            while(hi - lo > 1){\\n                int mid = (hi + lo) / 2;\\n                if(n[mid] > y)\\n                    hi = mid - 1;\\n                else\\n                    lo = mid;\\n            }\\n            if(n[lo] == y){\\n                y = n[lo];\\n                v.push_back(x);\\n                v.push_back(y);\\n                break;\\n            }\\n            else if(n[hi] == y){\\n                y = n[hi];\\n                v.push_back(x);\\n                v.push_back(y);\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& m, vector<int>& n) {\\n        vector<int> v;\\n        int x, y;\\n        int s1 = 0, s2 = 0;\\n        for(int i = 0; i < m.size(); i++){\\n            s1 += m[i];\\n        }\\n        for(int i = 0; i < n.size(); i++){\\n            s2 += n[i];\\n        }\\n        sort(n.begin(), n.end());\\n        for(int i = 0; i < m.size(); i++){\\n            x = m[i];\\n            y = (s2 - s1)/2 + x;\\n            int lo = 0, hi = n.size() - 1;\\n            while(hi - lo > 1){\\n                int mid = (hi + lo) / 2;\\n                if(n[mid] > y)\\n                    hi = mid - 1;\\n                else\\n                    lo = mid;\\n            }\\n            if(n[lo] == y){\\n                y = n[lo];\\n                v.push_back(x);\\n                v.push_back(y);\\n                break;\\n            }\\n            else if(n[hi] == y){\\n                y = n[hi];\\n                v.push_back(x);\\n                v.push_back(y);\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307263,
                "title": "python-hashmap-368ms",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        hmap={}\\n        ans=[]\\n        for i in range(len(bobSizes)):\\n            hmap[bobSizes[i]]=i\\n        s1=sum(aliceSizes)\\n        s2=sum(bobSizes)\\n        avg=(s1+s2)/2\\n        for i in range(len(aliceSizes)):\\n            key=avg-(s1-aliceSizes[i])\\n            if key in hmap:\\n                ans=[aliceSizes[i],bobSizes[hmap[key]]]\\n                break\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:\\n        hmap={}\\n        ans=[]\\n        for i in range(len(bobSizes)):\\n            hmap[bobSizes[i]]=i\\n        s1=sum(aliceSizes)\\n        s2=sum(bobSizes)\\n        avg=(s1+s2)/2\\n        for i in range(len(aliceSizes)):\\n            key=avg-(s1-aliceSizes[i])\\n            if key in hmap:\\n                ans=[aliceSizes[i],bobSizes[hmap[key]]]\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294350,
                "title": "c-hash-map-using-an-equation",
                "content": "```\\n\\n/* Equation: sum1-num1+num2 = sum2-num2+num1\\n          => sum1-sum2(diff) = 2num1 - 2num2  */\\n\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        int sum1=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n            sum1+=aliceSizes[i];\\n            \\n        \\n        int sum2=0;\\n        for(int i=0;i<bobSizes.size();i++)\\n            sum2+=bobSizes[i];\\n        \\n        int diff=abs(sum1-sum2);\\n        \\n        vector<int> ans;\\n        \\n        if(sum2<=sum1)\\n        {\\n            unordered_set<int> ust;\\n            for(int i=0;i<aliceSizes.size();i++)\\n                ust.insert(aliceSizes[i]*2);\\n            \\n            for(int i=0;i<bobSizes.size();i++)\\n            {\\n                if(ust.find(diff+(2*bobSizes[i]))!=ust.end())\\n                {\\n                    ans.push_back((*ust.find(diff+(2*bobSizes[i])))/2);\\n                    ans.push_back(bobSizes[i]);\\n                    return(ans);\\n                }\\n            }\\n        }\\n        if(sum2>sum1)\\n        {\\n            unordered_set<int> ust;\\n            for(int i=0;i<bobSizes.size();i++)\\n                ust.insert(bobSizes[i]*2);\\n            \\n            for(int i=0;i<aliceSizes.size();i++)\\n            {\\n                if(ust.find(diff+(2*aliceSizes[i]))!=ust.end())\\n                {\\n                    ans.push_back(aliceSizes[i]);\\n                    ans.push_back((*ust.find(diff+(2*aliceSizes[i])))/2);\\n                    return(ans);\\n                }\\n            }\\n        }\\n        \\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/* Equation: sum1-num1+num2 = sum2-num2+num1\\n          => sum1-sum2(diff) = 2num1 - 2num2  */\\n\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& aliceSizes, vector<int>& bobSizes) {\\n        \\n        int sum1=0;\\n        for(int i=0;i<aliceSizes.size();i++)\\n            sum1+=aliceSizes[i];\\n            \\n        \\n        int sum2=0;\\n        for(int i=0;i<bobSizes.size();i++)\\n            sum2+=bobSizes[i];\\n        \\n        int diff=abs(sum1-sum2);\\n        \\n        vector<int> ans;\\n        \\n        if(sum2<=sum1)\\n        {\\n            unordered_set<int> ust;\\n            for(int i=0;i<aliceSizes.size();i++)\\n                ust.insert(aliceSizes[i]*2);\\n            \\n            for(int i=0;i<bobSizes.size();i++)\\n            {\\n                if(ust.find(diff+(2*bobSizes[i]))!=ust.end())\\n                {\\n                    ans.push_back((*ust.find(diff+(2*bobSizes[i])))/2);\\n                    ans.push_back(bobSizes[i]);\\n                    return(ans);\\n                }\\n            }\\n        }\\n        if(sum2>sum1)\\n        {\\n            unordered_set<int> ust;\\n            for(int i=0;i<bobSizes.size();i++)\\n                ust.insert(bobSizes[i]*2);\\n            \\n            for(int i=0;i<aliceSizes.size();i++)\\n            {\\n                if(ust.find(diff+(2*aliceSizes[i]))!=ust.end())\\n                {\\n                    ans.push_back(aliceSizes[i]);\\n                    ans.push_back((*ust.find(diff+(2*aliceSizes[i])))/2);\\n                    return(ans);\\n                }\\n            }\\n        }\\n        \\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164350,
                "title": "implementation-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n        int suma=0,sumb=0;\\n        for(int e:a){\\n            suma+=e;\\n        }\\n        for(int y:b)\\n            sumb+=y;\\n        for(int x:a){\\n            for(int y:b){\\n         if(suma-x+y==sumb-y+x) return{x,y};\\n            }\\n        }\\n        return{0,0};\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n        int suma=0,sumb=0;\\n        for(int e:a){\\n            suma+=e;\\n        }\\n        for(int y:b)\\n            sumb+=y;\\n        for(int x:a){\\n            for(int y:b){\\n         if(suma-x+y==sumb-y+x) return{x,y};\\n            }\\n        }\\n        return{0,0};\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084350,
                "title": "java-solution-jw",
                "content": "```\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int[] ans = new int[2];\\n        int sumA = 0, sumB = 0;\\n        for(int i: A){\\n            sumA += i;\\n        }\\n        for(int j: B){\\n            sumB += j;\\n        }\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        int temp = sumA-(sumA+sumB)/2;\\n        int i = 0, j = 0;\\n        while(i<A.length&&j<B.length){\\n            if(A[i]-B[j]==temp){\\n                ans[0] = A[i];\\n                ans[1] = B[j];\\n                break;\\n            }\\n            else if(A[i]-B[j]>temp){\\n                j++;\\n            }\\n            else if(A[i]-B[j]<temp){\\n                i++;\\n            }\\n        }\\n        return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int[] ans = new int[2];\\n        int sumA = 0, sumB = 0;\\n        for(int i: A){\\n            sumA += i;\\n        }\\n        for(int j: B){\\n            sumB += j;\\n        }\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        int temp = sumA-(sumA+sumB)/2;\\n        int i = 0, j = 0;\\n        while(i<A.length&&j<B.length){\\n            if(A[i]-B[j]==temp){\\n                ans[0] = A[i];\\n                ans[1] = B[j];\\n                break;\\n            }\\n            else if(A[i]-B[j]>temp){\\n                j++;\\n            }\\n            else if(A[i]-B[j]<temp){\\n                i++;\\n            }\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1021514,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        \\n        totalhalf = ( sum(A) + sum(B) ) // 2   # gives sum(A) or sum(B) after sharing candies\\n        \\n        B = set(B) # for removing duplicates\\n\\n        for j in range(len(A)) :\\n            if (totalhalf - (sum(A) - A[j])) in B :\\n                return [A[j],totalhalf-(sum(A) - A[j])]\\n            \\n            \\n            # [sum(A) - A[j]] ---> amount [A] without the element that is to be shared\\n            # [totalhalf - (sum(A) - A[j])] ---> gives the needed element from bobs list\\n            \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        \\n        totalhalf = ( sum(A) + sum(B) ) // 2   # gives sum(A) or sum(B) after sharing candies\\n        \\n        B = set(B) # for removing duplicates\\n\\n        for j in range(len(A)) :\\n            if (totalhalf - (sum(A) - A[j])) in B :\\n                return [A[j],totalhalf-(sum(A) - A[j])]\\n            \\n            \\n            # [sum(A) - A[j]] ---> amount [A] without the element that is to be shared\\n            # [totalhalf - (sum(A) - A[j])] ---> gives the needed element from bobs list\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019746,
                "title": "solution-with-explanation-o-n-m-c",
                "content": "Let remove x from A and y from B to make their sum equal\\n\\nTherefore, A-x+y = B+x-y \\n=> x - y = (A - B)/2 = diff\\n\\nNow find if any x = y+diff\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        vector<int> ans;\\n        \\n        int sum_A = accumulate(A.begin(),A.end(),0);\\n        int sum_B = accumulate(B.begin(),B.end(),0);\\n        \\n        int diff = (sum_A - sum_B)/2;\\n        \\n        map<int,bool> m;\\n        for(int i=0; i<n; i++)\\n             m[A[i]] = true;\\n        \\n\\t\\tint m = B.size();\\n        for(int i=0; i<m; i++){\\n            if(m[B[i] + diff]){ // to find any j such that A[j] - B[i] = diff\\n                ans.push_back(B[i]+diff); \\n                ans.push_back(B[i]);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        vector<int> ans;\\n        \\n        int sum_A = accumulate(A.begin(),A.end(),0);\\n        int sum_B = accumulate(B.begin(),B.end(),0);\\n        \\n        int diff = (sum_A - sum_B)/2;\\n        \\n        map<int,bool> m;\\n        for(int i=0; i<n; i++)\\n             m[A[i]] = true;\\n        \\n\\t\\tint m = B.size();\\n        for(int i=0; i<m; i++){\\n            if(m[B[i] + diff]){ // to find any j such that A[j] - B[i] = diff\\n                ans.push_back(B[i]+diff); \\n                ans.push_back(B[i]);\\n                return ans;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 995822,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        #\\n        difference = sum(A)-sum(B)\\n        B = set(B)\\n        for i in A:\\n            if i-difference//2 in B:\\n                return [i,i-difference//2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        #\\n        difference = sum(A)-sum(B)\\n        B = set(B)\\n        for i in A:\\n            if i-difference//2 in B:\\n                return [i,i-difference//2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970756,
                "title": "python-easy-solution-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/3e18ba1c-9f6d-4b7c-9798-7cd1a036df57_1607855688.0515661.png)\\n\\n```\\ndef fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(A) - sum(B)) // 2\\n        b = set(B)\\n        for x in A:\\n            if x - diff in b:\\n                return [x, x - diff]\\n        return []\\n\\t",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/3e18ba1c-9f6d-4b7c-9798-7cd1a036df57_1607855688.0515661.png)\\n\\n```\\ndef fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(A) - sum(B)) // 2\\n        b = set(B)\\n        for x in A:\\n            if x - diff in b:\\n                return [x, x - diff]\\n        return []\\n\\t",
                "codeTag": "Python3"
            },
            {
                "id": 924473,
                "title": "python-simple-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        s = (sum(A) - sum(B)) // 2\\n        A = set(A)\\n        \\n        for n in B:\\n            if s + n in A:\\n                return [s + n, n]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        s = (sum(A) - sum(B)) // 2\\n        A = set(A)\\n        \\n        for n in B:\\n            if s + n in A:\\n                return [s + n, n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856146,
                "title": "c",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int sumA = accumulate(A.begin(), A.end(), 0);\\n        int sumB = accumulate(B.begin(), B.end(), 0);\\n        \\n        sort(A.begin(), A.end(), greater<int>());\\n        sort(B.begin(), B.end(), greater<int>());\\n        \\n        vector<int> ans;\\n        \\n        int avgSum = (sumA + sumB) / 2;\\n        \\n        int diff = abs(avgSum - sumA);\\n        \\n        for (const auto & a : A)\\n        {\\n            for (const auto & b : B)\\n            {\\n                if ( ( sumA > sumB && a - b == diff ) || ( sumB > sumA && b - a == diff ) )\\n                {\\n                    ans.push_back(a);\\n                    ans.push_back(b);\\n                    \\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n### [\\u53C2\\u8003](https://leetcode.com/problems/fair-candy-swap/solution/)\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int sumA = accumulate(A.begin(), A.end(), 0);\\n        int sumB = accumulate(B.begin(), B.end(), 0);\\n        \\n        int delta = (sumB - sumA) / 2;\\n        \\n        set<int> setB;\\n        \\n        for (const auto & item : B)\\n            setB.insert(item);\\n        \\n        vector<int> ans;\\n        \\n        for (const auto & item : A)\\n        {\\n            if (setB.count(item + delta))\\n                return {item, item+delta};\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int sumA = accumulate(A.begin(), A.end(), 0);\\n        int sumB = accumulate(B.begin(), B.end(), 0);\\n        \\n        sort(A.begin(), A.end(), greater<int>());\\n        sort(B.begin(), B.end(), greater<int>());\\n        \\n        vector<int> ans;\\n        \\n        int avgSum = (sumA + sumB) / 2;\\n        \\n        int diff = abs(avgSum - sumA);\\n        \\n        for (const auto & a : A)\\n        {\\n            for (const auto & b : B)\\n            {\\n                if ( ( sumA > sumB && a - b == diff ) || ( sumB > sumA && b - a == diff ) )\\n                {\\n                    ans.push_back(a);\\n                    ans.push_back(b);\\n                    \\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int sumA = accumulate(A.begin(), A.end(), 0);\\n        int sumB = accumulate(B.begin(), B.end(), 0);\\n        \\n        int delta = (sumB - sumA) / 2;\\n        \\n        set<int> setB;\\n        \\n        for (const auto & item : B)\\n            setB.insert(item);\\n        \\n        vector<int> ans;\\n        \\n        for (const auto & item : A)\\n        {\\n            if (setB.count(item + delta))\\n                return {item, item+delta};\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842951,
                "title": "python",
                "content": "\\tclass Solution:\\n\\t\\tdef fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n\\t\\t\\t\\n\\t\\t\\ta = sum(A)\\n\\t\\t\\tb = sum(B)\\n\\t\\t\\ttarget = (a+b)//2\\n\\n\\t\\t\\tif a<b:\\n\\t\\t\\t\\tdiff = target-a\\n\\t\\t\\t\\tfor q in A:\\n\\t\\t\\t\\t\\tif q+diff in B:\\n\\t\\t\\t\\t\\t\\treturn [q,q+diff]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdiff = target-b\\n\\t\\t\\t\\tfor q in B:\\n\\t\\t\\t\\t\\tif q+diff in A:\\n\\t\\t\\t\\t\\t\\treturn [q+diff,q]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n\\t\\t\\t\\n\\t\\t\\ta = sum(A)\\n\\t\\t\\tb = sum(B)\\n\\t\\t\\ttarget = (a+b)//2\\n\\n\\t\\t\\tif a<b:\\n\\t\\t\\t\\tdiff = target-a\\n\\t\\t\\t\\tfor q in A:\\n\\t\\t\\t\\t\\tif q+diff in B:\\n\\t\\t\\t\\t\\t\\treturn [q,q+diff]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdiff = target-b\\n\\t\\t\\t\\tfor q in B:\\n\\t\\t\\t\\t\\tif q+diff in A:\\n\\t\\t\\t\\t\\t\\treturn [q+diff,q]",
                "codeTag": "Java"
            },
            {
                "id": 840246,
                "title": "c-solution-using-binary-search-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(auto it : a) sum1+=it;\\n        \\n        for(auto it :b) sum2+=it;\\n        \\n       \\n        \\n        sort(b.begin(),b.end());\\n            \\n        for(int i=0;i<a.size();i++)\\n        {\\n            int y = a[i] - (sum1 - sum2)/2;\\n            if(binary_search(b.begin(), b.end(), y))\\n            {\\n               return {a[i],y};\\n            }\\n            \\n        }\\n        return {-1,-1};\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& a, vector<int>& b) {\\n\\n        int sum1=0;\\n        int sum2=0;\\n        \\n        for(auto it : a) sum1+=it;\\n        \\n        for(auto it :b) sum2+=it;\\n        \\n       \\n        \\n        sort(b.begin(),b.end());\\n            \\n        for(int i=0;i<a.size();i++)\\n        {\\n            int y = a[i] - (sum1 - sum2)/2;\\n            if(binary_search(b.begin(), b.end(), y))\\n            {\\n               return {a[i],y};\\n            }\\n            \\n        }\\n        return {-1,-1};\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776869,
                "title": "python-code-thank-you-looks-well",
                "content": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        aa=sum(A)\\n        bb=sum(B)\\n        for i in B:\\n             if (aa-bb+2*i)//2 in A:\\n                    return [(aa-bb+2*i)//2,i]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        aa=sum(A)\\n        bb=sum(B)\\n        for i in B:\\n             if (aa-bb+2*i)//2 in A:\\n                    return [(aa-bb+2*i)//2,i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695497,
                "title": "ruby-straightforward-simple-working-solution",
                "content": "##### Leetcode: 888. Fair Candy Swap.\\n\\n\\nFirst preparations calculate total amount of candy that Alice and Bob has. Next create a hash that stores what sizes of candy each sweets owner has, sizes will be keys in these Hash maps. Now iterating over all Alice candies solve such equity `Alice_sum - candy + x = Bob_sum + candy - x` and thus `2*x = (Bob_sum + candy) - (Alice_sum - candy)` and `x` will be candy size Bob need to return. Check that `2x` is positive, even, and `x` exists in Bobs hash. And return `[candy, 2x/2]`. Done.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 888. Fair Candy Swap.\\n# https://leetcode.com/problems/fair-candy-swap/\\n# Runtime: 452 ms, faster than 56.25% of Ruby online submissions for Fair Candy Swap.\\n# Memory Usage: 13.7 MB, less than 100.00% of Ruby online submissions for Fair Candy Swap.\\n# @param {Integer[]} a\\n# @param {Integer[]} b\\n# @return {Integer[]}\\ndef fair_candy_swap(a, b)\\n    asum, bsum = a.sum, b.sum\\n    ah, bh = a.zip(a).to_h, b.zip(b).to_h\\n    a.each do |swt|\\n        x2 = (bsum + swt) - (a.sum - swt)\\n        next if x2 <= 0\\n        next if x2.odd?\\n        next if bh[x2/2].nil?\\n        return [swt,x2/2]\\n        \\n    end\\n    raise \"Cannot find answer.\"\\n    \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 888. Fair Candy Swap.\\n# https://leetcode.com/problems/fair-candy-swap/\\n# Runtime: 452 ms, faster than 56.25% of Ruby online submissions for Fair Candy Swap.\\n# Memory Usage: 13.7 MB, less than 100.00% of Ruby online submissions for Fair Candy Swap.\\n# @param {Integer[]} a\\n# @param {Integer[]} b\\n# @return {Integer[]}\\ndef fair_candy_swap(a, b)\\n    asum, bsum = a.sum, b.sum\\n    ah, bh = a.zip(a).to_h, b.zip(b).to_h\\n    a.each do |swt|\\n        x2 = (bsum + swt) - (a.sum - swt)\\n        next if x2 <= 0\\n        next if x2.odd?\\n        next if bh[x2/2].nil?\\n        return [swt,x2/2]\\n        \\n    end\\n    raise \"Cannot find answer.\"\\n    \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 694608,
                "title": "rust-hashset-8ms",
                "content": "```Rust\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn fair_candy_swap(a: Vec<i32>, b: Vec<i32>) -> Vec<i32>\\n    {\\n        let a_sum: i32 = a.iter().sum();\\n        let b_sum: i32 = b.iter().sum();\\n        let b_set: HashSet<i32> = HashSet::from_iter(b.into_iter());\\n        for x in a {\\n            let y = (b_sum - a_sum) / 2 + x;\\n            if b_set.contains(&y) {\\n                return vec![x, y];\\n            }\\n        }\\n        panic!(\"Impossible.\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn fair_candy_swap(a: Vec<i32>, b: Vec<i32>) -> Vec<i32>\\n    {\\n        let a_sum: i32 = a.iter().sum();\\n        let b_sum: i32 = b.iter().sum();\\n        let b_set: HashSet<i32> = HashSet::from_iter(b.into_iter());\\n        for x in a {\\n            let y = (b_sum - a_sum) / 2 + x;\\n            if b_set.contains(&y) {\\n                return vec![x, y];\\n            }\\n        }\\n        panic!(\"Impossible.\");\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657723,
                "title": "java-solutions-easy-to-read-with-complexities",
                "content": "From my understanding there can be a total of 3 solutions. Brute force, Binary Search, and a Set solution.\\n\\nMy brute force was straightforward, compute the sums first, and traverse through every candy bar combination until a middle ground is met by both Alice and Bob. This of course is not linear but it can be useful if we are in a memory constraint environment.\\n\\n```\\n\\t// O(N*M) Time | O(1) Space, N and M size of A and B\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int Atotal = 0, Btotal = 0;\\n        for (int i : A) Atotal += i;\\n        for (int i : B) Btotal += i;\\n        \\n        int middleGround = (Atotal + Btotal) / 2;\\n        \\n        for (int i : A) {\\n            for (int j : B) {\\n                int Asum = Atotal - i, Bsum = Btotal - j;\\n                if (Asum + j == middleGround && Bsum + i == middleGround) {\\n                    return new int[] {i, j};\\n                }\\n            }\\n        }\\n        return new int[2];\\n    }\\n```\\n\\nThe set solution is much more efficient. We first convert Bob\\'s input into a set.\\nThen we go through Alice\\'s input to see if bob has the appropriate candy bar if Alice were to give up one of hers.\\n\\n```\\n// O(N + M) Time | O(M) Space OR O(N +M) Time | O(N) Space\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int Atotal = 0, Btotal = 0;\\n        Set<Integer> bSet = new HashSet<>();\\n        for (int i : A) Atotal += i;\\n        for (int i : B) {\\n            Btotal += i;\\n            bSet.add(i);\\n        }\\n        \\n        int middleGround = (Atotal + Btotal) / 2;\\n        for (int i : A) {\\n            // if alice gives up her candy bar at i, she is expecting middleGround - (Atotal- i) from bob.\\n            if (bSet.contains(middleGround - (Atotal- i))) \\n                return new int[] {i, middleGround - (Atotal- i)};\\n        }\\n        return new int[2];\\n    }\\n```\\n\\nFor binary search instead of searching the set like we did in our previous solution, we simply run a binary search for the candy bar we are looking for. This assumes the input is sorted, which is not guaranteed in the description. At best this is a better version of the brute force.",
                "solutionTags": [],
                "code": "```\\n\\t// O(N*M) Time | O(1) Space, N and M size of A and B\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int Atotal = 0, Btotal = 0;\\n        for (int i : A) Atotal += i;\\n        for (int i : B) Btotal += i;\\n        \\n        int middleGround = (Atotal + Btotal) / 2;\\n        \\n        for (int i : A) {\\n            for (int j : B) {\\n                int Asum = Atotal - i, Bsum = Btotal - j;\\n                if (Asum + j == middleGround && Bsum + i == middleGround) {\\n                    return new int[] {i, j};\\n                }\\n            }\\n        }\\n        return new int[2];\\n    }\\n```\n```\\n// O(N + M) Time | O(M) Space OR O(N +M) Time | O(N) Space\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int Atotal = 0, Btotal = 0;\\n        Set<Integer> bSet = new HashSet<>();\\n        for (int i : A) Atotal += i;\\n        for (int i : B) {\\n            Btotal += i;\\n            bSet.add(i);\\n        }\\n        \\n        int middleGround = (Atotal + Btotal) / 2;\\n        for (int i : A) {\\n            // if alice gives up her candy bar at i, she is expecting middleGround - (Atotal- i) from bob.\\n            if (bSet.contains(middleGround - (Atotal- i))) \\n                return new int[] {i, middleGround - (Atotal- i)};\\n        }\\n        return new int[2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 646546,
                "title": "simple-clean-swift-solution-with-time-and-space-complexity",
                "content": "```\\n// Kevin Li - 7:50 PM - 5/22/20\\n\\n// https://leetcode.com/problems/fair-candy-swap/solution/\\n// Time: O(n)\\n// Space: O(n)\\n\\nclass Solution {\\n\\n    // In this solution, we solve for candySizeFromB\\n    // Equation: SumOfA - candySizeFromA + candySizeFromB = SumOfB + candySizeFromA - candySizeFromB\\n    // Equation(cont): 2 * candySizeFromB = (SumOfB - SumOfA) + (2 * candySizeFromA)\\n    // Equation(cont): candySizeFromB = ((SumOfB - SumOfA) / 2) + candySizeFromA\\n    func fairCandySwap(_ A: [Int], _ B: [Int]) -> [Int] {\\n        // complementCandySizes contains all the possible values that may\\n        // result from solving for sizeFromB in the above equation\\n        let complementCandySizes = Set(B)\\n        let sumOfA = A.reduce(0, +)\\n        let sumOfB = B.reduce(0, +)\\n        // delta represents how much sizeFromA will be shifted\\n        // in order to calculate sizeFromB\\n        let delta = (sumOfB - sumOfA) / 2\\n\\n        for candySizeFromA in A {\\n            let candySizeFromB = delta + candySizeFromA\\n            if complementCandySizes.contains(candySizeFromB) {\\n                return [candySizeFromA, candySizeFromB]\\n            }\\n        }\\n\\n        fatalError(\"Error: Problem specifies that solution is guaranteed to exist\")\\n    }\\n\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Kevin Li - 7:50 PM - 5/22/20\\n\\n// https://leetcode.com/problems/fair-candy-swap/solution/\\n// Time: O(n)\\n// Space: O(n)\\n\\nclass Solution {\\n\\n    // In this solution, we solve for candySizeFromB\\n    // Equation: SumOfA - candySizeFromA + candySizeFromB = SumOfB + candySizeFromA - candySizeFromB\\n    // Equation(cont): 2 * candySizeFromB = (SumOfB - SumOfA) + (2 * candySizeFromA)\\n    // Equation(cont): candySizeFromB = ((SumOfB - SumOfA) / 2) + candySizeFromA\\n    func fairCandySwap(_ A: [Int], _ B: [Int]) -> [Int] {\\n        // complementCandySizes contains all the possible values that may\\n        // result from solving for sizeFromB in the above equation\\n        let complementCandySizes = Set(B)\\n        let sumOfA = A.reduce(0, +)\\n        let sumOfB = B.reduce(0, +)\\n        // delta represents how much sizeFromA will be shifted\\n        // in order to calculate sizeFromB\\n        let delta = (sumOfB - sumOfA) / 2\\n\\n        for candySizeFromA in A {\\n            let candySizeFromB = delta + candySizeFromA\\n            if complementCandySizes.contains(candySizeFromB) {\\n                return [candySizeFromA, candySizeFromB]\\n            }\\n        }\\n\\n        fatalError(\"Error: Problem specifies that solution is guaranteed to exist\")\\n    }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642296,
                "title": "simplest-java",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int diff = sum(A) - sum(B);\\n        int[] swaps = new int[2];\\n        \\n            for(int i=0; i< A.length; i++) {\\n                for(int j=0;j < B.length; j++) {\\n                    if(diff == 2*(A[i]-B[j])){  //these need to be swapped.\\n                        swaps[0] = A[i];\\n                        swaps[1] = B[j];\\n                        return swaps;\\n                    }\\n                    \\n                }\\n            }\\n      \\n        return null;\\n    }\\n    \\n    int sum(int[] arr) {\\n        int sum = 0;\\n        for(int item: arr) {\\n            sum+= item;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int diff = sum(A) - sum(B);\\n        int[] swaps = new int[2];\\n        \\n            for(int i=0; i< A.length; i++) {\\n                for(int j=0;j < B.length; j++) {\\n                    if(diff == 2*(A[i]-B[j])){  //these need to be swapped.\\n                        swaps[0] = A[i];\\n                        swaps[1] = B[j];\\n                        return swaps;\\n                    }\\n                    \\n                }\\n            }\\n      \\n        return null;\\n    }\\n    \\n    int sum(int[] arr) {\\n        int sum = 0;\\n        for(int item: arr) {\\n            sum+= item;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636263,
                "title": "python-2-line-video",
                "content": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        diff, B = (sum(B) - sum(A)) / 2, set(B)\\n        return [[a, a+diff] for a in A if a + diff in B][0]\\n```\\n\\nmeaningless video: http://youtube.com/watch?v=VhqKC0HQXlM\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        diff, B = (sum(B) - sum(A)) / 2, set(B)\\n        return [[a, a+diff] for a in A if a + diff in B][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623527,
                "title": "simple-java-solution-with-arrays-easy-to-understand-anyone",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n         int[] candyPair = new int[2];\\n        int countCandiesA = 0, countCandiesB = 0;\\n        for (int i = 0; i < A.length; i++) {//counting candies in A\\n            countCandiesA += A[i];\\n        }\\n        for (int i = 0; i < B.length; i++) {//counting candies in B\\n            countCandiesB += B[i];\\n        }\\n        int candiesNeedToBeSwitched = Math.abs((countCandiesA - countCandiesB) / 2);//averaging for switch\\n        if (countCandiesA > countCandiesB) { // this case applicable when A has more candies than B\\n            for (int i = 0; i < A.length; i++) {\\n                for (int j = 0; j < B.length; j++) {\\n                    if (Math.abs(A[i] - B[j]) == candiesNeedToBeSwitched) {\\n                        if (A[i] - B[j] == candiesNeedToBeSwitched) {\\n                            candyPair[0] = A[i];\\n                            candyPair[1] = B[j];\\n                            return candyPair;\\n                        }\\n                    }\\n                }\\n            }\\n        } else {\\n            for (int i = 0; i < A.length; i++) {\\n                for (int j = 0; j < B.length; j++) {\\n                    if (Math.abs(A[i] - B[j]) == candiesNeedToBeSwitched) {\\n                        if (B[j] - A[i] == candiesNeedToBeSwitched) {\\n                            candyPair[0] = A[i];\\n                            candyPair[1] = B[j];\\n                            return candyPair;\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n        return candyPair;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n         int[] candyPair = new int[2];\\n        int countCandiesA = 0, countCandiesB = 0;\\n        for (int i = 0; i < A.length; i++) {//counting candies in A\\n            countCandiesA += A[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 604229,
                "title": "cpp-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int a=accumulate(begin(A),end(A),0);\\n        int b=accumulate(begin(B),end(B),0);\\n        \\n        if(a==b)\\n            return {};\\n        \\n        int d=a-b;\\n        unordered_set<int> aa(begin(A),end(A)),bb(begin(B),end(B));\\n        for(auto x:aa){\\n            if(bb.count(x-d/2))\\n                return {x,x-d/2};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int a=accumulate(begin(A),end(A),0);\\n        int b=accumulate(begin(B),end(B),0);\\n        \\n        if(a==b)\\n            return {};\\n        \\n        int d=a-b;\\n        unordered_set<int> aa(begin(A),end(A)),bb(begin(B),end(B));\\n        for(auto x:aa){\\n            if(bb.count(x-d/2))\\n                return {x,x-d/2};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570338,
                "title": "c-solution",
                "content": "SumA - A[i] + B[j] = SumB - B[j] + A[i]\\n=> **A[i] = (SumA - SumB) / 2 + B[j]**\\n```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B) {\\n        \\n        int[] res = new int[2];\\n        int sumA = A.Sum();\\n        int sumB = B.Sum();\\n        int diff = (sumA - sumB) / 2;\\n        \\n        HashSet<int> set = new HashSet<int>(A);\\n        for(int i = 0; i < B.Length; i++)\\n        {\\n            if(set.Contains(B[i] + diff))\\n            {\\n                res[0] = B[i] + diff;\\n                res[1] = B[i];\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B) {\\n        \\n        int[] res = new int[2];\\n        int sumA = A.Sum();\\n        int sumB = B.Sum();\\n        int diff = (sumA - sumB) / 2;\\n        \\n        HashSet<int> set = new HashSet<int>(A);\\n        for(int i = 0; i < B.Length; i++)\\n        {\\n            if(set.Contains(B[i] + diff))\\n            {\\n                res[0] = B[i] + diff;\\n                res[1] = B[i];\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494764,
                "title": "rust-12ms-2-3m-80",
                "content": "```rust\\nuse std::collections::HashSet;\\n\\npub fn fair_candy_swap(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n    let s1 = a.iter().fold(0, |acc, x| { acc + *x });\\n    let s2 = b.iter().fold(0, |acc, x| { acc + *x });\\n    let delta = (s2 - s1) / 2;\\n    let mut set = HashSet::<i32>::new();\\n    for x in b { set.insert(x); }\\n    for x in a {\\n        if set.contains(&(x + delta)) {\\n            return vec![x, x + delta];\\n        }\\n    }\\n    panic!()\\n}\\n\\n````",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\npub fn fair_candy_swap(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n    let s1 = a.iter().fold(0, |acc, x| { acc + *x });\\n    let s2 = b.iter().fold(0, |acc, x| { acc + *x });\\n    let delta = (s2 - s1) / 2;\\n    let mut set = HashSet::<i32>::new();\\n    for x in b { set.insert(x); }\\n    for x in a {\\n        if set.contains(&(x + delta)) {\\n            return vec![x, x + delta];\\n        }\\n    }\\n    panic!()\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399536,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        l = (sum(A) - sum(B)) // 2\\n\\t\\tfor i in set(A):\\n\\t\\t    if i - l in set(B):\\n\\t\\t        return [i, i-l]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        l = (sum(A) - sum(B)) // 2\\n\\t\\tfor i in set(A):\\n\\t\\t    if i - l in set(B):\\n\\t\\t        return [i, i-l]",
                "codeTag": "Java"
            },
            {
                "id": 395876,
                "title": "python-3-solution-beats-95",
                "content": "Algo\\nIn order for the candy sizes after swap to be equal, the diffrence of  swapped candy sizes must be one half of the difference in total size before swapping, i.e. \\n\\ndiff = (sum(B) - sum(A))//2\\n\\nAfter that, loop through elements in A and check if a candy larger than the current element of A by diff exists in B. If so, return the pair. \\n\\n```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(B) - sum(A))//2\\n        B = set(B)\\n        for a in A:\\n            if a + diff in B:\\n                return [a, a+diff]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(B) - sum(A))//2\\n        B = set(B)\\n        for a in A:\\n            if a + diff in B:\\n                return [a, a+diff]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381856,
                "title": "solution-in-python-3-two-lines",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n    \\td, SA, SB = (sum(A) - sum(B))//2, set(A), set(B)\\n    \\treturn [[i, i - d] for i in SA if i - d in SB][0]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n    \\td, SA, SB = (sum(A) - sum(B))//2, set(A), set(B)\\n    \\treturn [[i, i - d] for i in SA if i - d in SB][0]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 368353,
                "title": "easy-cpp-solution-using-hash",
                "content": "Runtime: 112 ms, faster than 86.51% of C++ online submissions for Fair Candy Swap.\\nMemory Usage: 23.7 MB, less than 10.00% of C++ online submissions for Fair Candy Swap.\\n\\n```\\nvector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        int m = B.size();\\n        unordered_set<int> mp;\\n        \\n        int sum1 = 0;\\n        int sum2 = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sum1 += A[i];\\n            mp.insert(A[i]);\\n        }\\n        \\n        for(int j=0; j<m; j++)\\n            sum2 += B[j];\\n        \\n        int diff = (sum1 - sum2)/2;\\n        \\n        for(int j=0; j<m; j++)\\n        {\\n            if(mp.find(B[j] + diff) != mp.end())\\n                return vector<int>{B[j]+diff, B[j]};\\n        }\\n        \\n        return vector<int>{};\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Runtime: 112 ms, faster than 86.51% of C++ online submissions for Fair Candy Swap.\\nMemory Usage: 23.7 MB, less than 10.00% of C++ online submissions for Fair Candy Swap.\\n\\n```\\nvector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        int m = B.size();\\n        unordered_set<int> mp;\\n        \\n        int sum1 = 0;\\n        int sum2 = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sum1 += A[i];\\n            mp.insert(A[i]);\\n        }\\n        \\n        for(int j=0; j<m; j++)\\n            sum2 += B[j];\\n        \\n        int diff = (sum1 - sum2)/2;\\n        \\n        for(int j=0; j<m; j++)\\n        {\\n            if(mp.find(B[j] + diff) != mp.end())\\n                return vector<int>{B[j]+diff, B[j]};\\n        }\\n        \\n        return vector<int>{};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 352194,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nsA-x+y = sB-y+x => 2x = sA+2y-sB\\n\\n```\\n    public int[] fairCandySwap(int[] a, int[] b) {\\n        int sA = 0, sB = 0;\\n        Set<Integer> setA = new HashSet<>();\\n        for(int x : a){\\n            setA.add(x);\\n            sA += x;\\n        }\\n        for(int y : b)\\n            sB += y;\\n        for(int y : b){\\n            int x = (sA+2*y-sB) / 2;\\n            if(setA.contains(x))\\n                return new int[]{x, y};\\n        }\\n        //never reaches\\n        return new int[2];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] fairCandySwap(int[] a, int[] b) {\\n        int sA = 0, sB = 0;\\n        Set<Integer> setA = new HashSet<>();\\n        for(int x : a){\\n            setA.add(x);\\n            sA += x;\\n        }\\n        for(int y : b)\\n            sB += y;\\n        for(int y : b){\\n            int x = (sA+2*y-sB) / 2;\\n            if(setA.contains(x))\\n                return new int[]{x, y};\\n        }\\n        //never reaches\\n        return new int[2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308051,
                "title": "python-o-n-by-set",
                "content": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        b_set = set(B)\\n        sumA,sumB = sum(A),sum(B)\\n        diff = (sumB-sumA)/2\\n        \\n        for item in A:\\n            target = item+diff\\n            if target in b_set:\\n                return [item, item+diff]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        b_set = set(B)\\n        sumA,sumB = sum(A),sum(B)\\n        diff = (sumB-sumA)/2\\n        \\n        for item in A:\\n            target = item+diff\\n            if target in b_set:\\n                return [item, item+diff]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306497,
                "title": "o-nlogn-java-sol-with-no-extra-space-binary-search-93",
                "content": "```\\nclass Solution \\n{\\n    int sum(int a[])\\n    {\\n        int s=0;\\n        for(int i=0;i<a.length;i++)\\n            s=s+a[i];\\n        return s;\\n    }\\n    public int[] fairCandySwap(int[] a, int[] b) \\n    {\\n        int s1=sum(a);\\n        int s2=sum(b);\\n        int ans[]=new int[2];\\n        \\n        if(s1>s2)\\n        {\\n            int c=(s1-s2)/2;\\n            Arrays.sort(b);\\n            for(Integer i:a)\\n            {\\n                if(Arrays.binarySearch(b,i-c)>=0)\\n                {\\n                    ans[0]=i;\\n                    ans[1]=i-c;\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            int c=(s2-s1)/2;\\n            Arrays.sort(a);\\n            for(Integer i:b)\\n            {\\n                if(Arrays.binarySearch(a,i-c)>=0)\\n                {\\n                    ans[0]=i-c;\\n                    ans[1]=i;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    int sum(int a[])\\n    {\\n        int s=0;\\n        for(int i=0;i<a.length;i++)\\n            s=s+a[i];\\n        return s;\\n    }\\n    public int[] fairCandySwap(int[] a, int[] b) \\n    {\\n        int s1=sum(a);\\n        int s2=sum(b);\\n        int ans[]=new int[2];\\n        \\n        if(s1>s2)\\n        {\\n            int c=(s1-s2)/2;\\n            Arrays.sort(b);\\n            for(Integer i:a)\\n            {\\n                if(Arrays.binarySearch(b,i-c)>=0)\\n                {\\n                    ans[0]=i;\\n                    ans[1]=i-c;\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            int c=(s2-s1)/2;\\n            Arrays.sort(a);\\n            for(Integer i:b)\\n            {\\n                if(Arrays.binarySearch(a,i-c)>=0)\\n                {\\n                    ans[0]=i-c;\\n                    ans[1]=i;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295673,
                "title": "python3-simple-math",
                "content": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(A) - sum(B)) // 2\\n        for num in A:\\n            if num - diff in B:\\n                return [num, num - diff]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\\n        diff = (sum(A) - sum(B)) // 2\\n        for num in A:\\n            if num - diff in B:\\n                return [num, num - diff]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284253,
                "title": "c-constant-space-o-n-ln-n-time",
                "content": "```\\n\\tpublic int[] FairCandySwap(int[] A, int[] B) {\\n        int dif = (A.Sum() - B.Sum()) / 2;\\n        Array.Sort(A);\\n        Array.Sort(B);\\n        int i = 0, j = 0;\\n        while (A[i] - B[j] != dif)\\n        {\\n            while (A[i] - B[j] > dif) j++;\\n            while (A[i] - B[j] < dif) i++;\\n        }\\n        return new int[] { A[i], B[j] };\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[] FairCandySwap(int[] A, int[] B) {\\n        int dif = (A.Sum() - B.Sum()) / 2;\\n        Array.Sort(A);\\n        Array.Sort(B);\\n        int i = 0, j = 0;\\n        while (A[i] - B[j] != dif)\\n        {\\n            while (A[i] - B[j] > dif) j++;\\n            while (A[i] - B[j] < dif) i++;\\n        }\\n        return new int[] { A[i], B[j] };\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275850,
                "title": "javascript-o-n-100-readable",
                "content": "```\\nvar fairCandySwap = function(A, B) {    \\n    const sum = (first, next) => first + next;\\n    \\n    const sumA = A.reduce(sum);\\n    const sumB = B.reduce(sum);\\n    \\n    // sum of both together has to be even for this to work\\n    // if ( (sumA + sumB) % 2 !== 0 ) return false;\\n    \\n    const mid = (sumA + sumB) / 2;\\n    \\n    const setB = new Set(B);      \\n    \\n    for (let i=0; i< A.length; i++ ) {     \\n        const current = A[i];\\n        const withoutCurrent = sumA - current;\\n        const searchedItem = mid - withoutCurrent;\\n                       \\n        if ( setB.has(searchedItem) &&  sumB - searchedItem + current === mid ) {\\n            return [ A[i], searchedItem ];\\n        }        \\n    }      \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar fairCandySwap = function(A, B) {    \\n    const sum = (first, next) => first + next;\\n    \\n    const sumA = A.reduce(sum);\\n    const sumB = B.reduce(sum);\\n    \\n    // sum of both together has to be even for this to work\\n    // if ( (sumA + sumB) % 2 !== 0 ) return false;\\n    \\n    const mid = (sumA + sumB) / 2;\\n    \\n    const setB = new Set(B);      \\n    \\n    for (let i=0; i< A.length; i++ ) {     \\n        const current = A[i];\\n        const withoutCurrent = sumA - current;\\n        const searchedItem = mid - withoutCurrent;\\n                       \\n        if ( setB.has(searchedItem) &&  sumB - searchedItem + current === mid ) {\\n            return [ A[i], searchedItem ];\\n        }        \\n    }      \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 236648,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int a_sum =0;\\n        int b_sum =0;\\n        int sum =0;\\n        int[] ans = new int[2];\\n        HashMap<Integer,Integer> b= new HashMap<Integer,Integer>();\\n        for(int i=0; i<A.length;i++){\\n           a_sum +=A[i];\\n        }\\n        for(int i=0; i<B.length;i++){\\n            b_sum +=B[i];\\n            b.put(B[i],i);\\n        }\\n        sum = (a_sum + b_sum)/2;\\n         for(int i=0; i<A.length;i++){\\n            int c = (sum-a_sum+A[i]); \\n             if(b.containsKey(c)){\\n                 ans[1]=c;\\n                 ans[0]=A[i];\\n                 break;\\n             }\\n         }\\n        \\n        \\n    return ans;}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] fairCandySwap(int[] A, int[] B) {\\n        int a_sum =0;\\n        int b_sum =0;\\n        int sum =0;\\n        int[] ans = new int[2];\\n        HashMap<Integer,Integer> b= new HashMap<Integer,Integer>();\\n        for(int i=0; i<A.length;i++){\\n           a_sum +=A[i];\\n        }\\n        for(int i=0; i<B.length;i++){\\n            b_sum +=B[i];\\n            b.put(B[i],i);\\n        }\\n        sum = (a_sum + b_sum)/2;\\n         for(int i=0; i<A.length;i++){\\n            int c = (sum-a_sum+A[i]); \\n             if(b.containsKey(c)){\\n                 ans[1]=c;\\n                 ans[0]=A[i];\\n                 break;\\n             }\\n         }\\n        \\n        \\n    return ans;}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234432,
                "title": "simple-python-with-explaination",
                "content": "The goal is to have both lists have to same sum after trading one item with each other. The value of the sum therefore has to be equal to the average of the two lists i.e [sum(listA) + sum(listB)] / 2 = (target sum value of each list individually)\\n\\nAfter finding the target sum, then take item out of listA and try to find the opposing value that satifies (listA - a) + b = target\\n\\n\\tdef fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sumA = 0\\n        sumB = 0\\n        setB = set()\\n        \\n        for a in A:\\n            sumA = sumA + a\\n        \\n        for b in B:\\n            sumB = sumB + b\\n            setB.add(b)\\n            \\n        target = (sumA + sumB)//2\\n        \\n        for a in A:\\n            need = (target - (sumA - a)) \\n\\n            if need in setB:\\n                return [a, need]",
                "solutionTags": [],
                "code": "The goal is to have both lists have to same sum after trading one item with each other. The value of the sum therefore has to be equal to the average of the two lists i.e [sum(listA) + sum(listB)] / 2 = (target sum value of each list individually)\\n\\nAfter finding the target sum, then take item out of listA and try to find the opposing value that satifies (listA - a) + b = target\\n\\n\\tdef fairCandySwap(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sumA = 0\\n        sumB = 0\\n        setB = set()\\n        \\n        for a in A:\\n            sumA = sumA + a\\n        \\n        for b in B:\\n            sumB = sumB + b\\n            setB.add(b)\\n            \\n        target = (sumA + sumB)//2\\n        \\n        for a in A:\\n            need = (target - (sumA - a)) \\n\\n            if need in setB:\\n                return [a, need]",
                "codeTag": "Python3"
            },
            {
                "id": 175899,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun fairCandySwap(A: IntArray, B: IntArray): IntArray {\\n        val sumA = A.sum()\\n        val sumB = B.sum()\\n        val diff = (sumA - sumB) / 2\\n        val setB = B.toSet()\\n        val a = A.filter { setB.contains(it - diff) }.first()\\n        return intArrayOf(a, a - diff)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun fairCandySwap(A: IntArray, B: IntArray): IntArray {\\n        val sumA = A.sum()\\n        val sumB = B.sum()\\n        val diff = (sumA - sumB) / 2\\n        val setB = B.toSet()\\n        val a = A.filter { setB.contains(it - diff) }.first()\\n        return intArrayOf(a, a - diff)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170149,
                "title": "simple-scala-beats-100",
                "content": "Suppose the answer is `a` from A and `b` from B.\\nWe can get `A.sum - a + b = B.sum - b + a`, and then `b = a - (A.sum - B.sum)/2`.\\n```\\nobject Solution {\\n    def fairCandySwap(A: Array[Int], B: Array[Int]): Array[Int] = {\\n        val delta = A.sum - B.sum\\n        val bSet = B.toSet\\n        for (x <- A) {\\n            if (bSet contains (x - delta / 2))\\n                return Array(x, x - delta / 2)\\n        }\\n        Array() // no answer\\'s return \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def fairCandySwap(A: Array[Int], B: Array[Int]): Array[Int] = {\\n        val delta = A.sum - B.sum\\n        val bSet = B.toSet\\n        for (x <- A) {\\n            if (bSet contains (x - delta / 2))\\n                return Array(x, x - delta / 2)\\n        }\\n        Array() // no answer\\'s return \\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 169002,
                "title": "java-easy-solution-using-two-pointer",
                "content": "\\'\\'\\'\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0;\\n        int sumB = 0;\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        for (int i = 0; i <A.length ; i++) {\\n            sumA+=A[i];\\n        }\\n        for (int i = 0; i <B.length ; i++) {\\n            sumB+=B[i];\\n        }\\n        int dif = (sumA-sumB)/2;\\n        int i =0;int j =0;\\n        while (i<A.length||j<B.length){\\n            if(A[i]-B[j]<dif) i++;\\n            else if(A[i]-B[j]>dif) j++;\\n            else break;\\n        }\\n        return new int[]{A[i],B[j]};\\n    }\\n\\t\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\npublic int[] fairCandySwap(int[] A, int[] B) {\\n        int sumA = 0;\\n        int sumB = 0;\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        for (int i = 0; i <A.length ; i++) {\\n            sumA+=A[i];\\n        }\\n        for (int i = 0; i <B.length ; i++) {\\n            sumB+=B[i];\\n        }\\n        int dif = (sumA-sumB)/2;\\n        int i =0;int j =0;\\n        while (i<A.length||j<B.length){\\n            if(A[i]-B[j]<dif) i++;\\n            else if(A[i]-B[j]>dif) j++;\\n            else break;\\n        }\\n        return new int[]{A[i],B[j]};\\n    }\\n\\t\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 166309,
                "title": "c-readable-code",
                "content": "It is an easy level array algorithm. I wrote the algorithm but failed twice, I made the change to pass online judge. I like to share my C# code here. \\n\\n```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B)\\n        {\\n            if (A == null || B == null)\\n                return new int[0];\\n\\n            var sumA = A.Sum();\\n            var sumB = B.Sum();\\n\\n            if (sumA > sumB)\\n            {\\n                var result = FairCandySwap(B, A);\\n                return new int[] { result[1], result[0] };\\n            }\\n\\n            // A is small one\\n            var diff = sumB - sumA;\\n            var hashSet = new HashSet<int>(B);\\n\\n            foreach(var item in A)\\n            {\\n                var search = item + diff/2; \\n                if(hashSet.Contains(search))\\n                {\\n                    return new int[] { item, search };\\n                }\\n            }\\n\\n            return new int[0];\\n        }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] FairCandySwap(int[] A, int[] B)\\n        {\\n            if (A == null || B == null)\\n                return new int[0];\\n\\n            var sumA = A.Sum();\\n            var sumB = B.Sum();\\n\\n            if (sumA > sumB)\\n            {\\n                var result = FairCandySwap(B, A);\\n                return new int[] { result[1], result[0] };\\n            }\\n\\n            // A is small one\\n            var diff = sumB - sumA;\\n            var hashSet = new HashSet<int>(B);\\n\\n            foreach(var item in A)\\n            {\\n                var search = item + diff/2; \\n                if(hashSet.Contains(search))\\n                {\\n                    return new int[] { item, search };\\n                }\\n            }\\n\\n            return new int[0];\\n        }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1629846,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 1843504,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 1567031,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 1786853,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 2021303,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 1952350,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 1733578,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 2071103,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            },
            {
                "id": 2064271,
                "content": [
                    {
                        "username": "ewurst",
                        "content": "Why is this marked as binary search?"
                    },
                    {
                        "username": "ap3223",
                        "content": "[@sathya991](/sathya991) you used sorting itis considered nlogn still no meaning"
                    },
                    {
                        "username": "sathya991",
                        "content": "[@atharvakalele](/atharvakalele) \nHey, I did using Binary Search. Check it out \n\n```\nclass Solution {\n    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {\n        int aSum = sum(aliceSizes);\n        int bSum = sum(bobSizes);\n        Arrays.sort(bobSizes);\n        int mid = aSum+(bSum-aSum)/2;\n        for(int i: aliceSizes){\n            int a = Arrays.binarySearch(bobSizes,(bSum+i)-mid);\n            if(a >= 0){\n                return new int[]{i,bobSizes[a]};\n            }\n        }\n        return new int[]{-1,-1};\n    }\n    public int sum(int[] ar){\n        int s = 0;\n        for(int i: ar){\n            s += i;\n        }\n        return s;\n    }\n}\n```"
                    },
                    {
                        "username": "atharvakalele",
                        "content": "I did it using binary search but only 34/75 testcases passed. If you want the code and if you can help me rectify it well it\\'d be gud for both of us. Just tell me in case."
                    },
                    {
                        "username": "Princesah999",
                        "content": "should give the explanation of examples ;(\\n"
                    },
                    {
                        "username": "libai8723",
                        "content": "So the question description imply that after only one time candy-bar exchange, Alice and Bob will have the same amounts?\\n\\nAnd there will be at least one solution?\\n\\nSo this is the constraints?"
                    },
                    {
                        "username": "neoistheone123",
                        "content": "This problem should be medium. Took me a while to understand the zero-sum concept here.\nLeetCode's solution is not intuitive. I posted my solution which is easier to understand and has same efficiency."
                    },
                    {
                        "username": "omkareswarhota1234",
                        "content": "i am not able to understand this question plz explain it"
                    },
                    {
                        "username": "mraza6601",
                        "content": "Let\\'s say both Alice And bob have some boxes which contains different no of candies. It is also provided that the total no of candies they have is not equal.\\n\\nSince they are friends, they want to make sure that they have equal no of candies. They can do that by exchanging one of their boxes.\\n\\nSo, in short , Alice will provide some of her candies to Bob and Bob will also provide some of his candies to Alice in a way that they have equal no of candies. \\n\\nYou need to find the no of candies:\\n1)That Alice will give to Bob\\n2)That Bob will give Alice."
                    },
                    {
                        "username": "mr_mods",
                        "content": " Bob is Here to Explain : \\nBEFORE EXCHANGE :\\nalice has 2 candies\\nbob has 4 candies\\n\\nafter exchange, the both should have equal amount of candies\\nAFTER EXCHANGE:\\nalice has 3 candies\\nbob has 3 candies\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Looking for some **tips**? Check the image bellow \\uD83D\\uDC47\\n\\n![FairCandySwap](https://lh3.googleusercontent.com/u/0/drive-viewer/AK7aPaBgRNUUPZudX_Z2rmP8pmrGQ9AewLrvDmruGz0-w-Fu-PsNPdwUyNgoW_Pa8EU8zQNbQu9f3ZTi5E4fTEcuISEizCy_Bg=w1920-h965)"
                    },
                    {
                        "username": "ganeshsm466",
                        "content": "hint:we have to distribute candies equally\nsuppose you removed one box from alice side and added to bob side,\nnow we have to pick one box from bob's side which will be box with extra candies(extra candies=difference between total candies bob currently have - candies he should get(half of total candies of alice and bob))\nin this way we can equally distribute candies by exchanging one box from alice and one box from bob;\n//1)iterate over alice to remove one  box\n2)to find particular box on bob's side with given candies(extra candies)we can apply binary search "
                    }
                ]
            }
        ]
    }
]