[
    {
        "title": "Snail Traversal",
        "question_content": "Write code that enhances all arrays such that you can call the snail(rowsCount, colsCount) method that transforms the 1D&nbsp;array into&nbsp;a 2D array organised in&nbsp;the pattern known as snail traversal order. Invalid input values should output an empty array. If&nbsp;rowsCount * colsCount !== nums.length,&nbsp;the input is considered invalid.\nSnail traversal order&nbsp;starts at the top left cell with the first value of the current array. It then moves through the entire first column from top to bottom, followed by moving to the next column on the right and traversing it from bottom to top. This pattern continues, alternating the direction of traversal with each column, until the entire current array is covered. For example, when given the input array&nbsp;[19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15] with rowsCount = 5 and colsCount = 4,&nbsp;the desired output matrix is shown below. Note that iterating the matrix following the arrows corresponds to the order of numbers in the original array.\n&nbsp;\n\n&nbsp;\nExample 1:\n\nInput: \nnums = [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]\nrowsCount = 5\ncolsCount = 4\nOutput: \n[\n [19,17,16,15],\n&nbsp;[10,1,14,4],\n&nbsp;[3,2,12,20],\n&nbsp;[7,5,18,11],\n&nbsp;[9,8,6,13]\n]\n\nExample 2:\n\nInput: \nnums = [1,2,3,4]\nrowsCount = 1\ncolsCount = 4\nOutput: [[1, 2, 3, 4]]\n\nExample 3:\n\nInput: \nnums = [1,3]\nrowsCount = 2\ncolsCount = 2\nOutput: []\nExplanation: 2 multiplied by 2 is 4, and the original array [1,3] has a length of 2; therefore, the input is invalid.\n\n&nbsp;\nConstraints:\n\n\t0 <= nums.length <= 250\n\t1 <= nums[i] <= 1000\n\t1 <= rowsCount <= 250\n\t1 <= colsCount <= 250\n\n&nbsp;",
        "solutions": [
            {
                "id": 3567988,
                "title": "snail-easy-detail-explanation",
                "content": "## \\u2705\\u2705 Please Upvote if you find it useful \\u2705\\u2705\\n\\n1. The `Array.prototype.snail` function extends the functionality of the JavaScript `Array` prototype, allowing you to convert a one-dimensional array into a two-dimensional snail-shaped matrix based on the specified number of rows and columns.\\n\\n2. The function takes two parameters: `numRows` and `numCols`, which represent the number of rows and columns in the resulting matrix.\\n\\n3. We first checks whether the total number of elements in the array matches the expected number of elements based on the provided `numRows` and `numCols`. If they don\\'t match, it returns an empty array, indicating that the conversion is not possible.\\n\\n4. Then, we create an empty `result` array, which will store the elements of the resulting matrix. The `Array()` constructor is used to create an array with a length equal to `numRows`. The `fill()` method fills this array with empty arrays, essentially initializing a matrix structure.\\n\\n5. The nested loops iterate over the `numCols` and `numRows` to fill the result matrix. The outer loop, represented by `row`, iterates over the columns.\\n\\n6. Inside the outer loop, the inner loop, represented by `col`, iterates over the rows.\\n\\n7. The matrix elements are inserted into the `result` matrix based on their position in the snail shape. The conditional expression `(row & 1)` checks if the current row index is odd. If it is odd, it means the elements need to be inserted in reverse order, so the formula `numRows - col - 1` is used to calculate the correct index for insertion. Otherwise, if the row index is even, the elements are inserted in the regular order using the `col` index.\\n\\n8. The elements are pushed into the respective row of the `result` matrix using the calculated index.\\n\\n9. Once all the elements are inserted into the `result` matrix, it is returned as the final result.\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(numRows, numCols) {\\n  if (numRows * numCols !== this.length) return [];\\n  let result = Array(numRows).fill().map(() => []);\\n  for (let row = 0; row < numCols; row++) {\\n    for (let col = 0; col < numRows; col++) {\\n      result[(row & 1) ? numRows - col - 1 : col].push(this[row * numRows + col]);\\n    }\\n  }\\n  return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```\\n## \\u2705\\u2705 Please Upvote if you find it useful \\u2705\\u2705",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(numRows, numCols) {\\n  if (numRows * numCols !== this.length) return [];\\n  let result = Array(numRows).fill().map(() => []);\\n  for (let row = 0; row < numCols; row++) {\\n    for (let col = 0; col < numRows; col++) {\\n      result[(row & 1) ? numRows - col - 1 : col].push(this[row * numRows + col]);\\n    }\\n  }\\n  return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411949,
                "title": "100-only-one-for-loop",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(this.length !==  rowsCount * colsCount) return [];\\n    let result = Array(rowsCount).fill([]).map(() => []);\\n    for(let j = 0; j < this.length; j++){\\n        const i = Math.floor(j / rowsCount);\\n        if(i % 2 === 0){\\n            result[j % rowsCount][i] = this[j];\\n        }else{\\n            result[rowsCount - j % rowsCount - 1][i] = this[j];\\n        }\\n    }\\n    return result;\\n}\\n\\n/**     \\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(this.length !==  rowsCount * colsCount) return [];\\n    let result = Array(rowsCount).fill([]).map(() => []);\\n    for(let j = 0; j < this.length; j++){\\n        const i = Math.floor(j / rowsCount);\\n        if(i % 2 === 0){\\n            result[j % rowsCount][i] = this[j];\\n        }else{\\n            result[rowsCount - j % rowsCount - 1][i] = this[j];\\n        }\\n    }\\n    return result;\\n}\\n\\n/**     \\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407431,
                "title": "typescript-using-alternation",
                "content": "```typescript []\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function (rowsCount: number, colsCount: number): number[][] {\\n    if (rowsCount * colsCount != this.length) {\\n        return []\\n    }\\n\\n    const result = (new Array(rowsCount)).fill([]).map(_ => (new Array(colsCount)).fill(0))\\n\\n    let y = 0, x = 0, alt = 1\\n    this.forEach(v => {\\n        result[y][x] = v\\n        y += alt\\n        if (y === rowsCount || y === -1) {\\n            ++x\\n            alt = -alt\\n            y += alt\\n        }\\n    })\\n    return result\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript []\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function (rowsCount: number, colsCount: number): number[][] {\\n    if (rowsCount * colsCount != this.length) {\\n        return []\\n    }\\n\\n    const result = (new Array(rowsCount)).fill([]).map(_ => (new Array(colsCount)).fill(0))\\n\\n    let y = 0, x = 0, alt = 1\\n    this.forEach(v => {\\n        result[y][x] = v\\n        y += alt\\n        if (y === rowsCount || y === -1) {\\n            ++x\\n            alt = -alt\\n            y += alt\\n        }\\n    })\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3581423,
                "title": "full-simple-explanation-beginner-friendly",
                "content": "# Intuition\\nThe ```this``` array conveys the order the snail traversed. In the two-dimensional array we return, we need to depict the visual back and forth motion the snail makes, as shown in the problem description. Since the snail never goes to the left, we don\\'t have to place values to the left of other values in the return array. This way, we can iterate throughout the ```this``` array chronologically without worry that we can\\'t push to one of the rows of the array in a fairly straight forward manner.\\n\\nAnd so, we can iterate through the ```this``` array, while keeping track of where the snail is (meaning which row in the array we are returning), as well as the direction the snail is going. This will allow us to know which row we are pushing, and what direction we need to go to push the next value.\\n\\n# Approach\\n- If ```rowsCount``` and ```colsCount``` does not match the length of the ```this``` array, return an empty array. No snail path __@\\u256F^\\u2570\\n- Otherwise, start solving. Initialize the array we are returning, ```snailPath```. Then, push ```rowsCount``` number of empty arrays.\\n- Initialize ```curRow``` to 0.\\n- Initialize ```dir``` to 1. ```dir``` will be set to either 1 or -1 (depending on which direction we are heading), and we will add ```dir``` to ```curRow``` to move up or down.\\n    - If ```dir``` is 1, the snail is moving down, since we\\'re adding 1 to the current row. If ```dir``` is -1, the snail is moving up, since we\\'re adding -1 (aka subtracting 1) from the current row\\n- Iterate through the ```this``` array. In each iteration, push ```this[i]``` to the current row of ```snailPath```. Then, if we\\'ve reached the end of a column, that means the snail is turning around, so we need to change direction. Otherwise, increment current row: ```curRow += dir```. This will move ```curRow``` one up or one down, depending on the value of ```dir```.\\n    - Note: If the snail is at the end of a column, we only change direction, we don\\'t increment ```curRow``` at all. If you look at the snail\\'s movement pattern, it technically changes direction by either moving down to right to up, or moving up to right to down. By not changing ```curRow```, the next iteration will push to the same row as the last one, thereby automatically creating a movement to the right (a cell is pushed to a row, we change direction, then by pushing the next cell to the same row it is to the right of the previous one).\\n- SNAIL PATH!!!! __@^-^\\n\\n# Code\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount != this.length) return [];\\n\\n    let snailPath = []; // snail path!! :D\\n    for (let i = 0; i < rowsCount; ++i)\\n        snailPath.push([]);\\n\\n    let curRow = 0;\\n    let dir = 1; // 1 -> going down ; -1 -> going up\\n\\n    for (let i = 0; i < this.length; ++i) {\\n        snailPath[curRow].push(this[i]); // push current value\\n\\n        // if reached end of column, change direction\\n        // else, change curRow\\n        if (curRow === 0 && dir === -1) dir = 1;\\n        else if (curRow === rowsCount - 1 && dir === 1) dir = -1; \\n        else curRow += dir; // dir will always be either 1 or -1\\n    }\\n\\n    return snailPath; // snail path!!!! __@^-^\\n}\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Matrix"
                ],
                "code": "```this```\n```this```\n```this```\n```rowsCount```\n```colsCount```\n```this```\n```snailPath```\n```rowsCount```\n```curRow```\n```dir```\n```dir```\n```dir```\n```curRow```\n```dir```\n```dir```\n```this```\n```this[i]```\n```snailPath```\n```curRow += dir```\n```curRow```\n```dir```\n```curRow```\n```curRow```\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount != this.length) return [];\\n\\n    let snailPath = []; // snail path!! :D\\n    for (let i = 0; i < rowsCount; ++i)\\n        snailPath.push([]);\\n\\n    let curRow = 0;\\n    let dir = 1; // 1 -> going down ; -1 -> going up\\n\\n    for (let i = 0; i < this.length; ++i) {\\n        snailPath[curRow].push(this[i]); // push current value\\n\\n        // if reached end of column, change direction\\n        // else, change curRow\\n        if (curRow === 0 && dir === -1) dir = 1;\\n        else if (curRow === rowsCount - 1 && dir === 1) dir = -1; \\n        else curRow += dir; // dir will always be either 1 or -1\\n    }\\n\\n    return snailPath; // snail path!!!! __@^-^\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440262,
                "title": "one-loop-5-lines-js",
                "content": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount * colsCount !== this.length) return []\\n    \\n    return this.reduce((res,item, index) => {\\n        let col = index % rowsCount\\n        let row = Math.floor(index / rowsCount)\\n\\n        if(row % 2 !== 0){col = rowsCount - col -1}\\n        \\n        res[col] = [...(res[col] || []), item]\\n        return res\\n    }, [])\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount * colsCount !== this.length) return []\\n    \\n    return this.reduce((res,item, index) => {\\n        let col = index % rowsCount\\n        let row = Math.floor(index / rowsCount)\\n\\n        if(row % 2 !== 0){col = rowsCount - col -1}\\n        \\n        res[col] = [...(res[col] || []), item]\\n        return res\\n    }, [])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421279,
                "title": "simple-traverse-faster-96-6-lines-only",
                "content": "```js\\nArray.prototype.snail = function(row, col) {\\n    if (row * col != this.length) return [];\\n    let res = Array(row).fill().map(() => []);\\n    for (let i = 0; i < col; i++)\\n        for (let j = 0; j < row; j++) {\\n            let index = (i & 1) ? row - j - 1: j, \\n                item = this[i * row + j];\\n            res[index].push(item);\\n        }\\n    return res;\\n}\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nArray.prototype.snail = function(row, col) {\\n    if (row * col != this.length) return [];\\n    let res = Array(row).fill().map(() => []);\\n    for (let i = 0; i < col; i++)\\n        for (let j = 0; j < row; j++) {\\n            let index = (i & 1) ? row - j - 1: j, \\n                item = this[i * row + j];\\n            res[index].push(item);\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409847,
                "title": "just-loops",
                "content": "# Intuition\\nSimple loops.\\n\\n# Approach\\nKeep the topRow, bottomRow, leftCol and rightCol separately.\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(m * n)\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n  if (rowsCount * colsCount !== this.length) return [];\\n  \\n  const result = new Array(rowsCount).fill().map(() => new Array(colsCount).fill(null));\\n  let topRow = 0, bottomRow = rowsCount - 1, leftCol = 0, rightCol = colsCount - 1;\\n  let index = 0;\\n  let rev = false;\\n  \\n  while (topRow <= bottomRow && leftCol <= rightCol) {\\n    if (rev) {\\n      for (let i = bottomRow; i >= topRow; i--) {\\n        result[i][leftCol] = this[index++];\\n      }\\n    } else {\\n      for (let i = topRow; i <= bottomRow; i++) {\\n        result[i][leftCol] = this[index++];\\n      }\\n    }\\n    ++leftCol;\\n    rev = !rev; \\n  }\\n  \\n  return result;\\n};\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n  if (rowsCount * colsCount !== this.length) return [];\\n  \\n  const result = new Array(rowsCount).fill().map(() => new Array(colsCount).fill(null));\\n  let topRow = 0, bottomRow = rowsCount - 1, leftCol = 0, rightCol = colsCount - 1;\\n  let index = 0;\\n  let rev = false;\\n  \\n  while (topRow <= bottomRow && leftCol <= rightCol) {\\n    if (rev) {\\n      for (let i = bottomRow; i >= topRow; i--) {\\n        result[i][leftCol] = this[index++];\\n      }\\n    } else {\\n      for (let i = topRow; i <= bottomRow; i++) {\\n        result[i][leftCol] = this[index++];\\n      }\\n    }\\n    ++leftCol;\\n    rev = !rev; \\n  }\\n  \\n  return result;\\n};\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3750290,
                "title": "very-easy-and-simple-solution-in-js",
                "content": "# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = []\\n    let isOdd = true\\n    let curr = 0\\n    if(rowsCount * colsCount != this.length) return []\\n    for(let j = 0; j < rowsCount; j++) {\\n        result.push([])\\n    }\\n    for(let i = 0; i < colsCount; i++) {\\n        if(isOdd) {\\n            for(let j = 0; j < rowsCount; j++) {\\n            result[j][i] = this[curr]\\n            curr++\\n            isOdd = false\\n            }\\n        } else {\\n            for(let j = rowsCount - 1; j >= 0; j--) {\\n            result[j][i] = this[curr]\\n            curr++\\n            isOdd = true\\n        }\\n        }\\n    }\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = []\\n    let isOdd = true\\n    let curr = 0\\n    if(rowsCount * colsCount != this.length) return []\\n    for(let j = 0; j < rowsCount; j++) {\\n        result.push([])\\n    }\\n    for(let i = 0; i < colsCount; i++) {\\n        if(isOdd) {\\n            for(let j = 0; j < rowsCount; j++) {\\n            result[j][i] = this[curr]\\n            curr++\\n            isOdd = false\\n            }\\n        } else {\\n            for(let j = rowsCount - 1; j >= 0; j--) {\\n            result[j][i] = this[curr]\\n            curr++\\n            isOdd = true\\n        }\\n        }\\n    }\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424040,
                "title": "gross-typescript-one-liner",
                "content": "\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    return rowsCount * colsCount !== this.length ? [] : this.reduce((acc, num, i) =>\\n         (acc[Math.floor(i / rowsCount) % 2 ? \\n            rowsCount - i % rowsCount - 1 : \\n            i % rowsCount][Math.floor(i / rowsCount)] = num) \\n        && acc\\n    , new Array(rowsCount).fill(0).map(a=> []))\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    return rowsCount * colsCount !== this.length ? [] : this.reduce((acc, num, i) =>\\n         (acc[Math.floor(i / rowsCount) % 2 ? \\n            rowsCount - i % rowsCount - 1 : \\n            i % rowsCount][Math.floor(i / rowsCount)] = num) \\n        && acc\\n    , new Array(rowsCount).fill(0).map(a=> []))\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607356,
                "title": "concise-using-a-double-for-loop",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a 2D for loop to build the 2D array and calculate the 1D source index from the (x, y) position.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if (this.length != rowsCount * colsCount){\\n        return [];\\n    }\\n    let result: any[][] = [];\\n    for (let r = 0; r < rowsCount; r ++){\\n        result.push([]);\\n        for (let c = 0; c < colsCount; c ++){\\n            let source = c * rowsCount + (c % 2 === 0 ? r : rowsCount - r - 1);\\n            result[r].push(this[source]);\\n        }\\n    }\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if (this.length != rowsCount * colsCount){\\n        return [];\\n    }\\n    let result: any[][] = [];\\n    for (let r = 0; r < rowsCount; r ++){\\n        result.push([]);\\n        for (let c = 0; c < colsCount; c ++){\\n            let source = c * rowsCount + (c % 2 === 0 ? r : rowsCount - r - 1);\\n            result[r].push(this[source]);\\n        }\\n    }\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557644,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount*colsCount !==this.length) return []\\n    return this.reduce((ans,item,index)=>{\\n        let col=index%rowsCount;\\n        let row=Math.floor(index/rowsCount);\\n\\n        if (row%2!==0){col=rowsCount-col-1 }\\n        ans[col]=[...(ans[col] || []),item]\\n        return ans\\n    },[])\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount*colsCount !==this.length) return []\\n    return this.reduce((ans,item,index)=>{\\n        let col=index%rowsCount;\\n        let row=Math.floor(index/rowsCount);\\n\\n        if (row%2!==0){col=rowsCount-col-1 }\\n        ans[col]=[...(ans[col] || []),item]\\n        return ans\\n    },[])\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407178,
                "title": "js",
                "content": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    var arr = [];\\n    var n = rowsCount*colsCount;\\n    if(n != this.length) return arr;\\n    for(var i = 0;i< rowsCount;i++) arr[i] = [];\\n    \\n    for(var k=0, i = 0, j = 0, d=1; k<n; i+=d){\\n        if(i<0 || i== rowsCount){\\n            d = -1*d;\\n            j++;\\n            continue;\\n        }\\n        arr[i][j] = this[k++];\\n    }\\n    return arr;\\n}",
                "solutionTags": [],
                "code": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    var arr = [];\\n    var n = rowsCount*colsCount;\\n    if(n != this.length) return arr;\\n    for(var i = 0;i< rowsCount;i++) arr[i] = [];\\n    \\n    for(var k=0, i = 0, j = 0, d=1; k<n; i+=d){\\n        if(i<0 || i== rowsCount){\\n            d = -1*d;\\n            j++;\\n            continue;\\n        }\\n        arr[i][j] = this[k++];\\n    }\\n    return arr;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4091578,
                "title": "javascript-snail-array-transformation",
                "content": "# Intuition\\nThe problem involves transforming a 1D array into a 2D array in snail traversal order. To solve this, I need to iterate through the input array and populate the 2D array based on the specified rules of snail traversal. The main challenge is to keep track of the current position and direction while filling the 2D array.\\n\\n# Approach\\n1. First, I check if the input is valid by verifying that rowsCount * colsCount is equal to the length of the input array. If not, I return an empty array since an invalid input cannot be transformed into a 2D snail array.\\n2. I initialize an empty 2D array called result with the dimensions rowsCount x colsCount. This will be the output array.\\n3. I initialize row and col variables to keep track of the current position in the result array, and dir to keep track of the traversal direction (1 for down, -1 for up).\\n4. I iterate through the input array, and for each element, I add it to the current row of the result array.\\n5. I update the row and col based on the current direction (dir). If I are moving down, I increment the row if it\\'s within bounds; otherwise, I increment the col and change the direction to up. If I are moving up, I decrement the row if it\\'s within bounds; otherwise, I increment the col and change the direction to down.\\n6. Finally, I return the result array, which now contains the input array transformed into snail traversal order.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(rowsCount * colsCount)$$\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n    const nums = this;\\n\\n    if (rowsCount * colsCount !== nums.length) {\\n        return [];\\n    }\\n\\n    const result = Array.from({ length: rowsCount }, () => []);\\n    let row = 0;\\n    let col = 0;\\n    let dir = 1;\\n\\n    for (const num of nums) {\\n        result[row].push(num);\\n\\n        if (dir === 1) {\\n            if (row < rowsCount - 1) {\\n                row++;\\n            } else {\\n                col++;\\n                dir = -1;\\n            }\\n        } else {\\n            if (row > 0) {\\n                row--;\\n            } else {\\n                col++;\\n                dir = 1;\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n\\nconst arr = [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15];\\nconst snailResult = arr.snail(5, 4);\\nconsole.log(snailResult);\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n    const nums = this;\\n\\n    if (rowsCount * colsCount !== nums.length) {\\n        return [];\\n    }\\n\\n    const result = Array.from({ length: rowsCount }, () => []);\\n    let row = 0;\\n    let col = 0;\\n    let dir = 1;\\n\\n    for (const num of nums) {\\n        result[row].push(num);\\n\\n        if (dir === 1) {\\n            if (row < rowsCount - 1) {\\n                row++;\\n            } else {\\n                col++;\\n                dir = -1;\\n            }\\n        } else {\\n            if (row > 0) {\\n                row--;\\n            } else {\\n                col++;\\n                dir = 1;\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n\\nconst arr = [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15];\\nconst snailResult = arr.snail(5, 4);\\nconsole.log(snailResult);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085491,
                "title": "working-with-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount * colsCount !== this.length){\\n        return []\\n}else{\\n    let result = Array.from({ length: rowsCount }, () => Array(colsCount).fill(undefined));\\n     const chunkSize = Math.ceil(this.length / colsCount);\\n    let splittedArray = Array.from({ length: colsCount }, (_, index) =>\\n    this.slice(index * chunkSize, (index + 1) * chunkSize));\\n    splittedArray.map((columnArray, columnArrayIndex) => {\\n        const column = columnArrayIndex % 2 === 1 ? columnArray.reverse() : columnArray;\\n        column.map((item, itemIndex) => {result[itemIndex][columnArrayIndex] = item})\\n });\\n        return result;\\n}\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount * colsCount !== this.length){\\n        return []\\n}else{\\n    let result = Array.from({ length: rowsCount }, () => Array(colsCount).fill(undefined));\\n     const chunkSize = Math.ceil(this.length / colsCount);\\n    let splittedArray = Array.from({ length: colsCount }, (_, index) =>\\n    this.slice(index * chunkSize, (index + 1) * chunkSize));\\n    splittedArray.map((columnArray, columnArrayIndex) => {\\n        const column = columnArrayIndex % 2 === 1 ? columnArray.reverse() : columnArray;\\n        column.map((item, itemIndex) => {result[itemIndex][columnArrayIndex] = item})\\n });\\n        return result;\\n}\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081242,
                "title": "javascript-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount*colsCount  != this.length) return []\\n    \\n    let idx = 0;\\n    let matrix = Array(rowsCount).fill().map(() => []);\\n    for(let i=0; i<colsCount; i++) {\\n        for(let j=0; j<rowsCount; j++){\\n            let pos = i%2==0 ? j : rowsCount-j-1; \\n            matrix[pos][i] = this[idx++]\\n        }\\n    }\\n\\n    return matrix;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount*colsCount  != this.length) return []\\n    \\n    let idx = 0;\\n    let matrix = Array(rowsCount).fill().map(() => []);\\n    for(let i=0; i<colsCount; i++) {\\n        for(let j=0; j<rowsCount; j++){\\n            let pos = i%2==0 ? j : rowsCount-j-1; \\n            matrix[pos][i] = this[idx++]\\n        }\\n    }\\n\\n    return matrix;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068940,
                "title": "easy-javascript-solution-beats-99-in-memory",
                "content": "# Intuition\\nThinking through it step by step:\\n- the program needs to create nested arrays for each row\\n- it needs to iteratively push values from the original array to the proper row\\n- it has to have a sense of direction\\n- it must understand when to move to the next column\\n\\n# Approach\\n- start by adding the rows/ arrays to an all encompassing array\\n- ensure invalid values are not accepted with a conditional\\n- instantiate three variables: currentRow, currentCol, and the direction\\n- add a loop to grab each value from the input array (for of, for, while)\\n- using the currentRow, push the input array value to your newSelf array\\n- Conditional to handle edge cases for the end and start of columns. If we\\'re at neither currently, add or subtract direction\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const newSelf = Array.from({ length: rowsCount }, () => []);\\n\\n    if (rowsCount * colsCount !== this.length) return [];\\n\\n    let currentRow = 0;\\n    let currentCol = 0;\\n    let direction = 1; // 1 for moving down, -1 for moving up\\n\\n    for (let val of this) {\\n        newSelf[currentRow].push(val);\\n\\n        // Determine next cell\\n        if (direction === 1 && currentRow === rowsCount - 1) {\\n            currentCol++;\\n            direction = -1;\\n        } else if (direction === -1 && currentRow === 0) {\\n            currentCol++;\\n            direction = 1;\\n        } else {\\n            currentRow += direction;\\n        }\\n    }\\n    return newSelf;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const newSelf = Array.from({ length: rowsCount }, () => []);\\n\\n    if (rowsCount * colsCount !== this.length) return [];\\n\\n    let currentRow = 0;\\n    let currentCol = 0;\\n    let direction = 1; // 1 for moving down, -1 for moving up\\n\\n    for (let val of this) {\\n        newSelf[currentRow].push(val);\\n\\n        // Determine next cell\\n        if (direction === 1 && currentRow === rowsCount - 1) {\\n            currentCol++;\\n            direction = -1;\\n        } else if (direction === -1 && currentRow === 0) {\\n            currentCol++;\\n            direction = 1;\\n        } else {\\n            currentRow += direction;\\n        }\\n    }\\n    return newSelf;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4063509,
                "title": "js-solve-with-steps",
                "content": "# How it works?\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We have a number of items, we loop for each one:\\n```    \\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    this.forEach((item)=>{\\n        // code will be right here\\n    })\\n}\\n```\\n- We want to save the result in a variable which has empty array for each row to return it:\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = Array.from({length: rowsCount}, ()=>[])\\n    this.forEach((item)=>{\\n        // code will be right here\\n    })\\n    return result\\n}\\n```\\n- Let\\'s create the function:\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    this.forEach((item)=>{\\n        result[currRow - 1].push(item)\\n    })\\n}\\n```\\n# Challenges\\n<!-- Describe your approach to solving the problem. -->\\n- We should change the direction in the start of each col:\\n    1- Make a direction variable.\\n    2- Check if we go down and the item is in the last row and change the direction to up.\\n    3-Check if we go up and the item is in the first row and change the direction to down\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = Array.from({length: rowsCount}, ()=>[])\\n    let dir = \"down\" // Make a direction variable\\n    let currRow = 1\\n    this.forEach((item)=>{\\n        result[currRow - 1].push(item)\\n        if(dir === \"down\"){ // Check if we go down and the item is in the last row and change the direction to up\\n            if(currRow === rowsCount){\\n                dir = \"up\"\\n            }\\n        }else if(dir === \"up\"){ // Check if we go up and the item is in the first row and change the direction to down\\n            if(currRow === 1){\\n                dir = \"down\"\\n            }\\n        }\\n    })\\n    return result\\n}\\n```\\n- currRow +1 if we go down, and currRow -1 if we go up.\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = Array.from({length: rowsCount}, ()=>[])\\n    let dir = \"down\" // Make a direction variable\\n    let currRow = 1\\n    this.forEach((item)=>{\\n        result[currRow - 1].push(item)\\n        if(dir === \"down\"){\\n            if(currRow === rowsCount){\\n                dir = \"up\"\\n            }\\n            ++currRow // +1 because we go down\\n        }else if(dir === \"up\"){\\n            if(currRow === 1){\\n                dir = \"down\"\\n            }\\n            --currRow // -1 because we go up\\n        }\\n    })\\n    return result\\n}\\n```\\n\\n# Problems\\n- The code will run but you can find a bug, for example if we have 5 rows the code make them 6.\\n\\n    Reason: when we change the direction we should be in the same current row, but the code +1 the current row or -1 it ( based on direction ).\\n    Solve: when we change the direction we should return to don\\'t run the +1 or -1 for current row.\\n\\n# The Final Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = Array.from({length: rowsCount}, ()=>[])\\n    let dir = \"down\"\\n    let currRow = 1\\n    if(rowsCount * colsCount !== this.length){\\n        return []\\n    }\\n    this.forEach((item)=>{\\n        result[currRow - 1].push(item)\\n        if(dir === \"down\"){\\n            if(currRow === rowsCount){\\n                dir = \"up\"\\n                return\\n            }\\n            ++currRow \\n        }else if(dir === \"up\"){\\n            if(currRow === 1){\\n                dir = \"down\"\\n                return\\n            }\\n            --currRow\\n        }\\n    })\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```\\n# PLEASE VOTE UP!\\n![Vote up.jpg](https://assets.leetcode.com/users/images/0267f170-207e-40c7-bab5-b1b38f7acd70_1695112525.9492989.jpeg)\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```    \\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    this.forEach((item)=>{\\n        // code will be right here\\n    })\\n}\\n```\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = Array.from({length: rowsCount}, ()=>[])\\n    this.forEach((item)=>{\\n        // code will be right here\\n    })\\n    return result\\n}\\n```\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    this.forEach((item)=>{\\n        result[currRow - 1].push(item)\\n    })\\n}\\n```\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = Array.from({length: rowsCount}, ()=>[])\\n    let dir = \"down\" // Make a direction variable\\n    let currRow = 1\\n    this.forEach((item)=>{\\n        result[currRow - 1].push(item)\\n        if(dir === \"down\"){ // Check if we go down and the item is in the last row and change the direction to up\\n            if(currRow === rowsCount){\\n                dir = \"up\"\\n            }\\n        }else if(dir === \"up\"){ // Check if we go up and the item is in the first row and change the direction to down\\n            if(currRow === 1){\\n                dir = \"down\"\\n            }\\n        }\\n    })\\n    return result\\n}\\n```\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = Array.from({length: rowsCount}, ()=>[])\\n    let dir = \"down\" // Make a direction variable\\n    let currRow = 1\\n    this.forEach((item)=>{\\n        result[currRow - 1].push(item)\\n        if(dir === \"down\"){\\n            if(currRow === rowsCount){\\n                dir = \"up\"\\n            }\\n            ++currRow // +1 because we go down\\n        }else if(dir === \"up\"){\\n            if(currRow === 1){\\n                dir = \"down\"\\n            }\\n            --currRow // -1 because we go up\\n        }\\n    })\\n    return result\\n}\\n```\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = Array.from({length: rowsCount}, ()=>[])\\n    let dir = \"down\"\\n    let currRow = 1\\n    if(rowsCount * colsCount !== this.length){\\n        return []\\n    }\\n    this.forEach((item)=>{\\n        result[currRow - 1].push(item)\\n        if(dir === \"down\"){\\n            if(currRow === rowsCount){\\n                dir = \"up\"\\n                return\\n            }\\n            ++currRow \\n        }else if(dir === \"up\"){\\n            if(currRow === 1){\\n                dir = \"down\"\\n                return\\n            }\\n            --currRow\\n        }\\n    })\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056874,
                "title": "one-loop",
                "content": "# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n    if (this.length !== rowsCount * colsCount) return [];\\n\\n    const result = Array.from({ length: rowsCount }, () => []);\\n    let row = 0;\\n    let column = 0;\\n    let down = true;\\n\\n    for (let i = 0; i < this.length; i++) {\\n        result[row][column] = this[i];\\n\\n        if ((i + 1) % rowsCount === 0) {\\n            down = !down;\\n\\n            column += 1;\\n            row = down ? 0 : rowsCount - 1;\\n        } else {\\n            down ? row++ : row--;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n    if (this.length !== rowsCount * colsCount) return [];\\n\\n    const result = Array.from({ length: rowsCount }, () => []);\\n    let row = 0;\\n    let column = 0;\\n    let down = true;\\n\\n    for (let i = 0; i < this.length; i++) {\\n        result[row][column] = this[i];\\n\\n        if ((i + 1) % rowsCount === 0) {\\n            down = !down;\\n\\n            column += 1;\\n            row = down ? 0 : rowsCount - 1;\\n        } else {\\n            down ? row++ : row--;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051779,
                "title": "simple-ts-solution-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if (rowsCount * colsCount !== this.length) return [];\\n    const result = [];\\n    const cols = [];\\n    for (let i = 0; i <Math.ceil(this.length/rowsCount); i++){\\n        if (i % 2 !== 0) {\\n            cols[i] = this.slice((i*rowsCount), (i*rowsCount) + rowsCount).reverse();\\n        } else {\\n            cols[i] = this.slice((i*rowsCount), (i*rowsCount) + rowsCount);\\n        }\\n    }\\n    for (let col = 0; col < cols.length; col++) {\\n        for (let subCol = 0; subCol < cols[col].length; subCol++) {\\n            result[subCol] ? result[subCol].push(cols[col][subCol]) : result[subCol] = [cols[col][subCol]];\\n        }\\n    }\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if (rowsCount * colsCount !== this.length) return [];\\n    const result = [];\\n    const cols = [];\\n    for (let i = 0; i <Math.ceil(this.length/rowsCount); i++){\\n        if (i % 2 !== 0) {\\n            cols[i] = this.slice((i*rowsCount), (i*rowsCount) + rowsCount).reverse();\\n        } else {\\n            cols[i] = this.slice((i*rowsCount), (i*rowsCount) + rowsCount);\\n        }\\n    }\\n    for (let col = 0; col < cols.length; col++) {\\n        for (let subCol = 0; subCol < cols[col].length; subCol++) {\\n            result[subCol] ? result[subCol].push(cols[col][subCol]) : result[subCol] = [cols[col][subCol]];\\n        }\\n    }\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039315,
                "title": "javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\nlet result=[]\\nif(rowsCount * colsCount !== this.length) return result\\nfor(let i=0;i<rowsCount;i++){\\n    result.push([])\\n}\\nthis.forEach((el,i)=>{\\n    if(parseInt(i/rowsCount)%2===0){\\n        let index=i%rowsCount\\n        result[index].push(el)\\n    }\\n    else{\\n        let index=rowsCount-1 - i%rowsCount\\n        result[index].push(el)\\n    }\\n})\\nreturn(result)\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\nlet result=[]\\nif(rowsCount * colsCount !== this.length) return result\\nfor(let i=0;i<rowsCount;i++){\\n    result.push([])\\n}\\nthis.forEach((el,i)=>{\\n    if(parseInt(i/rowsCount)%2===0){\\n        let index=i%rowsCount\\n        result[index].push(el)\\n    }\\n    else{\\n        let index=rowsCount-1 - i%rowsCount\\n        result[index].push(el)\\n    }\\n})\\nreturn(result)\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969373,
                "title": "simple-double-for-loop",
                "content": "\\n# Code\\n```\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n  if (this.length !== rowsCount * colsCount) return []\\n  const m = [];\\n  for (let row = 0; row < rowsCount; row++) {\\n    m.push([])\\n    for (let column = 0; column < colsCount; column++) {\\n      const n = row + rowsCount * column\\n      if (column % 2 == 0) {\\n        m[row].push(this[n])\\n      } else {\\n        m[row].push(this[n + rowsCount - 1 - 2 * row])\\n      }\\n    }\\n  }\\n  return m;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n  if (this.length !== rowsCount * colsCount) return []\\n  const m = [];\\n  for (let row = 0; row < rowsCount; row++) {\\n    m.push([])\\n    for (let column = 0; column < colsCount; column++) {\\n      const n = row + rowsCount * column\\n      if (column % 2 == 0) {\\n        m[row].push(this[n])\\n      } else {\\n        m[row].push(this[n + rowsCount - 1 - 2 * row])\\n      }\\n    }\\n  }\\n  return m;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3960280,
                "title": "cool-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const arr = [];\\n\\n    if (rowsCount * colsCount !== this.length) {\\n        return []\\n    }\\n \\n    for (let i = 0; i < colsCount; i++) {\\n        for (let j = 0; j < rowsCount; j++) {\\n            if (i > 0) {\\n                if (i%2 === 0) {\\n                    arr[j].push(this[rowsCount*i + j])\\n                } else {\\n                    arr[j].push(this[rowsCount*i + (rowsCount-j-1)])  \\n                }\\n            } else {\\n                arr.push([this[j]])\\n            }\\n        }\\n    }\\n    return arr\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const arr = [];\\n\\n    if (rowsCount * colsCount !== this.length) {\\n        return []\\n    }\\n \\n    for (let i = 0; i < colsCount; i++) {\\n        for (let j = 0; j < rowsCount; j++) {\\n            if (i > 0) {\\n                if (i%2 === 0) {\\n                    arr[j].push(this[rowsCount*i + j])\\n                } else {\\n                    arr[j].push(this[rowsCount*i + (rowsCount-j-1)])  \\n                }\\n            } else {\\n                arr.push([this[j]])\\n            }\\n        }\\n    }\\n    return arr\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952164,
                "title": "typescript-best-solution",
                "content": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function (rowsCount: number, colsCount: number): number[][] {\\n  if (rowsCount * colsCount !== this.length) {\\n    return [];\\n  }\\n  \\n  return new Array(rowsCount).fill(0).map((_, row) => \\n    new Array(colsCount).fill(0).map((_, col) => \\n      this[rowsCount * (col + col % 2) + row * (col % 2 ? -1 : 1) + (col % 2) * -1]\\n    )\\n  );\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function (rowsCount: number, colsCount: number): number[][] {\\n  if (rowsCount * colsCount !== this.length) {\\n    return [];\\n  }\\n  \\n  return new Array(rowsCount).fill(0).map((_, row) => \\n    new Array(colsCount).fill(0).map((_, col) => \\n      this[rowsCount * (col + col % 2) + row * (col % 2 ? -1 : 1) + (col % 2) * -1]\\n    )\\n  );\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946663,
                "title": "solution-with-pattern-in-indices",
                "content": "# Intuition\\nTo find the pattern in which the 2D arrays are being created we need to check the indices of the numbers in the resultant array.\\n\\n# Approach\\nThere are 2 patterns, one for even and another for odd.\\nFor Even: index = (rowsCount * currentCol) + currentRow;\\nFor Odd: index = (rowsCount * (currentCol + 1)) - 1 - currentRow; \\n\\n# Complexity\\n- Time complexity: m * n\\n\\n- Space complexity: m * n\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n  if (rowsCount * colsCount !== this.length) {\\n    return [];\\n  }\\n\\n  let res = [];\\n  for (let i = 0; i < rowsCount; i++) {\\n    res[i] = [];\\n    for (let j = 0; j < colsCount; j++) {\\n      let index = (rowsCount * j) + i;\\n      if (j % 2 !== 0) {\\n        index = (rowsCount * (j + 1)) - 1 - i;\\n      }\\n      res[i].push(this[index]);\\n    }\\n  }\\n\\n  return res;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n  if (rowsCount * colsCount !== this.length) {\\n    return [];\\n  }\\n\\n  let res = [];\\n  for (let i = 0; i < rowsCount; i++) {\\n    res[i] = [];\\n    for (let j = 0; j < colsCount; j++) {\\n      let index = (rowsCount * j) + i;\\n      if (j % 2 !== 0) {\\n        index = (rowsCount * (j + 1)) - 1 - i;\\n      }\\n      res[i].push(this[index]);\\n    }\\n  }\\n\\n  return res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946299,
                "title": "literal-application-of-the-visual-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI just took the visual example and applied it to code. This could probably be made much more efficient, but this seemed to be a very straightforward way to do it for me.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create an empty 2d array of the correct dimensions\\n2. iterate down the first column, adding the elements\\n3. once reached bottom, shift to the next column and iterate up the column, adding the elements\\n4. steps 2 and 3 repeated till the 2d array is filled \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    // fail if dimensions are incorrect\\n    if(rowsCount*colsCount!==this.length) return [];\\n\\n    //the row and column pointers that will be used to write to the snail2d array\\n    let offsetRow = 0;\\n    let offsetCol = 0;\\n\\n    //create the array and fill it with 1s\\n    let snail2d = Array.from({length: rowsCount}, _ => new Array(colsCount).fill(1));\\n\\n    //row stepper is the number the row will be incremented by,\\n    // can be set to 1 or -1 to traverse in reverse\\n    let rowStepper = 1;\\n\\n    // indicates a row move has just happened last iter\\n    let rowMove = false;\\n    for(let item of this) {\\n        //if row was moved last iter, move column once and\\n        //reset the row to the max it could be, so that the\\n        //adjacent column could be written to\\n        if(rowMove) {\\n            offsetRow = rowsCount -1\\n            offsetCol += 1\\n            rowMove = false\\n        } else if(offsetRow === rowsCount-1) {\\n            rowStepper = -1;\\n            rowMove = true;\\n        };\\n        // if reached the top, turn around and iterate backwards\\n        // along the next column\\n        if(offsetRow === -1) {\\n            rowStepper = 1;\\n            offsetCol += 1\\n            offsetRow = 0;\\n        }\\n        // set the item in its position in the 2d array\\n        snail2d[offsetRow][offsetCol] = item\\n        // if adding the stepper to the row will cause it to\\n        // go out of bounds, increment column instead, otherwise\\n        // increment the row\\n        if(offsetRow+rowStepper!== rowsCount) offsetRow+=rowStepper;\\n        else offsetCol+=1;\\n    }\\n    //return the 2d array\\n    return snail2d;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    // fail if dimensions are incorrect\\n    if(rowsCount*colsCount!==this.length) return [];\\n\\n    //the row and column pointers that will be used to write to the snail2d array\\n    let offsetRow = 0;\\n    let offsetCol = 0;\\n\\n    //create the array and fill it with 1s\\n    let snail2d = Array.from({length: rowsCount}, _ => new Array(colsCount).fill(1));\\n\\n    //row stepper is the number the row will be incremented by,\\n    // can be set to 1 or -1 to traverse in reverse\\n    let rowStepper = 1;\\n\\n    // indicates a row move has just happened last iter\\n    let rowMove = false;\\n    for(let item of this) {\\n        //if row was moved last iter, move column once and\\n        //reset the row to the max it could be, so that the\\n        //adjacent column could be written to\\n        if(rowMove) {\\n            offsetRow = rowsCount -1\\n            offsetCol += 1\\n            rowMove = false\\n        } else if(offsetRow === rowsCount-1) {\\n            rowStepper = -1;\\n            rowMove = true;\\n        };\\n        // if reached the top, turn around and iterate backwards\\n        // along the next column\\n        if(offsetRow === -1) {\\n            rowStepper = 1;\\n            offsetCol += 1\\n            offsetRow = 0;\\n        }\\n        // set the item in its position in the 2d array\\n        snail2d[offsetRow][offsetCol] = item\\n        // if adding the stepper to the row will cause it to\\n        // go out of bounds, increment column instead, otherwise\\n        // increment the row\\n        if(offsetRow+rowStepper!== rowsCount) offsetRow+=rowStepper;\\n        else offsetCol+=1;\\n    }\\n    //return the 2d array\\n    return snail2d;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938435,
                "title": "javascript-solution-easy-approach-using-math",
                "content": "```javascript\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n    const arr = this;\\n\\n    if (rowsCount * colsCount !== arr.length) return [];\\n\\n    const snail = Array(rowsCount).fill().map(() =>\\n        Array(colsCount).fill(0));\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const columnIndex = Math.floor(i / rowsCount);\\n        const isEvenColumn = columnIndex % 2 == 0;\\n        const rowIndex = isEvenColumn ? i % rowsCount : rowsCount - (i % rowsCount) - 1;\\n        snail[rowIndex][columnIndex] = arr[i];\\n    }\\n\\n    return snail;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```javascript\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n    const arr = this;\\n\\n    if (rowsCount * colsCount !== arr.length) return [];\\n\\n    const snail = Array(rowsCount).fill().map(() =>\\n        Array(colsCount).fill(0));\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const columnIndex = Math.floor(i / rowsCount);\\n        const isEvenColumn = columnIndex % 2 == 0;\\n        const rowIndex = isEvenColumn ? i % rowsCount : rowsCount - (i % rowsCount) - 1;\\n        snail[rowIndex][columnIndex] = arr[i];\\n    }\\n\\n    return snail;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923448,
                "title": "beats-99-of-users-with-typescript",
                "content": "![image.png](https://assets.leetcode.com/users/images/b9894228-09c9-43d0-84bb-419132406255_1692291163.2704694.png)\\n\\n\\n# Code\\n```\\n// link: https://leetcode.com/problems/snail-traversal\\n\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function (rowsCount: number, colsCount: number): number[][] {\\n  if (rowsCount * colsCount !== this.length) return [];\\n\\n  const snailArray = [];\\n\\n  for (let currentRow = 0; currentRow < rowsCount; currentRow++) snailArray.push([]);\\n\\n  for (let currentCol = 1; currentCol <= colsCount; currentCol++) {\\n    const indexOfEndValue = currentCol * rowsCount;\\n    const indexOfStartValue = indexOfEndValue - rowsCount;\\n    const isPairCol = currentCol % 2 === 0;\\n    let targetRow = isPairCol ? rowsCount - 1 : 0;\\n\\n    for (let indexOfCurrentValue = indexOfStartValue; indexOfCurrentValue < indexOfEndValue; indexOfCurrentValue++) {\\n      snailArray[targetRow].push(this[indexOfCurrentValue]);\\n      if (isPairCol) targetRow--;\\n      else targetRow++;\\n    }\\n  }\\n\\n  return snailArray;\\n};\\n\\nexport {};\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// link: https://leetcode.com/problems/snail-traversal\\n\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function (rowsCount: number, colsCount: number): number[][] {\\n  if (rowsCount * colsCount !== this.length) return [];\\n\\n  const snailArray = [];\\n\\n  for (let currentRow = 0; currentRow < rowsCount; currentRow++) snailArray.push([]);\\n\\n  for (let currentCol = 1; currentCol <= colsCount; currentCol++) {\\n    const indexOfEndValue = currentCol * rowsCount;\\n    const indexOfStartValue = indexOfEndValue - rowsCount;\\n    const isPairCol = currentCol % 2 === 0;\\n    let targetRow = isPairCol ? rowsCount - 1 : 0;\\n\\n    for (let indexOfCurrentValue = indexOfStartValue; indexOfCurrentValue < indexOfEndValue; indexOfCurrentValue++) {\\n      snailArray[targetRow].push(this[indexOfCurrentValue]);\\n      if (isPairCol) targetRow--;\\n      else targetRow++;\\n    }\\n  }\\n\\n  return snailArray;\\n};\\n\\nexport {};\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919728,
                "title": "typescript-simple-straightforward-solution-o-n-o-n",
                "content": "# Complexity\\n- Time complexity: $\\\\mathcal{O}(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $\\\\mathcal{O}(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if ( this.length !== rowsCount * colsCount ) return [];\\n    const result = Array.from( { length: rowsCount }, () => Array( colsCount ) );\\n    let row = 0, col = 0, dir = 1;\\n    for ( let i = 0; i < this.length; i++ ) {\\n        result[ row ][ col ] = this[ i ];\\n        row += dir;\\n        if ( row < 0 || row === rowsCount ) dir = -dir, row += dir, col++;\\n    }\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if ( this.length !== rowsCount * colsCount ) return [];\\n    const result = Array.from( { length: rowsCount }, () => Array( colsCount ) );\\n    let row = 0, col = 0, dir = 1;\\n    for ( let i = 0; i < this.length; i++ ) {\\n        result[ row ][ col ] = this[ i ];\\n        row += dir;\\n        if ( row < 0 || row === rowsCount ) dir = -dir, row += dir, col++;\\n    }\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3873559,
                "title": "simple-linear-time-solution-beats-92-82",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$(rowcCount * colsCount) = O(n)$$ \\n\\n# Code\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount != this.length) return [];\\n    let snail = [];\\n\\n    for (let i = 0; i < this.length; i++) {\\n        let isEvenCol = Math.floor(i / rowsCount) % 2 == 0; \\n        let index = isEvenCol ? i % rowsCount : rowsCount - (i % rowsCount) - 1 ; \\n        if (snail[index] === undefined) {\\n            snail[index] = [this[i]];\\n        } else {\\n            snail[index].push(this[i]);\\n        }\\n    }\\n    return snail;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount != this.length) return [];\\n    let snail = [];\\n\\n    for (let i = 0; i < this.length; i++) {\\n        let isEvenCol = Math.floor(i / rowsCount) % 2 == 0; \\n        let index = isEvenCol ? i % rowsCount : rowsCount - (i % rowsCount) - 1 ; \\n        if (snail[index] === undefined) {\\n            snail[index] = [this[i]];\\n        } else {\\n            snail[index].push(this[i]);\\n        }\\n    }\\n    return snail;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3870997,
                "title": "javascript-solution",
                "content": "```javascript\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return []\\n    }\\n    const result = Array.from({ length: rowsCount }, () => Array(colsCount).fill(0))\\n\\n    for (let i = 0; i < colsCount; i++) {\\n        for (let j = 0; j < rowsCount; j++) {\\n            (i % 2 == 0 ? result[j] : result.at(~j))[i] = this[i * rowsCount + j]\\n        }\\n    }\\n\\n    return result\\n}   \\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return []\\n    }\\n    const result = Array.from({ length: rowsCount }, () => Array(colsCount).fill(0))\\n\\n    for (let i = 0; i < colsCount; i++) {\\n        for (let j = 0; j < rowsCount; j++) {\\n            (i % 2 == 0 ? result[j] : result.at(~j))[i] = this[i * rowsCount + j]\\n        }\\n    }\\n\\n    return result\\n}   \\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857982,
                "title": "js-solution-with-linear-complexity",
                "content": "# Code\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const snailOrderArray = [];\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n    let j = 0;\\n    let switchFlag = false;\\n    for (let i = 0; i < this.length; i++) {\\n        if (!snailOrderArray[j]) {\\n            snailOrderArray[j] = [];\\n        }\\n        snailOrderArray[j].push(this[i]);\\n        if (switchFlag) {\\n            j--;\\n            if (j < 0) {\\n                switchFlag = false;\\n                j = 0;\\n            }\\n        } else {\\n            j++;\\n            if (j > rowsCount - 1) {\\n                switchFlag = true;\\n                j = rowsCount - 1;\\n            }\\n        }\\n    }\\n    return snailOrderArray;\\n}\\n\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const snailOrderArray = [];\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n    let j = 0;\\n    let switchFlag = false;\\n    for (let i = 0; i < this.length; i++) {\\n        if (!snailOrderArray[j]) {\\n            snailOrderArray[j] = [];\\n        }\\n        snailOrderArray[j].push(this[i]);\\n        if (switchFlag) {\\n            j--;\\n            if (j < 0) {\\n                switchFlag = false;\\n                j = 0;\\n            }\\n        } else {\\n            j++;\\n            if (j > rowsCount - 1) {\\n                switchFlag = true;\\n                j = rowsCount - 1;\\n            }\\n        }\\n    }\\n    return snailOrderArray;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840411,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount*colsCount !== this.length){\\n        return [];\\n    };\\n\\n    const arr = new Array(rowsCount);\\n    for (let i=0; i<rowsCount; i++){\\n        arr[i] = new Array(colsCount);\\n    };\\n    for (let i=0; i<colsCount; i++){\\n        for (let j=0; j<rowsCount; j++){\\n            let a;\\n            if (i%2 === 1){\\n                a = (rowsCount*i) + (rowsCount-1-j);\\n            } else {\\n                a = i*rowsCount + j;\\n            }\\n            arr[j][i] = this.slice(a, a+1)[0];\\n        }\\n    }\\n    return arr;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount*colsCount !== this.length){\\n        return [];\\n    };\\n\\n    const arr = new Array(rowsCount);\\n    for (let i=0; i<rowsCount; i++){\\n        arr[i] = new Array(colsCount);\\n    };\\n    for (let i=0; i<colsCount; i++){\\n        for (let j=0; j<rowsCount; j++){\\n            let a;\\n            if (i%2 === 1){\\n                a = (rowsCount*i) + (rowsCount-1-j);\\n            } else {\\n                a = i*rowsCount + j;\\n            }\\n            arr[j][i] = this.slice(a, a+1)[0];\\n        }\\n    }\\n    return arr;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3820212,
                "title": "solutions-with-a-mathematical-algorithm-of-actions-runtime-163-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n    if (rowsCount * colsCount === this.length) {\\n        let upgradeMassive = []\\n        for (let j = rowsCount; j > 0; --j) {\\n            let first = rowsCount - j\\n            let boost = 1\\n            let massive = []\\n            for (b = 1; b <= colsCount; ++b) {\\n                if (b % 2 === 1) {\\n                    massive.push(this[first])\\n                    continue\\n                }\\n                if (b % 2 === 0) {\\n                    first += 1\\n                    let inter = first + (j - 1) * (b / boost)\\n                    massive.push(this[inter])\\n                    first = inter + 1 + 2 * (rowsCount - j)\\n                    boost += 1\\n                }\\n            }\\n            upgradeMassive.push(massive)\\n        }\\n        return upgradeMassive\\n    }\\n    return []\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n    if (rowsCount * colsCount === this.length) {\\n        let upgradeMassive = []\\n        for (let j = rowsCount; j > 0; --j) {\\n            let first = rowsCount - j\\n            let boost = 1\\n            let massive = []\\n            for (b = 1; b <= colsCount; ++b) {\\n                if (b % 2 === 1) {\\n                    massive.push(this[first])\\n                    continue\\n                }\\n                if (b % 2 === 0) {\\n                    first += 1\\n                    let inter = first + (j - 1) * (b / boost)\\n                    massive.push(this[inter])\\n                    first = inter + 1 + 2 * (rowsCount - j)\\n                    boost += 1\\n                }\\n            }\\n            upgradeMassive.push(massive)\\n        }\\n        return upgradeMassive\\n    }\\n    return []\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811665,
                "title": "create-a-matrix-iterate-over-col-times-then-iterate-over-row-times-to-push",
                "content": "# Intuition\\nCreate a matix of r x c\\nThen we just iterate over column times and then we iterate over row times and then push numbers into each row.\\nKeep a index running pointer which will increment each row iteration.\\nTo turn the direction we keep start,end and inceremnt pointer.\\nWe change them at the end of each column iteration.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n\\n    if ((rowsCount * colsCount) !== this.length){\\n        return []\\n    }\\n\\n    const matrix = []\\n    for (let i = 0; i < rowsCount; i++){\\n        matrix.push([])\\n    }\\n\\n    let index = 0;\\n\\n\\n    let start = 0;\\n    let end = rowsCount;\\n    let increment =  1\\n\\n    for (let i =0 ; i < colsCount;i += 1){\\n        for(let j =start; start < end? j < end : j > end; j += increment ){\\n            matrix[j].push(this[index])\\n            index ++\\n        }\\n        if (start == 0){\\n            start = rowsCount -1\\n            end = -1;\\n            increment = -1;\\n        } else{\\n            start = 0\\n            end = rowsCount;\\n            increment = 1\\n        }                \\n    }\\n\\n    return matrix\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n\\n    if ((rowsCount * colsCount) !== this.length){\\n        return []\\n    }\\n\\n    const matrix = []\\n    for (let i = 0; i < rowsCount; i++){\\n        matrix.push([])\\n    }\\n\\n    let index = 0;\\n\\n\\n    let start = 0;\\n    let end = rowsCount;\\n    let increment =  1\\n\\n    for (let i =0 ; i < colsCount;i += 1){\\n        for(let j =start; start < end? j < end : j > end; j += increment ){\\n            matrix[j].push(this[index])\\n            index ++\\n        }\\n        if (start == 0){\\n            start = rowsCount -1\\n            end = -1;\\n            increment = -1;\\n        } else{\\n            start = 0\\n            end = rowsCount;\\n            increment = 1\\n        }                \\n    }\\n\\n    return matrix\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807238,
                "title": "typescript-very-straightforward-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount*colsCount !== this.length) return []\\n    let retArr = []\\n    \\n    // constructing 2d array\\n    for(let i=0; i<rowsCount; i++) {\\n        let col = []\\n        for(let j=0; j<colsCount; j++) {\\n            col.push(0)\\n        }\\n        retArr.push(col)\\n    }\\n\\n    // populating\\n    let idx = 0\\n    for(let j=0; j<colsCount; j++) {\\n        if(j%2==0) {\\n            for(let i=0; i<rowsCount; i++) {\\n                retArr[i][j] = this[idx++]\\n            }\\n        } else {\\n            for(let i=rowsCount-1; i>=0; i--) {\\n                retArr[i][j] = this[idx++]\\n            }\\n        }\\n    }\\n    return retArr\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount*colsCount !== this.length) return []\\n    let retArr = []\\n    \\n    // constructing 2d array\\n    for(let i=0; i<rowsCount; i++) {\\n        let col = []\\n        for(let j=0; j<colsCount; j++) {\\n            col.push(0)\\n        }\\n        retArr.push(col)\\n    }\\n\\n    // populating\\n    let idx = 0\\n    for(let j=0; j<colsCount; j++) {\\n        if(j%2==0) {\\n            for(let i=0; i<rowsCount; i++) {\\n                retArr[i][j] = this[idx++]\\n            }\\n        } else {\\n            for(let i=rowsCount-1; i>=0; i--) {\\n                retArr[i][j] = this[idx++]\\n            }\\n        }\\n    }\\n    return retArr\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766434,
                "title": "js-solution",
                "content": "```\\nArray.prototype.snail = function(M, N, A = [...Array(M)].map(_ => Array(N)), k = 0) {\\n    if (M * N != this.length)\\n        return [];\\n    for (let j = 0; j < N; ++j)\\n        for (let i = (j & 1) ? M - 1 : 0; 0 <= i && i < M; i += (j & 1) ? -1 : 1)\\n            A[i][j] = this[k++];\\n    return A;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nArray.prototype.snail = function(M, N, A = [...Array(M)].map(_ => Array(N)), k = 0) {\\n    if (M * N != this.length)\\n        return [];\\n    for (let j = 0; j < N; ++j)\\n        for (let i = (j & 1) ? M - 1 : 0; 0 <= i && i < M; i += (j & 1) ? -1 : 1)\\n            A[i][j] = this[k++];\\n    return A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3764460,
                "title": "array-prototype-snail-javascript-mdn-web-docs",
                "content": "\\n# Beginner Approach :\\n# Syntax\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n\\n    if (rowsCount * colsCount !== this.length) return []\\n\\n    let snailMatrix =  Array();\\n\\n    for(let i = 0;i< rowsCount ;i++){\\n        snailMatrix.push(Array(colsCount));\\n    }\\n\\n\\n    let left = 0;\\n    let right = colsCount - 1;\\n    let l = 0;\\n    let col = 0;\\n\\n    while(left <= right){\\n\\n        if(left % 2 == 0) {\\n            for(let i = 0;i<rowsCount;i++){\\n            snailMatrix[i][col] = this[l];\\n            l++;\\n        }\\n        } else {\\n            \\n            for(let i = rowsCount - 1;i>=0;i--){\\n            snailMatrix[i][col] = this[l];\\n            l++;\\n        }\\n\\n        }\\n        \\n        col++;\\n        left++;\\n\\n    }\\n\\n        return snailMatrix;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n\\n    if (rowsCount * colsCount !== this.length) return []\\n\\n    let snailMatrix =  Array();\\n\\n    for(let i = 0;i< rowsCount ;i++){\\n        snailMatrix.push(Array(colsCount));\\n    }\\n\\n\\n    let left = 0;\\n    let right = colsCount - 1;\\n    let l = 0;\\n    let col = 0;\\n\\n    while(left <= right){\\n\\n        if(left % 2 == 0) {\\n            for(let i = 0;i<rowsCount;i++){\\n            snailMatrix[i][col] = this[l];\\n            l++;\\n        }\\n        } else {\\n            \\n            for(let i = rowsCount - 1;i>=0;i--){\\n            snailMatrix[i][col] = this[l];\\n            l++;\\n        }\\n\\n        }\\n        \\n        col++;\\n        left++;\\n\\n    }\\n\\n        return snailMatrix;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757847,
                "title": "beats-100-of-solutions",
                "content": "# Intuition\\nTry to find the pattern of traversal. Here there is definitly a fixed pattern. In case we are able to find that pattern then we can come up with a forumula for every row. He we can clearly see a pattern in each row.\\n\\nrow1 indexes :  0,9,10,19\\nrow2 indexes :  1,8,11,18\\nrow3 indexes :  2,7,12,17\\nrow4 indexes :  3,6,13,16\\nrow5 indexes :  4,5,14,15\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPopulating the first row is easy. All the number are from index (col+1) * rowCount -1 or col*rowCount. \\n\\nNow once the polulate the first row , we store the index of each element of the first row in another array and use that array to populate the next row. The index array follows the above pattern and can easly be set in the loop.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function (\\n  rowsCount: number,\\n  colsCount: number\\n): number[][] {\\n  // populate the first row\\n  if (rowsCount * colsCount !== this.length) {\\n    return [];\\n  }\\n  const finalArray: Array<Array<number>> = [];\\n  let firstRow = [];\\n  let firstRowIdx: Array<number> = [];\\n\\n  for (let i = 0; i < colsCount; i++) {\\n    let idx = 0;\\n    if (i === 0) {\\n      idx = 0;\\n    } else if (i % 2 !== 0) {\\n      idx = (i + 1) * rowsCount - 1;\\n    } else {\\n      idx = i * rowsCount;\\n    }\\n\\n    firstRow.push(this[idx]);\\n    firstRowIdx.push(idx);\\n  }\\n  finalArray.push(firstRow);\\n\\n  for (let i = 1; i < rowsCount; i++) {\\n    let tempArray = [];\\n\\n    for (let j = 0; j < colsCount; j++) {\\n      let idx: number;\\n      if (j % 2 === 0) {\\n        idx = firstRowIdx[j] + 1;\\n      } else {\\n        idx = firstRowIdx[j] - 1;\\n      }\\n      firstRowIdx[j] = idx;\\n      tempArray.push(this[idx]);\\n    }\\n    finalArray.push(tempArray);\\n  }\\n\\n  return finalArray;\\n};\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function (\\n  rowsCount: number,\\n  colsCount: number\\n): number[][] {\\n  // populate the first row\\n  if (rowsCount * colsCount !== this.length) {\\n    return [];\\n  }\\n  const finalArray: Array<Array<number>> = [];\\n  let firstRow = [];\\n  let firstRowIdx: Array<number> = [];\\n\\n  for (let i = 0; i < colsCount; i++) {\\n    let idx = 0;\\n    if (i === 0) {\\n      idx = 0;\\n    } else if (i % 2 !== 0) {\\n      idx = (i + 1) * rowsCount - 1;\\n    } else {\\n      idx = i * rowsCount;\\n    }\\n\\n    firstRow.push(this[idx]);\\n    firstRowIdx.push(idx);\\n  }\\n  finalArray.push(firstRow);\\n\\n  for (let i = 1; i < rowsCount; i++) {\\n    let tempArray = [];\\n\\n    for (let j = 0; j < colsCount; j++) {\\n      let idx: number;\\n      if (j % 2 === 0) {\\n        idx = firstRowIdx[j] + 1;\\n      } else {\\n        idx = firstRowIdx[j] - 1;\\n      }\\n      firstRowIdx[j] = idx;\\n      tempArray.push(this[idx]);\\n    }\\n    finalArray.push(tempArray);\\n  }\\n\\n  return finalArray;\\n};\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3697084,
                "title": "beats-98-intuitive-javascript-solution",
                "content": "# Intuition\\nIterate over the original array just once and use a direction boolean to increase or decrease the row index.\\n\\n# Approach\\nA bool value `grow` dictate if the snail is going up or down the rows.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = []\\n\\n    if (rowsCount * colsCount !== this.length) return result;\\n\\n    let j = 0;\\n    let grow = true\\n\\n    // Initialize rows\\n    for (let i = 0; i < rowsCount; i++) {\\n        result[i] = []\\n    }\\n\\n    for (let i = 0; i < this.length; i++) {\\n        result[j].push(this[i]);\\n        grow ? j++ : j--;\\n\\n        if (j === rowsCount) {\\n            grow = false;\\n            j--;\\n        } else if (j === -1) {\\n            grow = true\\n            j++;\\n        }\\n    }\\n\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let result = []\\n\\n    if (rowsCount * colsCount !== this.length) return result;\\n\\n    let j = 0;\\n    let grow = true\\n\\n    // Initialize rows\\n    for (let i = 0; i < rowsCount; i++) {\\n        result[i] = []\\n    }\\n\\n    for (let i = 0; i < this.length; i++) {\\n        result[j].push(this[i]);\\n        grow ? j++ : j--;\\n\\n        if (j === rowsCount) {\\n            grow = false;\\n            j--;\\n        } else if (j === -1) {\\n            grow = true\\n            j++;\\n        }\\n    }\\n\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679914,
                "title": "js-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let arr= this;\\n    let res= []\\n    let len = arr.length;\\n    if(len!=rowsCount*colsCount) return res;\\n    for(let i =0;i<rowsCount;i++){\\n        res.push([]);\\n    }\\n    let rowStart=0;\\n    let colStart=0\\n    let k =0;\\n    while(rowStart<rowsCount && colStart<colsCount){\\n        for(let i=rowStart;i<rowsCount;i++){\\n            res[i][colStart] = arr[k];\\n            k++\\n        }\\n        colStart++;\\n        if(colStart<colsCount){\\n        for(let i =rowsCount-1;i>=0;i--){\\n            \\n            res[i][colStart]=arr[k];\\n            k++;\\n\\n        }\\n        }\\n        colStart++;\\n\\n    }\\n    return res;\\n\\n\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let arr= this;\\n    let res= []\\n    let len = arr.length;\\n    if(len!=rowsCount*colsCount) return res;\\n    for(let i =0;i<rowsCount;i++){\\n        res.push([]);\\n    }\\n    let rowStart=0;\\n    let colStart=0\\n    let k =0;\\n    while(rowStart<rowsCount && colStart<colsCount){\\n        for(let i=rowStart;i<rowsCount;i++){\\n            res[i][colStart] = arr[k];\\n            k++\\n        }\\n        colStart++;\\n        if(colStart<colsCount){\\n        for(let i =rowsCount-1;i>=0;i--){\\n            \\n            res[i][colStart]=arr[k];\\n            k++;\\n\\n        }\\n        }\\n        colStart++;\\n\\n    }\\n    return res;\\n\\n\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659363,
                "title": "javascript-solution",
                "content": "\\n\\n# Code\\n```\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    \\n    if(this.length != (rowsCount*colsCount)) return [];\\n    \\n    let ans = new Array(rowsCount);\\n    for(let i=0; i<rowsCount; i++){\\n        ans[i] = new Array(colsCount);\\n    }\\n\\n    let bool = true;\\n    let index = 0;\\n\\n    for(let i=0; i<colsCount; i++){\\n        for(let j=0; j<rowsCount; j++){\\n            if(bool){ ans[j][i] = this[index++]; }\\n            else{ ans[rowsCount-j-1][i] = this[index++]; }\\n        }\\n        bool = !bool;\\n    }\\n\\n    return ans;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    \\n    if(this.length != (rowsCount*colsCount)) return [];\\n    \\n    let ans = new Array(rowsCount);\\n    for(let i=0; i<rowsCount; i++){\\n        ans[i] = new Array(colsCount);\\n    }\\n\\n    let bool = true;\\n    let index = 0;\\n\\n    for(let i=0; i<colsCount; i++){\\n        for(let j=0; j<rowsCount; j++){\\n            if(bool){ ans[j][i] = this[index++]; }\\n            else{ ans[rowsCount-j-1][i] = this[index++]; }\\n        }\\n        bool = !bool;\\n    }\\n\\n    return ans;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3652814,
                "title": "easy-just-doing-what-we-would-do-in-the-real-life-beats-95-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust create the result array as we would in real life.Create one column at time while changing the column-creation directions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First, create a M * N result array with zeros. \\n- We will be filling each column with rowCount elements at time up to the  last column.\\n- Have few trackers for traversal:\\n    1. The current rowIndex that we are at, starts at 0\\n    2. The current columnIndex we are at, starts at 0\\n    1. The direction we are going as we fill a column, we will start by going down. This will help us know if we should reduce or increment the rowIndex.\\n- When we are going down we will increase rowIndex, when we are going up we will reduce the rowIndex\\n- When rowIndex== rowCount , we know we are out of bound and it is time to go up ( setting  isDown= false ), we should also reset the rowIndex to rowCount-1\\n- When rowIndex== -1 , ( setting isDown= true ), we  we know it is time to  go down. we should also reset the rowIndex to 0\\n- At each turn,we know we are in a new column hence increment the columnIndex.\\n- Do this until all the element in the input are array are over.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$  where $$n$$ is the number of rows  and $$m$$ is the number of columns.\\n\\n- Space complexity:\\n$$O(n*m)$$ because of the output array.\\n\\n### Please give a vote up if you like this solution \\n\\n# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    /*  This part of the problem description  */\\n    if(this.length != rowsCount* colsCount){\\n      return []\\n    }\\n    \\n    //create a rowCount * colsCount array that will be modified and returned by the function.\\n    const result: number [][]= new Array(rowsCount).fill(null).map(()=>new Array(colsCount).fill(0))\\n    let colIndex: number= 0\\n    let rowIndex: number=0\\n    let isDown: boolean = true //starting by goind down.\\n\\n    for(let num of this ){\\n      if(isDown){\\n        result[rowIndex][colIndex]= num\\n        rowIndex++\\n      }\\n    \\n      if(!isDown){\\n        result[rowIndex][colIndex]= num\\n        rowIndex--\\n      }\\n      //it is time to go up, reset the val of rowIndex and \\n      // go to the next column\\n      if(rowIndex==rowsCount){\\n        isDown= false\\n        rowIndex=rowsCount-1\\n        colIndex++\\n       }\\n      //it is time to go down, reset the val of rowIndex and \\n      // go to the next column\\n      if(rowIndex==-1){\\n        isDown= true\\n        rowIndex=0\\n        colIndex++\\n      }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    /*  This part of the problem description  */\\n    if(this.length != rowsCount* colsCount){\\n      return []\\n    }\\n    \\n    //create a rowCount * colsCount array that will be modified and returned by the function.\\n    const result: number [][]= new Array(rowsCount).fill(null).map(()=>new Array(colsCount).fill(0))\\n    let colIndex: number= 0\\n    let rowIndex: number=0\\n    let isDown: boolean = true //starting by goind down.\\n\\n    for(let num of this ){\\n      if(isDown){\\n        result[rowIndex][colIndex]= num\\n        rowIndex++\\n      }\\n    \\n      if(!isDown){\\n        result[rowIndex][colIndex]= num\\n        rowIndex--\\n      }\\n      //it is time to go up, reset the val of rowIndex and \\n      // go to the next column\\n      if(rowIndex==rowsCount){\\n        isDown= false\\n        rowIndex=rowsCount-1\\n        colIndex++\\n       }\\n      //it is time to go down, reset the val of rowIndex and \\n      // go to the next column\\n      if(rowIndex==-1){\\n        isDown= true\\n        rowIndex=0\\n        colIndex++\\n      }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3646301,
                "title": "typescript-solution",
                "content": "# Code\\n```ts\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][] | [];\\n  }\\n}\\n\\nfunction isEven(num: number): boolean {\\n  return num % 2 === 0\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] | [] {\\n    if (rowsCount * colsCount !== this.length) return []\\n\\n    const result = []\\n    const templateRowIndex = [0]\\n\\n    while (templateRowIndex.length < colsCount) {\\n      const lastIndex = templateRowIndex[templateRowIndex.length - 1]\\n\\n      const nextIndex = isEven(lastIndex) ? lastIndex + rowsCount * 2 - 1 : lastIndex + 1\\n      templateRowIndex.push(nextIndex)\\n    }\\n\\n    for(let i = 0; i < rowsCount; i++) {\\n      const row = templateRowIndex.map((it, j) => isEven(j) ? this[it + i] : this[it - i])\\n      result.push(row)\\n    }\\n\\n    return result\\n}\\n\\n\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][] | [];\\n  }\\n}\\n\\nfunction isEven(num: number): boolean {\\n  return num % 2 === 0\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] | [] {\\n    if (rowsCount * colsCount !== this.length) return []\\n\\n    const result = []\\n    const templateRowIndex = [0]\\n\\n    while (templateRowIndex.length < colsCount) {\\n      const lastIndex = templateRowIndex[templateRowIndex.length - 1]\\n\\n      const nextIndex = isEven(lastIndex) ? lastIndex + rowsCount * 2 - 1 : lastIndex + 1\\n      templateRowIndex.push(nextIndex)\\n    }\\n\\n    for(let i = 0; i < rowsCount; i++) {\\n      const row = templateRowIndex.map((it, j) => isEven(j) ? this[it + i] : this[it - i])\\n      result.push(row)\\n    }\\n\\n    return result\\n}\\n\\n\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3628534,
                "title": "beats-99-80",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(row, col) {\\n  if (row * col != this.length) return [];\\n  let res = Array(row)\\n    .fill()\\n    .map(() => []);\\n  var x = 0;\\n  for (let i = 0; i < col; i++) {\\n    if (i % 2 == 0) {\\n      for (let j = 0; j < row; j++) {\\n        res[j][i] = this[x];\\n        x++;\\n      }\\n    } else {\\n      for (let j = row - 1; j >= 0; j--) {\\n        res[j][i] = this[x];\\n        x++;\\n      }\\n    }\\n  }\\n  return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(row, col) {\\n  if (row * col != this.length) return [];\\n  let res = Array(row)\\n    .fill()\\n    .map(() => []);\\n  var x = 0;\\n  for (let i = 0; i < col; i++) {\\n    if (i % 2 == 0) {\\n      for (let j = 0; j < row; j++) {\\n        res[j][i] = this[x];\\n        x++;\\n      }\\n    } else {\\n      for (let j = row - 1; j >= 0; j--) {\\n        res[j][i] = this[x];\\n        x++;\\n      }\\n    }\\n  }\\n  return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3598308,
                "title": "js-iteration",
                "content": "# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let length = this.length;\\n    let arr = [];\\n    \\n    for(let i = 0 ; i < rowsCount ; i++){\\n        arr.push([]);\\n    }\\n    \\n    let row = 0;\\n\\n    for(let i = 0 ; i < colsCount ; i++){\\n\\n        \\n        if(row === 0 || row === -1){\\n            \\n            row = 0;\\n            \\n            while(row < rowsCount){\\n                arr[row].push(this.shift());\\n                row++;\\n            }\\n\\n        }else{\\n\\n            row = rowsCount - 1;\\n\\n            while(row >= 0){\\n                arr[row].push(this.shift());\\n                row--;\\n            }\\n\\n        }\\n\\n    }\\n\\n    return rowsCount*colsCount !== length  ? []:  arr;\\n};\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let length = this.length;\\n    let arr = [];\\n    \\n    for(let i = 0 ; i < rowsCount ; i++){\\n        arr.push([]);\\n    }\\n    \\n    let row = 0;\\n\\n    for(let i = 0 ; i < colsCount ; i++){\\n\\n        \\n        if(row === 0 || row === -1){\\n            \\n            row = 0;\\n            \\n            while(row < rowsCount){\\n                arr[row].push(this.shift());\\n                row++;\\n            }\\n\\n        }else{\\n\\n            row = rowsCount - 1;\\n\\n            while(row >= 0){\\n                arr[row].push(this.shift());\\n                row--;\\n            }\\n\\n        }\\n\\n    }\\n\\n    return rowsCount*colsCount !== length  ? []:  arr;\\n};\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589805,
                "title": "linear-iteration-on-a-2d-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTranslating the index on the original array to a 2-index array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n\\n    const newArr = [];\\n    let index = 0;\\n    while (index < this.length) {\\n        const colIndex =  ~~(index / rowsCount);\\n        const rowIndex = index - colIndex * rowsCount;\\n        if (colIndex == 0){\\n            newArr[rowIndex] = [];\\n        }\\n        const rowPos = colIndex % 2 == 1 ? rowsCount - rowIndex - 1 : rowIndex;\\n        newArr[rowPos][colIndex] = this[index];\\n        index++;\\n    }\\n    return newArr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n\\n    const newArr = [];\\n    let index = 0;\\n    while (index < this.length) {\\n        const colIndex =  ~~(index / rowsCount);\\n        const rowIndex = index - colIndex * rowsCount;\\n        if (colIndex == 0){\\n            newArr[rowIndex] = [];\\n        }\\n        const rowPos = colIndex % 2 == 1 ? rowsCount - rowIndex - 1 : rowIndex;\\n        newArr[rowPos][colIndex] = this[index];\\n        index++;\\n    }\\n    return newArr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586476,
                "title": "javascript-clean-and-easy-solution-with-a-single-loop",
                "content": "# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n\\n    const matrix = Array.from(Array(rowsCount)).map(() => []);\\n    \\n    let row = 0;\\n    let pointer = 0;\\n    let forward = true;\\n    let processed = 0;\\n\\n    while (processed < this.length) {\\n        matrix[row].push(this[pointer]);\\n\\n        if (forward) {\\n            if (row === rowsCount - 1) {\\n                row = 0;\\n                pointer += rowsCount;\\n                forward = false;\\n            } else {\\n                row += 1;\\n                pointer += 1;\\n            }\\n        } else {\\n            if (row === rowsCount - 1) {\\n                row = 0;\\n                pointer += rowsCount;\\n                forward = true;\\n            } else {\\n                row += 1;\\n                pointer -= 1;\\n            }\\n        }\\n\\n        processed += 1;\\n    }\\n\\n    return matrix;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n\\n    const matrix = Array.from(Array(rowsCount)).map(() => []);\\n    \\n    let row = 0;\\n    let pointer = 0;\\n    let forward = true;\\n    let processed = 0;\\n\\n    while (processed < this.length) {\\n        matrix[row].push(this[pointer]);\\n\\n        if (forward) {\\n            if (row === rowsCount - 1) {\\n                row = 0;\\n                pointer += rowsCount;\\n                forward = false;\\n            } else {\\n                row += 1;\\n                pointer += 1;\\n            }\\n        } else {\\n            if (row === rowsCount - 1) {\\n                row = 0;\\n                pointer += rowsCount;\\n                forward = true;\\n            } else {\\n                row += 1;\\n                pointer -= 1;\\n            }\\n        }\\n\\n        processed += 1;\\n    }\\n\\n    return matrix;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3579598,
                "title": "snail-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith loops we can do more!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. we do check if the total number of elements in the array (this.length) matches the expected number of elements based on the provided rows and columns (rowsCount * colsCount). If they don\\'t match - we return [] (empty array).\\n\\n2. an empty array called `result` is created to store the snail pattern\\n\\n3. then, we iterate through each row and initializes an empty array within the result array, using the push method. This fills up the rows\\n\\n4. last loop (main one) is started to populate the data into the snail pattern. The index `i` is used to keep track of the current index in the original array.\\n\\n5. within the loop, two nested loops are used to traverse the snail pattern. The first loop goes from the top to the bottom of the snail pattern, and second loop goes from the bottom.\\n\\n6. each of these inner loops pushes next ordinal value from our kinda \"horizontal\" array.\\n\\n7. the main loop continues until all elements from the original array have been processed.\\n\\nAnd that\\'s it! The resulting snail pattern is returned.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n  if (rowsCount * colsCount !== this.length) { return []; }\\n  let result = [];\\n  let i = 0;\\n  // fill up rows\\n  for (let i = 0; i < rowsCount; i++) {\\n    result.push([]);\\n  }\\n  // populate data\\n  i = 0;\\n  while (i < this.length) {\\n    // form the top to the bottom\\n    for (let j = 0; j < rowsCount; j++) {\\n      result[j].push(this[i++]);\\n    }\\n    // from the bottom to the top\\n    for (let j = rowsCount - 1; j >= 0 && i in this; j--) {\\n      result[j].push(this[i++]);\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n  if (rowsCount * colsCount !== this.length) { return []; }\\n  let result = [];\\n  let i = 0;\\n  // fill up rows\\n  for (let i = 0; i < rowsCount; i++) {\\n    result.push([]);\\n  }\\n  // populate data\\n  i = 0;\\n  while (i < this.length) {\\n    // form the top to the bottom\\n    for (let j = 0; j < rowsCount; j++) {\\n      result[j].push(this[i++]);\\n    }\\n    // from the bottom to the top\\n    for (let j = rowsCount - 1; j >= 0 && i in this; j--) {\\n      result[j].push(this[i++]);\\n    }\\n  }\\n\\n  return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3579040,
                "title": "typescript-simple-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. From the original array we get an array of columns\\n2. Reverse even columns\\n3. Transpose the matrix\\n\\n# Complexity\\n- Time complexity: 238 ms Beats 29.70%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 65.1 MB Beats 6.84%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n\\n  if (rowsCount * colsCount != this.length) return []\\n\\n  const array: number[][] = []\\n  const result: number[][] = []\\n  let column: number = 0\\n\\n  for (let i = 0; i < this.length; i += rowsCount) {\\n    array.push(this.slice(i, i + rowsCount))\\n    column++\\n\\n    if(column % 2 === 0) {\\n      array[column - 1].reverse()\\n    }\\n  }\\n\\n  for (let i = 0; i < rowsCount; i++) {\\n    const row: number[] = []\\n    for (let j = 0; j < colsCount; j++) {\\n      row.push(array[j][i])\\n    }\\n    result.push(row)\\n  }\\n\\n  return result\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n\\n  if (rowsCount * colsCount != this.length) return []\\n\\n  const array: number[][] = []\\n  const result: number[][] = []\\n  let column: number = 0\\n\\n  for (let i = 0; i < this.length; i += rowsCount) {\\n    array.push(this.slice(i, i + rowsCount))\\n    column++\\n\\n    if(column % 2 === 0) {\\n      array[column - 1].reverse()\\n    }\\n  }\\n\\n  for (let i = 0; i < rowsCount; i++) {\\n    const row: number[] = []\\n    for (let j = 0; j < colsCount; j++) {\\n      row.push(array[j][i])\\n    }\\n    result.push(row)\\n  }\\n\\n  return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575963,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length != (rowsCount * colsCount)) {\\n        return []\\n    } else {\\n        let newArr = [];\\n        let start = 0;\\n        let end = rowsCount;\\n        for (let i = 0; i < colsCount; i++) {\\n            let arr = this.slice(start, end)\\n            if (i %2 == 0) {\\n                newArr.push(arr);\\n            } else {\\n                arr.reverse()\\n                newArr.push(arr);\\n            }\\n            start = end;\\n            end += rowsCount;\\n        }\\n\\n        return Object.keys(newArr[0]).map(function(c) {\\n            return newArr.map(function(r) { return r[c]; });\\n        });\\n    }\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length != (rowsCount * colsCount)) {\\n        return []\\n    } else {\\n        let newArr = [];\\n        let start = 0;\\n        let end = rowsCount;\\n        for (let i = 0; i < colsCount; i++) {\\n            let arr = this.slice(start, end)\\n            if (i %2 == 0) {\\n                newArr.push(arr);\\n            } else {\\n                arr.reverse()\\n                newArr.push(arr);\\n            }\\n            start = end;\\n            end += rowsCount;\\n        }\\n\\n        return Object.keys(newArr[0]).map(function(c) {\\n            return newArr.map(function(r) { return r[c]; });\\n        });\\n    }\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3573294,
                "title": "enum-approach-in-javascript-using-an-enum-for-direction-of-traversing",
                "content": "# Intuition\\nTraverse the given array and build the result 2D array during the process, populating the result array in alternate directions.\\n\\n# Approach\\nHave an Enum representing the direction of traversing the result array. Loop thru the given array sequentially and populate/assign the current number to appropriate cell/position in the result 2D array, while alternating the row increment/decrement direction based on the \\'Direction\\' enum value.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is number of element in given input array.\\n\\n- Space complexity:\\nO(p * q), where p is number of rows and q is number of columns in the result array.\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nconst Direction = {\\n    DOWN: Symbol(1),\\n    UP: Symbol(2)\\n};\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount != this.length) return [];\\n\\n    let row = 0, col = 0, i = 0;\\n    let direction = Direction.DOWN;\\n    let result = [];\\n\\n    while (i < this.length) {\\n        if (result.length < rowsCount) {\\n            result.push([]); // Add new row if not already added\\n        }\\n        result[row][col] = this[i];\\n\\n        if (direction == Direction.DOWN) { // Traverse down\\n            row += 1;\\n            if (row > rowsCount - 1) {\\n                row = rowsCount - 1;\\n                col += 1;\\n                direction = Direction.UP; // Reverse to up direction\\n            }\\n        } else if (direction == Direction.UP) { // Traverse up\\n            row -= 1;\\n            if (row < 0) {\\n                row = 0;\\n                col += 1;\\n                direction = Direction.DOWN; // Reverse to down direction\\n            }\\n        }\\n\\n        i += 1;\\n    }\\n\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nconst Direction = {\\n    DOWN: Symbol(1),\\n    UP: Symbol(2)\\n};\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount != this.length) return [];\\n\\n    let row = 0, col = 0, i = 0;\\n    let direction = Direction.DOWN;\\n    let result = [];\\n\\n    while (i < this.length) {\\n        if (result.length < rowsCount) {\\n            result.push([]); // Add new row if not already added\\n        }\\n        result[row][col] = this[i];\\n\\n        if (direction == Direction.DOWN) { // Traverse down\\n            row += 1;\\n            if (row > rowsCount - 1) {\\n                row = rowsCount - 1;\\n                col += 1;\\n                direction = Direction.UP; // Reverse to up direction\\n            }\\n        } else if (direction == Direction.UP) { // Traverse up\\n            row -= 1;\\n            if (row < 0) {\\n                row = 0;\\n                col += 1;\\n                direction = Direction.DOWN; // Reverse to down direction\\n            }\\n        }\\n\\n        i += 1;\\n    }\\n\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3561220,
                "title": "easy-to-understand-solution",
                "content": "\\n```\\n\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n  if (this.length !== rowsCount * colsCount) return [];\\n\\n  const output = [];\\n  const chunks = [];\\n\\n  let idx = 0;\\n\\n  for (let i = 0; i < this.length; i += rowsCount) {\\n    const chunk = this.slice(i, i + rowsCount);\\n\\n    if (idx % 2 === 0) chunks.push(chunk);\\n    else chunks.push(chunk.reverse());\\n    idx++;\\n  }\\n\\n  let index = 0;\\n\\n  while (index < rowsCount) {\\n    output.push(chunks.map(el => el[index]));\\n    index++;\\n  }\\n\\n  return output;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n  if (this.length !== rowsCount * colsCount) return [];\\n\\n  const output = [];\\n  const chunks = [];\\n\\n  let idx = 0;\\n\\n  for (let i = 0; i < this.length; i += rowsCount) {\\n    const chunk = this.slice(i, i + rowsCount);\\n\\n    if (idx % 2 === 0) chunks.push(chunk);\\n    else chunks.push(chunk.reverse());\\n    idx++;\\n  }\\n\\n  let index = 0;\\n\\n  while (index < rowsCount) {\\n    output.push(chunks.map(el => el[index]));\\n    index++;\\n  }\\n\\n  return output;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3553378,
                "title": "javascript-with-comments-begineer-friendly-5-lines",
                "content": "# Code\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const ans = [];\\n\\n    // Invalid Input\\n    if (rowsCount * colsCount !== this.length) return [];\\n\\n    // Step 1: Push elements in ans in group of rowsCount\\n    while(this.length) ans.push(this.splice(0, rowsCount));\\n\\n    // Step 2: Reverse every second array in ans\\n    for(let i=1; i<colsCount; i += 2) ans[i].reverse();\\n\\n    // Step 3: Change row to column and column to row (Transpose)\\n    return ans[0].map((_, i) => ans.map(row => row[i]));\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const ans = [];\\n\\n    // Invalid Input\\n    if (rowsCount * colsCount !== this.length) return [];\\n\\n    // Step 1: Push elements in ans in group of rowsCount\\n    while(this.length) ans.push(this.splice(0, rowsCount));\\n\\n    // Step 2: Reverse every second array in ans\\n    for(let i=1; i<colsCount; i += 2) ans[i].reverse();\\n\\n    // Step 3: Change row to column and column to row (Transpose)\\n    return ans[0].map((_, i) => ans.map(row => row[i]));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3547172,
                "title": "simple-single-loop-direction-controlled",
                "content": "# Intuition\\nChange the direction of flow by using a direction variable\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const cellsCount = rowsCount * colsCount;\\n\\n    /* If input length is not same as total cells expected */\\n    if(this.length !== cellsCount){\\n        return [];\\n    }\\n\\n    let pos = 0, direction = 1;\\n    const grid = Array.from(new Array(rowsCount), () => []); // Array of empty arrays\\n    for(let i = 0; i < rowsCount * colsCount; i++){\\n        /* control the direction of flow when boundary is crossed */\\n        if(pos === rowsCount || pos === -1){\\n            direction = -direction;\\n            pos += direction;\\n        }\\n\\n        grid[pos].push(this[i]);\\n        pos += direction;\\n    }\\n\\n    return grid;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const cellsCount = rowsCount * colsCount;\\n\\n    /* If input length is not same as total cells expected */\\n    if(this.length !== cellsCount){\\n        return [];\\n    }\\n\\n    let pos = 0, direction = 1;\\n    const grid = Array.from(new Array(rowsCount), () => []); // Array of empty arrays\\n    for(let i = 0; i < rowsCount * colsCount; i++){\\n        /* control the direction of flow when boundary is crossed */\\n        if(pos === rowsCount || pos === -1){\\n            direction = -direction;\\n            pos += direction;\\n        }\\n\\n        grid[pos].push(this[i]);\\n        pos += direction;\\n    }\\n\\n    return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546640,
                "title": "javascript-easy-solution-o-n-two-pointer-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let finalArr = [], len = this.length, row = rowsCount, downwards = true;\\n    while(row) {\\n        finalArr.push([]);\\n        row--;\\n    }\\n    if(rowsCount*colsCount != len) return [];\\n    for(let i = 0; i < len; i++) {\\n        if(row == rowsCount) {\\n            downwards = false;\\n            row--;\\n        }\\n        if(row == -1) {\\n            downwards = true;\\n            row++;\\n        }\\n        finalArr[row].push(this[i]);\\n        if(downwards) row++;\\n        else row--;\\n    }\\n    return finalArr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let finalArr = [], len = this.length, row = rowsCount, downwards = true;\\n    while(row) {\\n        finalArr.push([]);\\n        row--;\\n    }\\n    if(rowsCount*colsCount != len) return [];\\n    for(let i = 0; i < len; i++) {\\n        if(row == rowsCount) {\\n            downwards = false;\\n            row--;\\n        }\\n        if(row == -1) {\\n            downwards = true;\\n            row++;\\n        }\\n        finalArr[row].push(this[i]);\\n        if(downwards) row++;\\n        else row--;\\n    }\\n    return finalArr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536615,
                "title": "easy-solution-to-understand-beginner-s-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n    let length = this.length;\\n    let arr = [];\\n    for(let i=0; i<length; i++) {\\n        let temp = [];\\n        for(let j=0; j<rowsCount; j++) {\\n            temp.push(this[i]);\\n            i++;\\n        }\\n        i--;\\n        arr.push(temp);\\n    }\\n    for(let i=0; i<arr.length; i++) {\\n        if(i%2 !== 0) {\\n            arr[i].reverse();\\n        }\\n    }\\n    let ans = [];\\n    for(let i=0; i<arr[0].length; i++) {\\n        let temp = [];\\n        for(let j=0; j<arr.length; j++) {\\n            temp.push(arr[j][i]);\\n        }\\n        ans.push(temp);\\n    }\\n    return ans;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n    let length = this.length;\\n    let arr = [];\\n    for(let i=0; i<length; i++) {\\n        let temp = [];\\n        for(let j=0; j<rowsCount; j++) {\\n            temp.push(this[i]);\\n            i++;\\n        }\\n        i--;\\n        arr.push(temp);\\n    }\\n    for(let i=0; i<arr.length; i++) {\\n        if(i%2 !== 0) {\\n            arr[i].reverse();\\n        }\\n    }\\n    let ans = [];\\n    for(let i=0; i<arr[0].length; i++) {\\n        let temp = [];\\n        for(let j=0; j<arr.length; j++) {\\n            temp.push(arr[j][i]);\\n        }\\n        ans.push(temp);\\n    }\\n    return ans;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536432,
                "title": "flip-rowindex-for-even-column",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const res = Array(rowsCount).fill(0).map((c) => Array(colsCount).fill(0));\\n    const len = this.length;\\n    if(rowsCount * colsCount  !== len) return []\\n\\n    let currCol= 0;\\n    let index= 0;\\n    while(currCol < colsCount) {\\n        for(let r=0;r<rowsCount;r++) {\\n            let currRow = r\\n            if(currCol % 2 !== 0) {\\n                currRow = rowsCount - r -1 ;\\n            } \\n            res[currRow][currCol] = this[index]\\n            ++index\\n        }\\n        ++currCol;\\n    }\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const res = Array(rowsCount).fill(0).map((c) => Array(colsCount).fill(0));\\n    const len = this.length;\\n    if(rowsCount * colsCount  !== len) return []\\n\\n    let currCol= 0;\\n    let index= 0;\\n    while(currCol < colsCount) {\\n        for(let r=0;r<rowsCount;r++) {\\n            let currRow = r\\n            if(currCol % 2 !== 0) {\\n                currRow = rowsCount - r -1 ;\\n            } \\n            res[currRow][currCol] = this[index]\\n            ++index\\n        }\\n        ++currCol;\\n    }\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525596,
                "title": "solution-with-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const inputValuesAreInvalid = rowsCount * colsCount !== this.length\\n\\n    if (inputValuesAreInvalid) return []\\n\\n    let result = []    // is the array that contains the rows\\n\\n    function generateArrayReduceDefaultValue() {    // generates the array of rows\\n        for (let count=0; count < rowsCount; count++) {\\n            result.push([])\\n        }\\n    }\\n\\n    generateArrayReduceDefaultValue()\\n\\n    let rowToAddValue = 0   // means on which array of the array of rows the value will get added\\n    let direction = \\'normal\\'    // decides if the items will get added on the order rtl or ltr, it\\'s important because on the second column (of the image) for example the numbers are apprearing onn the order 8, 7, 2... not 17, 1, 2\\n\\n    for (value of this) {\\n        const currentRowIsTooHigh = rowToAddValue === rowsCount\\n        const currentRowIsTooLow = rowToAddValue === -1\\n\\n        if (currentRowIsTooHigh) {\\n            rowToAddValue = rowsCount-1\\n            direction = \\'reverse\\'\\n        }\\n        else if (currentRowIsTooLow) {\\n            rowToAddValue = 0\\n            direction = \\'normal\\'\\n        }\\n\\n        result[rowToAddValue].push(value)\\n        direction === \\'normal\\' ? rowToAddValue++ : rowToAddValue--\\n    }\\n\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const inputValuesAreInvalid = rowsCount * colsCount !== this.length\\n\\n    if (inputValuesAreInvalid) return []\\n\\n    let result = []    // is the array that contains the rows\\n\\n    function generateArrayReduceDefaultValue() {    // generates the array of rows\\n        for (let count=0; count < rowsCount; count++) {\\n            result.push([])\\n        }\\n    }\\n\\n    generateArrayReduceDefaultValue()\\n\\n    let rowToAddValue = 0   // means on which array of the array of rows the value will get added\\n    let direction = \\'normal\\'    // decides if the items will get added on the order rtl or ltr, it\\'s important because on the second column (of the image) for example the numbers are apprearing onn the order 8, 7, 2... not 17, 1, 2\\n\\n    for (value of this) {\\n        const currentRowIsTooHigh = rowToAddValue === rowsCount\\n        const currentRowIsTooLow = rowToAddValue === -1\\n\\n        if (currentRowIsTooHigh) {\\n            rowToAddValue = rowsCount-1\\n            direction = \\'reverse\\'\\n        }\\n        else if (currentRowIsTooLow) {\\n            rowToAddValue = 0\\n            direction = \\'normal\\'\\n        }\\n\\n        result[rowToAddValue].push(value)\\n        direction === \\'normal\\' ? rowToAddValue++ : rowToAddValue--\\n    }\\n\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524543,
                "title": "simple-implementation",
                "content": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(this.length !== rowsCount * colsCount) {\\n        return [];\\n    }\\n    \\n    const matrix = Array.from(Array(rowsCount), () => Array(colsCount));\\n    \\n    for(let i = 0, col = 0, reverse = false; col < colsCount; col++, reverse = !reverse) {\\n        if(reverse) {\\n            for(let row = rowsCount - 1; row >= 0; row--) {\\n                matrix[row][col] = this[i++];\\n            }\\n        } else {\\n            for(let row = 0; row < rowsCount; row++) {\\n                matrix[row][col] = this[i++];\\n            }\\n        }\\n    }\\n    \\n    return matrix;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(this.length !== rowsCount * colsCount) {\\n        return [];\\n    }\\n    \\n    const matrix = Array.from(Array(rowsCount), () => Array(colsCount));\\n    \\n    for(let i = 0, col = 0, reverse = false; col < colsCount; col++, reverse = !reverse) {\\n        if(reverse) {\\n            for(let row = rowsCount - 1; row >= 0; row--) {\\n                matrix[row][col] = this[i++];\\n            }\\n        } else {\\n            for(let row = 0; row < rowsCount; row++) {\\n                matrix[row][col] = this[i++];\\n            }\\n        }\\n    }\\n    \\n    return matrix;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3511744,
                "title": "easy-javascript-solution-by-beqa",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) time complaxity\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(row, col) {  \\n    if(this.length!==col*row) return []    \\n   const res=[]\\n   for(let i=0;i<row; i++){ res.push([])}\\n   let iter=0;\\n   for(let i=0;i<this.length;){\\n       for(let j=0;j<row; j++){\\n           if((iter+1)%2===0)res[row-1-j].push(this[i+j])           \\n           else res[j].push(this[i+j])\\n       }\\n       iter++\\n       i+=row\\n   }\\n   return res\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(row, col) {  \\n    if(this.length!==col*row) return []    \\n   const res=[]\\n   for(let i=0;i<row; i++){ res.push([])}\\n   let iter=0;\\n   for(let i=0;i<this.length;){\\n       for(let j=0;j<row; j++){\\n           if((iter+1)%2===0)res[row-1-j].push(this[i+j])           \\n           else res[j].push(this[i+j])\\n       }\\n       iter++\\n       i+=row\\n   }\\n   return res\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3506308,
                "title": "javascript-1d-to-2d-array-conversion",
                "content": "# Intuition\\nThe \"snail traversal\" is converting a 1D array into a 2D array by serpentining through the order of the array every N number of digits (where N is the number of rows in the 2D array). To do this, the original array will need to be traversed completely and the values of each position are transcribed into their new locations in the 2D array.\\n\\n# Approach\\nI decided I would do this with a for loop and have the placement of the value in the 2nd dimension array be kept in check by counting up to and down from the number of rows passed as an argument. Everytime the value equaled the number of rows, the placement would essentially \"turn around\" and begin placing again from that spot, but the traversal of the 2D arrays would then be backwards down to 0, where it would continue serpentining until the length of the original array would be reached.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the size of the original array\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount != this.length) return []\\n\\n    let snailArray = Array(rowsCount).fill([]).map(() => []);\\n    let serpentine = false\\n\\n    for (let i = 0, j = 0; i < this.length; ++i)\\n    {\\n        if (serpentine == true)\\n        {\\n            j--\\n            snailArray[j].push(this[i])\\n            if (j == 0) { serpentine = false }\\n        } else if (j < rowsCount && serpentine == false)\\n        {\\n            snailArray[j].push(this[i])\\n            j++\\n            if (j == rowsCount) { serpentine = true }\\n        }  \\n    }\\n\\n    return snailArray\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount != this.length) return []\\n\\n    let snailArray = Array(rowsCount).fill([]).map(() => []);\\n    let serpentine = false\\n\\n    for (let i = 0, j = 0; i < this.length; ++i)\\n    {\\n        if (serpentine == true)\\n        {\\n            j--\\n            snailArray[j].push(this[i])\\n            if (j == 0) { serpentine = false }\\n        } else if (j < rowsCount && serpentine == false)\\n        {\\n            snailArray[j].push(this[i])\\n            j++\\n            if (j == rowsCount) { serpentine = true }\\n        }  \\n    }\\n\\n    return snailArray\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504505,
                "title": "very-easy-solution-o-n",
                "content": "# Have fun with my code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) return []\\n    // Create a 2D array and initialize it with null values\\n    const matrix2d = new Array(rowsCount);\\n    for (let i = 0; i < rowsCount; i++) {\\n        matrix2d[i] = new Array(colsCount).fill(null);\\n    }\\n    let col = 0\\n    let row = 0\\n    for (let i = 0; i < this.length; i++) { \\n        if (col % 2 === 0) {   \\n            matrix2d[row][col] = this[i] \\n            if ((row + 1) === rowsCount) { \\n                col += 1\\n                continue\\n            }\\n            row += 1\\n        }\\n        else { \\n            matrix2d[row][col] = this[i] \\n            if (row === 0) {\\n                col += 1\\n                continue\\n            }\\n            row -= 1\\n        }\\n    }\\n    return matrix2d\\n}\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) return []\\n    // Create a 2D array and initialize it with null values\\n    const matrix2d = new Array(rowsCount);\\n    for (let i = 0; i < rowsCount; i++) {\\n        matrix2d[i] = new Array(colsCount).fill(null);\\n    }\\n    let col = 0\\n    let row = 0\\n    for (let i = 0; i < this.length; i++) { \\n        if (col % 2 === 0) {   \\n            matrix2d[row][col] = this[i] \\n            if ((row + 1) === rowsCount) { \\n                col += 1\\n                continue\\n            }\\n            row += 1\\n        }\\n        else { \\n            matrix2d[row][col] = this[i] \\n            if (row === 0) {\\n                col += 1\\n                continue\\n            }\\n            row -= 1\\n        }\\n    }\\n    return matrix2d\\n}\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503787,
                "title": "simple-beginner-friendly-bruteforce-approach",
                "content": "# Intuition\\nThe code implements a function that takes in the number of rows and columns, and returns a 2D array in a \"snail\" pattern. The snail pattern means the array is traversed from left to right, then from top to bottom, then right to left, and finally bottom to top until all elements are covered.\\n\\n# Approach\\n\\nThe approach is to first check if the input array can be arranged in the given rows and columns. Then, we use a flag to keep track of whether we are currently traversing the array from up to down or from down to up. We then slice the input array based on the current row count, and append each slice to a temporary array. Finally, we transpose the temporary array to get the snail pattern.\\n\\n\\n# Complexity\\n- Time complexity: The time complexity of the code is `O(N^2)`, where N is the size of the input array.\\n- Space complexity: The space complexity of the code is `O(N^2)`, where N is the size of the input array.\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\n\\n// A function to transpose a matrix\\nfunction transpose(matrix) {\\n  // Map each column to an array of rows\\n  return matrix[0].map((col, c) => {\\n    // Map each row to the element in the current column\\n    let t = matrix.map((row, r) => matrix[r][c]);\\n    // Remove any trailing undefined values\\n    if (t[t.length-1] == undefined) t.pop()\\n    return t\\n  });\\n}\\n\\n// Define a new function to return a 2D array in a \"snail\" pattern\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let ret = [];\\n    // Check if the input array can be arranged in the given rows and columns\\n    if (rowsCount * colsCount !== this.length) return ret;\\n    let fg = [];\\n    let up = false;\\n    let down = true;\\n    // Use a flag to keep track of whether we are currently traversing the array from up to down or from down to up\\n    for (let i=0 ; i <this.length;){\\n       if (down){\\n         // Slice the input array based on the current row count, and append each slice to a temporary array\\n         j=i+rowsCount\\n         let t = this.slice(i,j);\\n         if (t[t.length-1]==null) t.pop()\\n         fg.push(t)\\n         i+=rowsCount\\n         down = false\\n         up = true\\n       }\\n       if(up){\\n         // Slice the input array based on the current row count, reverse the slice, and append it to a temporary array\\n         j=i+rowsCount\\n         let t = this.slice(i,j);\\n         if (t[t.length-1]==null) t.pop()\\n         fg.push(t.reverse())\\n         i+=rowsCount\\n         up=false\\n         down =true\\n       }\\n    }\\n    // Transpose the temporary array to get the snail pattern\\n    return transpose(fg)\\n}\\n\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\n\\n// A function to transpose a matrix\\nfunction transpose(matrix) {\\n  // Map each column to an array of rows\\n  return matrix[0].map((col, c) => {\\n    // Map each row to the element in the current column\\n    let t = matrix.map((row, r) => matrix[r][c]);\\n    // Remove any trailing undefined values\\n    if (t[t.length-1] == undefined) t.pop()\\n    return t\\n  });\\n}\\n\\n// Define a new function to return a 2D array in a \"snail\" pattern\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let ret = [];\\n    // Check if the input array can be arranged in the given rows and columns\\n    if (rowsCount * colsCount !== this.length) return ret;\\n    let fg = [];\\n    let up = false;\\n    let down = true;\\n    // Use a flag to keep track of whether we are currently traversing the array from up to down or from down to up\\n    for (let i=0 ; i <this.length;){\\n       if (down){\\n         // Slice the input array based on the current row count, and append each slice to a temporary array\\n         j=i+rowsCount\\n         let t = this.slice(i,j);\\n         if (t[t.length-1]==null) t.pop()\\n         fg.push(t)\\n         i+=rowsCount\\n         down = false\\n         up = true\\n       }\\n       if(up){\\n         // Slice the input array based on the current row count, reverse the slice, and append it to a temporary array\\n         j=i+rowsCount\\n         let t = this.slice(i,j);\\n         if (t[t.length-1]==null) t.pop()\\n         fg.push(t.reverse())\\n         i+=rowsCount\\n         up=false\\n         down =true\\n       }\\n    }\\n    // Transpose the temporary array to get the snail pattern\\n    return transpose(fg)\\n}\\n\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501423,
                "title": "ts-2-pointer-approach-230ms-63-6mb",
                "content": "This is a funny one that we  can solve multiple ways.\\n\\nOur first approach will be to prepopulate a matrix `res` with the proper size and then go to write in it with a few support variables:\\n* `goingDown` is a boolean flag initially set to `true` that will tell us how to write in `res`;\\n* `x` and `y` are our pointers to where to write in `res`, initially both set to `0`.\\n\\nWe will then loop through each number `n` in `this`, and:\\n* write `n` in `res[y][x]`;\\n* update our coordinates, depending on the direction - if we are `goingDown`, then we will:\\n    * increase `y` by `1`;\\n    * check if we went out of boundaries (ie: `y == rows`) and, if so:\\n        * decrease `y` by `1`;\\n        * increase the column pointer `x` by `1`;\\n        * flag `goingDown` to `false`;\\n* otherwise, we will:\\n    * decrease `y` by `1`;\\n    * check if we went out of boundaries (ie: `y < 0`) and, if so:\\n        * reset `y` to `0`;\\n        * increase the column pointer `x` by `1`;\\n        * flag `goingDown` to `true`.\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$ (for the new array, constant otherwise)\\n\\n# Code\\n```ts\\nArray.prototype.snail = function(rows: number, cols: number): number[][] {\\n    // base case: wrong inputs\\n    if (rows * cols !== this.length) return [];\\n    // support variables\\n    const res = Array.from({length: rows}, () => Array.from({length: cols}) as number[]);\\n    let goingDown = true, x = 0, y = 0;\\n    // populating res\\n    for (const n of this) {\\n      res[y][x] = n;\\n      // updating the pointers\\n      if (goingDown) {\\n        y++;\\n        // end of the line\\n        if (y === rows) y--, x++, goingDown = false;\\n      }\\n      else  {\\n        y--;\\n        // end of the line\\n        if (y < 0) y = 0, x++, goingDown = true;\\n      }\\n    }\\n    return res;\\n}\\n```\\n\\nA funnier version can be built populating it row by row.\\n\\nLet\\'s check the picture accompanying the first example:\\n![image.png](https://assets.leetcode.com/users/images/533867f8-a29b-4ead-947c-b4308c31acf0_1683561637.7205722.png)\\n\\n\\nFor the first row, we can see that we will be inserting the indexes `0` and `9`, then `10` and `19`; second row is `1` and `8`, then `11` and `18`, and so on; more in general, the first two indexes match this pattern:\\n\\n```cpp\\n0 9 == y (rows * 2 - 1 - y) // with y == 0\\n1 8 == y (rows * 2 - 1 - y) // with y == 1\\n2 7 == y (rows * 2 - 1 - y) // with y == 2\\n3 6 == y (rows * 2 - 1 - y) // with y == 3\\n4 5 == y (rows * 2 - 1 - y) // with y == 4\\n```\\n\\nAnd the rest is just a `step` equals to twice the value of `rows` apart.\\n\\nWith that in mind, we can code a version that does will populate the rows like that (we just need an extra check to ensure that the second index for each passage is just not out of loop):\\n\\n```ts\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rows: number, cols: number): number[][] {\\n    // base case: wrong inputs\\n    if (rows * cols !== this.length) return [];\\n    // support variables\\n    const res = [];\\n    let step = rows << 1, x = 0, y = 0, len = this.length;\\n    // populating res\\n    while (y < rows) {\\n      // populating the current row\\n      const row = [];\\n      for (let i = y, j = step - y - 1; i < len; i += step, j += step) {\\n        row.push(this[i]);\\n        if (j < len) row.push(this[j]);\\n      }\\n      res.push(row);\\n      // next row\\n      y++;\\n    }\\n    return res;\\n}\\n```\\n\\nEven better version with preallocated sizes for both `res` and `row`:\\n\\n```ts\\nArray.prototype.snail = function(rows: number, cols: number): number[][] {\\n    // base case: wrong inputs\\n    if (rows * cols !== this.length) return [];\\n    // support variables\\n    const res = Array(rows);\\n    let step = rows << 1, x = 0, y = 0, len = this.length;\\n    // populating res\\n    while (y < rows) {\\n      // populating the current row\\n      const row = Array(cols);\\n      for (let i = y, j = step - y - 1, w = 0; i < len; i += step, j += step) {\\n        row[w++] = this[i];\\n        if (j < len) row[w++] = this[j];\\n      }\\n      res[y] = row;\\n      // next row\\n      y++;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Matrix"
                ],
                "code": "```ts\\nArray.prototype.snail = function(rows: number, cols: number): number[][] {\\n    // base case: wrong inputs\\n    if (rows * cols !== this.length) return [];\\n    // support variables\\n    const res = Array.from({length: rows}, () => Array.from({length: cols}) as number[]);\\n    let goingDown = true, x = 0, y = 0;\\n    // populating res\\n    for (const n of this) {\\n      res[y][x] = n;\\n      // updating the pointers\\n      if (goingDown) {\\n        y++;\\n        // end of the line\\n        if (y === rows) y--, x++, goingDown = false;\\n      }\\n      else  {\\n        y--;\\n        // end of the line\\n        if (y < 0) y = 0, x++, goingDown = true;\\n      }\\n    }\\n    return res;\\n}\\n```\n```cpp\\n0 9 == y (rows * 2 - 1 - y) // with y == 0\\n1 8 == y (rows * 2 - 1 - y) // with y == 1\\n2 7 == y (rows * 2 - 1 - y) // with y == 2\\n3 6 == y (rows * 2 - 1 - y) // with y == 3\\n4 5 == y (rows * 2 - 1 - y) // with y == 4\\n```\n```ts\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rows: number, cols: number): number[][] {\\n    // base case: wrong inputs\\n    if (rows * cols !== this.length) return [];\\n    // support variables\\n    const res = [];\\n    let step = rows << 1, x = 0, y = 0, len = this.length;\\n    // populating res\\n    while (y < rows) {\\n      // populating the current row\\n      const row = [];\\n      for (let i = y, j = step - y - 1; i < len; i += step, j += step) {\\n        row.push(this[i]);\\n        if (j < len) row.push(this[j]);\\n      }\\n      res.push(row);\\n      // next row\\n      y++;\\n    }\\n    return res;\\n}\\n```\n```ts\\nArray.prototype.snail = function(rows: number, cols: number): number[][] {\\n    // base case: wrong inputs\\n    if (rows * cols !== this.length) return [];\\n    // support variables\\n    const res = Array(rows);\\n    let step = rows << 1, x = 0, y = 0, len = this.length;\\n    // populating res\\n    while (y < rows) {\\n      // populating the current row\\n      const row = Array(cols);\\n      for (let i = y, j = step - y - 1, w = 0; i < len; i += step, j += step) {\\n        row[w++] = this[i];\\n        if (j < len) row[w++] = this[j];\\n      }\\n      res[y] = row;\\n      // next row\\n      y++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3500748,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(this.length != rowsCount*colsCount){\\n        return [];\\n    }else{\\n        let newArr = [];\\n        for(let i =0; i < rowsCount; i++){\\n            let rowArr = [];\\n            for(let j =0; j < colsCount; j++){\\n                rowArr.push(j%2 == 0 ? \\n                this[(rowsCount*j)+i] : \\n                this[(rowsCount*(j+1))-1-i]\\n                );\\n            }\\n            newArr.push(rowArr);\\n        }\\n        return newArr;\\n    }\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(this.length != rowsCount*colsCount){\\n        return [];\\n    }else{\\n        let newArr = [];\\n        for(let i =0; i < rowsCount; i++){\\n            let rowArr = [];\\n            for(let j =0; j < colsCount; j++){\\n                rowArr.push(j%2 == 0 ? \\n                this[(rowsCount*j)+i] : \\n                this[(rowsCount*(j+1))-1-i]\\n                );\\n            }\\n            newArr.push(rowArr);\\n        }\\n        return newArr;\\n    }\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494090,
                "title": "ts-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if (rowsCount * colsCount != this.length) return []\\n    \\n    let down = false\\n    const arr = new Array(rowsCount).fill([]).map(() => [])\\n    // for (let [i, el] of this.entries()) {\\n    for (let i=0; i<this.length; i++) {\\n        if (i % rowsCount == 0)\\n            down = !down\\n\\n        if (down) {\\n            arr[i % rowsCount].push(this[i])\\n        } else {\\n            arr[rowsCount - 1 - (i % rowsCount)].push(this[i])\\n        }\\n    }\\n    return arr\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if (rowsCount * colsCount != this.length) return []\\n    \\n    let down = false\\n    const arr = new Array(rowsCount).fill([]).map(() => [])\\n    // for (let [i, el] of this.entries()) {\\n    for (let i=0; i<this.length; i++) {\\n        if (i % rowsCount == 0)\\n            down = !down\\n\\n        if (down) {\\n            arr[i % rowsCount].push(this[i])\\n        } else {\\n            arr[rowsCount - 1 - (i % rowsCount)].push(this[i])\\n        }\\n    }\\n    return arr\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493112,
                "title": "easy-to-understand-top-down-thinking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFill the item to the result\\'s array by the order provided by the question.\\nIf the column number is even, use the normal order as position.\\nIf the column number is odd, use the reverse order of row as position.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n  if (this.length !== rowsCount * colsCount) {\\n    return []\\n  }\\n\\n  const res = new Array(rowsCount).fill(0).map(() => [])\\n\\n  for (let col = 0; col < colsCount; col++) {\\n    for (let row = 0; row < rowsCount; row++) {\\n      const pos = rowsCount * col + (col % 2 === 0 ? row : (rowsCount - row - 1))\\n      res[row][col] = this[pos]\\n    }\\n  }\\n\\n  return res\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n  if (this.length !== rowsCount * colsCount) {\\n    return []\\n  }\\n\\n  const res = new Array(rowsCount).fill(0).map(() => [])\\n\\n  for (let col = 0; col < colsCount; col++) {\\n    for (let row = 0; row < rowsCount; row++) {\\n      const pos = rowsCount * col + (col % 2 === 0 ? row : (rowsCount - row - 1))\\n      res[row][col] = this[pos]\\n    }\\n  }\\n\\n  return res\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3491105,
                "title": "javascript-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(this.length != rowsCount * colsCount) return [];\\n    let res = Array(rowsCount).fill().map(()=>[]);\\n    for(let i = 0; i < this.length; i++){\\n        const j = Math.floor(i/rowsCount);\\n        if(j%2 == 0){\\n            res[i%rowsCount][j] = this[i];\\n        }else{\\n            res[rowsCount -i%rowsCount - 1][j] = this[i];\\n        }\\n    }\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(this.length != rowsCount * colsCount) return [];\\n    let res = Array(rowsCount).fill().map(()=>[]);\\n    for(let i = 0; i < this.length; i++){\\n        const j = Math.floor(i/rowsCount);\\n        if(j%2 == 0){\\n            res[i%rowsCount][j] = this[i];\\n        }else{\\n            res[rowsCount -i%rowsCount - 1][j] = this[i];\\n        }\\n    }\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3488838,
                "title": "simple-short-easy-back-and-forth",
                "content": "Found out the equivalent of Python\\'s \\'range\\' function is Array.from which allows you to create the 3D grid in one line.\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if ((rowsCount*colsCount) != this.length) {\\n        return [];\\n    }\\n    let [cr,cc] = [0,0];\\n    const out = Array.from({length:rowsCount}, () => Array.from({length: colsCount},() => 0));\\n    let turn = 0;\\n    let idx = 0;\\n    while (cc < colsCount) {\\n        if ((cr < rowsCount) && (cr >= 0)) {\\n            out[cr][cc] = this[idx];\\n            cr = (turn === 0) ? cr+1:cr-1;\\n            idx += 1;\\n        }\\n        else {\\n            cc += 1\\n            cr = (turn === 0) ? rowsCount-1: 0;\\n            turn = 1-turn;\\n        }\\n    }\\n    return out;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if ((rowsCount*colsCount) != this.length) {\\n        return [];\\n    }\\n    let [cr,cc] = [0,0];\\n    const out = Array.from({length:rowsCount}, () => Array.from({length: colsCount},() => 0));\\n    let turn = 0;\\n    let idx = 0;\\n    while (cc < colsCount) {\\n        if ((cr < rowsCount) && (cr >= 0)) {\\n            out[cr][cc] = this[idx];\\n            cr = (turn === 0) ? cr+1:cr-1;\\n            idx += 1;\\n        }\\n        else {\\n            cc += 1\\n            cr = (turn === 0) ? rowsCount-1: 0;\\n            turn = 1-turn;\\n        }\\n    }\\n    return out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487188,
                "title": "use-modulo-and-reduce",
                "content": "# Intuition\\n\\nUnlike other solutions, no need to iterate extra to fill the array with zeroes or create nested arrays. Use `??=`. For direction (up or down), just use the column number, where even column means going from top to bottom.\\n\\n`(result[row] ??= [])[col] = item;` is the same as:\\n\\n```javascript\\nresult[row] = result[row] ?? [];\\nresult[row][col] = item;\\n```\\n\\n# Code\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const length = this.length;\\n\\n    if (rowsCount * colsCount !== length) {\\n        return [];\\n    }\\n\\n    return this.reduce((result, item, i) => {\\n        const col = Math.floor(i / rowsCount);\\n        const row = col % 2 === 0\\n            ? i % rowsCount // go top-down\\n            : (rowsCount - 1) - (i % rowsCount); // go bottom-up\\n        (result[row] ??= [])[col] = item;\\n        return result;\\n    }, []);\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nresult[row] = result[row] ?? [];\\nresult[row][col] = item;\\n```\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const length = this.length;\\n\\n    if (rowsCount * colsCount !== length) {\\n        return [];\\n    }\\n\\n    return this.reduce((result, item, i) => {\\n        const col = Math.floor(i / rowsCount);\\n        const row = col % 2 === 0\\n            ? i % rowsCount // go top-down\\n            : (rowsCount - 1) - (i % rowsCount); // go bottom-up\\n        (result[row] ??= [])[col] = item;\\n        return result;\\n    }, []);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484065,
                "title": "easy-solution-using-array-transpose",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you look clearly into the pattern, lets say if the rowsCount is 5 , then you see first column is first five elements, secodn column is next five elements in reverse, third column is next five elements, fourth column is next five elements in reverse;\\nso if original = [1,2,3,4,5 , 6,7,8,9,10 , 11,12,13,14,15,  16,17,18,19,20]\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou need to create array of arrays and first entry is array of first five elements in original array, next entry is next five elemnets in original array in reverse , and third entry is  next five elements in original array\\n\\nso temp = [[1,2,3,4,5],[10,9,8,7,6], [11,12,13,14,15], [20,19,18,17,16]]\\n\\nNow if we do the transpose of this array, then we will get the reult:\\nresult = transpose(temp)\\nresult = [[1,10,11,20],[2,9,12,19],[3,8,13,18],[4,7,14,17],[5,6,15,16]]\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) n is length of original array, because we are processing each element once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) , where n is size of original array; because the intermediate and result matrices have number of elements equal to the original size of array\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    // iterate over array and store result in temp arr\\n    // if temp.length ==5 -> clockwise->push in result \\n    // anticlockwise --> push reverse in result\\n    // finally do transpose of result\\n\\n    if(rowsCount * colsCount !== this.length){\\n        return []\\n    }\\n    \\n    const result = [];\\n\\n    let clockwise = true;\\n    let temp = [];\\n\\n    this.forEach((item)=>{\\n        if(temp.length< rowsCount){\\n                temp.push(item);\\n        }\\n        if(temp.length === rowsCount){\\n            // full -> assign\\n            if(clockwise){\\n               \\n                clockwise = false;\\n            }else{\\n               temp.reverse();\\n                clockwise = true\\n            }\\n             result.push([...temp]);\\n             temp=[]\\n        }\\n    });\\n\\n\\n\\n \\n    // here we calculate the transpose\\n     let transpose = []\\n        for(let j=0; j< result[0].length; j++){\\n            let t = []\\n            for(let i=0; i< result.length; i++){\\n                t.push(result[i][j]);\\n        }\\n        transpose.push([...t]);\\n    }\\n\\n    return transpose;\\n\\n    \\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    // iterate over array and store result in temp arr\\n    // if temp.length ==5 -> clockwise->push in result \\n    // anticlockwise --> push reverse in result\\n    // finally do transpose of result\\n\\n    if(rowsCount * colsCount !== this.length){\\n        return []\\n    }\\n    \\n    const result = [];\\n\\n    let clockwise = true;\\n    let temp = [];\\n\\n    this.forEach((item)=>{\\n        if(temp.length< rowsCount){\\n                temp.push(item);\\n        }\\n        if(temp.length === rowsCount){\\n            // full -> assign\\n            if(clockwise){\\n               \\n                clockwise = false;\\n            }else{\\n               temp.reverse();\\n                clockwise = true\\n            }\\n             result.push([...temp]);\\n             temp=[]\\n        }\\n    });\\n\\n\\n\\n \\n    // here we calculate the transpose\\n     let transpose = []\\n        for(let j=0; j< result[0].length; j++){\\n            let t = []\\n            for(let i=0; i< result.length; i++){\\n                t.push(result[i][j]);\\n        }\\n        transpose.push([...t]);\\n    }\\n\\n    return transpose;\\n\\n    \\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483062,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const resultArr = []\\n\\n    if(this.length !== rowsCount * colsCount){\\n        return []\\n    }\\n\\n    for(let i = 0; i < rowsCount; i++){\\n        const tmpArr = []\\n\\n        for(let j = 0; j < colsCount; j++){\\n            let isHonestCol = j % 2 === 0\\n            if(isHonestCol){\\n                 tmpArr.push(this[i+rowsCount*j]) \\n            } else {\\n               const col =  Math.min(j+1,colsCount)\\n               tmpArr.push(this[rowsCount * col - 1 - i]) \\n            }\\n           \\n        }\\n\\n        resultArr.push(tmpArr) \\n    }\\n    return resultArr\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const resultArr = []\\n\\n    if(this.length !== rowsCount * colsCount){\\n        return []\\n    }\\n\\n    for(let i = 0; i < rowsCount; i++){\\n        const tmpArr = []\\n\\n        for(let j = 0; j < colsCount; j++){\\n            let isHonestCol = j % 2 === 0\\n            if(isHonestCol){\\n                 tmpArr.push(this[i+rowsCount*j]) \\n            } else {\\n               const col =  Math.min(j+1,colsCount)\\n               tmpArr.push(this[rowsCount * col - 1 - i]) \\n            }\\n           \\n        }\\n\\n        resultArr.push(tmpArr) \\n    }\\n    return resultArr\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477570,
                "title": "easy-explanation-optimized-solution-javascript",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n$$n = Array.length$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let n = this.length;\\n\\n    if (rowsCount * colsCount !== n)\\n        return [];\\n\\n    let mat = [];\\n    // create mat with 0\\'s..\\n    for (i=0; i < rowsCount; i++){\\n        let row = [];\\n        for (j=0; j < colsCount; j++) {\\n            row.push(0);\\n        }\\n\\n        mat.push(row);\\n    }\\n\\n    let ind = 0,\\n        dir = -1;\\n    while (ind < n) {\\n        for (col=0; col < colsCount; col++) {\\n            // check direction..\\n            if (dir == -1) {\\n                // go top to bottom..\\n                for (row=0; row < rowsCount; row++) {\\n                    mat[row][col] = this[ind];\\n                    ind++;\\n                }\\n\\n                // change dir..\\n                dir = 1;\\n            }\\n\\n            else {\\n                // go bottom to top..\\n                for (row = rowsCount - 1 ; row >= 0; row--) {\\n                    mat[row][col] = this[ind];\\n                    ind++;\\n                }\\n\\n                dir = -1;\\n            }\\n        } \\n    }\\n\\n    return mat;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let n = this.length;\\n\\n    if (rowsCount * colsCount !== n)\\n        return [];\\n\\n    let mat = [];\\n    // create mat with 0\\'s..\\n    for (i=0; i < rowsCount; i++){\\n        let row = [];\\n        for (j=0; j < colsCount; j++) {\\n            row.push(0);\\n        }\\n\\n        mat.push(row);\\n    }\\n\\n    let ind = 0,\\n        dir = -1;\\n    while (ind < n) {\\n        for (col=0; col < colsCount; col++) {\\n            // check direction..\\n            if (dir == -1) {\\n                // go top to bottom..\\n                for (row=0; row < rowsCount; row++) {\\n                    mat[row][col] = this[ind];\\n                    ind++;\\n                }\\n\\n                // change dir..\\n                dir = 1;\\n            }\\n\\n            else {\\n                // go bottom to top..\\n                for (row = rowsCount - 1 ; row >= 0; row--) {\\n                    mat[row][col] = this[ind];\\n                    ind++;\\n                }\\n\\n                dir = -1;\\n            }\\n        } \\n    }\\n\\n    return mat;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477494,
                "title": "optimized-solution-easy-explanation-javascript",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n$$n = Array.length$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let n = this.length;\\n\\n    if (rowsCount * colsCount !== n)\\n        return [];\\n\\n    let mat = [];\\n    // create mat with 0\\'s..\\n    for (i=0; i < rowsCount; i++){\\n        let row = [];\\n        for (j=0; j < colsCount; j++) {\\n            row.push(0);\\n        }\\n\\n        mat.push(row);\\n    }\\n\\n    let ind = 0,\\n        dir = -1;\\n    while (ind < n) {\\n        for (col=0; col < colsCount; col++) {\\n            // check direction..\\n            if (dir == -1) {\\n                // go top to bottom..\\n                for (row=0; row < rowsCount; row++) {\\n                    mat[row][col] = this[ind];\\n                    ind++;\\n                }\\n\\n                // change dir..\\n                dir = 1;\\n            }\\n\\n            else {\\n                // go bottom to top..\\n                for (row = rowsCount - 1 ; row >= 0; row--) {\\n                    mat[row][col] = this[ind];\\n                    ind++;\\n                }\\n\\n                dir = -1;\\n            }\\n        } \\n    }\\n\\n    return mat;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let n = this.length;\\n\\n    if (rowsCount * colsCount !== n)\\n        return [];\\n\\n    let mat = [];\\n    // create mat with 0\\'s..\\n    for (i=0; i < rowsCount; i++){\\n        let row = [];\\n        for (j=0; j < colsCount; j++) {\\n            row.push(0);\\n        }\\n\\n        mat.push(row);\\n    }\\n\\n    let ind = 0,\\n        dir = -1;\\n    while (ind < n) {\\n        for (col=0; col < colsCount; col++) {\\n            // check direction..\\n            if (dir == -1) {\\n                // go top to bottom..\\n                for (row=0; row < rowsCount; row++) {\\n                    mat[row][col] = this[ind];\\n                    ind++;\\n                }\\n\\n                // change dir..\\n                dir = 1;\\n            }\\n\\n            else {\\n                // go bottom to top..\\n                for (row = rowsCount - 1 ; row >= 0; row--) {\\n                    mat[row][col] = this[ind];\\n                    ind++;\\n                }\\n\\n                dir = -1;\\n            }\\n        } \\n    }\\n\\n    return mat;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3473636,
                "title": "simple-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n\\n    const result = [];\\n    for (let row = 0; row < rowsCount; ++row) {\\n        result.push([]);\\n    }\\n\\n    let rowIndex = 0;\\n    for (let i = 0; i < this.length;) {\\n\\n        for (; rowIndex < rowsCount; i++) {\\n            result[rowIndex++].push(this[i]);\\n        }\\n\\n        for (; rowIndex > 0 && i < this.length; i++) {\\n            result[--rowIndex].push(this[i]);\\n        }\\n\\n    }\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n\\n    const result = [];\\n    for (let row = 0; row < rowsCount; ++row) {\\n        result.push([]);\\n    }\\n\\n    let rowIndex = 0;\\n    for (let i = 0; i < this.length;) {\\n\\n        for (; rowIndex < rowsCount; i++) {\\n            result[rowIndex++].push(this[i]);\\n        }\\n\\n        for (; rowIndex > 0 && i < this.length; i++) {\\n            result[--rowIndex].push(this[i]);\\n        }\\n\\n    }\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3471392,
                "title": "snail-array-fast",
                "content": "# Intuition\\nTransformation of the matrix depends on two crucial things. \\n1. The current array length being the same length as the proposed rows * columns matrix total length.\\n2. The zig zag up down of the traversal until all the elements are used. Whether it ends on zig or a zag should not matter as long as condition 1 is filled, condition 2 should be a pattern until the length of the array is exhausted.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ elements in the original array\\n\\n- Space complexity:\\n$$O(n * m)$$ rows and columns of the transformed snail array\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rc, cc) {\\n    // transforms 1d array into 2d matrix in snail format\\n    let snailArray = new Array();    \\n    if (this.length != (rc*cc)) return snailArray;\\n    \\n    let arrayIndex = 0;\\n    let colCount = 0;\\n    \\n    while (colCount < cc && arrayIndex < this.length) {   \\n        for (let r = 0; r < rc; r++) {s\\n            if (snailArray[r] === undefined) {snailArray[r] = new Array();}\\n            if (arrayIndex < this.length) {\\n                snailArray[r].push(this[arrayIndex++]);\\n            }\\n        }\\n        colCount++;\\n        if (colCount < cc) {\\n            for (let r = rc-1; r >= 0; r--) {\\n                if (arrayIndex < this.length) {\\n                    snailArray[r].push(this[arrayIndex++]);\\n                }\\n            }\\n            colCount++;\\n        }\\n    }\\n    return snailArray;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rc, cc) {\\n    // transforms 1d array into 2d matrix in snail format\\n    let snailArray = new Array();    \\n    if (this.length != (rc*cc)) return snailArray;\\n    \\n    let arrayIndex = 0;\\n    let colCount = 0;\\n    \\n    while (colCount < cc && arrayIndex < this.length) {   \\n        for (let r = 0; r < rc; r++) {s\\n            if (snailArray[r] === undefined) {snailArray[r] = new Array();}\\n            if (arrayIndex < this.length) {\\n                snailArray[r].push(this[arrayIndex++]);\\n            }\\n        }\\n        colCount++;\\n        if (colCount < cc) {\\n            for (let r = rc-1; r >= 0; r--) {\\n                if (arrayIndex < this.length) {\\n                    snailArray[r].push(this[arrayIndex++]);\\n                }\\n            }\\n            colCount++;\\n        }\\n    }\\n    return snailArray;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3469498,
                "title": "ts-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if(rowsCount * colsCount !== this.length) return []\\n\\n    const res = (new Array(rowsCount)).fill([]).map(() => (new Array(colsCount).fill(0)))\\n\\n    let i = 0, j = 0\\n    let order = 1\\n\\n    this.forEach(num => {\\n      res[i][j] = num\\n      i += order\\n      if(i === rowsCount || i === -1){\\n        j++\\n        order = -order\\n        i += order\\n      }\\n    })\\n    return res\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if(rowsCount * colsCount !== this.length) return []\\n\\n    const res = (new Array(rowsCount)).fill([]).map(() => (new Array(colsCount).fill(0)))\\n\\n    let i = 0, j = 0\\n    let order = 1\\n\\n    this.forEach(num => {\\n      res[i][j] = num\\n      i += order\\n      if(i === rowsCount || i === -1){\\n        j++\\n        order = -order\\n        i += order\\n      }\\n    })\\n    return res\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466254,
                "title": "efficient-conversion-of-flat-array-to-snail-matrix",
                "content": "# Intuition\\n\\nGiven a one-dimensional array, the goal is to transform it into a two-dimensional \"snail\" array with a specified number of rows and columns. We can achieve this by iterating through the elements of the input array and placing them in the new two-dimensional array in a zigzag pattern, where elements in even-numbered columns are placed from top to bottom and elements in odd-numbered columns are placed from bottom to top.\\n\\n# Approach\\nCheck if the product of the specified rows and columns matches the length of the input array. If not, return an empty array.\\nCreate a new two-dimensional array with the specified number of rows and columns.\\nIterate through the elements of the input array and place them in the two-dimensional array according to the snail pattern:\\nIf the current column is even, place the element from top to bottom.\\nIf the current column is odd, place the element from bottom to top.\\nReturn the resulting two-dimensional array.\\n\\n# Complexity\\n- Time complexity:\\nO(rowsCount\\u2217colsCount)\\n\\n- Space complexity:\\n O(rowsCount\\u2217colsCount).\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) return [];\\n\\n    const arr = Array.from({ length: rowsCount }, (_, i) =>\\n        Array.from({ length: colsCount }, (_, j) =>\\n            (j % 2 === 0 ? this[rowsCount * j + i] : this[rowsCount * (j + 1) - 1 - i])\\n        )\\n    );\\n\\n    return arr;\\n};\\n\\n/**\\n * const arr = [1, 2, 3, 4];\\n * arr.snail(1, 4); // [[1, 2, 3, 4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) return [];\\n\\n    const arr = Array.from({ length: rowsCount }, (_, i) =>\\n        Array.from({ length: colsCount }, (_, j) =>\\n            (j % 2 === 0 ? this[rowsCount * j + i] : this[rowsCount * (j + 1) - 1 - i])\\n        )\\n    );\\n\\n    return arr;\\n};\\n\\n/**\\n * const arr = [1, 2, 3, 4];\\n * arr.snail(1, 4); // [[1, 2, 3, 4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3461646,
                "title": "javascript-with-matrix-transpose",
                "content": "# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n   if (rowsCount * colsCount !== this.length) return [];\\n\\n   let arr = [];\\n\\n   for (let i=0; i<colsCount; i++) {\\n      let line = this.slice(i*rowsCount,i*rowsCount+rowsCount);\\n      if (i%2==1) line = line.reverse()\\n      arr.push(line)\\n   }\\n   \\n   return tranpose(arr)\\n}\\n\\nvar tranpose = (matrix) => _.zip(...matrix);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n   if (rowsCount * colsCount !== this.length) return [];\\n\\n   let arr = [];\\n\\n   for (let i=0; i<colsCount; i++) {\\n      let line = this.slice(i*rowsCount,i*rowsCount+rowsCount);\\n      if (i%2==1) line = line.reverse()\\n      arr.push(line)\\n   }\\n   \\n   return tranpose(arr)\\n}\\n\\nvar tranpose = (matrix) => _.zip(...matrix);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3460602,
                "title": "javascript-very-simple-easy-to-understand",
                "content": "\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rows, cols) {\\n    if (rows * cols !== this.length) return [];\\n\\n    let res = [], counter = 0;\\n    for (let i = 0; i < rows; i++) {\\n        res.push([]);\\n    }\\n\\n    for (let j = 0; j < cols; j++) {\\n        for (let i = 0; i < rows; i++) {\\n            res[j % 2 === 0 ? i : rows - i - 1][j] = this[counter++];\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rows, cols) {\\n    if (rows * cols !== this.length) return [];\\n\\n    let res = [], counter = 0;\\n    for (let i = 0; i < rows; i++) {\\n        res.push([]);\\n    }\\n\\n    for (let j = 0; j < cols; j++) {\\n        for (let i = 0; i < rows; i++) {\\n            res[j % 2 === 0 ? i : rows - i - 1][j] = this[counter++];\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459202,
                "title": "let-s-get-functional",
                "content": "```js\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n    return Array.from({length: rowsCount}, (_, row) =>\\n        Array.from({length: colsCount}, (_, col) => {\\n            const i = col * rowsCount;\\n            const j = col & 1 ? rowsCount - row - 1 : row;\\n            return this[i + j];\\n        })\\n    );\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n    return Array.from({length: rowsCount}, (_, row) =>\\n        Array.from({length: colsCount}, (_, col) => {\\n            const i = col * rowsCount;\\n            const j = col & 1 ? rowsCount - row - 1 : row;\\n            return this[i + j];\\n        })\\n    );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453215,
                "title": "simple-fast-and-memory-efficient",
                "content": "# Intuition\\nUse two different counters for populating the arrays, an incrementing for columns with even index and decrementing for the ones with odd index. \\n\\n# Approach\\nFirst check if the original array would fit in the 2D array transformation. Then go from the left to the right in the matrix, while inserting the values from the original array. Switch the row access direction by checking *column_index % 2 === 0*. Also don\\'t forget to initialize the rows when creating the values from the first column.\\n\\n# Complexity\\n- Time complexity:\\n$$O(rowsCount * colsCount)$$\\n\\n- Space complexity:\\nUses additional space of the size $$O(rowsCount * colsCount)$$ for the transformed matrix. The helper index uses only constant space.\\n\\n# Code\\n```\\n/**\\n - transform the 1D array into a 2D array\\n - rowsCount * colsCount !== nums.length should return an empty array\\n\\n - Return if rowsCount * colsCount !== nums.length with [] \\n - Create 2D array as a datastructure\\n - Start populating from i=0, j=0 -> rows, columns\\n - from 0 to rowsCount add elements from the original array, keeping the index\\n - for even j go from i= 0 to rowsCount -1\\n - for odd j go from i=rowsCount - 1 to 0\\n - then increase the j\\n */\\n\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length !== rowsCount * colsCount) {\\n        return [];\\n    }\\n\\n    let transformedArray = []\\n\\n    let originalIdx = 0;\\n    \\n    for (let j = 0; j < colsCount; j++) {\\n\\n        if (j % 2 === 0) {\\n            for (let i = 0; i < rowsCount; i++) {\\n                if (j === 0) {\\n                    transformedArray.push([this[originalIdx]])\\n                } else {\\n                    transformedArray[i].push(this[originalIdx])\\n                }\\n                originalIdx++;\\n            }\\n        } else {\\n            for (let i = rowsCount - 1; i >= 0; i--) {\\n                transformedArray[i].push(this[originalIdx])\\n                originalIdx++;\\n            }\\n        }\\n\\n    }\\n\\n    return transformedArray;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n - transform the 1D array into a 2D array\\n - rowsCount * colsCount !== nums.length should return an empty array\\n\\n - Return if rowsCount * colsCount !== nums.length with [] \\n - Create 2D array as a datastructure\\n - Start populating from i=0, j=0 -> rows, columns\\n - from 0 to rowsCount add elements from the original array, keeping the index\\n - for even j go from i= 0 to rowsCount -1\\n - for odd j go from i=rowsCount - 1 to 0\\n - then increase the j\\n */\\n\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length !== rowsCount * colsCount) {\\n        return [];\\n    }\\n\\n    let transformedArray = []\\n\\n    let originalIdx = 0;\\n    \\n    for (let j = 0; j < colsCount; j++) {\\n\\n        if (j % 2 === 0) {\\n            for (let i = 0; i < rowsCount; i++) {\\n                if (j === 0) {\\n                    transformedArray.push([this[originalIdx]])\\n                } else {\\n                    transformedArray[i].push(this[originalIdx])\\n                }\\n                originalIdx++;\\n            }\\n        } else {\\n            for (let i = rowsCount - 1; i >= 0; i--) {\\n                transformedArray[i].push(this[originalIdx])\\n                originalIdx++;\\n            }\\n        }\\n\\n    }\\n\\n    return transformedArray;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3452138,
                "title": "javascript-good-enough",
                "content": "``` JavaScript []\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const arr = [];\\n\\n    if(!this.length || rowsCount * colsCount != this.length){\\n        return arr;\\n    }\\n\\n    for(var i = 0; i < rowsCount; i++){\\n        const temp = [];\\n        for(var j = 0; j < colsCount; j++){\\n            if(j%2==0){\\n                temp.push(this[i+rowsCount*j]);\\n            }\\n            else{\\n                temp.push(this[rowsCount*(j+1)-(i+1)]);\\n            }\\n        }\\n\\n        arr.push(temp)\\n    }\\n\\n    return arr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JavaScript []\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const arr = [];\\n\\n    if(!this.length || rowsCount * colsCount != this.length){\\n        return arr;\\n    }\\n\\n    for(var i = 0; i < rowsCount; i++){\\n        const temp = [];\\n        for(var j = 0; j < colsCount; j++){\\n            if(j%2==0){\\n                temp.push(this[i+rowsCount*j]);\\n            }\\n            else{\\n                temp.push(this[rowsCount*(j+1)-(i+1)]);\\n            }\\n        }\\n\\n        arr.push(temp)\\n    }\\n\\n    return arr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450499,
                "title": "javascript-easy-to-understand",
                "content": "```\\nArray.prototype.snail = function (rows, cols) {\\n  if (rows * cols !== this.length) return [];\\n\\n  let res = new Array(rows).fill().map(() => []);\\n  let invert = false;\\n\\n  for (let i = 0; i < this.length; i++) {\\n    if (!invert) {\\n      res[i % rows].push(this[i]);\\n    } else {\\n      res[rows - (i % rows) - 1].push(this[i]);\\n    }\\n\\n    if (i % rows == rows - 1) {\\n      invert = !invert;\\n    }\\n  }\\n  \\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.snail = function (rows, cols) {\\n  if (rows * cols !== this.length) return [];\\n\\n  let res = new Array(rows).fill().map(() => []);\\n  let invert = false;\\n\\n  for (let i = 0; i < this.length; i++) {\\n    if (!invert) {\\n      res[i % rows].push(this[i]);\\n    } else {\\n      res[rows - (i % rows) - 1].push(this[i]);\\n    }\\n\\n    if (i % rows == rows - 1) {\\n      invert = !invert;\\n    }\\n  }\\n  \\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448731,
                "title": "python-simple-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount*colsCount == 0 || this.length != rowsCount*colsCount){\\n        return [];\\n    }\\n\\n    var res = [];\\n\\n    for (let i = 0; i < rowsCount; i++){\\n        res.push([]);\\n    }\\n\\n    for (let i = 0; i < this.length; i++){\\n        let col = i/rowsCount|0;\\n        let row = i%rowsCount;\\n\\n        if (col%2 == 1){\\n            row = rowsCount - row - 1;\\n        }\\n\\n        res[row].push(this[i]);\\n\\n    }\\n\\n    return res;\\n\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount*colsCount == 0 || this.length != rowsCount*colsCount){\\n        return [];\\n    }\\n\\n    var res = [];\\n\\n    for (let i = 0; i < rowsCount; i++){\\n        res.push([]);\\n    }\\n\\n    for (let i = 0; i < this.length; i++){\\n        let col = i/rowsCount|0;\\n        let row = i%rowsCount;\\n\\n        if (col%2 == 1){\\n            row = rowsCount - row - 1;\\n        }\\n\\n        res[row].push(this[i]);\\n\\n    }\\n\\n    return res;\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444708,
                "title": "single-loop-simplest-o-n-time-o-n-memory-98-solution",
                "content": "# Intuition\\nThis problem is a classic matrix unflattening question, with some slight twists. We are doing a column major traversal and also flipping between moving up or down each column based on where we finished the last one. There is also one extra check to ensure that \\'this\\' is an array with the correct length for rowsCount * colsCount.\\n\\n# Approach\\nI solved this question with very few lines of code and without using javascript array api\\'s that utilize callbacks. This is because I find this to be both an efficient way of solving these problems as well as developer friendly.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    ret = []\\n\\n    // if \\'this\\' is not the correct size, return an empty array\\n    if (this.length !== rowsCount * colsCount) return ret\\n\\n    for (let i = 0; i < rowsCount * colsCount; i += 1) {\\n        // if the column index is even, we traverse down the column\\n        // if the column index is odd, we traverse up the column\\n        // idx is the row index which we are modifying\\n        var idx = (Math.floor(i / rowsCount) % 2) == 0 ? (i % rowsCount) : (rowsCount - 1) - (i % rowsCount)\\n\\n        // mutate the \\'ret\\' array\\n        // check to make sure that there is an array at the current row\\n        // if so, modify the array, otherwise insert a new array with this[i] as the only element\\n        if (Array.isArray(ret[idx])) {\\n            ret[idx].push(this[i])\\n        } else {\\n            ret[idx] = [this[i]]\\n        }\\n    }\\n    return ret\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    ret = []\\n\\n    // if \\'this\\' is not the correct size, return an empty array\\n    if (this.length !== rowsCount * colsCount) return ret\\n\\n    for (let i = 0; i < rowsCount * colsCount; i += 1) {\\n        // if the column index is even, we traverse down the column\\n        // if the column index is odd, we traverse up the column\\n        // idx is the row index which we are modifying\\n        var idx = (Math.floor(i / rowsCount) % 2) == 0 ? (i % rowsCount) : (rowsCount - 1) - (i % rowsCount)\\n\\n        // mutate the \\'ret\\' array\\n        // check to make sure that there is an array at the current row\\n        // if so, modify the array, otherwise insert a new array with this[i] as the only element\\n        if (Array.isArray(ret[idx])) {\\n            ret[idx].push(this[i])\\n        } else {\\n            ret[idx] = [this[i]]\\n        }\\n    }\\n    return ret\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442010,
                "title": "using-alternate-up-down-approach",
                "content": "# Approach\\n  Filling values in 2D array alternately.\\n\\n# Complexity\\n- Time complexity: O(r*c)\\n\\n- Space complexity: O(r*c)\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n  if(rowsCount*colsCount !== this.length) return [];\\n    let arr = new Array(rowsCount).fill().map(_ => Array(colsCount).fill(0));\\n    \\n  let flag = true;\\n  let i = 0;\\n  for(let c = 0; c < colsCount; c++){\\n      if(flag === true){\\n        for(let r = 0; r < rowsCount; r++){\\n          arr[r][c] = this[i];\\n          i++;\\n        }\\n      }else{\\n        for(let r = rowsCount - 1; r >=0 ; r--){\\n          arr[r][c] = this[i];\\n          i++;\\n      }\\n    }\\n    flag = !flag;\\n  }\\n  return arr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n  if(rowsCount*colsCount !== this.length) return [];\\n    let arr = new Array(rowsCount).fill().map(_ => Array(colsCount).fill(0));\\n    \\n  let flag = true;\\n  let i = 0;\\n  for(let c = 0; c < colsCount; c++){\\n      if(flag === true){\\n        for(let r = 0; r < rowsCount; r++){\\n          arr[r][c] = this[i];\\n          i++;\\n        }\\n      }else{\\n        for(let r = rowsCount - 1; r >=0 ; r--){\\n          arr[r][c] = this[i];\\n          i++;\\n      }\\n    }\\n    flag = !flag;\\n  }\\n  return arr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439831,
                "title": "simple-js-solution-using-single-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n  if (rowsCount * colsCount !== this.length) {\\n    return [];\\n  }\\n  const res = [];\\n  for (let i = 0; i < rowsCount; i++) {\\n    res.push([]);\\n  }\\n  let i = 0;\\n  let bottom = true;\\n  for (const val of this) {\\n    res[i].push(val);\\n    if (bottom) {\\n      if (i === rowsCount - 1) {\\n        bottom = false;\\n      } else {\\n        i++;\\n      }\\n    } else { \\n      if (i === 0) {\\n        bottom = true;\\n      } else {\\n        i--;\\n      }\\n    }\\n  }\\n  return res;\\n};\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function (rowsCount, colsCount) {\\n  if (rowsCount * colsCount !== this.length) {\\n    return [];\\n  }\\n  const res = [];\\n  for (let i = 0; i < rowsCount; i++) {\\n    res.push([]);\\n  }\\n  let i = 0;\\n  let bottom = true;\\n  for (const val of this) {\\n    res[i].push(val);\\n    if (bottom) {\\n      if (i === rowsCount - 1) {\\n        bottom = false;\\n      } else {\\n        i++;\\n      }\\n    } else { \\n      if (i === 0) {\\n        bottom = true;\\n      } else {\\n        i--;\\n      }\\n    }\\n  }\\n  return res;\\n};\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438585,
                "title": "easy-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(p)$$ where p is the length of the array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ ,we don\\'t consider result array as we the question expects array\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let n = rowsCount * colsCount ;\\n    if(this.length !== n) return []\\n\\n    let result = new Array(rowsCount)\\n    for(let i = 0;i<rowsCount;i++){\\n        result[i] = new Array(colsCount).fill(0)\\n    }\\n    let pos = 0;\\n    let c = 0;\\n    let down = true;\\n    while(pos < n){\\n        if(down){\\n            for(let i = 0; i < rowsCount;i++){\\n                result[i][c] = this[pos]\\n                pos++\\n            }\\n        }\\n        else{\\n            for(let i = rowsCount-1; i >= 0;i--){\\n                result[i][c] = this[pos]\\n                pos++\\n            }\\n        }\\n        c++;\\n        down = !down;\\n    }\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    let n = rowsCount * colsCount ;\\n    if(this.length !== n) return []\\n\\n    let result = new Array(rowsCount)\\n    for(let i = 0;i<rowsCount;i++){\\n        result[i] = new Array(colsCount).fill(0)\\n    }\\n    let pos = 0;\\n    let c = 0;\\n    let down = true;\\n    while(pos < n){\\n        if(down){\\n            for(let i = 0; i < rowsCount;i++){\\n                result[i][c] = this[pos]\\n                pos++\\n            }\\n        }\\n        else{\\n            for(let i = rowsCount-1; i >= 0;i--){\\n                result[i][c] = this[pos]\\n                pos++\\n            }\\n        }\\n        c++;\\n        down = !down;\\n    }\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436866,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n    const grid = [];\\n    for (let i = 0; i < rowsCount; i++) {\\n        const row = [];\\n        for (let j = 0; j < colsCount; j++) {\\n            row.push(this[j * rowsCount + (j % 2 ? rowsCount - i - 1 : i)]);\\n        }\\n        grid.push(row);\\n    }\\n    return grid;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n    const grid = [];\\n    for (let i = 0; i < rowsCount; i++) {\\n        const row = [];\\n        for (let j = 0; j < colsCount; j++) {\\n            row.push(this[j * rowsCount + (j % 2 ? rowsCount - i - 1 : i)]);\\n        }\\n        grid.push(row);\\n    }\\n    return grid;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3435715,
                "title": "easy-clear-solution",
                "content": "# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    // if input doesn\\'t match the pattern, return empty array\\n    if(this.length !== rowsCount * colsCount) return [];\\n\\n    const res:number[][] = [];\\n    let count:number = 0;\\n    let rowIndex:number = 0;\\n    let isUpToDown:boolean = true;\\n\\n    while(count < this.length) {\\n        // initialize array if not created yet\\n        if(!res[rowIndex]) res[rowIndex] = [];\\n\\n        res[rowIndex].push(this[count]);\\n\\n        count++;\\n\\n        // when we meet the border, we update the flag\\n        if(count % rowsCount === 0) {\\n            isUpToDown = !isUpToDown;\\n            continue;\\n        }\\n\\n        // we traverse direction depends on the flag\\n        if(isUpToDown) rowIndex++;\\n        else rowIndex--;\\n    }\\n\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    // if input doesn\\'t match the pattern, return empty array\\n    if(this.length !== rowsCount * colsCount) return [];\\n\\n    const res:number[][] = [];\\n    let count:number = 0;\\n    let rowIndex:number = 0;\\n    let isUpToDown:boolean = true;\\n\\n    while(count < this.length) {\\n        // initialize array if not created yet\\n        if(!res[rowIndex]) res[rowIndex] = [];\\n\\n        res[rowIndex].push(this[count]);\\n\\n        count++;\\n\\n        // when we meet the border, we update the flag\\n        if(count % rowsCount === 0) {\\n            isUpToDown = !isUpToDown;\\n            continue;\\n        }\\n\\n        // we traverse direction depends on the flag\\n        if(isUpToDown) rowIndex++;\\n        else rowIndex--;\\n    }\\n\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434410,
                "title": "javascript-nested-loops-iterative",
                "content": "This solution uses nested loops to iteratively build the resulting grid.\\n\\nIt is quite straightforward with the exception of the following line, which determines the offset used to pick the next element.\\n \\n```\\nrow.push(this[j * rowsCount + (j % 2 ? rowsCount - i - 1 : i)]);\\n```\\n\\nSince this is the `j\\'th` column, skipping `j * rowsCount` elements will bring you to the start of the column. Then either pick the `i\\'th` element from the start or end of the current column, depending on whether the column is even or odd respectively.\\n \\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n    const grid = [];\\n    for (let i = 0; i < rowsCount; i++) {\\n        const row = [];\\n        for (let j = 0; j < colsCount; j++) {\\n            row.push(this[j * rowsCount + (j % 2 ? rowsCount - i - 1 : i)]);\\n        }\\n        grid.push(row);\\n    }\\n    return grid;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nrow.push(this[j * rowsCount + (j % 2 ? rowsCount - i - 1 : i)]);\\n```\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return [];\\n    }\\n    const grid = [];\\n    for (let i = 0; i < rowsCount; i++) {\\n        const row = [];\\n        for (let j = 0; j < colsCount; j++) {\\n            row.push(this[j * rowsCount + (j % 2 ? rowsCount - i - 1 : i)]);\\n        }\\n        grid.push(row);\\n    }\\n    return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432946,
                "title": "90-short-typesrcipt-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if(rowsCount*colsCount !== this.length) return [];\\n    let res: number[][] = [];\\n    for(let i=0; i<this.length; i++) {\\n        let col = Math.floor(i/rowsCount);\\n        let row = i%rowsCount;\\n        row = col%2===0 ? row : rowsCount-row-1;\\n        if(res[row] === undefined) res[row] = [];\\n        res[row].push(this[i]);\\n        \\n    }\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n    if(rowsCount*colsCount !== this.length) return [];\\n    let res: number[][] = [];\\n    for(let i=0; i<this.length; i++) {\\n        let col = Math.floor(i/rowsCount);\\n        let row = i%rowsCount;\\n        row = col%2===0 ? row : rowsCount-row-1;\\n        if(res[row] === undefined) res[row] = [];\\n        res[row].push(this[i]);\\n        \\n    }\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432678,
                "title": "alternate-up-down",
                "content": "# Code\\n```\\n// O(m*n)\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) return [];\\n    const arr = Array(rowsCount).fill().map(_ => Array(colsCount).fill(0));\\n    let m = 0;\\n    let n = 0;\\n    let dir = \\'d\\';\\n    let i = 0;\\n    while (n < colsCount) {\\n        arr[m][n] = this[i++];\\n        dir === \\'d\\' ? m++ : m--;\\n        // start heading back up\\n        if (m === rowsCount) {\\n            dir = \\'u\\';\\n            m--;\\n            n++;\\n        }\\n        // start heading back down\\n        if (m === -1) {\\n            dir = \\'d\\'\\n            m++;\\n            n++;\\n        }\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(m*n)\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) return [];\\n    const arr = Array(rowsCount).fill().map(_ => Array(colsCount).fill(0));\\n    let m = 0;\\n    let n = 0;\\n    let dir = \\'d\\';\\n    let i = 0;\\n    while (n < colsCount) {\\n        arr[m][n] = this[i++];\\n        dir === \\'d\\' ? m++ : m--;\\n        // start heading back up\\n        if (m === rowsCount) {\\n            dir = \\'u\\';\\n            m--;\\n            n++;\\n        }\\n        // start heading back down\\n        if (m === -1) {\\n            dir = \\'d\\'\\n            m++;\\n            n++;\\n        }\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3431770,
                "title": "straightforward-solution-ts",
                "content": "# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n\\n    if (this.length != rowsCount * colsCount) return [];\\n\\n    let res: number[][] = [];\\n    for (let i = 0; i < rowsCount; i++) res.push([])\\n\\n    for (let j = 0, resIndex = 0; j < colsCount;)\\n        if (j++ % 2)\\n            for (let i = rowsCount - 1; i > -1;)\\n                res[i--].push(this[resIndex++])\\n        else \\n            for (let i = 0; i < rowsCount;)\\n                res[i++].push(this[resIndex++])\\n\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n\\n    if (this.length != rowsCount * colsCount) return [];\\n\\n    let res: number[][] = [];\\n    for (let i = 0; i < rowsCount; i++) res.push([])\\n\\n    for (let j = 0, resIndex = 0; j < colsCount;)\\n        if (j++ % 2)\\n            for (let i = rowsCount - 1; i > -1;)\\n                res[i--].push(this[resIndex++])\\n        else \\n            for (let i = 0; i < rowsCount;)\\n                res[i++].push(this[resIndex++])\\n\\n    return res;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430139,
                "title": "for-loops-for-rows-and-columns",
                "content": "# Approach\\nUse for-loops to build the solution.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n\\n    const result = [];\\n    \\n    if (rowsCount * colsCount === this.length) {\\n        for (let row = 0; row < rowsCount; row++) {\\n\\n            const rowArr = [];\\n\\n            for (let col = 0; col < colsCount; col++) {\\n\\n                const idx = (col * rowsCount)\\n                    + (col % 2 === 0 ? row : rowsCount - row - 1);\\n                \\n                rowArr.push(this[idx]);\\n\\n            }\\n\\n            result.push(rowArr);\\n\\n        }\\n    }\\n\\n    return result;\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n\\n    const result = [];\\n    \\n    if (rowsCount * colsCount === this.length) {\\n        for (let row = 0; row < rowsCount; row++) {\\n\\n            const rowArr = [];\\n\\n            for (let col = 0; col < colsCount; col++) {\\n\\n                const idx = (col * rowsCount)\\n                    + (col % 2 === 0 ? row : rowsCount - row - 1);\\n                \\n                rowArr.push(this[idx]);\\n\\n            }\\n\\n            result.push(rowArr);\\n\\n        }\\n    }\\n\\n    return result;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3425180,
                "title": "a-little-ott-but-it-gets-the-job-done",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount * colsCount !== this.length){\\n        return [];\\n    }\\n    else{\\n        let result = [];\\n\\n        //traverses through the given array\\n        let counter = 0;\\n\\n        //to check whether col is odd or even\\n        let col = 1;\\n\\n        //initial column to set up # of arrays in result array\\n        for(let i = 0; i<rowsCount; i++){\\n            result.push([this[counter]]);\\n            counter++;\\n        }\\n\\n        while(col<colsCount){\\n            //if even add values in ascending order\\n            if(col % 2 == 0){\\n                for(let i = 0; i<rowsCount; i++){\\n                    result[i].push(this[counter]);\\n                    counter++;\\n                }\\n            }\\n            //if odd add value in descending order\\n            if(col % 2 == 1){\\n                for(let i = (rowsCount-1); i>=0; i--){\\n                    result[i].push(this[counter]);\\n                    counter++;\\n                }\\n            }\\n            col++;   \\n        }\\n        return result;\\n    }\\n    \\n\\n\\n}\\n\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount * colsCount !== this.length){\\n        return [];\\n    }\\n    else{\\n        let result = [];\\n\\n        //traverses through the given array\\n        let counter = 0;\\n\\n        //to check whether col is odd or even\\n        let col = 1;\\n\\n        //initial column to set up # of arrays in result array\\n        for(let i = 0; i<rowsCount; i++){\\n            result.push([this[counter]]);\\n            counter++;\\n        }\\n\\n        while(col<colsCount){\\n            //if even add values in ascending order\\n            if(col % 2 == 0){\\n                for(let i = 0; i<rowsCount; i++){\\n                    result[i].push(this[counter]);\\n                    counter++;\\n                }\\n            }\\n            //if odd add value in descending order\\n            if(col % 2 == 1){\\n                for(let i = (rowsCount-1); i>=0; i--){\\n                    result[i].push(this[counter]);\\n                    counter++;\\n                }\\n            }\\n            col++;   \\n        }\\n        return result;\\n    }\\n    \\n\\n\\n}\\n\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3425109,
                "title": "use-loops",
                "content": "# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length){\\n        return []\\n    }\\n\\n    let result = []\\n\\n    for (let i = 0; i < colsCount; i++){\\n        const offset = rowsCount * i\\n        for (let j = 0; j < rowsCount; j++){\\n            if (!(j in result)) result[j] = [];\\n\\n            if ((i + 1) % 2 == 0)\\n                result[rowsCount - j - 1].push(this[j + offset]);\\n             else\\n                result[j].push(this[j + offset]);\\n        }\\n        \\n    }\\n\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length){\\n        return []\\n    }\\n\\n    let result = []\\n\\n    for (let i = 0; i < colsCount; i++){\\n        const offset = rowsCount * i\\n        for (let j = 0; j < rowsCount; j++){\\n            if (!(j in result)) result[j] = [];\\n\\n            if ((i + 1) % 2 == 0)\\n                result[rowsCount - j - 1].push(this[j + offset]);\\n             else\\n                result[j].push(this[j + offset]);\\n        }\\n        \\n    }\\n\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424614,
                "title": "simple-easy-to-understand-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount*colsCount !== this.length) return [];\\n\\n    const resultArr = new Array(rowsCount);\\n    for (let i = 0; i < rowsCount; i++) {\\n     resultArr[i] = new Array(colsCount);\\n    }\\n    \\n    let down = true;\\n    let i = 0;\\n\\n\\n    for(let col=0; col< colsCount; col++){\\n        if(down){\\n            for(let row = 0; row<rowsCount; row++){\\n                resultArr[row][col] = this[i];\\n                i++;\\n            }\\n        }else{\\n            for(let row=rowsCount-1;row>=0;row--){\\n                resultArr[row][col] = this[i];\\n                i++;\\n            }\\n        }\\n     down = !down;\\n    }\\n\\n    return resultArr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount*colsCount !== this.length) return [];\\n\\n    const resultArr = new Array(rowsCount);\\n    for (let i = 0; i < rowsCount; i++) {\\n     resultArr[i] = new Array(colsCount);\\n    }\\n    \\n    let down = true;\\n    let i = 0;\\n\\n\\n    for(let col=0; col< colsCount; col++){\\n        if(down){\\n            for(let row = 0; row<rowsCount; row++){\\n                resultArr[row][col] = this[i];\\n                i++;\\n            }\\n        }else{\\n            for(let row=rowsCount-1;row>=0;row--){\\n                resultArr[row][col] = this[i];\\n                i++;\\n            }\\n        }\\n     down = !down;\\n    }\\n\\n    return resultArr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3423703,
                "title": "js-beats-96-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(this.length !==  rowsCount * colsCount) return [];\\n    const temp=[],array=[];\\n\\n    for(let i=0;i<rowsCount;i++){\\n        const col=new Array(colsCount);\\n        temp.push(col);\\n    }\\n\\n    for(let j=0;j<colsCount;j++){\\n        if(j%2!==0){\\n            for(let k=0;k<rowsCount;k++)\\n            array.push(this.shift());\\n        }\\n        for(let i=0;i<rowsCount;i++){\\n            if(j%2===0)\\n            temp[i][j]=this.shift();\\n            else\\n            temp[i][j]=array.pop();\\n        }\\n        array.length=0;\\n    }\\n    return temp;\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(this.length !==  rowsCount * colsCount) return [];\\n    const temp=[],array=[];\\n\\n    for(let i=0;i<rowsCount;i++){\\n        const col=new Array(colsCount);\\n        temp.push(col);\\n    }\\n\\n    for(let j=0;j<colsCount;j++){\\n        if(j%2!==0){\\n            for(let k=0;k<rowsCount;k++)\\n            array.push(this.shift());\\n        }\\n        for(let i=0;i<rowsCount;i++){\\n            if(j%2===0)\\n            temp[i][j]=this.shift();\\n            else\\n            temp[i][j]=array.pop();\\n        }\\n        array.length=0;\\n    }\\n    return temp;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3423057,
                "title": "straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple intuitive solution, first we go down and then we go up\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just use to variables for row count and direction\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) return []\\n\\n    const result = new Array(rowsCount).fill()\\n\\n    for (let i = 0; i < result.length; i++) {\\n        result[i] = []\\n    }\\n\\n    let rowIndex = 0\\n\\n    let isForward = true\\n\\n    for (let i = 0; i < this.length; i++) {\\n        // change direction if row index is out of bound\\n        if (rowIndex === rowsCount) {\\n            isForward = false\\n            rowIndex--\\n        }\\n        if (rowIndex < 0) {\\n            isForward = true\\n            rowIndex++\\n        }\\n\\n       result[rowIndex].push(this[i])\\n\\n       if (isForward) {\\n           rowIndex++\\n       } else {\\n          rowIndex--\\n       }\\n    }\\n\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) return []\\n\\n    const result = new Array(rowsCount).fill()\\n\\n    for (let i = 0; i < result.length; i++) {\\n        result[i] = []\\n    }\\n\\n    let rowIndex = 0\\n\\n    let isForward = true\\n\\n    for (let i = 0; i < this.length; i++) {\\n        // change direction if row index is out of bound\\n        if (rowIndex === rowsCount) {\\n            isForward = false\\n            rowIndex--\\n        }\\n        if (rowIndex < 0) {\\n            isForward = true\\n            rowIndex++\\n        }\\n\\n       result[rowIndex].push(this[i])\\n\\n       if (isForward) {\\n           rowIndex++\\n       } else {\\n          rowIndex--\\n       }\\n    }\\n\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3423038,
                "title": "javascript-calc-index-in-an-array-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe calculate an `index` in the inial array `this` to fill in a new matrix, `index` depends on whether it is odd or even column. If it is even column (odd index) we go in opposite direction and calculate `index` by substracting `row` from `col + 1`.\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const result = [];\\n\\n    if (rowsCount * colsCount !== this.length) {\\n        return result;\\n    }\\n\\n    for (let row = 0; row < rowsCount; row++) {\\n        result.push([]);\\n\\n        for (let col = 0; col < colsCount; col++) {\\n            const index = (col % 2 === 1) ?\\n                        (col + 1) * rowsCount - row - 1 :\\n                        col * rowsCount + row;                         \\n\\n            result[row][col] = this[index];\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const result = [];\\n\\n    if (rowsCount * colsCount !== this.length) {\\n        return result;\\n    }\\n\\n    for (let row = 0; row < rowsCount; row++) {\\n        result.push([]);\\n\\n        for (let col = 0; col < colsCount; col++) {\\n            const index = (col % 2 === 1) ?\\n                        (col + 1) * rowsCount - row - 1 :\\n                        col * rowsCount + row;                         \\n\\n            result[row][col] = this[index];\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421211,
                "title": "simple-js-solution-in-best-time-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N ^ 2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\n\\nfunction makeArray(d1, d2) {\\n    let arr = [];\\n    for(let i = 0; i < d1; i++) {\\n        arr.push(new Array(d2));\\n    }\\n    return arr;\\n}\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const arr = makeArray(rowsCount, colsCount);\\n    let size = rowsCount * colsCount;\\n\\n    if(size > this.length || size < this.length) return [];\\n\\n    let i = 0;\\n\\n    for(let col = 0; col < colsCount; col++){\\n        if(col&1){\\n            for(let row = rowsCount-1; row >= 0; row--){\\n                arr[row][col] = this[i];\\n                i++;\\n            }\\n        }\\n        else{\\n            for(let row = 0; row < rowsCount; row++){\\n                arr[row][col] = this[i];\\n                i++;\\n            }\\n        }\\n    }\\n    return arr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\n\\nfunction makeArray(d1, d2) {\\n    let arr = [];\\n    for(let i = 0; i < d1; i++) {\\n        arr.push(new Array(d2));\\n    }\\n    return arr;\\n}\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const arr = makeArray(rowsCount, colsCount);\\n    let size = rowsCount * colsCount;\\n\\n    if(size > this.length || size < this.length) return [];\\n\\n    let i = 0;\\n\\n    for(let col = 0; col < colsCount; col++){\\n        if(col&1){\\n            for(let row = rowsCount-1; row >= 0; row--){\\n                arr[row][col] = this[i];\\n                i++;\\n            }\\n        }\\n        else{\\n            for(let row = 0; row < rowsCount; row++){\\n                arr[row][col] = this[i];\\n                i++;\\n            }\\n        }\\n    }\\n    return arr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420637,
                "title": "two-loops-100-clean-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nArrays!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor loops to solve the problem\\n# Complexity\\n- Time complexity: O(n2) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nRuntime 217 ms\\nBeats 65.13%\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nMemory 57.4 MB\\nBeats 36.18%\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\nif(rowsCount * colsCount !== this.length) return []\\n\\nlet list=[]\\nlet i = 0\\nfor (let col = 0; col < colsCount; col++){\\n     list[col] = []\\n    if(col % 2 == 0){\\n        for(let cell = 0; cell < rowsCount; cell++){\\n            list[col][cell] = this[i++]\\n        }\\n    }else{\\n        for(let cell = rowsCount-1; cell >=0; cell--){\\n            list[col][cell] = this[i++]\\n        }\\n    }\\n}\\n\\n    let result = []\\n    for (let row = 0; row < rowsCount; row++){\\n        result[row] = []\\n        for (let cell = 0; cell < colsCount; cell++){\\n            result[row][cell]= list[cell][row]\\n        }\\n    }   \\n\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\nif(rowsCount * colsCount !== this.length) return []\\n\\nlet list=[]\\nlet i = 0\\nfor (let col = 0; col < colsCount; col++){\\n     list[col] = []\\n    if(col % 2 == 0){\\n        for(let cell = 0; cell < rowsCount; cell++){\\n            list[col][cell] = this[i++]\\n        }\\n    }else{\\n        for(let cell = rowsCount-1; cell >=0; cell--){\\n            list[col][cell] = this[i++]\\n        }\\n    }\\n}\\n\\n    let result = []\\n    for (let row = 0; row < rowsCount; row++){\\n        result[row] = []\\n        for (let cell = 0; cell < colsCount; cell++){\\n            result[row][cell]= list[cell][row]\\n        }\\n    }   \\n\\n    return result\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418320,
                "title": "simple-array",
                "content": "# Code\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) return [];\\n\\n    const newArr = Array.from({ length: rowsCount }, () => Array(colsCount));\\n\\n    for (let i = 0; i < colsCount; i++) {\\n        for (let j = 0; j < rowsCount; j++) {\\n            newArr[i % 2 ? rowsCount - j - 1 : j][i] = this[rowsCount * i + j];\\n        }\\n    }\\n\\n    return newArr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) return [];\\n\\n    const newArr = Array.from({ length: rowsCount }, () => Array(colsCount));\\n\\n    for (let i = 0; i < colsCount; i++) {\\n        for (let j = 0; j < rowsCount; j++) {\\n            newArr[i % 2 ? rowsCount - j - 1 : j][i] = this[rowsCount * i + j];\\n        }\\n    }\\n\\n    return newArr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3417796,
                "title": "fill-as-instruction",
                "content": "# Intuition\\nDo exactly like snail fill instruction,\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(rowsCount * colsCount) = O(N)\\n\\n- Space complexity:\\nNone since smae as output\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return []\\n    }\\n    const snail = new Array(rowsCount).fill([]).map(() => new Array(colsCount).fill(0));\\n    let row = 0;\\n    let column = 0;\\n    let direction = 1;\\n    for (const item of this) {\\n        snail[row][column] = item;\\n        row += direction;\\n        if (row >= rowsCount || row < 0) {\\n            direction = -1 * direction;\\n            row += direction;\\n            column += 1;\\n        }\\n    }\\n    return snail;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount !== this.length) {\\n        return []\\n    }\\n    const snail = new Array(rowsCount).fill([]).map(() => new Array(colsCount).fill(0));\\n    let row = 0;\\n    let column = 0;\\n    let direction = 1;\\n    for (const item of this) {\\n        snail[row][column] = item;\\n        row += direction;\\n        if (row >= rowsCount || row < 0) {\\n            direction = -1 * direction;\\n            row += direction;\\n            column += 1;\\n        }\\n    }\\n    return snail;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3417748,
                "title": "clean-js-solution-beginner-friendly",
                "content": "##### Intuition\\nThe solution is quite simple. We need carefully iterate over the new array and fill it with the values.\\n\\n```\\n[\\n  (row)> [1, 6, 7]\\n         [2, 5, 8]\\n         [3, 4, 9]\\n          ^(col)\\n]\\n```\\n\\nWe can see that `col` index always increases, while `row` index change direction when it reaches the edge of the array.\\n\\n##### Code\\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length !== rowsCount * colsCount) {\\n        return [];\\n    }\\n\\n    const result = new Array(rowsCount).fill(0).map(() => new Array(colsCount).fill(0));\\n    let row = 0;\\n    let col = 0;\\n    let dir = 1; // direction of row index\\n    let idx = 0; // index in the original array\\n\\n    while (col < colsCount) {\\n        result[row][col] = this[idx++];\\n        row += dir;\\n\\n        // change direction when reaching the edge\\n        if (row === rowsCount || row === -1) {\\n            dir *= -1;\\n            row += dir;\\n            col++;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n[\\n  (row)> [1, 6, 7]\\n         [2, 5, 8]\\n         [3, 4, 9]\\n          ^(col)\\n]\\n```\n```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length !== rowsCount * colsCount) {\\n        return [];\\n    }\\n\\n    const result = new Array(rowsCount).fill(0).map(() => new Array(colsCount).fill(0));\\n    let row = 0;\\n    let col = 0;\\n    let dir = 1; // direction of row index\\n    let idx = 0; // index in the original array\\n\\n    while (col < colsCount) {\\n        result[row][col] = this[idx++];\\n        row += dir;\\n\\n        // change direction when reaching the edge\\n        if (row === rowsCount || row === -1) {\\n            dir *= -1;\\n            row += dir;\\n            col++;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3417046,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const arr = Array.from({ length: rowsCount }, () => \\n  Array.from({ length: colsCount }, () => false)\\n);\\nif(rowsCount*colsCount!=this.length){\\n    return [];\\n}\\nlet rp = 0;let flag = true;let mp = 0;\\nfor(let i = 0;i < colsCount; i++){\\n    if(flag){\\n         while(rp < rowsCount){\\n            arr[rp][i] = this[mp];rp++;mp++;\\n\\n         }\\n    }else{\\n        while(rp>=0){\\n            arr[rp][i] = this[mp];mp++;rp--;\\n        }\\n    }\\n    if(flag){\\n        flag = false;\\n        rp = rowsCount - 1;\\n    }else{\\n        flag = true;\\n        rp = 0;\\n    }\\n}\\nreturn arr;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const arr = Array.from({ length: rowsCount }, () => \\n  Array.from({ length: colsCount }, () => false)\\n);\\nif(rowsCount*colsCount!=this.length){\\n    return [];\\n}\\nlet rp = 0;let flag = true;let mp = 0;\\nfor(let i = 0;i < colsCount; i++){\\n    if(flag){\\n         while(rp < rowsCount){\\n            arr[rp][i] = this[mp];rp++;mp++;\\n\\n         }\\n    }else{\\n        while(rp>=0){\\n            arr[rp][i] = this[mp];mp++;rp--;\\n        }\\n    }\\n    if(flag){\\n        flag = false;\\n        rp = rowsCount - 1;\\n    }else{\\n        flag = true;\\n        rp = 0;\\n    }\\n}\\nreturn arr;\\n\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3416833,
                "title": "my-solution",
                "content": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length != rowsCount * colsCount) {\\n        return [];\\n    }\\n    const ret = Array(rowsCount).fill([]).map(() => []);\\n    for (i = 0; i < this.length; ++i) {\\n        const col = Math.floor(i / rowsCount);\\n        const row_offset = i % rowsCount\\n        const row = col % 2 == 0 ? row_offset : rowsCount - row_offset - 1;\\n        ret[row][col] = this[i];\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length != rowsCount * colsCount) {\\n        return [];\\n    }\\n    const ret = Array(rowsCount).fill([]).map(() => []);\\n    for (i = 0; i < this.length; ++i) {\\n        const col = Math.floor(i / rowsCount);\\n        const row_offset = i % rowsCount\\n        const row = col % 2 == 0 ? row_offset : rowsCount - row_offset - 1;\\n        ret[row][col] = this[i];\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3415610,
                "title": "snail-traversal-straight-forward-approach-javascript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse a nestedd loop and a startight forward apporoach with js array apis\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n// return empty array when the condn is met\\n// Nested for loop where we update a created 2d array \\n// to do snail traversal reverse the row array when the column is even\\n// return op\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n2)$$\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount * colsCount !== this.length) return [];\\nlet snailArr= Array(rowsCount).fill(null).map(() => Array(colsCount));\\n    let index=0;\\n    for(let col=0 ;col<colsCount;col++){\\n        let row =[]\\n         for(let row=0 ;row<rowsCount;row++){\\n             if((col+1)%2 === 0){\\nsnailArr[rowsCount -row -1][col]=this[index]\\n\\n             }else{\\nsnailArr[row][col]=this[index]\\n\\n             }\\n index++\\n         }\\n    }\\nreturn(snailArr)\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if(rowsCount * colsCount !== this.length) return [];\\nlet snailArr= Array(rowsCount).fill(null).map(() => Array(colsCount));\\n    let index=0;\\n    for(let col=0 ;col<colsCount;col++){\\n        let row =[]\\n         for(let row=0 ;row<rowsCount;row++){\\n             if((col+1)%2 === 0){\\nsnailArr[rowsCount -row -1][col]=this[index]\\n\\n             }else{\\nsnailArr[row][col]=this[index]\\n\\n             }\\n index++\\n         }\\n    }\\nreturn(snailArr)\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3415591,
                "title": "accepted-javascript",
                "content": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    \\n    if (rowsCount * colsCount == 0 || this.length != rowsCount * colsCount) {\\n        return [];\\n    }\\n\\n    var res = [];\\n\\n    for (let i = 0; i < rowsCount; i++) {\\n        res.push([]);\\n    }\\n\\n    for (let i = 0; i < this.length; i++) {\\n        let col = i / rowsCount | 0;\\n        let row = i % rowsCount;\\n\\n        if (col % 2 == 1) {\\n            row = rowsCount - row - 1;\\n        }\\n\\n        res[row].push(this[i]);\\n    }\\n\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    \\n    if (rowsCount * colsCount == 0 || this.length != rowsCount * colsCount) {\\n        return [];\\n    }\\n\\n    var res = [];\\n\\n    for (let i = 0; i < rowsCount; i++) {\\n        res.push([]);\\n    }\\n\\n    for (let i = 0; i < this.length; i++) {\\n        let col = i / rowsCount | 0;\\n        let row = i % rowsCount;\\n\\n        if (col % 2 == 1) {\\n            row = rowsCount - row - 1;\\n        }\\n\\n        res[row].push(this[i]);\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3415434,
                "title": "relative-short-and-easy-understandard-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMay not be the best solutions regarding the space and time complexity, but relative easy for coding.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nTBD\\n\\n# Code\\n```\\n// Create 2d array regarding rowsCount\\nfunction create2DArr(n){\\n    let arr = [];\\n\\n    for(let i = 0; i < n; i ++){\\n        arr.push([])\\n    }\\n\\n    return arr\\n}\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n\\n    // if rowsCount * colsCount not match the array length\\n    if( (rowsCount * colsCount) !== this.length){\\n        return []\\n    }\\n\\n    let result = create2DArr(rowsCount);\\n\\n    // The Snail Traversal will be accroding from up to down\\n    // then repeat, hence the array \"all\" is about the \\n    // hardcode snail sequence of a loop\\n\\n    let forward = Array.from(Array(rowsCount).keys())\\n    let all = [...forward, ...forward.reverse()]\\n\\n    this.forEach( (v,i) => result[ all[i % all.length] ].push(v) )\\n\\n    return result\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Create 2d array regarding rowsCount\\nfunction create2DArr(n){\\n    let arr = [];\\n\\n    for(let i = 0; i < n; i ++){\\n        arr.push([])\\n    }\\n\\n    return arr\\n}\\n\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n\\n    // if rowsCount * colsCount not match the array length\\n    if( (rowsCount * colsCount) !== this.length){\\n        return []\\n    }\\n\\n    let result = create2DArr(rowsCount);\\n\\n    // The Snail Traversal will be accroding from up to down\\n    // then repeat, hence the array \"all\" is about the \\n    // hardcode snail sequence of a loop\\n\\n    let forward = Array.from(Array(rowsCount).keys())\\n    let all = [...forward, ...forward.reverse()]\\n\\n    this.forEach( (v,i) => result[ all[i % all.length] ].push(v) )\\n\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3413820,
                "title": "operand-switching-and-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can create an empty array based on given row and col count and fill it accordingly using appropriate flags\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse `Array()` to create the required empty array. And use a operand that takes the values of 1 or -1 based on the condition. We use this to add or subtract from the `row` and implement the logic\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount != this.length) return [] \\n    let arr = [], itr = 0, opr = 1, row = 0;\\n    for (let i = 0; i < rowsCount; i++) arr.push(Array(colsCount));\\n\\n    for (let i = 0; i < colsCount; i++) {\\n        if (row <= 0) {\\n            opr = 1;\\n            row = 0\\n        } else if (row >= rowsCount - 1) {\\n            opr = -1;\\n            row = rowsCount - 1;\\n        }\\n        for (let j = 0; j < rowsCount; j++) {\\n            arr[row][i] = this[itr++];\\n            row += opr;\\n        }\\n    }\\n\\n    return arr;\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (rowsCount * colsCount != this.length) return [] \\n    let arr = [], itr = 0, opr = 1, row = 0;\\n    for (let i = 0; i < rowsCount; i++) arr.push(Array(colsCount));\\n\\n    for (let i = 0; i < colsCount; i++) {\\n        if (row <= 0) {\\n            opr = 1;\\n            row = 0\\n        } else if (row >= rowsCount - 1) {\\n            opr = -1;\\n            row = rowsCount - 1;\\n        }\\n        for (let j = 0; j < rowsCount; j++) {\\n            arr[row][i] = this[itr++];\\n            row += opr;\\n        }\\n    }\\n\\n    return arr;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411948,
                "title": "some-simple-math",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTop to bottom, left to right means that for index i from 0 to nums.length-1:\\n\\nc = Math.floor(i/rowsCount);\\nr = (c%2==0) ? i%rowsCount : rowsCount-1-(i%rowsCount);\\n\\nWhen the column index is even, numbers are populated from top to bottom and when it\\'s odd, it goes from bottom to top. \\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length !== rowsCount*colsCount) return []; \\n    let n = this.length;\\n    let ans = Array.from({ length: rowsCount }, () => new Array(colsCount));\\n    let r = c = 0;\\n    for (let i=0; i<n; ++i) {\\n        c = Math.floor(i/rowsCount); \\n        r = (c%2==0) ? i%rowsCount : rowsCount-1-(i%rowsCount);\\n        ans[r][c] = this[i]; \\n    }\\n    return ans; \\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length !== rowsCount*colsCount) return []; \\n    let n = this.length;\\n    let ans = Array.from({ length: rowsCount }, () => new Array(colsCount));\\n    let r = c = 0;\\n    for (let i=0; i<n; ++i) {\\n        c = Math.floor(i/rowsCount); \\n        r = (c%2==0) ? i%rowsCount : rowsCount-1-(i%rowsCount);\\n        ans[r][c] = this[i]; \\n    }\\n    return ans; \\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411565,
                "title": "using-array-from-create-array",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    // Invalid input\\n    if(this.length !== rowsCount * colsCount) return []\\n\\n    const ans = Array.from({length: rowsCount}, () => [])\\n    let curr = 0 // nums\\'s index\\n    for(let i = 0; i < colsCount; i++) {\\n        for(let j = 0; j < rowsCount; j++) {\\n            if(i % 2 === 0) {\\n                ans[j][i] = this[curr++]\\n            } else {\\n                ans[rowsCount - j - 1][i] = this[curr++]\\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    // Invalid input\\n    if(this.length !== rowsCount * colsCount) return []\\n\\n    const ans = Array.from({length: rowsCount}, () => [])\\n    let curr = 0 // nums\\'s index\\n    for(let i = 0; i < colsCount; i++) {\\n        for(let j = 0; j < rowsCount; j++) {\\n            if(i % 2 === 0) {\\n                ans[j][i] = this[curr++]\\n            } else {\\n                ans[rowsCount - j - 1][i] = this[curr++]\\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410906,
                "title": "o-n-easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a 2D array and then push elements from the nums array sequentially using a for loop.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Declare a variable \\'result\\', which will create a two-dimensional array based on the value of rowsCount.\\n2. Declare a variable \\'direction\\', which is used to determine whether the direction of element insertion is downward or upward.\\n3. Declare a variable \\'count\\', which records the index of the element to be inserted.\\n4. Use a nested loop for colsCount and rowsCount to adjust the insertion order of the nums values based on the direction variable.\\n\\n\\n# Complexity\\nTime complexity:\\n- O(n)\\n\\nSpace complexity:\\n- O(m * n)\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length !== rowsCount * colsCount) return [];\\n    var result = new Array(rowsCount).fill().map(() => []);\\n    var direction = true;\\n    var count = 0;\\n    for(let i = 0; i < colsCount; i++) {\\n        for(let j = 0; j < rowsCount; j++) {\\n            if (direction) result[j][i] = this[count++];\\n            else result[rowsCount - j - 1][i] = this[count++];\\n        }\\n        direction = !direction;\\n    }\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length !== rowsCount * colsCount) return [];\\n    var result = new Array(rowsCount).fill().map(() => []);\\n    var direction = true;\\n    var count = 0;\\n    for(let i = 0; i < colsCount; i++) {\\n        for(let j = 0; j < rowsCount; j++) {\\n            if (direction) result[j][i] = this[count++];\\n            else result[rowsCount - j - 1][i] = this[count++];\\n        }\\n        direction = !direction;\\n    }\\n    return result;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410845,
                "title": "easy-solution-short-simple",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const len =this.length\\n    if(rowsCount * colsCount !== len)return []\\n    const snailArr= new Array(rowsCount).fill().map(()=>[])\\n\\n    let reverse = false\\n\\n    for(let i = 0; i < len; i++){\\n        if(reverse){\\n            snailArr[(rowsCount - 1) - (i % rowsCount)].push(this[i])\\n        }else{\\n            snailArr[i % rowsCount].push(this[i])\\n        }\\n\\n        if(i % rowsCount == rowsCount - 1)reverse = !reverse\\n    }\\n    return snailArr\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    const len =this.length\\n    if(rowsCount * colsCount !== len)return []\\n    const snailArr= new Array(rowsCount).fill().map(()=>[])\\n\\n    let reverse = false\\n\\n    for(let i = 0; i < len; i++){\\n        if(reverse){\\n            snailArr[(rowsCount - 1) - (i % rowsCount)].push(this[i])\\n        }else{\\n            snailArr[i % rowsCount].push(this[i])\\n        }\\n\\n        if(i % rowsCount == rowsCount - 1)reverse = !reverse\\n    }\\n    return snailArr\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410624,
                "title": "typescript-using-slice-and-boolean",
                "content": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function (\\n  rowsCount: number,\\n  colsCount: number\\n): number[][] {\\n  if (rowsCount * colsCount !== this.length) return [];\\n\\n  const out: any[][] = [];\\n  for (let i = 0; i < rowsCount; i++) out.push([] as any[]);\\n\\n  let down = true;\\n  for (let i = 0; i < colsCount; i++) {\\n    const nextCol = this.slice(i * rowsCount, (i + 1) * rowsCount);\\n    if (!down) nextCol.reverse();\\n    for (let j = 0; j < rowsCount; j++) {\\n      out[j].push(nextCol[j]);\\n    }\\n    down = !down;\\n  }\\n\\n  return out;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function (\\n  rowsCount: number,\\n  colsCount: number\\n): number[][] {\\n  if (rowsCount * colsCount !== this.length) return [];\\n\\n  const out: any[][] = [];\\n  for (let i = 0; i < rowsCount; i++) out.push([] as any[]);\\n\\n  let down = true;\\n  for (let i = 0; i < colsCount; i++) {\\n    const nextCol = this.slice(i * rowsCount, (i + 1) * rowsCount);\\n    if (!down) nextCol.reverse();\\n    for (let j = 0; j < rowsCount; j++) {\\n      out[j].push(nextCol[j]);\\n    }\\n    down = !down;\\n  }\\n\\n  return out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409495,
                "title": "simple-solution-using-boolean-value-typescript-js",
                "content": "# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n  if (rowsCount*colsCount !== this.length){\\n      return [];\\n  }\\n  const new_arr = [];\\n  for (let r = 0; r < rowsCount; r += 1){\\n      new_arr.push(new Array(colsCount));\\n  }\\n  let is_down = true;\\n  let idx = 0;\\n  for (let i = 0; i < colsCount; i += 1){\\n      if (is_down){\\n          for (let r = 0; r < rowsCount; r += 1){\\n            new_arr[r][i] = this[idx];\\n            idx += 1;\\n          }\\n      }else{\\n          for (let r = rowsCount-1; r >= 0; r -= 1){\\n            new_arr[r][i] = this[idx];\\n            idx += 1;\\n          }\\n      }\\n      is_down = !is_down;\\n  }\\n  return new_arr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    snail(rowsCount: number, colsCount: number): number[][];\\n  }\\n}\\n\\nArray.prototype.snail = function(rowsCount: number, colsCount: number): number[][] {\\n  if (rowsCount*colsCount !== this.length){\\n      return [];\\n  }\\n  const new_arr = [];\\n  for (let r = 0; r < rowsCount; r += 1){\\n      new_arr.push(new Array(colsCount));\\n  }\\n  let is_down = true;\\n  let idx = 0;\\n  for (let i = 0; i < colsCount; i += 1){\\n      if (is_down){\\n          for (let r = 0; r < rowsCount; r += 1){\\n            new_arr[r][i] = this[idx];\\n            idx += 1;\\n          }\\n      }else{\\n          for (let r = rowsCount-1; r >= 0; r -= 1){\\n            new_arr[r][i] = this[idx];\\n            idx += 1;\\n          }\\n      }\\n      is_down = !is_down;\\n  }\\n  return new_arr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409280,
                "title": "easy-to-understand-100-space-and-time-solution",
                "content": "# Intuition \\uD83E\\uDD14\\nThe problem is to convert a one-dimensional array into a two-dimensional array by snaking through the elements in a zigzag pattern.\\n\\n# Approach \\uD83D\\uDE80\\nThe approach used in the provided code is to create a new two-dimensional array with the specified number of rows and columns. Then, starting from the first column, the elements of the one-dimensional array are added to the two-dimensional array in a zigzag pattern. If the column index is even, the elements are added to the rows in increasing order. If the column index is odd, the elements are added to the rows in decreasing order.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length !== rowsCount * colsCount) return [];\\n    \\n    let arr = new Array(rowsCount).fill().map(() => new Array(colsCount));    \\n    let x = 0;\\n    for (let j = 0; j < colsCount; ++j)\\n        if (j % 2)\\n            for (let i = rowsCount - 1; i >= 0; --i)\\n                arr[i][j] = this[x++]\\n        else\\n            for (let i = 0; i < rowsCount; ++i)\\n                arr[i][j] = this[x++]\\n\\n    return arr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowsCount\\n * @param {number} colsCount\\n * @return {Array<Array<number>>}\\n */\\nArray.prototype.snail = function(rowsCount, colsCount) {\\n    if (this.length !== rowsCount * colsCount) return [];\\n    \\n    let arr = new Array(rowsCount).fill().map(() => new Array(colsCount));    \\n    let x = 0;\\n    for (let j = 0; j < colsCount; ++j)\\n        if (j % 2)\\n            for (let i = rowsCount - 1; i >= 0; --i)\\n                arr[i][j] = this[x++]\\n        else\\n            for (let i = 0; i < rowsCount; ++i)\\n                arr[i][j] = this[x++]\\n\\n    return arr;\\n}\\n\\n/**\\n * const arr = [1,2,3,4];\\n * arr.snail(1,4); // [[1,2,3,4]]\\n */\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1860860,
                "content": [
                    {
                        "username": "kodyczasupl1",
                        "content": "good question to practice, got asked this at one of FAANG as a UI question. Needless to say, it didn\\'t go well..."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "Needless to say, it didn\\'t go well... :D"
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "It\\'s not a big deal, but I\\'m confused why they randomized the values in the array for example 1. I feel like the problem would be clearer if either the input or output was sorted. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Nice question, but why is this a JS question? You can do this in any language right? it is similar 54. Spiral Matrix, which is available for all languages. I guess Array is a JS object which is not available in the same way in other languages. But that is not the interesting part of the question. The interesting part is the traversal."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "cause it\\'s commonly asked as ui question https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions and leetcode doesnt support html/css stuff"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "Facing error on this code, can anyone help me on this\n `Error: An error occurred calling array.snail(): Cannot set properties of undefined (setting '0')`\nCan anyone help me on this?\n\n\n`Array.prototype.snail = function(rowsCount, colsCount) {\n\n    if((rowsCount * colsCount) > this.length) return [];\n    let arr = [];\n    for(let ri=0;ri<rowsCount;ri++) {\n        arr.push(Array(colsCount).fill(0));\n    }\n    let rowsI = -1;\n    let colsI = -1;\n    for(let i=0;i<this.length;i++) {\n        let tempCnt = i % (colsCount + 1);\n        (tempCnt == 0) && colsI++;\n        rowsI = tempCnt;\n        arr[rowsI][colsI] = this[i];\n    }\n    return arr;\n}`\n\n"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "[@gyanendra2058](/gyanendra2058) In local execution|debugging is working fine, and result is also as per expectation."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "May be  this line is culprit  arr[rowsI][colsI] = this[i]; Try debugging it\\n"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The error messages are trash."
                    },
                    {
                        "username": "cionx",
                        "content": "This seems to be basically the same as [Problem 6](https://leetcode.com/problems/zigzag-conversion/) (Zigzag Conversion)."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "tbh they are very different, this is what asked exactly at Faang as snail traversal: https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions"
                    }
                ]
            },
            {
                "id": 1861717,
                "content": [
                    {
                        "username": "kodyczasupl1",
                        "content": "good question to practice, got asked this at one of FAANG as a UI question. Needless to say, it didn\\'t go well..."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "Needless to say, it didn\\'t go well... :D"
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "It\\'s not a big deal, but I\\'m confused why they randomized the values in the array for example 1. I feel like the problem would be clearer if either the input or output was sorted. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Nice question, but why is this a JS question? You can do this in any language right? it is similar 54. Spiral Matrix, which is available for all languages. I guess Array is a JS object which is not available in the same way in other languages. But that is not the interesting part of the question. The interesting part is the traversal."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "cause it\\'s commonly asked as ui question https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions and leetcode doesnt support html/css stuff"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "Facing error on this code, can anyone help me on this\n `Error: An error occurred calling array.snail(): Cannot set properties of undefined (setting '0')`\nCan anyone help me on this?\n\n\n`Array.prototype.snail = function(rowsCount, colsCount) {\n\n    if((rowsCount * colsCount) > this.length) return [];\n    let arr = [];\n    for(let ri=0;ri<rowsCount;ri++) {\n        arr.push(Array(colsCount).fill(0));\n    }\n    let rowsI = -1;\n    let colsI = -1;\n    for(let i=0;i<this.length;i++) {\n        let tempCnt = i % (colsCount + 1);\n        (tempCnt == 0) && colsI++;\n        rowsI = tempCnt;\n        arr[rowsI][colsI] = this[i];\n    }\n    return arr;\n}`\n\n"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "[@gyanendra2058](/gyanendra2058) In local execution|debugging is working fine, and result is also as per expectation."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "May be  this line is culprit  arr[rowsI][colsI] = this[i]; Try debugging it\\n"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The error messages are trash."
                    },
                    {
                        "username": "cionx",
                        "content": "This seems to be basically the same as [Problem 6](https://leetcode.com/problems/zigzag-conversion/) (Zigzag Conversion)."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "tbh they are very different, this is what asked exactly at Faang as snail traversal: https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions"
                    }
                ]
            },
            {
                "id": 1909946,
                "content": [
                    {
                        "username": "kodyczasupl1",
                        "content": "good question to practice, got asked this at one of FAANG as a UI question. Needless to say, it didn\\'t go well..."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "Needless to say, it didn\\'t go well... :D"
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "It\\'s not a big deal, but I\\'m confused why they randomized the values in the array for example 1. I feel like the problem would be clearer if either the input or output was sorted. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Nice question, but why is this a JS question? You can do this in any language right? it is similar 54. Spiral Matrix, which is available for all languages. I guess Array is a JS object which is not available in the same way in other languages. But that is not the interesting part of the question. The interesting part is the traversal."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "cause it\\'s commonly asked as ui question https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions and leetcode doesnt support html/css stuff"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "Facing error on this code, can anyone help me on this\n `Error: An error occurred calling array.snail(): Cannot set properties of undefined (setting '0')`\nCan anyone help me on this?\n\n\n`Array.prototype.snail = function(rowsCount, colsCount) {\n\n    if((rowsCount * colsCount) > this.length) return [];\n    let arr = [];\n    for(let ri=0;ri<rowsCount;ri++) {\n        arr.push(Array(colsCount).fill(0));\n    }\n    let rowsI = -1;\n    let colsI = -1;\n    for(let i=0;i<this.length;i++) {\n        let tempCnt = i % (colsCount + 1);\n        (tempCnt == 0) && colsI++;\n        rowsI = tempCnt;\n        arr[rowsI][colsI] = this[i];\n    }\n    return arr;\n}`\n\n"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "[@gyanendra2058](/gyanendra2058) In local execution|debugging is working fine, and result is also as per expectation."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "May be  this line is culprit  arr[rowsI][colsI] = this[i]; Try debugging it\\n"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The error messages are trash."
                    },
                    {
                        "username": "cionx",
                        "content": "This seems to be basically the same as [Problem 6](https://leetcode.com/problems/zigzag-conversion/) (Zigzag Conversion)."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "tbh they are very different, this is what asked exactly at Faang as snail traversal: https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions"
                    }
                ]
            },
            {
                "id": 2002087,
                "content": [
                    {
                        "username": "kodyczasupl1",
                        "content": "good question to practice, got asked this at one of FAANG as a UI question. Needless to say, it didn\\'t go well..."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "Needless to say, it didn\\'t go well... :D"
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "It\\'s not a big deal, but I\\'m confused why they randomized the values in the array for example 1. I feel like the problem would be clearer if either the input or output was sorted. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Nice question, but why is this a JS question? You can do this in any language right? it is similar 54. Spiral Matrix, which is available for all languages. I guess Array is a JS object which is not available in the same way in other languages. But that is not the interesting part of the question. The interesting part is the traversal."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "cause it\\'s commonly asked as ui question https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions and leetcode doesnt support html/css stuff"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "Facing error on this code, can anyone help me on this\n `Error: An error occurred calling array.snail(): Cannot set properties of undefined (setting '0')`\nCan anyone help me on this?\n\n\n`Array.prototype.snail = function(rowsCount, colsCount) {\n\n    if((rowsCount * colsCount) > this.length) return [];\n    let arr = [];\n    for(let ri=0;ri<rowsCount;ri++) {\n        arr.push(Array(colsCount).fill(0));\n    }\n    let rowsI = -1;\n    let colsI = -1;\n    for(let i=0;i<this.length;i++) {\n        let tempCnt = i % (colsCount + 1);\n        (tempCnt == 0) && colsI++;\n        rowsI = tempCnt;\n        arr[rowsI][colsI] = this[i];\n    }\n    return arr;\n}`\n\n"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "[@gyanendra2058](/gyanendra2058) In local execution|debugging is working fine, and result is also as per expectation."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "May be  this line is culprit  arr[rowsI][colsI] = this[i]; Try debugging it\\n"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The error messages are trash."
                    },
                    {
                        "username": "cionx",
                        "content": "This seems to be basically the same as [Problem 6](https://leetcode.com/problems/zigzag-conversion/) (Zigzag Conversion)."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "tbh they are very different, this is what asked exactly at Faang as snail traversal: https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions"
                    }
                ]
            },
            {
                "id": 1934756,
                "content": [
                    {
                        "username": "kodyczasupl1",
                        "content": "good question to practice, got asked this at one of FAANG as a UI question. Needless to say, it didn\\'t go well..."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "Needless to say, it didn\\'t go well... :D"
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "It\\'s not a big deal, but I\\'m confused why they randomized the values in the array for example 1. I feel like the problem would be clearer if either the input or output was sorted. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Nice question, but why is this a JS question? You can do this in any language right? it is similar 54. Spiral Matrix, which is available for all languages. I guess Array is a JS object which is not available in the same way in other languages. But that is not the interesting part of the question. The interesting part is the traversal."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "cause it\\'s commonly asked as ui question https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions and leetcode doesnt support html/css stuff"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "Facing error on this code, can anyone help me on this\n `Error: An error occurred calling array.snail(): Cannot set properties of undefined (setting '0')`\nCan anyone help me on this?\n\n\n`Array.prototype.snail = function(rowsCount, colsCount) {\n\n    if((rowsCount * colsCount) > this.length) return [];\n    let arr = [];\n    for(let ri=0;ri<rowsCount;ri++) {\n        arr.push(Array(colsCount).fill(0));\n    }\n    let rowsI = -1;\n    let colsI = -1;\n    for(let i=0;i<this.length;i++) {\n        let tempCnt = i % (colsCount + 1);\n        (tempCnt == 0) && colsI++;\n        rowsI = tempCnt;\n        arr[rowsI][colsI] = this[i];\n    }\n    return arr;\n}`\n\n"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "[@gyanendra2058](/gyanendra2058) In local execution|debugging is working fine, and result is also as per expectation."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "May be  this line is culprit  arr[rowsI][colsI] = this[i]; Try debugging it\\n"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The error messages are trash."
                    },
                    {
                        "username": "cionx",
                        "content": "This seems to be basically the same as [Problem 6](https://leetcode.com/problems/zigzag-conversion/) (Zigzag Conversion)."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "tbh they are very different, this is what asked exactly at Faang as snail traversal: https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions"
                    }
                ]
            },
            {
                "id": 1911121,
                "content": [
                    {
                        "username": "kodyczasupl1",
                        "content": "good question to practice, got asked this at one of FAANG as a UI question. Needless to say, it didn\\'t go well..."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "Needless to say, it didn\\'t go well... :D"
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "It\\'s not a big deal, but I\\'m confused why they randomized the values in the array for example 1. I feel like the problem would be clearer if either the input or output was sorted. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Nice question, but why is this a JS question? You can do this in any language right? it is similar 54. Spiral Matrix, which is available for all languages. I guess Array is a JS object which is not available in the same way in other languages. But that is not the interesting part of the question. The interesting part is the traversal."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "cause it\\'s commonly asked as ui question https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions and leetcode doesnt support html/css stuff"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "Facing error on this code, can anyone help me on this\n `Error: An error occurred calling array.snail(): Cannot set properties of undefined (setting '0')`\nCan anyone help me on this?\n\n\n`Array.prototype.snail = function(rowsCount, colsCount) {\n\n    if((rowsCount * colsCount) > this.length) return [];\n    let arr = [];\n    for(let ri=0;ri<rowsCount;ri++) {\n        arr.push(Array(colsCount).fill(0));\n    }\n    let rowsI = -1;\n    let colsI = -1;\n    for(let i=0;i<this.length;i++) {\n        let tempCnt = i % (colsCount + 1);\n        (tempCnt == 0) && colsI++;\n        rowsI = tempCnt;\n        arr[rowsI][colsI] = this[i];\n    }\n    return arr;\n}`\n\n"
                    },
                    {
                        "username": "AnuragChauhan02",
                        "content": "[@gyanendra2058](/gyanendra2058) In local execution|debugging is working fine, and result is also as per expectation."
                    },
                    {
                        "username": "gyanendra2058",
                        "content": "May be  this line is culprit  arr[rowsI][colsI] = this[i]; Try debugging it\\n"
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The error messages are trash."
                    },
                    {
                        "username": "cionx",
                        "content": "This seems to be basically the same as [Problem 6](https://leetcode.com/problems/zigzag-conversion/) (Zigzag Conversion)."
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "tbh they are very different, this is what asked exactly at Faang as snail traversal: https://www.frontendinterviewhandbook.com/companies/google-front-end-interview-questions"
                    }
                ]
            }
        ]
    }
]